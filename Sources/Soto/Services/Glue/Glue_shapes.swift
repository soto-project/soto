//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Glue {
    // MARK: Enums

    public enum AdditionalOptionKeys: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cacheOption = "performanceTuning.caching"
        case observationsOption = "observations.scope"
        public var description: String { return self.rawValue }
    }

    public enum AggFunction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avg = "avg"
        case count = "count"
        case countDistinct = "countDistinct"
        case first = "first"
        case kurtosis = "kurtosis"
        case last = "last"
        case max = "max"
        case min = "min"
        case skewness = "skewness"
        case stddevPop = "stddev_pop"
        case stddevSamp = "stddev_samp"
        case sum = "sum"
        case sumDistinct = "sumDistinct"
        case varPop = "var_pop"
        case varSamp = "var_samp"
        public var description: String { return self.rawValue }
    }

    public enum AllowFullTableExternalDataAccessEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `false` = "False"
        case `true` = "True"
        public var description: String { return self.rawValue }
    }

    public enum AuthenticationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case custom = "CUSTOM"
        case iam = "IAM"
        case oauth2 = "OAUTH2"
        public var description: String { return self.rawValue }
    }

    public enum BackfillErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case encryptedPartitionError = "ENCRYPTED_PARTITION_ERROR"
        case internalError = "INTERNAL_ERROR"
        case invalidPartitionTypeDataError = "INVALID_PARTITION_TYPE_DATA_ERROR"
        case missingPartitionValueError = "MISSING_PARTITION_VALUE_ERROR"
        case unsupportedPartitionCharacterError = "UNSUPPORTED_PARTITION_CHARACTER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum BlueprintRunState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case rollingBack = "ROLLING_BACK"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum BlueprintStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum CatalogEncryptionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case ssekms = "SSE-KMS"
        case ssekmswithservicerole = "SSE-KMS-WITH-SERVICE-ROLE"
        public var description: String { return self.rawValue }
    }

    public enum CloudWatchEncryptionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case ssekms = "SSE-KMS"
        public var description: String { return self.rawValue }
    }

    public enum ColumnStatisticsState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ColumnStatisticsType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case binary = "BINARY"
        case boolean = "BOOLEAN"
        case date = "DATE"
        case decimal = "DECIMAL"
        case double = "DOUBLE"
        case long = "LONG"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum Comparator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanEquals = "GREATER_THAN_EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanEquals = "LESS_THAN_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum Compatibility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backward = "BACKWARD"
        case backwardAll = "BACKWARD_ALL"
        case disabled = "DISABLED"
        case forward = "FORWARD"
        case forwardAll = "FORWARD_ALL"
        case full = "FULL"
        case fullAll = "FULL_ALL"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum CompressionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bzip2 = "bzip2"
        case gzip = "gzip"
        public var description: String { return self.rawValue }
    }

    public enum ComputationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case full = "FULL"
        case incremental = "INCREMENTAL"
        public var description: String { return self.rawValue }
    }

    public enum ComputeEnvironment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case athena = "ATHENA"
        case python = "PYTHON"
        case spark = "SPARK"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionPropertyKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case clusterIdentifier = "CLUSTER_IDENTIFIER"
        case configFiles = "CONFIG_FILES"
        case connectionUrl = "CONNECTION_URL"
        case connectorClassName = "CONNECTOR_CLASS_NAME"
        case connectorType = "CONNECTOR_TYPE"
        case connectorUrl = "CONNECTOR_URL"
        case customJdbcCert = "CUSTOM_JDBC_CERT"
        case customJdbcCertString = "CUSTOM_JDBC_CERT_STRING"
        case database = "DATABASE"
        case encryptedKafkaClientKeyPassword = "ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"
        case encryptedKafkaClientKeystorePassword = "ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"
        case encryptedKafkaSaslPlainPassword = "ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD"
        case encryptedKafkaSaslScramPassword = "ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD"
        case encryptedPassword = "ENCRYPTED_PASSWORD"
        case endpoint = "ENDPOINT"
        case endpointType = "ENDPOINT_TYPE"
        case host = "HOST"
        case instanceId = "INSTANCE_ID"
        case jdbcConnectionUrl = "JDBC_CONNECTION_URL"
        case jdbcDriverClassName = "JDBC_DRIVER_CLASS_NAME"
        case jdbcDriverJarUri = "JDBC_DRIVER_JAR_URI"
        case jdbcEnforceSsl = "JDBC_ENFORCE_SSL"
        case jdbcEngine = "JDBC_ENGINE"
        case jdbcEngineVersion = "JDBC_ENGINE_VERSION"
        case kafkaBootstrapServers = "KAFKA_BOOTSTRAP_SERVERS"
        case kafkaClientKeyPassword = "KAFKA_CLIENT_KEY_PASSWORD"
        case kafkaClientKeystore = "KAFKA_CLIENT_KEYSTORE"
        case kafkaClientKeystorePassword = "KAFKA_CLIENT_KEYSTORE_PASSWORD"
        case kafkaCustomCert = "KAFKA_CUSTOM_CERT"
        case kafkaSaslGssapiKeytab = "KAFKA_SASL_GSSAPI_KEYTAB"
        case kafkaSaslGssapiKrb5Conf = "KAFKA_SASL_GSSAPI_KRB5_CONF"
        case kafkaSaslGssapiPrincipal = "KAFKA_SASL_GSSAPI_PRINCIPAL"
        case kafkaSaslGssapiService = "KAFKA_SASL_GSSAPI_SERVICE"
        case kafkaSaslMechanism = "KAFKA_SASL_MECHANISM"
        case kafkaSaslPlainPassword = "KAFKA_SASL_PLAIN_PASSWORD"
        case kafkaSaslPlainUsername = "KAFKA_SASL_PLAIN_USERNAME"
        case kafkaSaslScramPassword = "KAFKA_SASL_SCRAM_PASSWORD"
        case kafkaSaslScramSecretsArn = "KAFKA_SASL_SCRAM_SECRETS_ARN"
        case kafkaSaslScramUsername = "KAFKA_SASL_SCRAM_USERNAME"
        case kafkaSkipCustomCertValidation = "KAFKA_SKIP_CUSTOM_CERT_VALIDATION"
        case kafkaSslEnabled = "KAFKA_SSL_ENABLED"
        case password = "PASSWORD"
        case port = "PORT"
        case region = "REGION"
        case roleArn = "ROLE_ARN"
        case secretId = "SECRET_ID"
        case skipCustomJdbcCertValidation = "SKIP_CUSTOM_JDBC_CERT_VALIDATION"
        case userName = "USERNAME"
        case workgroupName = "WORKGROUP_NAME"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case facebookads = "FACEBOOKADS"
        case googleads = "GOOGLEADS"
        case googleanalytics4 = "GOOGLEANALYTICS4"
        case googlesheets = "GOOGLESHEETS"
        case hubspot = "HUBSPOT"
        case instagramads = "INSTAGRAMADS"
        case intercom = "INTERCOM"
        case jdbc = "JDBC"
        case jiracloud = "JIRACLOUD"
        case kafka = "KAFKA"
        case marketo = "MARKETO"
        case marketplace = "MARKETPLACE"
        case mongodb = "MONGODB"
        case netsuiteerp = "NETSUITEERP"
        case network = "NETWORK"
        case salesforce = "SALESFORCE"
        case salesforcemarketingcloud = "SALESFORCEMARKETINGCLOUD"
        case salesforcepardot = "SALESFORCEPARDOT"
        case sapodata = "SAPODATA"
        case servicenow = "SERVICENOW"
        case sftp = "SFTP"
        case slack = "SLACK"
        case snapchatads = "SNAPCHATADS"
        case stripe = "STRIPE"
        case viewValidationAthena = "VIEW_VALIDATION_ATHENA"
        case viewValidationRedshift = "VIEW_VALIDATION_REDSHIFT"
        case zendesk = "ZENDESK"
        case zohocrm = "ZOHOCRM"
        public var description: String { return self.rawValue }
    }

    public enum CrawlState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case error = "ERROR"
        case failed = "FAILED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum CrawlerHistoryState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case running = "RUNNING"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum CrawlerLineageSettings: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disable = "DISABLE"
        case enable = "ENABLE"
        public var description: String { return self.rawValue }
    }

    public enum CrawlerState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ready = "READY"
        case running = "RUNNING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum CsvHeaderOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case absent = "ABSENT"
        case present = "PRESENT"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum CsvSerdeOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lazySimpleSerDe = "LazySimpleSerDe"
        case none = "None"
        case openCSVSerDe = "OpenCSVSerDe"
        public var description: String { return self.rawValue }
    }

    public enum DQCompositeRuleEvaluationMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case column = "COLUMN"
        case row = "ROW"
        public var description: String { return self.rawValue }
    }

    public enum DQStopJobOnFailureTiming: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case afterDataLoad = "AfterDataLoad"
        case immediate = "Immediate"
        public var description: String { return self.rawValue }
    }

    public enum DQTransformOutput: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case evaluationResults = "EvaluationResults"
        case primaryInput = "PrimaryInput"
        public var description: String { return self.rawValue }
    }

    public enum DataFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avro = "AVRO"
        case json = "JSON"
        case protobuf = "PROTOBUF"
        public var description: String { return self.rawValue }
    }

    public enum DataOperation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case read = "READ"
        case write = "WRITE"
        public var description: String { return self.rawValue }
    }

    public enum DataQualityEncryptionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case ssekms = "SSE-KMS"
        public var description: String { return self.rawValue }
    }

    public enum DataQualityModelStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum DataQualityRuleResultStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case fail = "FAIL"
        case pass = "PASS"
        public var description: String { return self.rawValue }
    }

    public enum DatabaseAttributes: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum DeleteBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleteFromDatabase = "DELETE_FROM_DATABASE"
        case deprecateInDatabase = "DEPRECATE_IN_DATABASE"
        case log = "LOG"
        public var description: String { return self.rawValue }
    }

    public enum DeltaTargetCompressionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case snappy = "snappy"
        case uncompressed = "uncompressed"
        public var description: String { return self.rawValue }
    }

    public enum EnableHybridValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `false` = "FALSE"
        case `true` = "TRUE"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case flex = "FLEX"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case started = "STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ExistCondition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mustExist = "MUST_EXIST"
        case none = "NONE"
        case notExist = "NOT_EXIST"
        public var description: String { return self.rawValue }
    }

    public enum FederationSourceErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "AccessDeniedException"
        case entityNotFoundException = "EntityNotFoundException"
        case internalServiceException = "InternalServiceException"
        case invalidCredentialsException = "InvalidCredentialsException"
        case invalidInputException = "InvalidInputException"
        case invalidResponseException = "InvalidResponseException"
        case operationNotSupportedException = "OperationNotSupportedException"
        case operationTimeoutException = "OperationTimeoutException"
        case partialFailureException = "PartialFailureException"
        case throttlingException = "ThrottlingException"
        public var description: String { return self.rawValue }
    }

    public enum FieldDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `struct` = "STRUCT"
        case array = "ARRAY"
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case byte = "BYTE"
        case date = "DATE"
        case decimal = "DECIMAL"
        case double = "DOUBLE"
        case float = "FLOAT"
        case int = "INT"
        case long = "LONG"
        case map = "MAP"
        case short = "SHORT"
        case smallint = "SMALLINT"
        case string = "STRING"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum FieldFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case notEqualTo = "NOT_EQUAL_TO"
        case orderBy = "ORDER_BY"
        public var description: String { return self.rawValue }
    }

    public enum FieldName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case crawlId = "CRAWL_ID"
        case dpuHour = "DPU_HOUR"
        case endTime = "END_TIME"
        case startTime = "START_TIME"
        case state = "STATE"
        public var description: String { return self.rawValue }
    }

    public enum FilterLogicalOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case and = "AND"
        case or = "OR"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eq = "EQ"
        case gt = "GT"
        case gte = "GTE"
        case isnull = "ISNULL"
        case lt = "LT"
        case lte = "LTE"
        case regex = "REGEX"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eq = "EQ"
        case ge = "GE"
        case gt = "GT"
        case le = "LE"
        case lt = "LT"
        case ne = "NE"
        public var description: String { return self.rawValue }
    }

    public enum FilterValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case columnextracted = "COLUMNEXTRACTED"
        case constant = "CONSTANT"
        public var description: String { return self.rawValue }
    }

    public enum GlueRecordType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigdecimal = "BIGDECIMAL"
        case byte = "BYTE"
        case date = "DATE"
        case double = "DOUBLE"
        case float = "FLOAT"
        case int = "INT"
        case long = "LONG"
        case short = "SHORT"
        case string = "STRING"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum HudiTargetCompressionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gzip = "gzip"
        case lzo = "lzo"
        case snappy = "snappy"
        case uncompressed = "uncompressed"
        public var description: String { return self.rawValue }
    }

    public enum InclusionAnnotationValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exclude = "EXCLUDE"
        case include = "INCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum IntegrationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case modifying = "MODIFYING"
        case needsAttention = "NEEDS_ATTENTION"
        case syncing = "SYNCING"
        public var description: String { return self.rawValue }
    }

    public enum JDBCConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mysql = "mysql"
        case oracle = "oracle"
        case postgresql = "postgresql"
        case redshift = "redshift"
        case sqlserver = "sqlserver"
        public var description: String { return self.rawValue }
    }

    public enum JDBCDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `struct` = "STRUCT"
        case array = "ARRAY"
        case bigint = "BIGINT"
        case binary = "BINARY"
        case bit = "BIT"
        case blob = "BLOB"
        case boolean = "BOOLEAN"
        case char = "CHAR"
        case clob = "CLOB"
        case datalink = "DATALINK"
        case date = "DATE"
        case decimal = "DECIMAL"
        case distinct = "DISTINCT"
        case double = "DOUBLE"
        case float = "FLOAT"
        case integer = "INTEGER"
        case javaObject = "JAVA_OBJECT"
        case longnvarchar = "LONGNVARCHAR"
        case longvarbinary = "LONGVARBINARY"
        case longvarchar = "LONGVARCHAR"
        case nchar = "NCHAR"
        case nclob = "NCLOB"
        case null = "NULL"
        case numeric = "NUMERIC"
        case nvarchar = "NVARCHAR"
        case other = "OTHER"
        case real = "REAL"
        case ref = "REF"
        case refCursor = "REF_CURSOR"
        case rowid = "ROWID"
        case smallint = "SMALLINT"
        case sqlxml = "SQLXML"
        case time = "TIME"
        case timeWithTimezone = "TIME_WITH_TIMEZONE"
        case timestamp = "TIMESTAMP"
        case timestampWithTimezone = "TIMESTAMP_WITH_TIMEZONE"
        case tinyint = "TINYINT"
        case varbinary = "VARBINARY"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum JdbcMetadataEntry: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case comments = "COMMENTS"
        case rawtypes = "RAWTYPES"
        public var description: String { return self.rawValue }
    }

    public enum JobBookmarksEncryptionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csekms = "CSE-KMS"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum JobMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notebook = "NOTEBOOK"
        case script = "SCRIPT"
        case visual = "VISUAL"
        public var description: String { return self.rawValue }
    }

    public enum JobRunState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case expired = "EXPIRED"
        case failed = "FAILED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case succeeded = "SUCCEEDED"
        case timeout = "TIMEOUT"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum JoinType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equijoin = "equijoin"
        case left = "left"
        case leftAnti = "leftanti"
        case leftSemi = "leftsemi"
        case outer = "outer"
        case right = "right"
        public var description: String { return self.rawValue }
    }

    public enum Language: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case python = "PYTHON"
        case scala = "SCALA"
        public var description: String { return self.rawValue }
    }

    public enum LastCrawlStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case failed = "FAILED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum Logical: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case and = "AND"
        case any = "ANY"
        public var description: String { return self.rawValue }
    }

    public enum LogicalOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum MLUserDataEncryptionModeString: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case ssekms = "SSE-KMS"
        public var description: String { return self.rawValue }
    }

    public enum MetadataOperation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case create = "CREATE"
        public var description: String { return self.rawValue }
    }

    public enum NodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case crawler = "CRAWLER"
        case job = "JOB"
        case trigger = "TRIGGER"
        public var description: String { return self.rawValue }
    }

    public enum OAuth2GrantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case authorizationCode = "AUTHORIZATION_CODE"
        case clientCredentials = "CLIENT_CREDENTIALS"
        case jwtBearer = "JWT_BEARER"
        public var description: String { return self.rawValue }
    }

    public enum ParamType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bool = "bool"
        case complex = "complex"
        case float = "float"
        case int = "int"
        case list = "list"
        case null = "null"
        case str = "str"
        public var description: String { return self.rawValue }
    }

    public enum ParquetCompressionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gzip = "gzip"
        case lzo = "lzo"
        case none = "none"
        case snappy = "snappy"
        case uncompressed = "uncompressed"
        public var description: String { return self.rawValue }
    }

    public enum PartitionIndexStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum Permission: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case alter = "ALTER"
        case createDatabase = "CREATE_DATABASE"
        case createTable = "CREATE_TABLE"
        case dataLocationAccess = "DATA_LOCATION_ACCESS"
        case delete = "DELETE"
        case drop = "DROP"
        case insert = "INSERT"
        case select = "SELECT"
        public var description: String { return self.rawValue }
    }

    public enum PermissionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cellFilterPermission = "CELL_FILTER_PERMISSION"
        case columnPermission = "COLUMN_PERMISSION"
        case nestedCellPermission = "NESTED_CELL_PERMISSION"
        case nestedPermission = "NESTED_PERMISSION"
        public var description: String { return self.rawValue }
    }

    public enum PiiType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case columnAudit = "ColumnAudit"
        case columnMasking = "ColumnMasking"
        case rowAudit = "RowAudit"
        case rowMasking = "RowMasking"
        public var description: String { return self.rawValue }
    }

    public enum PrincipalType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case group = "GROUP"
        case role = "ROLE"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum PropertyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case readOnly = "READ_ONLY"
        case secret = "SECRET"
        case secretOrUserInput = "SECRET_OR_USER_INPUT"
        case unused = "UNUSED"
        case userInput = "USER_INPUT"
        public var description: String { return self.rawValue }
    }

    public enum QuoteChar: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case quillemet = "quillemet"
        case quote = "quote"
        case singleQuote = "single_quote"
        public var description: String { return self.rawValue }
    }

    public enum RecrawlBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case crawlEventMode = "CRAWL_EVENT_MODE"
        case crawlEverything = "CRAWL_EVERYTHING"
        case crawlNewFoldersOnly = "CRAWL_NEW_FOLDERS_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum RegistryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ResourceAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case create = "CREATE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceShareType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case federated = "FEDERATED"
        case foreign = "FOREIGN"
        public var description: String { return self.rawValue }
    }

    public enum ResourceState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case queued = "QUEUED"
        case stopped = "STOPPED"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case archive = "ARCHIVE"
        case file = "FILE"
        case jar = "JAR"
        public var description: String { return self.rawValue }
    }

    public enum S3EncryptionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case ssekms = "SSE-KMS"
        case sses3 = "SSE-S3"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notScheduled = "NOT_SCHEDULED"
        case scheduled = "SCHEDULED"
        case transitioning = "TRANSITIONING"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case cron = "CRON"
        public var description: String { return self.rawValue }
    }

    public enum SchemaDiffType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case syntaxDiff = "SYNTAX_DIFF"
        public var description: String { return self.rawValue }
    }

    public enum SchemaStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case failure = "FAILURE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum Separator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case comma = "comma"
        case ctrla = "ctrla"
        case pipe = "pipe"
        case semicolon = "semicolon"
        case tab = "tab"
        public var description: String { return self.rawValue }
    }

    public enum SessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case provisioning = "PROVISIONING"
        case ready = "READY"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public enum SettingSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case catalog = "CATALOG"
        case table = "TABLE"
        public var description: String { return self.rawValue }
    }

    public enum Sort: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASC"
        case descending = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum SortDirectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum SourceControlAuthStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsSecretsManager = "AWS_SECRETS_MANAGER"
        case personalAccessToken = "PERSONAL_ACCESS_TOKEN"
        public var description: String { return self.rawValue }
    }

    public enum SourceControlProvider: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsCodeCommit = "AWS_CODE_COMMIT"
        case bitbucket = "BITBUCKET"
        case github = "GITHUB"
        case gitlab = "GITLAB"
        public var description: String { return self.rawValue }
    }

    public enum StartingPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case earliest = "earliest"
        case latest = "latest"
        case timestamp = "timestamp"
        case trimHorizon = "trim_horizon"
        public var description: String { return self.rawValue }
    }

    public enum StatementState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case error = "ERROR"
        case running = "RUNNING"
        case waiting = "WAITING"
        public var description: String { return self.rawValue }
    }

    public enum StatisticEvaluationLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case column = "Column"
        case dataset = "Dataset"
        case multicolumn = "Multicolumn"
        public var description: String { return self.rawValue }
    }

    public enum TableAttributes: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        case tableType = "TABLE_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum TableOptimizerEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "completed"
        case failed = "failed"
        case inProgress = "in_progress"
        case starting = "starting"
        public var description: String { return self.rawValue }
    }

    public enum TableOptimizerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compaction = "compaction"
        case orphanFileDeletion = "orphan_file_deletion"
        case retention = "retention"
        public var description: String { return self.rawValue }
    }

    public enum TargetFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avro = "avro"
        case csv = "csv"
        case delta = "delta"
        case hudi = "hudi"
        case json = "json"
        case orc = "orc"
        case parquet = "parquet"
        public var description: String { return self.rawValue }
    }

    public enum TaskRunSortColumnType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case started = "STARTED"
        case status = "STATUS"
        case taskRunType = "TASK_RUN_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum TaskStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case succeeded = "SUCCEEDED"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public enum TaskType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case evaluation = "EVALUATION"
        case exportLabels = "EXPORT_LABELS"
        case findMatches = "FIND_MATCHES"
        case importLabels = "IMPORT_LABELS"
        case labelingSetGeneration = "LABELING_SET_GENERATION"
        public var description: String { return self.rawValue }
    }

    public enum TransformSortColumnType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case lastModified = "LAST_MODIFIED"
        case name = "NAME"
        case status = "STATUS"
        case transformType = "TRANSFORM_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum TransformStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "DELETING"
        case notReady = "NOT_READY"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum TransformType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case findMatches = "FIND_MATCHES"
        public var description: String { return self.rawValue }
    }

    public enum TriggerState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activated = "ACTIVATED"
        case activating = "ACTIVATING"
        case created = "CREATED"
        case creating = "CREATING"
        case deactivated = "DEACTIVATED"
        case deactivating = "DEACTIVATING"
        case deleting = "DELETING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum TriggerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case conditional = "CONDITIONAL"
        case event = "EVENT"
        case onDemand = "ON_DEMAND"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum UnionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case distinct = "DISTINCT"
        public var description: String { return self.rawValue }
    }

    public enum UnnestSpec: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case full = "FULL"
        case nounnest = "NOUNNEST"
        case toplevel = "TOPLEVEL"
        public var description: String { return self.rawValue }
    }

    public enum UpdateBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case log = "LOG"
        case updateInDatabase = "UPDATE_IN_DATABASE"
        public var description: String { return self.rawValue }
    }

    public enum UpdateCatalogBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case log = "LOG"
        case updateInDatabase = "UPDATE_IN_DATABASE"
        public var description: String { return self.rawValue }
    }

    public enum ViewDialect: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case athena = "ATHENA"
        case redshift = "REDSHIFT"
        case spark = "SPARK"
        public var description: String { return self.rawValue }
    }

    public enum ViewUpdateAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case add = "ADD"
        case addOrReplace = "ADD_OR_REPLACE"
        case drop = "DROP"
        case replace = "REPLACE"
        public var description: String { return self.rawValue }
    }

    public enum WorkerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case g025X = "G.025X"
        case g1X = "G.1X"
        case g2X = "G.2X"
        case g4X = "G.4X"
        case g8X = "G.8X"
        case standard = "Standard"
        case z2X = "Z.2X"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case error = "ERROR"
        case running = "RUNNING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the key-value pairs that Glue consumes to set up your job, see the Special Parameters Used by Glue topic in the developer guide.
        public let arguments: [String: String]?
        /// The name of the crawler to be used with this action.
        public let crawlerName: String?
        /// The name of a job to be run.
        public let jobName: String?
        /// Specifies configuration properties of a job run notification.
        public let notificationProperty: NotificationProperty?
        /// The name of the SecurityConfiguration structure to be used with this action.
        public let securityConfiguration: String?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. This overrides the timeout value set in the parent job. Jobs must have timeout values less than 7 days or 10080 minutes. Otherwise, the jobs will throw an exception. When the value is left blank, the timeout is defaulted to 2880 minutes. Any existing Glue jobs that had a timeout value greater than 7 days will be defaulted to 7 days. For instance if you have specified a timeout of 20 days for a batch job, it will be stopped on the 7th day. For streaming jobs, if you have set up a maintenance window, it will be restarted during the maintenance window after 7 days.
        public let timeout: Int?

        @inlinable
        public init(arguments: [String: String]? = nil, crawlerName: String? = nil, jobName: String? = nil, notificationProperty: NotificationProperty? = nil, securityConfiguration: String? = nil, timeout: Int? = nil) {
            self.arguments = arguments
            self.crawlerName = crawlerName
            self.jobName = jobName
            self.notificationProperty = notificationProperty
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.notificationProperty?.validate(name: "\(name).notificationProperty")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case crawlerName = "CrawlerName"
            case jobName = "JobName"
            case notificationProperty = "NotificationProperty"
            case securityConfiguration = "SecurityConfiguration"
            case timeout = "Timeout"
        }
    }

    public struct Aggregate: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the aggregate functions to be performed on specified fields.
        public let aggs: [AggregateOperation]
        /// Specifies the fields to group by.
        public let groups: [[String]]
        /// Specifies the fields and rows to use as inputs for the aggregate transform.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String

        @inlinable
        public init(aggs: [AggregateOperation], groups: [[String]], inputs: [String], name: String) {
            self.aggs = aggs
            self.groups = groups
            self.inputs = inputs
            self.name = name
        }

        public func validate(name: String) throws {
            try self.aggs.forEach {
                try $0.validate(name: "\(name).aggs[]")
            }
            try self.validate(self.aggs, name: "aggs", parent: name, max: 30)
            try self.validate(self.aggs, name: "aggs", parent: name, min: 1)
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggs = "Aggs"
            case groups = "Groups"
            case inputs = "Inputs"
            case name = "Name"
        }
    }

    public struct AggregateOperation: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the aggregation function to apply. Possible aggregation functions include: avg countDistinct, count, first, last, kurtosis, max, min, skewness,  stddev_samp, stddev_pop, sum, sumDistinct, var_samp, var_pop
        public let aggFunc: AggFunction
        /// Specifies the column on the data set on which the aggregation function will be applied.
        public let column: [String]

        @inlinable
        public init(aggFunc: AggFunction, column: [String]) {
            self.aggFunc = aggFunc
            self.column = column
        }

        public func validate(name: String) throws {
            try self.column.forEach {
                try validate($0, name: "column[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aggFunc = "AggFunc"
            case column = "Column"
        }
    }

    public struct AllowedValue: AWSDecodableShape {
        /// A description of the allowed value.
        public let description: String?
        /// The value allowed for the property.
        public let value: String

        @inlinable
        public init(description: String? = nil, value: String) {
            self.description = description
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case value = "Value"
        }
    }

    public struct AmazonRedshiftAdvancedOption: AWSEncodableShape & AWSDecodableShape {
        /// The key for the additional connection option.
        public let key: String?
        /// The value for the additional connection option.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct AmazonRedshiftNodeData: AWSEncodableShape & AWSDecodableShape {
        /// The access type for the Redshift connection. Can be a direct connection or catalog connections.
        public let accessType: String?
        /// Specifies how writing to a Redshift cluser will occur.
        public let action: String?
        /// Optional values when connecting to the Redshift cluster.
        public let advancedOptions: [AmazonRedshiftAdvancedOption]?
        /// The name of the Glue Data Catalog database when working with a data catalog.
        public let catalogDatabase: Option?
        /// The Redshift schema name when working with a data catalog.
        public let catalogRedshiftSchema: String?
        /// The database table to read from.
        public let catalogRedshiftTable: String?
        /// The Glue Data Catalog table name when working with a data catalog.
        public let catalogTable: Option?
        /// The Glue connection to the Redshift cluster.
        public let connection: Option?
        /// Specifies the name of the connection that is associated with the catalog table used.
        public let crawlerConnection: String?
        /// Optional. The role name use when connection to S3. The IAM role ill default to the role on the job when left blank.
        public let iamRole: Option?
        /// The action used when to detemine how a MERGE in a Redshift sink will be handled.
        public let mergeAction: String?
        /// The SQL used in a custom merge to deal with matching records.
        public let mergeClause: String?
        /// The action used when to detemine how a MERGE in a Redshift sink will be handled when an existing record matches a new record.
        public let mergeWhenMatched: String?
        /// The action used when to detemine how a MERGE in a Redshift sink will be handled when an existing record doesn't match a new record.
        public let mergeWhenNotMatched: String?
        /// The SQL used before a MERGE or APPEND with upsert is run.
        public let postAction: String?
        /// The SQL used before a MERGE or APPEND with upsert is run.
        public let preAction: String?
        /// The SQL used to fetch the data from a Redshift sources when the SourceType is 'query'.
        public let sampleQuery: String?
        /// The Redshift schema name when working with a direct connection.
        public let schema: Option?
        /// The list of column names used to determine a matching record when doing a MERGE or APPEND with upsert.
        public let selectedColumns: [Option]?
        /// The source type to specify whether a specific table is the source or a custom query.
        public let sourceType: String?
        /// The name of the temporary staging table that is used when doing a MERGE or APPEND with upsert.
        public let stagingTable: String?
        /// The Redshift table name when working with a direct connection.
        public let table: Option?
        /// Specifies the prefix to a table.
        public let tablePrefix: String?
        /// The array of schema output for a given node.
        public let tableSchema: [Option]?
        /// The Amazon S3 path where temporary data can be staged when copying out of the database.
        public let tempDir: String?
        /// The action used on Redshift sinks when doing an APPEND.
        public let upsert: Bool?

        @inlinable
        public init(accessType: String? = nil, action: String? = nil, advancedOptions: [AmazonRedshiftAdvancedOption]? = nil, catalogDatabase: Option? = nil, catalogRedshiftSchema: String? = nil, catalogRedshiftTable: String? = nil, catalogTable: Option? = nil, connection: Option? = nil, crawlerConnection: String? = nil, iamRole: Option? = nil, mergeAction: String? = nil, mergeClause: String? = nil, mergeWhenMatched: String? = nil, mergeWhenNotMatched: String? = nil, postAction: String? = nil, preAction: String? = nil, sampleQuery: String? = nil, schema: Option? = nil, selectedColumns: [Option]? = nil, sourceType: String? = nil, stagingTable: String? = nil, table: Option? = nil, tablePrefix: String? = nil, tableSchema: [Option]? = nil, tempDir: String? = nil, upsert: Bool? = nil) {
            self.accessType = accessType
            self.action = action
            self.advancedOptions = advancedOptions
            self.catalogDatabase = catalogDatabase
            self.catalogRedshiftSchema = catalogRedshiftSchema
            self.catalogRedshiftTable = catalogRedshiftTable
            self.catalogTable = catalogTable
            self.connection = connection
            self.crawlerConnection = crawlerConnection
            self.iamRole = iamRole
            self.mergeAction = mergeAction
            self.mergeClause = mergeClause
            self.mergeWhenMatched = mergeWhenMatched
            self.mergeWhenNotMatched = mergeWhenNotMatched
            self.postAction = postAction
            self.preAction = preAction
            self.sampleQuery = sampleQuery
            self.schema = schema
            self.selectedColumns = selectedColumns
            self.sourceType = sourceType
            self.stagingTable = stagingTable
            self.table = table
            self.tablePrefix = tablePrefix
            self.tableSchema = tableSchema
            self.tempDir = tempDir
            self.upsert = upsert
        }

        public func validate(name: String) throws {
            try self.validate(self.accessType, name: "accessType", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.catalogDatabase?.validate(name: "\(name).catalogDatabase")
            try self.catalogTable?.validate(name: "\(name).catalogTable")
            try self.connection?.validate(name: "\(name).connection")
            try self.iamRole?.validate(name: "\(name).iamRole")
            try self.validate(self.mergeAction, name: "mergeAction", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.validate(self.mergeWhenMatched, name: "mergeWhenMatched", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.validate(self.mergeWhenNotMatched, name: "mergeWhenNotMatched", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.schema?.validate(name: "\(name).schema")
            try self.selectedColumns?.forEach {
                try $0.validate(name: "\(name).selectedColumns[]")
            }
            try self.validate(self.sourceType, name: "sourceType", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.table?.validate(name: "\(name).table")
            try self.validate(self.tablePrefix, name: "tablePrefix", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.tableSchema?.forEach {
                try $0.validate(name: "\(name).tableSchema[]")
            }
            try self.validate(self.tempDir, name: "tempDir", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessType = "AccessType"
            case action = "Action"
            case advancedOptions = "AdvancedOptions"
            case catalogDatabase = "CatalogDatabase"
            case catalogRedshiftSchema = "CatalogRedshiftSchema"
            case catalogRedshiftTable = "CatalogRedshiftTable"
            case catalogTable = "CatalogTable"
            case connection = "Connection"
            case crawlerConnection = "CrawlerConnection"
            case iamRole = "IamRole"
            case mergeAction = "MergeAction"
            case mergeClause = "MergeClause"
            case mergeWhenMatched = "MergeWhenMatched"
            case mergeWhenNotMatched = "MergeWhenNotMatched"
            case postAction = "PostAction"
            case preAction = "PreAction"
            case sampleQuery = "SampleQuery"
            case schema = "Schema"
            case selectedColumns = "SelectedColumns"
            case sourceType = "SourceType"
            case stagingTable = "StagingTable"
            case table = "Table"
            case tablePrefix = "TablePrefix"
            case tableSchema = "TableSchema"
            case tempDir = "TempDir"
            case upsert = "Upsert"
        }
    }

    public struct AmazonRedshiftSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the data of the Amazon Reshift source node.
        public let data: AmazonRedshiftNodeData?
        /// The name of the Amazon Redshift source.
        public let name: String?

        @inlinable
        public init(data: AmazonRedshiftNodeData? = nil, name: String? = nil) {
            self.data = data
            self.name = name
        }

        public func validate(name: String) throws {
            try self.data?.validate(name: "\(name).data")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
            case name = "Name"
        }
    }

    public struct AmazonRedshiftTarget: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the data of the Amazon Redshift target node.
        public let data: AmazonRedshiftNodeData?
        /// The nodes that are inputs to the data target.
        public let inputs: [String]?
        /// The name of the Amazon Redshift target.
        public let name: String?

        @inlinable
        public init(data: AmazonRedshiftNodeData? = nil, inputs: [String]? = nil, name: String? = nil) {
            self.data = data
            self.inputs = inputs
            self.name = name
        }

        public func validate(name: String) throws {
            try self.data?.validate(name: "\(name).data")
            try self.inputs?.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
            case inputs = "Inputs"
            case name = "Name"
        }
    }

    public struct AnnotationError: AWSDecodableShape {
        /// The reason why the annotation failed.
        public let failureReason: String?
        /// The Profile ID for the failed annotation.
        public let profileId: String?
        /// The Statistic ID for the failed annotation.
        public let statisticId: String?

        @inlinable
        public init(failureReason: String? = nil, profileId: String? = nil, statisticId: String? = nil) {
            self.failureReason = failureReason
            self.profileId = profileId
            self.statisticId = statisticId
        }

        private enum CodingKeys: String, CodingKey {
            case failureReason = "FailureReason"
            case profileId = "ProfileId"
            case statisticId = "StatisticId"
        }
    }

    public struct ApplyMapping: AWSEncodableShape & AWSDecodableShape {
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// Specifies the mapping of data property keys in the data source to data property keys in the data target.
        public let mapping: [Mapping]
        /// The name of the transform node.
        public let name: String

        @inlinable
        public init(inputs: [String], mapping: [Mapping], name: String) {
            self.inputs = inputs
            self.mapping = mapping
            self.name = name
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.mapping.forEach {
                try $0.validate(name: "\(name).mapping[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case mapping = "Mapping"
            case name = "Name"
        }
    }

    public struct AthenaConnectorSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection that is associated with the connector.
        public let connectionName: String
        /// The name of the table in the data source.
        public let connectionTable: String?
        /// The type of connection, such as marketplace.athena or custom.athena, designating a connection to an Amazon Athena data store.
        public let connectionType: String
        /// The name of a connector that assists with accessing the data store in Glue Studio.
        public let connectorName: String
        /// The name of the data source.
        public let name: String
        /// Specifies the data schema for the custom Athena source.
        public let outputSchemas: [GlueSchema]?
        /// The name of the Cloudwatch log group to read from. For example, /aws-glue/jobs/output.
        public let schemaName: String

        @inlinable
        public init(connectionName: String, connectionTable: String? = nil, connectionType: String, connectorName: String, name: String, outputSchemas: [GlueSchema]? = nil, schemaName: String) {
            self.connectionName = connectionName
            self.connectionTable = connectionTable
            self.connectionType = connectionType
            self.connectorName = connectorName
            self.name = name
            self.outputSchemas = outputSchemas
            self.schemaName = schemaName
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectionTable, name: "connectionTable", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectionType, name: "connectionType", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectorName, name: "connectorName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case connectionTable = "ConnectionTable"
            case connectionType = "ConnectionType"
            case connectorName = "ConnectorName"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case schemaName = "SchemaName"
        }
    }

    public struct AuditContext: AWSEncodableShape {
        /// A string containing the additional audit context information.
        public let additionalAuditContext: String?
        /// All columns request for audit.
        public let allColumnsRequested: Bool?
        /// The requested columns for audit.
        public let requestedColumns: [String]?

        @inlinable
        public init(additionalAuditContext: String? = nil, allColumnsRequested: Bool? = nil, requestedColumns: [String]? = nil) {
            self.additionalAuditContext = additionalAuditContext
            self.allColumnsRequested = allColumnsRequested
            self.requestedColumns = requestedColumns
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalAuditContext, name: "additionalAuditContext", parent: name, max: 2048)
            try self.requestedColumns?.forEach {
                try validate($0, name: "requestedColumns[]", parent: name, max: 1024)
                try validate($0, name: "requestedColumns[]", parent: name, min: 1)
                try validate($0, name: "requestedColumns[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAuditContext = "AdditionalAuditContext"
            case allColumnsRequested = "AllColumnsRequested"
            case requestedColumns = "RequestedColumns"
        }
    }

    public struct AuthConfiguration: AWSDecodableShape {
        /// The type of authentication for a connection.
        public let authenticationType: Property
        /// A map of key-value pairs for the OAuth2 properties. Each value is a a Property object.
        public let basicAuthenticationProperties: [String: Property]?
        /// A map of key-value pairs for the custom authentication properties. Each value is a a Property object.
        public let customAuthenticationProperties: [String: Property]?
        /// A map of key-value pairs for the OAuth2 properties. Each value is a a Property object.
        public let oAuth2Properties: [String: Property]?
        /// The Amazon Resource Name (ARN) for the Secrets Manager.
        public let secretArn: Property?

        @inlinable
        public init(authenticationType: Property, basicAuthenticationProperties: [String: Property]? = nil, customAuthenticationProperties: [String: Property]? = nil, oAuth2Properties: [String: Property]? = nil, secretArn: Property? = nil) {
            self.authenticationType = authenticationType
            self.basicAuthenticationProperties = basicAuthenticationProperties
            self.customAuthenticationProperties = customAuthenticationProperties
            self.oAuth2Properties = oAuth2Properties
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "AuthenticationType"
            case basicAuthenticationProperties = "BasicAuthenticationProperties"
            case customAuthenticationProperties = "CustomAuthenticationProperties"
            case oAuth2Properties = "OAuth2Properties"
            case secretArn = "SecretArn"
        }
    }

    public struct AuthenticationConfiguration: AWSDecodableShape {
        /// A structure containing the authentication configuration.
        public let authenticationType: AuthenticationType?
        /// The properties for OAuth2 authentication.
        public let oAuth2Properties: OAuth2Properties?
        /// The secret manager ARN to store credentials.
        public let secretArn: String?

        @inlinable
        public init(authenticationType: AuthenticationType? = nil, oAuth2Properties: OAuth2Properties? = nil, secretArn: String? = nil) {
            self.authenticationType = authenticationType
            self.oAuth2Properties = oAuth2Properties
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "AuthenticationType"
            case oAuth2Properties = "OAuth2Properties"
            case secretArn = "SecretArn"
        }
    }

    public struct AuthenticationConfigurationInput: AWSEncodableShape {
        /// A structure containing the authentication configuration in the CreateConnection request.
        public let authenticationType: AuthenticationType?
        /// The credentials used when the authentication type is basic authentication.
        public let basicAuthenticationCredentials: BasicAuthenticationCredentials?
        /// The credentials used when the authentication type is custom authentication.
        public let customAuthenticationCredentials: [String: String]?
        /// The ARN of the KMS key used to encrypt the connection. Only taken an as input in the request and stored in the Secret Manager.
        public let kmsKeyArn: String?
        /// The properties for OAuth2 authentication in the CreateConnection request.
        public let oAuth2Properties: OAuth2PropertiesInput?
        /// The secret manager ARN to store credentials in the CreateConnection request.
        public let secretArn: String?

        @inlinable
        public init(authenticationType: AuthenticationType? = nil, basicAuthenticationCredentials: BasicAuthenticationCredentials? = nil, customAuthenticationCredentials: [String: String]? = nil, kmsKeyArn: String? = nil, oAuth2Properties: OAuth2PropertiesInput? = nil, secretArn: String? = nil) {
            self.authenticationType = authenticationType
            self.basicAuthenticationCredentials = basicAuthenticationCredentials
            self.customAuthenticationCredentials = customAuthenticationCredentials
            self.kmsKeyArn = kmsKeyArn
            self.oAuth2Properties = oAuth2Properties
            self.secretArn = secretArn
        }

        public func validate(name: String) throws {
            try self.basicAuthenticationCredentials?.validate(name: "\(name).basicAuthenticationCredentials")
            try self.customAuthenticationCredentials?.forEach {
                try validate($0.key, name: "customAuthenticationCredentials.key", parent: name, max: 128)
                try validate($0.key, name: "customAuthenticationCredentials.key", parent: name, min: 1)
                try validate($0.value, name: "customAuthenticationCredentials[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "customAuthenticationCredentials[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:")
            try self.oAuth2Properties?.validate(name: "\(name).oAuth2Properties")
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:secretsmanager:.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "AuthenticationType"
            case basicAuthenticationCredentials = "BasicAuthenticationCredentials"
            case customAuthenticationCredentials = "CustomAuthenticationCredentials"
            case kmsKeyArn = "KmsKeyArn"
            case oAuth2Properties = "OAuth2Properties"
            case secretArn = "SecretArn"
        }
    }

    public struct AuthorizationCodeProperties: AWSEncodableShape {
        /// An authorization code to be used in the third leg of the AUTHORIZATION_CODE grant workflow. This is a single-use code which becomes invalid once exchanged for an access token, thus it is acceptable to have this value as a request parameter.
        public let authorizationCode: String?
        /// The redirect URI where the user gets redirected to by authorization server when issuing an authorization code. The URI is subsequently used when the authorization code is exchanged for an access token.
        public let redirectUri: String?

        @inlinable
        public init(authorizationCode: String? = nil, redirectUri: String? = nil) {
            self.authorizationCode = authorizationCode
            self.redirectUri = redirectUri
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizationCode, name: "authorizationCode", parent: name, max: 4096)
            try self.validate(self.authorizationCode, name: "authorizationCode", parent: name, min: 1)
            try self.validate(self.authorizationCode, name: "authorizationCode", parent: name, pattern: "^\\S+$")
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, max: 512)
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, pattern: "^(https?):\\/\\/[^\\s/$.?#].[^\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationCode = "AuthorizationCode"
            case redirectUri = "RedirectUri"
        }
    }

    public struct BackfillError: AWSDecodableShape {
        /// The error code for an error that occurred when registering partition indexes for an existing table.
        public let code: BackfillErrorCode?
        /// A list of a limited number of partitions in the response.
        public let partitions: [PartitionValueList]?

        @inlinable
        public init(code: BackfillErrorCode? = nil, partitions: [PartitionValueList]? = nil) {
            self.code = code
            self.partitions = partitions
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case partitions = "Partitions"
        }
    }

    public struct BasicAuthenticationCredentials: AWSEncodableShape {
        /// The password to connect to the data source.
        public let password: String?
        /// The username to connect to the data source.
        public let username: String?

        @inlinable
        public init(password: String? = nil, username: String? = nil) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 512)
            try self.validate(self.password, name: "password", parent: name, pattern: ".*")
            try self.validate(self.username, name: "username", parent: name, max: 512)
            try self.validate(self.username, name: "username", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case password = "Password"
            case username = "Username"
        }
    }

    public struct BasicCatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// The database that contains the table you want to use as the target. This database must already exist in the Data Catalog.
        public let database: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of your data target.
        public let name: String
        /// The partition keys used to distribute data across multiple partitions or shards based on a specific key or set of key.
        public let partitionKeys: [[String]]?
        /// The table that defines the schema of your output data. This table must already exist in the Data Catalog.
        public let table: String

        @inlinable
        public init(database: String, inputs: [String], name: String, partitionKeys: [[String]]? = nil, table: String) {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case inputs = "Inputs"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case table = "Table"
        }
    }

    public struct BatchCreatePartitionRequest: AWSEncodableShape {
        /// The ID of the catalog in which the partition is to be created. Currently, this should be the Amazon Web Services account ID.
        public let catalogId: String?
        /// The name of the metadata database in which the partition is to be created.
        public let databaseName: String
        /// A list of PartitionInput structures that define the partitions to be created.
        public let partitionInputList: [PartitionInput]
        /// The name of the metadata table in which the partition is to be created.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, partitionInputList: [PartitionInput], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionInputList = partitionInputList
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionInputList.forEach {
                try $0.validate(name: "\(name).partitionInputList[]")
            }
            try self.validate(self.partitionInputList, name: "partitionInputList", parent: name, max: 100)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionInputList = "PartitionInputList"
            case tableName = "TableName"
        }
    }

    public struct BatchCreatePartitionResponse: AWSDecodableShape {
        /// The errors encountered when trying to create the requested partitions.
        public let errors: [PartitionError]?

        @inlinable
        public init(errors: [PartitionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteConnectionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A list of names of the connections to delete.
        public let connectionNameList: [String]

        @inlinable
        public init(catalogId: String? = nil, connectionNameList: [String]) {
            self.catalogId = catalogId
            self.connectionNameList = connectionNameList
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.connectionNameList.forEach {
                try validate($0, name: "connectionNameList[]", parent: name, max: 255)
                try validate($0, name: "connectionNameList[]", parent: name, min: 1)
                try validate($0, name: "connectionNameList[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.connectionNameList, name: "connectionNameList", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionNameList = "ConnectionNameList"
        }
    }

    public struct BatchDeleteConnectionResponse: AWSDecodableShape {
        /// A map of the names of connections that were not successfully deleted to error details.
        public let errors: [String: ErrorDetail]?
        /// A list of names of the connection definitions that were successfully deleted.
        public let succeeded: [String]?

        @inlinable
        public init(errors: [String: ErrorDetail]? = nil, succeeded: [String]? = nil) {
            self.errors = errors
            self.succeeded = succeeded
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case succeeded = "Succeeded"
        }
    }

    public struct BatchDeletePartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partition to be deleted resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String
        /// A list of PartitionInput structures that define the partitions to be deleted.
        public let partitionsToDelete: [PartitionValueList]
        /// The name of the table that contains the partitions to be deleted.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, partitionsToDelete: [PartitionValueList], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionsToDelete = partitionsToDelete
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionsToDelete.forEach {
                try $0.validate(name: "\(name).partitionsToDelete[]")
            }
            try self.validate(self.partitionsToDelete, name: "partitionsToDelete", parent: name, max: 25)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionsToDelete = "PartitionsToDelete"
            case tableName = "TableName"
        }
    }

    public struct BatchDeletePartitionResponse: AWSDecodableShape {
        /// The errors encountered when trying to delete the requested partitions.
        public let errors: [PartitionError]?

        @inlinable
        public init(errors: [PartitionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the tables to delete reside. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// A list of the table to delete.
        public let tablesToDelete: [String]
        /// The transaction ID at which to delete the table contents.
        public let transactionId: String?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, tablesToDelete: [String], transactionId: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tablesToDelete = tablesToDelete
            self.transactionId = transactionId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tablesToDelete.forEach {
                try validate($0, name: "tablesToDelete[]", parent: name, max: 255)
                try validate($0, name: "tablesToDelete[]", parent: name, min: 1)
                try validate($0, name: "tablesToDelete[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.tablesToDelete, name: "tablesToDelete", parent: name, max: 100)
            try self.validate(self.transactionId, name: "transactionId", parent: name, max: 255)
            try self.validate(self.transactionId, name: "transactionId", parent: name, min: 1)
            try self.validate(self.transactionId, name: "transactionId", parent: name, pattern: "^[\\p{L}\\p{N}\\p{P}]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tablesToDelete = "TablesToDelete"
            case transactionId = "TransactionId"
        }
    }

    public struct BatchDeleteTableResponse: AWSDecodableShape {
        /// A list of errors encountered in attempting to delete the specified tables.
        public let errors: [TableError]?

        @inlinable
        public init(errors: [TableError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteTableVersionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table. For Hive compatibility,  this name is entirely lowercase.
        public let tableName: String
        /// A list of the IDs of versions to be deleted. A VersionId is a string representation of an integer. Each version is incremented by 1.
        public let versionIds: [String]

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, tableName: String, versionIds: [String]) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.versionIds = versionIds
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.versionIds.forEach {
                try validate($0, name: "versionIds[]", parent: name, max: 255)
                try validate($0, name: "versionIds[]", parent: name, min: 1)
                try validate($0, name: "versionIds[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.versionIds, name: "versionIds", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case versionIds = "VersionIds"
        }
    }

    public struct BatchDeleteTableVersionResponse: AWSDecodableShape {
        /// A list of errors encountered while trying to delete the specified table versions.
        public let errors: [TableVersionError]?

        @inlinable
        public init(errors: [TableVersionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchGetBlueprintsRequest: AWSEncodableShape {
        /// Specifies whether or not to include the blueprint in the response.
        public let includeBlueprint: Bool?
        /// Specifies whether or not to include the parameters, as a JSON string, for the blueprint in the response.
        public let includeParameterSpec: Bool?
        /// A list of blueprint names.
        public let names: [String]

        @inlinable
        public init(includeBlueprint: Bool? = nil, includeParameterSpec: Bool? = nil, names: [String]) {
            self.includeBlueprint = includeBlueprint
            self.includeParameterSpec = includeParameterSpec
            self.names = names
        }

        public func validate(name: String) throws {
            try self.names.forEach {
                try validate($0, name: "names[]", parent: name, max: 128)
                try validate($0, name: "names[]", parent: name, min: 1)
                try validate($0, name: "names[]", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 25)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includeBlueprint = "IncludeBlueprint"
            case includeParameterSpec = "IncludeParameterSpec"
            case names = "Names"
        }
    }

    public struct BatchGetBlueprintsResponse: AWSDecodableShape {
        /// Returns a list of blueprint as a Blueprints object.
        public let blueprints: [Blueprint]?
        /// Returns a list of BlueprintNames that were not found.
        public let missingBlueprints: [String]?

        @inlinable
        public init(blueprints: [Blueprint]? = nil, missingBlueprints: [String]? = nil) {
            self.blueprints = blueprints
            self.missingBlueprints = missingBlueprints
        }

        private enum CodingKeys: String, CodingKey {
            case blueprints = "Blueprints"
            case missingBlueprints = "MissingBlueprints"
        }
    }

    public struct BatchGetCrawlersRequest: AWSEncodableShape {
        /// A list of crawler names, which might be the names returned from the ListCrawlers operation.
        public let crawlerNames: [String]

        @inlinable
        public init(crawlerNames: [String]) {
            self.crawlerNames = crawlerNames
        }

        public func validate(name: String) throws {
            try self.crawlerNames.forEach {
                try validate($0, name: "crawlerNames[]", parent: name, max: 255)
                try validate($0, name: "crawlerNames[]", parent: name, min: 1)
                try validate($0, name: "crawlerNames[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.crawlerNames, name: "crawlerNames", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerNames = "CrawlerNames"
        }
    }

    public struct BatchGetCrawlersResponse: AWSDecodableShape {
        /// A list of crawler definitions.
        public let crawlers: [Crawler]?
        /// A list of names of crawlers that were not found.
        public let crawlersNotFound: [String]?

        @inlinable
        public init(crawlers: [Crawler]? = nil, crawlersNotFound: [String]? = nil) {
            self.crawlers = crawlers
            self.crawlersNotFound = crawlersNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case crawlers = "Crawlers"
            case crawlersNotFound = "CrawlersNotFound"
        }
    }

    public struct BatchGetCustomEntityTypesRequest: AWSEncodableShape {
        /// A list of names of the custom patterns that you want to retrieve.
        public let names: [String]

        @inlinable
        public init(names: [String]) {
            self.names = names
        }

        public func validate(name: String) throws {
            try self.names.forEach {
                try validate($0, name: "names[]", parent: name, max: 255)
                try validate($0, name: "names[]", parent: name, min: 1)
                try validate($0, name: "names[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 50)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case names = "Names"
        }
    }

    public struct BatchGetCustomEntityTypesResponse: AWSDecodableShape {
        /// A list of CustomEntityType objects representing the custom patterns that have been created.
        public let customEntityTypes: [CustomEntityType]?
        /// A list of the names of custom patterns that were not found.
        public let customEntityTypesNotFound: [String]?

        @inlinable
        public init(customEntityTypes: [CustomEntityType]? = nil, customEntityTypesNotFound: [String]? = nil) {
            self.customEntityTypes = customEntityTypes
            self.customEntityTypesNotFound = customEntityTypesNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case customEntityTypes = "CustomEntityTypes"
            case customEntityTypesNotFound = "CustomEntityTypesNotFound"
        }
    }

    public struct BatchGetDataQualityResultRequest: AWSEncodableShape {
        /// A list of unique result IDs for the data quality results.
        public let resultIds: [String]

        @inlinable
        public init(resultIds: [String]) {
            self.resultIds = resultIds
        }

        public func validate(name: String) throws {
            try self.resultIds.forEach {
                try validate($0, name: "resultIds[]", parent: name, max: 255)
                try validate($0, name: "resultIds[]", parent: name, min: 1)
                try validate($0, name: "resultIds[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.resultIds, name: "resultIds", parent: name, max: 100)
            try self.validate(self.resultIds, name: "resultIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resultIds = "ResultIds"
        }
    }

    public struct BatchGetDataQualityResultResponse: AWSDecodableShape {
        /// A list of DataQualityResult objects representing the data quality results.
        public let results: [DataQualityResult]
        /// A list of result IDs for which results were not found.
        public let resultsNotFound: [String]?

        @inlinable
        public init(results: [DataQualityResult], resultsNotFound: [String]? = nil) {
            self.results = results
            self.resultsNotFound = resultsNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case results = "Results"
            case resultsNotFound = "ResultsNotFound"
        }
    }

    public struct BatchGetDevEndpointsRequest: AWSEncodableShape {
        /// The list of DevEndpoint names, which might be the names returned from the ListDevEndpoint operation.
        public let devEndpointNames: [String]

        @inlinable
        public init(devEndpointNames: [String]) {
            self.devEndpointNames = devEndpointNames
        }

        public func validate(name: String) throws {
            try self.validate(self.devEndpointNames, name: "devEndpointNames", parent: name, max: 25)
            try self.validate(self.devEndpointNames, name: "devEndpointNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpointNames = "DevEndpointNames"
        }
    }

    public struct BatchGetDevEndpointsResponse: AWSDecodableShape {
        /// A list of DevEndpoint definitions.
        public let devEndpoints: [DevEndpoint]?
        /// A list of DevEndpoints not found.
        public let devEndpointsNotFound: [String]?

        @inlinable
        public init(devEndpoints: [DevEndpoint]? = nil, devEndpointsNotFound: [String]? = nil) {
            self.devEndpoints = devEndpoints
            self.devEndpointsNotFound = devEndpointsNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpoints = "DevEndpoints"
            case devEndpointsNotFound = "DevEndpointsNotFound"
        }
    }

    public struct BatchGetJobsRequest: AWSEncodableShape {
        /// A list of job names, which might be the names returned from the ListJobs operation.
        public let jobNames: [String]

        @inlinable
        public init(jobNames: [String]) {
            self.jobNames = jobNames
        }

        public func validate(name: String) throws {
            try self.jobNames.forEach {
                try validate($0, name: "jobNames[]", parent: name, max: 255)
                try validate($0, name: "jobNames[]", parent: name, min: 1)
                try validate($0, name: "jobNames[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case jobNames = "JobNames"
        }
    }

    public struct BatchGetJobsResponse: AWSDecodableShape {
        /// A list of job definitions.
        public let jobs: [Job]?
        /// A list of names of jobs not found.
        public let jobsNotFound: [String]?

        @inlinable
        public init(jobs: [Job]? = nil, jobsNotFound: [String]? = nil) {
            self.jobs = jobs
            self.jobsNotFound = jobsNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case jobsNotFound = "JobsNotFound"
        }
    }

    public struct BatchGetPartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// A list of partition values identifying the partitions to retrieve.
        public let partitionsToGet: [PartitionValueList]
        /// The name of the partitions' table.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, partitionsToGet: [PartitionValueList], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionsToGet = partitionsToGet
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionsToGet.forEach {
                try $0.validate(name: "\(name).partitionsToGet[]")
            }
            try self.validate(self.partitionsToGet, name: "partitionsToGet", parent: name, max: 1000)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionsToGet = "PartitionsToGet"
            case tableName = "TableName"
        }
    }

    public struct BatchGetPartitionResponse: AWSDecodableShape {
        /// A list of the requested partitions.
        public let partitions: [Partition]?
        /// A list of the partition values in the request for which partitions were not returned.
        public let unprocessedKeys: [PartitionValueList]?

        @inlinable
        public init(partitions: [Partition]? = nil, unprocessedKeys: [PartitionValueList]? = nil) {
            self.partitions = partitions
            self.unprocessedKeys = unprocessedKeys
        }

        private enum CodingKeys: String, CodingKey {
            case partitions = "Partitions"
            case unprocessedKeys = "UnprocessedKeys"
        }
    }

    public struct BatchGetTableOptimizerEntry: AWSEncodableShape {
        /// The Catalog ID of the table.
        public let catalogId: String?
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String?
        /// The name of the table.
        public let tableName: String?
        /// The type of table optimizer.
        public let type: TableOptimizerType?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String? = nil, tableName: String? = nil, type: TableOptimizerType? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "catalogId"
            case databaseName = "databaseName"
            case tableName = "tableName"
            case type = "type"
        }
    }

    public struct BatchGetTableOptimizerError: AWSDecodableShape {
        /// The Catalog ID of the table.
        public let catalogId: String?
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String?
        /// An ErrorDetail object containing code and message details about the error.
        public let error: ErrorDetail?
        /// The name of the table.
        public let tableName: String?
        /// The type of table optimizer.
        public let type: TableOptimizerType?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String? = nil, error: ErrorDetail? = nil, tableName: String? = nil, type: TableOptimizerType? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.error = error
            self.tableName = tableName
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "catalogId"
            case databaseName = "databaseName"
            case error = "error"
            case tableName = "tableName"
            case type = "type"
        }
    }

    public struct BatchGetTableOptimizerRequest: AWSEncodableShape {
        /// A list of BatchGetTableOptimizerEntry objects specifying the table optimizers to retrieve.
        public let entries: [BatchGetTableOptimizerEntry]

        @inlinable
        public init(entries: [BatchGetTableOptimizerEntry]) {
            self.entries = entries
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "Entries"
        }
    }

    public struct BatchGetTableOptimizerResponse: AWSDecodableShape {
        /// A list of errors from the operation.
        public let failures: [BatchGetTableOptimizerError]?
        /// A list of BatchTableOptimizer objects.
        public let tableOptimizers: [BatchTableOptimizer]?

        @inlinable
        public init(failures: [BatchGetTableOptimizerError]? = nil, tableOptimizers: [BatchTableOptimizer]? = nil) {
            self.failures = failures
            self.tableOptimizers = tableOptimizers
        }

        private enum CodingKeys: String, CodingKey {
            case failures = "Failures"
            case tableOptimizers = "TableOptimizers"
        }
    }

    public struct BatchGetTriggersRequest: AWSEncodableShape {
        /// A list of trigger names, which may be the names returned from the ListTriggers operation.
        public let triggerNames: [String]

        @inlinable
        public init(triggerNames: [String]) {
            self.triggerNames = triggerNames
        }

        public func validate(name: String) throws {
            try self.triggerNames.forEach {
                try validate($0, name: "triggerNames[]", parent: name, max: 255)
                try validate($0, name: "triggerNames[]", parent: name, min: 1)
                try validate($0, name: "triggerNames[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case triggerNames = "TriggerNames"
        }
    }

    public struct BatchGetTriggersResponse: AWSDecodableShape {
        /// A list of trigger definitions.
        public let triggers: [Trigger]?
        /// A list of names of triggers not found.
        public let triggersNotFound: [String]?

        @inlinable
        public init(triggers: [Trigger]? = nil, triggersNotFound: [String]? = nil) {
            self.triggers = triggers
            self.triggersNotFound = triggersNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case triggers = "Triggers"
            case triggersNotFound = "TriggersNotFound"
        }
    }

    public struct BatchGetWorkflowsRequest: AWSEncodableShape {
        /// Specifies whether to include a graph when returning the workflow resource metadata.
        public let includeGraph: Bool?
        /// A list of workflow names, which may be the names returned from the ListWorkflows operation.
        public let names: [String]

        @inlinable
        public init(includeGraph: Bool? = nil, names: [String]) {
            self.includeGraph = includeGraph
            self.names = names
        }

        public func validate(name: String) throws {
            try self.names.forEach {
                try validate($0, name: "names[]", parent: name, max: 255)
                try validate($0, name: "names[]", parent: name, min: 1)
                try validate($0, name: "names[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 25)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case names = "Names"
        }
    }

    public struct BatchGetWorkflowsResponse: AWSDecodableShape {
        /// A list of names of workflows not found.
        public let missingWorkflows: [String]?
        /// A list of workflow resource metadata.
        public let workflows: [Workflow]?

        @inlinable
        public init(missingWorkflows: [String]? = nil, workflows: [Workflow]? = nil) {
            self.missingWorkflows = missingWorkflows
            self.workflows = workflows
        }

        private enum CodingKeys: String, CodingKey {
            case missingWorkflows = "MissingWorkflows"
            case workflows = "Workflows"
        }
    }

    public struct BatchPutDataQualityStatisticAnnotationRequest: AWSEncodableShape {
        /// Client Token.
        public let clientToken: String?
        /// A list of DatapointInclusionAnnotation's.
        public let inclusionAnnotations: [DatapointInclusionAnnotation]

        @inlinable
        public init(clientToken: String? = nil, inclusionAnnotations: [DatapointInclusionAnnotation]) {
            self.clientToken = clientToken
            self.inclusionAnnotations = inclusionAnnotations
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 255)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.inclusionAnnotations.forEach {
                try $0.validate(name: "\(name).inclusionAnnotations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case inclusionAnnotations = "InclusionAnnotations"
        }
    }

    public struct BatchPutDataQualityStatisticAnnotationResponse: AWSDecodableShape {
        /// A list of AnnotationError's.
        public let failedInclusionAnnotations: [AnnotationError]?

        @inlinable
        public init(failedInclusionAnnotations: [AnnotationError]? = nil) {
            self.failedInclusionAnnotations = failedInclusionAnnotations
        }

        private enum CodingKeys: String, CodingKey {
            case failedInclusionAnnotations = "FailedInclusionAnnotations"
        }
    }

    public struct BatchStopJobRunError: AWSDecodableShape {
        /// Specifies details about the error that was encountered.
        public let errorDetail: ErrorDetail?
        /// The name of the job definition that is used in the job run in question.
        public let jobName: String?
        /// The JobRunId of the job run in question.
        public let jobRunId: String?

        @inlinable
        public init(errorDetail: ErrorDetail? = nil, jobName: String? = nil, jobRunId: String? = nil) {
            self.errorDetail = errorDetail
            self.jobName = jobName
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
        }
    }

    public struct BatchStopJobRunRequest: AWSEncodableShape {
        /// The name of the job definition for which to stop job runs.
        public let jobName: String
        /// A list of the JobRunIds that should be stopped for that job definition.
        public let jobRunIds: [String]

        @inlinable
        public init(jobName: String, jobRunIds: [String]) {
            self.jobName = jobName
            self.jobRunIds = jobRunIds
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.jobRunIds.forEach {
                try validate($0, name: "jobRunIds[]", parent: name, max: 255)
                try validate($0, name: "jobRunIds[]", parent: name, min: 1)
                try validate($0, name: "jobRunIds[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.jobRunIds, name: "jobRunIds", parent: name, max: 25)
            try self.validate(self.jobRunIds, name: "jobRunIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobRunIds = "JobRunIds"
        }
    }

    public struct BatchStopJobRunResponse: AWSDecodableShape {
        /// A list of the errors that were encountered in trying to stop JobRuns, including the JobRunId for which each error was encountered and details about the error.
        public let errors: [BatchStopJobRunError]?
        /// A list of the JobRuns that were successfully submitted for stopping.
        public let successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]?

        @inlinable
        public init(errors: [BatchStopJobRunError]? = nil, successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]? = nil) {
            self.errors = errors
            self.successfulSubmissions = successfulSubmissions
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case successfulSubmissions = "SuccessfulSubmissions"
        }
    }

    public struct BatchStopJobRunSuccessfulSubmission: AWSDecodableShape {
        /// The name of the job definition used in the job run that was stopped.
        public let jobName: String?
        /// The JobRunId of the job run that was stopped.
        public let jobRunId: String?

        @inlinable
        public init(jobName: String? = nil, jobRunId: String? = nil) {
            self.jobName = jobName
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobRunId = "JobRunId"
        }
    }

    public struct BatchTableOptimizer: AWSDecodableShape {
        /// The Catalog ID of the table.
        public let catalogId: String?
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String?
        /// The name of the table.
        public let tableName: String?
        /// A TableOptimizer object that contains details on the configuration and last run of a table optimizer.
        public let tableOptimizer: TableOptimizer?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String? = nil, tableName: String? = nil, tableOptimizer: TableOptimizer? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.tableOptimizer = tableOptimizer
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "catalogId"
            case databaseName = "databaseName"
            case tableName = "tableName"
            case tableOptimizer = "tableOptimizer"
        }
    }

    public struct BatchUpdatePartitionFailureEntry: AWSDecodableShape {
        /// The details about the batch update partition error.
        public let errorDetail: ErrorDetail?
        /// A list of values defining the partitions.
        public let partitionValueList: [String]?

        @inlinable
        public init(errorDetail: ErrorDetail? = nil, partitionValueList: [String]? = nil) {
            self.errorDetail = errorDetail
            self.partitionValueList = partitionValueList
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case partitionValueList = "PartitionValueList"
        }
    }

    public struct BatchUpdatePartitionRequest: AWSEncodableShape {
        /// The ID of the catalog in which the partition is to be updated. Currently, this should be the Amazon Web Services account ID.
        public let catalogId: String?
        /// The name of the metadata database in which the partition is to be updated.
        public let databaseName: String
        /// A list of up to 100 BatchUpdatePartitionRequestEntry objects to update.
        public let entries: [BatchUpdatePartitionRequestEntry]
        /// The name of the metadata table in which the partition is to be updated.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, entries: [BatchUpdatePartitionRequestEntry], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.entries = entries
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.entries, name: "entries", parent: name, max: 100)
            try self.validate(self.entries, name: "entries", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case entries = "Entries"
            case tableName = "TableName"
        }
    }

    public struct BatchUpdatePartitionRequestEntry: AWSEncodableShape {
        /// The structure used to update a partition.
        public let partitionInput: PartitionInput
        /// A list of values defining the partitions.
        public let partitionValueList: [String]

        @inlinable
        public init(partitionInput: PartitionInput, partitionValueList: [String]) {
            self.partitionInput = partitionInput
            self.partitionValueList = partitionValueList
        }

        public func validate(name: String) throws {
            try self.partitionInput.validate(name: "\(name).partitionInput")
            try self.partitionValueList.forEach {
                try validate($0, name: "partitionValueList[]", parent: name, max: 1024)
                try validate($0, name: "partitionValueList[]", parent: name, min: 1)
            }
            try self.validate(self.partitionValueList, name: "partitionValueList", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case partitionInput = "PartitionInput"
            case partitionValueList = "PartitionValueList"
        }
    }

    public struct BatchUpdatePartitionResponse: AWSDecodableShape {
        /// The errors encountered when trying to update the requested partitions. A list of BatchUpdatePartitionFailureEntry objects.
        public let errors: [BatchUpdatePartitionFailureEntry]?

        @inlinable
        public init(errors: [BatchUpdatePartitionFailureEntry]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BinaryColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The average bit sequence length in the column.
        public let averageLength: Double
        /// The size of the longest bit sequence in the column.
        public let maximumLength: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        @inlinable
        public init(averageLength: Double, maximumLength: Int64, numberOfNulls: Int64) {
            self.averageLength = averageLength
            self.maximumLength = maximumLength
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.averageLength, name: "averageLength", parent: name, min: 0.0)
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case averageLength = "AverageLength"
            case maximumLength = "MaximumLength"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct Blueprint: AWSDecodableShape {
        /// Specifies the path in Amazon S3 where the blueprint is published.
        public let blueprintLocation: String?
        /// Specifies a path in Amazon S3 where the blueprint is copied when you call CreateBlueprint/UpdateBlueprint to register the blueprint in Glue.
        public let blueprintServiceLocation: String?
        /// The date and time the blueprint was registered.
        public let createdOn: Date?
        /// The description of the blueprint.
        public let description: String?
        /// An error message.
        public let errorMessage: String?
        /// When there are multiple versions of a blueprint and the latest version has some errors, this attribute indicates the last successful blueprint definition that is available with the service.
        public let lastActiveDefinition: LastActiveDefinition?
        /// The date and time the blueprint was last modified.
        public let lastModifiedOn: Date?
        /// The name of the blueprint.
        public let name: String?
        /// A JSON string that indicates the list of parameter specifications for the blueprint.
        public let parameterSpec: String?
        /// The status of the blueprint registration.   Creating  The blueprint registration is in progress.   Active  The blueprint has been successfully registered.   Updating  An update to the blueprint registration is in progress.   Failed  The blueprint registration failed.
        public let status: BlueprintStatus?

        @inlinable
        public init(blueprintLocation: String? = nil, blueprintServiceLocation: String? = nil, createdOn: Date? = nil, description: String? = nil, errorMessage: String? = nil, lastActiveDefinition: LastActiveDefinition? = nil, lastModifiedOn: Date? = nil, name: String? = nil, parameterSpec: String? = nil, status: BlueprintStatus? = nil) {
            self.blueprintLocation = blueprintLocation
            self.blueprintServiceLocation = blueprintServiceLocation
            self.createdOn = createdOn
            self.description = description
            self.errorMessage = errorMessage
            self.lastActiveDefinition = lastActiveDefinition
            self.lastModifiedOn = lastModifiedOn
            self.name = name
            self.parameterSpec = parameterSpec
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintLocation = "BlueprintLocation"
            case blueprintServiceLocation = "BlueprintServiceLocation"
            case createdOn = "CreatedOn"
            case description = "Description"
            case errorMessage = "ErrorMessage"
            case lastActiveDefinition = "LastActiveDefinition"
            case lastModifiedOn = "LastModifiedOn"
            case name = "Name"
            case parameterSpec = "ParameterSpec"
            case status = "Status"
        }
    }

    public struct BlueprintDetails: AWSDecodableShape {
        /// The name of the blueprint.
        public let blueprintName: String?
        /// The run ID for this blueprint.
        public let runId: String?

        @inlinable
        public init(blueprintName: String? = nil, runId: String? = nil) {
            self.blueprintName = blueprintName
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintName = "BlueprintName"
            case runId = "RunId"
        }
    }

    public struct BlueprintRun: AWSDecodableShape {
        /// The name of the blueprint.
        public let blueprintName: String?
        /// The date and time that the blueprint run completed.
        public let completedOn: Date?
        /// Indicates any errors that are seen while running the blueprint.
        public let errorMessage: String?
        /// The blueprint parameters as a string. You will have to provide a value for each key that is required from the parameter spec that is defined in the Blueprint$ParameterSpec.
        public let parameters: String?
        /// The role ARN. This role will be assumed by the Glue service and will be used to create the workflow and other entities of a workflow.
        public let roleArn: String?
        /// If there are any errors while creating the entities of a workflow, we try to roll back the created entities until that point and delete them. This attribute indicates the errors seen while trying to delete the entities that are created.
        public let rollbackErrorMessage: String?
        /// The run ID for this blueprint run.
        public let runId: String?
        /// The date and time that the blueprint run started.
        public let startedOn: Date?
        /// The state of the blueprint run. Possible values are:   Running  The blueprint run is in progress.   Succeeded  The blueprint run completed successfully.   Failed  The blueprint run failed and rollback is complete.   Rolling Back  The blueprint run failed and rollback is in progress.
        public let state: BlueprintRunState?
        /// The name of a workflow that is created as a result of a successful blueprint run. If a blueprint run has an error, there will not be a workflow created.
        public let workflowName: String?

        @inlinable
        public init(blueprintName: String? = nil, completedOn: Date? = nil, errorMessage: String? = nil, parameters: String? = nil, roleArn: String? = nil, rollbackErrorMessage: String? = nil, runId: String? = nil, startedOn: Date? = nil, state: BlueprintRunState? = nil, workflowName: String? = nil) {
            self.blueprintName = blueprintName
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.parameters = parameters
            self.roleArn = roleArn
            self.rollbackErrorMessage = rollbackErrorMessage
            self.runId = runId
            self.startedOn = startedOn
            self.state = state
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintName = "BlueprintName"
            case completedOn = "CompletedOn"
            case errorMessage = "ErrorMessage"
            case parameters = "Parameters"
            case roleArn = "RoleArn"
            case rollbackErrorMessage = "RollbackErrorMessage"
            case runId = "RunId"
            case startedOn = "StartedOn"
            case state = "State"
            case workflowName = "WorkflowName"
        }
    }

    public struct BooleanColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The number of false values in the column.
        public let numberOfFalses: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64
        /// The number of true values in the column.
        public let numberOfTrues: Int64

        @inlinable
        public init(numberOfFalses: Int64, numberOfNulls: Int64, numberOfTrues: Int64) {
            self.numberOfFalses = numberOfFalses
            self.numberOfNulls = numberOfNulls
            self.numberOfTrues = numberOfTrues
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfFalses, name: "numberOfFalses", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
            try self.validate(self.numberOfTrues, name: "numberOfTrues", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfFalses = "NumberOfFalses"
            case numberOfNulls = "NumberOfNulls"
            case numberOfTrues = "NumberOfTrues"
        }
    }

    public struct CancelDataQualityRuleRecommendationRunRequest: AWSEncodableShape {
        /// The unique run identifier associated with this run.
        public let runId: String

        @inlinable
        public init(runId: String) {
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct CancelDataQualityRuleRecommendationRunResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CancelDataQualityRulesetEvaluationRunRequest: AWSEncodableShape {
        /// The unique run identifier associated with this run.
        public let runId: String

        @inlinable
        public init(runId: String) {
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct CancelDataQualityRulesetEvaluationRunResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CancelMLTaskRunRequest: AWSEncodableShape {
        /// A unique identifier for the task run.
        public let taskRunId: String
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        @inlinable
        public init(taskRunId: String, transformId: String) {
            self.taskRunId = taskRunId
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, max: 255)
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, min: 1)
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
            case transformId = "TransformId"
        }
    }

    public struct CancelMLTaskRunResponse: AWSDecodableShape {
        /// The status for this run.
        public let status: TaskStatusType?
        /// The unique identifier for the task run.
        public let taskRunId: String?
        /// The unique identifier of the machine learning transform.
        public let transformId: String?

        @inlinable
        public init(status: TaskStatusType? = nil, taskRunId: String? = nil, transformId: String? = nil) {
            self.status = status
            self.taskRunId = taskRunId
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case taskRunId = "TaskRunId"
            case transformId = "TransformId"
        }
    }

    public struct CancelStatementRequest: AWSEncodableShape {
        /// The ID of the statement to be cancelled.
        public let id: Int
        /// The origin of the request to cancel the statement.
        public let requestOrigin: String?
        /// The Session ID of the statement to be cancelled.
        public let sessionId: String

        @inlinable
        public init(id: Int = 0, requestOrigin: String? = nil, sessionId: String) {
            self.id = id
            self.requestOrigin = requestOrigin
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, max: 128)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, min: 1)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 255)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case requestOrigin = "RequestOrigin"
            case sessionId = "SessionId"
        }
    }

    public struct CancelStatementResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Capabilities: AWSDecodableShape {
        /// A list of supported authentication types.
        public let supportedAuthenticationTypes: [AuthenticationType]
        /// A list of supported compute environments.
        public let supportedComputeEnvironments: [ComputeEnvironment]
        /// A list of supported data operations.
        public let supportedDataOperations: [DataOperation]

        @inlinable
        public init(supportedAuthenticationTypes: [AuthenticationType], supportedComputeEnvironments: [ComputeEnvironment], supportedDataOperations: [DataOperation]) {
            self.supportedAuthenticationTypes = supportedAuthenticationTypes
            self.supportedComputeEnvironments = supportedComputeEnvironments
            self.supportedDataOperations = supportedDataOperations
        }

        private enum CodingKeys: String, CodingKey {
            case supportedAuthenticationTypes = "SupportedAuthenticationTypes"
            case supportedComputeEnvironments = "SupportedComputeEnvironments"
            case supportedDataOperations = "SupportedDataOperations"
        }
    }

    public struct Catalog: AWSDecodableShape {
        ///  Allows third-party engines to access data in Amazon S3 locations that are registered with Lake Formation.
        public let allowFullTableExternalDataAccess: AllowFullTableExternalDataAccessEnum?
        /// The ID of the catalog. To grant access to the default catalog, this field should not be provided.
        public let catalogId: String?
        /// A CatalogProperties object that specifies data lake access properties and other custom properties.
        public let catalogProperties: CatalogPropertiesOutput?
        /// An array of PrincipalPermissions objects. Creates a set of default permissions on the database(s) for principals. Used by Amazon Web Services Lake Formation. Not used in the normal course of Glue operations.
        public let createDatabaseDefaultPermissions: [PrincipalPermissions]?
        /// An array of PrincipalPermissions objects. Creates a set of default permissions on the table(s) for principals. Used by Amazon Web Services Lake Formation. Not used in the normal course of Glue operations.
        public let createTableDefaultPermissions: [PrincipalPermissions]?
        /// The time at which the catalog was created.
        public let createTime: Date?
        /// Description string, not more than 2048 bytes long, matching the URI address multi-line string pattern. A description of the catalog.
        public let description: String?
        /// A FederatedCatalog object that points to an entity outside the Glue Data Catalog.
        public let federatedCatalog: FederatedCatalog?
        /// The name of the catalog. Cannot be the same as the account ID.
        public let name: String
        ///  A map array of key-value pairs that define parameters and properties of the catalog.
        public let parameters: [String: String]?
        /// The Amazon Resource Name (ARN) assigned to the catalog resource.
        public let resourceArn: String?
        /// A TargetRedshiftCatalog object that describes a target catalog for database resource linking.
        public let targetRedshiftCatalog: TargetRedshiftCatalog?
        /// The time at which the catalog was last updated.
        public let updateTime: Date?

        @inlinable
        public init(allowFullTableExternalDataAccess: AllowFullTableExternalDataAccessEnum? = nil, catalogId: String? = nil, catalogProperties: CatalogPropertiesOutput? = nil, createDatabaseDefaultPermissions: [PrincipalPermissions]? = nil, createTableDefaultPermissions: [PrincipalPermissions]? = nil, createTime: Date? = nil, description: String? = nil, federatedCatalog: FederatedCatalog? = nil, name: String, parameters: [String: String]? = nil, resourceArn: String? = nil, targetRedshiftCatalog: TargetRedshiftCatalog? = nil, updateTime: Date? = nil) {
            self.allowFullTableExternalDataAccess = allowFullTableExternalDataAccess
            self.catalogId = catalogId
            self.catalogProperties = catalogProperties
            self.createDatabaseDefaultPermissions = createDatabaseDefaultPermissions
            self.createTableDefaultPermissions = createTableDefaultPermissions
            self.createTime = createTime
            self.description = description
            self.federatedCatalog = federatedCatalog
            self.name = name
            self.parameters = parameters
            self.resourceArn = resourceArn
            self.targetRedshiftCatalog = targetRedshiftCatalog
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case allowFullTableExternalDataAccess = "AllowFullTableExternalDataAccess"
            case catalogId = "CatalogId"
            case catalogProperties = "CatalogProperties"
            case createDatabaseDefaultPermissions = "CreateDatabaseDefaultPermissions"
            case createTableDefaultPermissions = "CreateTableDefaultPermissions"
            case createTime = "CreateTime"
            case description = "Description"
            case federatedCatalog = "FederatedCatalog"
            case name = "Name"
            case parameters = "Parameters"
            case resourceArn = "ResourceArn"
            case targetRedshiftCatalog = "TargetRedshiftCatalog"
            case updateTime = "UpdateTime"
        }
    }

    public struct CatalogDeltaSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalDeltaOptions: [String: String]?
        /// The name of the database to read from.
        public let database: String
        /// The name of the Delta Lake data source.
        public let name: String
        /// Specifies the data schema for the Delta Lake source.
        public let outputSchemas: [GlueSchema]?
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(additionalDeltaOptions: [String: String]? = nil, database: String, name: String, outputSchemas: [GlueSchema]? = nil, table: String) {
            self.additionalDeltaOptions = additionalDeltaOptions
            self.database = database
            self.name = name
            self.outputSchemas = outputSchemas
            self.table = table
        }

        public func validate(name: String) throws {
            try self.additionalDeltaOptions?.forEach {
                try validate($0.key, name: "additionalDeltaOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalDeltaOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalDeltaOptions = "AdditionalDeltaOptions"
            case database = "Database"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case table = "Table"
        }
    }

    public struct CatalogEntry: AWSEncodableShape {
        /// The database in which the table metadata resides.
        public let databaseName: String
        /// The name of the table in question.
        public let tableName: String

        @inlinable
        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct CatalogHudiSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalHudiOptions: [String: String]?
        /// The name of the database to read from.
        public let database: String
        /// The name of the Hudi data source.
        public let name: String
        /// Specifies the data schema for the Hudi source.
        public let outputSchemas: [GlueSchema]?
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(additionalHudiOptions: [String: String]? = nil, database: String, name: String, outputSchemas: [GlueSchema]? = nil, table: String) {
            self.additionalHudiOptions = additionalHudiOptions
            self.database = database
            self.name = name
            self.outputSchemas = outputSchemas
            self.table = table
        }

        public func validate(name: String) throws {
            try self.additionalHudiOptions?.forEach {
                try validate($0.key, name: "additionalHudiOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalHudiOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalHudiOptions = "AdditionalHudiOptions"
            case database = "Database"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case table = "Table"
        }
    }

    public struct CatalogImportStatus: AWSDecodableShape {
        ///  True if the migration has completed, or False otherwise.
        public let importCompleted: Bool?
        /// The name of the person who initiated the migration.
        public let importedBy: String?
        /// The time that the migration was started.
        public let importTime: Date?

        @inlinable
        public init(importCompleted: Bool? = nil, importedBy: String? = nil, importTime: Date? = nil) {
            self.importCompleted = importCompleted
            self.importedBy = importedBy
            self.importTime = importTime
        }

        private enum CodingKeys: String, CodingKey {
            case importCompleted = "ImportCompleted"
            case importedBy = "ImportedBy"
            case importTime = "ImportTime"
        }
    }

    public struct CatalogInput: AWSEncodableShape {
        ///  Allows third-party engines to access data in Amazon S3 locations that are registered with Lake Formation.
        public let allowFullTableExternalDataAccess: AllowFullTableExternalDataAccessEnum?
        /// A CatalogProperties object that specifies data lake access properties and other custom properties.
        public let catalogProperties: CatalogProperties?
        /// An array of PrincipalPermissions objects. Creates a set of default permissions on the database(s) for principals. Used by Amazon Web Services Lake Formation. Typically should be explicitly set as an empty list.
        public let createDatabaseDefaultPermissions: [PrincipalPermissions]?
        /// An array of PrincipalPermissions objects. Creates a set of default permissions on the table(s) for principals. Used by Amazon Web Services Lake Formation. Typically should be explicitly set as an empty list.
        public let createTableDefaultPermissions: [PrincipalPermissions]?
        /// Description string, not more than 2048 bytes long, matching the URI address multi-line string pattern. A description of the catalog.
        public let description: String?
        /// A FederatedCatalog object. A FederatedCatalog structure that references an entity outside the Glue Data Catalog, for example a Redshift database.
        public let federatedCatalog: FederatedCatalog?
        /// A map array of key-value pairs that define the parameters and properties of the catalog.
        public let parameters: [String: String]?
        /// A TargetRedshiftCatalog object that describes a target catalog for resource linking.
        public let targetRedshiftCatalog: TargetRedshiftCatalog?

        @inlinable
        public init(allowFullTableExternalDataAccess: AllowFullTableExternalDataAccessEnum? = nil, catalogProperties: CatalogProperties? = nil, createDatabaseDefaultPermissions: [PrincipalPermissions]? = nil, createTableDefaultPermissions: [PrincipalPermissions]? = nil, description: String? = nil, federatedCatalog: FederatedCatalog? = nil, parameters: [String: String]? = nil, targetRedshiftCatalog: TargetRedshiftCatalog? = nil) {
            self.allowFullTableExternalDataAccess = allowFullTableExternalDataAccess
            self.catalogProperties = catalogProperties
            self.createDatabaseDefaultPermissions = createDatabaseDefaultPermissions
            self.createTableDefaultPermissions = createTableDefaultPermissions
            self.description = description
            self.federatedCatalog = federatedCatalog
            self.parameters = parameters
            self.targetRedshiftCatalog = targetRedshiftCatalog
        }

        public func validate(name: String) throws {
            try self.catalogProperties?.validate(name: "\(name).catalogProperties")
            try self.createDatabaseDefaultPermissions?.forEach {
                try $0.validate(name: "\(name).createDatabaseDefaultPermissions[]")
            }
            try self.createTableDefaultPermissions?.forEach {
                try $0.validate(name: "\(name).createTableDefaultPermissions[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.federatedCatalog?.validate(name: "\(name).federatedCatalog")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512000)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowFullTableExternalDataAccess = "AllowFullTableExternalDataAccess"
            case catalogProperties = "CatalogProperties"
            case createDatabaseDefaultPermissions = "CreateDatabaseDefaultPermissions"
            case createTableDefaultPermissions = "CreateTableDefaultPermissions"
            case description = "Description"
            case federatedCatalog = "FederatedCatalog"
            case parameters = "Parameters"
            case targetRedshiftCatalog = "TargetRedshiftCatalog"
        }
    }

    public struct CatalogKafkaSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to read from.
        public let database: String
        /// Specifies options related to data preview for viewing a sample of your data.
        public let dataPreviewOptions: StreamingDataPreviewOptions?
        /// Whether to automatically determine the schema from the incoming data.
        public let detectSchema: Bool?
        /// The name of the data store.
        public let name: String
        /// Specifies the streaming options.
        public let streamingOptions: KafkaStreamingSourceOptions?
        /// The name of the table in the database to read from.
        public let table: String
        /// The amount of time to spend processing each micro batch.
        public let windowSize: Int?

        @inlinable
        public init(database: String, dataPreviewOptions: StreamingDataPreviewOptions? = nil, detectSchema: Bool? = nil, name: String, streamingOptions: KafkaStreamingSourceOptions? = nil, table: String, windowSize: Int? = nil) {
            self.database = database
            self.dataPreviewOptions = dataPreviewOptions
            self.detectSchema = detectSchema
            self.name = name
            self.streamingOptions = streamingOptions
            self.table = table
            self.windowSize = windowSize
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.dataPreviewOptions?.validate(name: "\(name).dataPreviewOptions")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.streamingOptions?.validate(name: "\(name).streamingOptions")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.windowSize, name: "windowSize", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case dataPreviewOptions = "DataPreviewOptions"
            case detectSchema = "DetectSchema"
            case name = "Name"
            case streamingOptions = "StreamingOptions"
            case table = "Table"
            case windowSize = "WindowSize"
        }
    }

    public struct CatalogKinesisSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to read from.
        public let database: String
        /// Additional options for data preview.
        public let dataPreviewOptions: StreamingDataPreviewOptions?
        /// Whether to automatically determine the schema from the incoming data.
        public let detectSchema: Bool?
        /// The name of the data source.
        public let name: String
        /// Additional options for the Kinesis streaming data source.
        public let streamingOptions: KinesisStreamingSourceOptions?
        /// The name of the table in the database to read from.
        public let table: String
        /// The amount of time to spend processing each micro batch.
        public let windowSize: Int?

        @inlinable
        public init(database: String, dataPreviewOptions: StreamingDataPreviewOptions? = nil, detectSchema: Bool? = nil, name: String, streamingOptions: KinesisStreamingSourceOptions? = nil, table: String, windowSize: Int? = nil) {
            self.database = database
            self.dataPreviewOptions = dataPreviewOptions
            self.detectSchema = detectSchema
            self.name = name
            self.streamingOptions = streamingOptions
            self.table = table
            self.windowSize = windowSize
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.dataPreviewOptions?.validate(name: "\(name).dataPreviewOptions")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.streamingOptions?.validate(name: "\(name).streamingOptions")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.windowSize, name: "windowSize", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case dataPreviewOptions = "DataPreviewOptions"
            case detectSchema = "DetectSchema"
            case name = "Name"
            case streamingOptions = "StreamingOptions"
            case table = "Table"
            case windowSize = "WindowSize"
        }
    }

    public struct CatalogProperties: AWSEncodableShape {
        /// Additional key-value properties for the catalog, such as column statistics optimizations.
        public let customProperties: [String: String]?
        /// A DataLakeAccessProperties object that specifies properties to configure data lake access for your catalog resource in the Glue Data Catalog.
        public let dataLakeAccessProperties: DataLakeAccessProperties?

        @inlinable
        public init(customProperties: [String: String]? = nil, dataLakeAccessProperties: DataLakeAccessProperties? = nil) {
            self.customProperties = customProperties
            self.dataLakeAccessProperties = dataLakeAccessProperties
        }

        public func validate(name: String) throws {
            try self.customProperties?.forEach {
                try validate($0.key, name: "customProperties.key", parent: name, max: 255)
                try validate($0.key, name: "customProperties.key", parent: name, min: 1)
                try validate($0.key, name: "customProperties.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try validate($0.value, name: "customProperties[\"\($0.key)\"]", parent: name, max: 512000)
            }
            try self.dataLakeAccessProperties?.validate(name: "\(name).dataLakeAccessProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case customProperties = "CustomProperties"
            case dataLakeAccessProperties = "DataLakeAccessProperties"
        }
    }

    public struct CatalogPropertiesOutput: AWSDecodableShape {
        /// Additional key-value properties for the catalog, such as column statistics optimizations.
        public let customProperties: [String: String]?
        /// A DataLakeAccessProperties object with input properties to configure data lake access for your catalog resource in the Glue Data Catalog.
        public let dataLakeAccessProperties: DataLakeAccessPropertiesOutput?

        @inlinable
        public init(customProperties: [String: String]? = nil, dataLakeAccessProperties: DataLakeAccessPropertiesOutput? = nil) {
            self.customProperties = customProperties
            self.dataLakeAccessProperties = dataLakeAccessProperties
        }

        private enum CodingKeys: String, CodingKey {
            case customProperties = "CustomProperties"
            case dataLakeAccessProperties = "DataLakeAccessProperties"
        }
    }

    public struct CatalogSchemaChangePolicy: AWSEncodableShape & AWSDecodableShape {
        /// Whether to use the specified update behavior when the crawler finds a changed schema.
        public let enableUpdateCatalog: Bool?
        /// The update behavior when the crawler finds a changed schema.
        public let updateBehavior: UpdateCatalogBehavior?

        @inlinable
        public init(enableUpdateCatalog: Bool? = nil, updateBehavior: UpdateCatalogBehavior? = nil) {
            self.enableUpdateCatalog = enableUpdateCatalog
            self.updateBehavior = updateBehavior
        }

        private enum CodingKeys: String, CodingKey {
            case enableUpdateCatalog = "EnableUpdateCatalog"
            case updateBehavior = "UpdateBehavior"
        }
    }

    public struct CatalogSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to read from.
        public let database: String
        /// The name of the data store.
        public let name: String
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(database: String, name: String, table: String) {
            self.database = database
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct CatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl when using a Catalog connection type paired with a NETWORK Connection type.
        public let connectionName: String?
        /// The name of the database to be synchronized.
        public let databaseName: String
        /// A valid Amazon dead-letter SQS ARN. For example, arn:aws:sqs:region:account:deadLetterQueue.
        public let dlqEventQueueArn: String?
        /// A valid Amazon SQS ARN. For example, arn:aws:sqs:region:account:sqs.
        public let eventQueueArn: String?
        /// A list of the tables to be synchronized.
        public let tables: [String]

        @inlinable
        public init(connectionName: String? = nil, databaseName: String, dlqEventQueueArn: String? = nil, eventQueueArn: String? = nil, tables: [String]) {
            self.connectionName = connectionName
            self.databaseName = databaseName
            self.dlqEventQueueArn = dlqEventQueueArn
            self.eventQueueArn = eventQueueArn
            self.tables = tables
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tables.forEach {
                try validate($0, name: "tables[]", parent: name, max: 255)
                try validate($0, name: "tables[]", parent: name, min: 1)
                try validate($0, name: "tables[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.tables, name: "tables", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case databaseName = "DatabaseName"
            case dlqEventQueueArn = "DlqEventQueueArn"
            case eventQueueArn = "EventQueueArn"
            case tables = "Tables"
        }
    }

    public struct CheckSchemaVersionValidityInput: AWSEncodableShape {
        /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
        public let dataFormat: DataFormat
        /// The definition of the schema that has to be validated.
        public let schemaDefinition: String

        @inlinable
        public init(dataFormat: DataFormat, schemaDefinition: String) {
            self.dataFormat = dataFormat
            self.schemaDefinition = schemaDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, max: 170000)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, min: 1)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataFormat = "DataFormat"
            case schemaDefinition = "SchemaDefinition"
        }
    }

    public struct CheckSchemaVersionValidityResponse: AWSDecodableShape {
        /// A validation failure error message.
        public let error: String?
        /// Return true, if the schema is valid and false otherwise.
        public let valid: Bool?

        @inlinable
        public init(error: String? = nil, valid: Bool? = nil) {
            self.error = error
            self.valid = valid
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case valid = "Valid"
        }
    }

    public struct Classifier: AWSDecodableShape {
        /// A classifier for comma-separated values (CSV).
        public let csvClassifier: CsvClassifier?
        /// A classifier that uses grok.
        public let grokClassifier: GrokClassifier?
        /// A classifier for JSON content.
        public let jsonClassifier: JsonClassifier?
        /// A classifier for XML content.
        public let xmlClassifier: XMLClassifier?

        @inlinable
        public init(csvClassifier: CsvClassifier? = nil, grokClassifier: GrokClassifier? = nil, jsonClassifier: JsonClassifier? = nil, xmlClassifier: XMLClassifier? = nil) {
            self.csvClassifier = csvClassifier
            self.grokClassifier = grokClassifier
            self.jsonClassifier = jsonClassifier
            self.xmlClassifier = xmlClassifier
        }

        private enum CodingKeys: String, CodingKey {
            case csvClassifier = "CsvClassifier"
            case grokClassifier = "GrokClassifier"
            case jsonClassifier = "JsonClassifier"
            case xmlClassifier = "XMLClassifier"
        }
    }

    public struct CloudWatchEncryption: AWSEncodableShape & AWSDecodableShape {
        /// The encryption mode to use for CloudWatch data.
        public let cloudWatchEncryptionMode: CloudWatchEncryptionMode?
        /// The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        public let kmsKeyArn: String?

        @inlinable
        public init(cloudWatchEncryptionMode: CloudWatchEncryptionMode? = nil, kmsKeyArn: String? = nil) {
            self.cloudWatchEncryptionMode = cloudWatchEncryptionMode
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchEncryptionMode = "CloudWatchEncryptionMode"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct CodeGenConfigurationNode: AWSEncodableShape & AWSDecodableShape {
        /// Specifies a transform that groups rows by chosen fields and computes the aggregated value by specified function.
        public let aggregate: Aggregate?
        /// Specifies a target that writes to a data source in Amazon Redshift.
        public let amazonRedshiftSource: AmazonRedshiftSource?
        /// Specifies a target that writes to a data target in Amazon Redshift.
        public let amazonRedshiftTarget: AmazonRedshiftTarget?
        /// Specifies a transform that maps data property keys in the data source to data property keys in the data target. You can rename keys, modify the data types for keys, and choose which keys to drop from the dataset.
        public let applyMapping: ApplyMapping?
        /// Specifies a connector to an Amazon Athena data source.
        public let athenaConnectorSource: AthenaConnectorSource?
        /// Specifies a Delta Lake data source that is registered in the Glue Data Catalog.
        public let catalogDeltaSource: CatalogDeltaSource?
        /// Specifies a Hudi data source that is registered in the Glue Data Catalog.
        public let catalogHudiSource: CatalogHudiSource?
        /// Specifies an Apache Kafka data store in the Data Catalog.
        public let catalogKafkaSource: CatalogKafkaSource?
        /// Specifies a Kinesis data source in the Glue Data Catalog.
        public let catalogKinesisSource: CatalogKinesisSource?
        /// Specifies a data store in the Glue Data Catalog.
        public let catalogSource: CatalogSource?
        /// Specifies a target that uses a Glue Data Catalog table.
        public let catalogTarget: BasicCatalogTarget?
        /// Specifies a source generated with standard connection options.
        public let connectorDataSource: ConnectorDataSource?
        /// Specifies a target generated with standard connection options.
        public let connectorDataTarget: ConnectorDataTarget?
        /// Specifies a transform that uses custom code you provide to perform the data transformation. The output is a collection of DynamicFrames.
        public let customCode: CustomCode?
        public let directJDBCSource: DirectJDBCSource?
        /// Specifies an Apache Kafka data store.
        public let directKafkaSource: DirectKafkaSource?
        /// Specifies a direct Amazon Kinesis data source.
        public let directKinesisSource: DirectKinesisSource?
        /// Specifies a transform that removes rows of repeating data from a data set.
        public let dropDuplicates: DropDuplicates?
        /// Specifies a transform that chooses the data property keys that you want to drop.
        public let dropFields: DropFields?
        /// Specifies a transform that removes columns from the dataset if all values in the column are 'null'. By default, Glue Studio will recognize null objects, but some values such as empty strings, strings that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized as nulls.
        public let dropNullFields: DropNullFields?
        /// Specifies a custom visual transform created by a user.
        public let dynamicTransform: DynamicTransform?
        /// Specifies a DynamoDBC Catalog data store in the Glue Data Catalog.
        public let dynamoDBCatalogSource: DynamoDBCatalogSource?
        /// Specifies your data quality evaluation criteria.
        public let evaluateDataQuality: EvaluateDataQuality?
        /// Specifies your data quality evaluation criteria. Allows multiple input data and returns a collection of Dynamic Frames.
        public let evaluateDataQualityMultiFrame: EvaluateDataQualityMultiFrame?
        /// Specifies a transform that locates records in the dataset that have missing values and adds a new field with a value determined by imputation. The input data set is used to train the machine learning model that determines what the missing value should be.
        public let fillMissingValues: FillMissingValues?
        /// Specifies a transform that splits a dataset into two, based on a filter condition.
        public let filter: Filter?
        /// Specifies a data source in a goverened Data Catalog.
        public let governedCatalogSource: GovernedCatalogSource?
        /// Specifies a data target that writes to a goverened catalog.
        public let governedCatalogTarget: GovernedCatalogTarget?
        /// Specifies a connector to a JDBC data source.
        public let jdbcConnectorSource: JDBCConnectorSource?
        /// Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.
        public let jdbcConnectorTarget: JDBCConnectorTarget?
        /// Specifies a transform that joins two datasets into one dataset using a comparison phrase on the specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.
        public let join: Join?
        /// Specifies a transform that merges a DynamicFrame with a staging DynamicFrame based on the specified primary keys to identify records. Duplicate records (records with the same primary keys) are not de-duplicated.
        public let merge: Merge?
        /// Specifies a Microsoft SQL server data source in the Glue Data Catalog.
        public let microsoftSQLServerCatalogSource: MicrosoftSQLServerCatalogSource?
        /// Specifies a target that uses Microsoft SQL.
        public let microsoftSQLServerCatalogTarget: MicrosoftSQLServerCatalogTarget?
        /// Specifies a MySQL data source in the Glue Data Catalog.
        public let mySQLCatalogSource: MySQLCatalogSource?
        /// Specifies a target that uses MySQL.
        public let mySQLCatalogTarget: MySQLCatalogTarget?
        /// Specifies an Oracle data source in the Glue Data Catalog.
        public let oracleSQLCatalogSource: OracleSQLCatalogSource?
        /// Specifies a target that uses Oracle SQL.
        public let oracleSQLCatalogTarget: OracleSQLCatalogTarget?
        /// Specifies a transform that identifies, removes or masks PII data.
        public let piiDetection: PIIDetection?
        /// Specifies a PostgresSQL data source in the Glue Data Catalog.
        public let postgreSQLCatalogSource: PostgreSQLCatalogSource?
        /// Specifies a target that uses Postgres SQL.
        public let postgreSQLCatalogTarget: PostgreSQLCatalogTarget?
        /// Specifies a Glue DataBrew recipe node.
        public let recipe: Recipe?
        /// Specifies an Amazon Redshift data store.
        public let redshiftSource: RedshiftSource?
        /// Specifies a target that uses Amazon Redshift.
        public let redshiftTarget: RedshiftTarget?
        /// Specifies a relational catalog data store in the Glue Data Catalog.
        public let relationalCatalogSource: RelationalCatalogSource?
        /// Specifies a transform that renames a single data property key.
        public let renameField: RenameField?
        /// Specifies a Delta Lake data source that is registered in the Glue Data Catalog. The data source must be stored in Amazon S3.
        public let s3CatalogDeltaSource: S3CatalogDeltaSource?
        /// Specifies a Hudi data source that is registered in the Glue Data Catalog. The data source must be stored in Amazon S3.
        public let s3CatalogHudiSource: S3CatalogHudiSource?
        /// Specifies an Amazon S3 data store in the Glue Data Catalog.
        public let s3CatalogSource: S3CatalogSource?
        /// Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
        public let s3CatalogTarget: S3CatalogTarget?
        /// Specifies a command-separated value (CSV) data store stored in Amazon S3.
        public let s3CsvSource: S3CsvSource?
        /// Specifies a target that writes to a Delta Lake data source in the Glue Data Catalog.
        public let s3DeltaCatalogTarget: S3DeltaCatalogTarget?
        /// Specifies a target that writes to a Delta Lake data source in Amazon S3.
        public let s3DeltaDirectTarget: S3DeltaDirectTarget?
        /// Specifies a Delta Lake data source stored in Amazon S3.
        public let s3DeltaSource: S3DeltaSource?
        /// Specifies a data target that writes to Amazon S3.
        public let s3DirectTarget: S3DirectTarget?
        /// Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.
        public let s3GlueParquetTarget: S3GlueParquetTarget?
        /// Specifies a target that writes to a Hudi data source in the Glue Data Catalog.
        public let s3HudiCatalogTarget: S3HudiCatalogTarget?
        /// Specifies a target that writes to a Hudi data source in Amazon S3.
        public let s3HudiDirectTarget: S3HudiDirectTarget?
        /// Specifies a Hudi data source stored in Amazon S3.
        public let s3HudiSource: S3HudiSource?
        /// Specifies a JSON data store stored in Amazon S3.
        public let s3JsonSource: S3JsonSource?
        /// Specifies an Apache Parquet data store stored in Amazon S3.
        public let s3ParquetSource: S3ParquetSource?
        /// Specifies a transform that chooses the data property keys that you want to keep.
        public let selectFields: SelectFields?
        /// Specifies a transform that chooses one DynamicFrame from a collection of DynamicFrames. The output is the selected DynamicFrame
        public let selectFromCollection: SelectFromCollection?
        /// Specifies a Snowflake data source.
        public let snowflakeSource: SnowflakeSource?
        /// Specifies a target that writes to a Snowflake data source.
        public let snowflakeTarget: SnowflakeTarget?
        /// Specifies a connector to an Apache Spark data source.
        public let sparkConnectorSource: SparkConnectorSource?
        /// Specifies a target that uses an Apache Spark connector.
        public let sparkConnectorTarget: SparkConnectorTarget?
        /// Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The output is a single DynamicFrame.
        public let sparkSQL: SparkSQL?
        /// Specifies a transform that writes samples of the data to an Amazon S3 bucket.
        public let spigot: Spigot?
        /// Specifies a transform that splits data property keys into two DynamicFrames. The output is a collection of DynamicFrames: one with selected data property keys, and one with the remaining data property keys.
        public let splitFields: SplitFields?
        /// Specifies a transform that combines the rows from two or more datasets into a single result.
        public let union: Union?

        @inlinable
        public init(aggregate: Aggregate? = nil, amazonRedshiftSource: AmazonRedshiftSource? = nil, amazonRedshiftTarget: AmazonRedshiftTarget? = nil, applyMapping: ApplyMapping? = nil, athenaConnectorSource: AthenaConnectorSource? = nil, catalogDeltaSource: CatalogDeltaSource? = nil, catalogHudiSource: CatalogHudiSource? = nil, catalogKafkaSource: CatalogKafkaSource? = nil, catalogKinesisSource: CatalogKinesisSource? = nil, catalogSource: CatalogSource? = nil, catalogTarget: BasicCatalogTarget? = nil, connectorDataSource: ConnectorDataSource? = nil, connectorDataTarget: ConnectorDataTarget? = nil, customCode: CustomCode? = nil, directJDBCSource: DirectJDBCSource? = nil, directKafkaSource: DirectKafkaSource? = nil, directKinesisSource: DirectKinesisSource? = nil, dropDuplicates: DropDuplicates? = nil, dropFields: DropFields? = nil, dropNullFields: DropNullFields? = nil, dynamicTransform: DynamicTransform? = nil, dynamoDBCatalogSource: DynamoDBCatalogSource? = nil, evaluateDataQuality: EvaluateDataQuality? = nil, evaluateDataQualityMultiFrame: EvaluateDataQualityMultiFrame? = nil, fillMissingValues: FillMissingValues? = nil, filter: Filter? = nil, governedCatalogSource: GovernedCatalogSource? = nil, governedCatalogTarget: GovernedCatalogTarget? = nil, jdbcConnectorSource: JDBCConnectorSource? = nil, jdbcConnectorTarget: JDBCConnectorTarget? = nil, join: Join? = nil, merge: Merge? = nil, microsoftSQLServerCatalogSource: MicrosoftSQLServerCatalogSource? = nil, microsoftSQLServerCatalogTarget: MicrosoftSQLServerCatalogTarget? = nil, mySQLCatalogSource: MySQLCatalogSource? = nil, mySQLCatalogTarget: MySQLCatalogTarget? = nil, oracleSQLCatalogSource: OracleSQLCatalogSource? = nil, oracleSQLCatalogTarget: OracleSQLCatalogTarget? = nil, piiDetection: PIIDetection? = nil, postgreSQLCatalogSource: PostgreSQLCatalogSource? = nil, postgreSQLCatalogTarget: PostgreSQLCatalogTarget? = nil, recipe: Recipe? = nil, redshiftSource: RedshiftSource? = nil, redshiftTarget: RedshiftTarget? = nil, relationalCatalogSource: RelationalCatalogSource? = nil, renameField: RenameField? = nil, s3CatalogDeltaSource: S3CatalogDeltaSource? = nil, s3CatalogHudiSource: S3CatalogHudiSource? = nil, s3CatalogSource: S3CatalogSource? = nil, s3CatalogTarget: S3CatalogTarget? = nil, s3CsvSource: S3CsvSource? = nil, s3DeltaCatalogTarget: S3DeltaCatalogTarget? = nil, s3DeltaDirectTarget: S3DeltaDirectTarget? = nil, s3DeltaSource: S3DeltaSource? = nil, s3DirectTarget: S3DirectTarget? = nil, s3GlueParquetTarget: S3GlueParquetTarget? = nil, s3HudiCatalogTarget: S3HudiCatalogTarget? = nil, s3HudiDirectTarget: S3HudiDirectTarget? = nil, s3HudiSource: S3HudiSource? = nil, s3JsonSource: S3JsonSource? = nil, s3ParquetSource: S3ParquetSource? = nil, selectFields: SelectFields? = nil, selectFromCollection: SelectFromCollection? = nil, snowflakeSource: SnowflakeSource? = nil, snowflakeTarget: SnowflakeTarget? = nil, sparkConnectorSource: SparkConnectorSource? = nil, sparkConnectorTarget: SparkConnectorTarget? = nil, sparkSQL: SparkSQL? = nil, spigot: Spigot? = nil, splitFields: SplitFields? = nil, union: Union? = nil) {
            self.aggregate = aggregate
            self.amazonRedshiftSource = amazonRedshiftSource
            self.amazonRedshiftTarget = amazonRedshiftTarget
            self.applyMapping = applyMapping
            self.athenaConnectorSource = athenaConnectorSource
            self.catalogDeltaSource = catalogDeltaSource
            self.catalogHudiSource = catalogHudiSource
            self.catalogKafkaSource = catalogKafkaSource
            self.catalogKinesisSource = catalogKinesisSource
            self.catalogSource = catalogSource
            self.catalogTarget = catalogTarget
            self.connectorDataSource = connectorDataSource
            self.connectorDataTarget = connectorDataTarget
            self.customCode = customCode
            self.directJDBCSource = directJDBCSource
            self.directKafkaSource = directKafkaSource
            self.directKinesisSource = directKinesisSource
            self.dropDuplicates = dropDuplicates
            self.dropFields = dropFields
            self.dropNullFields = dropNullFields
            self.dynamicTransform = dynamicTransform
            self.dynamoDBCatalogSource = dynamoDBCatalogSource
            self.evaluateDataQuality = evaluateDataQuality
            self.evaluateDataQualityMultiFrame = evaluateDataQualityMultiFrame
            self.fillMissingValues = fillMissingValues
            self.filter = filter
            self.governedCatalogSource = governedCatalogSource
            self.governedCatalogTarget = governedCatalogTarget
            self.jdbcConnectorSource = jdbcConnectorSource
            self.jdbcConnectorTarget = jdbcConnectorTarget
            self.join = join
            self.merge = merge
            self.microsoftSQLServerCatalogSource = microsoftSQLServerCatalogSource
            self.microsoftSQLServerCatalogTarget = microsoftSQLServerCatalogTarget
            self.mySQLCatalogSource = mySQLCatalogSource
            self.mySQLCatalogTarget = mySQLCatalogTarget
            self.oracleSQLCatalogSource = oracleSQLCatalogSource
            self.oracleSQLCatalogTarget = oracleSQLCatalogTarget
            self.piiDetection = piiDetection
            self.postgreSQLCatalogSource = postgreSQLCatalogSource
            self.postgreSQLCatalogTarget = postgreSQLCatalogTarget
            self.recipe = recipe
            self.redshiftSource = redshiftSource
            self.redshiftTarget = redshiftTarget
            self.relationalCatalogSource = relationalCatalogSource
            self.renameField = renameField
            self.s3CatalogDeltaSource = s3CatalogDeltaSource
            self.s3CatalogHudiSource = s3CatalogHudiSource
            self.s3CatalogSource = s3CatalogSource
            self.s3CatalogTarget = s3CatalogTarget
            self.s3CsvSource = s3CsvSource
            self.s3DeltaCatalogTarget = s3DeltaCatalogTarget
            self.s3DeltaDirectTarget = s3DeltaDirectTarget
            self.s3DeltaSource = s3DeltaSource
            self.s3DirectTarget = s3DirectTarget
            self.s3GlueParquetTarget = s3GlueParquetTarget
            self.s3HudiCatalogTarget = s3HudiCatalogTarget
            self.s3HudiDirectTarget = s3HudiDirectTarget
            self.s3HudiSource = s3HudiSource
            self.s3JsonSource = s3JsonSource
            self.s3ParquetSource = s3ParquetSource
            self.selectFields = selectFields
            self.selectFromCollection = selectFromCollection
            self.snowflakeSource = snowflakeSource
            self.snowflakeTarget = snowflakeTarget
            self.sparkConnectorSource = sparkConnectorSource
            self.sparkConnectorTarget = sparkConnectorTarget
            self.sparkSQL = sparkSQL
            self.spigot = spigot
            self.splitFields = splitFields
            self.union = union
        }

        public func validate(name: String) throws {
            try self.aggregate?.validate(name: "\(name).aggregate")
            try self.amazonRedshiftSource?.validate(name: "\(name).amazonRedshiftSource")
            try self.amazonRedshiftTarget?.validate(name: "\(name).amazonRedshiftTarget")
            try self.applyMapping?.validate(name: "\(name).applyMapping")
            try self.athenaConnectorSource?.validate(name: "\(name).athenaConnectorSource")
            try self.catalogDeltaSource?.validate(name: "\(name).catalogDeltaSource")
            try self.catalogHudiSource?.validate(name: "\(name).catalogHudiSource")
            try self.catalogKafkaSource?.validate(name: "\(name).catalogKafkaSource")
            try self.catalogKinesisSource?.validate(name: "\(name).catalogKinesisSource")
            try self.catalogSource?.validate(name: "\(name).catalogSource")
            try self.catalogTarget?.validate(name: "\(name).catalogTarget")
            try self.connectorDataSource?.validate(name: "\(name).connectorDataSource")
            try self.connectorDataTarget?.validate(name: "\(name).connectorDataTarget")
            try self.customCode?.validate(name: "\(name).customCode")
            try self.directJDBCSource?.validate(name: "\(name).directJDBCSource")
            try self.directKafkaSource?.validate(name: "\(name).directKafkaSource")
            try self.directKinesisSource?.validate(name: "\(name).directKinesisSource")
            try self.dropDuplicates?.validate(name: "\(name).dropDuplicates")
            try self.dropFields?.validate(name: "\(name).dropFields")
            try self.dropNullFields?.validate(name: "\(name).dropNullFields")
            try self.dynamicTransform?.validate(name: "\(name).dynamicTransform")
            try self.dynamoDBCatalogSource?.validate(name: "\(name).dynamoDBCatalogSource")
            try self.evaluateDataQuality?.validate(name: "\(name).evaluateDataQuality")
            try self.evaluateDataQualityMultiFrame?.validate(name: "\(name).evaluateDataQualityMultiFrame")
            try self.fillMissingValues?.validate(name: "\(name).fillMissingValues")
            try self.filter?.validate(name: "\(name).filter")
            try self.governedCatalogSource?.validate(name: "\(name).governedCatalogSource")
            try self.governedCatalogTarget?.validate(name: "\(name).governedCatalogTarget")
            try self.jdbcConnectorSource?.validate(name: "\(name).jdbcConnectorSource")
            try self.jdbcConnectorTarget?.validate(name: "\(name).jdbcConnectorTarget")
            try self.join?.validate(name: "\(name).join")
            try self.merge?.validate(name: "\(name).merge")
            try self.microsoftSQLServerCatalogSource?.validate(name: "\(name).microsoftSQLServerCatalogSource")
            try self.microsoftSQLServerCatalogTarget?.validate(name: "\(name).microsoftSQLServerCatalogTarget")
            try self.mySQLCatalogSource?.validate(name: "\(name).mySQLCatalogSource")
            try self.mySQLCatalogTarget?.validate(name: "\(name).mySQLCatalogTarget")
            try self.oracleSQLCatalogSource?.validate(name: "\(name).oracleSQLCatalogSource")
            try self.oracleSQLCatalogTarget?.validate(name: "\(name).oracleSQLCatalogTarget")
            try self.piiDetection?.validate(name: "\(name).piiDetection")
            try self.postgreSQLCatalogSource?.validate(name: "\(name).postgreSQLCatalogSource")
            try self.postgreSQLCatalogTarget?.validate(name: "\(name).postgreSQLCatalogTarget")
            try self.recipe?.validate(name: "\(name).recipe")
            try self.redshiftSource?.validate(name: "\(name).redshiftSource")
            try self.redshiftTarget?.validate(name: "\(name).redshiftTarget")
            try self.relationalCatalogSource?.validate(name: "\(name).relationalCatalogSource")
            try self.renameField?.validate(name: "\(name).renameField")
            try self.s3CatalogDeltaSource?.validate(name: "\(name).s3CatalogDeltaSource")
            try self.s3CatalogHudiSource?.validate(name: "\(name).s3CatalogHudiSource")
            try self.s3CatalogSource?.validate(name: "\(name).s3CatalogSource")
            try self.s3CatalogTarget?.validate(name: "\(name).s3CatalogTarget")
            try self.s3CsvSource?.validate(name: "\(name).s3CsvSource")
            try self.s3DeltaCatalogTarget?.validate(name: "\(name).s3DeltaCatalogTarget")
            try self.s3DeltaDirectTarget?.validate(name: "\(name).s3DeltaDirectTarget")
            try self.s3DeltaSource?.validate(name: "\(name).s3DeltaSource")
            try self.s3DirectTarget?.validate(name: "\(name).s3DirectTarget")
            try self.s3GlueParquetTarget?.validate(name: "\(name).s3GlueParquetTarget")
            try self.s3HudiCatalogTarget?.validate(name: "\(name).s3HudiCatalogTarget")
            try self.s3HudiDirectTarget?.validate(name: "\(name).s3HudiDirectTarget")
            try self.s3HudiSource?.validate(name: "\(name).s3HudiSource")
            try self.s3JsonSource?.validate(name: "\(name).s3JsonSource")
            try self.s3ParquetSource?.validate(name: "\(name).s3ParquetSource")
            try self.selectFields?.validate(name: "\(name).selectFields")
            try self.selectFromCollection?.validate(name: "\(name).selectFromCollection")
            try self.snowflakeSource?.validate(name: "\(name).snowflakeSource")
            try self.snowflakeTarget?.validate(name: "\(name).snowflakeTarget")
            try self.sparkConnectorSource?.validate(name: "\(name).sparkConnectorSource")
            try self.sparkConnectorTarget?.validate(name: "\(name).sparkConnectorTarget")
            try self.sparkSQL?.validate(name: "\(name).sparkSQL")
            try self.spigot?.validate(name: "\(name).spigot")
            try self.splitFields?.validate(name: "\(name).splitFields")
            try self.union?.validate(name: "\(name).union")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregate = "Aggregate"
            case amazonRedshiftSource = "AmazonRedshiftSource"
            case amazonRedshiftTarget = "AmazonRedshiftTarget"
            case applyMapping = "ApplyMapping"
            case athenaConnectorSource = "AthenaConnectorSource"
            case catalogDeltaSource = "CatalogDeltaSource"
            case catalogHudiSource = "CatalogHudiSource"
            case catalogKafkaSource = "CatalogKafkaSource"
            case catalogKinesisSource = "CatalogKinesisSource"
            case catalogSource = "CatalogSource"
            case catalogTarget = "CatalogTarget"
            case connectorDataSource = "ConnectorDataSource"
            case connectorDataTarget = "ConnectorDataTarget"
            case customCode = "CustomCode"
            case directJDBCSource = "DirectJDBCSource"
            case directKafkaSource = "DirectKafkaSource"
            case directKinesisSource = "DirectKinesisSource"
            case dropDuplicates = "DropDuplicates"
            case dropFields = "DropFields"
            case dropNullFields = "DropNullFields"
            case dynamicTransform = "DynamicTransform"
            case dynamoDBCatalogSource = "DynamoDBCatalogSource"
            case evaluateDataQuality = "EvaluateDataQuality"
            case evaluateDataQualityMultiFrame = "EvaluateDataQualityMultiFrame"
            case fillMissingValues = "FillMissingValues"
            case filter = "Filter"
            case governedCatalogSource = "GovernedCatalogSource"
            case governedCatalogTarget = "GovernedCatalogTarget"
            case jdbcConnectorSource = "JDBCConnectorSource"
            case jdbcConnectorTarget = "JDBCConnectorTarget"
            case join = "Join"
            case merge = "Merge"
            case microsoftSQLServerCatalogSource = "MicrosoftSQLServerCatalogSource"
            case microsoftSQLServerCatalogTarget = "MicrosoftSQLServerCatalogTarget"
            case mySQLCatalogSource = "MySQLCatalogSource"
            case mySQLCatalogTarget = "MySQLCatalogTarget"
            case oracleSQLCatalogSource = "OracleSQLCatalogSource"
            case oracleSQLCatalogTarget = "OracleSQLCatalogTarget"
            case piiDetection = "PIIDetection"
            case postgreSQLCatalogSource = "PostgreSQLCatalogSource"
            case postgreSQLCatalogTarget = "PostgreSQLCatalogTarget"
            case recipe = "Recipe"
            case redshiftSource = "RedshiftSource"
            case redshiftTarget = "RedshiftTarget"
            case relationalCatalogSource = "RelationalCatalogSource"
            case renameField = "RenameField"
            case s3CatalogDeltaSource = "S3CatalogDeltaSource"
            case s3CatalogHudiSource = "S3CatalogHudiSource"
            case s3CatalogSource = "S3CatalogSource"
            case s3CatalogTarget = "S3CatalogTarget"
            case s3CsvSource = "S3CsvSource"
            case s3DeltaCatalogTarget = "S3DeltaCatalogTarget"
            case s3DeltaDirectTarget = "S3DeltaDirectTarget"
            case s3DeltaSource = "S3DeltaSource"
            case s3DirectTarget = "S3DirectTarget"
            case s3GlueParquetTarget = "S3GlueParquetTarget"
            case s3HudiCatalogTarget = "S3HudiCatalogTarget"
            case s3HudiDirectTarget = "S3HudiDirectTarget"
            case s3HudiSource = "S3HudiSource"
            case s3JsonSource = "S3JsonSource"
            case s3ParquetSource = "S3ParquetSource"
            case selectFields = "SelectFields"
            case selectFromCollection = "SelectFromCollection"
            case snowflakeSource = "SnowflakeSource"
            case snowflakeTarget = "SnowflakeTarget"
            case sparkConnectorSource = "SparkConnectorSource"
            case sparkConnectorTarget = "SparkConnectorTarget"
            case sparkSQL = "SparkSQL"
            case spigot = "Spigot"
            case splitFields = "SplitFields"
            case union = "Union"
        }
    }

    public struct CodeGenEdge: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the node at which the edge starts.
        public let source: String
        /// The ID of the node at which the edge ends.
        public let target: String
        /// The target of the edge.
        public let targetParameter: String?

        @inlinable
        public init(source: String, target: String, targetParameter: String? = nil) {
            self.source = source
            self.target = target
            self.targetParameter = targetParameter
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, max: 255)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^[A-Za-z_][A-Za-z0-9_]*$")
            try self.validate(self.target, name: "target", parent: name, max: 255)
            try self.validate(self.target, name: "target", parent: name, min: 1)
            try self.validate(self.target, name: "target", parent: name, pattern: "^[A-Za-z_][A-Za-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "Source"
            case target = "Target"
            case targetParameter = "TargetParameter"
        }
    }

    public struct CodeGenNode: AWSEncodableShape & AWSDecodableShape {
        /// Properties of the node, in the form of name-value pairs.
        public let args: [CodeGenNodeArg]
        /// A node identifier that is unique within the node's graph.
        public let id: String
        /// The line number of the node.
        public let lineNumber: Int?
        /// The type of node that this is.
        public let nodeType: String

        @inlinable
        public init(args: [CodeGenNodeArg], id: String, lineNumber: Int? = nil, nodeType: String) {
            self.args = args
            self.id = id
            self.lineNumber = lineNumber
            self.nodeType = nodeType
        }

        public func validate(name: String) throws {
            try self.validate(self.args, name: "args", parent: name, max: 50)
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[A-Za-z_][A-Za-z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case args = "Args"
            case id = "Id"
            case lineNumber = "LineNumber"
            case nodeType = "NodeType"
        }
    }

    public struct CodeGenNodeArg: AWSEncodableShape & AWSDecodableShape {
        /// The name of the argument or property.
        public let name: String
        /// True if the value is used as a parameter.
        public let param: Bool?
        /// The value of the argument or property.
        public let value: String

        @inlinable
        public init(name: String, param: Bool? = nil, value: String) {
            self.name = name
            self.param = param
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case param = "Param"
            case value = "Value"
        }
    }

    public struct Column: AWSEncodableShape & AWSDecodableShape {
        /// A free-form text comment.
        public let comment: String?
        /// The name of the Column.
        public let name: String
        /// These key-value pairs define properties associated with the column.
        public let parameters: [String: String]?
        /// The data type of the Column.
        public let type: String?

        @inlinable
        public init(comment: String? = nil, name: String, parameters: [String: String]? = nil, type: String? = nil) {
            self.comment = comment
            self.name = name
            self.parameters = parameters
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 255)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512000)
            }
            try self.validate(self.type, name: "type", parent: name, max: 131072)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "Comment"
            case name = "Name"
            case parameters = "Parameters"
            case type = "Type"
        }
    }

    public struct ColumnError: AWSDecodableShape {
        /// The name of the column that failed.
        public let columnName: String?
        /// An error message with the reason for the failure of an operation.
        public let error: ErrorDetail?

        @inlinable
        public init(columnName: String? = nil, error: ErrorDetail? = nil) {
            self.columnName = columnName
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case error = "Error"
        }
    }

    public struct ColumnImportance: AWSDecodableShape {
        /// The name of a column.
        public let columnName: String?
        /// The column importance score for the column, as a decimal.
        public let importance: Double?

        @inlinable
        public init(columnName: String? = nil, importance: Double? = nil) {
            self.columnName = columnName
            self.importance = importance
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case importance = "Importance"
        }
    }

    public struct ColumnRowFilter: AWSDecodableShape {
        /// A string containing the name of the column.
        public let columnName: String?
        /// A string containing the row-level filter expression.
        public let rowFilterExpression: String?

        @inlinable
        public init(columnName: String? = nil, rowFilterExpression: String? = nil) {
            self.columnName = columnName
            self.rowFilterExpression = rowFilterExpression
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case rowFilterExpression = "RowFilterExpression"
        }
    }

    public struct ColumnStatistics: AWSEncodableShape & AWSDecodableShape {
        /// The timestamp of when column statistics were generated.
        public let analyzedTime: Date
        /// Name of column which statistics belong to.
        public let columnName: String
        /// The data type of the column.
        public let columnType: String
        /// A ColumnStatisticData object that contains the statistics data values.
        public let statisticsData: ColumnStatisticsData

        @inlinable
        public init(analyzedTime: Date, columnName: String, columnType: String, statisticsData: ColumnStatisticsData) {
            self.analyzedTime = analyzedTime
            self.columnName = columnName
            self.columnType = columnType
            self.statisticsData = statisticsData
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 255)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.columnType, name: "columnType", parent: name, max: 20000)
            try self.validate(self.columnType, name: "columnType", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.statisticsData.validate(name: "\(name).statisticsData")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzedTime = "AnalyzedTime"
            case columnName = "ColumnName"
            case columnType = "ColumnType"
            case statisticsData = "StatisticsData"
        }
    }

    public struct ColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// Binary column statistics data.
        public let binaryColumnStatisticsData: BinaryColumnStatisticsData?
        /// Boolean column statistics data.
        public let booleanColumnStatisticsData: BooleanColumnStatisticsData?
        /// Date column statistics data.
        public let dateColumnStatisticsData: DateColumnStatisticsData?
        ///  Decimal column statistics data. UnscaledValues within are Base64-encoded binary objects storing big-endian, two's complement representations of the decimal's unscaled value.
        public let decimalColumnStatisticsData: DecimalColumnStatisticsData?
        /// Double column statistics data.
        public let doubleColumnStatisticsData: DoubleColumnStatisticsData?
        /// Long column statistics data.
        public let longColumnStatisticsData: LongColumnStatisticsData?
        /// String column statistics data.
        public let stringColumnStatisticsData: StringColumnStatisticsData?
        /// The type of column statistics data.
        public let type: ColumnStatisticsType

        @inlinable
        public init(binaryColumnStatisticsData: BinaryColumnStatisticsData? = nil, booleanColumnStatisticsData: BooleanColumnStatisticsData? = nil, dateColumnStatisticsData: DateColumnStatisticsData? = nil, decimalColumnStatisticsData: DecimalColumnStatisticsData? = nil, doubleColumnStatisticsData: DoubleColumnStatisticsData? = nil, longColumnStatisticsData: LongColumnStatisticsData? = nil, stringColumnStatisticsData: StringColumnStatisticsData? = nil, type: ColumnStatisticsType) {
            self.binaryColumnStatisticsData = binaryColumnStatisticsData
            self.booleanColumnStatisticsData = booleanColumnStatisticsData
            self.dateColumnStatisticsData = dateColumnStatisticsData
            self.decimalColumnStatisticsData = decimalColumnStatisticsData
            self.doubleColumnStatisticsData = doubleColumnStatisticsData
            self.longColumnStatisticsData = longColumnStatisticsData
            self.stringColumnStatisticsData = stringColumnStatisticsData
            self.type = type
        }

        public func validate(name: String) throws {
            try self.binaryColumnStatisticsData?.validate(name: "\(name).binaryColumnStatisticsData")
            try self.booleanColumnStatisticsData?.validate(name: "\(name).booleanColumnStatisticsData")
            try self.dateColumnStatisticsData?.validate(name: "\(name).dateColumnStatisticsData")
            try self.decimalColumnStatisticsData?.validate(name: "\(name).decimalColumnStatisticsData")
            try self.doubleColumnStatisticsData?.validate(name: "\(name).doubleColumnStatisticsData")
            try self.longColumnStatisticsData?.validate(name: "\(name).longColumnStatisticsData")
            try self.stringColumnStatisticsData?.validate(name: "\(name).stringColumnStatisticsData")
        }

        private enum CodingKeys: String, CodingKey {
            case binaryColumnStatisticsData = "BinaryColumnStatisticsData"
            case booleanColumnStatisticsData = "BooleanColumnStatisticsData"
            case dateColumnStatisticsData = "DateColumnStatisticsData"
            case decimalColumnStatisticsData = "DecimalColumnStatisticsData"
            case doubleColumnStatisticsData = "DoubleColumnStatisticsData"
            case longColumnStatisticsData = "LongColumnStatisticsData"
            case stringColumnStatisticsData = "StringColumnStatisticsData"
            case type = "Type"
        }
    }

    public struct ColumnStatisticsError: AWSDecodableShape {
        /// The ColumnStatistics of the column.
        public let columnStatistics: ColumnStatistics?
        /// An error message with the reason for the failure of an operation.
        public let error: ErrorDetail?

        @inlinable
        public init(columnStatistics: ColumnStatistics? = nil, error: ErrorDetail? = nil) {
            self.columnStatistics = columnStatistics
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatistics = "ColumnStatistics"
            case error = "Error"
        }
    }

    public struct ColumnStatisticsTaskRun: AWSDecodableShape {
        /// The ID of the Data Catalog where the table resides. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogID: String?
        /// A list of the column names. If none is supplied, all column names for the table will be used by default.
        public let columnNameList: [String]?
        /// The identifier for the particular column statistics task run.
        public let columnStatisticsTaskRunId: String?
        /// The type of column statistics computation.
        public let computationType: ComputationType?
        /// The time that this task was created.
        public let creationTime: Date?
        /// The Amazon Web Services account ID.
        public let customerId: String?
        /// The database where the table resides.
        public let databaseName: String?
        /// The calculated DPU usage in seconds for all autoscaled workers.
        public let dpuSeconds: Double?
        /// The end time of the task.
        public let endTime: Date?
        /// The error message for the job.
        public let errorMessage: String?
        /// The last point in time when this task was modified.
        public let lastUpdated: Date?
        /// The number of workers used to generate column statistics. The job is preconfigured to autoscale up to 25 instances.
        public let numberOfWorkers: Int?
        /// The IAM role that the service assumes to generate statistics.
        public let role: String?
        /// The percentage of rows used to generate statistics. If none is supplied, the entire table will be used to generate stats.
        public let sampleSize: Double?
        /// Name of the security configuration that is used to encrypt CloudWatch logs for the column stats task run.
        public let securityConfiguration: String?
        /// The start time of the task.
        public let startTime: Date?
        /// The status of the task run.
        public let status: ColumnStatisticsState?
        /// The name of the table for which column statistics is generated.
        public let tableName: String?
        /// The type of workers being used for generating stats. The default is g.1x.
        public let workerType: String?

        @inlinable
        public init(catalogID: String? = nil, columnNameList: [String]? = nil, columnStatisticsTaskRunId: String? = nil, computationType: ComputationType? = nil, creationTime: Date? = nil, customerId: String? = nil, databaseName: String? = nil, dpuSeconds: Double? = nil, endTime: Date? = nil, errorMessage: String? = nil, lastUpdated: Date? = nil, numberOfWorkers: Int? = nil, role: String? = nil, sampleSize: Double? = nil, securityConfiguration: String? = nil, startTime: Date? = nil, status: ColumnStatisticsState? = nil, tableName: String? = nil, workerType: String? = nil) {
            self.catalogID = catalogID
            self.columnNameList = columnNameList
            self.columnStatisticsTaskRunId = columnStatisticsTaskRunId
            self.computationType = computationType
            self.creationTime = creationTime
            self.customerId = customerId
            self.databaseName = databaseName
            self.dpuSeconds = dpuSeconds
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.lastUpdated = lastUpdated
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.sampleSize = sampleSize
            self.securityConfiguration = securityConfiguration
            self.startTime = startTime
            self.status = status
            self.tableName = tableName
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case catalogID = "CatalogID"
            case columnNameList = "ColumnNameList"
            case columnStatisticsTaskRunId = "ColumnStatisticsTaskRunId"
            case computationType = "ComputationType"
            case creationTime = "CreationTime"
            case customerId = "CustomerId"
            case databaseName = "DatabaseName"
            case dpuSeconds = "DPUSeconds"
            case endTime = "EndTime"
            case errorMessage = "ErrorMessage"
            case lastUpdated = "LastUpdated"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case sampleSize = "SampleSize"
            case securityConfiguration = "SecurityConfiguration"
            case startTime = "StartTime"
            case status = "Status"
            case tableName = "TableName"
            case workerType = "WorkerType"
        }
    }

    public struct ColumnStatisticsTaskSettings: AWSDecodableShape {
        /// The ID of the Data Catalog in which the database resides.
        public let catalogID: String?
        /// A list of column names for which to run statistics.
        public let columnNameList: [String]?
        /// The name of the database where the table resides.
        public let databaseName: String?
        /// The last ExecutionAttempt for the column statistics task run.
        public let lastExecutionAttempt: ExecutionAttempt?
        /// The role used for running the column statistics.
        public let role: String?
        /// The percentage of data to sample.
        public let sampleSize: Double?
        /// A schedule for running the column statistics, specified in CRON syntax.
        public let schedule: Schedule?
        /// The type of schedule for a column statistics task. Possible values may be CRON or AUTO.
        public let scheduleType: ScheduleType?
        /// Name of the security configuration that is used to encrypt CloudWatch logs.
        public let securityConfiguration: String?
        /// The source of setting the column statistics task. Possible values may be CATALOG or TABLE.
        public let settingSource: SettingSource?
        /// The name of the table for which to generate column statistics.
        public let tableName: String?

        @inlinable
        public init(catalogID: String? = nil, columnNameList: [String]? = nil, databaseName: String? = nil, lastExecutionAttempt: ExecutionAttempt? = nil, role: String? = nil, sampleSize: Double? = nil, schedule: Schedule? = nil, scheduleType: ScheduleType? = nil, securityConfiguration: String? = nil, settingSource: SettingSource? = nil, tableName: String? = nil) {
            self.catalogID = catalogID
            self.columnNameList = columnNameList
            self.databaseName = databaseName
            self.lastExecutionAttempt = lastExecutionAttempt
            self.role = role
            self.sampleSize = sampleSize
            self.schedule = schedule
            self.scheduleType = scheduleType
            self.securityConfiguration = securityConfiguration
            self.settingSource = settingSource
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case catalogID = "CatalogID"
            case columnNameList = "ColumnNameList"
            case databaseName = "DatabaseName"
            case lastExecutionAttempt = "LastExecutionAttempt"
            case role = "Role"
            case sampleSize = "SampleSize"
            case schedule = "Schedule"
            case scheduleType = "ScheduleType"
            case securityConfiguration = "SecurityConfiguration"
            case settingSource = "SettingSource"
            case tableName = "TableName"
        }
    }

    public struct CompactionMetrics: AWSDecodableShape {
        /// A structure containing the Iceberg compaction metrics for the optimizer run.
        public let icebergMetrics: IcebergCompactionMetrics?

        @inlinable
        public init(icebergMetrics: IcebergCompactionMetrics? = nil) {
            self.icebergMetrics = icebergMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case icebergMetrics = "IcebergMetrics"
        }
    }

    public struct ComputeEnvironmentConfiguration: AWSDecodableShape {
        /// The type of compute environment.
        public let computeEnvironment: ComputeEnvironment
        /// The connection option name overrides for the compute environment.
        public let connectionOptionNameOverrides: [String: String]
        /// The parameters used as connection options for the compute environment.
        public let connectionOptions: [String: Property]
        /// The connection properties that are required as overrides for the compute environment.
        public let connectionPropertiesRequiredOverrides: [String]
        /// The connection property name overrides for the compute environment.
        public let connectionPropertyNameOverrides: [String: String]
        /// A description of the compute environment.
        public let description: String
        /// A name for the compute environment configuration.
        public let name: String
        /// Indicates whether PhysicalConnectionProperties are required for the compute environment.
        public let physicalConnectionPropertiesRequired: Bool?
        /// The supported authentication types for the compute environment.
        public let supportedAuthenticationTypes: [AuthenticationType]

        @inlinable
        public init(computeEnvironment: ComputeEnvironment, connectionOptionNameOverrides: [String: String], connectionOptions: [String: Property], connectionPropertiesRequiredOverrides: [String], connectionPropertyNameOverrides: [String: String], description: String, name: String, physicalConnectionPropertiesRequired: Bool? = nil, supportedAuthenticationTypes: [AuthenticationType]) {
            self.computeEnvironment = computeEnvironment
            self.connectionOptionNameOverrides = connectionOptionNameOverrides
            self.connectionOptions = connectionOptions
            self.connectionPropertiesRequiredOverrides = connectionPropertiesRequiredOverrides
            self.connectionPropertyNameOverrides = connectionPropertyNameOverrides
            self.description = description
            self.name = name
            self.physicalConnectionPropertiesRequired = physicalConnectionPropertiesRequired
            self.supportedAuthenticationTypes = supportedAuthenticationTypes
        }

        private enum CodingKeys: String, CodingKey {
            case computeEnvironment = "ComputeEnvironment"
            case connectionOptionNameOverrides = "ConnectionOptionNameOverrides"
            case connectionOptions = "ConnectionOptions"
            case connectionPropertiesRequiredOverrides = "ConnectionPropertiesRequiredOverrides"
            case connectionPropertyNameOverrides = "ConnectionPropertyNameOverrides"
            case description = "Description"
            case name = "Name"
            case physicalConnectionPropertiesRequired = "PhysicalConnectionPropertiesRequired"
            case supportedAuthenticationTypes = "SupportedAuthenticationTypes"
        }
    }

    public struct Condition: AWSEncodableShape & AWSDecodableShape {
        /// The name of the crawler to which this condition applies.
        public let crawlerName: String?
        /// The state of the crawler to which this condition applies.
        public let crawlState: CrawlState?
        /// The name of the job whose JobRuns this condition applies to, and on which this trigger waits.
        public let jobName: String?
        /// A logical operator.
        public let logicalOperator: LogicalOperator?
        /// The condition state. Currently, the only job states that a trigger can listen for are SUCCEEDED, STOPPED, FAILED, and TIMEOUT. The only crawler states that a trigger can listen for are SUCCEEDED, FAILED, and CANCELLED.
        public let state: JobRunState?

        @inlinable
        public init(crawlerName: String? = nil, crawlState: CrawlState? = nil, jobName: String? = nil, logicalOperator: LogicalOperator? = nil, state: JobRunState? = nil) {
            self.crawlerName = crawlerName
            self.crawlState = crawlState
            self.jobName = jobName
            self.logicalOperator = logicalOperator
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
            case crawlState = "CrawlState"
            case jobName = "JobName"
            case logicalOperator = "LogicalOperator"
            case state = "State"
        }
    }

    public struct ConditionExpression: AWSEncodableShape & AWSDecodableShape {
        /// The condition of the condition expression.
        public let condition: String
        /// The target column of the condition expressions.
        public let targetColumn: String
        /// The value of the condition expression.
        public let value: String?

        @inlinable
        public init(condition: String, targetColumn: String, value: String? = nil) {
            self.condition = condition
            self.targetColumn = targetColumn
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.condition, name: "condition", parent: name, max: 128)
            try self.validate(self.condition, name: "condition", parent: name, min: 1)
            try self.validate(self.condition, name: "condition", parent: name, pattern: "^[A-Z\\_]+$")
            try self.validate(self.targetColumn, name: "targetColumn", parent: name, max: 1024)
            try self.validate(self.targetColumn, name: "targetColumn", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case targetColumn = "TargetColumn"
            case value = "Value"
        }
    }

    public struct ConfigurationObject: AWSEncodableShape & AWSDecodableShape {
        /// A list of allowed values for the parameter.
        public let allowedValues: [String]?
        /// A default value for the parameter.
        public let defaultValue: String?
        /// A maximum allowed value for the parameter.
        public let maxValue: String?
        /// A minimum allowed value for the parameter.
        public let minValue: String?

        @inlinable
        public init(allowedValues: [String]? = nil, defaultValue: String? = nil, maxValue: String? = nil, minValue: String? = nil) {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
            self.maxValue = maxValue
            self.minValue = minValue
        }

        public func validate(name: String) throws {
            try self.allowedValues?.forEach {
                try validate($0, name: "allowedValues[]", parent: name, max: 128)
                try validate($0, name: "allowedValues[]", parent: name, min: 1)
                try validate($0, name: "allowedValues[]", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            }
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 128)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, min: 1)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.maxValue, name: "maxValue", parent: name, max: 128)
            try self.validate(self.maxValue, name: "maxValue", parent: name, min: 1)
            try self.validate(self.maxValue, name: "maxValue", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.minValue, name: "minValue", parent: name, max: 128)
            try self.validate(self.minValue, name: "minValue", parent: name, min: 1)
            try self.validate(self.minValue, name: "minValue", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "AllowedValues"
            case defaultValue = "DefaultValue"
            case maxValue = "MaxValue"
            case minValue = "MinValue"
        }
    }

    public struct ConfusionMatrix: AWSDecodableShape {
        /// The number of matches in the data that the transform didn't find, in the confusion matrix for your transform.
        public let numFalseNegatives: Int64?
        /// The number of nonmatches in the data that the transform incorrectly classified as a match, in the confusion matrix for your transform.
        public let numFalsePositives: Int64?
        /// The number of nonmatches in the data that the transform correctly rejected, in the confusion matrix for your transform.
        public let numTrueNegatives: Int64?
        /// The number of matches in the data that the transform correctly found, in the confusion matrix for your transform.
        public let numTruePositives: Int64?

        @inlinable
        public init(numFalseNegatives: Int64? = nil, numFalsePositives: Int64? = nil, numTrueNegatives: Int64? = nil, numTruePositives: Int64? = nil) {
            self.numFalseNegatives = numFalseNegatives
            self.numFalsePositives = numFalsePositives
            self.numTrueNegatives = numTrueNegatives
            self.numTruePositives = numTruePositives
        }

        private enum CodingKeys: String, CodingKey {
            case numFalseNegatives = "NumFalseNegatives"
            case numFalsePositives = "NumFalsePositives"
            case numTrueNegatives = "NumTrueNegatives"
            case numTruePositives = "NumTruePositives"
        }
    }

    public struct Connection: AWSDecodableShape {
        /// Connection properties specific to the Athena compute environment.
        public let athenaProperties: [String: String]?
        /// The authentication properties of the connection.
        public let authenticationConfiguration: AuthenticationConfiguration?
        /// A list of compute environments compatible with the connection.
        public let compatibleComputeEnvironments: [ComputeEnvironment]?
        /// These key-value pairs define parameters for the connection when using the version 1 Connection schema:    HOST - The host URI: either the fully qualified domain name (FQDN) or the IPv4 address of the database host.    PORT - The port number, between 1024 and 65535, of the port on which the database host is listening for database connections.    USER_NAME -  The name under which to log in to the database. The value string for USER_NAME is "USERNAME".    PASSWORD - A password, if one is used, for the user name.    ENCRYPTED_PASSWORD - When you enable connection password protection by setting ConnectionPasswordEncryption in the Data Catalog encryption settings, this field stores the encrypted password.    JDBC_DRIVER_JAR_URI - The Amazon Simple Storage Service (Amazon S3) path of the JAR file that contains the JDBC driver to use.    JDBC_DRIVER_CLASS_NAME - The class name of the JDBC driver to use.    JDBC_ENGINE - The name of the JDBC engine to use.    JDBC_ENGINE_VERSION - The version of the JDBC engine to use.    CONFIG_FILES - (Reserved for future use.)    INSTANCE_ID - The instance ID to use.    JDBC_CONNECTION_URL - The URL for connecting to a JDBC data source.    JDBC_ENFORCE_SSL - A Boolean string (true, false) specifying whether Secure Sockets Layer (SSL) with hostname matching is enforced for the JDBC connection on the client. The default is false.    CUSTOM_JDBC_CERT - An Amazon S3 location specifying the customer's root certificate. Glue uses this root certificate to validate the customers certificate when connecting to the customer database. Glue only handles X.509 certificates. The certificate provided must be DER-encoded and supplied in Base64 encoding PEM format.    SKIP_CUSTOM_JDBC_CERT_VALIDATION - By default, this is false. Glue validates the Signature algorithm and Subject Public Key Algorithm for the customer certificate. The only permitted algorithms for the Signature algorithm are SHA256withRSA, SHA384withRSA or SHA512withRSA. For the Subject Public Key Algorithm, the key length must be at least 2048. You can set the value of this property to true to skip Glues validation of the customer certificate.    CUSTOM_JDBC_CERT_STRING - A custom JDBC certificate string which is used for domain match or distinguished name match to prevent a man-in-the-middle attack. In Oracle database, this is used as the SSL_SERVER_CERT_DN; in Microsoft SQL Server, this is used as the hostNameInCertificate.    CONNECTION_URL - The URL for connecting to a general (non-JDBC) data source.    SECRET_ID - The secret ID used for the secret manager of credentials.    CONNECTOR_URL - The connector URL for a MARKETPLACE or CUSTOM connection.    CONNECTOR_TYPE - The connector type for a MARKETPLACE or CUSTOM connection.    CONNECTOR_CLASS_NAME - The connector class name for a MARKETPLACE or CUSTOM connection.    KAFKA_BOOTSTRAP_SERVERS - A comma-separated list of host and port pairs that are the addresses of the Apache Kafka brokers in a Kafka cluster to which a Kafka client will connect to and bootstrap itself.    KAFKA_SSL_ENABLED - Whether to enable or disable SSL on an Apache Kafka connection. Default value is "true".    KAFKA_CUSTOM_CERT - The Amazon S3 URL for the private CA cert file (.pem format). The default is an empty string.    KAFKA_SKIP_CUSTOM_CERT_VALIDATION - Whether to skip the validation of the CA cert file or not. Glue validates for three algorithms: SHA256withRSA, SHA384withRSA and SHA512withRSA. Default value is "false".    KAFKA_CLIENT_KEYSTORE - The Amazon S3 location of the client keystore file for Kafka client side authentication (Optional).    KAFKA_CLIENT_KEYSTORE_PASSWORD - The password to access the provided keystore (Optional).    KAFKA_CLIENT_KEY_PASSWORD - A keystore can consist of multiple keys, so this is the password to access the client key to be used with the Kafka server side key (Optional).    ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD - The encrypted version of the Kafka client keystore password (if the user has the Glue encrypt passwords setting selected).    ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD - The encrypted version of the Kafka client key password (if the user has the Glue encrypt passwords setting selected).    KAFKA_SASL_MECHANISM - "SCRAM-SHA-512", "GSSAPI", "AWS_MSK_IAM", or "PLAIN". These are the supported SASL Mechanisms.    KAFKA_SASL_PLAIN_USERNAME - A plaintext username used to authenticate with the "PLAIN" mechanism.    KAFKA_SASL_PLAIN_PASSWORD - A plaintext password used to authenticate with the "PLAIN" mechanism.    ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD - The encrypted version of the Kafka SASL PLAIN password (if the user has the Glue encrypt passwords setting selected).    KAFKA_SASL_SCRAM_USERNAME - A plaintext username used to authenticate with the "SCRAM-SHA-512" mechanism.    KAFKA_SASL_SCRAM_PASSWORD - A plaintext password used to authenticate with the "SCRAM-SHA-512" mechanism.    ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD - The encrypted version of the Kafka SASL SCRAM password (if the user has the Glue encrypt passwords setting selected).    KAFKA_SASL_SCRAM_SECRETS_ARN - The Amazon Resource Name of a secret in Amazon Web Services Secrets Manager.    KAFKA_SASL_GSSAPI_KEYTAB - The S3 location of a Kerberos keytab file. A keytab stores long-term keys for one or more principals. For more information, see MIT Kerberos Documentation: Keytab.    KAFKA_SASL_GSSAPI_KRB5_CONF - The S3 location of a Kerberos krb5.conf file. A krb5.conf stores Kerberos configuration information, such as the location of the KDC server. For more information, see MIT Kerberos Documentation: krb5.conf.    KAFKA_SASL_GSSAPI_SERVICE - The Kerberos service name, as set with sasl.kerberos.service.name in your Kafka Configuration.    KAFKA_SASL_GSSAPI_PRINCIPAL - The name of the Kerberos princial used by Glue. For more information, see Kafka Documentation: Configuring Kafka Brokers.    ROLE_ARN - The role to be used for running queries.    REGION - The Amazon Web Services Region where queries will be run.    WORKGROUP_NAME - The name of an Amazon Redshift serverless workgroup or Amazon Athena workgroup in which queries will run.    CLUSTER_IDENTIFIER - The cluster identifier of an Amazon Redshift cluster in which queries will run.    DATABASE - The Amazon Redshift database that you are connecting to.
        public let connectionProperties: [ConnectionPropertyKey: String]?
        /// The version of the connection schema for this connection. Version 2 supports properties for specific compute environments.
        public let connectionSchemaVersion: Int?
        /// The type of the connection. Currently, SFTP is not supported.
        public let connectionType: ConnectionType?
        /// The timestamp of the time that this connection definition was created.
        public let creationTime: Date?
        /// The description of the connection.
        public let description: String?
        /// A timestamp of the time this connection was last validated.
        public let lastConnectionValidationTime: Date?
        /// The user, group, or role that last updated this connection definition.
        public let lastUpdatedBy: String?
        /// The timestamp of the last time the connection definition was updated.
        public let lastUpdatedTime: Date?
        /// A list of criteria that can be used in selecting this connection.
        public let matchCriteria: [String]?
        /// The name of the connection definition.
        public let name: String?
        /// The physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup, that are needed to make this connection successfully.
        public let physicalConnectionRequirements: PhysicalConnectionRequirements?
        /// Connection properties specific to the Python compute environment.
        public let pythonProperties: [String: String]?
        /// Connection properties specific to the Spark compute environment.
        public let sparkProperties: [String: String]?
        /// The status of the connection. Can be one of: READY, IN_PROGRESS, or FAILED.
        public let status: ConnectionStatus?
        /// The reason for the connection status.
        public let statusReason: String?

        @inlinable
        public init(athenaProperties: [String: String]? = nil, authenticationConfiguration: AuthenticationConfiguration? = nil, compatibleComputeEnvironments: [ComputeEnvironment]? = nil, connectionProperties: [ConnectionPropertyKey: String]? = nil, connectionSchemaVersion: Int? = nil, connectionType: ConnectionType? = nil, creationTime: Date? = nil, description: String? = nil, lastConnectionValidationTime: Date? = nil, lastUpdatedBy: String? = nil, lastUpdatedTime: Date? = nil, matchCriteria: [String]? = nil, name: String? = nil, physicalConnectionRequirements: PhysicalConnectionRequirements? = nil, pythonProperties: [String: String]? = nil, sparkProperties: [String: String]? = nil, status: ConnectionStatus? = nil, statusReason: String? = nil) {
            self.athenaProperties = athenaProperties
            self.authenticationConfiguration = authenticationConfiguration
            self.compatibleComputeEnvironments = compatibleComputeEnvironments
            self.connectionProperties = connectionProperties
            self.connectionSchemaVersion = connectionSchemaVersion
            self.connectionType = connectionType
            self.creationTime = creationTime
            self.description = description
            self.lastConnectionValidationTime = lastConnectionValidationTime
            self.lastUpdatedBy = lastUpdatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.matchCriteria = matchCriteria
            self.name = name
            self.physicalConnectionRequirements = physicalConnectionRequirements
            self.pythonProperties = pythonProperties
            self.sparkProperties = sparkProperties
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case athenaProperties = "AthenaProperties"
            case authenticationConfiguration = "AuthenticationConfiguration"
            case compatibleComputeEnvironments = "CompatibleComputeEnvironments"
            case connectionProperties = "ConnectionProperties"
            case connectionSchemaVersion = "ConnectionSchemaVersion"
            case connectionType = "ConnectionType"
            case creationTime = "CreationTime"
            case description = "Description"
            case lastConnectionValidationTime = "LastConnectionValidationTime"
            case lastUpdatedBy = "LastUpdatedBy"
            case lastUpdatedTime = "LastUpdatedTime"
            case matchCriteria = "MatchCriteria"
            case name = "Name"
            case physicalConnectionRequirements = "PhysicalConnectionRequirements"
            case pythonProperties = "PythonProperties"
            case sparkProperties = "SparkProperties"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct ConnectionInput: AWSEncodableShape {
        /// Connection properties specific to the Athena compute environment.
        public let athenaProperties: [String: String]?
        /// The authentication properties of the connection.
        public let authenticationConfiguration: AuthenticationConfigurationInput?
        /// These key-value pairs define parameters for the connection.
        public let connectionProperties: [ConnectionPropertyKey: String]
        /// The type of the connection. Currently, these types are supported:    JDBC - Designates a connection to a database through Java Database Connectivity (JDBC).  JDBC Connections use the following ConnectionParameters.   Required: All of (HOST, PORT, JDBC_ENGINE) or JDBC_CONNECTION_URL.   Required: All of (USERNAME, PASSWORD) or SECRET_ID.   Optional: JDBC_ENFORCE_SSL, CUSTOM_JDBC_CERT, CUSTOM_JDBC_CERT_STRING, SKIP_CUSTOM_JDBC_CERT_VALIDATION.  These parameters are used to configure SSL with JDBC.      KAFKA - Designates a connection to an Apache Kafka streaming platform.  KAFKA Connections use the following ConnectionParameters.   Required: KAFKA_BOOTSTRAP_SERVERS.   Optional: KAFKA_SSL_ENABLED, KAFKA_CUSTOM_CERT, KAFKA_SKIP_CUSTOM_CERT_VALIDATION. These parameters are used to configure SSL with KAFKA.   Optional: KAFKA_CLIENT_KEYSTORE, KAFKA_CLIENT_KEYSTORE_PASSWORD, KAFKA_CLIENT_KEY_PASSWORD, ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD, ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD. These parameters are used to configure TLS client configuration with SSL in KAFKA.   Optional: KAFKA_SASL_MECHANISM. Can be specified as SCRAM-SHA-512, GSSAPI, or AWS_MSK_IAM.   Optional: KAFKA_SASL_SCRAM_USERNAME, KAFKA_SASL_SCRAM_PASSWORD, ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD. These parameters are used to configure SASL/SCRAM-SHA-512 authentication with KAFKA.   Optional: KAFKA_SASL_GSSAPI_KEYTAB, KAFKA_SASL_GSSAPI_KRB5_CONF, KAFKA_SASL_GSSAPI_SERVICE, KAFKA_SASL_GSSAPI_PRINCIPAL. These parameters are used to configure SASL/GSSAPI authentication with KAFKA.      MONGODB - Designates a connection to a MongoDB document database.  MONGODB Connections use the following ConnectionParameters.   Required: CONNECTION_URL.   Required: All of (USERNAME, PASSWORD) or SECRET_ID.      VIEW_VALIDATION_REDSHIFT - Designates a connection used for view validation by Amazon Redshift.    VIEW_VALIDATION_ATHENA - Designates a connection used for view validation by Amazon Athena.    NETWORK - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).  NETWORK Connections do not require ConnectionParameters. Instead, provide a PhysicalConnectionRequirements.    MARKETPLACE - Uses configuration settings contained in a connector purchased from Amazon Web Services Marketplace to read from and write to data stores that are not natively supported by Glue.  MARKETPLACE Connections use the following ConnectionParameters.   Required: CONNECTOR_TYPE, CONNECTOR_URL, CONNECTOR_CLASS_NAME, CONNECTION_URL.   Required for JDBC CONNECTOR_TYPE connections: All of (USERNAME, PASSWORD) or SECRET_ID.      CUSTOM - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by Glue.   Additionally, a ConnectionType for the following SaaS connectors is supported:    FACEBOOKADS - Designates a connection to Facebook Ads.    GOOGLEADS - Designates a connection to Google Ads.    GOOGLESHEETS - Designates a connection to Google Sheets.    GOOGLEANALYTICS4 - Designates a connection to Google Analytics 4.    HUBSPOT - Designates a connection to HubSpot.    INSTAGRAMADS - Designates a connection to Instagram Ads.    INTERCOM - Designates a connection to Intercom.    JIRACLOUD - Designates a connection to Jira Cloud.    MARKETO - Designates a connection to Adobe Marketo Engage.    NETSUITEERP - Designates a connection to Oracle NetSuite.    SALESFORCE - Designates a connection to Salesforce using OAuth authentication.    SALESFORCEMARKETINGCLOUD - Designates a connection to Salesforce Marketing Cloud.    SALESFORCEPARDOT - Designates a connection to Salesforce Marketing Cloud Account Engagement (MCAE).    SAPODATA - Designates a connection to SAP OData.    SERVICENOW - Designates a connection to ServiceNow.    SLACK - Designates a connection to Slack.    SNAPCHATADS - Designates a connection to Snapchat Ads.    STRIPE - Designates a connection to Stripe.    ZENDESK - Designates a connection to Zendesk.    ZOHOCRM - Designates a connection to Zoho CRM.   For more information on the connection parameters needed for a particular connector, see the documentation for the connector in Adding an Glue connectionin the Glue User Guide.  SFTP is not supported. For more information about how optional ConnectionProperties are used to configure features in Glue, consult Glue connection properties. For more information about how optional ConnectionProperties are used to configure features in Glue Studio, consult Using connectors and connections.
        public let connectionType: ConnectionType
        /// The description of the connection.
        public let description: String?
        /// A list of criteria that can be used in selecting this connection.
        public let matchCriteria: [String]?
        /// The name of the connection.
        public let name: String
        /// The physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup, that are needed to successfully make this connection.
        public let physicalConnectionRequirements: PhysicalConnectionRequirements?
        /// Connection properties specific to the Python compute environment.
        public let pythonProperties: [String: String]?
        /// Connection properties specific to the Spark compute environment.
        public let sparkProperties: [String: String]?
        /// A flag to validate the credentials during create connection. Default is true.
        public let validateCredentials: Bool?
        /// The compute environments that the specified connection properties are validated against.
        public let validateForComputeEnvironments: [ComputeEnvironment]?

        @inlinable
        public init(athenaProperties: [String: String]? = nil, authenticationConfiguration: AuthenticationConfigurationInput? = nil, connectionProperties: [ConnectionPropertyKey: String], connectionType: ConnectionType, description: String? = nil, matchCriteria: [String]? = nil, name: String, physicalConnectionRequirements: PhysicalConnectionRequirements? = nil, pythonProperties: [String: String]? = nil, sparkProperties: [String: String]? = nil, validateCredentials: Bool? = nil, validateForComputeEnvironments: [ComputeEnvironment]? = nil) {
            self.athenaProperties = athenaProperties
            self.authenticationConfiguration = authenticationConfiguration
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
            self.description = description
            self.matchCriteria = matchCriteria
            self.name = name
            self.physicalConnectionRequirements = physicalConnectionRequirements
            self.pythonProperties = pythonProperties
            self.sparkProperties = sparkProperties
            self.validateCredentials = validateCredentials
            self.validateForComputeEnvironments = validateForComputeEnvironments
        }

        public func validate(name: String) throws {
            try self.athenaProperties?.forEach {
                try validate($0.key, name: "athenaProperties.key", parent: name, max: 128)
                try validate($0.key, name: "athenaProperties.key", parent: name, min: 1)
                try validate($0.value, name: "athenaProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "athenaProperties[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.authenticationConfiguration?.validate(name: "\(name).authenticationConfiguration")
            try self.connectionProperties.forEach {
                try validate($0.value, name: "connectionProperties[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "connectionProperties[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.connectionProperties, name: "connectionProperties", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.matchCriteria?.forEach {
                try validate($0, name: "matchCriteria[]", parent: name, max: 255)
                try validate($0, name: "matchCriteria[]", parent: name, min: 1)
                try validate($0, name: "matchCriteria[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.matchCriteria, name: "matchCriteria", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.physicalConnectionRequirements?.validate(name: "\(name).physicalConnectionRequirements")
            try self.pythonProperties?.forEach {
                try validate($0.key, name: "pythonProperties.key", parent: name, max: 128)
                try validate($0.key, name: "pythonProperties.key", parent: name, min: 1)
                try validate($0.value, name: "pythonProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "pythonProperties[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.sparkProperties?.forEach {
                try validate($0.key, name: "sparkProperties.key", parent: name, max: 128)
                try validate($0.key, name: "sparkProperties.key", parent: name, min: 1)
                try validate($0.value, name: "sparkProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "sparkProperties[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case athenaProperties = "AthenaProperties"
            case authenticationConfiguration = "AuthenticationConfiguration"
            case connectionProperties = "ConnectionProperties"
            case connectionType = "ConnectionType"
            case description = "Description"
            case matchCriteria = "MatchCriteria"
            case name = "Name"
            case physicalConnectionRequirements = "PhysicalConnectionRequirements"
            case pythonProperties = "PythonProperties"
            case sparkProperties = "SparkProperties"
            case validateCredentials = "ValidateCredentials"
            case validateForComputeEnvironments = "ValidateForComputeEnvironments"
        }
    }

    public struct ConnectionPasswordEncryption: AWSEncodableShape & AWSDecodableShape {
        /// An KMS key that is used to encrypt the connection password.  If connection password protection is enabled, the caller of CreateConnection and UpdateConnection needs at least kms:Encrypt permission on the specified KMS key, to encrypt passwords before storing them in the Data Catalog.  You can set the decrypt permission to enable or restrict access on the password key according to your security requirements.
        public let awsKmsKeyId: String?
        /// When the ReturnConnectionPasswordEncrypted flag is set to "true", passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently from catalog encryption.
        public let returnConnectionPasswordEncrypted: Bool

        @inlinable
        public init(awsKmsKeyId: String? = nil, returnConnectionPasswordEncrypted: Bool) {
            self.awsKmsKeyId = awsKmsKeyId
            self.returnConnectionPasswordEncrypted = returnConnectionPasswordEncrypted
        }

        public func validate(name: String) throws {
            try self.validate(self.awsKmsKeyId, name: "awsKmsKeyId", parent: name, max: 255)
            try self.validate(self.awsKmsKeyId, name: "awsKmsKeyId", parent: name, min: 1)
            try self.validate(self.awsKmsKeyId, name: "awsKmsKeyId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsKmsKeyId = "AwsKmsKeyId"
            case returnConnectionPasswordEncrypted = "ReturnConnectionPasswordEncrypted"
        }
    }

    public struct ConnectionTypeBrief: AWSDecodableShape {
        /// The supported authentication types, data interface types (compute environments), and data operations of the connector.
        public let capabilities: Capabilities?
        /// The name of the connection type.
        public let connectionType: ConnectionType?
        /// A description of the connection type.
        public let description: String?

        @inlinable
        public init(capabilities: Capabilities? = nil, connectionType: ConnectionType? = nil, description: String? = nil) {
            self.capabilities = capabilities
            self.connectionType = connectionType
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case connectionType = "ConnectionType"
            case description = "Description"
        }
    }

    public struct ConnectionsList: AWSEncodableShape & AWSDecodableShape {
        /// A list of connections used by the job.
        public let connections: [String]?

        @inlinable
        public init(connections: [String]? = nil) {
            self.connections = connections
        }

        public func validate(name: String) throws {
            try self.connections?.forEach {
                try validate($0, name: "connections[]", parent: name, max: 255)
            }
            try self.validate(self.connections, name: "connections", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
        }
    }

    public struct ConnectorDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The connectionType, as provided to the underlying Glue library. This node type supports
        /// the following connection types:     opensearch     azuresql     azurecosmos     bigquery     saphana     teradata     vertica
        public let connectionType: String
        /// A map specifying connection options for the node. You can find standard connection options for the corresponding connection type in the  Connection parameters section of the Glue documentation.
        public let data: [String: String]
        /// The name of this source node.
        public let name: String
        /// Specifies the data schema for this source.
        public let outputSchemas: [GlueSchema]?

        @inlinable
        public init(connectionType: String, data: [String: String], name: String, outputSchemas: [GlueSchema]? = nil) {
            self.connectionType = connectionType
            self.data = data
            self.name = name
            self.outputSchemas = outputSchemas
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionType, name: "connectionType", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectionType = "ConnectionType"
            case data = "Data"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
        }
    }

    public struct ConnectorDataTarget: AWSEncodableShape & AWSDecodableShape {
        /// The connectionType, as provided to the underlying Glue library. This node type supports
        /// the following connection types:     opensearch     azuresql     azurecosmos     bigquery     saphana     teradata     vertica
        public let connectionType: String
        /// A map specifying connection options for the node. You can find standard connection options for the  corresponding connection type in the   Connection parameters section of the Glue documentation.
        public let data: [String: String]
        /// The nodes that are inputs to the data target.
        public let inputs: [String]?
        /// The name of this target node.
        public let name: String

        @inlinable
        public init(connectionType: String, data: [String: String], inputs: [String]? = nil, name: String) {
            self.connectionType = connectionType
            self.data = data
            self.inputs = inputs
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionType, name: "connectionType", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs?.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionType = "ConnectionType"
            case data = "Data"
            case inputs = "Inputs"
            case name = "Name"
        }
    }

    public struct Crawl: AWSDecodableShape {
        /// The date and time on which the crawl completed.
        public let completedOn: Date?
        /// The error message associated with the crawl.
        public let errorMessage: String?
        /// The log group associated with the crawl.
        public let logGroup: String?
        /// The log stream associated with the crawl.
        public let logStream: String?
        /// The date and time on which the crawl started.
        public let startedOn: Date?
        /// The state of the crawler.
        public let state: CrawlState?

        @inlinable
        public init(completedOn: Date? = nil, errorMessage: String? = nil, logGroup: String? = nil, logStream: String? = nil, startedOn: Date? = nil, state: CrawlState? = nil) {
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.logGroup = logGroup
            self.logStream = logStream
            self.startedOn = startedOn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case errorMessage = "ErrorMessage"
            case logGroup = "LogGroup"
            case logStream = "LogStream"
            case startedOn = "StartedOn"
            case state = "State"
        }
    }

    public struct Crawler: AWSDecodableShape {
        /// A list of UTF-8 strings that specify the custom classifiers that are associated  with the crawler.
        public let classifiers: [String]?
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Setting crawler configuration options.
        public let configuration: String?
        /// If the crawler is running, contains the total time elapsed since the last crawl began.
        public let crawlElapsedTime: Int64?
        /// The name of the SecurityConfiguration structure to be used by this crawler.
        public let crawlerSecurityConfiguration: String?
        /// The time that the crawler was created.
        public let creationTime: Date?
        /// The name of the database in which the crawler's output is stored.
        public let databaseName: String?
        /// A description of the crawler.
        public let description: String?
        /// Specifies whether the crawler should use Lake Formation credentials for the crawler instead of the IAM role credentials.
        public let lakeFormationConfiguration: LakeFormationConfiguration?
        /// The status of the last crawl, and potentially error information if an error occurred.
        public let lastCrawl: LastCrawlInfo?
        /// The time that the crawler was last updated.
        public let lastUpdated: Date?
        /// A configuration that specifies whether data lineage is enabled for the crawler.
        public let lineageConfiguration: LineageConfiguration?
        /// The name of the crawler.
        public let name: String?
        /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
        public let recrawlPolicy: RecrawlPolicy?
        /// The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.
        public let role: String?
        /// For scheduled crawlers, the schedule when the crawler runs.
        public let schedule: Schedule?
        /// The policy that specifies update and delete behaviors for the crawler.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// Indicates whether the crawler is running, or whether a run is pending.
        public let state: CrawlerState?
        /// The prefix added to the names of tables that are created.
        public let tablePrefix: String?
        /// A collection of targets to crawl.
        public let targets: CrawlerTargets?
        /// The version of the crawler.
        public let version: Int64?

        @inlinable
        public init(classifiers: [String]? = nil, configuration: String? = nil, crawlElapsedTime: Int64? = nil, crawlerSecurityConfiguration: String? = nil, creationTime: Date? = nil, databaseName: String? = nil, description: String? = nil, lakeFormationConfiguration: LakeFormationConfiguration? = nil, lastCrawl: LastCrawlInfo? = nil, lastUpdated: Date? = nil, lineageConfiguration: LineageConfiguration? = nil, name: String? = nil, recrawlPolicy: RecrawlPolicy? = nil, role: String? = nil, schedule: Schedule? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, state: CrawlerState? = nil, tablePrefix: String? = nil, targets: CrawlerTargets? = nil, version: Int64? = nil) {
            self.classifiers = classifiers
            self.configuration = configuration
            self.crawlElapsedTime = crawlElapsedTime
            self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.description = description
            self.lakeFormationConfiguration = lakeFormationConfiguration
            self.lastCrawl = lastCrawl
            self.lastUpdated = lastUpdated
            self.lineageConfiguration = lineageConfiguration
            self.name = name
            self.recrawlPolicy = recrawlPolicy
            self.role = role
            self.schedule = schedule
            self.schemaChangePolicy = schemaChangePolicy
            self.state = state
            self.tablePrefix = tablePrefix
            self.targets = targets
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case configuration = "Configuration"
            case crawlElapsedTime = "CrawlElapsedTime"
            case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case description = "Description"
            case lakeFormationConfiguration = "LakeFormationConfiguration"
            case lastCrawl = "LastCrawl"
            case lastUpdated = "LastUpdated"
            case lineageConfiguration = "LineageConfiguration"
            case name = "Name"
            case recrawlPolicy = "RecrawlPolicy"
            case role = "Role"
            case schedule = "Schedule"
            case schemaChangePolicy = "SchemaChangePolicy"
            case state = "State"
            case tablePrefix = "TablePrefix"
            case targets = "Targets"
            case version = "Version"
        }
    }

    public struct CrawlerHistory: AWSDecodableShape {
        /// A UUID identifier for each crawl.
        public let crawlId: String?
        /// The number of data processing units (DPU) used in hours for the crawl.
        public let dpuHour: Double?
        /// The date and time on which the crawl ended.
        public let endTime: Date?
        /// If an error occurred, the error message associated with the crawl.
        public let errorMessage: String?
        /// The log group associated with the crawl.
        public let logGroup: String?
        /// The log stream associated with the crawl.
        public let logStream: String?
        /// The prefix for a CloudWatch message about this crawl.
        public let messagePrefix: String?
        /// The date and time on which the crawl started.
        public let startTime: Date?
        /// The state of the crawl.
        public let state: CrawlerHistoryState?
        /// A run summary for the specific crawl in JSON. Contains the catalog tables and partitions that were added, updated, or deleted.
        public let summary: String?

        @inlinable
        public init(crawlId: String? = nil, dpuHour: Double? = nil, endTime: Date? = nil, errorMessage: String? = nil, logGroup: String? = nil, logStream: String? = nil, messagePrefix: String? = nil, startTime: Date? = nil, state: CrawlerHistoryState? = nil, summary: String? = nil) {
            self.crawlId = crawlId
            self.dpuHour = dpuHour
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.logGroup = logGroup
            self.logStream = logStream
            self.messagePrefix = messagePrefix
            self.startTime = startTime
            self.state = state
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case crawlId = "CrawlId"
            case dpuHour = "DPUHour"
            case endTime = "EndTime"
            case errorMessage = "ErrorMessage"
            case logGroup = "LogGroup"
            case logStream = "LogStream"
            case messagePrefix = "MessagePrefix"
            case startTime = "StartTime"
            case state = "State"
            case summary = "Summary"
        }
    }

    public struct CrawlerMetrics: AWSDecodableShape {
        /// The name of the crawler.
        public let crawlerName: String?
        /// The duration of the crawler's most recent run, in seconds.
        public let lastRuntimeSeconds: Double?
        /// The median duration of this crawler's runs, in seconds.
        public let medianRuntimeSeconds: Double?
        /// True if the crawler is still estimating how long it will take to complete this run.
        public let stillEstimating: Bool?
        /// The number of tables created by this crawler.
        public let tablesCreated: Int?
        /// The number of tables deleted by this crawler.
        public let tablesDeleted: Int?
        /// The number of tables updated by this crawler.
        public let tablesUpdated: Int?
        /// The estimated time left to complete a running crawl.
        public let timeLeftSeconds: Double?

        @inlinable
        public init(crawlerName: String? = nil, lastRuntimeSeconds: Double? = nil, medianRuntimeSeconds: Double? = nil, stillEstimating: Bool? = nil, tablesCreated: Int? = nil, tablesDeleted: Int? = nil, tablesUpdated: Int? = nil, timeLeftSeconds: Double? = nil) {
            self.crawlerName = crawlerName
            self.lastRuntimeSeconds = lastRuntimeSeconds
            self.medianRuntimeSeconds = medianRuntimeSeconds
            self.stillEstimating = stillEstimating
            self.tablesCreated = tablesCreated
            self.tablesDeleted = tablesDeleted
            self.tablesUpdated = tablesUpdated
            self.timeLeftSeconds = timeLeftSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
            case lastRuntimeSeconds = "LastRuntimeSeconds"
            case medianRuntimeSeconds = "MedianRuntimeSeconds"
            case stillEstimating = "StillEstimating"
            case tablesCreated = "TablesCreated"
            case tablesDeleted = "TablesDeleted"
            case tablesUpdated = "TablesUpdated"
            case timeLeftSeconds = "TimeLeftSeconds"
        }
    }

    public struct CrawlerNodeDetails: AWSDecodableShape {
        /// A list of crawls represented by the crawl node.
        public let crawls: [Crawl]?

        @inlinable
        public init(crawls: [Crawl]? = nil) {
            self.crawls = crawls
        }

        private enum CodingKeys: String, CodingKey {
            case crawls = "Crawls"
        }
    }

    public struct CrawlerTargets: AWSEncodableShape & AWSDecodableShape {
        /// Specifies Glue Data Catalog targets.
        public let catalogTargets: [CatalogTarget]?
        /// Specifies Delta data store targets.
        public let deltaTargets: [DeltaTarget]?
        /// Specifies Amazon DynamoDB targets.
        public let dynamoDBTargets: [DynamoDBTarget]?
        /// Specifies Apache Hudi data store targets.
        public let hudiTargets: [HudiTarget]?
        /// Specifies Apache Iceberg data store targets.
        public let icebergTargets: [IcebergTarget]?
        /// Specifies JDBC targets.
        public let jdbcTargets: [JdbcTarget]?
        /// Specifies Amazon DocumentDB or MongoDB targets.
        public let mongoDBTargets: [MongoDBTarget]?
        /// Specifies Amazon Simple Storage Service (Amazon S3) targets.
        public let s3Targets: [S3Target]?

        @inlinable
        public init(catalogTargets: [CatalogTarget]? = nil, deltaTargets: [DeltaTarget]? = nil, dynamoDBTargets: [DynamoDBTarget]? = nil, hudiTargets: [HudiTarget]? = nil, icebergTargets: [IcebergTarget]? = nil, jdbcTargets: [JdbcTarget]? = nil, mongoDBTargets: [MongoDBTarget]? = nil, s3Targets: [S3Target]? = nil) {
            self.catalogTargets = catalogTargets
            self.deltaTargets = deltaTargets
            self.dynamoDBTargets = dynamoDBTargets
            self.hudiTargets = hudiTargets
            self.icebergTargets = icebergTargets
            self.jdbcTargets = jdbcTargets
            self.mongoDBTargets = mongoDBTargets
            self.s3Targets = s3Targets
        }

        public func validate(name: String) throws {
            try self.catalogTargets?.forEach {
                try $0.validate(name: "\(name).catalogTargets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case catalogTargets = "CatalogTargets"
            case deltaTargets = "DeltaTargets"
            case dynamoDBTargets = "DynamoDBTargets"
            case hudiTargets = "HudiTargets"
            case icebergTargets = "IcebergTargets"
            case jdbcTargets = "JdbcTargets"
            case mongoDBTargets = "MongoDBTargets"
            case s3Targets = "S3Targets"
        }
    }

    public struct CrawlsFilter: AWSEncodableShape {
        /// A key used to filter the crawler runs for a specified crawler. Valid values for each of the field names are:    CRAWL_ID: A string representing the UUID identifier for a crawl.    STATE: A string representing the state of the crawl.    START_TIME and END_TIME: The epoch timestamp in milliseconds.    DPU_HOUR: The number of data processing unit (DPU) hours used for the crawl.
        public let fieldName: FieldName?
        /// The value provided for comparison on the crawl field.
        public let fieldValue: String?
        /// A defined comparator that operates on the value. The available operators are:    GT: Greater than.    GE: Greater than or equal to.    LT: Less than.    LE: Less than or equal to.    EQ: Equal to.    NE: Not equal to.
        public let filterOperator: FilterOperator?

        @inlinable
        public init(fieldName: FieldName? = nil, fieldValue: String? = nil, filterOperator: FilterOperator? = nil) {
            self.fieldName = fieldName
            self.fieldValue = fieldValue
            self.filterOperator = filterOperator
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "FieldName"
            case fieldValue = "FieldValue"
            case filterOperator = "FilterOperator"
        }
    }

    public struct CreateBlueprintRequest: AWSEncodableShape {
        /// Specifies a path in Amazon S3 where the blueprint is published.
        public let blueprintLocation: String
        /// A description of the blueprint.
        public let description: String?
        /// The name of the blueprint.
        public let name: String
        /// The tags to be applied to this blueprint.
        public let tags: [String: String]?

        @inlinable
        public init(blueprintLocation: String, description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.blueprintLocation = blueprintLocation
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintLocation, name: "blueprintLocation", parent: name, max: 8192)
            try self.validate(self.blueprintLocation, name: "blueprintLocation", parent: name, min: 1)
            try self.validate(self.blueprintLocation, name: "blueprintLocation", parent: name, pattern: "^s3://([^/]+)/([^/]+/)*([^/]+)$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintLocation = "BlueprintLocation"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateBlueprintResponse: AWSDecodableShape {
        /// Returns the name of the blueprint that was registered.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateCatalogRequest: AWSEncodableShape {
        /// A CatalogInput object that defines the metadata for the catalog.
        public let catalogInput: CatalogInput
        /// The name of the catalog to create.
        public let name: String
        /// A map array of key-value pairs, not more than 50 pairs. Each key is a UTF-8 string, not less than 1 or more than 128 bytes long. Each value is a UTF-8 string, not more than 256 bytes long. The tags you assign to the catalog.
        public let tags: [String: String]?

        @inlinable
        public init(catalogInput: CatalogInput, name: String, tags: [String: String]? = nil) {
            self.catalogInput = catalogInput
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.catalogInput.validate(name: "\(name).catalogInput")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!(.*[.\\/\\\\]|aws:)).*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogInput = "CatalogInput"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateCatalogResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateClassifierRequest: AWSEncodableShape {
        /// A CsvClassifier object specifying the classifier to create.
        public let csvClassifier: CreateCsvClassifierRequest?
        /// A GrokClassifier object specifying the classifier to create.
        public let grokClassifier: CreateGrokClassifierRequest?
        /// A JsonClassifier object specifying the classifier to create.
        public let jsonClassifier: CreateJsonClassifierRequest?
        /// An XMLClassifier object specifying the classifier to create.
        public let xmlClassifier: CreateXMLClassifierRequest?

        @inlinable
        public init(csvClassifier: CreateCsvClassifierRequest? = nil, grokClassifier: CreateGrokClassifierRequest? = nil, jsonClassifier: CreateJsonClassifierRequest? = nil, xmlClassifier: CreateXMLClassifierRequest? = nil) {
            self.csvClassifier = csvClassifier
            self.grokClassifier = grokClassifier
            self.jsonClassifier = jsonClassifier
            self.xmlClassifier = xmlClassifier
        }

        public func validate(name: String) throws {
            try self.csvClassifier?.validate(name: "\(name).csvClassifier")
            try self.grokClassifier?.validate(name: "\(name).grokClassifier")
            try self.jsonClassifier?.validate(name: "\(name).jsonClassifier")
            try self.xmlClassifier?.validate(name: "\(name).xmlClassifier")
        }

        private enum CodingKeys: String, CodingKey {
            case csvClassifier = "CsvClassifier"
            case grokClassifier = "GrokClassifier"
            case jsonClassifier = "JsonClassifier"
            case xmlClassifier = "XMLClassifier"
        }
    }

    public struct CreateClassifierResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateColumnStatisticsTaskSettingsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the database resides.
        public let catalogID: String?
        /// A list of column names for which to run statistics.
        public let columnNameList: [String]?
        /// The name of the database where the table resides.
        public let databaseName: String
        /// The role used for running the column statistics.
        public let role: String
        /// The percentage of data to sample.
        public let sampleSize: Double?
        /// A schedule for running the column statistics, specified in CRON syntax.
        public let schedule: String?
        /// Name of the security configuration that is used to encrypt CloudWatch logs.
        public let securityConfiguration: String?
        /// The name of the table for which to generate column statistics.
        public let tableName: String
        /// A map of tags.
        public let tags: [String: String]?

        @inlinable
        public init(catalogID: String? = nil, columnNameList: [String]? = nil, databaseName: String, role: String, sampleSize: Double? = nil, schedule: String? = nil, securityConfiguration: String? = nil, tableName: String, tags: [String: String]? = nil) {
            self.catalogID = catalogID
            self.columnNameList = columnNameList
            self.databaseName = databaseName
            self.role = role
            self.sampleSize = sampleSize
            self.schedule = schedule
            self.securityConfiguration = securityConfiguration
            self.tableName = tableName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogID, name: "catalogID", parent: name, max: 255)
            try self.validate(self.catalogID, name: "catalogID", parent: name, min: 1)
            try self.validate(self.catalogID, name: "catalogID", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.columnNameList?.forEach {
                try validate($0, name: "columnNameList[]", parent: name, max: 255)
                try validate($0, name: "columnNameList[]", parent: name, min: 1)
                try validate($0, name: "columnNameList[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.role, name: "role", parent: name, max: 255)
            try self.validate(self.role, name: "role", parent: name, min: 1)
            try self.validate(self.role, name: "role", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.sampleSize, name: "sampleSize", parent: name, max: 100.0)
            try self.validate(self.sampleSize, name: "sampleSize", parent: name, min: 0.0)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogID = "CatalogID"
            case columnNameList = "ColumnNameList"
            case databaseName = "DatabaseName"
            case role = "Role"
            case sampleSize = "SampleSize"
            case schedule = "Schedule"
            case securityConfiguration = "SecurityConfiguration"
            case tableName = "TableName"
            case tags = "Tags"
        }
    }

    public struct CreateColumnStatisticsTaskSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateConnectionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which to create the connection. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A ConnectionInput object defining the connection to create.
        public let connectionInput: ConnectionInput
        /// The tags you assign to the connection.
        public let tags: [String: String]?

        @inlinable
        public init(catalogId: String? = nil, connectionInput: ConnectionInput, tags: [String: String]? = nil) {
            self.catalogId = catalogId
            self.connectionInput = connectionInput
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.connectionInput.validate(name: "\(name).connectionInput")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionInput = "ConnectionInput"
            case tags = "Tags"
        }
    }

    public struct CreateConnectionResponse: AWSDecodableShape {
        /// The status of the connection creation request. The request can take some time for certain authentication types, for example when creating an OAuth connection with token exchange over VPC.
        public let createConnectionStatus: ConnectionStatus?

        @inlinable
        public init(createConnectionStatus: ConnectionStatus? = nil) {
            self.createConnectionStatus = createConnectionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createConnectionStatus = "CreateConnectionStatus"
        }
    }

    public struct CreateCrawlerRequest: AWSEncodableShape {
        /// A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
        public let classifiers: [String]?
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Setting crawler configuration options.
        public let configuration: String?
        /// The name of the SecurityConfiguration structure to be used by this crawler.
        public let crawlerSecurityConfiguration: String?
        /// The Glue database where results are written, such as: arn:aws:daylight:us-east-1::database/sometable/*.
        public let databaseName: String?
        /// A description of the new crawler.
        public let description: String?
        /// Specifies Lake Formation configuration settings for the crawler.
        public let lakeFormationConfiguration: LakeFormationConfiguration?
        /// Specifies data lineage configuration settings for the crawler.
        public let lineageConfiguration: LineageConfiguration?
        /// Name of the new crawler.
        public let name: String
        /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
        public let recrawlPolicy: RecrawlPolicy?
        /// The IAM role or Amazon Resource Name (ARN) of an IAM role used by the new crawler to access customer resources.
        public let role: String
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// The policy for the crawler's update and deletion behavior.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// The table prefix used for catalog tables that are created.
        public let tablePrefix: String?
        /// The tags to use with this crawler request. You may use tags to limit access to the crawler. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
        public let tags: [String: String]?
        /// A list of collection of targets to crawl.
        public let targets: CrawlerTargets

        @inlinable
        public init(classifiers: [String]? = nil, configuration: String? = nil, crawlerSecurityConfiguration: String? = nil, databaseName: String? = nil, description: String? = nil, lakeFormationConfiguration: LakeFormationConfiguration? = nil, lineageConfiguration: LineageConfiguration? = nil, name: String, recrawlPolicy: RecrawlPolicy? = nil, role: String, schedule: String? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, tablePrefix: String? = nil, tags: [String: String]? = nil, targets: CrawlerTargets) {
            self.classifiers = classifiers
            self.configuration = configuration
            self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
            self.databaseName = databaseName
            self.description = description
            self.lakeFormationConfiguration = lakeFormationConfiguration
            self.lineageConfiguration = lineageConfiguration
            self.name = name
            self.recrawlPolicy = recrawlPolicy
            self.role = role
            self.schedule = schedule
            self.schemaChangePolicy = schemaChangePolicy
            self.tablePrefix = tablePrefix
            self.tags = tags
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.classifiers?.forEach {
                try validate($0, name: "classifiers[]", parent: name, max: 255)
                try validate($0, name: "classifiers[]", parent: name, min: 1)
                try validate($0, name: "classifiers[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.crawlerSecurityConfiguration, name: "crawlerSecurityConfiguration", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.lakeFormationConfiguration?.validate(name: "\(name).lakeFormationConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tablePrefix, name: "tablePrefix", parent: name, max: 128)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.targets.validate(name: "\(name).targets")
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case configuration = "Configuration"
            case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
            case databaseName = "DatabaseName"
            case description = "Description"
            case lakeFormationConfiguration = "LakeFormationConfiguration"
            case lineageConfiguration = "LineageConfiguration"
            case name = "Name"
            case recrawlPolicy = "RecrawlPolicy"
            case role = "Role"
            case schedule = "Schedule"
            case schemaChangePolicy = "SchemaChangePolicy"
            case tablePrefix = "TablePrefix"
            case tags = "Tags"
            case targets = "Targets"
        }
    }

    public struct CreateCrawlerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateCsvClassifierRequest: AWSEncodableShape {
        /// Enables the processing of files that contain only one column.
        public let allowSingleColumn: Bool?
        /// Indicates whether the CSV file contains a header.
        public let containsHeader: CsvHeaderOption?
        /// Enables the configuration of custom datatypes.
        public let customDatatypeConfigured: Bool?
        /// Creates a list of supported custom datatypes.
        public let customDatatypes: [String]?
        /// A custom symbol to denote what separates each column entry in the row.
        public let delimiter: String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public let disableValueTrimming: Bool?
        /// A list of strings representing column names.
        public let header: [String]?
        /// The name of the classifier.
        public let name: String
        /// A custom symbol to denote what combines content into a single column value. Must be different from the column delimiter.
        public let quoteSymbol: String?
        /// Sets the SerDe for processing CSV in the classifier, which will be applied in the Data Catalog. Valid values are OpenCSVSerDe, LazySimpleSerDe, and None. You can specify the None value when you want the crawler to do the detection.
        public let serde: CsvSerdeOption?

        @inlinable
        public init(allowSingleColumn: Bool? = nil, containsHeader: CsvHeaderOption? = nil, customDatatypeConfigured: Bool? = nil, customDatatypes: [String]? = nil, delimiter: String? = nil, disableValueTrimming: Bool? = nil, header: [String]? = nil, name: String, quoteSymbol: String? = nil, serde: CsvSerdeOption? = nil) {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.customDatatypeConfigured = customDatatypeConfigured
            self.customDatatypes = customDatatypes
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.name = name
            self.quoteSymbol = quoteSymbol
            self.serde = serde
        }

        public func validate(name: String) throws {
            try self.customDatatypes?.forEach {
                try validate($0, name: "customDatatypes[]", parent: name, max: 255)
                try validate($0, name: "customDatatypes[]", parent: name, min: 1)
                try validate($0, name: "customDatatypes[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, pattern: "^[^\\r\\n]$")
            try self.header?.forEach {
                try validate($0, name: "header[]", parent: name, max: 255)
                try validate($0, name: "header[]", parent: name, min: 1)
                try validate($0, name: "header[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, max: 1)
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, min: 1)
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, pattern: "^[^\\r\\n]$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowSingleColumn = "AllowSingleColumn"
            case containsHeader = "ContainsHeader"
            case customDatatypeConfigured = "CustomDatatypeConfigured"
            case customDatatypes = "CustomDatatypes"
            case delimiter = "Delimiter"
            case disableValueTrimming = "DisableValueTrimming"
            case header = "Header"
            case name = "Name"
            case quoteSymbol = "QuoteSymbol"
            case serde = "Serde"
        }
    }

    public struct CreateCustomEntityTypeRequest: AWSEncodableShape {
        /// A list of context words. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data. If no context words are passed only a regular expression is checked.
        public let contextWords: [String]?
        /// A name for the custom pattern that allows it to be retrieved or deleted later. This name must be unique per Amazon Web Services account.
        public let name: String
        /// A regular expression string that is used for detecting sensitive data in a custom pattern.
        public let regexString: String
        /// A list of tags applied to the custom entity type.
        public let tags: [String: String]?

        @inlinable
        public init(contextWords: [String]? = nil, name: String, regexString: String, tags: [String: String]? = nil) {
            self.contextWords = contextWords
            self.name = name
            self.regexString = regexString
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.contextWords?.forEach {
                try validate($0, name: "contextWords[]", parent: name, max: 255)
                try validate($0, name: "contextWords[]", parent: name, min: 1)
                try validate($0, name: "contextWords[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.contextWords, name: "contextWords", parent: name, max: 20)
            try self.validate(self.contextWords, name: "contextWords", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.regexString, name: "regexString", parent: name, max: 255)
            try self.validate(self.regexString, name: "regexString", parent: name, min: 1)
            try self.validate(self.regexString, name: "regexString", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case contextWords = "ContextWords"
            case name = "Name"
            case regexString = "RegexString"
            case tags = "Tags"
        }
    }

    public struct CreateCustomEntityTypeResponse: AWSDecodableShape {
        /// The name of the custom pattern you created.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateDataQualityRulesetRequest: AWSEncodableShape {
        /// Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.
        public let clientToken: String?
        /// The name of the security configuration created with the data quality encryption option.
        public let dataQualitySecurityConfiguration: String?
        /// A description of the data quality ruleset.
        public let description: String?
        /// A unique name for the data quality ruleset.
        public let name: String
        /// A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer guide.
        public let ruleset: String
        /// A list of tags applied to the data quality ruleset.
        public let tags: [String: String]?
        /// A target table associated with the data quality ruleset.
        public let targetTable: DataQualityTargetTable?

        @inlinable
        public init(clientToken: String? = nil, dataQualitySecurityConfiguration: String? = nil, description: String? = nil, name: String, ruleset: String, tags: [String: String]? = nil, targetTable: DataQualityTargetTable? = nil) {
            self.clientToken = clientToken
            self.dataQualitySecurityConfiguration = dataQualitySecurityConfiguration
            self.description = description
            self.name = name
            self.ruleset = ruleset
            self.tags = tags
            self.targetTable = targetTable
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 255)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.dataQualitySecurityConfiguration, name: "dataQualitySecurityConfiguration", parent: name, max: 255)
            try self.validate(self.dataQualitySecurityConfiguration, name: "dataQualitySecurityConfiguration", parent: name, min: 1)
            try self.validate(self.dataQualitySecurityConfiguration, name: "dataQualitySecurityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.ruleset, name: "ruleset", parent: name, max: 65536)
            try self.validate(self.ruleset, name: "ruleset", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.targetTable?.validate(name: "\(name).targetTable")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case dataQualitySecurityConfiguration = "DataQualitySecurityConfiguration"
            case description = "Description"
            case name = "Name"
            case ruleset = "Ruleset"
            case tags = "Tags"
            case targetTable = "TargetTable"
        }
    }

    public struct CreateDataQualityRulesetResponse: AWSDecodableShape {
        /// A unique name for the data quality ruleset.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateDatabaseRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which to create the database. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The metadata for the database.
        public let databaseInput: DatabaseInput
        /// The tags you assign to the database.
        public let tags: [String: String]?

        @inlinable
        public init(catalogId: String? = nil, databaseInput: DatabaseInput, tags: [String: String]? = nil) {
            self.catalogId = catalogId
            self.databaseInput = databaseInput
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.databaseInput.validate(name: "\(name).databaseInput")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseInput = "DatabaseInput"
            case tags = "Tags"
        }
    }

    public struct CreateDatabaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateDevEndpointRequest: AWSEncodableShape {
        /// A map of arguments used to configure the DevEndpoint.
        public let arguments: [String: String]?
        /// The name to be assigned to the new DevEndpoint.
        public let endpointName: String
        /// The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint.
        public let extraJarsS3Path: String?
        /// The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma.  You can only use pure Python libraries with a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not yet supported.
        public let extraPythonLibsS3Path: String?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Development endpoints that are created without specifying a Glue version default to Glue 0.9. You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public let glueVersion: String?
        /// The number of Glue Data Processing Units (DPUs) to allocate to this DevEndpoint.
        public let numberOfNodes: Int?
        /// The number of workers of a defined workerType that are allocated to the development endpoint. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
        public let numberOfWorkers: Int?
        /// The public key to be used by this DevEndpoint for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.
        public let publicKey: String?
        /// A list of public keys to be used by the development endpoints for authentication. The use of this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.  If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the UpdateDevEndpoint API with the public key content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys attribute.
        public let publicKeys: [String]?
        /// The IAM role for the DevEndpoint.
        public let roleArn: String
        /// The name of the SecurityConfiguration structure to be used with this DevEndpoint.
        public let securityConfiguration: String?
        /// Security group IDs for the security groups to be used by the new DevEndpoint.
        public let securityGroupIds: [String]?
        /// The subnet ID for the new DevEndpoint to use.
        public let subnetId: String?
        /// The tags to use with this DevEndpoint. You may use tags to limit access to the DevEndpoint. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
        public let tags: [String: String]?
        /// The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   Known issue: when a development endpoint is created with the G.2X WorkerType configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk.
        public let workerType: WorkerType?

        @inlinable
        public init(arguments: [String: String]? = nil, endpointName: String, extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil, glueVersion: String? = nil, numberOfNodes: Int? = nil, numberOfWorkers: Int? = nil, publicKey: String? = nil, publicKeys: [String]? = nil, roleArn: String, securityConfiguration: String? = nil, securityGroupIds: [String]? = nil, subnetId: String? = nil, tags: [String: String]? = nil, workerType: WorkerType? = nil) {
            self.arguments = arguments
            self.endpointName = endpointName
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.glueVersion = glueVersion
            self.numberOfNodes = numberOfNodes
            self.numberOfWorkers = numberOfWorkers
            self.publicKey = publicKey
            self.publicKeys = publicKeys
            self.roleArn = roleArn
            self.securityConfiguration = securityConfiguration
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
            self.tags = tags
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.validate(self.arguments, name: "arguments", parent: name, max: 100)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^(\\w+\\.)+\\w+$")
            try self.validate(self.publicKeys, name: "publicKeys", parent: name, max: 5)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::\\d{12}:role/")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case endpointName = "EndpointName"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case glueVersion = "GlueVersion"
            case numberOfNodes = "NumberOfNodes"
            case numberOfWorkers = "NumberOfWorkers"
            case publicKey = "PublicKey"
            case publicKeys = "PublicKeys"
            case roleArn = "RoleArn"
            case securityConfiguration = "SecurityConfiguration"
            case securityGroupIds = "SecurityGroupIds"
            case subnetId = "SubnetId"
            case tags = "Tags"
            case workerType = "WorkerType"
        }
    }

    public struct CreateDevEndpointResponse: AWSDecodableShape {
        /// The map of arguments used to configure this DevEndpoint. Valid arguments are:    "--enable-glue-datacatalog": ""    You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public let arguments: [String: String]?
        /// The Amazon Web Services Availability Zone where this DevEndpoint is located.
        public let availabilityZone: String?
        /// The point in time at which this DevEndpoint was created.
        public let createdTimestamp: Date?
        /// The name assigned to the new DevEndpoint.
        public let endpointName: String?
        /// Path to one or more Java .jar files in an S3 bucket that will be loaded in your DevEndpoint.
        public let extraJarsS3Path: String?
        /// The paths to one or more Python libraries in an S3 bucket that will be loaded in your DevEndpoint.
        public let extraPythonLibsS3Path: String?
        /// The reason for a current failure in this DevEndpoint.
        public let failureReason: String?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide.
        public let glueVersion: String?
        /// The number of Glue Data Processing Units (DPUs) allocated to this DevEndpoint.
        public let numberOfNodes: Int?
        /// The number of workers of a defined workerType that are allocated to the development endpoint.
        public let numberOfWorkers: Int?
        /// The Amazon Resource Name (ARN) of the role assigned to the new DevEndpoint.
        public let roleArn: String?
        /// The name of the SecurityConfiguration structure being used with this DevEndpoint.
        public let securityConfiguration: String?
        /// The security groups assigned to the new DevEndpoint.
        public let securityGroupIds: [String]?
        /// The current status of the new DevEndpoint.
        public let status: String?
        /// The subnet ID assigned to the new DevEndpoint.
        public let subnetId: String?
        /// The ID of the virtual private cloud (VPC) used by this DevEndpoint.
        public let vpcId: String?
        /// The type of predefined worker that is allocated to the development endpoint. May be a value of Standard, G.1X, or G.2X.
        public let workerType: WorkerType?
        /// The address of the YARN endpoint used by this DevEndpoint.
        public let yarnEndpointAddress: String?
        /// The Apache Zeppelin port for the remote Apache Spark interpreter.
        public let zeppelinRemoteSparkInterpreterPort: Int?

        @inlinable
        public init(arguments: [String: String]? = nil, availabilityZone: String? = nil, createdTimestamp: Date? = nil, endpointName: String? = nil, extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil, failureReason: String? = nil, glueVersion: String? = nil, numberOfNodes: Int? = nil, numberOfWorkers: Int? = nil, roleArn: String? = nil, securityConfiguration: String? = nil, securityGroupIds: [String]? = nil, status: String? = nil, subnetId: String? = nil, vpcId: String? = nil, workerType: WorkerType? = nil, yarnEndpointAddress: String? = nil, zeppelinRemoteSparkInterpreterPort: Int? = nil) {
            self.arguments = arguments
            self.availabilityZone = availabilityZone
            self.createdTimestamp = createdTimestamp
            self.endpointName = endpointName
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.failureReason = failureReason
            self.glueVersion = glueVersion
            self.numberOfNodes = numberOfNodes
            self.numberOfWorkers = numberOfWorkers
            self.roleArn = roleArn
            self.securityConfiguration = securityConfiguration
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetId = subnetId
            self.vpcId = vpcId
            self.workerType = workerType
            self.yarnEndpointAddress = yarnEndpointAddress
            self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case availabilityZone = "AvailabilityZone"
            case createdTimestamp = "CreatedTimestamp"
            case endpointName = "EndpointName"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case failureReason = "FailureReason"
            case glueVersion = "GlueVersion"
            case numberOfNodes = "NumberOfNodes"
            case numberOfWorkers = "NumberOfWorkers"
            case roleArn = "RoleArn"
            case securityConfiguration = "SecurityConfiguration"
            case securityGroupIds = "SecurityGroupIds"
            case status = "Status"
            case subnetId = "SubnetId"
            case vpcId = "VpcId"
            case workerType = "WorkerType"
            case yarnEndpointAddress = "YarnEndpointAddress"
            case zeppelinRemoteSparkInterpreterPort = "ZeppelinRemoteSparkInterpreterPort"
        }
    }

    public struct CreateGrokClassifierRequest: AWSEncodableShape {
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        public let classification: String
        /// Optional custom grok patterns used by this classifier.
        public let customPatterns: String?
        /// The grok pattern used by this classifier.
        public let grokPattern: String
        /// The name of the new classifier.
        public let name: String

        @inlinable
        public init(classification: String, customPatterns: String? = nil, grokPattern: String, name: String) {
            self.classification = classification
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.customPatterns, name: "customPatterns", parent: name, max: 16000)
            try self.validate(self.customPatterns, name: "customPatterns", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, max: 2048)
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, min: 1)
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case customPatterns = "CustomPatterns"
            case grokPattern = "GrokPattern"
            case name = "Name"
        }
    }

    public struct CreateIntegrationRequest: AWSEncodableShape {
        /// An optional set of non-secret keyvalue pairs that contains additional contextual information for encryption. This can only be provided if KMSKeyId is provided.
        public let additionalEncryptionContext: [String: String]?
        /// Selects source tables for the integration using Maxwell filter syntax.
        public let dataFilter: String?
        /// A description of the integration.
        public let description: String?
        /// A unique name for an integration in Glue.
        public let integrationName: String
        /// The ARN of a KMS key used for encrypting the channel.
        public let kmsKeyId: String?
        /// The ARN of the source resource for the integration.
        public let sourceArn: String
        /// Metadata assigned to the resource consisting of a list of key-value pairs.
        public let tags: [Tag]?
        /// The ARN of the target resource for the integration.
        public let targetArn: String

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, dataFilter: String? = nil, description: String? = nil, integrationName: String, kmsKeyId: String? = nil, sourceArn: String, tags: [Tag]? = nil, targetArn: String) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.dataFilter = dataFilter
            self.description = description
            self.integrationName = integrationName
            self.kmsKeyId = kmsKeyId
            self.sourceArn = sourceArn
            self.tags = tags
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.dataFilter, name: "dataFilter", parent: name, max: 2048)
            try self.validate(self.dataFilter, name: "dataFilter", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.integrationName, name: "integrationName", parent: name, max: 128)
            try self.validate(self.integrationName, name: "integrationName", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 128)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.targetArn, name: "targetArn", parent: name, max: 128)
            try self.validate(self.targetArn, name: "targetArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "AdditionalEncryptionContext"
            case dataFilter = "DataFilter"
            case description = "Description"
            case integrationName = "IntegrationName"
            case kmsKeyId = "KmsKeyId"
            case sourceArn = "SourceArn"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct CreateIntegrationResourcePropertyRequest: AWSEncodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String
        /// The resource properties associated with the integration source.
        public let sourceProcessingProperties: SourceProcessingProperties?
        /// The resource properties associated with the integration target.
        public let targetProcessingProperties: TargetProcessingProperties?

        @inlinable
        public init(resourceArn: String, sourceProcessingProperties: SourceProcessingProperties? = nil, targetProcessingProperties: TargetProcessingProperties? = nil) {
            self.resourceArn = resourceArn
            self.sourceProcessingProperties = sourceProcessingProperties
            self.targetProcessingProperties = targetProcessingProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.sourceProcessingProperties?.validate(name: "\(name).sourceProcessingProperties")
            try self.targetProcessingProperties?.validate(name: "\(name).targetProcessingProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case sourceProcessingProperties = "SourceProcessingProperties"
            case targetProcessingProperties = "TargetProcessingProperties"
        }
    }

    public struct CreateIntegrationResourcePropertyResponse: AWSDecodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String
        /// The resource properties associated with the integration source.
        public let sourceProcessingProperties: SourceProcessingProperties?
        /// The resource properties associated with the integration target.
        public let targetProcessingProperties: TargetProcessingProperties?

        @inlinable
        public init(resourceArn: String, sourceProcessingProperties: SourceProcessingProperties? = nil, targetProcessingProperties: TargetProcessingProperties? = nil) {
            self.resourceArn = resourceArn
            self.sourceProcessingProperties = sourceProcessingProperties
            self.targetProcessingProperties = targetProcessingProperties
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case sourceProcessingProperties = "SourceProcessingProperties"
            case targetProcessingProperties = "TargetProcessingProperties"
        }
    }

    public struct CreateIntegrationResponse: AWSDecodableShape {
        /// An optional set of non-secret keyvalue pairs that contains additional contextual information for encryption.
        public let additionalEncryptionContext: [String: String]?
        /// The time when the integration was created, in UTC.
        public let createTime: Date
        /// Selects source tables for the integration using Maxwell filter syntax.
        public let dataFilter: String?
        /// A description of the integration.
        public let description: String?
        /// A list of errors associated with the integration creation.
        public let errors: [IntegrationError]?
        /// The Amazon Resource Name (ARN) for the created integration.
        public let integrationArn: String
        /// A unique name for an integration in Glue.
        public let integrationName: String
        /// The ARN of a KMS key used for encrypting the channel.
        public let kmsKeyId: String?
        /// The ARN of the source resource for the integration.
        public let sourceArn: String
        /// The status of the integration being created. The possible statuses are:   CREATING: The integration is being created.   ACTIVE: The integration creation succeeds.   MODIFYING: The integration is being modified.   FAILED: The integration creation fails.    DELETING: The integration is deleted.   SYNCING: The integration is synchronizing.   NEEDS_ATTENTION: The integration needs attention, such as synchronization.
        public let status: IntegrationStatus
        /// Metadata assigned to the resource consisting of a list of key-value pairs.
        public let tags: [Tag]?
        /// The ARN of the target resource for the integration.
        public let targetArn: String

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, createTime: Date, dataFilter: String? = nil, description: String? = nil, errors: [IntegrationError]? = nil, integrationArn: String, integrationName: String, kmsKeyId: String? = nil, sourceArn: String, status: IntegrationStatus, tags: [Tag]? = nil, targetArn: String) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.createTime = createTime
            self.dataFilter = dataFilter
            self.description = description
            self.errors = errors
            self.integrationArn = integrationArn
            self.integrationName = integrationName
            self.kmsKeyId = kmsKeyId
            self.sourceArn = sourceArn
            self.status = status
            self.tags = tags
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "AdditionalEncryptionContext"
            case createTime = "CreateTime"
            case dataFilter = "DataFilter"
            case description = "Description"
            case errors = "Errors"
            case integrationArn = "IntegrationArn"
            case integrationName = "IntegrationName"
            case kmsKeyId = "KmsKeyId"
            case sourceArn = "SourceArn"
            case status = "Status"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct CreateIntegrationTablePropertiesRequest: AWSEncodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String
        /// A structure for the source table configuration.
        public let sourceTableConfig: SourceTableConfig?
        /// The name of the table to be replicated.
        public let tableName: String
        /// A structure for the target table configuration.
        public let targetTableConfig: TargetTableConfig?

        @inlinable
        public init(resourceArn: String, sourceTableConfig: SourceTableConfig? = nil, tableName: String, targetTableConfig: TargetTableConfig? = nil) {
            self.resourceArn = resourceArn
            self.sourceTableConfig = sourceTableConfig
            self.tableName = tableName
            self.targetTableConfig = targetTableConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.sourceTableConfig?.validate(name: "\(name).sourceTableConfig")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 128)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.targetTableConfig?.validate(name: "\(name).targetTableConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case sourceTableConfig = "SourceTableConfig"
            case tableName = "TableName"
            case targetTableConfig = "TargetTableConfig"
        }
    }

    public struct CreateIntegrationTablePropertiesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateJobRequest: AWSEncodableShape {
        /// This parameter is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs) to allocate to this Job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.
        public let allocatedCapacity: Int?
        /// The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.
        public let codeGenConfigurationNodes: [String: CodeGenConfigurationNode]?
        /// The JobCommand that runs this job.
        public let command: JobCommand
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// The default arguments for every run of this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job.  For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see Using job parameters in Ray jobs in the developer guide.
        public let defaultArguments: [String: String]?
        /// Description of the job being defined.
        public let description: String?
        /// Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary.  Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
        public let executionClass: ExecutionClass?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark.  Ray jobs should set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the Runtime parameter of the Job command. For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
        public let glueVersion: String?
        /// A mode that describes how a job was created. Valid values are:    SCRIPT - The job was created using the Glue Studio script editor.    VISUAL - The job was created using the Glue Studio visual editor.    NOTEBOOK - The job was created using an interactive sessions notebook.   When the JobMode field is missing or null, SCRIPT is assigned as the default value.
        public let jobMode: JobMode?
        /// Specifies whether job run queuing is enabled for the job runs for this job. A value of true means job run queuing is enabled for the job runs. If false or not populated, the job runs will not be considered for queueing. If this field does not match the value set in the job run, then the value from the job run field will be used.
        public let jobRunQueuingEnabled: Bool?
        /// This field is reserved for future use.
        public let logUri: String?
        /// This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue periodically performs maintenance activities. During these maintenance windows, Glue will need to restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will be restarted between 10:00AM GMT to 1:00PM GMT.
        public let maintenanceWindow: String?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the  Glue pricing page. For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache  Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs.  The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
        public let maxCapacity: Double?
        /// The maximum number of times to retry this job if it fails.
        public let maxRetries: Int?
        /// The name you assign to this job definition. It must be unique in your account.
        public let name: String
        /// Arguments for this job that are not overridden when providing job arguments in a job run, specified as name-value pairs.
        public let nonOverridableArguments: [String: String]?
        /// Specifies configuration properties of a job notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs.
        public let numberOfWorkers: Int?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
        public let role: String
        /// The name of the SecurityConfiguration structure to be used with this job.
        public let securityConfiguration: String?
        /// The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.
        public let sourceControlDetails: SourceControlDetails?
        /// The tags to use with this job. You may use tags to limit access to the job. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
        public let tags: [String: String]?
        /// The job timeout in minutes.  This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. Jobs must have timeout values less than 7 days or 10080 minutes. Otherwise, the jobs will throw an exception. When the value is left blank, the timeout is defaulted to 2880 minutes. Any existing Glue jobs that had a timeout value greater than 7 days will be defaulted to 7 days. For instance if you have specified a timeout of 20 days for a batch job, it will be stopped on the 7th day. For streaming jobs, if you have set up a maintenance window, it will be restarted during the maintenance window after 7 days.
        public let timeout: Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 94GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 138GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).   For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.   For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk, and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 or later streaming jobs.   For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk, and provides up to 8 Ray workers based on the autoscaler.
        public let workerType: WorkerType?

        @inlinable
        public init(codeGenConfigurationNodes: [String: CodeGenConfigurationNode]? = nil, command: JobCommand, connections: ConnectionsList? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionClass: ExecutionClass? = nil, executionProperty: ExecutionProperty? = nil, glueVersion: String? = nil, jobMode: JobMode? = nil, jobRunQueuingEnabled: Bool? = nil, logUri: String? = nil, maintenanceWindow: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String, nonOverridableArguments: [String: String]? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, role: String, securityConfiguration: String? = nil, sourceControlDetails: SourceControlDetails? = nil, tags: [String: String]? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.allocatedCapacity = nil
            self.codeGenConfigurationNodes = codeGenConfigurationNodes
            self.command = command
            self.connections = connections
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionClass = executionClass
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.jobMode = jobMode
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.logUri = logUri
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.sourceControlDetails = sourceControlDetails
            self.tags = tags
            self.timeout = timeout
            self.workerType = workerType
        }

        @available(*, deprecated, message: "Members allocatedCapacity have been deprecated")
        @inlinable
        public init(allocatedCapacity: Int? = nil, codeGenConfigurationNodes: [String: CodeGenConfigurationNode]? = nil, command: JobCommand, connections: ConnectionsList? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionClass: ExecutionClass? = nil, executionProperty: ExecutionProperty? = nil, glueVersion: String? = nil, jobMode: JobMode? = nil, jobRunQueuingEnabled: Bool? = nil, logUri: String? = nil, maintenanceWindow: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String, nonOverridableArguments: [String: String]? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, role: String, securityConfiguration: String? = nil, sourceControlDetails: SourceControlDetails? = nil, tags: [String: String]? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.allocatedCapacity = allocatedCapacity
            self.codeGenConfigurationNodes = codeGenConfigurationNodes
            self.command = command
            self.connections = connections
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionClass = executionClass
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.jobMode = jobMode
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.logUri = logUri
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.sourceControlDetails = sourceControlDetails
            self.tags = tags
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.codeGenConfigurationNodes?.forEach {
                try validate($0.key, name: "codeGenConfigurationNodes.key", parent: name, pattern: "^[A-Za-z0-9_-]*$")
                try $0.value.validate(name: "\(name).codeGenConfigurationNodes[\"\($0.key)\"]")
            }
            try self.command.validate(name: "\(name).command")
            try self.connections?.validate(name: "\(name).connections")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^(\\w+\\.)+\\w+$")
            try self.validate(self.maintenanceWindow, name: "maintenanceWindow", parent: name, pattern: "^(Sun|Mon|Tue|Wed|Thu|Fri|Sat):([01]?[0-9]|2[0-3])$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.notificationProperty?.validate(name: "\(name).notificationProperty")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.sourceControlDetails?.validate(name: "\(name).sourceControlDetails")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedCapacity = "AllocatedCapacity"
            case codeGenConfigurationNodes = "CodeGenConfigurationNodes"
            case command = "Command"
            case connections = "Connections"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case executionClass = "ExecutionClass"
            case executionProperty = "ExecutionProperty"
            case glueVersion = "GlueVersion"
            case jobMode = "JobMode"
            case jobRunQueuingEnabled = "JobRunQueuingEnabled"
            case logUri = "LogUri"
            case maintenanceWindow = "MaintenanceWindow"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case nonOverridableArguments = "NonOverridableArguments"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case sourceControlDetails = "SourceControlDetails"
            case tags = "Tags"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct CreateJobResponse: AWSDecodableShape {
        /// The unique name that was provided for this job definition.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateJsonClassifierRequest: AWSEncodableShape {
        /// A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
        public let jsonPath: String
        /// The name of the classifier.
        public let name: String

        @inlinable
        public init(jsonPath: String, name: String) {
            self.jsonPath = jsonPath
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jsonPath = "JsonPath"
            case name = "Name"
        }
    }

    public struct CreateMLTransformRequest: AWSEncodableShape {
        /// A description of the machine learning transform that is being defined. The default is an empty string.
        public let description: String?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see Glue Versions in the developer guide.
        public let glueVersion: String?
        /// A list of Glue table definitions used by the transform.
        public let inputRecordTables: [GlueTable]
        /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.   MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.   If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.   If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.   If WorkerType is set, then NumberOfWorkers is required (and vice versa).    MaxCapacity and NumberOfWorkers must both be at least 1.   When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only. When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
        public let maxCapacity: Double?
        /// The maximum number of times to retry a task for this transform after a task run fails.
        public let maxRetries: Int?
        /// The unique name that you give the transform when you create it.
        public let name: String
        /// The number of workers of a defined workerType that are allocated when this task runs. If WorkerType is set, then NumberOfWorkers is required (and vice versa).
        public let numberOfWorkers: Int?
        /// The algorithmic parameters that are specific to the transform type used. Conditionally dependent on the transform type.
        public let parameters: TransformParameters
        /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform.    This role needs Glue service role permissions to allow access to resources in Glue. See Attach a Policy to IAM Users That Access Glue.   This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.
        public let role: String
        /// The tags to use with this machine learning transform. You may use tags to limit access to the machine learning transform. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
        public let tags: [String: String]?
        /// The timeout of the task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?
        /// The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.
        public let transformEncryption: TransformEncryption?
        /// The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.    MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.   If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.   If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.   If WorkerType is set, then NumberOfWorkers is required (and vice versa).    MaxCapacity and NumberOfWorkers must both be at least 1.
        public let workerType: WorkerType?

        @inlinable
        public init(description: String? = nil, glueVersion: String? = nil, inputRecordTables: [GlueTable], maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String, numberOfWorkers: Int? = nil, parameters: TransformParameters, role: String, tags: [String: String]? = nil, timeout: Int? = nil, transformEncryption: TransformEncryption? = nil, workerType: WorkerType? = nil) {
            self.description = description
            self.glueVersion = glueVersion
            self.inputRecordTables = inputRecordTables
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.numberOfWorkers = numberOfWorkers
            self.parameters = parameters
            self.role = role
            self.tags = tags
            self.timeout = timeout
            self.transformEncryption = transformEncryption
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^(\\w+\\.)+\\w+$")
            try self.inputRecordTables.forEach {
                try $0.validate(name: "\(name).inputRecordTables[]")
            }
            try self.validate(self.inputRecordTables, name: "inputRecordTables", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.parameters.validate(name: "\(name).parameters")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
            try self.transformEncryption?.validate(name: "\(name).transformEncryption")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case glueVersion = "GlueVersion"
            case inputRecordTables = "InputRecordTables"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case numberOfWorkers = "NumberOfWorkers"
            case parameters = "Parameters"
            case role = "Role"
            case tags = "Tags"
            case timeout = "Timeout"
            case transformEncryption = "TransformEncryption"
            case workerType = "WorkerType"
        }
    }

    public struct CreateMLTransformResponse: AWSDecodableShape {
        /// A unique identifier that is generated for the transform.
        public let transformId: String?

        @inlinable
        public init(transformId: String? = nil) {
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct CreatePartitionIndexRequest: AWSEncodableShape {
        /// The catalog ID where the table resides.
        public let catalogId: String?
        /// Specifies the name of a database in which you want to create a partition index.
        public let databaseName: String
        /// Specifies a PartitionIndex structure to create a partition index in an existing table.
        public let partitionIndex: PartitionIndex
        /// Specifies the name of a table in which you want to create a partition index.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, partitionIndex: PartitionIndex, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionIndex = partitionIndex
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionIndex.validate(name: "\(name).partitionIndex")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionIndex = "PartitionIndex"
            case tableName = "TableName"
        }
    }

    public struct CreatePartitionIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreatePartitionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the catalog in which the partition is to be created.
        public let catalogId: String?
        /// The name of the metadata database in which the partition is to be created.
        public let databaseName: String
        /// A PartitionInput structure defining the partition to be created.
        public let partitionInput: PartitionInput
        /// The name of the metadata table in which the partition is to be created.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, partitionInput: PartitionInput, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionInput = partitionInput
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionInput.validate(name: "\(name).partitionInput")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionInput = "PartitionInput"
            case tableName = "TableName"
        }
    }

    public struct CreatePartitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateRegistryInput: AWSEncodableShape {
        /// A description of the registry. If description is not provided, there will not be any default value for this.
        public let description: String?
        /// Name of the registry to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark.  No whitespace.
        public let registryName: String
        /// Amazon Web Services tags that contain a key value pair and may be searched by console, command line, or API.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, registryName: String, tags: [String: String]? = nil) {
            self.description = description
            self.registryName = registryName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.registryName, name: "registryName", parent: name, max: 255)
            try self.validate(self.registryName, name: "registryName", parent: name, min: 1)
            try self.validate(self.registryName, name: "registryName", parent: name, pattern: "^[a-zA-Z0-9-_$#.]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryName = "RegistryName"
            case tags = "Tags"
        }
    }

    public struct CreateRegistryResponse: AWSDecodableShape {
        /// A description of the registry.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the newly created registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// The tags for the registry.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, registryArn: String? = nil, registryName: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case tags = "Tags"
        }
    }

    public struct CreateSchemaInput: AWSEncodableShape {
        /// The compatibility mode of the schema. The possible values are:    NONE: No compatibility mode applies. You can use this choice in development scenarios or if you do not know the compatibility mode that you want to apply to schemas. Any new version added will be accepted without undergoing a compatibility check.    DISABLED: This compatibility choice prevents versioning for a particular schema. You can use this choice to prevent future versioning of a schema.    BACKWARD: This compatibility choice is recommended as it allows data receivers to read both the current and one previous schema version. This means that for instance, a new schema version cannot drop data fields or change the type of these fields, so they can't be read by readers using the previous version.    BACKWARD_ALL: This compatibility choice allows data receivers to read both the current and all previous schema versions. You can use this choice when you need to delete fields or add optional fields, and check compatibility against all previous schema versions.     FORWARD: This compatibility choice allows data receivers to read both the current and one next schema version, but not necessarily later versions. You can use this choice when you need to add fields or delete optional fields, but only check compatibility against the last schema version.    FORWARD_ALL: This compatibility choice allows data receivers to read written by producers of any new registered schema. You can use this choice when you need to add fields or delete optional fields, and check compatibility against all previous schema versions.    FULL: This compatibility choice allows data receivers to read data written by producers using the previous or next version of the schema, but not necessarily earlier or later versions. You can use this choice when you need to add or remove optional fields, but only check compatibility against the last schema version.    FULL_ALL: This compatibility choice allows data receivers to read data written by producers using all previous schema versions. You can use this choice when you need to add or remove optional fields, and check compatibility against all previous schema versions.
        public let compatibility: Compatibility?
        /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
        public let dataFormat: DataFormat
        /// An optional description of the schema. If description is not provided, there will not be any automatic default value for this.
        public let description: String?
        ///  This is a wrapper shape to contain the registry identity fields. If this is not provided, the default registry will be used. The ARN format for the same will be: arn:aws:glue:us-east-2::registry/default-registry:random-5-letter-id.
        public let registryId: RegistryId?
        /// The schema definition using the DataFormat setting for SchemaName.
        public let schemaDefinition: String?
        /// Name of the schema to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark. No whitespace.
        public let schemaName: String
        /// Amazon Web Services tags that contain a key value pair and may be searched by console, command line, or API. If specified, follows the Amazon Web Services tags-on-create pattern.
        public let tags: [String: String]?

        @inlinable
        public init(compatibility: Compatibility? = nil, dataFormat: DataFormat, description: String? = nil, registryId: RegistryId? = nil, schemaDefinition: String? = nil, schemaName: String, tags: [String: String]? = nil) {
            self.compatibility = compatibility
            self.dataFormat = dataFormat
            self.description = description
            self.registryId = registryId
            self.schemaDefinition = schemaDefinition
            self.schemaName = schemaName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.registryId?.validate(name: "\(name).registryId")
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, max: 170000)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, min: 1)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, pattern: "\\S")
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z0-9-_$#.]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case compatibility = "Compatibility"
            case dataFormat = "DataFormat"
            case description = "Description"
            case registryId = "RegistryId"
            case schemaDefinition = "SchemaDefinition"
            case schemaName = "SchemaName"
            case tags = "Tags"
        }
    }

    public struct CreateSchemaResponse: AWSDecodableShape {
        /// The schema compatibility mode.
        public let compatibility: Compatibility?
        /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
        public let dataFormat: DataFormat?
        /// A description of the schema if specified when created.
        public let description: String?
        /// The latest version of the schema associated with the returned schema definition.
        public let latestSchemaVersion: Int64?
        /// The next version of the schema associated with the returned schema definition.
        public let nextSchemaVersion: Int64?
        /// The Amazon Resource Name (ARN) of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The version number of the checkpoint (the last time the compatibility mode was changed).
        public let schemaCheckpoint: Int64?
        /// The name of the schema.
        public let schemaName: String?
        /// The status of the schema.
        public let schemaStatus: SchemaStatus?
        /// The unique identifier of the first schema version.
        public let schemaVersionId: String?
        /// The status of the first schema version created.
        public let schemaVersionStatus: SchemaVersionStatus?
        /// The tags for the schema.
        public let tags: [String: String]?

        @inlinable
        public init(compatibility: Compatibility? = nil, dataFormat: DataFormat? = nil, description: String? = nil, latestSchemaVersion: Int64? = nil, nextSchemaVersion: Int64? = nil, registryArn: String? = nil, registryName: String? = nil, schemaArn: String? = nil, schemaCheckpoint: Int64? = nil, schemaName: String? = nil, schemaStatus: SchemaStatus? = nil, schemaVersionId: String? = nil, schemaVersionStatus: SchemaVersionStatus? = nil, tags: [String: String]? = nil) {
            self.compatibility = compatibility
            self.dataFormat = dataFormat
            self.description = description
            self.latestSchemaVersion = latestSchemaVersion
            self.nextSchemaVersion = nextSchemaVersion
            self.registryArn = registryArn
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaCheckpoint = schemaCheckpoint
            self.schemaName = schemaName
            self.schemaStatus = schemaStatus
            self.schemaVersionId = schemaVersionId
            self.schemaVersionStatus = schemaVersionStatus
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case compatibility = "Compatibility"
            case dataFormat = "DataFormat"
            case description = "Description"
            case latestSchemaVersion = "LatestSchemaVersion"
            case nextSchemaVersion = "NextSchemaVersion"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaCheckpoint = "SchemaCheckpoint"
            case schemaName = "SchemaName"
            case schemaStatus = "SchemaStatus"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionStatus = "SchemaVersionStatus"
            case tags = "Tags"
        }
    }

    public struct CreateScriptRequest: AWSEncodableShape {
        /// A list of the edges in the DAG.
        public let dagEdges: [CodeGenEdge]?
        /// A list of the nodes in the DAG.
        public let dagNodes: [CodeGenNode]?
        /// The programming language of the resulting code from the DAG.
        public let language: Language?

        @inlinable
        public init(dagEdges: [CodeGenEdge]? = nil, dagNodes: [CodeGenNode]? = nil, language: Language? = nil) {
            self.dagEdges = dagEdges
            self.dagNodes = dagNodes
            self.language = language
        }

        public func validate(name: String) throws {
            try self.dagEdges?.forEach {
                try $0.validate(name: "\(name).dagEdges[]")
            }
            try self.dagNodes?.forEach {
                try $0.validate(name: "\(name).dagNodes[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dagEdges = "DagEdges"
            case dagNodes = "DagNodes"
            case language = "Language"
        }
    }

    public struct CreateScriptResponse: AWSDecodableShape {
        /// The Python script generated from the DAG.
        public let pythonScript: String?
        /// The Scala code generated from the DAG.
        public let scalaCode: String?

        @inlinable
        public init(pythonScript: String? = nil, scalaCode: String? = nil) {
            self.pythonScript = pythonScript
            self.scalaCode = scalaCode
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
            case scalaCode = "ScalaCode"
        }
    }

    public struct CreateSecurityConfigurationRequest: AWSEncodableShape {
        /// The encryption configuration for the new security configuration.
        public let encryptionConfiguration: EncryptionConfiguration
        /// The name for the new security configuration.
        public let name: String

        @inlinable
        public init(encryptionConfiguration: EncryptionConfiguration, name: String) {
            self.encryptionConfiguration = encryptionConfiguration
            self.name = name
        }

        public func validate(name: String) throws {
            try self.encryptionConfiguration.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "EncryptionConfiguration"
            case name = "Name"
        }
    }

    public struct CreateSecurityConfigurationResponse: AWSDecodableShape {
        /// The time at which the new security configuration was created.
        public let createdTimestamp: Date?
        /// The name assigned to the new security configuration.
        public let name: String?

        @inlinable
        public init(createdTimestamp: Date? = nil, name: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case name = "Name"
        }
    }

    public struct CreateSessionRequest: AWSEncodableShape {
        /// The SessionCommand that runs the job.
        public let command: SessionCommand
        /// The number of connections to use for the session.
        public let connections: ConnectionsList?
        /// A map array of key-value pairs. Max is 75 pairs.
        public let defaultArguments: [String: String]?
        /// The description of the session.
        public let description: String?
        /// The Glue version determines the versions of Apache Spark and Python that Glue supports.  The GlueVersion must be greater than 2.0.
        public let glueVersion: String?
        /// The ID of the session request.
        public let id: String
        ///  The number of minutes when idle before session times out. Default for Spark ETL jobs is value of Timeout. Consult the documentation for other job types.
        public let idleTimeout: Int?
        /// The number of Glue data processing units (DPUs) that can be allocated when the job runs.  A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.
        public let maxCapacity: Double?
        /// The number of workers of a defined WorkerType to use for the session.
        public let numberOfWorkers: Int?
        /// The origin of the request.
        public let requestOrigin: String?
        /// The IAM Role ARN
        public let role: String
        /// The name of the SecurityConfiguration structure to be used with the session
        public let securityConfiguration: String?
        /// The map of key value pairs (tags) belonging to the session.
        public let tags: [String: String]?
        ///  The number of minutes before session times out. Default for Spark ETL jobs is 48 hours (2880 minutes). Consult the documentation for other job types.
        public let timeout: Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, or G.8X for Spark jobs. Accepts the value Z.2X for Ray notebooks.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 94GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 138GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).   For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.   For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk, and provides up to 8 Ray workers based on the autoscaler.
        public let workerType: WorkerType?

        @inlinable
        public init(command: SessionCommand, connections: ConnectionsList? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, glueVersion: String? = nil, id: String, idleTimeout: Int? = nil, maxCapacity: Double? = nil, numberOfWorkers: Int? = nil, requestOrigin: String? = nil, role: String, securityConfiguration: String? = nil, tags: [String: String]? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.command = command
            self.connections = connections
            self.defaultArguments = defaultArguments
            self.description = description
            self.glueVersion = glueVersion
            self.id = id
            self.idleTimeout = idleTimeout
            self.maxCapacity = maxCapacity
            self.numberOfWorkers = numberOfWorkers
            self.requestOrigin = requestOrigin
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.tags = tags
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.command.validate(name: "\(name).command")
            try self.connections?.validate(name: "\(name).connections")
            try self.defaultArguments?.forEach {
                try validate($0.key, name: "defaultArguments.key", parent: name, max: 128)
                try validate($0.key, name: "defaultArguments.key", parent: name, min: 1)
                try validate($0.key, name: "defaultArguments.key", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
                try validate($0.value, name: "defaultArguments[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "defaultArguments[\"\($0.key)\"]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            }
            try self.validate(self.defaultArguments, name: "defaultArguments", parent: name, max: 75)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^(\\w+\\.)+\\w+$")
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.idleTimeout, name: "idleTimeout", parent: name, min: 1)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, max: 128)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, min: 1)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:aws[^:]*:iam::[0-9]*:role/.+$")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case connections = "Connections"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case glueVersion = "GlueVersion"
            case id = "Id"
            case idleTimeout = "IdleTimeout"
            case maxCapacity = "MaxCapacity"
            case numberOfWorkers = "NumberOfWorkers"
            case requestOrigin = "RequestOrigin"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case tags = "Tags"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct CreateSessionResponse: AWSDecodableShape {
        /// Returns the session object in the response.
        public let session: Session?

        @inlinable
        public init(session: Session? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "Session"
        }
    }

    public struct CreateTableOptimizerRequest: AWSEncodableShape {
        /// The Catalog ID of the table.
        public let catalogId: String
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String
        /// The name of the table.
        public let tableName: String
        /// A TableOptimizerConfiguration object representing the configuration of a table optimizer.
        public let tableOptimizerConfiguration: TableOptimizerConfiguration
        /// The type of table optimizer.
        public let type: TableOptimizerType

        @inlinable
        public init(catalogId: String, databaseName: String, tableName: String, tableOptimizerConfiguration: TableOptimizerConfiguration, type: TableOptimizerType) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.tableOptimizerConfiguration = tableOptimizerConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tableOptimizerConfiguration.validate(name: "\(name).tableOptimizerConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case tableOptimizerConfiguration = "TableOptimizerConfiguration"
            case type = "Type"
        }
    }

    public struct CreateTableOptimizerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which to create the Table. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The catalog database in which to create the new table. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// Specifies an OpenTableFormatInput structure when creating an open format table.
        public let openTableFormatInput: OpenTableFormatInput?
        /// A list of partition indexes, PartitionIndex structures, to create in the table.
        public let partitionIndexes: [PartitionIndex]?
        /// The TableInput object that defines the metadata table to create in the catalog.
        public let tableInput: TableInput
        /// The ID of the transaction.
        public let transactionId: String?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, openTableFormatInput: OpenTableFormatInput? = nil, partitionIndexes: [PartitionIndex]? = nil, tableInput: TableInput, transactionId: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.openTableFormatInput = openTableFormatInput
            self.partitionIndexes = partitionIndexes
            self.tableInput = tableInput
            self.transactionId = transactionId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.openTableFormatInput?.validate(name: "\(name).openTableFormatInput")
            try self.partitionIndexes?.forEach {
                try $0.validate(name: "\(name).partitionIndexes[]")
            }
            try self.validate(self.partitionIndexes, name: "partitionIndexes", parent: name, max: 3)
            try self.tableInput.validate(name: "\(name).tableInput")
            try self.validate(self.transactionId, name: "transactionId", parent: name, max: 255)
            try self.validate(self.transactionId, name: "transactionId", parent: name, min: 1)
            try self.validate(self.transactionId, name: "transactionId", parent: name, pattern: "^[\\p{L}\\p{N}\\p{P}]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case openTableFormatInput = "OpenTableFormatInput"
            case partitionIndexes = "PartitionIndexes"
            case tableInput = "TableInput"
            case transactionId = "TransactionId"
        }
    }

    public struct CreateTableResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateTriggerRequest: AWSEncodableShape {
        /// The actions initiated by this trigger when it fires.
        public let actions: [Action]
        /// A description of the new trigger.
        public let description: String?
        /// Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.
        public let eventBatchingCondition: EventBatchingCondition?
        /// The name of the trigger.
        public let name: String
        /// A predicate to specify when the new trigger should fire. This field is required when the trigger type is CONDITIONAL.
        public let predicate: Predicate?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *). This field is required when the trigger type is SCHEDULED.
        public let schedule: String?
        /// Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
        public let startOnCreation: Bool?
        /// The tags to use with this trigger. You may use tags to limit access to the trigger. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
        public let tags: [String: String]?
        /// The type of the new trigger.
        public let type: TriggerType
        /// The name of the workflow associated with the trigger.
        public let workflowName: String?

        @inlinable
        public init(actions: [Action], description: String? = nil, eventBatchingCondition: EventBatchingCondition? = nil, name: String, predicate: Predicate? = nil, schedule: String? = nil, startOnCreation: Bool? = nil, tags: [String: String]? = nil, type: TriggerType, workflowName: String? = nil) {
            self.actions = actions
            self.description = description
            self.eventBatchingCondition = eventBatchingCondition
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
            self.startOnCreation = startOnCreation
            self.tags = tags
            self.type = type
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.eventBatchingCondition?.validate(name: "\(name).eventBatchingCondition")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.predicate?.validate(name: "\(name).predicate")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case eventBatchingCondition = "EventBatchingCondition"
            case name = "Name"
            case predicate = "Predicate"
            case schedule = "Schedule"
            case startOnCreation = "StartOnCreation"
            case tags = "Tags"
            case type = "Type"
            case workflowName = "WorkflowName"
        }
    }

    public struct CreateTriggerResponse: AWSDecodableShape {
        /// The name of the trigger.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateUsageProfileRequest: AWSEncodableShape {
        /// A ProfileConfiguration object specifying the job and session values for the profile.
        public let configuration: ProfileConfiguration
        /// A description of the usage profile.
        public let description: String?
        /// The name of the usage profile.
        public let name: String
        /// A list of tags applied to the usage profile.
        public let tags: [String: String]?

        @inlinable
        public init(configuration: ProfileConfiguration, description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.configuration = configuration
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateUsageProfileResponse: AWSDecodableShape {
        /// The name of the usage profile that was created.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateUserDefinedFunctionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which to create the function. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which to create the function.
        public let databaseName: String
        /// A FunctionInput object that defines the function to create in the Data Catalog.
        public let functionInput: UserDefinedFunctionInput

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, functionInput: UserDefinedFunctionInput) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionInput = functionInput
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.functionInput.validate(name: "\(name).functionInput")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionInput = "FunctionInput"
        }
    }

    public struct CreateUserDefinedFunctionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateWorkflowRequest: AWSEncodableShape {
        /// A collection of properties to be used as part of each execution of the workflow. Run properties may be logged. Do not pass plaintext secrets as properties. Retrieve secrets from a Glue Connection, Amazon Web Services Secrets Manager or other secret management mechanism if you intend to use them within the workflow run.
        public let defaultRunProperties: [String: String]?
        /// A description of the workflow.
        public let description: String?
        /// You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
        public let maxConcurrentRuns: Int?
        /// The name to be assigned to the workflow. It should be unique within your account.
        public let name: String
        /// The tags to be used with this workflow.
        public let tags: [String: String]?

        @inlinable
        public init(defaultRunProperties: [String: String]? = nil, description: String? = nil, maxConcurrentRuns: Int? = nil, name: String, tags: [String: String]? = nil) {
            self.defaultRunProperties = defaultRunProperties
            self.description = description
            self.maxConcurrentRuns = maxConcurrentRuns
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.defaultRunProperties?.forEach {
                try validate($0.key, name: "defaultRunProperties.key", parent: name, max: 255)
                try validate($0.key, name: "defaultRunProperties.key", parent: name, min: 1)
                try validate($0.key, name: "defaultRunProperties.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.description, name: "description", parent: name, max: 120000)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultRunProperties = "DefaultRunProperties"
            case description = "Description"
            case maxConcurrentRuns = "MaxConcurrentRuns"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateWorkflowResponse: AWSDecodableShape {
        /// The name of the workflow which was provided as part of the request.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateXMLClassifierRequest: AWSEncodableShape {
        /// An identifier of the data format that the classifier matches.
        public let classification: String
        /// The name of the classifier.
        public let name: String
        /// The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by />). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example,  is okay, but is not).
        public let rowTag: String?

        @inlinable
        public init(classification: String, name: String, rowTag: String? = nil) {
            self.classification = classification
            self.name = name
            self.rowTag = rowTag
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case name = "Name"
            case rowTag = "RowTag"
        }
    }

    public struct CsvClassifier: AWSDecodableShape {
        /// Enables the processing of files that contain only one column.
        public let allowSingleColumn: Bool?
        /// Indicates whether the CSV file contains a header.
        public let containsHeader: CsvHeaderOption?
        /// The time that this classifier was registered.
        public let creationTime: Date?
        /// Enables the custom datatype to be configured.
        public let customDatatypeConfigured: Bool?
        /// A list of custom datatypes including "BINARY", "BOOLEAN", "DATE", "DECIMAL", "DOUBLE", "FLOAT", "INT", "LONG", "SHORT", "STRING", "TIMESTAMP".
        public let customDatatypes: [String]?
        /// A custom symbol to denote what separates each column entry in the row.
        public let delimiter: String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public let disableValueTrimming: Bool?
        /// A list of strings representing column names.
        public let header: [String]?
        /// The time that this classifier was last updated.
        public let lastUpdated: Date?
        /// The name of the classifier.
        public let name: String
        /// A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        public let quoteSymbol: String?
        /// Sets the SerDe for processing CSV in the classifier, which will be applied in the Data Catalog. Valid values are OpenCSVSerDe, LazySimpleSerDe, and None. You can specify the None value when you want the crawler to do the detection.
        public let serde: CsvSerdeOption?
        /// The version of this classifier.
        public let version: Int64?

        @inlinable
        public init(allowSingleColumn: Bool? = nil, containsHeader: CsvHeaderOption? = nil, creationTime: Date? = nil, customDatatypeConfigured: Bool? = nil, customDatatypes: [String]? = nil, delimiter: String? = nil, disableValueTrimming: Bool? = nil, header: [String]? = nil, lastUpdated: Date? = nil, name: String, quoteSymbol: String? = nil, serde: CsvSerdeOption? = nil, version: Int64? = nil) {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.creationTime = creationTime
            self.customDatatypeConfigured = customDatatypeConfigured
            self.customDatatypes = customDatatypes
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.lastUpdated = lastUpdated
            self.name = name
            self.quoteSymbol = quoteSymbol
            self.serde = serde
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case allowSingleColumn = "AllowSingleColumn"
            case containsHeader = "ContainsHeader"
            case creationTime = "CreationTime"
            case customDatatypeConfigured = "CustomDatatypeConfigured"
            case customDatatypes = "CustomDatatypes"
            case delimiter = "Delimiter"
            case disableValueTrimming = "DisableValueTrimming"
            case header = "Header"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case quoteSymbol = "QuoteSymbol"
            case serde = "Serde"
            case version = "Version"
        }
    }

    public struct CustomCode: AWSEncodableShape & AWSDecodableShape {
        /// The name defined for the custom code node class.
        public let className: String
        /// The custom code that is used to perform the data transformation.
        public let code: String
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String
        /// Specifies the data schema for the custom code transform.
        public let outputSchemas: [GlueSchema]?

        @inlinable
        public init(className: String, code: String, inputs: [String], name: String, outputSchemas: [GlueSchema]? = nil) {
            self.className = className
            self.code = code
            self.inputs = inputs
            self.name = name
            self.outputSchemas = outputSchemas
        }

        public func validate(name: String) throws {
            try self.validate(self.className, name: "className", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.code, name: "code", parent: name, pattern: "^[\\s\\S]*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case className = "ClassName"
            case code = "Code"
            case inputs = "Inputs"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
        }
    }

    public struct CustomEntityType: AWSDecodableShape {
        /// A list of context words. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data. If no context words are passed only a regular expression is checked.
        public let contextWords: [String]?
        /// A name for the custom pattern that allows it to be retrieved or deleted later. This name must be unique per Amazon Web Services account.
        public let name: String
        /// A regular expression string that is used for detecting sensitive data in a custom pattern.
        public let regexString: String

        @inlinable
        public init(contextWords: [String]? = nil, name: String, regexString: String) {
            self.contextWords = contextWords
            self.name = name
            self.regexString = regexString
        }

        private enum CodingKeys: String, CodingKey {
            case contextWords = "ContextWords"
            case name = "Name"
            case regexString = "RegexString"
        }
    }

    public struct DQResultsPublishingOptions: AWSEncodableShape & AWSDecodableShape {
        /// Enable metrics for your data quality results.
        public let cloudWatchMetricsEnabled: Bool?
        /// The context of the evaluation.
        public let evaluationContext: String?
        /// Enable publishing for your data quality results.
        public let resultsPublishingEnabled: Bool?
        /// The Amazon S3 prefix prepended to the results.
        public let resultsS3Prefix: String?

        @inlinable
        public init(cloudWatchMetricsEnabled: Bool? = nil, evaluationContext: String? = nil, resultsPublishingEnabled: Bool? = nil, resultsS3Prefix: String? = nil) {
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.evaluationContext = evaluationContext
            self.resultsPublishingEnabled = resultsPublishingEnabled
            self.resultsS3Prefix = resultsS3Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationContext, name: "evaluationContext", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.validate(self.resultsS3Prefix, name: "resultsS3Prefix", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
            case evaluationContext = "EvaluationContext"
            case resultsPublishingEnabled = "ResultsPublishingEnabled"
            case resultsS3Prefix = "ResultsS3Prefix"
        }
    }

    public struct DQStopJobOnFailureOptions: AWSEncodableShape & AWSDecodableShape {
        /// When to stop job if your data quality evaluation fails. Options are Immediate or AfterDataLoad.
        public let stopJobOnFailureTiming: DQStopJobOnFailureTiming?

        @inlinable
        public init(stopJobOnFailureTiming: DQStopJobOnFailureTiming? = nil) {
            self.stopJobOnFailureTiming = stopJobOnFailureTiming
        }

        private enum CodingKeys: String, CodingKey {
            case stopJobOnFailureTiming = "StopJobOnFailureTiming"
        }
    }

    public struct DataCatalogEncryptionSettings: AWSEncodableShape & AWSDecodableShape {
        /// When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption.
        public let connectionPasswordEncryption: ConnectionPasswordEncryption?
        /// Specifies the encryption-at-rest configuration for the Data Catalog.
        public let encryptionAtRest: EncryptionAtRest?

        @inlinable
        public init(connectionPasswordEncryption: ConnectionPasswordEncryption? = nil, encryptionAtRest: EncryptionAtRest? = nil) {
            self.connectionPasswordEncryption = connectionPasswordEncryption
            self.encryptionAtRest = encryptionAtRest
        }

        public func validate(name: String) throws {
            try self.connectionPasswordEncryption?.validate(name: "\(name).connectionPasswordEncryption")
            try self.encryptionAtRest?.validate(name: "\(name).encryptionAtRest")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionPasswordEncryption = "ConnectionPasswordEncryption"
            case encryptionAtRest = "EncryptionAtRest"
        }
    }

    public struct DataLakeAccessProperties: AWSEncodableShape {
        /// Specifies a federated catalog type for the native catalog resource. The currently supported type is aws:redshift.
        public let catalogType: String?
        /// Turns on or off data lake access for Apache Spark applications that access Amazon Redshift databases in the Data Catalog from any non-Redshift engine, such as Amazon Athena, Amazon EMR, or Glue ETL.
        public let dataLakeAccess: Bool?
        /// A role that will be assumed by Glue for transferring data into/out of the staging bucket during a query.
        public let dataTransferRole: String?
        /// An encryption key that will be used for the staging bucket that will be created along with the catalog.
        public let kmsKey: String?

        @inlinable
        public init(catalogType: String? = nil, dataLakeAccess: Bool? = nil, dataTransferRole: String? = nil, kmsKey: String? = nil) {
            self.catalogType = catalogType
            self.dataLakeAccess = dataLakeAccess
            self.dataTransferRole = dataTransferRole
            self.kmsKey = kmsKey
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogType, name: "catalogType", parent: name, max: 255)
            try self.validate(self.catalogType, name: "catalogType", parent: name, min: 1)
            try self.validate(self.catalogType, name: "catalogType", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.dataTransferRole, name: "dataTransferRole", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogType = "CatalogType"
            case dataLakeAccess = "DataLakeAccess"
            case dataTransferRole = "DataTransferRole"
            case kmsKey = "KmsKey"
        }
    }

    public struct DataLakeAccessPropertiesOutput: AWSDecodableShape {
        /// Specifies a federated catalog type for the native catalog resource. The currently supported type is aws:redshift.
        public let catalogType: String?
        /// Turns on or off data lake access for Apache Spark applications that access Amazon Redshift databases in the Data Catalog.
        public let dataLakeAccess: Bool?
        /// A role that will be assumed by Glue for transferring data into/out of the staging bucket during a query.
        public let dataTransferRole: String?
        /// An encryption key that will be used for the staging bucket that will be created along with the catalog.
        public let kmsKey: String?
        /// The managed Redshift Serverless compute name that is created for your catalog resource.
        public let managedWorkgroupName: String?
        /// The managed Redshift Serverless compute status.
        public let managedWorkgroupStatus: String?
        /// The default Redshift database resource name in the managed compute.
        public let redshiftDatabaseName: String?
        /// A message that gives more detailed information about the managed workgroup status.
        public let statusMessage: String?

        @inlinable
        public init(catalogType: String? = nil, dataLakeAccess: Bool? = nil, dataTransferRole: String? = nil, kmsKey: String? = nil, managedWorkgroupName: String? = nil, managedWorkgroupStatus: String? = nil, redshiftDatabaseName: String? = nil, statusMessage: String? = nil) {
            self.catalogType = catalogType
            self.dataLakeAccess = dataLakeAccess
            self.dataTransferRole = dataTransferRole
            self.kmsKey = kmsKey
            self.managedWorkgroupName = managedWorkgroupName
            self.managedWorkgroupStatus = managedWorkgroupStatus
            self.redshiftDatabaseName = redshiftDatabaseName
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case catalogType = "CatalogType"
            case dataLakeAccess = "DataLakeAccess"
            case dataTransferRole = "DataTransferRole"
            case kmsKey = "KmsKey"
            case managedWorkgroupName = "ManagedWorkgroupName"
            case managedWorkgroupStatus = "ManagedWorkgroupStatus"
            case redshiftDatabaseName = "RedshiftDatabaseName"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DataLakePrincipal: AWSEncodableShape & AWSDecodableShape {
        /// An identifier for the Lake Formation principal.
        public let dataLakePrincipalIdentifier: String?

        @inlinable
        public init(dataLakePrincipalIdentifier: String? = nil) {
            self.dataLakePrincipalIdentifier = dataLakePrincipalIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.dataLakePrincipalIdentifier, name: "dataLakePrincipalIdentifier", parent: name, max: 255)
            try self.validate(self.dataLakePrincipalIdentifier, name: "dataLakePrincipalIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataLakePrincipalIdentifier = "DataLakePrincipalIdentifier"
        }
    }

    public struct DataQualityAnalyzerResult: AWSDecodableShape {
        /// A description of the data quality analyzer.
        public let description: String?
        /// A map of metrics associated with the evaluation of the analyzer.
        public let evaluatedMetrics: [String: Double]?
        /// An evaluation message.
        public let evaluationMessage: String?
        /// The name of the data quality analyzer.
        public let name: String?

        @inlinable
        public init(description: String? = nil, evaluatedMetrics: [String: Double]? = nil, evaluationMessage: String? = nil, name: String? = nil) {
            self.description = description
            self.evaluatedMetrics = evaluatedMetrics
            self.evaluationMessage = evaluationMessage
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case evaluatedMetrics = "EvaluatedMetrics"
            case evaluationMessage = "EvaluationMessage"
            case name = "Name"
        }
    }

    public struct DataQualityEncryption: AWSEncodableShape & AWSDecodableShape {
        /// The encryption mode to use for encrypting Data Quality assets. These assets include data quality rulesets, results, statistics, anomaly detection models and observations. Valid values are SSEKMS for encryption using a customer-managed KMS key, or DISABLED.
        public let dataQualityEncryptionMode: DataQualityEncryptionMode?
        /// The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        public let kmsKeyArn: String?

        @inlinable
        public init(dataQualityEncryptionMode: DataQualityEncryptionMode? = nil, kmsKeyArn: String? = nil) {
            self.dataQualityEncryptionMode = dataQualityEncryptionMode
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:")
        }

        private enum CodingKeys: String, CodingKey {
            case dataQualityEncryptionMode = "DataQualityEncryptionMode"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct DataQualityEvaluationRunAdditionalRunOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether or not to enable CloudWatch metrics.
        public let cloudWatchMetricsEnabled: Bool?
        /// Set the evaluation method for composite rules in the ruleset to ROW/COLUMN
        public let compositeRuleEvaluationMethod: DQCompositeRuleEvaluationMethod?
        /// Prefix for Amazon S3 to store results.
        public let resultsS3Prefix: String?

        @inlinable
        public init(cloudWatchMetricsEnabled: Bool? = nil, compositeRuleEvaluationMethod: DQCompositeRuleEvaluationMethod? = nil, resultsS3Prefix: String? = nil) {
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.compositeRuleEvaluationMethod = compositeRuleEvaluationMethod
            self.resultsS3Prefix = resultsS3Prefix
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
            case compositeRuleEvaluationMethod = "CompositeRuleEvaluationMethod"
            case resultsS3Prefix = "ResultsS3Prefix"
        }
    }

    public struct DataQualityMetricValues: AWSDecodableShape {
        /// The actual value of the data quality metric.
        public let actualValue: Double?
        /// The expected value of the data quality metric according to the analysis of historical data.
        public let expectedValue: Double?
        /// The lower limit of the data quality metric value according to the analysis of historical data.
        public let lowerLimit: Double?
        /// The upper limit of the data quality metric value according to the analysis of historical data.
        public let upperLimit: Double?

        @inlinable
        public init(actualValue: Double? = nil, expectedValue: Double? = nil, lowerLimit: Double? = nil, upperLimit: Double? = nil) {
            self.actualValue = actualValue
            self.expectedValue = expectedValue
            self.lowerLimit = lowerLimit
            self.upperLimit = upperLimit
        }

        private enum CodingKeys: String, CodingKey {
            case actualValue = "ActualValue"
            case expectedValue = "ExpectedValue"
            case lowerLimit = "LowerLimit"
            case upperLimit = "UpperLimit"
        }
    }

    public struct DataQualityObservation: AWSDecodableShape {
        /// A description of the data quality observation.
        public let description: String?
        /// An object of type MetricBasedObservation representing the observation that is based on evaluated data quality metrics.
        public let metricBasedObservation: MetricBasedObservation?

        @inlinable
        public init(description: String? = nil, metricBasedObservation: MetricBasedObservation? = nil) {
            self.description = description
            self.metricBasedObservation = metricBasedObservation
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case metricBasedObservation = "MetricBasedObservation"
        }
    }

    public struct DataQualityResult: AWSDecodableShape {
        /// A list of DataQualityAnalyzerResult objects representing the results for each analyzer.
        public let analyzerResults: [DataQualityAnalyzerResult]?
        /// The date and time when this data quality run completed.
        public let completedOn: Date?
        /// The table associated with the data quality result, if any.
        public let dataSource: DataSource?
        /// In the context of a job in Glue Studio, each node in the canvas is typically assigned some sort of name and data quality nodes will have names. In the case of multiple nodes, the evaluationContext can differentiate the nodes.
        public let evaluationContext: String?
        /// The job name associated with the data quality result, if any.
        public let jobName: String?
        /// The job run ID associated with the data quality result, if any.
        public let jobRunId: String?
        /// A list of DataQualityObservation objects representing the observations generated after evaluating the rules and analyzers.
        public let observations: [DataQualityObservation]?
        /// The Profile ID for the data quality result.
        public let profileId: String?
        /// A unique result ID for the data quality result.
        public let resultId: String?
        /// A list of DataQualityRuleResult objects representing the results for each rule.
        public let ruleResults: [DataQualityRuleResult]?
        /// The unique run ID for the ruleset evaluation for this data quality result.
        public let rulesetEvaluationRunId: String?
        /// The name of the ruleset associated with the data quality result.
        public let rulesetName: String?
        /// An aggregate data quality score. Represents the ratio of rules that passed to the total number of rules.
        public let score: Double?
        /// The date and time when this data quality run started.
        public let startedOn: Date?

        @inlinable
        public init(analyzerResults: [DataQualityAnalyzerResult]? = nil, completedOn: Date? = nil, dataSource: DataSource? = nil, evaluationContext: String? = nil, jobName: String? = nil, jobRunId: String? = nil, observations: [DataQualityObservation]? = nil, profileId: String? = nil, resultId: String? = nil, ruleResults: [DataQualityRuleResult]? = nil, rulesetEvaluationRunId: String? = nil, rulesetName: String? = nil, score: Double? = nil, startedOn: Date? = nil) {
            self.analyzerResults = analyzerResults
            self.completedOn = completedOn
            self.dataSource = dataSource
            self.evaluationContext = evaluationContext
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.observations = observations
            self.profileId = profileId
            self.resultId = resultId
            self.ruleResults = ruleResults
            self.rulesetEvaluationRunId = rulesetEvaluationRunId
            self.rulesetName = rulesetName
            self.score = score
            self.startedOn = startedOn
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerResults = "AnalyzerResults"
            case completedOn = "CompletedOn"
            case dataSource = "DataSource"
            case evaluationContext = "EvaluationContext"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
            case observations = "Observations"
            case profileId = "ProfileId"
            case resultId = "ResultId"
            case ruleResults = "RuleResults"
            case rulesetEvaluationRunId = "RulesetEvaluationRunId"
            case rulesetName = "RulesetName"
            case score = "Score"
            case startedOn = "StartedOn"
        }
    }

    public struct DataQualityResultDescription: AWSDecodableShape {
        /// The table name associated with the data quality result.
        public let dataSource: DataSource?
        /// The job name associated with the data quality result.
        public let jobName: String?
        /// The job run ID associated with the data quality result.
        public let jobRunId: String?
        /// The unique result ID for this data quality result.
        public let resultId: String?
        /// The time that the run started for this data quality result.
        public let startedOn: Date?

        @inlinable
        public init(dataSource: DataSource? = nil, jobName: String? = nil, jobRunId: String? = nil, resultId: String? = nil, startedOn: Date? = nil) {
            self.dataSource = dataSource
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.resultId = resultId
            self.startedOn = startedOn
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
            case resultId = "ResultId"
            case startedOn = "StartedOn"
        }
    }

    public struct DataQualityResultFilterCriteria: AWSEncodableShape {
        /// Filter results by the specified data source. For example, retrieving all results for an Glue table.
        public let dataSource: DataSource?
        /// Filter results by the specified job name.
        public let jobName: String?
        /// Filter results by the specified job run ID.
        public let jobRunId: String?
        /// Filter results by runs that started after this time.
        public let startedAfter: Date?
        /// Filter results by runs that started before this time.
        public let startedBefore: Date?

        @inlinable
        public init(dataSource: DataSource? = nil, jobName: String? = nil, jobRunId: String? = nil, startedAfter: Date? = nil, startedBefore: Date? = nil) {
            self.dataSource = dataSource
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
        }

        public func validate(name: String) throws {
            try self.dataSource?.validate(name: "\(name).dataSource")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.jobRunId, name: "jobRunId", parent: name, max: 255)
            try self.validate(self.jobRunId, name: "jobRunId", parent: name, min: 1)
            try self.validate(self.jobRunId, name: "jobRunId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
            case startedAfter = "StartedAfter"
            case startedBefore = "StartedBefore"
        }
    }

    public struct DataQualityRuleRecommendationRunDescription: AWSDecodableShape {
        /// The data source (Glue table) associated with the recommendation run.
        public let dataSource: DataSource?
        /// The unique run identifier associated with this run.
        public let runId: String?
        /// The date and time when this run started.
        public let startedOn: Date?
        /// The status for this run.
        public let status: TaskStatusType?

        @inlinable
        public init(dataSource: DataSource? = nil, runId: String? = nil, startedOn: Date? = nil, status: TaskStatusType? = nil) {
            self.dataSource = dataSource
            self.runId = runId
            self.startedOn = startedOn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case runId = "RunId"
            case startedOn = "StartedOn"
            case status = "Status"
        }
    }

    public struct DataQualityRuleRecommendationRunFilter: AWSEncodableShape {
        /// Filter based on a specified data source (Glue table).
        public let dataSource: DataSource
        /// Filter based on time for results started after provided time.
        public let startedAfter: Date?
        /// Filter based on time for results started before provided time.
        public let startedBefore: Date?

        @inlinable
        public init(dataSource: DataSource, startedAfter: Date? = nil, startedBefore: Date? = nil) {
            self.dataSource = dataSource
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
        }

        public func validate(name: String) throws {
            try self.dataSource.validate(name: "\(name).dataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case startedAfter = "StartedAfter"
            case startedBefore = "StartedBefore"
        }
    }

    public struct DataQualityRuleResult: AWSDecodableShape {
        /// A description of the data quality rule.
        public let description: String?
        /// A map of metrics associated with the evaluation of the rule.
        public let evaluatedMetrics: [String: Double]?
        /// The evaluated rule.
        public let evaluatedRule: String?
        /// An evaluation message.
        public let evaluationMessage: String?
        /// The name of the data quality rule.
        public let name: String?
        /// A pass or fail status for the rule.
        public let result: DataQualityRuleResultStatus?

        @inlinable
        public init(description: String? = nil, evaluatedMetrics: [String: Double]? = nil, evaluatedRule: String? = nil, evaluationMessage: String? = nil, name: String? = nil, result: DataQualityRuleResultStatus? = nil) {
            self.description = description
            self.evaluatedMetrics = evaluatedMetrics
            self.evaluatedRule = evaluatedRule
            self.evaluationMessage = evaluationMessage
            self.name = name
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case evaluatedMetrics = "EvaluatedMetrics"
            case evaluatedRule = "EvaluatedRule"
            case evaluationMessage = "EvaluationMessage"
            case name = "Name"
            case result = "Result"
        }
    }

    public struct DataQualityRulesetEvaluationRunDescription: AWSDecodableShape {
        /// The data source (an Glue table) associated with the run.
        public let dataSource: DataSource?
        /// The unique run identifier associated with this run.
        public let runId: String?
        /// The date and time when the run started.
        public let startedOn: Date?
        /// The status for this run.
        public let status: TaskStatusType?

        @inlinable
        public init(dataSource: DataSource? = nil, runId: String? = nil, startedOn: Date? = nil, status: TaskStatusType? = nil) {
            self.dataSource = dataSource
            self.runId = runId
            self.startedOn = startedOn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case runId = "RunId"
            case startedOn = "StartedOn"
            case status = "Status"
        }
    }

    public struct DataQualityRulesetEvaluationRunFilter: AWSEncodableShape {
        /// Filter based on a data source (an Glue table) associated with the run.
        public let dataSource: DataSource
        /// Filter results by runs that started after this time.
        public let startedAfter: Date?
        /// Filter results by runs that started before this time.
        public let startedBefore: Date?

        @inlinable
        public init(dataSource: DataSource, startedAfter: Date? = nil, startedBefore: Date? = nil) {
            self.dataSource = dataSource
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
        }

        public func validate(name: String) throws {
            try self.dataSource.validate(name: "\(name).dataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case startedAfter = "StartedAfter"
            case startedBefore = "StartedBefore"
        }
    }

    public struct DataQualityRulesetFilterCriteria: AWSEncodableShape {
        /// Filter on rulesets created after this date.
        public let createdAfter: Date?
        /// Filter on rulesets created before this date.
        public let createdBefore: Date?
        /// The description of the ruleset filter criteria.
        public let description: String?
        /// Filter on rulesets last modified after this date.
        public let lastModifiedAfter: Date?
        /// Filter on rulesets last modified before this date.
        public let lastModifiedBefore: Date?
        /// The name of the ruleset filter criteria.
        public let name: String?
        /// The name and database name of the target table.
        public let targetTable: DataQualityTargetTable?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, description: String? = nil, lastModifiedAfter: Date? = nil, lastModifiedBefore: Date? = nil, name: String? = nil, targetTable: DataQualityTargetTable? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.description = description
            self.lastModifiedAfter = lastModifiedAfter
            self.lastModifiedBefore = lastModifiedBefore
            self.name = name
            self.targetTable = targetTable
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.targetTable?.validate(name: "\(name).targetTable")
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case description = "Description"
            case lastModifiedAfter = "LastModifiedAfter"
            case lastModifiedBefore = "LastModifiedBefore"
            case name = "Name"
            case targetTable = "TargetTable"
        }
    }

    public struct DataQualityRulesetListDetails: AWSDecodableShape {
        /// The date and time the data quality ruleset was created.
        public let createdOn: Date?
        /// A description of the data quality ruleset.
        public let description: String?
        /// The date and time the data quality ruleset was last modified.
        public let lastModifiedOn: Date?
        /// The name of the data quality ruleset.
        public let name: String?
        /// When a ruleset was created from a recommendation run, this run ID is generated to link the two together.
        public let recommendationRunId: String?
        /// The number of rules in the ruleset.
        public let ruleCount: Int?
        /// An object representing an Glue table.
        public let targetTable: DataQualityTargetTable?

        @inlinable
        public init(createdOn: Date? = nil, description: String? = nil, lastModifiedOn: Date? = nil, name: String? = nil, recommendationRunId: String? = nil, ruleCount: Int? = nil, targetTable: DataQualityTargetTable? = nil) {
            self.createdOn = createdOn
            self.description = description
            self.lastModifiedOn = lastModifiedOn
            self.name = name
            self.recommendationRunId = recommendationRunId
            self.ruleCount = ruleCount
            self.targetTable = targetTable
        }

        private enum CodingKeys: String, CodingKey {
            case createdOn = "CreatedOn"
            case description = "Description"
            case lastModifiedOn = "LastModifiedOn"
            case name = "Name"
            case recommendationRunId = "RecommendationRunId"
            case ruleCount = "RuleCount"
            case targetTable = "TargetTable"
        }
    }

    public struct DataQualityTargetTable: AWSEncodableShape & AWSDecodableShape {
        /// The catalog id where the Glue table exists.
        public let catalogId: String?
        /// The name of the database where the Glue table exists.
        public let databaseName: String
        /// The name of the Glue table.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct DataSource: AWSEncodableShape & AWSDecodableShape {
        /// An Glue table.
        public let glueTable: GlueTable

        @inlinable
        public init(glueTable: GlueTable) {
            self.glueTable = glueTable
        }

        public func validate(name: String) throws {
            try self.glueTable.validate(name: "\(name).glueTable")
        }

        private enum CodingKeys: String, CodingKey {
            case glueTable = "GlueTable"
        }
    }

    public struct Database: AWSDecodableShape {
        /// The ID of the Data Catalog in which the database resides.
        public let catalogId: String?
        /// Creates a set of default permissions on the table for principals. Used by Lake Formation. Not used in the normal course of Glue operations.
        public let createTableDefaultPermissions: [PrincipalPermissions]?
        /// The time at which the metadata database was created in the catalog.
        public let createTime: Date?
        /// A description of the database.
        public let description: String?
        /// A FederatedDatabase structure that references an entity outside the Glue Data Catalog.
        public let federatedDatabase: FederatedDatabase?
        /// The location of the database (for example, an HDFS path).
        public let locationUri: String?
        /// The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
        public let name: String
        /// These key-value pairs define parameters and properties of the database.
        public let parameters: [String: String]?
        /// A DatabaseIdentifier structure that describes a target database for resource linking.
        public let targetDatabase: DatabaseIdentifier?

        @inlinable
        public init(catalogId: String? = nil, createTableDefaultPermissions: [PrincipalPermissions]? = nil, createTime: Date? = nil, description: String? = nil, federatedDatabase: FederatedDatabase? = nil, locationUri: String? = nil, name: String, parameters: [String: String]? = nil, targetDatabase: DatabaseIdentifier? = nil) {
            self.catalogId = catalogId
            self.createTableDefaultPermissions = createTableDefaultPermissions
            self.createTime = createTime
            self.description = description
            self.federatedDatabase = federatedDatabase
            self.locationUri = locationUri
            self.name = name
            self.parameters = parameters
            self.targetDatabase = targetDatabase
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case createTableDefaultPermissions = "CreateTableDefaultPermissions"
            case createTime = "CreateTime"
            case description = "Description"
            case federatedDatabase = "FederatedDatabase"
            case locationUri = "LocationUri"
            case name = "Name"
            case parameters = "Parameters"
            case targetDatabase = "TargetDatabase"
        }
    }

    public struct DatabaseIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the Data Catalog in which the database resides.
        public let catalogId: String?
        /// The name of the catalog database.
        public let databaseName: String?
        /// Region of the target database.
        public let region: String?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String? = nil, region: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.region, name: "region", parent: name, max: 255)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.validate(self.region, name: "region", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case region = "Region"
        }
    }

    public struct DatabaseInput: AWSEncodableShape {
        /// Creates a set of default permissions on the table for principals. Used by Lake Formation. Not used in the normal course of Glue operations.
        public let createTableDefaultPermissions: [PrincipalPermissions]?
        /// A description of the database.
        public let description: String?
        /// A FederatedDatabase structure that references an entity outside the Glue Data Catalog.
        public let federatedDatabase: FederatedDatabase?
        /// The location of the database (for example, an HDFS path).
        public let locationUri: String?
        /// The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
        public let name: String
        /// These key-value pairs define parameters and properties of the database. These key-value pairs define parameters and properties of the database.
        public let parameters: [String: String]?
        /// A DatabaseIdentifier structure that describes a target database for resource linking.
        public let targetDatabase: DatabaseIdentifier?

        @inlinable
        public init(createTableDefaultPermissions: [PrincipalPermissions]? = nil, description: String? = nil, federatedDatabase: FederatedDatabase? = nil, locationUri: String? = nil, name: String, parameters: [String: String]? = nil, targetDatabase: DatabaseIdentifier? = nil) {
            self.createTableDefaultPermissions = createTableDefaultPermissions
            self.description = description
            self.federatedDatabase = federatedDatabase
            self.locationUri = locationUri
            self.name = name
            self.parameters = parameters
            self.targetDatabase = targetDatabase
        }

        public func validate(name: String) throws {
            try self.createTableDefaultPermissions?.forEach {
                try $0.validate(name: "\(name).createTableDefaultPermissions[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.federatedDatabase?.validate(name: "\(name).federatedDatabase")
            try self.validate(self.locationUri, name: "locationUri", parent: name, max: 1024)
            try self.validate(self.locationUri, name: "locationUri", parent: name, min: 1)
            try self.validate(self.locationUri, name: "locationUri", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512000)
            }
            try self.targetDatabase?.validate(name: "\(name).targetDatabase")
        }

        private enum CodingKeys: String, CodingKey {
            case createTableDefaultPermissions = "CreateTableDefaultPermissions"
            case description = "Description"
            case federatedDatabase = "FederatedDatabase"
            case locationUri = "LocationUri"
            case name = "Name"
            case parameters = "Parameters"
            case targetDatabase = "TargetDatabase"
        }
    }

    public struct DatapointInclusionAnnotation: AWSEncodableShape {
        /// The inclusion annotation value to apply to the statistic.
        public let inclusionAnnotation: InclusionAnnotationValue?
        /// The ID of the data quality profile the statistic belongs to.
        public let profileId: String?
        /// The Statistic ID.
        public let statisticId: String?

        @inlinable
        public init(inclusionAnnotation: InclusionAnnotationValue? = nil, profileId: String? = nil, statisticId: String? = nil) {
            self.inclusionAnnotation = inclusionAnnotation
            self.profileId = profileId
            self.statisticId = statisticId
        }

        public func validate(name: String) throws {
            try self.validate(self.profileId, name: "profileId", parent: name, max: 255)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.statisticId, name: "statisticId", parent: name, max: 255)
            try self.validate(self.statisticId, name: "statisticId", parent: name, min: 1)
            try self.validate(self.statisticId, name: "statisticId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inclusionAnnotation = "InclusionAnnotation"
            case profileId = "ProfileId"
            case statisticId = "StatisticId"
        }
    }

    public struct Datatype: AWSEncodableShape & AWSDecodableShape {
        /// The datatype of the value.
        public let id: String
        /// A label assigned to the datatype.
        public let label: String

        @inlinable
        public init(id: String, label: String) {
            self.id = id
            self.label = label
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.validate(self.label, name: "label", parent: name, pattern: "^[A-Za-z0-9_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case label = "Label"
        }
    }

    public struct DateColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The highest value in the column.
        public let maximumValue: Date?
        /// The lowest value in the column.
        public let minimumValue: Date?
        /// The number of distinct values in a column.
        public let numberOfDistinctValues: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        @inlinable
        public init(maximumValue: Date? = nil, minimumValue: Date? = nil, numberOfDistinctValues: Int64, numberOfNulls: Int64) {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDistinctValues, name: "numberOfDistinctValues", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case numberOfDistinctValues = "NumberOfDistinctValues"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct DecimalColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The highest value in the column.
        public let maximumValue: DecimalNumber?
        /// The lowest value in the column.
        public let minimumValue: DecimalNumber?
        /// The number of distinct values in a column.
        public let numberOfDistinctValues: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        @inlinable
        public init(maximumValue: DecimalNumber? = nil, minimumValue: DecimalNumber? = nil, numberOfDistinctValues: Int64, numberOfNulls: Int64) {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDistinctValues, name: "numberOfDistinctValues", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case numberOfDistinctValues = "NumberOfDistinctValues"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct DecimalNumber: AWSEncodableShape & AWSDecodableShape {
        /// The scale that determines where the decimal point falls in the unscaled value.
        public let scale: Int
        /// The unscaled numeric value.
        public let unscaledValue: AWSBase64Data

        @inlinable
        public init(scale: Int, unscaledValue: AWSBase64Data) {
            self.scale = scale
            self.unscaledValue = unscaledValue
        }

        private enum CodingKeys: String, CodingKey {
            case scale = "Scale"
            case unscaledValue = "UnscaledValue"
        }
    }

    public struct DeleteBlueprintRequest: AWSEncodableShape {
        /// The name of the blueprint to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteBlueprintResponse: AWSDecodableShape {
        /// Returns the name of the blueprint that was deleted.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteCatalogRequest: AWSEncodableShape {
        /// The ID of the catalog.
        public let catalogId: String

        @inlinable
        public init(catalogId: String) {
            self.catalogId = catalogId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct DeleteCatalogResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteClassifierRequest: AWSEncodableShape {
        /// Name of the classifier to remove.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteClassifierResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteColumnStatisticsForPartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// Name of the column.
        public let columnName: String
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// A list of partition values identifying the partition.
        public let partitionValues: [String]
        /// The name of the partitions' table.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, columnName: String, databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.columnName = columnName
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.columnName, name: "columnName", parent: name, max: 255)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
                try validate($0, name: "partitionValues[]", parent: name, min: 1)
            }
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnName = "ColumnName"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct DeleteColumnStatisticsForPartitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteColumnStatisticsForTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the column.
        public let columnName: String
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// The name of the partitions' table.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, columnName: String, databaseName: String, tableName: String) {
            self.catalogId = catalogId
            self.columnName = columnName
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.columnName, name: "columnName", parent: name, max: 255)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnName = "ColumnName"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct DeleteColumnStatisticsForTableResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteColumnStatisticsTaskSettingsRequest: AWSEncodableShape {
        /// The name of the database where the table resides.
        public let databaseName: String
        /// The name of the table for which to delete column statistics.
        public let tableName: String

        @inlinable
        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct DeleteColumnStatisticsTaskSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConnectionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the connection to delete.
        public let connectionName: String

        @inlinable
        public init(catalogId: String? = nil, connectionName: String) {
            self.catalogId = catalogId
            self.connectionName = connectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 255)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionName = "ConnectionName"
        }
    }

    public struct DeleteConnectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCrawlerRequest: AWSEncodableShape {
        /// The name of the crawler to remove.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteCrawlerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCustomEntityTypeRequest: AWSEncodableShape {
        /// The name of the custom pattern that you want to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteCustomEntityTypeResponse: AWSDecodableShape {
        /// The name of the custom pattern you deleted.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteDataQualityRulesetRequest: AWSEncodableShape {
        /// A name for the data quality ruleset.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteDataQualityRulesetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDatabaseRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the database to delete. For Hive compatibility, this must be all lowercase.
        public let name: String

        @inlinable
        public init(catalogId: String? = nil, name: String) {
            self.catalogId = catalogId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
        }
    }

    public struct DeleteDatabaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDevEndpointRequest: AWSEncodableShape {
        /// The name of the DevEndpoint.
        public let endpointName: String

        @inlinable
        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct DeleteDevEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIntegrationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the integration.
        public let integrationIdentifier: String

        @inlinable
        public init(integrationIdentifier: String) {
            self.integrationIdentifier = integrationIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, max: 128)
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case integrationIdentifier = "IntegrationIdentifier"
        }
    }

    public struct DeleteIntegrationResponse: AWSDecodableShape {
        /// An optional set of non-secret keyvalue pairs that contains additional contextual information for encryption.
        public let additionalEncryptionContext: [String: String]?
        /// The time when the integration was created, in UTC.
        public let createTime: Date
        /// Selects source tables for the integration using Maxwell filter syntax.
        public let dataFilter: String?
        /// A description of the integration.
        public let description: String?
        /// A list of errors associated with the integration.
        public let errors: [IntegrationError]?
        /// The Amazon Resource Name (ARN) for the integration.
        public let integrationArn: String
        /// A unique name for an integration in Glue.
        public let integrationName: String
        /// The ARN of a KMS key used for encrypting the channel.
        public let kmsKeyId: String?
        /// The ARN of the source for the integration.
        public let sourceArn: String
        /// The status of the integration being deleted. The possible statuses are:   CREATING: The integration is being created.   ACTIVE: The integration creation succeeds.   MODIFYING: The integration is being modified.   FAILED: The integration creation fails.    DELETING: The integration is deleted.   SYNCING: The integration is synchronizing.   NEEDS_ATTENTION: The integration needs attention, such as synchronization.
        public let status: IntegrationStatus
        /// Metadata assigned to the resource consisting of a list of key-value pairs.
        public let tags: [Tag]?
        /// The ARN of the target for the integration.
        public let targetArn: String

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, createTime: Date, dataFilter: String? = nil, description: String? = nil, errors: [IntegrationError]? = nil, integrationArn: String, integrationName: String, kmsKeyId: String? = nil, sourceArn: String, status: IntegrationStatus, tags: [Tag]? = nil, targetArn: String) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.createTime = createTime
            self.dataFilter = dataFilter
            self.description = description
            self.errors = errors
            self.integrationArn = integrationArn
            self.integrationName = integrationName
            self.kmsKeyId = kmsKeyId
            self.sourceArn = sourceArn
            self.status = status
            self.tags = tags
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "AdditionalEncryptionContext"
            case createTime = "CreateTime"
            case dataFilter = "DataFilter"
            case description = "Description"
            case errors = "Errors"
            case integrationArn = "IntegrationArn"
            case integrationName = "IntegrationName"
            case kmsKeyId = "KmsKeyId"
            case sourceArn = "SourceArn"
            case status = "Status"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct DeleteIntegrationTablePropertiesRequest: AWSEncodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String
        /// The name of the table to be replicated.
        public let tableName: String

        @inlinable
        public init(resourceArn: String, tableName: String) {
            self.resourceArn = resourceArn
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 128)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tableName = "TableName"
        }
    }

    public struct DeleteIntegrationTablePropertiesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteJobRequest: AWSEncodableShape {
        /// The name of the job definition to delete.
        public let jobName: String

        @inlinable
        public init(jobName: String) {
            self.jobName = jobName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct DeleteJobResponse: AWSDecodableShape {
        /// The name of the job definition that was deleted.
        public let jobName: String?

        @inlinable
        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct DeleteMLTransformRequest: AWSEncodableShape {
        /// The unique identifier of the transform to delete.
        public let transformId: String

        @inlinable
        public init(transformId: String) {
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct DeleteMLTransformResponse: AWSDecodableShape {
        /// The unique identifier of the transform that was deleted.
        public let transformId: String?

        @inlinable
        public init(transformId: String? = nil) {
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct DeletePartitionIndexRequest: AWSEncodableShape {
        /// The catalog ID where the table resides.
        public let catalogId: String?
        /// Specifies the name of a database from which you want to delete a partition index.
        public let databaseName: String
        /// The name of the partition index to be deleted.
        public let indexName: String
        /// Specifies the name of a table from which you want to delete a partition index.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, indexName: String, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.indexName = indexName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.indexName, name: "indexName", parent: name, max: 255)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case indexName = "IndexName"
            case tableName = "TableName"
        }
    }

    public struct DeletePartitionIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partition to be deleted resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String
        /// The values that define the partition.
        public let partitionValues: [String]
        /// The name of the table that contains the partition to be deleted.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
                try validate($0, name: "partitionValues[]", parent: name, min: 1)
            }
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct DeletePartitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRegistryInput: AWSEncodableShape {
        /// This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
        public let registryId: RegistryId

        @inlinable
        public init(registryId: RegistryId) {
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.registryId.validate(name: "\(name).registryId")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "RegistryId"
        }
    }

    public struct DeleteRegistryResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the registry being deleted.
        public let registryArn: String?
        /// The name of the registry being deleted.
        public let registryName: String?
        /// The status of the registry. A successful operation will return the Deleting status.
        public let status: RegistryStatus?

        @inlinable
        public init(registryArn: String? = nil, registryName: String? = nil, status: RegistryStatus? = nil) {
            self.registryArn = registryArn
            self.registryName = registryName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case status = "Status"
        }
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The hash value returned when this policy was set.
        public let policyHashCondition: String?
        /// The ARN of the Glue resource for the resource policy to be deleted.
        public let resourceArn: String?

        @inlinable
        public init(policyHashCondition: String? = nil, resourceArn: String? = nil) {
            self.policyHashCondition = policyHashCondition
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, max: 255)
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, min: 1)
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:glue:")
        }

        private enum CodingKeys: String, CodingKey {
            case policyHashCondition = "PolicyHashCondition"
            case resourceArn = "ResourceArn"
        }
    }

    public struct DeleteResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSchemaInput: AWSEncodableShape {
        /// This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
        public let schemaId: SchemaId

        @inlinable
        public init(schemaId: SchemaId) {
            self.schemaId = schemaId
        }

        public func validate(name: String) throws {
            try self.schemaId.validate(name: "\(name).schemaId")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaId = "SchemaId"
        }
    }

    public struct DeleteSchemaResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the schema being deleted.
        public let schemaArn: String?
        /// The name of the schema being deleted.
        public let schemaName: String?
        /// The status of the schema.
        public let status: SchemaStatus?

        @inlinable
        public init(schemaArn: String? = nil, schemaName: String? = nil, status: SchemaStatus? = nil) {
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case status = "Status"
        }
    }

    public struct DeleteSchemaVersionsInput: AWSEncodableShape {
        /// This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
        public let schemaId: SchemaId
        /// A version range may be supplied which may be of the format:   a single version number, 5   a range, 5-8 : deletes versions 5, 6, 7, 8
        public let versions: String

        @inlinable
        public init(schemaId: SchemaId, versions: String) {
            self.schemaId = schemaId
            self.versions = versions
        }

        public func validate(name: String) throws {
            try self.schemaId.validate(name: "\(name).schemaId")
            try self.validate(self.versions, name: "versions", parent: name, max: 100000)
            try self.validate(self.versions, name: "versions", parent: name, min: 1)
            try self.validate(self.versions, name: "versions", parent: name, pattern: "^[1-9][0-9]*|[1-9][0-9]*-[1-9][0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaId = "SchemaId"
            case versions = "Versions"
        }
    }

    public struct DeleteSchemaVersionsResponse: AWSDecodableShape {
        /// A list of SchemaVersionErrorItem objects, each containing an error and schema version.
        public let schemaVersionErrors: [SchemaVersionErrorItem]?

        @inlinable
        public init(schemaVersionErrors: [SchemaVersionErrorItem]? = nil) {
            self.schemaVersionErrors = schemaVersionErrors
        }

        private enum CodingKeys: String, CodingKey {
            case schemaVersionErrors = "SchemaVersionErrors"
        }
    }

    public struct DeleteSecurityConfigurationRequest: AWSEncodableShape {
        /// The name of the security configuration to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteSecurityConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSessionRequest: AWSEncodableShape {
        /// The ID of the session to be deleted.
        public let id: String
        /// The name of the origin of the delete session request.
        public let requestOrigin: String?

        @inlinable
        public init(id: String, requestOrigin: String? = nil) {
            self.id = id
            self.requestOrigin = requestOrigin
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, max: 128)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, min: 1)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case requestOrigin = "RequestOrigin"
        }
    }

    public struct DeleteSessionResponse: AWSDecodableShape {
        /// Returns the ID of the deleted session.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct DeleteTableOptimizerRequest: AWSEncodableShape {
        /// The Catalog ID of the table.
        public let catalogId: String
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String
        /// The name of the table.
        public let tableName: String
        /// The type of table optimizer.
        public let type: TableOptimizerType

        @inlinable
        public init(catalogId: String, databaseName: String, tableName: String, type: TableOptimizerType) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case type = "Type"
        }
    }

    public struct DeleteTableOptimizerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table to be deleted. For Hive compatibility, this name is entirely lowercase.
        public let name: String
        /// The transaction ID at which to delete the table contents.
        public let transactionId: String?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, name: String, transactionId: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
            self.transactionId = transactionId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.transactionId, name: "transactionId", parent: name, max: 255)
            try self.validate(self.transactionId, name: "transactionId", parent: name, min: 1)
            try self.validate(self.transactionId, name: "transactionId", parent: name, pattern: "^[\\p{L}\\p{N}\\p{P}]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case name = "Name"
            case transactionId = "TransactionId"
        }
    }

    public struct DeleteTableResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTableVersionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table. For Hive compatibility,  this name is entirely lowercase.
        public let tableName: String
        /// The ID of the table version to be deleted. A VersionID is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, tableName: String, versionId: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 255)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case versionId = "VersionId"
        }
    }

    public struct DeleteTableVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTriggerRequest: AWSEncodableShape {
        /// The name of the trigger to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteTriggerResponse: AWSDecodableShape {
        /// The name of the trigger that was deleted.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteUsageProfileRequest: AWSEncodableShape {
        /// The name of the usage profile to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteUsageProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUserDefinedFunctionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the function to be deleted is located. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the function is located.
        public let databaseName: String
        /// The name of the function definition to be deleted.
        public let functionName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, functionName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 255)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionName = "FunctionName"
        }
    }

    public struct DeleteUserDefinedFunctionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorkflowRequest: AWSEncodableShape {
        /// Name of the workflow to be deleted.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteWorkflowResponse: AWSDecodableShape {
        /// Name of the workflow specified in input.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeltaTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection to use to connect to the Delta table target.
        public let connectionName: String?
        /// Specifies whether the crawler will create native tables, to allow integration with query engines that support querying of the Delta transaction log directly.
        public let createNativeDeltaTable: Bool?
        /// A list of the Amazon S3 paths to the Delta tables.
        public let deltaTables: [String]?
        /// Specifies whether to write the manifest files to the Delta table path.
        public let writeManifest: Bool?

        @inlinable
        public init(connectionName: String? = nil, createNativeDeltaTable: Bool? = nil, deltaTables: [String]? = nil, writeManifest: Bool? = nil) {
            self.connectionName = connectionName
            self.createNativeDeltaTable = createNativeDeltaTable
            self.deltaTables = deltaTables
            self.writeManifest = writeManifest
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case createNativeDeltaTable = "CreateNativeDeltaTable"
            case deltaTables = "DeltaTables"
            case writeManifest = "WriteManifest"
        }
    }

    public struct DescribeConnectionTypeRequest: AWSEncodableShape {
        /// The name of the connection type to be described.
        public let connectionType: String

        @inlinable
        public init(connectionType: String) {
            self.connectionType = connectionType
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionType, name: "connectionType", parent: name, max: 255)
            try self.validate(self.connectionType, name: "connectionType", parent: name, min: 1)
            try self.validate(self.connectionType, name: "connectionType", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionType = "ConnectionType"
        }
    }

    public struct DescribeConnectionTypeResponse: AWSDecodableShape {
        /// Connection properties specific to the Athena compute environment.
        public let athenaConnectionProperties: [String: Property]?
        /// The type of authentication used for the connection.
        public let authenticationConfiguration: AuthConfiguration?
        /// The supported authentication types, data interface types (compute environments), and data operations of the connector.
        public let capabilities: Capabilities?
        /// The compute environments that are supported by the connection.
        public let computeEnvironmentConfigurations: [String: ComputeEnvironmentConfiguration]?
        /// Returns properties that can be set when creating a connection in the ConnectionInput.ConnectionProperties. ConnectionOptions defines parameters that can be set in a Spark ETL script in the connection options map passed to a dataframe.
        public let connectionOptions: [String: Property]?
        /// Connection properties which are common across compute environments.
        public let connectionProperties: [String: Property]?
        /// The name of the connection type.
        public let connectionType: String?
        /// A description of the connection type.
        public let description: String?
        /// Physical requirements for a connection, such as VPC, Subnet and Security Group specifications.
        public let physicalConnectionRequirements: [String: Property]?
        /// Connection properties specific to the Python compute environment.
        public let pythonConnectionProperties: [String: Property]?
        /// Connection properties specific to the Spark compute environment.
        public let sparkConnectionProperties: [String: Property]?

        @inlinable
        public init(athenaConnectionProperties: [String: Property]? = nil, authenticationConfiguration: AuthConfiguration? = nil, capabilities: Capabilities? = nil, computeEnvironmentConfigurations: [String: ComputeEnvironmentConfiguration]? = nil, connectionOptions: [String: Property]? = nil, connectionProperties: [String: Property]? = nil, connectionType: String? = nil, description: String? = nil, physicalConnectionRequirements: [String: Property]? = nil, pythonConnectionProperties: [String: Property]? = nil, sparkConnectionProperties: [String: Property]? = nil) {
            self.athenaConnectionProperties = athenaConnectionProperties
            self.authenticationConfiguration = authenticationConfiguration
            self.capabilities = capabilities
            self.computeEnvironmentConfigurations = computeEnvironmentConfigurations
            self.connectionOptions = connectionOptions
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
            self.description = description
            self.physicalConnectionRequirements = physicalConnectionRequirements
            self.pythonConnectionProperties = pythonConnectionProperties
            self.sparkConnectionProperties = sparkConnectionProperties
        }

        private enum CodingKeys: String, CodingKey {
            case athenaConnectionProperties = "AthenaConnectionProperties"
            case authenticationConfiguration = "AuthenticationConfiguration"
            case capabilities = "Capabilities"
            case computeEnvironmentConfigurations = "ComputeEnvironmentConfigurations"
            case connectionOptions = "ConnectionOptions"
            case connectionProperties = "ConnectionProperties"
            case connectionType = "ConnectionType"
            case description = "Description"
            case physicalConnectionRequirements = "PhysicalConnectionRequirements"
            case pythonConnectionProperties = "PythonConnectionProperties"
            case sparkConnectionProperties = "SparkConnectionProperties"
        }
    }

    public struct DescribeEntityRequest: AWSEncodableShape {
        /// The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon Web Services Account ID is the catalog ID.
        public let catalogId: String?
        /// The name of the connection that contains the connection type credentials.
        public let connectionName: String
        /// The version of the API used for the data store.
        public let dataStoreApiVersion: String?
        /// The name of the entity that you want to describe from the connection type.
        public let entityName: String
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(catalogId: String? = nil, connectionName: String, dataStoreApiVersion: String? = nil, entityName: String, nextToken: String? = nil) {
            self.catalogId = catalogId
            self.connectionName = connectionName
            self.dataStoreApiVersion = dataStoreApiVersion
            self.entityName = entityName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 255)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.dataStoreApiVersion, name: "dataStoreApiVersion", parent: name, max: 256)
            try self.validate(self.dataStoreApiVersion, name: "dataStoreApiVersion", parent: name, min: 1)
            try self.validate(self.dataStoreApiVersion, name: "dataStoreApiVersion", parent: name, pattern: "^[a-zA-Z0-9.-]*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[-a-zA-Z0-9+=/:_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionName = "ConnectionName"
            case dataStoreApiVersion = "DataStoreApiVersion"
            case entityName = "EntityName"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeEntityResponse: AWSDecodableShape {
        /// Describes the fields for that connector entity. This is the list of Field objects. Field is very similar to column in a database. The Field object has information about different properties associated with fields in the connector.
        public let fields: [Field]?
        /// A continuation token, present if the current segment is not the last.
        public let nextToken: String?

        @inlinable
        public init(fields: [Field]? = nil, nextToken: String? = nil) {
            self.fields = fields
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeInboundIntegrationsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the integration.
        public let integrationArn: String?
        /// A token to specify where to start paginating. This is the marker from a previously truncated response.
        public let marker: String?
        /// The total number of items to return in the output.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the target resource in the integration.
        public let targetArn: String?

        @inlinable
        public init(integrationArn: String? = nil, marker: String? = nil, maxRecords: Int? = nil, targetArn: String? = nil) {
            self.integrationArn = integrationArn
            self.marker = marker
            self.maxRecords = maxRecords
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.integrationArn, name: "integrationArn", parent: name, max: 128)
            try self.validate(self.integrationArn, name: "integrationArn", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 128)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
            try self.validate(self.targetArn, name: "targetArn", parent: name, max: 128)
            try self.validate(self.targetArn, name: "targetArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case integrationArn = "IntegrationArn"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case targetArn = "TargetArn"
        }
    }

    public struct DescribeInboundIntegrationsResponse: AWSDecodableShape {
        /// A list of inbound integrations.
        public let inboundIntegrations: [InboundIntegration]?
        /// A value that indicates the starting point for the next set of response records in a subsequent request.
        public let marker: String?

        @inlinable
        public init(inboundIntegrations: [InboundIntegration]? = nil, marker: String? = nil) {
            self.inboundIntegrations = inboundIntegrations
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case inboundIntegrations = "InboundIntegrations"
            case marker = "Marker"
        }
    }

    public struct DescribeIntegrationsRequest: AWSEncodableShape {
        /// A list of key and values, to filter down the results. Supported keys are "Status", "IntegrationName", and "SourceArn". IntegrationName is limited to only one value.
        public let filters: [IntegrationFilter]?
        /// The Amazon Resource Name (ARN) for the integration.
        public let integrationIdentifier: String?
        /// A value that indicates the starting point for the next set of response records in a subsequent request.
        public let marker: String?
        /// The total number of items to return in the output.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [IntegrationFilter]? = nil, integrationIdentifier: String? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.integrationIdentifier = integrationIdentifier
            self.marker = marker
            self.maxRecords = maxRecords
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, max: 128)
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, min: 1)
            try self.validate(self.marker, name: "marker", parent: name, max: 128)
            try self.validate(self.marker, name: "marker", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case integrationIdentifier = "IntegrationIdentifier"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeIntegrationsResponse: AWSDecodableShape {
        /// A list of zero-ETL integrations.
        public let integrations: [Integration]?
        /// A value that indicates the starting point for the next set of response records in a subsequent request.
        public let marker: String?

        @inlinable
        public init(integrations: [Integration]? = nil, marker: String? = nil) {
            self.integrations = integrations
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case integrations = "Integrations"
            case marker = "Marker"
        }
    }

    public struct DevEndpoint: AWSDecodableShape {
        /// A map of arguments used to configure the DevEndpoint. Valid arguments are:    "--enable-glue-datacatalog": ""    You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public let arguments: [String: String]?
        /// The Amazon Web Services Availability Zone where this DevEndpoint is located.
        public let availabilityZone: String?
        /// The point in time at which this DevEndpoint was created.
        public let createdTimestamp: Date?
        /// The name of the DevEndpoint.
        public let endpointName: String?
        /// The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint.  You can only use pure Java/Scala libraries with a DevEndpoint.
        public let extraJarsS3Path: String?
        /// The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma.  You can only use pure Python libraries with a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not currently supported.
        public let extraPythonLibsS3Path: String?
        /// The reason for a current failure in this DevEndpoint.
        public let failureReason: String?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Development endpoints that are created without specifying a Glue version default to Glue 0.9. You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public let glueVersion: String?
        /// The point in time at which this DevEndpoint was last modified.
        public let lastModifiedTimestamp: Date?
        /// The status of the last update.
        public let lastUpdateStatus: String?
        /// The number of Glue Data Processing Units (DPUs) allocated to this DevEndpoint.
        public let numberOfNodes: Int?
        /// The number of workers of a defined workerType that are allocated to the development endpoint. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
        public let numberOfWorkers: Int?
        /// A private IP address to access the DevEndpoint within a VPC if the DevEndpoint is created within one. The PrivateAddress field is present only when you create the DevEndpoint within your VPC.
        public let privateAddress: String?
        /// The public IP address used by this DevEndpoint. The PublicAddress field is present only when you create a non-virtual private cloud (VPC) DevEndpoint.
        public let publicAddress: String?
        /// The public key to be used by this DevEndpoint for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.
        public let publicKey: String?
        /// A list of public keys to be used by the DevEndpoints for authentication. Using this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.  If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the UpdateDevEndpoint API operation with the public key content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys attribute.
        public let publicKeys: [String]?
        /// The Amazon Resource Name (ARN) of the IAM role used in this DevEndpoint.
        public let roleArn: String?
        /// The name of the SecurityConfiguration structure to be used with this DevEndpoint.
        public let securityConfiguration: String?
        /// A list of security group identifiers used in this DevEndpoint.
        public let securityGroupIds: [String]?
        /// The current status of this DevEndpoint.
        public let status: String?
        /// The subnet ID for this DevEndpoint.
        public let subnetId: String?
        /// The ID of the virtual private cloud (VPC) used by this DevEndpoint.
        public let vpcId: String?
        /// The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   Known issue: when a development endpoint is created with the G.2X WorkerType configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk.
        public let workerType: WorkerType?
        /// The YARN endpoint address used by this DevEndpoint.
        public let yarnEndpointAddress: String?
        /// The Apache Zeppelin port for the remote Apache Spark interpreter.
        public let zeppelinRemoteSparkInterpreterPort: Int?

        @inlinable
        public init(arguments: [String: String]? = nil, availabilityZone: String? = nil, createdTimestamp: Date? = nil, endpointName: String? = nil, extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil, failureReason: String? = nil, glueVersion: String? = nil, lastModifiedTimestamp: Date? = nil, lastUpdateStatus: String? = nil, numberOfNodes: Int? = nil, numberOfWorkers: Int? = nil, privateAddress: String? = nil, publicAddress: String? = nil, publicKey: String? = nil, publicKeys: [String]? = nil, roleArn: String? = nil, securityConfiguration: String? = nil, securityGroupIds: [String]? = nil, status: String? = nil, subnetId: String? = nil, vpcId: String? = nil, workerType: WorkerType? = nil, yarnEndpointAddress: String? = nil, zeppelinRemoteSparkInterpreterPort: Int? = nil) {
            self.arguments = arguments
            self.availabilityZone = availabilityZone
            self.createdTimestamp = createdTimestamp
            self.endpointName = endpointName
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.failureReason = failureReason
            self.glueVersion = glueVersion
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.lastUpdateStatus = lastUpdateStatus
            self.numberOfNodes = numberOfNodes
            self.numberOfWorkers = numberOfWorkers
            self.privateAddress = privateAddress
            self.publicAddress = publicAddress
            self.publicKey = publicKey
            self.publicKeys = publicKeys
            self.roleArn = roleArn
            self.securityConfiguration = securityConfiguration
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetId = subnetId
            self.vpcId = vpcId
            self.workerType = workerType
            self.yarnEndpointAddress = yarnEndpointAddress
            self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case availabilityZone = "AvailabilityZone"
            case createdTimestamp = "CreatedTimestamp"
            case endpointName = "EndpointName"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case failureReason = "FailureReason"
            case glueVersion = "GlueVersion"
            case lastModifiedTimestamp = "LastModifiedTimestamp"
            case lastUpdateStatus = "LastUpdateStatus"
            case numberOfNodes = "NumberOfNodes"
            case numberOfWorkers = "NumberOfWorkers"
            case privateAddress = "PrivateAddress"
            case publicAddress = "PublicAddress"
            case publicKey = "PublicKey"
            case publicKeys = "PublicKeys"
            case roleArn = "RoleArn"
            case securityConfiguration = "SecurityConfiguration"
            case securityGroupIds = "SecurityGroupIds"
            case status = "Status"
            case subnetId = "SubnetId"
            case vpcId = "VpcId"
            case workerType = "WorkerType"
            case yarnEndpointAddress = "YarnEndpointAddress"
            case zeppelinRemoteSparkInterpreterPort = "ZeppelinRemoteSparkInterpreterPort"
        }
    }

    public struct DevEndpointCustomLibraries: AWSEncodableShape {
        /// The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint.  You can only use pure Java/Scala libraries with a DevEndpoint.
        public let extraJarsS3Path: String?
        /// The paths to one or more Python libraries in an Amazon Simple Storage Service (Amazon S3) bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma.  You can only use pure Python libraries with a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not currently supported.
        public let extraPythonLibsS3Path: String?

        @inlinable
        public init(extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil) {
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
        }

        private enum CodingKeys: String, CodingKey {
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
        }
    }

    public struct DirectJDBCSource: AWSEncodableShape & AWSDecodableShape {
        /// The connection name of the JDBC source.
        public let connectionName: String
        /// The connection type of the JDBC source.
        public let connectionType: JDBCConnectionType
        /// The database of the JDBC source connection.
        public let database: String
        /// The name of the JDBC source connection.
        public let name: String
        /// The temp directory of the JDBC Redshift source.
        public let redshiftTmpDir: String?
        /// The table of the JDBC source connection.
        public let table: String

        @inlinable
        public init(connectionName: String, connectionType: JDBCConnectionType, database: String, name: String, redshiftTmpDir: String? = nil, table: String) {
            self.connectionName = connectionName
            self.connectionType = connectionType
            self.database = database
            self.name = name
            self.redshiftTmpDir = redshiftTmpDir
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.redshiftTmpDir, name: "redshiftTmpDir", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case connectionType = "ConnectionType"
            case database = "Database"
            case name = "Name"
            case redshiftTmpDir = "RedshiftTmpDir"
            case table = "Table"
        }
    }

    public struct DirectKafkaSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies options related to data preview for viewing a sample of your data.
        public let dataPreviewOptions: StreamingDataPreviewOptions?
        /// Whether to automatically determine the schema from the incoming data.
        public let detectSchema: Bool?
        /// The name of the data store.
        public let name: String
        /// Specifies the streaming options.
        public let streamingOptions: KafkaStreamingSourceOptions?
        /// The amount of time to spend processing each micro batch.
        public let windowSize: Int?

        @inlinable
        public init(dataPreviewOptions: StreamingDataPreviewOptions? = nil, detectSchema: Bool? = nil, name: String, streamingOptions: KafkaStreamingSourceOptions? = nil, windowSize: Int? = nil) {
            self.dataPreviewOptions = dataPreviewOptions
            self.detectSchema = detectSchema
            self.name = name
            self.streamingOptions = streamingOptions
            self.windowSize = windowSize
        }

        public func validate(name: String) throws {
            try self.dataPreviewOptions?.validate(name: "\(name).dataPreviewOptions")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.streamingOptions?.validate(name: "\(name).streamingOptions")
            try self.validate(self.windowSize, name: "windowSize", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dataPreviewOptions = "DataPreviewOptions"
            case detectSchema = "DetectSchema"
            case name = "Name"
            case streamingOptions = "StreamingOptions"
            case windowSize = "WindowSize"
        }
    }

    public struct DirectKinesisSource: AWSEncodableShape & AWSDecodableShape {
        /// Additional options for data preview.
        public let dataPreviewOptions: StreamingDataPreviewOptions?
        /// Whether to automatically determine the schema from the incoming data.
        public let detectSchema: Bool?
        /// The name of the data source.
        public let name: String
        /// Additional options for the Kinesis streaming data source.
        public let streamingOptions: KinesisStreamingSourceOptions?
        /// The amount of time to spend processing each micro batch.
        public let windowSize: Int?

        @inlinable
        public init(dataPreviewOptions: StreamingDataPreviewOptions? = nil, detectSchema: Bool? = nil, name: String, streamingOptions: KinesisStreamingSourceOptions? = nil, windowSize: Int? = nil) {
            self.dataPreviewOptions = dataPreviewOptions
            self.detectSchema = detectSchema
            self.name = name
            self.streamingOptions = streamingOptions
            self.windowSize = windowSize
        }

        public func validate(name: String) throws {
            try self.dataPreviewOptions?.validate(name: "\(name).dataPreviewOptions")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.streamingOptions?.validate(name: "\(name).streamingOptions")
            try self.validate(self.windowSize, name: "windowSize", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dataPreviewOptions = "DataPreviewOptions"
            case detectSchema = "DetectSchema"
            case name = "Name"
            case streamingOptions = "StreamingOptions"
            case windowSize = "WindowSize"
        }
    }

    public struct DirectSchemaChangePolicy: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the database that the schema change policy applies to.
        public let database: String?
        /// Whether to use the specified update behavior when the crawler finds a changed schema.
        public let enableUpdateCatalog: Bool?
        /// Specifies the table in the database that the schema change policy applies to.
        public let table: String?
        /// The update behavior when the crawler finds a changed schema.
        public let updateBehavior: UpdateCatalogBehavior?

        @inlinable
        public init(database: String? = nil, enableUpdateCatalog: Bool? = nil, table: String? = nil, updateBehavior: UpdateCatalogBehavior? = nil) {
            self.database = database
            self.enableUpdateCatalog = enableUpdateCatalog
            self.table = table
            self.updateBehavior = updateBehavior
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case enableUpdateCatalog = "EnableUpdateCatalog"
            case table = "Table"
            case updateBehavior = "UpdateBehavior"
        }
    }

    public struct DoubleColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The highest value in the column.
        public let maximumValue: Double?
        /// The lowest value in the column.
        public let minimumValue: Double?
        /// The number of distinct values in a column.
        public let numberOfDistinctValues: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        @inlinable
        public init(maximumValue: Double? = nil, minimumValue: Double? = nil, numberOfDistinctValues: Int64, numberOfNulls: Int64) {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDistinctValues, name: "numberOfDistinctValues", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case numberOfDistinctValues = "NumberOfDistinctValues"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct DropDuplicates: AWSEncodableShape & AWSDecodableShape {
        /// The name of the columns to be merged or removed if repeating.
        public let columns: [[String]]?
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String

        @inlinable
        public init(columns: [[String]]? = nil, inputs: [String], name: String) {
            self.columns = columns
            self.inputs = inputs
            self.name = name
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case inputs = "Inputs"
            case name = "Name"
        }
    }

    public struct DropFields: AWSEncodableShape & AWSDecodableShape {
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String
        /// A JSON path to a variable in the data structure.
        public let paths: [[String]]

        @inlinable
        public init(inputs: [String], name: String, paths: [[String]]) {
            self.inputs = inputs
            self.name = name
            self.paths = paths
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case paths = "Paths"
        }
    }

    public struct DropNullFields: AWSEncodableShape & AWSDecodableShape {
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String
        /// A structure that represents whether certain values are recognized as null values for removal.
        public let nullCheckBoxList: NullCheckBoxList?
        /// A structure that specifies a list of NullValueField structures that represent a custom null value such as zero or other value being used as a null placeholder unique to the dataset. The DropNullFields transform removes custom null values only if both the value of the null placeholder and the datatype match the data.
        public let nullTextList: [NullValueField]?

        @inlinable
        public init(inputs: [String], name: String, nullCheckBoxList: NullCheckBoxList? = nil, nullTextList: [NullValueField]? = nil) {
            self.inputs = inputs
            self.name = name
            self.nullCheckBoxList = nullCheckBoxList
            self.nullTextList = nullTextList
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.nullTextList?.forEach {
                try $0.validate(name: "\(name).nullTextList[]")
            }
            try self.validate(self.nullTextList, name: "nullTextList", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case nullCheckBoxList = "NullCheckBoxList"
            case nullTextList = "NullTextList"
        }
    }

    public struct DynamicTransform: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the name of the function of the dynamic transform.
        public let functionName: String
        /// Specifies the inputs for the dynamic transform that are required.
        public let inputs: [String]
        /// Specifies the name of the dynamic transform.
        public let name: String
        /// Specifies the data schema for the dynamic transform.
        public let outputSchemas: [GlueSchema]?
        /// Specifies the parameters of the dynamic transform.
        public let parameters: [TransformConfigParameter]?
        /// Specifies the path of the dynamic transform source and config files.
        public let path: String
        /// Specifies the name of the dynamic transform as it appears in the Glue Studio visual editor.
        public let transformName: String
        /// This field is not used and will be deprecated in future release.
        public let version: String?

        @inlinable
        public init(functionName: String, inputs: [String], name: String, outputSchemas: [GlueSchema]? = nil, parameters: [TransformConfigParameter]? = nil, path: String, transformName: String, version: String? = nil) {
            self.functionName = functionName
            self.inputs = inputs
            self.name = name
            self.outputSchemas = outputSchemas
            self.parameters = parameters
            self.path = path
            self.transformName = transformName
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.parameters?.forEach {
                try $0.validate(name: "\(name).parameters[]")
            }
            try self.validate(self.path, name: "path", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.transformName, name: "transformName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.version, name: "version", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case functionName = "FunctionName"
            case inputs = "Inputs"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case parameters = "Parameters"
            case path = "Path"
            case transformName = "TransformName"
            case version = "Version"
        }
    }

    public struct DynamoDBCatalogSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to read from.
        public let database: String
        /// The name of the data source.
        public let name: String
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(database: String, name: String, table: String) {
            self.database = database
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct DynamoDBTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the DynamoDB table to crawl.
        public let path: String?
        /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table. A value of true means to scan all records, while a value of false means to sample the records. If no value is specified, the value defaults to true.
        public let scanAll: Bool?
        /// The percentage of the configured read capacity units to use by the Glue crawler. Read capacity units is a term defined by DynamoDB, and is a numeric value that acts as rate limiter for the number of reads that can be performed on that table per second. The valid values are null or a value between 0.1 to 1.5. A null value is used when user does not provide a value, and defaults to 0.5 of the configured Read Capacity Unit (for provisioned tables), or 0.25 of the max configured Read Capacity Unit (for tables using on-demand mode).
        public let scanRate: Double?

        @inlinable
        public init(path: String? = nil, scanAll: Bool? = nil, scanRate: Double? = nil) {
            self.path = path
            self.scanAll = scanAll
            self.scanRate = scanRate
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
            case scanAll = "scanAll"
            case scanRate = "scanRate"
        }
    }

    public struct Edge: AWSDecodableShape {
        /// The unique of the node within the workflow where the edge ends.
        public let destinationId: String?
        /// The unique of the node within the workflow where the edge starts.
        public let sourceId: String?

        @inlinable
        public init(destinationId: String? = nil, sourceId: String? = nil) {
            self.destinationId = destinationId
            self.sourceId = sourceId
        }

        private enum CodingKeys: String, CodingKey {
            case destinationId = "DestinationId"
            case sourceId = "SourceId"
        }
    }

    public struct EncryptionAtRest: AWSEncodableShape & AWSDecodableShape {
        /// The encryption-at-rest mode for encrypting Data Catalog data.
        public let catalogEncryptionMode: CatalogEncryptionMode
        /// The role that Glue assumes to encrypt and decrypt the Data Catalog objects on the caller's behalf.
        public let catalogEncryptionServiceRole: String?
        /// The ID of the KMS key to use for encryption at rest.
        public let sseAwsKmsKeyId: String?

        @inlinable
        public init(catalogEncryptionMode: CatalogEncryptionMode, catalogEncryptionServiceRole: String? = nil, sseAwsKmsKeyId: String? = nil) {
            self.catalogEncryptionMode = catalogEncryptionMode
            self.catalogEncryptionServiceRole = catalogEncryptionServiceRole
            self.sseAwsKmsKeyId = sseAwsKmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogEncryptionServiceRole, name: "catalogEncryptionServiceRole", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:iam::[0-9]{12}:role/.+$")
            try self.validate(self.sseAwsKmsKeyId, name: "sseAwsKmsKeyId", parent: name, max: 255)
            try self.validate(self.sseAwsKmsKeyId, name: "sseAwsKmsKeyId", parent: name, min: 1)
            try self.validate(self.sseAwsKmsKeyId, name: "sseAwsKmsKeyId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogEncryptionMode = "CatalogEncryptionMode"
            case catalogEncryptionServiceRole = "CatalogEncryptionServiceRole"
            case sseAwsKmsKeyId = "SseAwsKmsKeyId"
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The encryption configuration for Amazon CloudWatch.
        public let cloudWatchEncryption: CloudWatchEncryption?
        /// The encryption configuration for Glue Data Quality assets.
        public let dataQualityEncryption: DataQualityEncryption?
        /// The encryption configuration for job bookmarks.
        public let jobBookmarksEncryption: JobBookmarksEncryption?
        /// The encryption configuration for Amazon Simple Storage Service (Amazon S3) data.
        public let s3Encryption: [S3Encryption]?

        @inlinable
        public init(cloudWatchEncryption: CloudWatchEncryption? = nil, dataQualityEncryption: DataQualityEncryption? = nil, jobBookmarksEncryption: JobBookmarksEncryption? = nil, s3Encryption: [S3Encryption]? = nil) {
            self.cloudWatchEncryption = cloudWatchEncryption
            self.dataQualityEncryption = dataQualityEncryption
            self.jobBookmarksEncryption = jobBookmarksEncryption
            self.s3Encryption = s3Encryption
        }

        public func validate(name: String) throws {
            try self.cloudWatchEncryption?.validate(name: "\(name).cloudWatchEncryption")
            try self.dataQualityEncryption?.validate(name: "\(name).dataQualityEncryption")
            try self.jobBookmarksEncryption?.validate(name: "\(name).jobBookmarksEncryption")
            try self.s3Encryption?.forEach {
                try $0.validate(name: "\(name).s3Encryption[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchEncryption = "CloudWatchEncryption"
            case dataQualityEncryption = "DataQualityEncryption"
            case jobBookmarksEncryption = "JobBookmarksEncryption"
            case s3Encryption = "S3Encryption"
        }
    }

    public struct Entity: AWSDecodableShape {
        /// The type of entities that are present in the response. This value depends on the source connection. For example this is SObjects for Salesforce and databases or schemas or tables for sources like Amazon Redshift.
        public let category: String?
        /// An optional map of keys which may be returned for an entity by a connector.
        public let customProperties: [String: String]?
        /// A description of the entity.
        public let description: String?
        /// The name of the entity.
        public let entityName: String?
        /// A Boolean value which helps to determine whether there are sub objects that can be listed.
        public let isParentEntity: Bool?
        /// Label used for the entity.
        public let label: String?

        @inlinable
        public init(category: String? = nil, customProperties: [String: String]? = nil, description: String? = nil, entityName: String? = nil, isParentEntity: Bool? = nil, label: String? = nil) {
            self.category = category
            self.customProperties = customProperties
            self.description = description
            self.entityName = entityName
            self.isParentEntity = isParentEntity
            self.label = label
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case customProperties = "CustomProperties"
            case description = "Description"
            case entityName = "EntityName"
            case isParentEntity = "IsParentEntity"
            case label = "Label"
        }
    }

    public struct EntityNotFoundException: AWSErrorShape {
        /// Indicates whether or not the exception relates to a federated source.
        public let fromFederationSource: Bool?
        /// A message describing the problem.
        public let message: String?

        @inlinable
        public init(fromFederationSource: Bool? = nil, message: String? = nil) {
            self.fromFederationSource = fromFederationSource
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case fromFederationSource = "FromFederationSource"
            case message = "Message"
        }
    }

    public struct ErrorDetail: AWSDecodableShape {
        /// The code associated with this error.
        public let errorCode: String?
        /// A message describing the error.
        public let errorMessage: String?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error code for an error.
        public let errorCode: String?
        /// The error message for an error.
        public let errorMessage: String?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct EvaluateDataQuality: AWSEncodableShape & AWSDecodableShape {
        /// The inputs of your data quality evaluation.
        public let inputs: [String]
        /// The name of the data quality evaluation.
        public let name: String
        /// The output of your data quality evaluation.
        public let output: DQTransformOutput?
        /// Options to configure how your results are published.
        public let publishingOptions: DQResultsPublishingOptions?
        /// The ruleset for your data quality evaluation.
        public let ruleset: String
        /// Options to configure how your job will stop if your data quality evaluation fails.
        public let stopJobOnFailureOptions: DQStopJobOnFailureOptions?

        @inlinable
        public init(inputs: [String], name: String, output: DQTransformOutput? = nil, publishingOptions: DQResultsPublishingOptions? = nil, ruleset: String, stopJobOnFailureOptions: DQStopJobOnFailureOptions? = nil) {
            self.inputs = inputs
            self.name = name
            self.output = output
            self.publishingOptions = publishingOptions
            self.ruleset = ruleset
            self.stopJobOnFailureOptions = stopJobOnFailureOptions
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.publishingOptions?.validate(name: "\(name).publishingOptions")
            try self.validate(self.ruleset, name: "ruleset", parent: name, max: 65536)
            try self.validate(self.ruleset, name: "ruleset", parent: name, min: 1)
            try self.validate(self.ruleset, name: "ruleset", parent: name, pattern: "^([\\u0020-\\u007E\\r\\s\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case output = "Output"
            case publishingOptions = "PublishingOptions"
            case ruleset = "Ruleset"
            case stopJobOnFailureOptions = "StopJobOnFailureOptions"
        }
    }

    public struct EvaluateDataQualityMultiFrame: AWSEncodableShape & AWSDecodableShape {
        /// The aliases of all data sources except primary.
        public let additionalDataSources: [String: String]?
        /// Options to configure runtime behavior of the transform.
        public let additionalOptions: [AdditionalOptionKeys: String]?
        /// The inputs of your data quality evaluation. The first input in this list is the primary data source.
        public let inputs: [String]
        /// The name of the data quality evaluation.
        public let name: String
        /// Options to configure how your results are published.
        public let publishingOptions: DQResultsPublishingOptions?
        /// The ruleset for your data quality evaluation.
        public let ruleset: String
        /// Options to configure how your job will stop if your data quality evaluation fails.
        public let stopJobOnFailureOptions: DQStopJobOnFailureOptions?

        @inlinable
        public init(additionalDataSources: [String: String]? = nil, additionalOptions: [AdditionalOptionKeys: String]? = nil, inputs: [String], name: String, publishingOptions: DQResultsPublishingOptions? = nil, ruleset: String, stopJobOnFailureOptions: DQStopJobOnFailureOptions? = nil) {
            self.additionalDataSources = additionalDataSources
            self.additionalOptions = additionalOptions
            self.inputs = inputs
            self.name = name
            self.publishingOptions = publishingOptions
            self.ruleset = ruleset
            self.stopJobOnFailureOptions = stopJobOnFailureOptions
        }

        public func validate(name: String) throws {
            try self.additionalDataSources?.forEach {
                try validate($0.key, name: "additionalDataSources.key", parent: name, pattern: "^([^\\r\\n])*$")
                try validate($0.value, name: "additionalDataSources[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.publishingOptions?.validate(name: "\(name).publishingOptions")
            try self.validate(self.ruleset, name: "ruleset", parent: name, max: 65536)
            try self.validate(self.ruleset, name: "ruleset", parent: name, min: 1)
            try self.validate(self.ruleset, name: "ruleset", parent: name, pattern: "^([\\u0020-\\u007E\\r\\s\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalDataSources = "AdditionalDataSources"
            case additionalOptions = "AdditionalOptions"
            case inputs = "Inputs"
            case name = "Name"
            case publishingOptions = "PublishingOptions"
            case ruleset = "Ruleset"
            case stopJobOnFailureOptions = "StopJobOnFailureOptions"
        }
    }

    public struct EvaluationMetrics: AWSDecodableShape {
        /// The evaluation metrics for the find matches algorithm.
        public let findMatchesMetrics: FindMatchesMetrics?
        /// The type of machine learning transform.
        public let transformType: TransformType

        @inlinable
        public init(findMatchesMetrics: FindMatchesMetrics? = nil, transformType: TransformType) {
            self.findMatchesMetrics = findMatchesMetrics
            self.transformType = transformType
        }

        private enum CodingKeys: String, CodingKey {
            case findMatchesMetrics = "FindMatchesMetrics"
            case transformType = "TransformType"
        }
    }

    public struct EventBatchingCondition: AWSEncodableShape & AWSDecodableShape {
        /// Number of events that must be received from Amazon EventBridge before EventBridge event trigger fires.
        public let batchSize: Int
        /// Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received.
        public let batchWindow: Int?

        @inlinable
        public init(batchSize: Int, batchWindow: Int? = nil) {
            self.batchSize = batchSize
            self.batchWindow = batchWindow
        }

        public func validate(name: String) throws {
            try self.validate(self.batchSize, name: "batchSize", parent: name, max: 100)
            try self.validate(self.batchSize, name: "batchSize", parent: name, min: 1)
            try self.validate(self.batchWindow, name: "batchWindow", parent: name, max: 900)
            try self.validate(self.batchWindow, name: "batchWindow", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case batchSize = "BatchSize"
            case batchWindow = "BatchWindow"
        }
    }

    public struct ExecutionAttempt: AWSDecodableShape {
        /// A task run ID for the last column statistics task run.
        public let columnStatisticsTaskRunId: String?
        /// An error message associated with the last column statistics task run.
        public let errorMessage: String?
        /// A timestamp when the last column statistics task run occurred.
        public let executionTimestamp: Date?
        /// The status of the last column statistics task run.
        public let status: ExecutionStatus?

        @inlinable
        public init(columnStatisticsTaskRunId: String? = nil, errorMessage: String? = nil, executionTimestamp: Date? = nil, status: ExecutionStatus? = nil) {
            self.columnStatisticsTaskRunId = columnStatisticsTaskRunId
            self.errorMessage = errorMessage
            self.executionTimestamp = executionTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsTaskRunId = "ColumnStatisticsTaskRunId"
            case errorMessage = "ErrorMessage"
            case executionTimestamp = "ExecutionTimestamp"
            case status = "Status"
        }
    }

    public struct ExecutionProperty: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.
        public let maxConcurrentRuns: Int?

        @inlinable
        public init(maxConcurrentRuns: Int? = nil) {
            self.maxConcurrentRuns = maxConcurrentRuns
        }

        private enum CodingKeys: String, CodingKey {
            case maxConcurrentRuns = "MaxConcurrentRuns"
        }
    }

    public struct ExportLabelsTaskRunProperties: AWSDecodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path where you will export the labels.
        public let outputS3Path: String?

        @inlinable
        public init(outputS3Path: String? = nil) {
            self.outputS3Path = outputS3Path
        }

        private enum CodingKeys: String, CodingKey {
            case outputS3Path = "OutputS3Path"
        }
    }

    public struct FederatedCatalog: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection to an external data source, for example a Redshift-federated catalog.
        public let connectionName: String?
        /// A unique identifier for the federated catalog.
        public let identifier: String?

        @inlinable
        public init(connectionName: String? = nil, identifier: String? = nil) {
            self.connectionName = connectionName
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 255)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 512)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case identifier = "Identifier"
        }
    }

    public struct FederatedDatabase: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection to the external metastore.
        public let connectionName: String?
        /// A unique identifier for the federated database.
        public let identifier: String?

        @inlinable
        public init(connectionName: String? = nil, identifier: String? = nil) {
            self.connectionName = connectionName
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 255)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 512)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case identifier = "Identifier"
        }
    }

    public struct FederatedResourceAlreadyExistsException: AWSErrorShape {
        /// The associated Glue resource already exists.
        public let associatedGlueResource: String?
        /// The message describing the problem.
        public let message: String?

        @inlinable
        public init(associatedGlueResource: String? = nil, message: String? = nil) {
            self.associatedGlueResource = associatedGlueResource
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case associatedGlueResource = "AssociatedGlueResource"
            case message = "Message"
        }
    }

    public struct FederatedTable: AWSDecodableShape {
        /// The name of the connection to the external metastore.
        public let connectionName: String?
        /// A unique identifier for the federated database.
        public let databaseIdentifier: String?
        /// A unique identifier for the federated table.
        public let identifier: String?

        @inlinable
        public init(connectionName: String? = nil, databaseIdentifier: String? = nil, identifier: String? = nil) {
            self.connectionName = connectionName
            self.databaseIdentifier = databaseIdentifier
            self.identifier = identifier
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case databaseIdentifier = "DatabaseIdentifier"
            case identifier = "Identifier"
        }
    }

    public struct FederationSourceException: AWSErrorShape {
        /// The error code of the problem.
        public let federationSourceErrorCode: FederationSourceErrorCode?
        /// The message describing the problem.
        public let message: String?

        @inlinable
        public init(federationSourceErrorCode: FederationSourceErrorCode? = nil, message: String? = nil) {
            self.federationSourceErrorCode = federationSourceErrorCode
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case federationSourceErrorCode = "FederationSourceErrorCode"
            case message = "Message"
        }
    }

    public struct Field: AWSDecodableShape {
        /// Optional map of keys which may be returned.
        public let customProperties: [String: String]?
        /// A description of the field.
        public let description: String?
        /// A unique identifier for the field.
        public let fieldName: String?
        /// The type of data in the field.
        public let fieldType: FieldDataType?
        /// Indicates whether this field can be created as part of a destination write.
        public let isCreateable: Bool?
        /// Indicates whether this field is populated automatically when the object is created, such as a created at timestamp.
        public let isDefaultOnCreate: Bool?
        ///  Indicates whether this field can used in a filter clause (WHERE clause) of a SQL statement when querying data.
        public let isFilterable: Bool?
        /// Indicates whether this field can be nullable or not.
        public let isNullable: Bool?
        /// Indicates whether a given field can be used in partitioning the query made to SaaS.
        public let isPartitionable: Bool?
        /// Indicates whether this field can used as a primary key for the given entity.
        public let isPrimaryKey: Bool?
        /// Indicates whether this field can be added in Select clause of SQL query or whether it is retrievable or not.
        public let isRetrievable: Bool?
        /// Indicates whether this field can be updated as part of a destination write.
        public let isUpdateable: Bool?
        /// Indicates whether this field can be upserted as part of a destination write.
        public let isUpsertable: Bool?
        /// A readable label used for the field.
        public let label: String?
        /// The data type returned by the SaaS API, such as picklist or textarea from Salesforce.
        public let nativeDataType: String?
        /// A parent field name for a nested field.
        public let parentField: String?
        /// Indicates the support filter operators for this field.
        public let supportedFilterOperators: [FieldFilterOperator]?
        /// A list of supported values for the field.
        public let supportedValues: [String]?

        @inlinable
        public init(customProperties: [String: String]? = nil, description: String? = nil, fieldName: String? = nil, fieldType: FieldDataType? = nil, isCreateable: Bool? = nil, isDefaultOnCreate: Bool? = nil, isFilterable: Bool? = nil, isNullable: Bool? = nil, isPartitionable: Bool? = nil, isPrimaryKey: Bool? = nil, isRetrievable: Bool? = nil, isUpdateable: Bool? = nil, isUpsertable: Bool? = nil, label: String? = nil, nativeDataType: String? = nil, parentField: String? = nil, supportedFilterOperators: [FieldFilterOperator]? = nil, supportedValues: [String]? = nil) {
            self.customProperties = customProperties
            self.description = description
            self.fieldName = fieldName
            self.fieldType = fieldType
            self.isCreateable = isCreateable
            self.isDefaultOnCreate = isDefaultOnCreate
            self.isFilterable = isFilterable
            self.isNullable = isNullable
            self.isPartitionable = isPartitionable
            self.isPrimaryKey = isPrimaryKey
            self.isRetrievable = isRetrievable
            self.isUpdateable = isUpdateable
            self.isUpsertable = isUpsertable
            self.label = label
            self.nativeDataType = nativeDataType
            self.parentField = parentField
            self.supportedFilterOperators = supportedFilterOperators
            self.supportedValues = supportedValues
        }

        private enum CodingKeys: String, CodingKey {
            case customProperties = "CustomProperties"
            case description = "Description"
            case fieldName = "FieldName"
            case fieldType = "FieldType"
            case isCreateable = "IsCreateable"
            case isDefaultOnCreate = "IsDefaultOnCreate"
            case isFilterable = "IsFilterable"
            case isNullable = "IsNullable"
            case isPartitionable = "IsPartitionable"
            case isPrimaryKey = "IsPrimaryKey"
            case isRetrievable = "IsRetrievable"
            case isUpdateable = "IsUpdateable"
            case isUpsertable = "IsUpsertable"
            case label = "Label"
            case nativeDataType = "NativeDataType"
            case parentField = "ParentField"
            case supportedFilterOperators = "SupportedFilterOperators"
            case supportedValues = "SupportedValues"
        }
    }

    public struct FillMissingValues: AWSEncodableShape & AWSDecodableShape {
        /// A JSON path to a variable in the data structure for the dataset that is filled.
        public let filledPath: String?
        /// A JSON path to a variable in the data structure for the dataset that is imputed.
        public let imputedPath: String
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String

        @inlinable
        public init(filledPath: String? = nil, imputedPath: String, inputs: [String], name: String) {
            self.filledPath = filledPath
            self.imputedPath = imputedPath
            self.inputs = inputs
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.filledPath, name: "filledPath", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.imputedPath, name: "imputedPath", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filledPath = "FilledPath"
            case imputedPath = "ImputedPath"
            case inputs = "Inputs"
            case name = "Name"
        }
    }

    public struct Filter: AWSEncodableShape & AWSDecodableShape {
        /// Specifies a filter expression.
        public let filters: [FilterExpression]
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The operator used to filter rows by comparing the key value to a specified value.
        public let logicalOperator: FilterLogicalOperator
        /// The name of the transform node.
        public let name: String

        @inlinable
        public init(filters: [FilterExpression], inputs: [String], logicalOperator: FilterLogicalOperator, name: String) {
            self.filters = filters
            self.inputs = inputs
            self.logicalOperator = logicalOperator
            self.name = name
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case inputs = "Inputs"
            case logicalOperator = "LogicalOperator"
            case name = "Name"
        }
    }

    public struct FilterExpression: AWSEncodableShape & AWSDecodableShape {
        /// Whether the expression is to be negated.
        public let negated: Bool?
        /// The type of operation to perform in the expression.
        public let operation: FilterOperation
        /// A list of filter values.
        public let values: [FilterValue]

        @inlinable
        public init(negated: Bool? = nil, operation: FilterOperation, values: [FilterValue]) {
            self.negated = negated
            self.operation = operation
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try $0.validate(name: "\(name).values[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case negated = "Negated"
            case operation = "Operation"
            case values = "Values"
        }
    }

    public struct FilterValue: AWSEncodableShape & AWSDecodableShape {
        /// The type of filter value.
        public let type: FilterValueType
        /// The value to be associated.
        public let value: [String]

        @inlinable
        public init(type: FilterValueType, value: [String]) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.value.forEach {
                try validate($0, name: "value[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct FindMatchesMetrics: AWSDecodableShape {
        /// The area under the precision/recall curve (AUPRC) is a single number measuring the overall quality of the transform, that is independent of the choice made for precision vs. recall. Higher values indicate that you have a more attractive precision vs. recall tradeoff. For more information, see Precision and recall in Wikipedia.
        public let areaUnderPRCurve: Double?
        /// A list of ColumnImportance structures containing column importance metrics, sorted in order of descending importance.
        public let columnImportances: [ColumnImportance]?
        /// The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making. For more information, see Confusion matrix in Wikipedia.
        public let confusionMatrix: ConfusionMatrix?
        /// The maximum F1 metric indicates the transform's accuracy between 0 and 1, where 1 is the best accuracy. For more information, see F1 score in Wikipedia.
        public let f1: Double?
        /// The precision metric indicates when often your transform is correct when it predicts a match. Specifically, it measures how well the transform finds true positives from the total true positives possible. For more information, see Precision and recall in Wikipedia.
        public let precision: Double?
        /// The recall metric indicates that for an actual match, how often your transform predicts the match. Specifically, it measures how well the transform finds true positives from the total records in the source data. For more information, see Precision and recall in Wikipedia.
        public let recall: Double?

        @inlinable
        public init(areaUnderPRCurve: Double? = nil, columnImportances: [ColumnImportance]? = nil, confusionMatrix: ConfusionMatrix? = nil, f1: Double? = nil, precision: Double? = nil, recall: Double? = nil) {
            self.areaUnderPRCurve = areaUnderPRCurve
            self.columnImportances = columnImportances
            self.confusionMatrix = confusionMatrix
            self.f1 = f1
            self.precision = precision
            self.recall = recall
        }

        private enum CodingKeys: String, CodingKey {
            case areaUnderPRCurve = "AreaUnderPRCurve"
            case columnImportances = "ColumnImportances"
            case confusionMatrix = "ConfusionMatrix"
            case f1 = "F1"
            case precision = "Precision"
            case recall = "Recall"
        }
    }

    public struct FindMatchesParameters: AWSEncodableShape & AWSDecodableShape {
        /// The value that is selected when tuning your transform for a balance between accuracy and cost. A value of 0.5 means that the system balances accuracy and cost concerns. A value of 1.0 means a bias purely for accuracy, which typically results in a higher cost, sometimes substantially higher. A value of 0.0 means a bias purely for cost, which results in a less accurate FindMatches transform, sometimes with unacceptable accuracy. Accuracy measures how well the transform finds true positives and true negatives. Increasing accuracy requires more machine resources and cost. But it also results in increased recall.  Cost measures how many compute resources, and thus money, are consumed to run the transform.
        public let accuracyCostTradeoff: Double?
        /// The value to switch on or off to force the output to match the provided labels from users. If the value is True, the find matches transform forces the output to match the provided labels. The results override the normal conflation results. If the value is False, the find matches transform does not ensure all the labels provided are respected, and the results rely on the trained model. Note that setting this value to true may increase the conflation execution time.
        public let enforceProvidedLabels: Bool?
        /// The value selected when tuning your transform for a balance between precision and recall. A value of 0.5 means no preference; a value of 1.0 means a bias purely for precision, and a value of 0.0 means a bias for recall. Because this is a tradeoff, choosing values close to 1.0 means very low recall, and choosing values close to 0.0 results in very low precision. The precision metric indicates how often your model is correct when it predicts a match.  The recall metric indicates that for an actual match, how often your model predicts the match.
        public let precisionRecallTradeoff: Double?
        /// The name of a column that uniquely identifies rows in the source table. Used to help identify matching records.
        public let primaryKeyColumnName: String?

        @inlinable
        public init(accuracyCostTradeoff: Double? = nil, enforceProvidedLabels: Bool? = nil, precisionRecallTradeoff: Double? = nil, primaryKeyColumnName: String? = nil) {
            self.accuracyCostTradeoff = accuracyCostTradeoff
            self.enforceProvidedLabels = enforceProvidedLabels
            self.precisionRecallTradeoff = precisionRecallTradeoff
            self.primaryKeyColumnName = primaryKeyColumnName
        }

        public func validate(name: String) throws {
            try self.validate(self.accuracyCostTradeoff, name: "accuracyCostTradeoff", parent: name, max: 1.0)
            try self.validate(self.accuracyCostTradeoff, name: "accuracyCostTradeoff", parent: name, min: 0.0)
            try self.validate(self.precisionRecallTradeoff, name: "precisionRecallTradeoff", parent: name, max: 1.0)
            try self.validate(self.precisionRecallTradeoff, name: "precisionRecallTradeoff", parent: name, min: 0.0)
            try self.validate(self.primaryKeyColumnName, name: "primaryKeyColumnName", parent: name, max: 1024)
            try self.validate(self.primaryKeyColumnName, name: "primaryKeyColumnName", parent: name, min: 1)
            try self.validate(self.primaryKeyColumnName, name: "primaryKeyColumnName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accuracyCostTradeoff = "AccuracyCostTradeoff"
            case enforceProvidedLabels = "EnforceProvidedLabels"
            case precisionRecallTradeoff = "PrecisionRecallTradeoff"
            case primaryKeyColumnName = "PrimaryKeyColumnName"
        }
    }

    public struct FindMatchesTaskRunProperties: AWSDecodableShape {
        /// The job ID for the Find Matches task run.
        public let jobId: String?
        /// The name assigned to the job for the Find Matches task run.
        public let jobName: String?
        /// The job run ID for the Find Matches task run.
        public let jobRunId: String?

        @inlinable
        public init(jobId: String? = nil, jobName: String? = nil, jobRunId: String? = nil) {
            self.jobId = jobId
            self.jobName = jobName
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
        }
    }

    public struct GetBlueprintRequest: AWSEncodableShape {
        /// Specifies whether or not to include the blueprint in the response.
        public let includeBlueprint: Bool?
        /// Specifies whether or not to include the parameter specification.
        public let includeParameterSpec: Bool?
        /// The name of the blueprint.
        public let name: String

        @inlinable
        public init(includeBlueprint: Bool? = nil, includeParameterSpec: Bool? = nil, name: String) {
            self.includeBlueprint = includeBlueprint
            self.includeParameterSpec = includeParameterSpec
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case includeBlueprint = "IncludeBlueprint"
            case includeParameterSpec = "IncludeParameterSpec"
            case name = "Name"
        }
    }

    public struct GetBlueprintResponse: AWSDecodableShape {
        /// Returns a Blueprint object.
        public let blueprint: Blueprint?

        @inlinable
        public init(blueprint: Blueprint? = nil) {
            self.blueprint = blueprint
        }

        private enum CodingKeys: String, CodingKey {
            case blueprint = "Blueprint"
        }
    }

    public struct GetBlueprintRunRequest: AWSEncodableShape {
        /// The name of the blueprint.
        public let blueprintName: String
        /// The run ID for the blueprint run you want to retrieve.
        public let runId: String

        @inlinable
        public init(blueprintName: String, runId: String) {
            self.blueprintName = blueprintName
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, max: 128)
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, min: 1)
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintName = "BlueprintName"
            case runId = "RunId"
        }
    }

    public struct GetBlueprintRunResponse: AWSDecodableShape {
        /// Returns a BlueprintRun object.
        public let blueprintRun: BlueprintRun?

        @inlinable
        public init(blueprintRun: BlueprintRun? = nil) {
            self.blueprintRun = blueprintRun
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintRun = "BlueprintRun"
        }
    }

    public struct GetBlueprintRunsRequest: AWSEncodableShape {
        /// The name of the blueprint.
        public let blueprintName: String
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?

        @inlinable
        public init(blueprintName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.blueprintName = blueprintName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, max: 255)
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, min: 1)
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintName = "BlueprintName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetBlueprintRunsResponse: AWSDecodableShape {
        /// Returns a list of BlueprintRun objects.
        public let blueprintRuns: [BlueprintRun]?
        /// A continuation token, if not all blueprint runs have been returned.
        public let nextToken: String?

        @inlinable
        public init(blueprintRuns: [BlueprintRun]? = nil, nextToken: String? = nil) {
            self.blueprintRuns = blueprintRuns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintRuns = "BlueprintRuns"
            case nextToken = "NextToken"
        }
    }

    public struct GetCatalogImportStatusRequest: AWSEncodableShape {
        /// The ID of the catalog to migrate. Currently, this should be the Amazon Web Services account ID.
        public let catalogId: String?

        @inlinable
        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct GetCatalogImportStatusResponse: AWSDecodableShape {
        /// The status of the specified catalog migration.
        public let importStatus: CatalogImportStatus?

        @inlinable
        public init(importStatus: CatalogImportStatus? = nil) {
            self.importStatus = importStatus
        }

        private enum CodingKeys: String, CodingKey {
            case importStatus = "ImportStatus"
        }
    }

    public struct GetCatalogRequest: AWSEncodableShape {
        /// The ID of the parent catalog in which the catalog resides. If none is provided, the Amazon Web Services Account Number is used by default.
        public let catalogId: String

        @inlinable
        public init(catalogId: String) {
            self.catalogId = catalogId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct GetCatalogResponse: AWSDecodableShape {
        /// A Catalog object. The definition of the specified catalog in the Glue Data Catalog.
        public let catalog: Catalog?

        @inlinable
        public init(catalog: Catalog? = nil) {
            self.catalog = catalog
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
        }
    }

    public struct GetCatalogsRequest: AWSEncodableShape {
        /// Whether to list the default catalog in the account and region in the response. Defaults to false. When true and ParentCatalogId = NULL | Amazon Web Services Account ID, all catalogs and the default catalog are enumerated in the response. When the ParentCatalogId is not equal to null, and this attribute is passed as false or true, an InvalidInputException is thrown.
        public let includeRoot: Bool?
        /// The maximum number of catalogs to return in one response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The ID of the parent catalog in which the catalog resides. If none is provided, the Amazon Web Services Account Number is used by default.
        public let parentCatalogId: String?
        /// Whether to list all catalogs across the catalog hierarchy, starting from the ParentCatalogId. Defaults to false . When true, all catalog objects in the ParentCatalogID hierarchy are enumerated in the response.
        public let recursive: Bool?

        @inlinable
        public init(includeRoot: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, parentCatalogId: String? = nil, recursive: Bool? = nil) {
            self.includeRoot = includeRoot
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.parentCatalogId = parentCatalogId
            self.recursive = recursive
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.parentCatalogId, name: "parentCatalogId", parent: name, max: 255)
            try self.validate(self.parentCatalogId, name: "parentCatalogId", parent: name, min: 1)
            try self.validate(self.parentCatalogId, name: "parentCatalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case includeRoot = "IncludeRoot"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case parentCatalogId = "ParentCatalogId"
            case recursive = "Recursive"
        }
    }

    public struct GetCatalogsResponse: AWSDecodableShape {
        /// An array of Catalog objects. A list of Catalog objects from the specified parent catalog.
        public let catalogList: [Catalog]
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?

        @inlinable
        public init(catalogList: [Catalog], nextToken: String? = nil) {
            self.catalogList = catalogList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case catalogList = "CatalogList"
            case nextToken = "NextToken"
        }
    }

    public struct GetClassifierRequest: AWSEncodableShape {
        /// Name of the classifier to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetClassifierResponse: AWSDecodableShape {
        /// The requested classifier.
        public let classifier: Classifier?

        @inlinable
        public init(classifier: Classifier? = nil) {
            self.classifier = classifier
        }

        private enum CodingKeys: String, CodingKey {
            case classifier = "Classifier"
        }
    }

    public struct GetClassifiersRequest: AWSEncodableShape {
        /// The size of the list to return (optional).
        public let maxResults: Int?
        /// An optional continuation token.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetClassifiersResponse: AWSDecodableShape {
        /// The requested list of classifier objects.
        public let classifiers: [Classifier]?
        /// A continuation token.
        public let nextToken: String?

        @inlinable
        public init(classifiers: [Classifier]? = nil, nextToken: String? = nil) {
            self.classifiers = classifiers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case nextToken = "NextToken"
        }
    }

    public struct GetColumnStatisticsForPartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A list of the column names.
        public let columnNames: [String]
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// A list of partition values identifying the partition.
        public let partitionValues: [String]
        /// The name of the partitions' table.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, columnNames: [String], databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.columnNames = columnNames
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.columnNames.forEach {
                try validate($0, name: "columnNames[]", parent: name, max: 255)
                try validate($0, name: "columnNames[]", parent: name, min: 1)
                try validate($0, name: "columnNames[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.columnNames, name: "columnNames", parent: name, max: 100)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
                try validate($0, name: "partitionValues[]", parent: name, min: 1)
            }
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnNames = "ColumnNames"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct GetColumnStatisticsForPartitionResponse: AWSDecodableShape {
        /// List of ColumnStatistics that failed to be retrieved.
        public let columnStatisticsList: [ColumnStatistics]?
        /// Error occurred during retrieving column statistics data.
        public let errors: [ColumnError]?

        @inlinable
        public init(columnStatisticsList: [ColumnStatistics]? = nil, errors: [ColumnError]? = nil) {
            self.columnStatisticsList = columnStatisticsList
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsList = "ColumnStatisticsList"
            case errors = "Errors"
        }
    }

    public struct GetColumnStatisticsForTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A list of the column names.
        public let columnNames: [String]
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// The name of the partitions' table.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, columnNames: [String], databaseName: String, tableName: String) {
            self.catalogId = catalogId
            self.columnNames = columnNames
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.columnNames.forEach {
                try validate($0, name: "columnNames[]", parent: name, max: 255)
                try validate($0, name: "columnNames[]", parent: name, min: 1)
                try validate($0, name: "columnNames[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.columnNames, name: "columnNames", parent: name, max: 100)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnNames = "ColumnNames"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct GetColumnStatisticsForTableResponse: AWSDecodableShape {
        /// List of ColumnStatistics.
        public let columnStatisticsList: [ColumnStatistics]?
        /// List of ColumnStatistics that failed to be retrieved.
        public let errors: [ColumnError]?

        @inlinable
        public init(columnStatisticsList: [ColumnStatistics]? = nil, errors: [ColumnError]? = nil) {
            self.columnStatisticsList = columnStatisticsList
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsList = "ColumnStatisticsList"
            case errors = "Errors"
        }
    }

    public struct GetColumnStatisticsTaskRunRequest: AWSEncodableShape {
        /// The identifier for the particular column statistics task run.
        public let columnStatisticsTaskRunId: String

        @inlinable
        public init(columnStatisticsTaskRunId: String) {
            self.columnStatisticsTaskRunId = columnStatisticsTaskRunId
        }

        public func validate(name: String) throws {
            try self.validate(self.columnStatisticsTaskRunId, name: "columnStatisticsTaskRunId", parent: name, max: 255)
            try self.validate(self.columnStatisticsTaskRunId, name: "columnStatisticsTaskRunId", parent: name, min: 1)
            try self.validate(self.columnStatisticsTaskRunId, name: "columnStatisticsTaskRunId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsTaskRunId = "ColumnStatisticsTaskRunId"
        }
    }

    public struct GetColumnStatisticsTaskRunResponse: AWSDecodableShape {
        /// A ColumnStatisticsTaskRun object representing the details of the column stats run.
        public let columnStatisticsTaskRun: ColumnStatisticsTaskRun?

        @inlinable
        public init(columnStatisticsTaskRun: ColumnStatisticsTaskRun? = nil) {
            self.columnStatisticsTaskRun = columnStatisticsTaskRun
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsTaskRun = "ColumnStatisticsTaskRun"
        }
    }

    public struct GetColumnStatisticsTaskRunsRequest: AWSEncodableShape {
        /// The name of the database where the table resides.
        public let databaseName: String
        /// The maximum size of the response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The name of the table.
        public let tableName: String

        @inlinable
        public init(databaseName: String, maxResults: Int? = nil, nextToken: String? = nil, tableName: String) {
            self.databaseName = databaseName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tableName = "TableName"
        }
    }

    public struct GetColumnStatisticsTaskRunsResponse: AWSDecodableShape {
        /// A list of column statistics task runs.
        public let columnStatisticsTaskRuns: [ColumnStatisticsTaskRun]?
        /// A continuation token, if not all task runs have yet been returned.
        public let nextToken: String?

        @inlinable
        public init(columnStatisticsTaskRuns: [ColumnStatisticsTaskRun]? = nil, nextToken: String? = nil) {
            self.columnStatisticsTaskRuns = columnStatisticsTaskRuns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsTaskRuns = "ColumnStatisticsTaskRuns"
            case nextToken = "NextToken"
        }
    }

    public struct GetColumnStatisticsTaskSettingsRequest: AWSEncodableShape {
        /// The name of the database where the table resides.
        public let databaseName: String
        /// The name of the table for which to retrieve column statistics.
        public let tableName: String

        @inlinable
        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct GetColumnStatisticsTaskSettingsResponse: AWSDecodableShape {
        /// A ColumnStatisticsTaskSettings object representing the settings for the column statistics task.
        public let columnStatisticsTaskSettings: ColumnStatisticsTaskSettings?

        @inlinable
        public init(columnStatisticsTaskSettings: ColumnStatisticsTaskSettings? = nil) {
            self.columnStatisticsTaskSettings = columnStatisticsTaskSettings
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsTaskSettings = "ColumnStatisticsTaskSettings"
        }
    }

    public struct GetConnectionRequest: AWSEncodableShape {
        /// For connections that may be used in multiple services, specifies returning properties for the specified compute environment.
        public let applyOverrideForComputeEnvironment: ComputeEnvironment?
        /// The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// Allows you to retrieve the connection metadata without returning the password. For instance, the Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the KMS key to decrypt the password, but it does have permission to access the rest of the connection properties.
        public let hidePassword: Bool?
        /// The name of the connection definition to retrieve.
        public let name: String

        @inlinable
        public init(applyOverrideForComputeEnvironment: ComputeEnvironment? = nil, catalogId: String? = nil, hidePassword: Bool? = nil, name: String) {
            self.applyOverrideForComputeEnvironment = applyOverrideForComputeEnvironment
            self.catalogId = catalogId
            self.hidePassword = hidePassword
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case applyOverrideForComputeEnvironment = "ApplyOverrideForComputeEnvironment"
            case catalogId = "CatalogId"
            case hidePassword = "HidePassword"
            case name = "Name"
        }
    }

    public struct GetConnectionResponse: AWSDecodableShape {
        /// The requested connection definition.
        public let connection: Connection?

        @inlinable
        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct GetConnectionsFilter: AWSEncodableShape {
        /// Denotes if the connection was created with schema version 1 or 2.
        public let connectionSchemaVersion: Int?
        /// The type of connections to return. Currently, SFTP is not supported.
        public let connectionType: ConnectionType?
        /// A criteria string that must match the criteria recorded in the connection definition for that connection definition to be returned.
        public let matchCriteria: [String]?

        @inlinable
        public init(connectionSchemaVersion: Int? = nil, connectionType: ConnectionType? = nil, matchCriteria: [String]? = nil) {
            self.connectionSchemaVersion = connectionSchemaVersion
            self.connectionType = connectionType
            self.matchCriteria = matchCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionSchemaVersion, name: "connectionSchemaVersion", parent: name, max: 2)
            try self.validate(self.connectionSchemaVersion, name: "connectionSchemaVersion", parent: name, min: 1)
            try self.matchCriteria?.forEach {
                try validate($0, name: "matchCriteria[]", parent: name, max: 255)
                try validate($0, name: "matchCriteria[]", parent: name, min: 1)
                try validate($0, name: "matchCriteria[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.matchCriteria, name: "matchCriteria", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case connectionSchemaVersion = "ConnectionSchemaVersion"
            case connectionType = "ConnectionType"
            case matchCriteria = "MatchCriteria"
        }
    }

    public struct GetConnectionsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A filter that controls which connections are returned.
        public let filter: GetConnectionsFilter?
        /// Allows you to retrieve the connection metadata without returning the password. For instance, the Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the KMS key to decrypt the password, but it does have permission to access the rest of the connection properties.
        public let hidePassword: Bool?
        /// The maximum number of connections to return in one response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(catalogId: String? = nil, filter: GetConnectionsFilter? = nil, hidePassword: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.catalogId = catalogId
            self.filter = filter
            self.hidePassword = hidePassword
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case filter = "Filter"
            case hidePassword = "HidePassword"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetConnectionsResponse: AWSDecodableShape {
        /// A list of requested connection definitions.
        public let connectionList: [Connection]?
        /// A continuation token, if the list of connections returned does not include the last of the filtered connections.
        public let nextToken: String?

        @inlinable
        public init(connectionList: [Connection]? = nil, nextToken: String? = nil) {
            self.connectionList = connectionList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectionList = "ConnectionList"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlerMetricsRequest: AWSEncodableShape {
        /// A list of the names of crawlers about which to retrieve metrics.
        public let crawlerNameList: [String]?
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(crawlerNameList: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.crawlerNameList = crawlerNameList
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.crawlerNameList?.forEach {
                try validate($0, name: "crawlerNameList[]", parent: name, max: 255)
                try validate($0, name: "crawlerNameList[]", parent: name, min: 1)
                try validate($0, name: "crawlerNameList[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.crawlerNameList, name: "crawlerNameList", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerNameList = "CrawlerNameList"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlerMetricsResponse: AWSDecodableShape {
        /// A list of metrics for the specified crawler.
        public let crawlerMetricsList: [CrawlerMetrics]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        @inlinable
        public init(crawlerMetricsList: [CrawlerMetrics]? = nil, nextToken: String? = nil) {
            self.crawlerMetricsList = crawlerMetricsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerMetricsList = "CrawlerMetricsList"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlerRequest: AWSEncodableShape {
        /// The name of the crawler to retrieve metadata for.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetCrawlerResponse: AWSDecodableShape {
        /// The metadata for the specified crawler.
        public let crawler: Crawler?

        @inlinable
        public init(crawler: Crawler? = nil) {
            self.crawler = crawler
        }

        private enum CodingKeys: String, CodingKey {
            case crawler = "Crawler"
        }
    }

    public struct GetCrawlersRequest: AWSEncodableShape {
        /// The number of crawlers to return on each call.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlersResponse: AWSDecodableShape {
        /// A list of crawler metadata.
        public let crawlers: [Crawler]?
        /// A continuation token, if the returned list has not reached the end of those defined in this customer account.
        public let nextToken: String?

        @inlinable
        public init(crawlers: [Crawler]? = nil, nextToken: String? = nil) {
            self.crawlers = crawlers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case crawlers = "Crawlers"
            case nextToken = "NextToken"
        }
    }

    public struct GetCustomEntityTypeRequest: AWSEncodableShape {
        /// The name of the custom pattern that you want to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetCustomEntityTypeResponse: AWSDecodableShape {
        /// A list of context words if specified when you created the custom pattern. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data.
        public let contextWords: [String]?
        /// The name of the custom pattern that you retrieved.
        public let name: String?
        /// A regular expression string that is used for detecting sensitive data in a custom pattern.
        public let regexString: String?

        @inlinable
        public init(contextWords: [String]? = nil, name: String? = nil, regexString: String? = nil) {
            self.contextWords = contextWords
            self.name = name
            self.regexString = regexString
        }

        private enum CodingKeys: String, CodingKey {
            case contextWords = "ContextWords"
            case name = "Name"
            case regexString = "RegexString"
        }
    }

    public struct GetDataCatalogEncryptionSettingsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog to retrieve the security configuration for. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?

        @inlinable
        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct GetDataCatalogEncryptionSettingsResponse: AWSDecodableShape {
        /// The requested security configuration.
        public let dataCatalogEncryptionSettings: DataCatalogEncryptionSettings?

        @inlinable
        public init(dataCatalogEncryptionSettings: DataCatalogEncryptionSettings? = nil) {
            self.dataCatalogEncryptionSettings = dataCatalogEncryptionSettings
        }

        private enum CodingKeys: String, CodingKey {
            case dataCatalogEncryptionSettings = "DataCatalogEncryptionSettings"
        }
    }

    public struct GetDataQualityModelRequest: AWSEncodableShape {
        /// The Profile ID.
        public let profileId: String
        /// The Statistic ID.
        public let statisticId: String?

        @inlinable
        public init(profileId: String, statisticId: String? = nil) {
            self.profileId = profileId
            self.statisticId = statisticId
        }

        public func validate(name: String) throws {
            try self.validate(self.profileId, name: "profileId", parent: name, max: 255)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.statisticId, name: "statisticId", parent: name, max: 255)
            try self.validate(self.statisticId, name: "statisticId", parent: name, min: 1)
            try self.validate(self.statisticId, name: "statisticId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case profileId = "ProfileId"
            case statisticId = "StatisticId"
        }
    }

    public struct GetDataQualityModelResponse: AWSDecodableShape {
        /// The timestamp when the data quality model training completed.
        public let completedOn: Date?
        /// The training failure reason.
        public let failureReason: String?
        /// The timestamp when the data quality model training started.
        public let startedOn: Date?
        /// The training status of the data quality model.
        public let status: DataQualityModelStatus?

        @inlinable
        public init(completedOn: Date? = nil, failureReason: String? = nil, startedOn: Date? = nil, status: DataQualityModelStatus? = nil) {
            self.completedOn = completedOn
            self.failureReason = failureReason
            self.startedOn = startedOn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case failureReason = "FailureReason"
            case startedOn = "StartedOn"
            case status = "Status"
        }
    }

    public struct GetDataQualityModelResultRequest: AWSEncodableShape {
        /// The Profile ID.
        public let profileId: String
        /// The Statistic ID.
        public let statisticId: String

        @inlinable
        public init(profileId: String, statisticId: String) {
            self.profileId = profileId
            self.statisticId = statisticId
        }

        public func validate(name: String) throws {
            try self.validate(self.profileId, name: "profileId", parent: name, max: 255)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.statisticId, name: "statisticId", parent: name, max: 255)
            try self.validate(self.statisticId, name: "statisticId", parent: name, min: 1)
            try self.validate(self.statisticId, name: "statisticId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case profileId = "ProfileId"
            case statisticId = "StatisticId"
        }
    }

    public struct GetDataQualityModelResultResponse: AWSDecodableShape {
        /// The timestamp when the data quality model training completed.
        public let completedOn: Date?
        /// A list of StatisticModelResult
        public let model: [StatisticModelResult]?

        @inlinable
        public init(completedOn: Date? = nil, model: [StatisticModelResult]? = nil) {
            self.completedOn = completedOn
            self.model = model
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case model = "Model"
        }
    }

    public struct GetDataQualityResultRequest: AWSEncodableShape {
        /// A unique result ID for the data quality result.
        public let resultId: String

        @inlinable
        public init(resultId: String) {
            self.resultId = resultId
        }

        public func validate(name: String) throws {
            try self.validate(self.resultId, name: "resultId", parent: name, max: 255)
            try self.validate(self.resultId, name: "resultId", parent: name, min: 1)
            try self.validate(self.resultId, name: "resultId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case resultId = "ResultId"
        }
    }

    public struct GetDataQualityResultResponse: AWSDecodableShape {
        /// A list of DataQualityAnalyzerResult objects representing the results for each analyzer.
        public let analyzerResults: [DataQualityAnalyzerResult]?
        /// The date and time when the run for this data quality result was completed.
        public let completedOn: Date?
        /// The table associated with the data quality result, if any.
        public let dataSource: DataSource?
        /// In the context of a job in Glue Studio, each node in the canvas is typically assigned some sort of name and data quality nodes will have names. In the case of multiple nodes, the evaluationContext can differentiate the nodes.
        public let evaluationContext: String?
        /// The job name associated with the data quality result, if any.
        public let jobName: String?
        /// The job run ID associated with the data quality result, if any.
        public let jobRunId: String?
        /// A list of DataQualityObservation objects representing the observations generated after evaluating the rules and analyzers.
        public let observations: [DataQualityObservation]?
        /// The Profile ID for the data quality result.
        public let profileId: String?
        /// A unique result ID for the data quality result.
        public let resultId: String?
        /// A list of DataQualityRuleResult objects representing the results for each rule.
        public let ruleResults: [DataQualityRuleResult]?
        /// The unique run ID associated with the ruleset evaluation.
        public let rulesetEvaluationRunId: String?
        /// The name of the ruleset associated with the data quality result.
        public let rulesetName: String?
        /// An aggregate data quality score. Represents the ratio of rules that passed to the total number of rules.
        public let score: Double?
        /// The date and time when the run for this data quality result started.
        public let startedOn: Date?

        @inlinable
        public init(analyzerResults: [DataQualityAnalyzerResult]? = nil, completedOn: Date? = nil, dataSource: DataSource? = nil, evaluationContext: String? = nil, jobName: String? = nil, jobRunId: String? = nil, observations: [DataQualityObservation]? = nil, profileId: String? = nil, resultId: String? = nil, ruleResults: [DataQualityRuleResult]? = nil, rulesetEvaluationRunId: String? = nil, rulesetName: String? = nil, score: Double? = nil, startedOn: Date? = nil) {
            self.analyzerResults = analyzerResults
            self.completedOn = completedOn
            self.dataSource = dataSource
            self.evaluationContext = evaluationContext
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.observations = observations
            self.profileId = profileId
            self.resultId = resultId
            self.ruleResults = ruleResults
            self.rulesetEvaluationRunId = rulesetEvaluationRunId
            self.rulesetName = rulesetName
            self.score = score
            self.startedOn = startedOn
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerResults = "AnalyzerResults"
            case completedOn = "CompletedOn"
            case dataSource = "DataSource"
            case evaluationContext = "EvaluationContext"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
            case observations = "Observations"
            case profileId = "ProfileId"
            case resultId = "ResultId"
            case ruleResults = "RuleResults"
            case rulesetEvaluationRunId = "RulesetEvaluationRunId"
            case rulesetName = "RulesetName"
            case score = "Score"
            case startedOn = "StartedOn"
        }
    }

    public struct GetDataQualityRuleRecommendationRunRequest: AWSEncodableShape {
        /// The unique run identifier associated with this run.
        public let runId: String

        @inlinable
        public init(runId: String) {
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct GetDataQualityRuleRecommendationRunResponse: AWSDecodableShape {
        /// The date and time when this run was completed.
        public let completedOn: Date?
        /// The name of the ruleset that was created by the run.
        public let createdRulesetName: String?
        /// The name of the security configuration created with the data quality encryption option.
        public let dataQualitySecurityConfiguration: String?
        /// The data source (an Glue table) associated with this run.
        public let dataSource: DataSource?
        /// The error strings that are associated with the run.
        public let errorString: String?
        /// The amount of time (in seconds) that the run consumed resources.
        public let executionTime: Int?
        /// A timestamp. The last point in time when this data quality rule recommendation run was modified.
        public let lastModifiedOn: Date?
        /// The number of G.1X workers to be used in the run. The default is 5.
        public let numberOfWorkers: Int?
        /// When a start rule recommendation run completes, it creates a recommended ruleset (a set of rules). This member has those rules in Data Quality Definition Language (DQDL) format.
        public let recommendedRuleset: String?
        /// An IAM role supplied to encrypt the results of the run.
        public let role: String?
        /// The unique run identifier associated with this run.
        public let runId: String?
        /// The date and time when this run started.
        public let startedOn: Date?
        /// The status for this run.
        public let status: TaskStatusType?
        /// The timeout for a run in minutes. This is the maximum time that a run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?

        @inlinable
        public init(completedOn: Date? = nil, createdRulesetName: String? = nil, dataQualitySecurityConfiguration: String? = nil, dataSource: DataSource? = nil, errorString: String? = nil, executionTime: Int? = nil, lastModifiedOn: Date? = nil, numberOfWorkers: Int? = nil, recommendedRuleset: String? = nil, role: String? = nil, runId: String? = nil, startedOn: Date? = nil, status: TaskStatusType? = nil, timeout: Int? = nil) {
            self.completedOn = completedOn
            self.createdRulesetName = createdRulesetName
            self.dataQualitySecurityConfiguration = dataQualitySecurityConfiguration
            self.dataSource = dataSource
            self.errorString = errorString
            self.executionTime = executionTime
            self.lastModifiedOn = lastModifiedOn
            self.numberOfWorkers = numberOfWorkers
            self.recommendedRuleset = recommendedRuleset
            self.role = role
            self.runId = runId
            self.startedOn = startedOn
            self.status = status
            self.timeout = timeout
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case createdRulesetName = "CreatedRulesetName"
            case dataQualitySecurityConfiguration = "DataQualitySecurityConfiguration"
            case dataSource = "DataSource"
            case errorString = "ErrorString"
            case executionTime = "ExecutionTime"
            case lastModifiedOn = "LastModifiedOn"
            case numberOfWorkers = "NumberOfWorkers"
            case recommendedRuleset = "RecommendedRuleset"
            case role = "Role"
            case runId = "RunId"
            case startedOn = "StartedOn"
            case status = "Status"
            case timeout = "Timeout"
        }
    }

    public struct GetDataQualityRulesetEvaluationRunRequest: AWSEncodableShape {
        /// The unique run identifier associated with this run.
        public let runId: String

        @inlinable
        public init(runId: String) {
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct GetDataQualityRulesetEvaluationRunResponse: AWSDecodableShape {
        /// A map of reference strings to additional data sources you can specify for an evaluation run.
        public let additionalDataSources: [String: DataSource]?
        /// Additional run options you can specify for an evaluation run.
        public let additionalRunOptions: DataQualityEvaluationRunAdditionalRunOptions?
        /// The date and time when this run was completed.
        public let completedOn: Date?
        /// The data source (an Glue table) associated with this evaluation run.
        public let dataSource: DataSource?
        /// The error strings that are associated with the run.
        public let errorString: String?
        /// The amount of time (in seconds) that the run consumed resources.
        public let executionTime: Int?
        /// A timestamp. The last point in time when this data quality rule recommendation run was modified.
        public let lastModifiedOn: Date?
        /// The number of G.1X workers to be used in the run. The default is 5.
        public let numberOfWorkers: Int?
        /// A list of result IDs for the data quality results for the run.
        public let resultIds: [String]?
        /// An IAM role supplied to encrypt the results of the run.
        public let role: String?
        /// A list of ruleset names for the run. Currently, this parameter takes only one Ruleset name.
        public let rulesetNames: [String]?
        /// The unique run identifier associated with this run.
        public let runId: String?
        /// The date and time when this run started.
        public let startedOn: Date?
        /// The status for this run.
        public let status: TaskStatusType?
        /// The timeout for a run in minutes. This is the maximum time that a run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?

        @inlinable
        public init(additionalDataSources: [String: DataSource]? = nil, additionalRunOptions: DataQualityEvaluationRunAdditionalRunOptions? = nil, completedOn: Date? = nil, dataSource: DataSource? = nil, errorString: String? = nil, executionTime: Int? = nil, lastModifiedOn: Date? = nil, numberOfWorkers: Int? = nil, resultIds: [String]? = nil, role: String? = nil, rulesetNames: [String]? = nil, runId: String? = nil, startedOn: Date? = nil, status: TaskStatusType? = nil, timeout: Int? = nil) {
            self.additionalDataSources = additionalDataSources
            self.additionalRunOptions = additionalRunOptions
            self.completedOn = completedOn
            self.dataSource = dataSource
            self.errorString = errorString
            self.executionTime = executionTime
            self.lastModifiedOn = lastModifiedOn
            self.numberOfWorkers = numberOfWorkers
            self.resultIds = resultIds
            self.role = role
            self.rulesetNames = rulesetNames
            self.runId = runId
            self.startedOn = startedOn
            self.status = status
            self.timeout = timeout
        }

        private enum CodingKeys: String, CodingKey {
            case additionalDataSources = "AdditionalDataSources"
            case additionalRunOptions = "AdditionalRunOptions"
            case completedOn = "CompletedOn"
            case dataSource = "DataSource"
            case errorString = "ErrorString"
            case executionTime = "ExecutionTime"
            case lastModifiedOn = "LastModifiedOn"
            case numberOfWorkers = "NumberOfWorkers"
            case resultIds = "ResultIds"
            case role = "Role"
            case rulesetNames = "RulesetNames"
            case runId = "RunId"
            case startedOn = "StartedOn"
            case status = "Status"
            case timeout = "Timeout"
        }
    }

    public struct GetDataQualityRulesetRequest: AWSEncodableShape {
        /// The name of the ruleset.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetDataQualityRulesetResponse: AWSDecodableShape {
        /// A timestamp. The time and date that this data quality ruleset was created.
        public let createdOn: Date?
        /// The name of the security configuration created with the data quality encryption option.
        public let dataQualitySecurityConfiguration: String?
        /// A description of the ruleset.
        public let description: String?
        /// A timestamp. The last point in time when this data quality ruleset was modified.
        public let lastModifiedOn: Date?
        /// The name of the ruleset.
        public let name: String?
        /// When a ruleset was created from a recommendation run, this run ID is generated to link the two together.
        public let recommendationRunId: String?
        /// A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer guide.
        public let ruleset: String?
        /// The name and database name of the target table.
        public let targetTable: DataQualityTargetTable?

        @inlinable
        public init(createdOn: Date? = nil, dataQualitySecurityConfiguration: String? = nil, description: String? = nil, lastModifiedOn: Date? = nil, name: String? = nil, recommendationRunId: String? = nil, ruleset: String? = nil, targetTable: DataQualityTargetTable? = nil) {
            self.createdOn = createdOn
            self.dataQualitySecurityConfiguration = dataQualitySecurityConfiguration
            self.description = description
            self.lastModifiedOn = lastModifiedOn
            self.name = name
            self.recommendationRunId = recommendationRunId
            self.ruleset = ruleset
            self.targetTable = targetTable
        }

        private enum CodingKeys: String, CodingKey {
            case createdOn = "CreatedOn"
            case dataQualitySecurityConfiguration = "DataQualitySecurityConfiguration"
            case description = "Description"
            case lastModifiedOn = "LastModifiedOn"
            case name = "Name"
            case recommendationRunId = "RecommendationRunId"
            case ruleset = "Ruleset"
            case targetTable = "TargetTable"
        }
    }

    public struct GetDatabaseRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the database to retrieve. For Hive compatibility, this  should be all lowercase.
        public let name: String

        @inlinable
        public init(catalogId: String? = nil, name: String) {
            self.catalogId = catalogId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
        }
    }

    public struct GetDatabaseResponse: AWSDecodableShape {
        /// The definition of the specified database in the Data Catalog.
        public let database: Database?

        @inlinable
        public init(database: Database? = nil) {
            self.database = database
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
        }
    }

    public struct GetDatabasesRequest: AWSEncodableShape {
        /// Specifies the database fields returned by the GetDatabases call. This parameter doesnt accept an empty list. The request must include the NAME.
        public let attributesToGet: [DatabaseAttributes]?
        /// The ID of the Data Catalog from which to retrieve Databases. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The maximum number of databases to return in one response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// Allows you to specify that you want to list the databases shared with your account. The allowable values are FEDERATED, FOREIGN or ALL.    If set to FEDERATED, will list the federated databases (referencing an external entity) shared with your account.   If set to FOREIGN, will list the databases shared with your account.    If set to ALL, will list the databases shared with your account, as well as the databases in yor local account.
        public let resourceShareType: ResourceShareType?

        @inlinable
        public init(attributesToGet: [DatabaseAttributes]? = nil, catalogId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceShareType: ResourceShareType? = nil) {
            self.attributesToGet = attributesToGet
            self.catalogId = catalogId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceShareType = resourceShareType
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributesToGet = "AttributesToGet"
            case catalogId = "CatalogId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceShareType = "ResourceShareType"
        }
    }

    public struct GetDatabasesResponse: AWSDecodableShape {
        /// A list of Database objects from the specified catalog.
        public let databaseList: [Database]
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?

        @inlinable
        public init(databaseList: [Database], nextToken: String? = nil) {
            self.databaseList = databaseList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case databaseList = "DatabaseList"
            case nextToken = "NextToken"
        }
    }

    public struct GetDataflowGraphRequest: AWSEncodableShape {
        /// The Python script to transform.
        public let pythonScript: String?

        @inlinable
        public init(pythonScript: String? = nil) {
            self.pythonScript = pythonScript
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
        }
    }

    public struct GetDataflowGraphResponse: AWSDecodableShape {
        /// A list of the edges in the resulting DAG.
        public let dagEdges: [CodeGenEdge]?
        /// A list of the nodes in the resulting DAG.
        public let dagNodes: [CodeGenNode]?

        @inlinable
        public init(dagEdges: [CodeGenEdge]? = nil, dagNodes: [CodeGenNode]? = nil) {
            self.dagEdges = dagEdges
            self.dagNodes = dagNodes
        }

        private enum CodingKeys: String, CodingKey {
            case dagEdges = "DagEdges"
            case dagNodes = "DagNodes"
        }
    }

    public struct GetDevEndpointRequest: AWSEncodableShape {
        /// Name of the DevEndpoint to retrieve information for.
        public let endpointName: String

        @inlinable
        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct GetDevEndpointResponse: AWSDecodableShape {
        /// A DevEndpoint definition.
        public let devEndpoint: DevEndpoint?

        @inlinable
        public init(devEndpoint: DevEndpoint? = nil) {
            self.devEndpoint = devEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpoint = "DevEndpoint"
        }
    }

    public struct GetDevEndpointsRequest: AWSEncodableShape {
        /// The maximum size of information to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetDevEndpointsResponse: AWSDecodableShape {
        /// A list of DevEndpoint definitions.
        public let devEndpoints: [DevEndpoint]?
        /// A continuation token, if not all DevEndpoint definitions have yet been returned.
        public let nextToken: String?

        @inlinable
        public init(devEndpoints: [DevEndpoint]? = nil, nextToken: String? = nil) {
            self.devEndpoints = devEndpoints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpoints = "DevEndpoints"
            case nextToken = "NextToken"
        }
    }

    public struct GetEntityRecordsRequest: AWSEncodableShape {
        /// The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon Web Services Account ID is the catalog ID.
        public let catalogId: String?
        /// The name of the connection that contains the connection type credentials.
        public let connectionName: String?
        /// Connector options that are required to query the data.
        public let connectionOptions: [String: String]?
        /// The API version of the SaaS connector.
        public let dataStoreApiVersion: String?
        /// Name of the entity that we want to query the preview data from the given connection type.
        public let entityName: String
        /// A filter predicate that you can apply in the query request.
        public let filterPredicate: String?
        /// Limits the number of records fetched with the request.
        public let limit: Int64
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?
        /// A parameter that orders the response preview data.
        public let orderBy: String?
        ///  List of fields that we want to fetch as part of preview data.
        public let selectedFields: [String]?

        @inlinable
        public init(catalogId: String? = nil, connectionName: String? = nil, connectionOptions: [String: String]? = nil, dataStoreApiVersion: String? = nil, entityName: String, filterPredicate: String? = nil, limit: Int64, nextToken: String? = nil, orderBy: String? = nil, selectedFields: [String]? = nil) {
            self.catalogId = catalogId
            self.connectionName = connectionName
            self.connectionOptions = connectionOptions
            self.dataStoreApiVersion = dataStoreApiVersion
            self.entityName = entityName
            self.filterPredicate = filterPredicate
            self.limit = limit
            self.nextToken = nextToken
            self.orderBy = orderBy
            self.selectedFields = selectedFields
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 255)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.connectionOptions?.forEach {
                try validate($0.key, name: "connectionOptions.key", parent: name, max: 256)
                try validate($0.key, name: "connectionOptions.key", parent: name, min: 1)
                try validate($0.key, name: "connectionOptions.key", parent: name, pattern: "^[\\w]*$")
                try validate($0.value, name: "connectionOptions[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "connectionOptions[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "connectionOptions[\"\($0.key)\"]", parent: name, pattern: "^[\\S]*$")
            }
            try self.validate(self.connectionOptions, name: "connectionOptions", parent: name, max: 100)
            try self.validate(self.dataStoreApiVersion, name: "dataStoreApiVersion", parent: name, max: 256)
            try self.validate(self.dataStoreApiVersion, name: "dataStoreApiVersion", parent: name, min: 1)
            try self.validate(self.dataStoreApiVersion, name: "dataStoreApiVersion", parent: name, pattern: "^[a-zA-Z0-9.-]*$")
            try self.validate(self.filterPredicate, name: "filterPredicate", parent: name, max: 100000)
            try self.validate(self.filterPredicate, name: "filterPredicate", parent: name, min: 1)
            try self.validate(self.limit, name: "limit", parent: name, max: 1000)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[-a-zA-Z0-9+=/:_]*$")
            try self.validate(self.selectedFields, name: "selectedFields", parent: name, max: 1000)
            try self.validate(self.selectedFields, name: "selectedFields", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionName = "ConnectionName"
            case connectionOptions = "ConnectionOptions"
            case dataStoreApiVersion = "DataStoreApiVersion"
            case entityName = "EntityName"
            case filterPredicate = "FilterPredicate"
            case limit = "Limit"
            case nextToken = "NextToken"
            case orderBy = "OrderBy"
            case selectedFields = "SelectedFields"
        }
    }

    public struct GetEntityRecordsResponse: AWSDecodableShape {
        /// A continuation token, present if the current segment is not the last.
        public let nextToken: String?
        /// A list of the requested objects.
        public let records: [AWSDocument]?

        @inlinable
        public init(nextToken: String? = nil, records: [AWSDocument]? = nil) {
            self.nextToken = nextToken
            self.records = records
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case records = "Records"
        }
    }

    public struct GetIntegrationResourcePropertyRequest: AWSEncodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct GetIntegrationResourcePropertyResponse: AWSDecodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String?
        /// The resource properties associated with the integration source.
        public let sourceProcessingProperties: SourceProcessingProperties?
        /// The resource properties associated with the integration target.
        public let targetProcessingProperties: TargetProcessingProperties?

        @inlinable
        public init(resourceArn: String? = nil, sourceProcessingProperties: SourceProcessingProperties? = nil, targetProcessingProperties: TargetProcessingProperties? = nil) {
            self.resourceArn = resourceArn
            self.sourceProcessingProperties = sourceProcessingProperties
            self.targetProcessingProperties = targetProcessingProperties
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case sourceProcessingProperties = "SourceProcessingProperties"
            case targetProcessingProperties = "TargetProcessingProperties"
        }
    }

    public struct GetIntegrationTablePropertiesRequest: AWSEncodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String
        /// The name of the table to be replicated.
        public let tableName: String

        @inlinable
        public init(resourceArn: String, tableName: String) {
            self.resourceArn = resourceArn
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 128)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tableName = "TableName"
        }
    }

    public struct GetIntegrationTablePropertiesResponse: AWSDecodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String?
        /// A structure for the source table configuration.
        public let sourceTableConfig: SourceTableConfig?
        /// The name of the table to be replicated.
        public let tableName: String?
        /// A structure for the target table configuration.
        public let targetTableConfig: TargetTableConfig?

        @inlinable
        public init(resourceArn: String? = nil, sourceTableConfig: SourceTableConfig? = nil, tableName: String? = nil, targetTableConfig: TargetTableConfig? = nil) {
            self.resourceArn = resourceArn
            self.sourceTableConfig = sourceTableConfig
            self.tableName = tableName
            self.targetTableConfig = targetTableConfig
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case sourceTableConfig = "SourceTableConfig"
            case tableName = "TableName"
            case targetTableConfig = "TargetTableConfig"
        }
    }

    public struct GetJobBookmarkRequest: AWSEncodableShape {
        /// The name of the job in question.
        public let jobName: String
        /// The unique run identifier associated with this job run.
        public let runId: String?

        @inlinable
        public init(jobName: String, runId: String? = nil) {
            self.jobName = jobName
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case runId = "RunId"
        }
    }

    public struct GetJobBookmarkResponse: AWSDecodableShape {
        /// A structure that defines a point that a job can resume processing.
        public let jobBookmarkEntry: JobBookmarkEntry?

        @inlinable
        public init(jobBookmarkEntry: JobBookmarkEntry? = nil) {
            self.jobBookmarkEntry = jobBookmarkEntry
        }

        private enum CodingKeys: String, CodingKey {
            case jobBookmarkEntry = "JobBookmarkEntry"
        }
    }

    public struct GetJobRequest: AWSEncodableShape {
        /// The name of the job definition to retrieve.
        public let jobName: String

        @inlinable
        public init(jobName: String) {
            self.jobName = jobName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct GetJobResponse: AWSDecodableShape {
        /// The requested job definition.
        public let job: Job?

        @inlinable
        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "Job"
        }
    }

    public struct GetJobRunRequest: AWSEncodableShape {
        /// Name of the job definition being run.
        public let jobName: String
        /// True if a list of predecessor runs should be returned.
        public let predecessorsIncluded: Bool?
        /// The ID of the job run.
        public let runId: String

        @inlinable
        public init(jobName: String, predecessorsIncluded: Bool? = nil, runId: String) {
            self.jobName = jobName
            self.predecessorsIncluded = predecessorsIncluded
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case predecessorsIncluded = "PredecessorsIncluded"
            case runId = "RunId"
        }
    }

    public struct GetJobRunResponse: AWSDecodableShape {
        /// The requested job-run metadata.
        public let jobRun: JobRun?

        @inlinable
        public init(jobRun: JobRun? = nil) {
            self.jobRun = jobRun
        }

        private enum CodingKeys: String, CodingKey {
            case jobRun = "JobRun"
        }
    }

    public struct GetJobRunsRequest: AWSEncodableShape {
        /// The name of the job definition for which to retrieve all job runs.
        public let jobName: String
        /// The maximum size of the response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(jobName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobName = jobName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobRunsResponse: AWSDecodableShape {
        /// A list of job-run metadata objects.
        public let jobRuns: [JobRun]?
        /// A continuation token, if not all requested job runs have been returned.
        public let nextToken: String?

        @inlinable
        public init(jobRuns: [JobRun]? = nil, nextToken: String? = nil) {
            self.jobRuns = jobRuns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobRuns = "JobRuns"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobsRequest: AWSEncodableShape {
        /// The maximum size of the response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobsResponse: AWSDecodableShape {
        /// A list of job definitions.
        public let jobs: [Job]?
        /// A continuation token, if not all job definitions have yet been returned.
        public let nextToken: String?

        @inlinable
        public init(jobs: [Job]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct GetMLTaskRunRequest: AWSEncodableShape {
        /// The unique identifier of the task run.
        public let taskRunId: String
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        @inlinable
        public init(taskRunId: String, transformId: String) {
            self.taskRunId = taskRunId
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, max: 255)
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, min: 1)
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
            case transformId = "TransformId"
        }
    }

    public struct GetMLTaskRunResponse: AWSDecodableShape {
        /// The date and time when this task run was completed.
        public let completedOn: Date?
        /// The error strings that are associated with the task run.
        public let errorString: String?
        /// The amount of time (in seconds) that the task run consumed resources.
        public let executionTime: Int?
        /// The date and time when this task run was last modified.
        public let lastModifiedOn: Date?
        /// The names of the log groups that are associated with the task run.
        public let logGroupName: String?
        /// The list of properties that are associated with the task run.
        public let properties: TaskRunProperties?
        /// The date and time when this task run started.
        public let startedOn: Date?
        /// The status for this task run.
        public let status: TaskStatusType?
        /// The unique run identifier associated with this run.
        public let taskRunId: String?
        /// The unique identifier of the task run.
        public let transformId: String?

        @inlinable
        public init(completedOn: Date? = nil, errorString: String? = nil, executionTime: Int? = nil, lastModifiedOn: Date? = nil, logGroupName: String? = nil, properties: TaskRunProperties? = nil, startedOn: Date? = nil, status: TaskStatusType? = nil, taskRunId: String? = nil, transformId: String? = nil) {
            self.completedOn = completedOn
            self.errorString = errorString
            self.executionTime = executionTime
            self.lastModifiedOn = lastModifiedOn
            self.logGroupName = logGroupName
            self.properties = properties
            self.startedOn = startedOn
            self.status = status
            self.taskRunId = taskRunId
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case errorString = "ErrorString"
            case executionTime = "ExecutionTime"
            case lastModifiedOn = "LastModifiedOn"
            case logGroupName = "LogGroupName"
            case properties = "Properties"
            case startedOn = "StartedOn"
            case status = "Status"
            case taskRunId = "TaskRunId"
            case transformId = "TransformId"
        }
    }

    public struct GetMLTaskRunsRequest: AWSEncodableShape {
        /// The filter criteria, in the TaskRunFilterCriteria structure, for the task run.
        public let filter: TaskRunFilterCriteria?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A token for pagination of the results. The default is empty.
        public let nextToken: String?
        /// The sorting criteria, in the TaskRunSortCriteria structure, for the task run.
        public let sort: TaskRunSortCriteria?
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        @inlinable
        public init(filter: TaskRunFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: TaskRunSortCriteria? = nil, transformId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sort = "Sort"
            case transformId = "TransformId"
        }
    }

    public struct GetMLTaskRunsResponse: AWSDecodableShape {
        /// A pagination token, if more results are available.
        public let nextToken: String?
        /// A list of task runs that are associated with the transform.
        public let taskRuns: [TaskRun]?

        @inlinable
        public init(nextToken: String? = nil, taskRuns: [TaskRun]? = nil) {
            self.nextToken = nextToken
            self.taskRuns = taskRuns
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case taskRuns = "TaskRuns"
        }
    }

    public struct GetMLTransformRequest: AWSEncodableShape {
        /// The unique identifier of the transform, generated at the time that the transform was created.
        public let transformId: String

        @inlinable
        public init(transformId: String) {
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct GetMLTransformResponse: AWSDecodableShape {
        /// The date and time when the transform was created.
        public let createdOn: Date?
        /// A description of the transform.
        public let description: String?
        /// The latest evaluation metrics.
        public let evaluationMetrics: EvaluationMetrics?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see Glue Versions in the developer guide.
        public let glueVersion: String?
        /// A list of Glue table definitions used by the transform.
        public let inputRecordTables: [GlueTable]?
        /// The number of labels available for this transform.
        public let labelCount: Int?
        /// The date and time when the transform was last modified.
        public let lastModifiedOn: Date?
        /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.  When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
        public let maxCapacity: Double?
        /// The maximum number of times to retry a task for this transform after a task run fails.
        public let maxRetries: Int?
        /// The unique name given to the transform when it was created.
        public let name: String?
        /// The number of workers of a defined workerType that are allocated when this task runs.
        public let numberOfWorkers: Int?
        /// The configuration parameters that are specific to the algorithm used.
        public let parameters: TransformParameters?
        /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.
        public let role: String?
        /// The Map object that represents the schema that this transform accepts. Has an upper bound of 100 columns.
        public let schema: [SchemaColumn]?
        /// The last known status of the transform (to indicate whether it can be used or not). One of "NOT_READY", "READY", or "DELETING".
        public let status: TransformStatusType?
        /// The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?
        /// The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.
        public let transformEncryption: TransformEncryption?
        /// The unique identifier of the transform, generated at the time that the transform was created.
        public let transformId: String?
        /// The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
        public let workerType: WorkerType?

        @inlinable
        public init(createdOn: Date? = nil, description: String? = nil, evaluationMetrics: EvaluationMetrics? = nil, glueVersion: String? = nil, inputRecordTables: [GlueTable]? = nil, labelCount: Int? = nil, lastModifiedOn: Date? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String? = nil, numberOfWorkers: Int? = nil, parameters: TransformParameters? = nil, role: String? = nil, schema: [SchemaColumn]? = nil, status: TransformStatusType? = nil, timeout: Int? = nil, transformEncryption: TransformEncryption? = nil, transformId: String? = nil, workerType: WorkerType? = nil) {
            self.createdOn = createdOn
            self.description = description
            self.evaluationMetrics = evaluationMetrics
            self.glueVersion = glueVersion
            self.inputRecordTables = inputRecordTables
            self.labelCount = labelCount
            self.lastModifiedOn = lastModifiedOn
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.numberOfWorkers = numberOfWorkers
            self.parameters = parameters
            self.role = role
            self.schema = schema
            self.status = status
            self.timeout = timeout
            self.transformEncryption = transformEncryption
            self.transformId = transformId
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case createdOn = "CreatedOn"
            case description = "Description"
            case evaluationMetrics = "EvaluationMetrics"
            case glueVersion = "GlueVersion"
            case inputRecordTables = "InputRecordTables"
            case labelCount = "LabelCount"
            case lastModifiedOn = "LastModifiedOn"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case numberOfWorkers = "NumberOfWorkers"
            case parameters = "Parameters"
            case role = "Role"
            case schema = "Schema"
            case status = "Status"
            case timeout = "Timeout"
            case transformEncryption = "TransformEncryption"
            case transformId = "TransformId"
            case workerType = "WorkerType"
        }
    }

    public struct GetMLTransformsRequest: AWSEncodableShape {
        /// The filter transformation criteria.
        public let filter: TransformFilterCriteria?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A paginated token to offset the results.
        public let nextToken: String?
        /// The sorting criteria.
        public let sort: TransformSortCriteria?

        @inlinable
        public init(filter: TransformFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: TransformSortCriteria? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sort = "Sort"
        }
    }

    public struct GetMLTransformsResponse: AWSDecodableShape {
        /// A pagination token, if more results are available.
        public let nextToken: String?
        /// A list of machine learning transforms.
        public let transforms: [MLTransform]

        @inlinable
        public init(nextToken: String? = nil, transforms: [MLTransform]) {
            self.nextToken = nextToken
            self.transforms = transforms
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case transforms = "Transforms"
        }
    }

    public struct GetMappingRequest: AWSEncodableShape {
        /// Parameters for the mapping.
        public let location: Location?
        /// A list of target tables.
        public let sinks: [CatalogEntry]?
        /// Specifies the source table.
        public let source: CatalogEntry

        @inlinable
        public init(location: Location? = nil, sinks: [CatalogEntry]? = nil, source: CatalogEntry) {
            self.location = location
            self.sinks = sinks
            self.source = source
        }

        public func validate(name: String) throws {
            try self.location?.validate(name: "\(name).location")
            try self.sinks?.forEach {
                try $0.validate(name: "\(name).sinks[]")
            }
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
            case sinks = "Sinks"
            case source = "Source"
        }
    }

    public struct GetMappingResponse: AWSDecodableShape {
        /// A list of mappings to the specified targets.
        public let mapping: [MappingEntry]

        @inlinable
        public init(mapping: [MappingEntry]) {
            self.mapping = mapping
        }

        private enum CodingKeys: String, CodingKey {
            case mapping = "Mapping"
        }
    }

    public struct GetPartitionIndexesRequest: AWSEncodableShape {
        /// The catalog ID where the table resides.
        public let catalogId: String?
        /// Specifies the name of a database from which you want to retrieve partition indexes.
        public let databaseName: String
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?
        /// Specifies the name of a table for which you want to retrieve the partition indexes.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, nextToken: String? = nil, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.nextToken = nextToken
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case nextToken = "NextToken"
            case tableName = "TableName"
        }
    }

    public struct GetPartitionIndexesResponse: AWSDecodableShape {
        /// A continuation token, present if the current list segment is not the last.
        public let nextToken: String?
        /// A list of index descriptors.
        public let partitionIndexDescriptorList: [PartitionIndexDescriptor]?

        @inlinable
        public init(nextToken: String? = nil, partitionIndexDescriptorList: [PartitionIndexDescriptor]? = nil) {
            self.nextToken = nextToken
            self.partitionIndexDescriptorList = partitionIndexDescriptorList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case partitionIndexDescriptorList = "PartitionIndexDescriptorList"
        }
    }

    public struct GetPartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partition resides.
        public let databaseName: String
        /// The values that define the partition.
        public let partitionValues: [String]
        /// The name of the partition's table.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
                try validate($0, name: "partitionValues[]", parent: name, min: 1)
            }
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct GetPartitionResponse: AWSDecodableShape {
        /// The requested information, in the form of a Partition object.
        public let partition: Partition?

        @inlinable
        public init(partition: Partition? = nil) {
            self.partition = partition
        }

        private enum CodingKeys: String, CodingKey {
            case partition = "Partition"
        }
    }

    public struct GetPartitionsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// When true, specifies not returning the partition column schema. Useful when you are interested only in other partition attributes such as partition values or location. This approach avoids the problem of a large response by not returning duplicate data.
        public let excludeColumnSchema: Bool?
        /// An expression that filters the partitions to be returned. The expression uses SQL syntax similar to the SQL WHERE filter clause. The SQL statement parser JSQLParser parses the expression.   Operators: The following are the operators that you can use in the Expression API call:  =  Checks whether the values of the two operands are equal; if yes, then the condition becomes true. Example: Assume 'variable a' holds 10 and 'variable b' holds 20.  (a = b) is not true.    Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true. Example: (a  b) is true.  >  Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true. Example: (a > b) is not true.    Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true. Example: (a   >=  Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a >= b) is not true.    Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a   AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL  Logical operators.    Supported Partition Key Types: The following are the supported partition keys.    string     date     timestamp     int     bigint     long     tinyint     smallint     decimal    If an type is encountered that is not valid, an exception is thrown.  The following list shows the valid operators on each type. When you define a crawler, the partitionKey type is created as a STRING, to be compatible with the catalog partitions.   Sample API Call:
        public let expression: String?
        /// The maximum number of partitions to return in a single response.
        public let maxResults: Int?
        /// A continuation token, if this is not the first call to retrieve these partitions.
        public let nextToken: String?
        /// The time as of when to read the partition contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
        public let queryAsOfTime: Date?
        /// The segment of the table's partitions to scan in this request.
        public let segment: Segment?
        /// The name of the partitions' table.
        public let tableName: String
        /// The transaction ID at which to read the partition contents.
        public let transactionId: String?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, excludeColumnSchema: Bool? = nil, expression: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, queryAsOfTime: Date? = nil, segment: Segment? = nil, tableName: String, transactionId: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.excludeColumnSchema = excludeColumnSchema
            self.expression = expression
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryAsOfTime = queryAsOfTime
            self.segment = segment
            self.tableName = tableName
            self.transactionId = transactionId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.segment?.validate(name: "\(name).segment")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.transactionId, name: "transactionId", parent: name, max: 255)
            try self.validate(self.transactionId, name: "transactionId", parent: name, min: 1)
            try self.validate(self.transactionId, name: "transactionId", parent: name, pattern: "^[\\p{L}\\p{N}\\p{P}]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case excludeColumnSchema = "ExcludeColumnSchema"
            case expression = "Expression"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case queryAsOfTime = "QueryAsOfTime"
            case segment = "Segment"
            case tableName = "TableName"
            case transactionId = "TransactionId"
        }
    }

    public struct GetPartitionsResponse: AWSDecodableShape {
        /// A continuation token, if the returned list of partitions does not include the last one.
        public let nextToken: String?
        /// A list of requested partitions.
        public let partitions: [Partition]?

        @inlinable
        public init(nextToken: String? = nil, partitions: [Partition]? = nil) {
            self.nextToken = nextToken
            self.partitions = partitions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case partitions = "Partitions"
        }
    }

    public struct GetPlanRequest: AWSEncodableShape {
        /// A map to hold additional optional key-value parameters. Currently, these key-value pairs are supported:    inferSchema  Specifies whether to set inferSchema to true or false for the default script generated by an Glue job. For example, to set inferSchema to true, pass the following key value pair:  --additional-plan-options-map '{"inferSchema":"true"}'
        public let additionalPlanOptionsMap: [String: String]?
        /// The programming language of the code to perform the mapping.
        public let language: Language?
        /// The parameters for the mapping.
        public let location: Location?
        /// The list of mappings from a source table to target tables.
        public let mapping: [MappingEntry]
        /// The target tables.
        public let sinks: [CatalogEntry]?
        /// The source table.
        public let source: CatalogEntry

        @inlinable
        public init(additionalPlanOptionsMap: [String: String]? = nil, language: Language? = nil, location: Location? = nil, mapping: [MappingEntry], sinks: [CatalogEntry]? = nil, source: CatalogEntry) {
            self.additionalPlanOptionsMap = additionalPlanOptionsMap
            self.language = language
            self.location = location
            self.mapping = mapping
            self.sinks = sinks
            self.source = source
        }

        public func validate(name: String) throws {
            try self.location?.validate(name: "\(name).location")
            try self.sinks?.forEach {
                try $0.validate(name: "\(name).sinks[]")
            }
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalPlanOptionsMap = "AdditionalPlanOptionsMap"
            case language = "Language"
            case location = "Location"
            case mapping = "Mapping"
            case sinks = "Sinks"
            case source = "Source"
        }
    }

    public struct GetPlanResponse: AWSDecodableShape {
        /// A Python script to perform the mapping.
        public let pythonScript: String?
        /// The Scala code to perform the mapping.
        public let scalaCode: String?

        @inlinable
        public init(pythonScript: String? = nil, scalaCode: String? = nil) {
            self.pythonScript = pythonScript
            self.scalaCode = scalaCode
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
            case scalaCode = "ScalaCode"
        }
    }

    public struct GetRegistryInput: AWSEncodableShape {
        /// This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
        public let registryId: RegistryId

        @inlinable
        public init(registryId: RegistryId) {
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.registryId.validate(name: "\(name).registryId")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "RegistryId"
        }
    }

    public struct GetRegistryResponse: AWSDecodableShape {
        /// The date and time the registry was created.
        public let createdTime: String?
        /// A description of the registry.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// The status of the registry.
        public let status: RegistryStatus?
        /// The date and time the registry was updated.
        public let updatedTime: String?

        @inlinable
        public init(createdTime: String? = nil, description: String? = nil, registryArn: String? = nil, registryName: String? = nil, status: RegistryStatus? = nil, updatedTime: String? = nil) {
            self.createdTime = createdTime
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.status = status
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case status = "Status"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct GetResourcePoliciesRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetResourcePoliciesResponse: AWSDecodableShape {
        /// A list of the individual resource policies and the account-level resource policy.
        public let getResourcePoliciesResponseList: [GluePolicy]?
        /// A continuation token, if the returned list does not contain the last resource policy available.
        public let nextToken: String?

        @inlinable
        public init(getResourcePoliciesResponseList: [GluePolicy]? = nil, nextToken: String? = nil) {
            self.getResourcePoliciesResponseList = getResourcePoliciesResponseList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case getResourcePoliciesResponseList = "GetResourcePoliciesResponseList"
            case nextToken = "NextToken"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// The ARN of the Glue resource for which to retrieve the resource policy. If not supplied, the Data Catalog resource policy is returned. Use GetResourcePolicies to view all existing resource policies. For more information see Specifying Glue Resource ARNs.
        public let resourceArn: String?

        @inlinable
        public init(resourceArn: String? = nil) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:glue:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// The date and time at which the policy was created.
        public let createTime: Date?
        /// Contains the hash value associated with this policy.
        public let policyHash: String?
        /// Contains the requested policy document, in JSON format.
        public let policyInJson: String?
        /// The date and time at which the policy was last updated.
        public let updateTime: Date?

        @inlinable
        public init(createTime: Date? = nil, policyHash: String? = nil, policyInJson: String? = nil, updateTime: Date? = nil) {
            self.createTime = createTime
            self.policyHash = policyHash
            self.policyInJson = policyInJson
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case policyHash = "PolicyHash"
            case policyInJson = "PolicyInJson"
            case updateTime = "UpdateTime"
        }
    }

    public struct GetSchemaByDefinitionInput: AWSEncodableShape {
        /// The definition of the schema for which schema details are required.
        public let schemaDefinition: String
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.   SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
        public let schemaId: SchemaId

        @inlinable
        public init(schemaDefinition: String, schemaId: SchemaId) {
            self.schemaDefinition = schemaDefinition
            self.schemaId = schemaId
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, max: 170000)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, min: 1)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, pattern: "\\S")
            try self.schemaId.validate(name: "\(name).schemaId")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaDefinition = "SchemaDefinition"
            case schemaId = "SchemaId"
        }
    }

    public struct GetSchemaByDefinitionResponse: AWSDecodableShape {
        /// The date and time the schema was created.
        public let createdTime: String?
        /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
        public let dataFormat: DataFormat?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The schema ID of the schema version.
        public let schemaVersionId: String?
        /// The status of the schema version.
        public let status: SchemaVersionStatus?

        @inlinable
        public init(createdTime: String? = nil, dataFormat: DataFormat? = nil, schemaArn: String? = nil, schemaVersionId: String? = nil, status: SchemaVersionStatus? = nil) {
            self.createdTime = createdTime
            self.dataFormat = dataFormat
            self.schemaArn = schemaArn
            self.schemaVersionId = schemaVersionId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case dataFormat = "DataFormat"
            case schemaArn = "SchemaArn"
            case schemaVersionId = "SchemaVersionId"
            case status = "Status"
        }
    }

    public struct GetSchemaInput: AWSEncodableShape {
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
        public let schemaId: SchemaId

        @inlinable
        public init(schemaId: SchemaId) {
            self.schemaId = schemaId
        }

        public func validate(name: String) throws {
            try self.schemaId.validate(name: "\(name).schemaId")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaId = "SchemaId"
        }
    }

    public struct GetSchemaResponse: AWSDecodableShape {
        /// The compatibility mode of the schema.
        public let compatibility: Compatibility?
        /// The date and time the schema was created.
        public let createdTime: String?
        /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
        public let dataFormat: DataFormat?
        /// A description of schema if specified when created
        public let description: String?
        /// The latest version of the schema associated with the returned schema definition.
        public let latestSchemaVersion: Int64?
        /// The next version of the schema associated with the returned schema definition.
        public let nextSchemaVersion: Int64?
        /// The Amazon Resource Name (ARN) of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The version number of the checkpoint (the last time the compatibility mode was changed).
        public let schemaCheckpoint: Int64?
        /// The name of the schema.
        public let schemaName: String?
        /// The status of the schema.
        public let schemaStatus: SchemaStatus?
        /// The date and time the schema was updated.
        public let updatedTime: String?

        @inlinable
        public init(compatibility: Compatibility? = nil, createdTime: String? = nil, dataFormat: DataFormat? = nil, description: String? = nil, latestSchemaVersion: Int64? = nil, nextSchemaVersion: Int64? = nil, registryArn: String? = nil, registryName: String? = nil, schemaArn: String? = nil, schemaCheckpoint: Int64? = nil, schemaName: String? = nil, schemaStatus: SchemaStatus? = nil, updatedTime: String? = nil) {
            self.compatibility = compatibility
            self.createdTime = createdTime
            self.dataFormat = dataFormat
            self.description = description
            self.latestSchemaVersion = latestSchemaVersion
            self.nextSchemaVersion = nextSchemaVersion
            self.registryArn = registryArn
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaCheckpoint = schemaCheckpoint
            self.schemaName = schemaName
            self.schemaStatus = schemaStatus
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case compatibility = "Compatibility"
            case createdTime = "CreatedTime"
            case dataFormat = "DataFormat"
            case description = "Description"
            case latestSchemaVersion = "LatestSchemaVersion"
            case nextSchemaVersion = "NextSchemaVersion"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaCheckpoint = "SchemaCheckpoint"
            case schemaName = "SchemaName"
            case schemaStatus = "SchemaStatus"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct GetSchemaVersionInput: AWSEncodableShape {
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
        public let schemaId: SchemaId?
        /// The SchemaVersionId of the schema version. This field is required for fetching by schema ID. Either this or the SchemaId wrapper has to be provided.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let schemaVersionNumber: SchemaVersionNumber?

        @inlinable
        public init(schemaId: SchemaId? = nil, schemaVersionId: String? = nil, schemaVersionNumber: SchemaVersionNumber? = nil) {
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.schemaId?.validate(name: "\(name).schemaId")
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.schemaVersionNumber?.validate(name: "\(name).schemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaId = "SchemaId"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct GetSchemaVersionResponse: AWSDecodableShape {
        /// The date and time the schema version was created.
        public let createdTime: String?
        /// The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
        public let dataFormat: DataFormat?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The schema definition for the schema ID.
        public let schemaDefinition: String?
        /// The SchemaVersionId of the schema version.
        public let schemaVersionId: String?
        /// The status of the schema version.
        public let status: SchemaVersionStatus?
        /// The version number of the schema.
        public let versionNumber: Int64?

        @inlinable
        public init(createdTime: String? = nil, dataFormat: DataFormat? = nil, schemaArn: String? = nil, schemaDefinition: String? = nil, schemaVersionId: String? = nil, status: SchemaVersionStatus? = nil, versionNumber: Int64? = nil) {
            self.createdTime = createdTime
            self.dataFormat = dataFormat
            self.schemaArn = schemaArn
            self.schemaDefinition = schemaDefinition
            self.schemaVersionId = schemaVersionId
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case dataFormat = "DataFormat"
            case schemaArn = "SchemaArn"
            case schemaDefinition = "SchemaDefinition"
            case schemaVersionId = "SchemaVersionId"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct GetSchemaVersionsDiffInput: AWSEncodableShape {
        /// The first of the two schema versions to be compared.
        public let firstSchemaVersionNumber: SchemaVersionNumber
        /// Refers to SYNTAX_DIFF, which is the currently supported diff type.
        public let schemaDiffType: SchemaDiffType
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.   SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
        public let schemaId: SchemaId
        /// The second of the two schema versions to be compared.
        public let secondSchemaVersionNumber: SchemaVersionNumber

        @inlinable
        public init(firstSchemaVersionNumber: SchemaVersionNumber, schemaDiffType: SchemaDiffType, schemaId: SchemaId, secondSchemaVersionNumber: SchemaVersionNumber) {
            self.firstSchemaVersionNumber = firstSchemaVersionNumber
            self.schemaDiffType = schemaDiffType
            self.schemaId = schemaId
            self.secondSchemaVersionNumber = secondSchemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.firstSchemaVersionNumber.validate(name: "\(name).firstSchemaVersionNumber")
            try self.schemaId.validate(name: "\(name).schemaId")
            try self.secondSchemaVersionNumber.validate(name: "\(name).secondSchemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case firstSchemaVersionNumber = "FirstSchemaVersionNumber"
            case schemaDiffType = "SchemaDiffType"
            case schemaId = "SchemaId"
            case secondSchemaVersionNumber = "SecondSchemaVersionNumber"
        }
    }

    public struct GetSchemaVersionsDiffResponse: AWSDecodableShape {
        /// The difference between schemas as a string in JsonPatch format.
        public let diff: String?

        @inlinable
        public init(diff: String? = nil) {
            self.diff = diff
        }

        private enum CodingKeys: String, CodingKey {
            case diff = "Diff"
        }
    }

    public struct GetSecurityConfigurationRequest: AWSEncodableShape {
        /// The name of the security configuration to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetSecurityConfigurationResponse: AWSDecodableShape {
        /// The requested security configuration.
        public let securityConfiguration: SecurityConfiguration?

        @inlinable
        public init(securityConfiguration: SecurityConfiguration? = nil) {
            self.securityConfiguration = securityConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case securityConfiguration = "SecurityConfiguration"
        }
    }

    public struct GetSecurityConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetSecurityConfigurationsResponse: AWSDecodableShape {
        /// A continuation token, if there are more security configurations to return.
        public let nextToken: String?
        /// A list of security configurations.
        public let securityConfigurations: [SecurityConfiguration]?

        @inlinable
        public init(nextToken: String? = nil, securityConfigurations: [SecurityConfiguration]? = nil) {
            self.nextToken = nextToken
            self.securityConfigurations = securityConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case securityConfigurations = "SecurityConfigurations"
        }
    }

    public struct GetSessionRequest: AWSEncodableShape {
        /// The ID of the session.
        public let id: String
        /// The origin of the request.
        public let requestOrigin: String?

        @inlinable
        public init(id: String, requestOrigin: String? = nil) {
            self.id = id
            self.requestOrigin = requestOrigin
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, max: 128)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, min: 1)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case requestOrigin = "RequestOrigin"
        }
    }

    public struct GetSessionResponse: AWSDecodableShape {
        /// The session object is returned in the response.
        public let session: Session?

        @inlinable
        public init(session: Session? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "Session"
        }
    }

    public struct GetStatementRequest: AWSEncodableShape {
        /// The Id of the statement.
        public let id: Int
        /// The origin of the request.
        public let requestOrigin: String?
        /// The Session ID of the statement.
        public let sessionId: String

        @inlinable
        public init(id: Int = 0, requestOrigin: String? = nil, sessionId: String) {
            self.id = id
            self.requestOrigin = requestOrigin
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, max: 128)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, min: 1)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 255)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case requestOrigin = "RequestOrigin"
            case sessionId = "SessionId"
        }
    }

    public struct GetStatementResponse: AWSDecodableShape {
        /// Returns the statement.
        public let statement: Statement?

        @inlinable
        public init(statement: Statement? = nil) {
            self.statement = statement
        }

        private enum CodingKeys: String, CodingKey {
            case statement = "Statement"
        }
    }

    public struct GetTableOptimizerRequest: AWSEncodableShape {
        /// The Catalog ID of the table.
        public let catalogId: String
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String
        /// The name of the table.
        public let tableName: String
        /// The type of table optimizer.
        public let type: TableOptimizerType

        @inlinable
        public init(catalogId: String, databaseName: String, tableName: String, type: TableOptimizerType) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case type = "Type"
        }
    }

    public struct GetTableOptimizerResponse: AWSDecodableShape {
        /// The Catalog ID of the table.
        public let catalogId: String?
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String?
        /// The name of the table.
        public let tableName: String?
        /// The optimizer associated with the specified table.
        public let tableOptimizer: TableOptimizer?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String? = nil, tableName: String? = nil, tableOptimizer: TableOptimizer? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.tableOptimizer = tableOptimizer
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case tableOptimizer = "TableOptimizer"
        }
    }

    public struct GetTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
        public let includeStatusDetails: Bool?
        /// The name of the table for which to retrieve the definition. For Hive compatibility, this name is entirely lowercase.
        public let name: String
        /// The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
        public let queryAsOfTime: Date?
        /// The transaction ID at which to read the table contents.
        public let transactionId: String?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, includeStatusDetails: Bool? = nil, name: String, queryAsOfTime: Date? = nil, transactionId: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.includeStatusDetails = includeStatusDetails
            self.name = name
            self.queryAsOfTime = queryAsOfTime
            self.transactionId = transactionId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.transactionId, name: "transactionId", parent: name, max: 255)
            try self.validate(self.transactionId, name: "transactionId", parent: name, min: 1)
            try self.validate(self.transactionId, name: "transactionId", parent: name, pattern: "^[\\p{L}\\p{N}\\p{P}]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case includeStatusDetails = "IncludeStatusDetails"
            case name = "Name"
            case queryAsOfTime = "QueryAsOfTime"
            case transactionId = "TransactionId"
        }
    }

    public struct GetTableResponse: AWSDecodableShape {
        /// The Table object that defines the specified table.
        public let table: Table?

        @inlinable
        public init(table: Table? = nil) {
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
        }
    }

    public struct GetTableVersionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table. For Hive compatibility, this name is entirely lowercase.
        public let tableName: String
        /// The ID value of the table version to be retrieved. A VersionID is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, tableName: String, versionId: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 255)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case versionId = "VersionId"
        }
    }

    public struct GetTableVersionResponse: AWSDecodableShape {
        /// The requested table version.
        public let tableVersion: TableVersion?

        @inlinable
        public init(tableVersion: TableVersion? = nil) {
            self.tableVersion = tableVersion
        }

        private enum CodingKeys: String, CodingKey {
            case tableVersion = "TableVersion"
        }
    }

    public struct GetTableVersionsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The maximum number of table versions to return in one response.
        public let maxResults: Int?
        /// A continuation token, if this is not the first call.
        public let nextToken: String?
        /// The name of the table. For Hive compatibility, this name is entirely lowercase.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, maxResults: Int? = nil, nextToken: String? = nil, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tableName = "TableName"
        }
    }

    public struct GetTableVersionsResponse: AWSDecodableShape {
        /// A continuation token, if the list of available versions does not include the last one.
        public let nextToken: String?
        /// A list of strings identifying available versions of the specified table.
        public let tableVersions: [TableVersion]?

        @inlinable
        public init(nextToken: String? = nil, tableVersions: [TableVersion]? = nil) {
            self.nextToken = nextToken
            self.tableVersions = tableVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tableVersions = "TableVersions"
        }
    }

    public struct GetTablesRequest: AWSEncodableShape {
        ///  Specifies the table fields returned by the GetTables call. This parameter doesnt accept an empty list. The request must include NAME. The following are the valid combinations of values:    NAME - Names of all tables in the database.    NAME, TABLE_TYPE - Names of all tables and the table types.
        public let attributesToGet: [TableAttributes]?
        /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog whose tables to list. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// A regular expression pattern. If present, only those tables whose names match the pattern are returned.
        public let expression: String?
        /// Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
        public let includeStatusDetails: Bool?
        /// The maximum number of tables to return in a single response.
        public let maxResults: Int?
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?
        /// The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
        public let queryAsOfTime: Date?
        /// The transaction ID at which to read the table contents.
        public let transactionId: String?

        @inlinable
        public init(attributesToGet: [TableAttributes]? = nil, catalogId: String? = nil, databaseName: String, expression: String? = nil, includeStatusDetails: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, queryAsOfTime: Date? = nil, transactionId: String? = nil) {
            self.attributesToGet = attributesToGet
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.expression = expression
            self.includeStatusDetails = includeStatusDetails
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryAsOfTime = queryAsOfTime
            self.transactionId = transactionId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.transactionId, name: "transactionId", parent: name, max: 255)
            try self.validate(self.transactionId, name: "transactionId", parent: name, min: 1)
            try self.validate(self.transactionId, name: "transactionId", parent: name, pattern: "^[\\p{L}\\p{N}\\p{P}]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributesToGet = "AttributesToGet"
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case expression = "Expression"
            case includeStatusDetails = "IncludeStatusDetails"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case queryAsOfTime = "QueryAsOfTime"
            case transactionId = "TransactionId"
        }
    }

    public struct GetTablesResponse: AWSDecodableShape {
        /// A continuation token, present if the current list segment is not the last.
        public let nextToken: String?
        /// A list of the requested Table objects.
        public let tableList: [Table]?

        @inlinable
        public init(nextToken: String? = nil, tableList: [Table]? = nil) {
            self.nextToken = nextToken
            self.tableList = tableList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tableList = "TableList"
        }
    }

    public struct GetTagsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which to retrieve tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:glue:")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct GetTagsResponse: AWSDecodableShape {
        /// The requested tags.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct GetTriggerRequest: AWSEncodableShape {
        /// The name of the trigger to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetTriggerResponse: AWSDecodableShape {
        /// The requested trigger definition.
        public let trigger: Trigger?

        @inlinable
        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public struct GetTriggersRequest: AWSEncodableShape {
        /// The name of the job to retrieve triggers for. The trigger that can start this job is returned, and if there is no such trigger, all triggers are returned.
        public let dependentJobName: String?
        /// The maximum size of the response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(dependentJobName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dependentJobName = dependentJobName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, max: 255)
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, min: 1)
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dependentJobName = "DependentJobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetTriggersResponse: AWSDecodableShape {
        /// A continuation token, if not all the requested triggers have yet been returned.
        public let nextToken: String?
        /// A list of triggers for the specified job.
        public let triggers: [Trigger]?

        @inlinable
        public init(nextToken: String? = nil, triggers: [Trigger]? = nil) {
            self.nextToken = nextToken
            self.triggers = triggers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case triggers = "Triggers"
        }
    }

    public struct GetUnfilteredPartitionMetadataRequest: AWSEncodableShape {
        /// A structure containing Lake Formation audit context information.
        public let auditContext: AuditContext?
        /// The catalog ID where the partition resides.
        public let catalogId: String
        /// (Required) Specifies the name of a database that contains the partition.
        public let databaseName: String
        /// (Required) A list of partition key values.
        public let partitionValues: [String]
        /// A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
        public let querySessionContext: QuerySessionContext?
        /// Specified only if the base tables belong to a different Amazon Web Services Region.
        public let region: String?
        /// (Required) A list of supported permission types.
        public let supportedPermissionTypes: [PermissionType]
        /// (Required) Specifies the name of a table that contains the partition.
        public let tableName: String

        @inlinable
        public init(auditContext: AuditContext? = nil, catalogId: String, databaseName: String, partitionValues: [String], querySessionContext: QuerySessionContext? = nil, region: String? = nil, supportedPermissionTypes: [PermissionType], tableName: String) {
            self.auditContext = auditContext
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.querySessionContext = querySessionContext
            self.region = region
            self.supportedPermissionTypes = supportedPermissionTypes
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.auditContext?.validate(name: "\(name).auditContext")
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
                try validate($0, name: "partitionValues[]", parent: name, min: 1)
            }
            try self.querySessionContext?.validate(name: "\(name).querySessionContext")
            try self.validate(self.region, name: "region", parent: name, max: 1024)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.validate(self.supportedPermissionTypes, name: "supportedPermissionTypes", parent: name, max: 255)
            try self.validate(self.supportedPermissionTypes, name: "supportedPermissionTypes", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case auditContext = "AuditContext"
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case querySessionContext = "QuerySessionContext"
            case region = "Region"
            case supportedPermissionTypes = "SupportedPermissionTypes"
            case tableName = "TableName"
        }
    }

    public struct GetUnfilteredPartitionMetadataResponse: AWSDecodableShape {
        /// A list of column names that the user has been granted access to.
        public let authorizedColumns: [String]?
        /// A Boolean value that indicates whether the partition location is registered  with Lake Formation.
        public let isRegisteredWithLakeFormation: Bool?
        /// A Partition object containing the partition metadata.
        public let partition: Partition?

        @inlinable
        public init(authorizedColumns: [String]? = nil, isRegisteredWithLakeFormation: Bool? = nil, partition: Partition? = nil) {
            self.authorizedColumns = authorizedColumns
            self.isRegisteredWithLakeFormation = isRegisteredWithLakeFormation
            self.partition = partition
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedColumns = "AuthorizedColumns"
            case isRegisteredWithLakeFormation = "IsRegisteredWithLakeFormation"
            case partition = "Partition"
        }
    }

    public struct GetUnfilteredPartitionsMetadataRequest: AWSEncodableShape {
        /// A structure containing Lake Formation audit context information.
        public let auditContext: AuditContext?
        /// The ID of the Data Catalog where the partitions in question reside. If none is provided,  the AWS account ID is used by default.
        public let catalogId: String
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// An expression that filters the partitions to be returned. The expression uses SQL syntax similar to the SQL WHERE filter clause. The SQL statement parser JSQLParser parses the expression.   Operators: The following are the operators that you can use in the Expression API call:  =  Checks whether the values of the two operands are equal; if yes, then the condition becomes true. Example: Assume 'variable a' holds 10 and 'variable b' holds 20.  (a = b) is not true.    Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true. Example: (a  b) is true.  >  Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true. Example: (a > b) is not true.    Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true. Example: (a   >=  Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a >= b) is not true.    Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a   AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL  Logical operators.    Supported Partition Key Types: The following are the supported partition keys.    string     date     timestamp     int     bigint     long     tinyint     smallint     decimal    If an type is encountered that is not valid, an exception is thrown.
        public let expression: String?
        /// The maximum number of partitions to return in a single response.
        public let maxResults: Int?
        /// A continuation token, if this is not the first call to retrieve these partitions.
        public let nextToken: String?
        /// A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
        public let querySessionContext: QuerySessionContext?
        /// Specified only if the base tables belong to a different Amazon Web Services Region.
        public let region: String?
        /// The segment of the table's partitions to scan in this request.
        public let segment: Segment?
        /// A list of supported permission types.
        public let supportedPermissionTypes: [PermissionType]
        /// The name of the table that contains the partition.
        public let tableName: String

        @inlinable
        public init(auditContext: AuditContext? = nil, catalogId: String, databaseName: String, expression: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, querySessionContext: QuerySessionContext? = nil, region: String? = nil, segment: Segment? = nil, supportedPermissionTypes: [PermissionType], tableName: String) {
            self.auditContext = auditContext
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.expression = expression
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.querySessionContext = querySessionContext
            self.region = region
            self.segment = segment
            self.supportedPermissionTypes = supportedPermissionTypes
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.auditContext?.validate(name: "\(name).auditContext")
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.querySessionContext?.validate(name: "\(name).querySessionContext")
            try self.validate(self.region, name: "region", parent: name, max: 1024)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.segment?.validate(name: "\(name).segment")
            try self.validate(self.supportedPermissionTypes, name: "supportedPermissionTypes", parent: name, max: 255)
            try self.validate(self.supportedPermissionTypes, name: "supportedPermissionTypes", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case auditContext = "AuditContext"
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case expression = "Expression"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case querySessionContext = "QuerySessionContext"
            case region = "Region"
            case segment = "Segment"
            case supportedPermissionTypes = "SupportedPermissionTypes"
            case tableName = "TableName"
        }
    }

    public struct GetUnfilteredPartitionsMetadataResponse: AWSDecodableShape {
        /// A continuation token, if the returned list of partitions does not include the last one.
        public let nextToken: String?
        /// A list of requested partitions.
        public let unfilteredPartitions: [UnfilteredPartition]?

        @inlinable
        public init(nextToken: String? = nil, unfilteredPartitions: [UnfilteredPartition]? = nil) {
            self.nextToken = nextToken
            self.unfilteredPartitions = unfilteredPartitions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case unfilteredPartitions = "UnfilteredPartitions"
        }
    }

    public struct GetUnfilteredTableMetadataRequest: AWSEncodableShape {
        /// A structure containing Lake Formation audit context information.
        public let auditContext: AuditContext?
        /// The catalog ID where the table resides.
        public let catalogId: String
        /// (Required) Specifies the name of a database that contains the table.
        public let databaseName: String
        /// (Required) Specifies the name of a table for which you are requesting metadata.
        public let name: String
        /// The resource ARN of the view.
        public let parentResourceArn: String?
        /// The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.
        public let permissions: [Permission]?
        /// A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
        public let querySessionContext: QuerySessionContext?
        /// Specified only if the base tables belong to a different Amazon Web Services Region.
        public let region: String?
        /// The resource ARN of the root view in a chain of nested views.
        public let rootResourceArn: String?
        /// A structure specifying the dialect and dialect version used by the query engine.
        public let supportedDialect: SupportedDialect?
        /// Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the GetUnfilteredTableMetadata API operation. Accepted values are:    COLUMN_PERMISSION - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.    CELL_FILTER_PERMISSION - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.    NESTED_PERMISSION - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.    NESTED_CELL_PERMISSION - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.    Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type. Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the GetUnfilteredTableMetadata operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.
        public let supportedPermissionTypes: [PermissionType]

        @inlinable
        public init(auditContext: AuditContext? = nil, catalogId: String, databaseName: String, name: String, parentResourceArn: String? = nil, permissions: [Permission]? = nil, querySessionContext: QuerySessionContext? = nil, region: String? = nil, rootResourceArn: String? = nil, supportedDialect: SupportedDialect? = nil, supportedPermissionTypes: [PermissionType]) {
            self.auditContext = auditContext
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
            self.parentResourceArn = parentResourceArn
            self.permissions = permissions
            self.querySessionContext = querySessionContext
            self.region = region
            self.rootResourceArn = rootResourceArn
            self.supportedDialect = supportedDialect
            self.supportedPermissionTypes = supportedPermissionTypes
        }

        public func validate(name: String) throws {
            try self.auditContext?.validate(name: "\(name).auditContext")
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.parentResourceArn, name: "parentResourceArn", parent: name, max: 2048)
            try self.validate(self.parentResourceArn, name: "parentResourceArn", parent: name, min: 20)
            try self.querySessionContext?.validate(name: "\(name).querySessionContext")
            try self.validate(self.region, name: "region", parent: name, max: 1024)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.validate(self.rootResourceArn, name: "rootResourceArn", parent: name, max: 2048)
            try self.validate(self.rootResourceArn, name: "rootResourceArn", parent: name, min: 20)
            try self.supportedDialect?.validate(name: "\(name).supportedDialect")
            try self.validate(self.supportedPermissionTypes, name: "supportedPermissionTypes", parent: name, max: 255)
            try self.validate(self.supportedPermissionTypes, name: "supportedPermissionTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case auditContext = "AuditContext"
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case name = "Name"
            case parentResourceArn = "ParentResourceArn"
            case permissions = "Permissions"
            case querySessionContext = "QuerySessionContext"
            case region = "Region"
            case rootResourceArn = "RootResourceArn"
            case supportedDialect = "SupportedDialect"
            case supportedPermissionTypes = "SupportedPermissionTypes"
        }
    }

    public struct GetUnfilteredTableMetadataResponse: AWSDecodableShape {
        /// A list of column names that the user has been granted access to.
        public let authorizedColumns: [String]?
        /// A list of column row filters.
        public let cellFilters: [ColumnRowFilter]?
        /// Specifies whether the view supports the SQL dialects of one or more different query engines and can therefore be read by those engines.
        public let isMultiDialectView: Bool?
        /// A flag that instructs the engine not to push user-provided operations into the logical plan of the view during query planning. However, if set this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.
        public let isProtected: Bool?
        /// A Boolean value that indicates whether the partition location is registered  with Lake Formation.
        public let isRegisteredWithLakeFormation: Bool?
        /// The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.
        public let permissions: [Permission]?
        /// A cryptographically generated query identifier generated by Glue or Lake Formation.
        public let queryAuthorizationId: String?
        /// The resource ARN of the parent resource extracted from the request.
        public let resourceArn: String?
        /// The filter that applies to the table. For example when applying the filter in SQL, it would go in the WHERE clause and can be evaluated by using an AND operator with any other predicates applied by the user querying the table.
        public let rowFilter: String?
        /// A Table object containing the table metadata.
        public let table: Table?

        @inlinable
        public init(authorizedColumns: [String]? = nil, cellFilters: [ColumnRowFilter]? = nil, isMultiDialectView: Bool? = nil, isProtected: Bool? = nil, isRegisteredWithLakeFormation: Bool? = nil, permissions: [Permission]? = nil, queryAuthorizationId: String? = nil, resourceArn: String? = nil, rowFilter: String? = nil, table: Table? = nil) {
            self.authorizedColumns = authorizedColumns
            self.cellFilters = cellFilters
            self.isMultiDialectView = isMultiDialectView
            self.isProtected = isProtected
            self.isRegisteredWithLakeFormation = isRegisteredWithLakeFormation
            self.permissions = permissions
            self.queryAuthorizationId = queryAuthorizationId
            self.resourceArn = resourceArn
            self.rowFilter = rowFilter
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedColumns = "AuthorizedColumns"
            case cellFilters = "CellFilters"
            case isMultiDialectView = "IsMultiDialectView"
            case isProtected = "IsProtected"
            case isRegisteredWithLakeFormation = "IsRegisteredWithLakeFormation"
            case permissions = "Permissions"
            case queryAuthorizationId = "QueryAuthorizationId"
            case resourceArn = "ResourceArn"
            case rowFilter = "RowFilter"
            case table = "Table"
        }
    }

    public struct GetUsageProfileRequest: AWSEncodableShape {
        /// The name of the usage profile to retrieve.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetUsageProfileResponse: AWSDecodableShape {
        /// A ProfileConfiguration object specifying the job and session values for the profile.
        public let configuration: ProfileConfiguration?
        /// The date and time when the usage profile was created.
        public let createdOn: Date?
        /// A description of the usage profile.
        public let description: String?
        /// The date and time when the usage profile was last modified.
        public let lastModifiedOn: Date?
        /// The name of the usage profile.
        public let name: String?

        @inlinable
        public init(configuration: ProfileConfiguration? = nil, createdOn: Date? = nil, description: String? = nil, lastModifiedOn: Date? = nil, name: String? = nil) {
            self.configuration = configuration
            self.createdOn = createdOn
            self.description = description
            self.lastModifiedOn = lastModifiedOn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case createdOn = "CreatedOn"
            case description = "Description"
            case lastModifiedOn = "LastModifiedOn"
            case name = "Name"
        }
    }

    public struct GetUserDefinedFunctionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the function to be retrieved is located. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the function is located.
        public let databaseName: String
        /// The name of the function.
        public let functionName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, functionName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 255)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionName = "FunctionName"
        }
    }

    public struct GetUserDefinedFunctionResponse: AWSDecodableShape {
        /// The requested function definition.
        public let userDefinedFunction: UserDefinedFunction?

        @inlinable
        public init(userDefinedFunction: UserDefinedFunction? = nil) {
            self.userDefinedFunction = userDefinedFunction
        }

        private enum CodingKeys: String, CodingKey {
            case userDefinedFunction = "UserDefinedFunction"
        }
    }

    public struct GetUserDefinedFunctionsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the functions to be retrieved are located. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the functions are located. If none is provided, functions from all the databases across the catalog will be returned.
        public let databaseName: String?
        /// The maximum number of functions to return in one response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// An optional function-name pattern string that filters the function definitions returned.
        public let pattern: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, pattern: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pattern = pattern
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.pattern, name: "pattern", parent: name, max: 255)
            try self.validate(self.pattern, name: "pattern", parent: name, min: 1)
            try self.validate(self.pattern, name: "pattern", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pattern = "Pattern"
        }
    }

    public struct GetUserDefinedFunctionsResponse: AWSDecodableShape {
        /// A continuation token, if the list of functions returned does not include the last requested function.
        public let nextToken: String?
        /// A list of requested function definitions.
        public let userDefinedFunctions: [UserDefinedFunction]?

        @inlinable
        public init(nextToken: String? = nil, userDefinedFunctions: [UserDefinedFunction]? = nil) {
            self.nextToken = nextToken
            self.userDefinedFunctions = userDefinedFunctions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userDefinedFunctions = "UserDefinedFunctions"
        }
    }

    public struct GetWorkflowRequest: AWSEncodableShape {
        /// Specifies whether to include a graph when returning the workflow resource metadata.
        public let includeGraph: Bool?
        /// The name of the workflow to retrieve.
        public let name: String

        @inlinable
        public init(includeGraph: Bool? = nil, name: String) {
            self.includeGraph = includeGraph
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case name = "Name"
        }
    }

    public struct GetWorkflowResponse: AWSDecodableShape {
        /// The resource metadata for the workflow.
        public let workflow: Workflow?

        @inlinable
        public init(workflow: Workflow? = nil) {
            self.workflow = workflow
        }

        private enum CodingKeys: String, CodingKey {
            case workflow = "Workflow"
        }
    }

    public struct GetWorkflowRunPropertiesRequest: AWSEncodableShape {
        /// Name of the workflow which was run.
        public let name: String
        /// The ID of the workflow run whose run properties should be returned.
        public let runId: String

        @inlinable
        public init(name: String, runId: String) {
            self.name = name
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case runId = "RunId"
        }
    }

    public struct GetWorkflowRunPropertiesResponse: AWSDecodableShape {
        /// The workflow run properties which were set during the specified run.
        public let runProperties: [String: String]?

        @inlinable
        public init(runProperties: [String: String]? = nil) {
            self.runProperties = runProperties
        }

        private enum CodingKeys: String, CodingKey {
            case runProperties = "RunProperties"
        }
    }

    public struct GetWorkflowRunRequest: AWSEncodableShape {
        /// Specifies whether to include the workflow graph in response or not.
        public let includeGraph: Bool?
        /// Name of the workflow being run.
        public let name: String
        /// The ID of the workflow run.
        public let runId: String

        @inlinable
        public init(includeGraph: Bool? = nil, name: String, runId: String) {
            self.includeGraph = includeGraph
            self.name = name
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case name = "Name"
            case runId = "RunId"
        }
    }

    public struct GetWorkflowRunResponse: AWSDecodableShape {
        /// The requested workflow run metadata.
        public let run: WorkflowRun?

        @inlinable
        public init(run: WorkflowRun? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run = "Run"
        }
    }

    public struct GetWorkflowRunsRequest: AWSEncodableShape {
        /// Specifies whether to include the workflow graph in response or not.
        public let includeGraph: Bool?
        /// The maximum number of workflow runs to be included in the response.
        public let maxResults: Int?
        /// Name of the workflow whose metadata of runs should be returned.
        public let name: String
        /// The maximum size of the response.
        public let nextToken: String?

        @inlinable
        public init(includeGraph: Bool? = nil, maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.includeGraph = includeGraph
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case maxResults = "MaxResults"
            case name = "Name"
            case nextToken = "NextToken"
        }
    }

    public struct GetWorkflowRunsResponse: AWSDecodableShape {
        /// A continuation token, if not all requested workflow runs have been returned.
        public let nextToken: String?
        /// A list of workflow run metadata objects.
        public let runs: [WorkflowRun]?

        @inlinable
        public init(nextToken: String? = nil, runs: [WorkflowRun]? = nil) {
            self.nextToken = nextToken
            self.runs = runs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case runs = "Runs"
        }
    }

    public struct GluePolicy: AWSDecodableShape {
        /// The date and time at which the policy was created.
        public let createTime: Date?
        /// Contains the hash value associated with this policy.
        public let policyHash: String?
        /// Contains the requested policy document, in JSON format.
        public let policyInJson: String?
        /// The date and time at which the policy was last updated.
        public let updateTime: Date?

        @inlinable
        public init(createTime: Date? = nil, policyHash: String? = nil, policyInJson: String? = nil, updateTime: Date? = nil) {
            self.createTime = createTime
            self.policyHash = policyHash
            self.policyInJson = policyInJson
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case policyHash = "PolicyHash"
            case policyInJson = "PolicyInJson"
            case updateTime = "UpdateTime"
        }
    }

    public struct GlueSchema: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the column definitions that make up a Glue schema.
        public let columns: [GlueStudioSchemaColumn]?

        @inlinable
        public init(columns: [GlueStudioSchemaColumn]? = nil) {
            self.columns = columns
        }

        public func validate(name: String) throws {
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
        }
    }

    public struct GlueStudioSchemaColumn: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column in the Glue Studio schema.
        public let name: String
        /// The hive type for this column in the Glue Studio schema.
        public let type: String?

        @inlinable
        public init(name: String, type: String? = nil) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.type, name: "type", parent: name, max: 131072)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct GlueTable: AWSEncodableShape & AWSDecodableShape {
        /// Additional options for the table. Currently there are two keys supported:    pushDownPredicate: to filter on partitions without having to list and read all the files in your dataset.    catalogPartitionPredicate: to use server-side partition pruning using partition indexes in the Glue Data Catalog.
        public let additionalOptions: [String: String]?
        /// A unique identifier for the Glue Data Catalog.
        public let catalogId: String?
        /// The name of the connection to the Glue Data Catalog.
        public let connectionName: String?
        /// A database name in the Glue Data Catalog.
        public let databaseName: String
        /// A table name in the Glue Data Catalog.
        public let tableName: String

        @inlinable
        public init(additionalOptions: [String: String]? = nil, catalogId: String? = nil, connectionName: String? = nil, databaseName: String, tableName: String) {
            self.additionalOptions = additionalOptions
            self.catalogId = catalogId
            self.connectionName = connectionName
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.forEach {
                try validate($0.key, name: "additionalOptions.key", parent: name, max: 255)
                try validate($0.key, name: "additionalOptions.key", parent: name, min: 1)
                try validate($0.key, name: "additionalOptions.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try validate($0.value, name: "additionalOptions[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "additionalOptions[\"\($0.key)\"]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            }
            try self.validate(self.additionalOptions, name: "additionalOptions", parent: name, max: 10)
            try self.validate(self.additionalOptions, name: "additionalOptions", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 255)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case catalogId = "CatalogId"
            case connectionName = "ConnectionName"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct GovernedCatalogSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalOptions: S3SourceAdditionalOptions?
        /// The database to read from.
        public let database: String
        /// The name of the data store.
        public let name: String
        /// Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to ""  empty by default.
        public let partitionPredicate: String?
        /// The database table to read from.
        public let table: String

        @inlinable
        public init(additionalOptions: S3SourceAdditionalOptions? = nil, database: String, name: String, partitionPredicate: String? = nil, table: String) {
            self.additionalOptions = additionalOptions
            self.database = database
            self.name = name
            self.partitionPredicate = partitionPredicate
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.partitionPredicate, name: "partitionPredicate", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case database = "Database"
            case name = "Name"
            case partitionPredicate = "PartitionPredicate"
            case table = "Table"
        }
    }

    public struct GovernedCatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to write to.
        public let database: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// Specifies native partitioning using a sequence of keys.
        public let partitionKeys: [[String]]?
        /// A policy that specifies update behavior for the governed catalog.
        public let schemaChangePolicy: CatalogSchemaChangePolicy?
        /// The name of the table in the database to write to.
        public let table: String

        @inlinable
        public init(database: String, inputs: [String], name: String, partitionKeys: [[String]]? = nil, schemaChangePolicy: CatalogSchemaChangePolicy? = nil, table: String) {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaChangePolicy = schemaChangePolicy
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case inputs = "Inputs"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case schemaChangePolicy = "SchemaChangePolicy"
            case table = "Table"
        }
    }

    public struct GrokClassifier: AWSDecodableShape {
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and so on.
        public let classification: String
        /// The time that this classifier was registered.
        public let creationTime: Date?
        /// Optional custom grok patterns defined by this classifier. For more information, see custom patterns in Writing Custom Classifiers.
        public let customPatterns: String?
        /// The grok pattern applied to a data store by this classifier. For more information, see built-in patterns in Writing Custom Classifiers.
        public let grokPattern: String
        /// The time that this classifier was last updated.
        public let lastUpdated: Date?
        /// The name of the classifier.
        public let name: String
        /// The version of this classifier.
        public let version: Int64?

        @inlinable
        public init(classification: String, creationTime: Date? = nil, customPatterns: String? = nil, grokPattern: String, lastUpdated: Date? = nil, name: String, version: Int64? = nil) {
            self.classification = classification
            self.creationTime = creationTime
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.lastUpdated = lastUpdated
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case creationTime = "CreationTime"
            case customPatterns = "CustomPatterns"
            case grokPattern = "GrokPattern"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct HudiTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection to use to connect to the Hudi target. If your Hudi files are stored in buckets that require VPC authorization, you can set their connection properties here.
        public let connectionName: String?
        /// A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler.
        public let exclusions: [String]?
        /// The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata folder in your Amazon S3 path. Used to limit the crawler run time.
        public let maximumTraversalDepth: Int?
        /// An array of Amazon S3 location strings for Hudi, each indicating the root folder with which the metadata files for a Hudi table resides. The Hudi folder may be located in a child folder of the root folder. The crawler will scan all folders underneath a path for a Hudi folder.
        public let paths: [String]?

        @inlinable
        public init(connectionName: String? = nil, exclusions: [String]? = nil, maximumTraversalDepth: Int? = nil, paths: [String]? = nil) {
            self.connectionName = connectionName
            self.exclusions = exclusions
            self.maximumTraversalDepth = maximumTraversalDepth
            self.paths = paths
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case exclusions = "Exclusions"
            case maximumTraversalDepth = "MaximumTraversalDepth"
            case paths = "Paths"
        }
    }

    public struct IcebergCompactionMetrics: AWSDecodableShape {
        /// The number of DPU hours consumed by the job.
        public let dpuHours: Double?
        /// The duration of the job in hours.
        public let jobDurationInHour: Double?
        /// The number of bytes removed by the compaction job run.
        public let numberOfBytesCompacted: Int64?
        /// The number of DPUs consumed by the job, rounded up to the nearest whole number.
        public let numberOfDpus: Int?
        /// The number of files removed by the compaction job run.
        public let numberOfFilesCompacted: Int64?

        @inlinable
        public init(dpuHours: Double? = nil, jobDurationInHour: Double? = nil, numberOfBytesCompacted: Int64? = nil, numberOfDpus: Int? = nil, numberOfFilesCompacted: Int64? = nil) {
            self.dpuHours = dpuHours
            self.jobDurationInHour = jobDurationInHour
            self.numberOfBytesCompacted = numberOfBytesCompacted
            self.numberOfDpus = numberOfDpus
            self.numberOfFilesCompacted = numberOfFilesCompacted
        }

        private enum CodingKeys: String, CodingKey {
            case dpuHours = "DpuHours"
            case jobDurationInHour = "JobDurationInHour"
            case numberOfBytesCompacted = "NumberOfBytesCompacted"
            case numberOfDpus = "NumberOfDpus"
            case numberOfFilesCompacted = "NumberOfFilesCompacted"
        }
    }

    public struct IcebergInput: AWSEncodableShape {
        /// A required metadata operation. Can only be set to CREATE.
        public let metadataOperation: MetadataOperation
        /// The table version for the Iceberg table. Defaults to 2.
        public let version: String?

        @inlinable
        public init(metadataOperation: MetadataOperation, version: String? = nil) {
            self.metadataOperation = metadataOperation
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.version, name: "version", parent: name, max: 255)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataOperation = "MetadataOperation"
            case version = "Version"
        }
    }

    public struct IcebergOrphanFileDeletionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies a directory in which to look for files (defaults to the table's location). You may choose a sub-directory rather than the top-level table location.
        public let location: String?
        /// The number of days that orphan files should be retained before file deletion. If an input is not provided, the default value 3 will be used.
        public let orphanFileRetentionPeriodInDays: Int?

        @inlinable
        public init(location: String? = nil, orphanFileRetentionPeriodInDays: Int? = nil) {
            self.location = location
            self.orphanFileRetentionPeriodInDays = orphanFileRetentionPeriodInDays
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
            case orphanFileRetentionPeriodInDays = "orphanFileRetentionPeriodInDays"
        }
    }

    public struct IcebergOrphanFileDeletionMetrics: AWSDecodableShape {
        /// The number of DPU hours consumed by the job.
        public let dpuHours: Double?
        /// The duration of the job in hours.
        public let jobDurationInHour: Double?
        /// The number of DPUs consumed by the job, rounded up to the nearest whole number.
        public let numberOfDpus: Int?
        /// The number of orphan files deleted by the orphan file deletion job run.
        public let numberOfOrphanFilesDeleted: Int64?

        @inlinable
        public init(dpuHours: Double? = nil, jobDurationInHour: Double? = nil, numberOfDpus: Int? = nil, numberOfOrphanFilesDeleted: Int64? = nil) {
            self.dpuHours = dpuHours
            self.jobDurationInHour = jobDurationInHour
            self.numberOfDpus = numberOfDpus
            self.numberOfOrphanFilesDeleted = numberOfOrphanFilesDeleted
        }

        private enum CodingKeys: String, CodingKey {
            case dpuHours = "DpuHours"
            case jobDurationInHour = "JobDurationInHour"
            case numberOfDpus = "NumberOfDpus"
            case numberOfOrphanFilesDeleted = "NumberOfOrphanFilesDeleted"
        }
    }

    public struct IcebergRetentionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// If set to false, snapshots are only deleted from table metadata, and the underlying data and metadata files are not deleted.
        public let cleanExpiredFiles: Bool?
        /// The number of Iceberg snapshots to retain within the retention period. If an input is not provided, the corresponding Iceberg table configuration field will be used or if not present, the default value 1 will be used.
        public let numberOfSnapshotsToRetain: Int?
        /// The number of days to retain the Iceberg snapshots. If an input is not provided, the corresponding Iceberg table configuration field will be used or if not present, the default value 5 will be used.
        public let snapshotRetentionPeriodInDays: Int?

        @inlinable
        public init(cleanExpiredFiles: Bool? = nil, numberOfSnapshotsToRetain: Int? = nil, snapshotRetentionPeriodInDays: Int? = nil) {
            self.cleanExpiredFiles = cleanExpiredFiles
            self.numberOfSnapshotsToRetain = numberOfSnapshotsToRetain
            self.snapshotRetentionPeriodInDays = snapshotRetentionPeriodInDays
        }

        private enum CodingKeys: String, CodingKey {
            case cleanExpiredFiles = "cleanExpiredFiles"
            case numberOfSnapshotsToRetain = "numberOfSnapshotsToRetain"
            case snapshotRetentionPeriodInDays = "snapshotRetentionPeriodInDays"
        }
    }

    public struct IcebergRetentionMetrics: AWSDecodableShape {
        /// The number of DPU hours consumed by the job.
        public let dpuHours: Double?
        /// The duration of the job in hours.
        public let jobDurationInHour: Double?
        /// The number of data files deleted by the retention job run.
        public let numberOfDataFilesDeleted: Int64?
        /// The number of DPUs consumed by the job, rounded up to the nearest whole number.
        public let numberOfDpus: Int?
        /// The number of manifest files deleted by the retention job run.
        public let numberOfManifestFilesDeleted: Int64?
        /// The number of manifest lists deleted by the retention job run.
        public let numberOfManifestListsDeleted: Int64?

        @inlinable
        public init(dpuHours: Double? = nil, jobDurationInHour: Double? = nil, numberOfDataFilesDeleted: Int64? = nil, numberOfDpus: Int? = nil, numberOfManifestFilesDeleted: Int64? = nil, numberOfManifestListsDeleted: Int64? = nil) {
            self.dpuHours = dpuHours
            self.jobDurationInHour = jobDurationInHour
            self.numberOfDataFilesDeleted = numberOfDataFilesDeleted
            self.numberOfDpus = numberOfDpus
            self.numberOfManifestFilesDeleted = numberOfManifestFilesDeleted
            self.numberOfManifestListsDeleted = numberOfManifestListsDeleted
        }

        private enum CodingKeys: String, CodingKey {
            case dpuHours = "DpuHours"
            case jobDurationInHour = "JobDurationInHour"
            case numberOfDataFilesDeleted = "NumberOfDataFilesDeleted"
            case numberOfDpus = "NumberOfDpus"
            case numberOfManifestFilesDeleted = "NumberOfManifestFilesDeleted"
            case numberOfManifestListsDeleted = "NumberOfManifestListsDeleted"
        }
    }

    public struct IcebergTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection to use to connect to the Iceberg target.
        public let connectionName: String?
        /// A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler.
        public let exclusions: [String]?
        /// The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Iceberg metadata folder in your Amazon S3 path. Used to limit the crawler run time.
        public let maximumTraversalDepth: Int?
        /// One or more Amazon S3 paths that contains Iceberg metadata folders as s3://bucket/prefix.
        public let paths: [String]?

        @inlinable
        public init(connectionName: String? = nil, exclusions: [String]? = nil, maximumTraversalDepth: Int? = nil, paths: [String]? = nil) {
            self.connectionName = connectionName
            self.exclusions = exclusions
            self.maximumTraversalDepth = maximumTraversalDepth
            self.paths = paths
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case exclusions = "Exclusions"
            case maximumTraversalDepth = "MaximumTraversalDepth"
            case paths = "Paths"
        }
    }

    public struct ImportCatalogToGlueRequest: AWSEncodableShape {
        /// The ID of the catalog to import. Currently, this should be the Amazon Web Services account ID.
        public let catalogId: String?

        @inlinable
        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct ImportCatalogToGlueResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ImportLabelsTaskRunProperties: AWSDecodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path from where you will import the labels.
        public let inputS3Path: String?
        /// Indicates whether to overwrite your existing labels.
        public let replace: Bool?

        @inlinable
        public init(inputS3Path: String? = nil, replace: Bool? = nil) {
            self.inputS3Path = inputS3Path
            self.replace = replace
        }

        private enum CodingKeys: String, CodingKey {
            case inputS3Path = "InputS3Path"
            case replace = "Replace"
        }
    }

    public struct InboundIntegration: AWSDecodableShape {
        /// The time that the integration was created, in UTC.
        public let createTime: Date
        /// A list of errors associated with the integration.
        public let errors: [IntegrationError]?
        /// The ARN of the zero-ETL integration.
        public let integrationArn: String
        /// The ARN of the source resource for the integration.
        public let sourceArn: String
        /// The possible statuses are:   CREATING: The integration is being created.   ACTIVE: The integration creation succeeds.   MODIFYING: The integration is being modified.   FAILED: The integration creation fails.    DELETING: The integration is deleted.   SYNCING: The integration is synchronizing.   NEEDS_ATTENTION: The integration needs attention, such as synchronization.
        public let status: IntegrationStatus
        /// The ARN of the target resource for the integration.
        public let targetArn: String

        @inlinable
        public init(createTime: Date, errors: [IntegrationError]? = nil, integrationArn: String, sourceArn: String, status: IntegrationStatus, targetArn: String) {
            self.createTime = createTime
            self.errors = errors
            self.integrationArn = integrationArn
            self.sourceArn = sourceArn
            self.status = status
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case errors = "Errors"
            case integrationArn = "IntegrationArn"
            case sourceArn = "SourceArn"
            case status = "Status"
            case targetArn = "TargetArn"
        }
    }

    public struct Integration: AWSDecodableShape {
        /// An optional set of non-secret keyvalue pairs that contains additional contextual information for encryption. This can only be provided if KMSKeyId is provided.
        public let additionalEncryptionContext: [String: String]?
        /// The time that the integration was created, in UTC.
        public let createTime: Date
        /// Selects source tables for the integration using Maxwell filter syntax.
        public let dataFilter: String?
        /// A description for the integration.
        public let description: String?
        /// A list of errors associated with the integration.
        public let errors: [IntegrationError]?
        /// The Amazon Resource Name (ARN) for the integration.
        public let integrationArn: String
        /// A unique name for the integration.
        public let integrationName: String
        /// The ARN of a KMS key used for encrypting the channel.
        public let kmsKeyId: String?
        /// The ARN for the source of the integration.
        public let sourceArn: String
        /// The possible statuses are:   CREATING: The integration is being created.   ACTIVE: The integration creation succeeds.   MODIFYING: The integration is being modified.   FAILED: The integration creation fails.    DELETING: The integration is deleted.   SYNCING: The integration is synchronizing.   NEEDS_ATTENTION: The integration needs attention, such as synchronization.
        public let status: IntegrationStatus
        /// Metadata assigned to the resource consisting of a list of key-value pairs.
        public let tags: [Tag]?
        /// The ARN for the target of the integration.
        public let targetArn: String

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, createTime: Date, dataFilter: String? = nil, description: String? = nil, errors: [IntegrationError]? = nil, integrationArn: String, integrationName: String, kmsKeyId: String? = nil, sourceArn: String, status: IntegrationStatus, tags: [Tag]? = nil, targetArn: String) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.createTime = createTime
            self.dataFilter = dataFilter
            self.description = description
            self.errors = errors
            self.integrationArn = integrationArn
            self.integrationName = integrationName
            self.kmsKeyId = kmsKeyId
            self.sourceArn = sourceArn
            self.status = status
            self.tags = tags
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "AdditionalEncryptionContext"
            case createTime = "CreateTime"
            case dataFilter = "DataFilter"
            case description = "Description"
            case errors = "Errors"
            case integrationArn = "IntegrationArn"
            case integrationName = "IntegrationName"
            case kmsKeyId = "KmsKeyId"
            case sourceArn = "SourceArn"
            case status = "Status"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct IntegrationError: AWSDecodableShape {
        /// The code associated with this error.
        public let errorCode: String?
        /// A message describing the error.
        public let errorMessage: String?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct IntegrationFilter: AWSEncodableShape {
        /// The name of the filter.
        public let name: String?
        /// A list of filter values.
        public let values: [String]?

        @inlinable
        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct IntegrationPartition: AWSEncodableShape & AWSDecodableShape {
        /// The field name used to partition data on the target.
        public let fieldName: String?
        /// Specifies a function used to partition data on the target.
        public let functionSpec: String?

        @inlinable
        public init(fieldName: String? = nil, functionSpec: String? = nil) {
            self.fieldName = fieldName
            self.functionSpec = functionSpec
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 128)
            try self.validate(self.fieldName, name: "fieldName", parent: name, min: 1)
            try self.validate(self.functionSpec, name: "functionSpec", parent: name, max: 128)
            try self.validate(self.functionSpec, name: "functionSpec", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "FieldName"
            case functionSpec = "FunctionSpec"
        }
    }

    public struct InvalidInputException: AWSErrorShape {
        /// Indicates whether or not the exception relates to a federated source.
        public let fromFederationSource: Bool?
        /// A message describing the problem.
        public let message: String?

        @inlinable
        public init(fromFederationSource: Bool? = nil, message: String? = nil) {
            self.fromFederationSource = fromFederationSource
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case fromFederationSource = "FromFederationSource"
            case message = "Message"
        }
    }

    public struct JDBCConnectorOptions: AWSEncodableShape & AWSDecodableShape {
        /// Custom data type mapping that builds a mapping from a JDBC data type to an Glue data type. For example, the option "dataTypeMapping":{"FLOAT":"STRING"} maps data fields of JDBC type FLOAT into the Java String type by calling the ResultSet.getString() method of the driver, and uses it to build the Glue record. The ResultSet object is implemented by each driver, so the behavior is specific to the driver you use. Refer to the documentation for your JDBC driver to understand how the driver performs the conversions.
        public let dataTypeMapping: [JDBCDataType: GlueRecordType]?
        /// Extra condition clause to filter data from source. For example:  BillingCity='Mountain View'  When using a query instead of a table name, you should validate that the query works with the specified filterPredicate.
        public let filterPredicate: String?
        /// The name of the job bookmark keys on which to sort.
        public let jobBookmarkKeys: [String]?
        /// Specifies an ascending or descending sort order.
        public let jobBookmarkKeysSortOrder: String?
        /// The minimum value of partitionColumn that is used to decide partition stride.
        public let lowerBound: Int64?
        /// The number of partitions. This value, along with lowerBound (inclusive) and upperBound (exclusive), form partition strides for generated WHERE clause expressions that are used to split the partitionColumn.
        public let numPartitions: Int64?
        /// The name of an integer column that is used for partitioning. This option works only when it's included with lowerBound, upperBound, and numPartitions. This option works the same way as in the Spark SQL JDBC reader.
        public let partitionColumn: String?
        /// The maximum value of partitionColumn that is used to decide partition stride.
        public let upperBound: Int64?

        @inlinable
        public init(dataTypeMapping: [JDBCDataType: GlueRecordType]? = nil, filterPredicate: String? = nil, jobBookmarkKeys: [String]? = nil, jobBookmarkKeysSortOrder: String? = nil, lowerBound: Int64? = nil, numPartitions: Int64? = nil, partitionColumn: String? = nil, upperBound: Int64? = nil) {
            self.dataTypeMapping = dataTypeMapping
            self.filterPredicate = filterPredicate
            self.jobBookmarkKeys = jobBookmarkKeys
            self.jobBookmarkKeysSortOrder = jobBookmarkKeysSortOrder
            self.lowerBound = lowerBound
            self.numPartitions = numPartitions
            self.partitionColumn = partitionColumn
            self.upperBound = upperBound
        }

        public func validate(name: String) throws {
            try self.validate(self.filterPredicate, name: "filterPredicate", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.jobBookmarkKeys?.forEach {
                try validate($0, name: "jobBookmarkKeys[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.jobBookmarkKeysSortOrder, name: "jobBookmarkKeysSortOrder", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.lowerBound, name: "lowerBound", parent: name, min: 0)
            try self.validate(self.numPartitions, name: "numPartitions", parent: name, min: 0)
            try self.validate(self.partitionColumn, name: "partitionColumn", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.upperBound, name: "upperBound", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dataTypeMapping = "DataTypeMapping"
            case filterPredicate = "FilterPredicate"
            case jobBookmarkKeys = "JobBookmarkKeys"
            case jobBookmarkKeysSortOrder = "JobBookmarkKeysSortOrder"
            case lowerBound = "LowerBound"
            case numPartitions = "NumPartitions"
            case partitionColumn = "PartitionColumn"
            case upperBound = "UpperBound"
        }
    }

    public struct JDBCConnectorSource: AWSEncodableShape & AWSDecodableShape {
        /// Additional connection options for the connector.
        public let additionalOptions: JDBCConnectorOptions?
        /// The name of the connection that is associated with the connector.
        public let connectionName: String
        /// The name of the table in the data source.
        public let connectionTable: String?
        /// The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data store.
        public let connectionType: String
        /// The name of a connector that assists with accessing the data store in Glue Studio.
        public let connectorName: String
        /// The name of the data source.
        public let name: String
        /// Specifies the data schema for the custom JDBC source.
        public let outputSchemas: [GlueSchema]?
        /// The table or SQL query to get the data from. You can specify either ConnectionTable or query, but not both.
        public let query: String?

        @inlinable
        public init(additionalOptions: JDBCConnectorOptions? = nil, connectionName: String, connectionTable: String? = nil, connectionType: String, connectorName: String, name: String, outputSchemas: [GlueSchema]? = nil, query: String? = nil) {
            self.additionalOptions = additionalOptions
            self.connectionName = connectionName
            self.connectionTable = connectionTable
            self.connectionType = connectionType
            self.connectorName = connectorName
            self.name = name
            self.outputSchemas = outputSchemas
            self.query = query
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.validate(name: "\(name).additionalOptions")
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectionTable, name: "connectionTable", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectionType, name: "connectionType", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectorName, name: "connectorName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.validate(self.query, name: "query", parent: name, pattern: "^([\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\s])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case connectionName = "ConnectionName"
            case connectionTable = "ConnectionTable"
            case connectionType = "ConnectionType"
            case connectorName = "ConnectorName"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case query = "Query"
        }
    }

    public struct JDBCConnectorTarget: AWSEncodableShape & AWSDecodableShape {
        /// Additional connection options for the connector.
        public let additionalOptions: [String: String]?
        /// The name of the connection that is associated with the connector.
        public let connectionName: String
        /// The name of the table in the data target.
        public let connectionTable: String
        /// The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC data target.
        public let connectionType: String
        /// The name of a connector that will be used.
        public let connectorName: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// Specifies the data schema for the JDBC target.
        public let outputSchemas: [GlueSchema]?

        @inlinable
        public init(additionalOptions: [String: String]? = nil, connectionName: String, connectionTable: String, connectionType: String, connectorName: String, inputs: [String], name: String, outputSchemas: [GlueSchema]? = nil) {
            self.additionalOptions = additionalOptions
            self.connectionName = connectionName
            self.connectionTable = connectionTable
            self.connectionType = connectionType
            self.connectorName = connectorName
            self.inputs = inputs
            self.name = name
            self.outputSchemas = outputSchemas
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.forEach {
                try validate($0.key, name: "additionalOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectionTable, name: "connectionTable", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectionType, name: "connectionType", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectorName, name: "connectorName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case connectionName = "ConnectionName"
            case connectionTable = "ConnectionTable"
            case connectionType = "ConnectionType"
            case connectorName = "ConnectorName"
            case inputs = "Inputs"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
        }
    }

    public struct JdbcTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection to use to connect to the JDBC target.
        public let connectionName: String?
        /// Specify a value of RAWTYPES or COMMENTS to enable additional metadata in table responses. RAWTYPES provides the native-level datatype. COMMENTS provides comments associated with a column or table in the database. If you do not need additional metadata, keep the field empty.
        public let enableAdditionalMetadata: [JdbcMetadataEntry]?
        /// A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler.
        public let exclusions: [String]?
        /// The path of the JDBC target.
        public let path: String?

        @inlinable
        public init(connectionName: String? = nil, enableAdditionalMetadata: [JdbcMetadataEntry]? = nil, exclusions: [String]? = nil, path: String? = nil) {
            self.connectionName = connectionName
            self.enableAdditionalMetadata = enableAdditionalMetadata
            self.exclusions = exclusions
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case enableAdditionalMetadata = "EnableAdditionalMetadata"
            case exclusions = "Exclusions"
            case path = "Path"
        }
    }

    public struct Job: AWSDecodableShape {
        /// This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs) allocated to runs of this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.
        public let allocatedCapacity: Int?
        /// The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.
        public let codeGenConfigurationNodes: [String: CodeGenConfigurationNode]?
        /// The JobCommand that runs this job.
        public let command: JobCommand?
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// The time and date that this job definition was created.
        public let createdOn: Date?
        /// The default arguments for every run of this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job.  For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see Using job parameters in Ray jobs in the developer guide.
        public let defaultArguments: [String: String]?
        /// A description of the job.
        public let description: String?
        /// Indicates whether the job is run with a standard or flexible execution class. The standard execution class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary.  Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
        public let executionClass: ExecutionClass?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark.  Ray jobs should set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the Runtime parameter of the Job command. For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
        public let glueVersion: String?
        /// A mode that describes how a job was created. Valid values are:    SCRIPT - The job was created using the Glue Studio script editor.    VISUAL - The job was created using the Glue Studio visual editor.    NOTEBOOK - The job was created using an interactive sessions notebook.   When the JobMode field is missing or null, SCRIPT is assigned as the default value.
        public let jobMode: JobMode?
        /// Specifies whether job run queuing is enabled for the job runs for this job. A value of true means job run queuing is enabled for the job runs. If false or not populated, the job runs will not be considered for queueing. If this field does not match the value set in the job run, then the value from the job run field will be used.
        public let jobRunQueuingEnabled: Bool?
        /// The last point in time when this job definition was modified.
        public let lastModifiedOn: Date?
        /// This field is reserved for future use.
        public let logUri: String?
        /// This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue periodically performs maintenance activities. During these maintenance windows, Glue will need to restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will be restarted between 10:00AM GMT to 1:00PM GMT.
        public let maintenanceWindow: String?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the  Glue pricing page. For Glue version 2.0 or later jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache  Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs.  The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
        public let maxCapacity: Double?
        /// The maximum number of times to retry this job after a JobRun fails.
        public let maxRetries: Int?
        /// The name you assign to this job definition.
        public let name: String?
        /// Arguments for this job that are not overridden when providing job arguments in a job run, specified as name-value pairs.
        public let nonOverridableArguments: [String: String]?
        /// Specifies configuration properties of a job notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs.
        public let numberOfWorkers: Int?
        /// The name of an Glue usage profile associated with the job.
        public let profileName: String?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
        public let role: String?
        /// The name of the SecurityConfiguration structure to be used with this job.
        public let securityConfiguration: String?
        /// The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.
        public let sourceControlDetails: SourceControlDetails?
        /// The job timeout in minutes.  This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. Jobs must have timeout values less than 7 days or 10080 minutes. Otherwise, the jobs will throw an exception. When the value is left blank, the timeout is defaulted to 2880 minutes. Any existing Glue jobs that had a timeout value greater than 7 days will be defaulted to 7 days. For instance if you have specified a timeout of 20 days for a batch job, it will be stopped on the 7th day. For streaming jobs, if you have set up a maintenance window, it will be restarted during the maintenance window after 7 days.
        public let timeout: Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 94GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 138GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).   For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.   For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk, and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 or later streaming jobs.   For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk, and provides up to 8 Ray workers based on the autoscaler.
        public let workerType: WorkerType?

        @inlinable
        public init(codeGenConfigurationNodes: [String: CodeGenConfigurationNode]? = nil, command: JobCommand? = nil, connections: ConnectionsList? = nil, createdOn: Date? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionClass: ExecutionClass? = nil, executionProperty: ExecutionProperty? = nil, glueVersion: String? = nil, jobMode: JobMode? = nil, jobRunQueuingEnabled: Bool? = nil, lastModifiedOn: Date? = nil, logUri: String? = nil, maintenanceWindow: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String? = nil, nonOverridableArguments: [String: String]? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, profileName: String? = nil, role: String? = nil, securityConfiguration: String? = nil, sourceControlDetails: SourceControlDetails? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.allocatedCapacity = nil
            self.codeGenConfigurationNodes = codeGenConfigurationNodes
            self.command = command
            self.connections = connections
            self.createdOn = createdOn
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionClass = executionClass
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.jobMode = jobMode
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.lastModifiedOn = lastModifiedOn
            self.logUri = logUri
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.profileName = profileName
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.sourceControlDetails = sourceControlDetails
            self.timeout = timeout
            self.workerType = workerType
        }

        @available(*, deprecated, message: "Members allocatedCapacity have been deprecated")
        @inlinable
        public init(allocatedCapacity: Int? = nil, codeGenConfigurationNodes: [String: CodeGenConfigurationNode]? = nil, command: JobCommand? = nil, connections: ConnectionsList? = nil, createdOn: Date? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionClass: ExecutionClass? = nil, executionProperty: ExecutionProperty? = nil, glueVersion: String? = nil, jobMode: JobMode? = nil, jobRunQueuingEnabled: Bool? = nil, lastModifiedOn: Date? = nil, logUri: String? = nil, maintenanceWindow: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String? = nil, nonOverridableArguments: [String: String]? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, profileName: String? = nil, role: String? = nil, securityConfiguration: String? = nil, sourceControlDetails: SourceControlDetails? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.allocatedCapacity = allocatedCapacity
            self.codeGenConfigurationNodes = codeGenConfigurationNodes
            self.command = command
            self.connections = connections
            self.createdOn = createdOn
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionClass = executionClass
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.jobMode = jobMode
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.lastModifiedOn = lastModifiedOn
            self.logUri = logUri
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.profileName = profileName
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.sourceControlDetails = sourceControlDetails
            self.timeout = timeout
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedCapacity = "AllocatedCapacity"
            case codeGenConfigurationNodes = "CodeGenConfigurationNodes"
            case command = "Command"
            case connections = "Connections"
            case createdOn = "CreatedOn"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case executionClass = "ExecutionClass"
            case executionProperty = "ExecutionProperty"
            case glueVersion = "GlueVersion"
            case jobMode = "JobMode"
            case jobRunQueuingEnabled = "JobRunQueuingEnabled"
            case lastModifiedOn = "LastModifiedOn"
            case logUri = "LogUri"
            case maintenanceWindow = "MaintenanceWindow"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case nonOverridableArguments = "NonOverridableArguments"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case profileName = "ProfileName"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case sourceControlDetails = "SourceControlDetails"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct JobBookmarkEntry: AWSDecodableShape {
        /// The attempt ID number.
        public let attempt: Int?
        /// The bookmark itself.
        public let jobBookmark: String?
        /// The name of the job in question.
        public let jobName: String?
        /// The unique run identifier associated with the previous job run.
        public let previousRunId: String?
        /// The run ID number.
        public let run: Int?
        /// The run ID number.
        public let runId: String?
        /// The version of the job.
        public let version: Int?

        @inlinable
        public init(attempt: Int? = nil, jobBookmark: String? = nil, jobName: String? = nil, previousRunId: String? = nil, run: Int? = nil, runId: String? = nil, version: Int? = nil) {
            self.attempt = attempt
            self.jobBookmark = jobBookmark
            self.jobName = jobName
            self.previousRunId = previousRunId
            self.run = run
            self.runId = runId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case attempt = "Attempt"
            case jobBookmark = "JobBookmark"
            case jobName = "JobName"
            case previousRunId = "PreviousRunId"
            case run = "Run"
            case runId = "RunId"
            case version = "Version"
        }
    }

    public struct JobBookmarksEncryption: AWSEncodableShape & AWSDecodableShape {
        /// The encryption mode to use for job bookmarks data.
        public let jobBookmarksEncryptionMode: JobBookmarksEncryptionMode?
        /// The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        public let kmsKeyArn: String?

        @inlinable
        public init(jobBookmarksEncryptionMode: JobBookmarksEncryptionMode? = nil, kmsKeyArn: String? = nil) {
            self.jobBookmarksEncryptionMode = jobBookmarksEncryptionMode
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:")
        }

        private enum CodingKeys: String, CodingKey {
            case jobBookmarksEncryptionMode = "JobBookmarksEncryptionMode"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct JobCommand: AWSEncodableShape & AWSDecodableShape {
        /// The name of the job command. For an Apache Spark ETL job, this must be glueetl. For a Python shell job, it must be pythonshell.  For an Apache Spark streaming ETL job, this must be gluestreaming. For a Ray job, this must be glueray.
        public let name: String?
        /// The Python version being used to run a Python shell job. Allowed values are 2 or 3.
        public let pythonVersion: String?
        /// In Ray jobs, Runtime is used to specify the versions of Ray, Python and additional libraries available in your environment. This field is not used in other job types. For supported runtime environment values, see Supported Ray runtime environments in the Glue Developer Guide.
        public let runtime: String?
        /// Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that runs a job.
        public let scriptLocation: String?

        @inlinable
        public init(name: String? = nil, pythonVersion: String? = nil, runtime: String? = nil, scriptLocation: String? = nil) {
            self.name = name
            self.pythonVersion = pythonVersion
            self.runtime = runtime
            self.scriptLocation = scriptLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.pythonVersion, name: "pythonVersion", parent: name, pattern: "^([2-3]|3[.]9)$")
            try self.validate(self.runtime, name: "runtime", parent: name, max: 64)
            try self.validate(self.runtime, name: "runtime", parent: name, pattern: ".*")
            try self.validate(self.scriptLocation, name: "scriptLocation", parent: name, max: 400000)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case pythonVersion = "PythonVersion"
            case runtime = "Runtime"
            case scriptLocation = "ScriptLocation"
        }
    }

    public struct JobNodeDetails: AWSDecodableShape {
        /// The information for the job runs represented by the job node.
        public let jobRuns: [JobRun]?

        @inlinable
        public init(jobRuns: [JobRun]? = nil) {
            self.jobRuns = jobRuns
        }

        private enum CodingKeys: String, CodingKey {
            case jobRuns = "JobRuns"
        }
    }

    public struct JobRun: AWSDecodableShape {
        /// This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs) allocated to this JobRun. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.
        public let allocatedCapacity: Int?
        /// The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job.  For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see Using job parameters in Ray jobs in the developer guide.
        public let arguments: [String: String]?
        /// The number of the attempt to run this job.
        public let attempt: Int?
        /// The date and time that this job run completed.
        public let completedOn: Date?
        /// This field can be set for either job runs with execution class FLEX or when Auto Scaling is enabled, and represents the total time each executor ran during the lifecycle of a job run in seconds, multiplied by a DPU factor (1 for G.1X, 2 for G.2X, or 0.25 for G.025X workers). This value may be different than the executionEngineRuntime * MaxCapacity as in the case of Auto Scaling jobs, as the number of executors running at a given time may be less than the MaxCapacity. Therefore, it is possible that the value of DPUSeconds is less than executionEngineRuntime * MaxCapacity.
        public let dpuSeconds: Double?
        /// An error message associated with this job run.
        public let errorMessage: String?
        /// Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary.  Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
        public let executionClass: ExecutionClass?
        /// The amount of time (in seconds) that the job run consumed resources.
        public let executionTime: Int?
        /// In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark.  Ray jobs should set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the Runtime parameter of the Job command. For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
        public let glueVersion: String?
        /// The ID of this job run.
        public let id: String?
        /// A mode that describes how a job was created. Valid values are:    SCRIPT - The job was created using the Glue Studio script editor.    VISUAL - The job was created using the Glue Studio visual editor.    NOTEBOOK - The job was created using an interactive sessions notebook.   When the JobMode field is missing or null, SCRIPT is assigned as the default value.
        public let jobMode: JobMode?
        /// The name of the job definition being used in this run.
        public let jobName: String?
        /// Specifies whether job run queuing is enabled for the job run. A value of true means job run queuing is enabled for the job run. If false or not populated, the job run will not be considered for queueing.
        public let jobRunQueuingEnabled: Bool?
        /// The current state of the job run. For more information about the statuses of jobs that have terminated abnormally, see Glue Job Run Statuses.
        public let jobRunState: JobRunState?
        /// The last time that this job run was modified.
        public let lastModifiedOn: Date?
        /// The name of the log group for secure logging that can be server-side encrypted in Amazon CloudWatch using KMS. This name can be /aws-glue/jobs/, in which case the default encryption is NONE. If you add a role name and SecurityConfiguration name (in other words, /aws-glue/jobs-yourRoleName-yourSecurityConfigurationName/), then that security configuration is used to encrypt the log group.
        public let logGroupName: String?
        /// This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue periodically performs maintenance activities. During these maintenance windows, Glue will need to restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will be restarted between 10:00AM GMT to 1:00PM GMT.
        public let maintenanceWindow: String?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the  Glue pricing page. For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache  Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs.  The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
        public let maxCapacity: Double?
        /// Specifies configuration properties of a job run notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs.
        public let numberOfWorkers: Int?
        /// A list of predecessors to this job run.
        public let predecessorRuns: [Predecessor]?
        /// The ID of the previous run of this job. For example, the JobRunId specified in the StartJobRun action.
        public let previousRunId: String?
        /// The name of an Glue usage profile associated with the job run.
        public let profileName: String?
        /// The name of the SecurityConfiguration structure to be used with this job run.
        public let securityConfiguration: String?
        /// The date and time at which this job run was started.
        public let startedOn: Date?
        /// This field holds details that pertain to the state of a job run. The field is nullable. For example, when a job run is in a WAITING state as a result of job run queuing, the field has the reason why the job run is in that state.
        public let stateDetail: String?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. This value overrides the timeout value set in the parent job. Jobs must have timeout values less than 7 days or 10080 minutes. Otherwise, the jobs will throw an exception. When the value is left blank, the timeout is defaulted to 2880 minutes. Any existing Glue jobs that had a timeout value greater than 7 days will be defaulted to 7 days. For instance if you have specified a timeout of 20 days for a batch job, it will be stopped on the 7th day. For streaming jobs, if you have set up a maintenance window, it will be restarted during the maintenance window after 7 days.
        public let timeout: Int?
        /// The name of the trigger that started this job run.
        public let triggerName: String?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 94GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 138GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).   For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.   For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk, and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 or later streaming jobs.   For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk, and provides up to 8 Ray workers based on the autoscaler.
        public let workerType: WorkerType?

        @inlinable
        public init(arguments: [String: String]? = nil, attempt: Int? = nil, completedOn: Date? = nil, dpuSeconds: Double? = nil, errorMessage: String? = nil, executionClass: ExecutionClass? = nil, executionTime: Int? = nil, glueVersion: String? = nil, id: String? = nil, jobMode: JobMode? = nil, jobName: String? = nil, jobRunQueuingEnabled: Bool? = nil, jobRunState: JobRunState? = nil, lastModifiedOn: Date? = nil, logGroupName: String? = nil, maintenanceWindow: String? = nil, maxCapacity: Double? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, predecessorRuns: [Predecessor]? = nil, previousRunId: String? = nil, profileName: String? = nil, securityConfiguration: String? = nil, startedOn: Date? = nil, stateDetail: String? = nil, timeout: Int? = nil, triggerName: String? = nil, workerType: WorkerType? = nil) {
            self.allocatedCapacity = nil
            self.arguments = arguments
            self.attempt = attempt
            self.completedOn = completedOn
            self.dpuSeconds = dpuSeconds
            self.errorMessage = errorMessage
            self.executionClass = executionClass
            self.executionTime = executionTime
            self.glueVersion = glueVersion
            self.id = id
            self.jobMode = jobMode
            self.jobName = jobName
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.jobRunState = jobRunState
            self.lastModifiedOn = lastModifiedOn
            self.logGroupName = logGroupName
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.predecessorRuns = predecessorRuns
            self.previousRunId = previousRunId
            self.profileName = profileName
            self.securityConfiguration = securityConfiguration
            self.startedOn = startedOn
            self.stateDetail = stateDetail
            self.timeout = timeout
            self.triggerName = triggerName
            self.workerType = workerType
        }

        @available(*, deprecated, message: "Members allocatedCapacity have been deprecated")
        @inlinable
        public init(allocatedCapacity: Int? = nil, arguments: [String: String]? = nil, attempt: Int? = nil, completedOn: Date? = nil, dpuSeconds: Double? = nil, errorMessage: String? = nil, executionClass: ExecutionClass? = nil, executionTime: Int? = nil, glueVersion: String? = nil, id: String? = nil, jobMode: JobMode? = nil, jobName: String? = nil, jobRunQueuingEnabled: Bool? = nil, jobRunState: JobRunState? = nil, lastModifiedOn: Date? = nil, logGroupName: String? = nil, maintenanceWindow: String? = nil, maxCapacity: Double? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, predecessorRuns: [Predecessor]? = nil, previousRunId: String? = nil, profileName: String? = nil, securityConfiguration: String? = nil, startedOn: Date? = nil, stateDetail: String? = nil, timeout: Int? = nil, triggerName: String? = nil, workerType: WorkerType? = nil) {
            self.allocatedCapacity = allocatedCapacity
            self.arguments = arguments
            self.attempt = attempt
            self.completedOn = completedOn
            self.dpuSeconds = dpuSeconds
            self.errorMessage = errorMessage
            self.executionClass = executionClass
            self.executionTime = executionTime
            self.glueVersion = glueVersion
            self.id = id
            self.jobMode = jobMode
            self.jobName = jobName
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.jobRunState = jobRunState
            self.lastModifiedOn = lastModifiedOn
            self.logGroupName = logGroupName
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.predecessorRuns = predecessorRuns
            self.previousRunId = previousRunId
            self.profileName = profileName
            self.securityConfiguration = securityConfiguration
            self.startedOn = startedOn
            self.stateDetail = stateDetail
            self.timeout = timeout
            self.triggerName = triggerName
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedCapacity = "AllocatedCapacity"
            case arguments = "Arguments"
            case attempt = "Attempt"
            case completedOn = "CompletedOn"
            case dpuSeconds = "DPUSeconds"
            case errorMessage = "ErrorMessage"
            case executionClass = "ExecutionClass"
            case executionTime = "ExecutionTime"
            case glueVersion = "GlueVersion"
            case id = "Id"
            case jobMode = "JobMode"
            case jobName = "JobName"
            case jobRunQueuingEnabled = "JobRunQueuingEnabled"
            case jobRunState = "JobRunState"
            case lastModifiedOn = "LastModifiedOn"
            case logGroupName = "LogGroupName"
            case maintenanceWindow = "MaintenanceWindow"
            case maxCapacity = "MaxCapacity"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case predecessorRuns = "PredecessorRuns"
            case previousRunId = "PreviousRunId"
            case profileName = "ProfileName"
            case securityConfiguration = "SecurityConfiguration"
            case startedOn = "StartedOn"
            case stateDetail = "StateDetail"
            case timeout = "Timeout"
            case triggerName = "TriggerName"
            case workerType = "WorkerType"
        }
    }

    public struct JobUpdate: AWSEncodableShape {
        /// This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs) to allocate to this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.
        public let allocatedCapacity: Int?
        /// The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.
        public let codeGenConfigurationNodes: [String: CodeGenConfigurationNode]?
        /// The JobCommand that runs this job (required).
        public let command: JobCommand?
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// The default arguments for every run of this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job.  For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see Using job parameters in Ray jobs in the developer guide.
        public let defaultArguments: [String: String]?
        /// Description of the job being defined.
        public let description: String?
        /// Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary.  Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
        public let executionClass: ExecutionClass?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark.  Ray jobs should set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the Runtime parameter of the Job command. For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
        public let glueVersion: String?
        /// A mode that describes how a job was created. Valid values are:    SCRIPT - The job was created using the Glue Studio script editor.    VISUAL - The job was created using the Glue Studio visual editor.    NOTEBOOK - The job was created using an interactive sessions notebook.   When the JobMode field is missing or null, SCRIPT is assigned as the default value.
        public let jobMode: JobMode?
        /// Specifies whether job run queuing is enabled for the job runs for this job. A value of true means job run queuing is enabled for the job runs. If false or not populated, the job runs will not be considered for queueing. If this field does not match the value set in the job run, then the value from the job run field will be used.
        public let jobRunQueuingEnabled: Bool?
        /// This field is reserved for future use.
        public let logUri: String?
        /// This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue periodically performs maintenance activities. During these maintenance windows, Glue will need to restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will be restarted between 10:00AM GMT to 1:00PM GMT.
        public let maintenanceWindow: String?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the  Glue pricing page. For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache  Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs.  The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
        public let maxCapacity: Double?
        /// The maximum number of times to retry this job if it fails.
        public let maxRetries: Int?
        /// Arguments for this job that are not overridden when providing job arguments in a job run, specified as name-value pairs.
        public let nonOverridableArguments: [String: String]?
        /// Specifies the configuration properties of a job notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs.
        public let numberOfWorkers: Int?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job (required).
        public let role: String?
        /// The name of the SecurityConfiguration structure to be used with this job.
        public let securityConfiguration: String?
        /// The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.
        public let sourceControlDetails: SourceControlDetails?
        /// The job timeout in minutes.  This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. Jobs must have timeout values less than 7 days or 10080 minutes. Otherwise, the jobs will throw an exception. When the value is left blank, the timeout is defaulted to 2880 minutes. Any existing Glue jobs that had a timeout value greater than 7 days will be defaulted to 7 days. For instance if you have specified a timeout of 20 days for a batch job, it will be stopped on the 7th day. For streaming jobs, if you have set up a maintenance window, it will be restarted during the maintenance window after 7 days.
        public let timeout: Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 94GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 138GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).   For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.   For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk, and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 or later streaming jobs.   For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk, and provides up to 8 Ray workers based on the autoscaler.
        public let workerType: WorkerType?

        @inlinable
        public init(codeGenConfigurationNodes: [String: CodeGenConfigurationNode]? = nil, command: JobCommand? = nil, connections: ConnectionsList? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionClass: ExecutionClass? = nil, executionProperty: ExecutionProperty? = nil, glueVersion: String? = nil, jobMode: JobMode? = nil, jobRunQueuingEnabled: Bool? = nil, logUri: String? = nil, maintenanceWindow: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, nonOverridableArguments: [String: String]? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, role: String? = nil, securityConfiguration: String? = nil, sourceControlDetails: SourceControlDetails? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.allocatedCapacity = nil
            self.codeGenConfigurationNodes = codeGenConfigurationNodes
            self.command = command
            self.connections = connections
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionClass = executionClass
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.jobMode = jobMode
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.logUri = logUri
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.sourceControlDetails = sourceControlDetails
            self.timeout = timeout
            self.workerType = workerType
        }

        @available(*, deprecated, message: "Members allocatedCapacity have been deprecated")
        @inlinable
        public init(allocatedCapacity: Int? = nil, codeGenConfigurationNodes: [String: CodeGenConfigurationNode]? = nil, command: JobCommand? = nil, connections: ConnectionsList? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionClass: ExecutionClass? = nil, executionProperty: ExecutionProperty? = nil, glueVersion: String? = nil, jobMode: JobMode? = nil, jobRunQueuingEnabled: Bool? = nil, logUri: String? = nil, maintenanceWindow: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, nonOverridableArguments: [String: String]? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, role: String? = nil, securityConfiguration: String? = nil, sourceControlDetails: SourceControlDetails? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.allocatedCapacity = allocatedCapacity
            self.codeGenConfigurationNodes = codeGenConfigurationNodes
            self.command = command
            self.connections = connections
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionClass = executionClass
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.jobMode = jobMode
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.logUri = logUri
            self.maintenanceWindow = maintenanceWindow
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.sourceControlDetails = sourceControlDetails
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.codeGenConfigurationNodes?.forEach {
                try validate($0.key, name: "codeGenConfigurationNodes.key", parent: name, pattern: "^[A-Za-z0-9_-]*$")
                try $0.value.validate(name: "\(name).codeGenConfigurationNodes[\"\($0.key)\"]")
            }
            try self.command?.validate(name: "\(name).command")
            try self.connections?.validate(name: "\(name).connections")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^(\\w+\\.)+\\w+$")
            try self.validate(self.maintenanceWindow, name: "maintenanceWindow", parent: name, pattern: "^(Sun|Mon|Tue|Wed|Thu|Fri|Sat):([01]?[0-9]|2[0-3])$")
            try self.notificationProperty?.validate(name: "\(name).notificationProperty")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.sourceControlDetails?.validate(name: "\(name).sourceControlDetails")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedCapacity = "AllocatedCapacity"
            case codeGenConfigurationNodes = "CodeGenConfigurationNodes"
            case command = "Command"
            case connections = "Connections"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case executionClass = "ExecutionClass"
            case executionProperty = "ExecutionProperty"
            case glueVersion = "GlueVersion"
            case jobMode = "JobMode"
            case jobRunQueuingEnabled = "JobRunQueuingEnabled"
            case logUri = "LogUri"
            case maintenanceWindow = "MaintenanceWindow"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case nonOverridableArguments = "NonOverridableArguments"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case sourceControlDetails = "SourceControlDetails"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct Join: AWSEncodableShape & AWSDecodableShape {
        /// A list of the two columns to be joined.
        public let columns: [JoinColumn]
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// Specifies the type of join to be performed on the datasets.
        public let joinType: JoinType
        /// The name of the transform node.
        public let name: String

        @inlinable
        public init(columns: [JoinColumn], inputs: [String], joinType: JoinType, name: String) {
            self.columns = columns
            self.inputs = inputs
            self.joinType = joinType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.columns.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.columns, name: "columns", parent: name, max: 2)
            try self.validate(self.columns, name: "columns", parent: name, min: 2)
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 2)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 2)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "Columns"
            case inputs = "Inputs"
            case joinType = "JoinType"
            case name = "Name"
        }
    }

    public struct JoinColumn: AWSEncodableShape & AWSDecodableShape {
        /// The column to be joined.
        public let from: String
        /// The key of the column to be joined.
        public let keys: [[String]]

        @inlinable
        public init(from: String, keys: [[String]]) {
            self.from = from
            self.keys = keys
        }

        public func validate(name: String) throws {
            try self.validate(self.from, name: "from", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case keys = "Keys"
        }
    }

    public struct JsonClassifier: AWSDecodableShape {
        /// The time that this classifier was registered.
        public let creationTime: Date?
        /// A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
        public let jsonPath: String
        /// The time that this classifier was last updated.
        public let lastUpdated: Date?
        /// The name of the classifier.
        public let name: String
        /// The version of this classifier.
        public let version: Int64?

        @inlinable
        public init(creationTime: Date? = nil, jsonPath: String, lastUpdated: Date? = nil, name: String, version: Int64? = nil) {
            self.creationTime = creationTime
            self.jsonPath = jsonPath
            self.lastUpdated = lastUpdated
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case jsonPath = "JsonPath"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct KafkaStreamingSourceOptions: AWSEncodableShape & AWSDecodableShape {
        /// When this option is set to 'true', the data output will contain an additional column named "__src_timestamp" that indicates the time when the corresponding record received by the topic. The default value is 'false'. This option is supported in Glue  version 4.0 or later.
        public let addRecordTimestamp: String?
        /// The specific TopicPartitions to consume. You must specify at least one of "topicName", "assign" or "subscribePattern".
        public let assign: String?
        /// A list of bootstrap server URLs, for example, as b-1.vpc-test-2.o4q88o.c6.kafka.us-east-1.amazonaws.com:9094. This option must be specified in the API call or defined in the table metadata in the Data Catalog.
        public let bootstrapServers: String?
        /// An optional classification.
        public let classification: String?
        /// The name of the connection.
        public let connectionName: String?
        /// Specifies the delimiter character.
        public let delimiter: String?
        /// When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the topic and the time it arrives in Glue to CloudWatch. The metric's name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is supported in Glue version 4.0 or later.
        public let emitConsumerLagMetrics: String?
        /// The end point when a batch query is ended. Possible values are either "latest" or a JSON string that specifies an ending offset for each TopicPartition.
        public let endingOffsets: String?
        /// Whether to include the Kafka headers. When the option is set to "true", the data output will contain an additional column named "glue_streaming_kafka_headers"  with type Array[Struct(key: String, value: String)]. The default value is "false".  This option is available in Glue version 3.0 or later only.
        public let includeHeaders: Bool?
        /// The rate limit on the maximum number of offsets that are processed per trigger interval. The specified total number of offsets is proportionally split across topicPartitions of different volumes. The default value is null, which means that the consumer reads all offsets until the known latest offset.
        public let maxOffsetsPerTrigger: Int64?
        /// The desired minimum number of partitions to read from Kafka. The default value is null, which means that the number of spark partitions is equal to the number of Kafka partitions.
        public let minPartitions: Int?
        /// The number of times to retry before failing to fetch Kafka offsets. The default value is 3.
        public let numRetries: Int?
        /// The timeout in milliseconds to poll data from Kafka in Spark job executors. The default value is 512.
        public let pollTimeoutMs: Int64?
        /// The time in milliseconds to wait before retrying to fetch Kafka offsets. The default value is 10.
        public let retryIntervalMs: Int64?
        /// The protocol used to communicate with brokers. The possible values are "SSL" or "PLAINTEXT".
        public let securityProtocol: String?
        /// The starting position in the Kafka topic to read data from. The possible values are "earliest" or "latest". The default value is "latest".
        public let startingOffsets: String?
        /// The timestamp of the record in the Kafka topic to start reading data from. The possible values are a timestamp string in UTC format of the pattern yyyy-mm-ddTHH:MM:SSZ (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00").  Only one of StartingTimestamp or StartingOffsets must be set.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startingTimestamp: Date?
        /// A Java regex string that identifies the topic list to subscribe to. You must specify at least one of "topicName", "assign" or "subscribePattern".
        public let subscribePattern: String?
        /// The topic name as specified in Apache Kafka. You must specify at least one of "topicName", "assign" or "subscribePattern".
        public let topicName: String?

        @inlinable
        public init(addRecordTimestamp: String? = nil, assign: String? = nil, bootstrapServers: String? = nil, classification: String? = nil, connectionName: String? = nil, delimiter: String? = nil, emitConsumerLagMetrics: String? = nil, endingOffsets: String? = nil, includeHeaders: Bool? = nil, maxOffsetsPerTrigger: Int64? = nil, minPartitions: Int? = nil, numRetries: Int? = nil, pollTimeoutMs: Int64? = nil, retryIntervalMs: Int64? = nil, securityProtocol: String? = nil, startingOffsets: String? = nil, startingTimestamp: Date? = nil, subscribePattern: String? = nil, topicName: String? = nil) {
            self.addRecordTimestamp = addRecordTimestamp
            self.assign = assign
            self.bootstrapServers = bootstrapServers
            self.classification = classification
            self.connectionName = connectionName
            self.delimiter = delimiter
            self.emitConsumerLagMetrics = emitConsumerLagMetrics
            self.endingOffsets = endingOffsets
            self.includeHeaders = includeHeaders
            self.maxOffsetsPerTrigger = maxOffsetsPerTrigger
            self.minPartitions = minPartitions
            self.numRetries = numRetries
            self.pollTimeoutMs = pollTimeoutMs
            self.retryIntervalMs = retryIntervalMs
            self.securityProtocol = securityProtocol
            self.startingOffsets = startingOffsets
            self.startingTimestamp = startingTimestamp
            self.subscribePattern = subscribePattern
            self.topicName = topicName
        }

        public func validate(name: String) throws {
            try self.validate(self.addRecordTimestamp, name: "addRecordTimestamp", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.assign, name: "assign", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.bootstrapServers, name: "bootstrapServers", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.classification, name: "classification", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.delimiter, name: "delimiter", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.emitConsumerLagMetrics, name: "emitConsumerLagMetrics", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.endingOffsets, name: "endingOffsets", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.maxOffsetsPerTrigger, name: "maxOffsetsPerTrigger", parent: name, min: 0)
            try self.validate(self.minPartitions, name: "minPartitions", parent: name, min: 0)
            try self.validate(self.numRetries, name: "numRetries", parent: name, min: 0)
            try self.validate(self.pollTimeoutMs, name: "pollTimeoutMs", parent: name, min: 0)
            try self.validate(self.retryIntervalMs, name: "retryIntervalMs", parent: name, min: 0)
            try self.validate(self.securityProtocol, name: "securityProtocol", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.startingOffsets, name: "startingOffsets", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.subscribePattern, name: "subscribePattern", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.topicName, name: "topicName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case addRecordTimestamp = "AddRecordTimestamp"
            case assign = "Assign"
            case bootstrapServers = "BootstrapServers"
            case classification = "Classification"
            case connectionName = "ConnectionName"
            case delimiter = "Delimiter"
            case emitConsumerLagMetrics = "EmitConsumerLagMetrics"
            case endingOffsets = "EndingOffsets"
            case includeHeaders = "IncludeHeaders"
            case maxOffsetsPerTrigger = "MaxOffsetsPerTrigger"
            case minPartitions = "MinPartitions"
            case numRetries = "NumRetries"
            case pollTimeoutMs = "PollTimeoutMs"
            case retryIntervalMs = "RetryIntervalMs"
            case securityProtocol = "SecurityProtocol"
            case startingOffsets = "StartingOffsets"
            case startingTimestamp = "StartingTimestamp"
            case subscribePattern = "SubscribePattern"
            case topicName = "TopicName"
        }
    }

    public struct KeySchemaElement: AWSDecodableShape {
        /// The name of a partition key.
        public let name: String
        /// The type of a partition key.
        public let type: String

        @inlinable
        public init(name: String, type: String) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct KinesisStreamingSourceOptions: AWSEncodableShape & AWSDecodableShape {
        /// Adds a time delay between two consecutive getRecords operations. The default value is "False". This option is only configurable for Glue version 2.0 and above.
        public let addIdleTimeBetweenReads: Bool?
        /// When this option is set to 'true', the data output will contain an additional column named "__src_timestamp" that indicates the time when the corresponding record received by the stream. The default value is 'false'. This option is supported in Glue version 4.0 or later.
        public let addRecordTimestamp: String?
        /// Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream before the batch is started. The default value is "False".
        public let avoidEmptyBatches: Bool?
        /// An optional classification.
        public let classification: String?
        /// Specifies the delimiter character.
        public let delimiter: String?
        /// The minimum time interval between two ListShards API calls for your script to consider resharding. The default value is 1s.
        public let describeShardInterval: Int64?
        /// When this option is set to 'true', for each batch, it will emit the metrics for the duration between the oldest record received by the stream and the time it arrives in Glue  to CloudWatch. The metric's name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is supported in Glue version 4.0 or later.
        public let emitConsumerLagMetrics: String?
        /// The URL of the Kinesis endpoint.
        public let endpointUrl: String?
        /// The minimum time delay between two consecutive getRecords operations, specified in ms. The default value is 1000. This option is only configurable for Glue version 2.0 and above.
        public let idleTimeBetweenReadsInMs: Int64?
        /// The maximum number of records to fetch per shard in the Kinesis data stream per microbatch. Note: The client can exceed this limit if the streaming job has already read extra records from Kinesis (in the same get-records call). If MaxFetchRecordsPerShard needs to be strict then it needs to be a multiple of MaxRecordPerRead. The default value is 100000.
        public let maxFetchRecordsPerShard: Int64?
        /// The maximum time spent for the job executor to read records for the current batch from the Kinesis data stream, specified in milliseconds (ms). Multiple GetRecords API calls may be made within this time. The default value is 1000.
        public let maxFetchTimeInMs: Int64?
        /// The maximum number of records to fetch from the Kinesis data stream in each getRecords operation. The default value is 10000.
        public let maxRecordPerRead: Int64?
        /// The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API call. The default value is 10000.
        public let maxRetryIntervalMs: Int64?
        /// The maximum number of retries for Kinesis Data Streams API requests. The default value is 3.
        public let numRetries: Int?
        /// The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The default value is 1000.
        public let retryIntervalMs: Int64?
        /// The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS). This role must have permissions for describe or read record operations for the Kinesis data stream. You must use this parameter when accessing a data stream in a different account. Used in conjunction with "awsSTSSessionName".
        public let roleArn: String?
        /// An identifier for the session assuming the role using AWS STS. You must use this parameter when accessing a data stream in a different account. Used in conjunction with "awsSTSRoleARN".
        public let roleSessionName: String?
        /// The starting position in the Kinesis data stream to read data from. The possible values are "latest", "trim_horizon", "earliest", or a timestamp string in UTC format in the pattern yyyy-mm-ddTHH:MM:SSZ (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00-04:00"). The default value is "latest". Note: Using a value that is a timestamp string in UTC format for "startingPosition" is supported only for Glue version 4.0 or later.
        public let startingPosition: StartingPosition?
        /// The timestamp of the record in the Kinesis data stream to start reading data from. The possible values are a timestamp string in UTC format of the pattern yyyy-mm-ddTHH:MM:SSZ (where Z represents a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00").
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startingTimestamp: Date?
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        public let streamArn: String?
        /// The name of the Kinesis data stream.
        public let streamName: String?

        @inlinable
        public init(addIdleTimeBetweenReads: Bool? = nil, addRecordTimestamp: String? = nil, avoidEmptyBatches: Bool? = nil, classification: String? = nil, delimiter: String? = nil, describeShardInterval: Int64? = nil, emitConsumerLagMetrics: String? = nil, endpointUrl: String? = nil, idleTimeBetweenReadsInMs: Int64? = nil, maxFetchRecordsPerShard: Int64? = nil, maxFetchTimeInMs: Int64? = nil, maxRecordPerRead: Int64? = nil, maxRetryIntervalMs: Int64? = nil, numRetries: Int? = nil, retryIntervalMs: Int64? = nil, roleArn: String? = nil, roleSessionName: String? = nil, startingPosition: StartingPosition? = nil, startingTimestamp: Date? = nil, streamArn: String? = nil, streamName: String? = nil) {
            self.addIdleTimeBetweenReads = addIdleTimeBetweenReads
            self.addRecordTimestamp = addRecordTimestamp
            self.avoidEmptyBatches = avoidEmptyBatches
            self.classification = classification
            self.delimiter = delimiter
            self.describeShardInterval = describeShardInterval
            self.emitConsumerLagMetrics = emitConsumerLagMetrics
            self.endpointUrl = endpointUrl
            self.idleTimeBetweenReadsInMs = idleTimeBetweenReadsInMs
            self.maxFetchRecordsPerShard = maxFetchRecordsPerShard
            self.maxFetchTimeInMs = maxFetchTimeInMs
            self.maxRecordPerRead = maxRecordPerRead
            self.maxRetryIntervalMs = maxRetryIntervalMs
            self.numRetries = numRetries
            self.retryIntervalMs = retryIntervalMs
            self.roleArn = roleArn
            self.roleSessionName = roleSessionName
            self.startingPosition = startingPosition
            self.startingTimestamp = startingTimestamp
            self.streamArn = streamArn
            self.streamName = streamName
        }

        public func validate(name: String) throws {
            try self.validate(self.addRecordTimestamp, name: "addRecordTimestamp", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.classification, name: "classification", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.delimiter, name: "delimiter", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.describeShardInterval, name: "describeShardInterval", parent: name, min: 0)
            try self.validate(self.emitConsumerLagMetrics, name: "emitConsumerLagMetrics", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.endpointUrl, name: "endpointUrl", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.idleTimeBetweenReadsInMs, name: "idleTimeBetweenReadsInMs", parent: name, min: 0)
            try self.validate(self.maxFetchRecordsPerShard, name: "maxFetchRecordsPerShard", parent: name, min: 0)
            try self.validate(self.maxFetchTimeInMs, name: "maxFetchTimeInMs", parent: name, min: 0)
            try self.validate(self.maxRecordPerRead, name: "maxRecordPerRead", parent: name, min: 0)
            try self.validate(self.maxRetryIntervalMs, name: "maxRetryIntervalMs", parent: name, min: 0)
            try self.validate(self.numRetries, name: "numRetries", parent: name, min: 0)
            try self.validate(self.retryIntervalMs, name: "retryIntervalMs", parent: name, min: 0)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.roleSessionName, name: "roleSessionName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.streamArn, name: "streamArn", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.streamName, name: "streamName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case addIdleTimeBetweenReads = "AddIdleTimeBetweenReads"
            case addRecordTimestamp = "AddRecordTimestamp"
            case avoidEmptyBatches = "AvoidEmptyBatches"
            case classification = "Classification"
            case delimiter = "Delimiter"
            case describeShardInterval = "DescribeShardInterval"
            case emitConsumerLagMetrics = "EmitConsumerLagMetrics"
            case endpointUrl = "EndpointUrl"
            case idleTimeBetweenReadsInMs = "IdleTimeBetweenReadsInMs"
            case maxFetchRecordsPerShard = "MaxFetchRecordsPerShard"
            case maxFetchTimeInMs = "MaxFetchTimeInMs"
            case maxRecordPerRead = "MaxRecordPerRead"
            case maxRetryIntervalMs = "MaxRetryIntervalMs"
            case numRetries = "NumRetries"
            case retryIntervalMs = "RetryIntervalMs"
            case roleArn = "RoleArn"
            case roleSessionName = "RoleSessionName"
            case startingPosition = "StartingPosition"
            case startingTimestamp = "StartingTimestamp"
            case streamArn = "StreamArn"
            case streamName = "StreamName"
        }
    }

    public struct LabelingSetGenerationTaskRunProperties: AWSDecodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path where you will generate the labeling set.
        public let outputS3Path: String?

        @inlinable
        public init(outputS3Path: String? = nil) {
            self.outputS3Path = outputS3Path
        }

        private enum CodingKeys: String, CodingKey {
            case outputS3Path = "OutputS3Path"
        }
    }

    public struct LakeFormationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Required for cross account crawls. For same account crawls as the target data, this can be left as null.
        public let accountId: String?
        /// Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role credentials.
        public let useLakeFormationCredentials: Bool?

        @inlinable
        public init(accountId: String? = nil, useLakeFormationCredentials: Bool? = nil) {
            self.accountId = accountId
            self.useLakeFormationCredentials = useLakeFormationCredentials
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case useLakeFormationCredentials = "UseLakeFormationCredentials"
        }
    }

    public struct LastActiveDefinition: AWSDecodableShape {
        /// Specifies a path in Amazon S3 where the blueprint is published by the Glue developer.
        public let blueprintLocation: String?
        /// Specifies a path in Amazon S3 where the blueprint is copied when you create or update the blueprint.
        public let blueprintServiceLocation: String?
        /// The description of the blueprint.
        public let description: String?
        /// The date and time the blueprint was last modified.
        public let lastModifiedOn: Date?
        /// A JSON string specifying the parameters for the blueprint.
        public let parameterSpec: String?

        @inlinable
        public init(blueprintLocation: String? = nil, blueprintServiceLocation: String? = nil, description: String? = nil, lastModifiedOn: Date? = nil, parameterSpec: String? = nil) {
            self.blueprintLocation = blueprintLocation
            self.blueprintServiceLocation = blueprintServiceLocation
            self.description = description
            self.lastModifiedOn = lastModifiedOn
            self.parameterSpec = parameterSpec
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintLocation = "BlueprintLocation"
            case blueprintServiceLocation = "BlueprintServiceLocation"
            case description = "Description"
            case lastModifiedOn = "LastModifiedOn"
            case parameterSpec = "ParameterSpec"
        }
    }

    public struct LastCrawlInfo: AWSDecodableShape {
        /// If an error occurred, the error information about the last crawl.
        public let errorMessage: String?
        /// The log group for the last crawl.
        public let logGroup: String?
        /// The log stream for the last crawl.
        public let logStream: String?
        /// The prefix for a message about this crawl.
        public let messagePrefix: String?
        /// The time at which the crawl started.
        public let startTime: Date?
        /// Status of the last crawl.
        public let status: LastCrawlStatus?

        @inlinable
        public init(errorMessage: String? = nil, logGroup: String? = nil, logStream: String? = nil, messagePrefix: String? = nil, startTime: Date? = nil, status: LastCrawlStatus? = nil) {
            self.errorMessage = errorMessage
            self.logGroup = logGroup
            self.logStream = logStream
            self.messagePrefix = messagePrefix
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case logGroup = "LogGroup"
            case logStream = "LogStream"
            case messagePrefix = "MessagePrefix"
            case startTime = "StartTime"
            case status = "Status"
        }
    }

    public struct LineageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether data lineage is enabled for the crawler. Valid values are:   ENABLE: enables data lineage for the crawler   DISABLE: disables data lineage for the crawler
        public let crawlerLineageSettings: CrawlerLineageSettings?

        @inlinable
        public init(crawlerLineageSettings: CrawlerLineageSettings? = nil) {
            self.crawlerLineageSettings = crawlerLineageSettings
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerLineageSettings = "CrawlerLineageSettings"
        }
    }

    public struct ListBlueprintsRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Filters the list by an Amazon Web Services resource tag.
        public let tags: [String: String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListBlueprintsResponse: AWSDecodableShape {
        /// List of names of blueprints in the account.
        public let blueprints: [String]?
        /// A continuation token, if not all blueprint names have been returned.
        public let nextToken: String?

        @inlinable
        public init(blueprints: [String]? = nil, nextToken: String? = nil) {
            self.blueprints = blueprints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case blueprints = "Blueprints"
            case nextToken = "NextToken"
        }
    }

    public struct ListColumnStatisticsTaskRunsRequest: AWSEncodableShape {
        /// The maximum size of the response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListColumnStatisticsTaskRunsResponse: AWSDecodableShape {
        /// A list of column statistics task run IDs.
        public let columnStatisticsTaskRunIds: [String]?
        /// A continuation token, if not all task run IDs have yet been returned.
        public let nextToken: String?

        @inlinable
        public init(columnStatisticsTaskRunIds: [String]? = nil, nextToken: String? = nil) {
            self.columnStatisticsTaskRunIds = columnStatisticsTaskRunIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsTaskRunIds = "ColumnStatisticsTaskRunIds"
            case nextToken = "NextToken"
        }
    }

    public struct ListConnectionTypesRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[-a-zA-Z0-9+=/:_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListConnectionTypesResponse: AWSDecodableShape {
        /// A list of ConnectionTypeBrief objects containing brief information about the supported connection types.
        public let connectionTypes: [ConnectionTypeBrief]?
        /// A continuation token, if the current list segment is not the last.
        public let nextToken: String?

        @inlinable
        public init(connectionTypes: [ConnectionTypeBrief]? = nil, nextToken: String? = nil) {
            self.connectionTypes = connectionTypes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectionTypes = "ConnectionTypes"
            case nextToken = "NextToken"
        }
    }

    public struct ListCrawlersRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListCrawlersResponse: AWSDecodableShape {
        /// The names of all crawlers in the account, or the crawlers with the specified tags.
        public let crawlerNames: [String]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        @inlinable
        public init(crawlerNames: [String]? = nil, nextToken: String? = nil) {
            self.crawlerNames = crawlerNames
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerNames = "CrawlerNames"
            case nextToken = "NextToken"
        }
    }

    public struct ListCrawlsRequest: AWSEncodableShape {
        /// The name of the crawler whose runs you want to retrieve.
        public let crawlerName: String
        /// Filters the crawls by the criteria you specify in a list of CrawlsFilter objects.
        public let filters: [CrawlsFilter]?
        /// The maximum number of results to return. The default is 20, and maximum is 100.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(crawlerName: String, filters: [CrawlsFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.crawlerName = crawlerName
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCrawlsResponse: AWSDecodableShape {
        /// A list of CrawlerHistory objects representing the crawl runs that meet your criteria.
        public let crawls: [CrawlerHistory]?
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?

        @inlinable
        public init(crawls: [CrawlerHistory]? = nil, nextToken: String? = nil) {
            self.crawls = crawls
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case crawls = "Crawls"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomEntityTypesRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A paginated token to offset the results.
        public let nextToken: String?
        /// A list of key-value pair tags.
        public let tags: [String: String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListCustomEntityTypesResponse: AWSDecodableShape {
        /// A list of CustomEntityType objects representing custom patterns.
        public let customEntityTypes: [CustomEntityType]?
        /// A pagination token, if more results are available.
        public let nextToken: String?

        @inlinable
        public init(customEntityTypes: [CustomEntityType]? = nil, nextToken: String? = nil) {
            self.customEntityTypes = customEntityTypes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case customEntityTypes = "CustomEntityTypes"
            case nextToken = "NextToken"
        }
    }

    public struct ListDataQualityResultsRequest: AWSEncodableShape {
        /// The filter criteria.
        public let filter: DataQualityResultFilterCriteria?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A paginated token to offset the results.
        public let nextToken: String?

        @inlinable
        public init(filter: DataQualityResultFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDataQualityResultsResponse: AWSDecodableShape {
        /// A pagination token, if more results are available.
        public let nextToken: String?
        /// A list of DataQualityResultDescription objects.
        public let results: [DataQualityResultDescription]

        @inlinable
        public init(nextToken: String? = nil, results: [DataQualityResultDescription]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case results = "Results"
        }
    }

    public struct ListDataQualityRuleRecommendationRunsRequest: AWSEncodableShape {
        /// The filter criteria.
        public let filter: DataQualityRuleRecommendationRunFilter?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A paginated token to offset the results.
        public let nextToken: String?

        @inlinable
        public init(filter: DataQualityRuleRecommendationRunFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDataQualityRuleRecommendationRunsResponse: AWSDecodableShape {
        /// A pagination token, if more results are available.
        public let nextToken: String?
        /// A list of DataQualityRuleRecommendationRunDescription objects.
        public let runs: [DataQualityRuleRecommendationRunDescription]?

        @inlinable
        public init(nextToken: String? = nil, runs: [DataQualityRuleRecommendationRunDescription]? = nil) {
            self.nextToken = nextToken
            self.runs = runs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case runs = "Runs"
        }
    }

    public struct ListDataQualityRulesetEvaluationRunsRequest: AWSEncodableShape {
        /// The filter criteria.
        public let filter: DataQualityRulesetEvaluationRunFilter?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A paginated token to offset the results.
        public let nextToken: String?

        @inlinable
        public init(filter: DataQualityRulesetEvaluationRunFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDataQualityRulesetEvaluationRunsResponse: AWSDecodableShape {
        /// A pagination token, if more results are available.
        public let nextToken: String?
        /// A list of DataQualityRulesetEvaluationRunDescription objects representing data quality ruleset runs.
        public let runs: [DataQualityRulesetEvaluationRunDescription]?

        @inlinable
        public init(nextToken: String? = nil, runs: [DataQualityRulesetEvaluationRunDescription]? = nil) {
            self.nextToken = nextToken
            self.runs = runs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case runs = "Runs"
        }
    }

    public struct ListDataQualityRulesetsRequest: AWSEncodableShape {
        /// The filter criteria.
        public let filter: DataQualityRulesetFilterCriteria?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A paginated token to offset the results.
        public let nextToken: String?
        /// A list of key-value pair tags.
        public let tags: [String: String]?

        @inlinable
        public init(filter: DataQualityRulesetFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListDataQualityRulesetsResponse: AWSDecodableShape {
        /// A pagination token, if more results are available.
        public let nextToken: String?
        /// A paginated list of rulesets for the specified list of Glue tables.
        public let rulesets: [DataQualityRulesetListDetails]?

        @inlinable
        public init(nextToken: String? = nil, rulesets: [DataQualityRulesetListDetails]? = nil) {
            self.nextToken = nextToken
            self.rulesets = rulesets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case rulesets = "Rulesets"
        }
    }

    public struct ListDataQualityStatisticAnnotationsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A pagination token to retrieve the next set of results.
        public let nextToken: String?
        /// The Profile ID.
        public let profileId: String?
        /// The Statistic ID.
        public let statisticId: String?
        /// A timestamp filter.
        public let timestampFilter: TimestampFilter?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, profileId: String? = nil, statisticId: String? = nil, timestampFilter: TimestampFilter? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.profileId = profileId
            self.statisticId = statisticId
            self.timestampFilter = timestampFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, max: 255)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.statisticId, name: "statisticId", parent: name, max: 255)
            try self.validate(self.statisticId, name: "statisticId", parent: name, min: 1)
            try self.validate(self.statisticId, name: "statisticId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case profileId = "ProfileId"
            case statisticId = "StatisticId"
            case timestampFilter = "TimestampFilter"
        }
    }

    public struct ListDataQualityStatisticAnnotationsResponse: AWSDecodableShape {
        /// A list of StatisticAnnotation applied to the Statistic
        public let annotations: [StatisticAnnotation]?
        /// A pagination token to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(annotations: [StatisticAnnotation]? = nil, nextToken: String? = nil) {
            self.annotations = annotations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case annotations = "Annotations"
            case nextToken = "NextToken"
        }
    }

    public struct ListDataQualityStatisticsRequest: AWSEncodableShape {
        /// The maximum number of results to return in this request.
        public let maxResults: Int?
        /// A pagination token to request the next page of results.
        public let nextToken: String?
        /// The Profile ID.
        public let profileId: String?
        /// The Statistic ID.
        public let statisticId: String?
        /// A timestamp filter.
        public let timestampFilter: TimestampFilter?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, profileId: String? = nil, statisticId: String? = nil, timestampFilter: TimestampFilter? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.profileId = profileId
            self.statisticId = statisticId
            self.timestampFilter = timestampFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, max: 255)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.statisticId, name: "statisticId", parent: name, max: 255)
            try self.validate(self.statisticId, name: "statisticId", parent: name, min: 1)
            try self.validate(self.statisticId, name: "statisticId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case profileId = "ProfileId"
            case statisticId = "StatisticId"
            case timestampFilter = "TimestampFilter"
        }
    }

    public struct ListDataQualityStatisticsResponse: AWSDecodableShape {
        /// A pagination token to request the next page of results.
        public let nextToken: String?
        /// A StatisticSummaryList.
        public let statistics: [StatisticSummary]?

        @inlinable
        public init(nextToken: String? = nil, statistics: [StatisticSummary]? = nil) {
            self.nextToken = nextToken
            self.statistics = statistics
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case statistics = "Statistics"
        }
    }

    public struct ListDevEndpointsRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListDevEndpointsResponse: AWSDecodableShape {
        /// The names of all the DevEndpoints in the account, or the DevEndpoints with the specified tags.
        public let devEndpointNames: [String]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        @inlinable
        public init(devEndpointNames: [String]? = nil, nextToken: String? = nil) {
            self.devEndpointNames = devEndpointNames
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpointNames = "DevEndpointNames"
            case nextToken = "NextToken"
        }
    }

    public struct ListEntitiesRequest: AWSEncodableShape {
        /// The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon Web Services Account ID is the catalog ID.
        public let catalogId: String?
        /// A name for the connection that has required credentials to query any connection type.
        public let connectionName: String?
        /// The API version of the SaaS connector.
        public let dataStoreApiVersion: String?
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?
        /// Name of the parent entity for which you want to list the children. This parameter takes a fully-qualified path of the entity in order to list the child entities.
        public let parentEntityName: String?

        @inlinable
        public init(catalogId: String? = nil, connectionName: String? = nil, dataStoreApiVersion: String? = nil, nextToken: String? = nil, parentEntityName: String? = nil) {
            self.catalogId = catalogId
            self.connectionName = connectionName
            self.dataStoreApiVersion = dataStoreApiVersion
            self.nextToken = nextToken
            self.parentEntityName = parentEntityName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 255)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.dataStoreApiVersion, name: "dataStoreApiVersion", parent: name, max: 256)
            try self.validate(self.dataStoreApiVersion, name: "dataStoreApiVersion", parent: name, min: 1)
            try self.validate(self.dataStoreApiVersion, name: "dataStoreApiVersion", parent: name, pattern: "^[a-zA-Z0-9.-]*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[-a-zA-Z0-9+=/:_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionName = "ConnectionName"
            case dataStoreApiVersion = "DataStoreApiVersion"
            case nextToken = "NextToken"
            case parentEntityName = "ParentEntityName"
        }
    }

    public struct ListEntitiesResponse: AWSDecodableShape {
        /// A list of Entity objects.
        public let entities: [Entity]?
        /// A continuation token, present if the current segment is not the last.
        public let nextToken: String?

        @inlinable
        public init(entities: [Entity]? = nil, nextToken: String? = nil) {
            self.entities = entities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "Entities"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListJobsResponse: AWSDecodableShape {
        /// The names of all jobs in the account, or the jobs with the specified tags.
        public let jobNames: [String]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        @inlinable
        public init(jobNames: [String]? = nil, nextToken: String? = nil) {
            self.jobNames = jobNames
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobNames = "JobNames"
            case nextToken = "NextToken"
        }
    }

    public struct ListMLTransformsRequest: AWSEncodableShape {
        /// A TransformFilterCriteria used to filter the machine learning transforms.
        public let filter: TransformFilterCriteria?
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// A TransformSortCriteria used to sort the machine learning transforms.
        public let sort: TransformSortCriteria?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        @inlinable
        public init(filter: TransformFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: TransformSortCriteria? = nil, tags: [String: String]? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sort = "Sort"
            case tags = "Tags"
        }
    }

    public struct ListMLTransformsResponse: AWSDecodableShape {
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?
        /// The identifiers of all the machine learning transforms in the account, or the machine learning transforms with the specified tags.
        public let transformIds: [String]

        @inlinable
        public init(nextToken: String? = nil, transformIds: [String]) {
            self.nextToken = nextToken
            self.transformIds = transformIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case transformIds = "TransformIds"
        }
    }

    public struct ListRegistriesInput: AWSEncodableShape {
        /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListRegistriesResponse: AWSDecodableShape {
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?
        /// An array of RegistryDetailedListItem objects containing minimal details of each registry.
        public let registries: [RegistryListItem]?

        @inlinable
        public init(nextToken: String? = nil, registries: [RegistryListItem]? = nil) {
            self.nextToken = nextToken
            self.registries = registries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registries = "Registries"
        }
    }

    public struct ListSchemaVersionsInput: AWSEncodableShape {
        /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
        public let schemaId: SchemaId

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, schemaId: SchemaId) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.schemaId = schemaId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.schemaId.validate(name: "\(name).schemaId")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case schemaId = "SchemaId"
        }
    }

    public struct ListSchemaVersionsResponse: AWSDecodableShape {
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?
        /// An array of SchemaVersionList objects containing details of each schema version.
        public let schemas: [SchemaVersionListItem]?

        @inlinable
        public init(nextToken: String? = nil, schemas: [SchemaVersionListItem]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schemas = "Schemas"
        }
    }

    public struct ListSchemasInput: AWSEncodableShape {
        /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
        public let registryId: RegistryId?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, registryId: RegistryId? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.registryId?.validate(name: "\(name).registryId")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registryId = "RegistryId"
        }
    }

    public struct ListSchemasResponse: AWSDecodableShape {
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?
        /// An array of SchemaListItem objects containing details of each schema.
        public let schemas: [SchemaListItem]?

        @inlinable
        public init(nextToken: String? = nil, schemas: [SchemaListItem]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schemas = "Schemas"
        }
    }

    public struct ListSessionsRequest: AWSEncodableShape {
        /// The maximum number of results.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more result.
        public let nextToken: String?
        /// The origin of the request.
        public let requestOrigin: String?
        /// Tags belonging to the session.
        public let tags: [String: String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, requestOrigin: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.requestOrigin = requestOrigin
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 400000)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, max: 128)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, min: 1)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case requestOrigin = "RequestOrigin"
            case tags = "Tags"
        }
    }

    public struct ListSessionsResponse: AWSDecodableShape {
        /// Returns the ID of the session.
        public let ids: [String]?
        /// The token for the next set of results, or null if there are no more result.
        public let nextToken: String?
        /// Returns the session object.
        public let sessions: [Session]?

        @inlinable
        public init(ids: [String]? = nil, nextToken: String? = nil, sessions: [Session]? = nil) {
            self.ids = ids
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case ids = "Ids"
            case nextToken = "NextToken"
            case sessions = "Sessions"
        }
    }

    public struct ListStatementsRequest: AWSEncodableShape {
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The origin of the request to list statements.
        public let requestOrigin: String?
        /// The Session ID of the statements.
        public let sessionId: String

        @inlinable
        public init(nextToken: String? = nil, requestOrigin: String? = nil, sessionId: String) {
            self.nextToken = nextToken
            self.requestOrigin = requestOrigin
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 400000)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, max: 128)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, min: 1)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 255)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case requestOrigin = "RequestOrigin"
            case sessionId = "SessionId"
        }
    }

    public struct ListStatementsResponse: AWSDecodableShape {
        /// A continuation token, if not all statements have yet been returned.
        public let nextToken: String?
        /// Returns the list of statements.
        public let statements: [Statement]?

        @inlinable
        public init(nextToken: String? = nil, statements: [Statement]? = nil) {
            self.nextToken = nextToken
            self.statements = statements
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case statements = "Statements"
        }
    }

    public struct ListTableOptimizerRunsRequest: AWSEncodableShape {
        /// The Catalog ID of the table.
        public let catalogId: String
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String
        /// The maximum number of optimizer runs to return on each call.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// The name of the table.
        public let tableName: String
        /// The type of table optimizer.
        public let type: TableOptimizerType

        @inlinable
        public init(catalogId: String, databaseName: String, maxResults: Int? = nil, nextToken: String? = nil, tableName: String, type: TableOptimizerType) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tableName = tableName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tableName = "TableName"
            case type = "Type"
        }
    }

    public struct ListTableOptimizerRunsResponse: AWSDecodableShape {
        /// The Catalog ID of the table.
        public let catalogId: String?
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String?
        /// A continuation token for paginating the returned list of optimizer runs, returned if the current segment of the list is not the last.
        public let nextToken: String?
        /// The name of the table.
        public let tableName: String?
        /// A list of the optimizer runs associated with a table.
        public let tableOptimizerRuns: [TableOptimizerRun]?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String? = nil, nextToken: String? = nil, tableName: String? = nil, tableOptimizerRuns: [TableOptimizerRun]? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.nextToken = nextToken
            self.tableName = tableName
            self.tableOptimizerRuns = tableOptimizerRuns
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case nextToken = "NextToken"
            case tableName = "TableName"
            case tableOptimizerRuns = "TableOptimizerRuns"
        }
    }

    public struct ListTriggersRequest: AWSEncodableShape {
        ///  The name of the job for which to retrieve triggers. The trigger that can start this job is returned. If there is no such trigger, all triggers are returned.
        public let dependentJobName: String?
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        @inlinable
        public init(dependentJobName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.dependentJobName = dependentJobName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, max: 255)
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, min: 1)
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case dependentJobName = "DependentJobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListTriggersResponse: AWSDecodableShape {
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?
        /// The names of all triggers in the account, or the triggers with the specified tags.
        public let triggerNames: [String]?

        @inlinable
        public init(nextToken: String? = nil, triggerNames: [String]? = nil) {
            self.nextToken = nextToken
            self.triggerNames = triggerNames
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case triggerNames = "TriggerNames"
        }
    }

    public struct ListUsageProfilesRequest: AWSEncodableShape {
        /// The maximum number of usage profiles to return in a single response.
        public let maxResults: Int?
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 400000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListUsageProfilesResponse: AWSDecodableShape {
        /// A continuation token, present if the current list segment is not the last.
        public let nextToken: String?
        /// A list of usage profile (UsageProfileDefinition) objects.
        public let profiles: [UsageProfileDefinition]?

        @inlinable
        public init(nextToken: String? = nil, profiles: [UsageProfileDefinition]? = nil) {
            self.nextToken = nextToken
            self.profiles = profiles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case profiles = "Profiles"
        }
    }

    public struct ListWorkflowsRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListWorkflowsResponse: AWSDecodableShape {
        /// A continuation token, if not all workflow names have been returned.
        public let nextToken: String?
        /// List of names of workflows in the account.
        public let workflows: [String]?

        @inlinable
        public init(nextToken: String? = nil, workflows: [String]? = nil) {
            self.nextToken = nextToken
            self.workflows = workflows
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workflows = "Workflows"
        }
    }

    public struct Location: AWSEncodableShape {
        /// An Amazon DynamoDB table location.
        public let dynamoDB: [CodeGenNodeArg]?
        /// A JDBC location.
        public let jdbc: [CodeGenNodeArg]?
        /// An Amazon Simple Storage Service (Amazon S3) location.
        public let s3: [CodeGenNodeArg]?

        @inlinable
        public init(dynamoDB: [CodeGenNodeArg]? = nil, jdbc: [CodeGenNodeArg]? = nil, s3: [CodeGenNodeArg]? = nil) {
            self.dynamoDB = dynamoDB
            self.jdbc = jdbc
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.validate(self.dynamoDB, name: "dynamoDB", parent: name, max: 50)
            try self.validate(self.jdbc, name: "jdbc", parent: name, max: 50)
            try self.validate(self.s3, name: "s3", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamoDB = "DynamoDB"
            case jdbc = "Jdbc"
            case s3 = "S3"
        }
    }

    public struct LongColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The highest value in the column.
        public let maximumValue: Int64?
        /// The lowest value in the column.
        public let minimumValue: Int64?
        /// The number of distinct values in a column.
        public let numberOfDistinctValues: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        @inlinable
        public init(maximumValue: Int64? = nil, minimumValue: Int64? = nil, numberOfDistinctValues: Int64, numberOfNulls: Int64) {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDistinctValues, name: "numberOfDistinctValues", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case numberOfDistinctValues = "NumberOfDistinctValues"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct MLTransform: AWSDecodableShape {
        /// A timestamp. The time and date that this machine learning transform was created.
        public let createdOn: Date?
        /// A user-defined, long-form description text for the machine learning transform. Descriptions are not guaranteed to be unique and can be changed at any time.
        public let description: String?
        /// An EvaluationMetrics object. Evaluation metrics provide an estimate of the quality of your machine learning transform.
        public let evaluationMetrics: EvaluationMetrics?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see Glue Versions in the developer guide.
        public let glueVersion: String?
        /// A list of Glue table definitions used by the transform.
        public let inputRecordTables: [GlueTable]?
        /// A count identifier for the labeling files generated by Glue for this transform. As you create a better transform, you can iteratively download, label, and upload the labeling file.
        public let labelCount: Int?
        /// A timestamp. The last point in time when this machine learning transform was modified.
        public let lastModifiedOn: Date?
        /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.   MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.   If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.   If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.   If WorkerType is set, then NumberOfWorkers is required (and vice versa).    MaxCapacity and NumberOfWorkers must both be at least 1.   When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
        public let maxCapacity: Double?
        /// The maximum number of times to retry after an MLTaskRun of the machine learning transform fails.
        public let maxRetries: Int?
        /// A user-defined name for the machine learning transform. Names are not guaranteed unique and can be changed at any time.
        public let name: String?
        /// The number of workers of a defined workerType that are allocated when a task of the transform runs. If WorkerType is set, then NumberOfWorkers is required (and vice versa).
        public let numberOfWorkers: Int?
        /// A TransformParameters object. You can use parameters to tune (customize) the behavior of the machine learning transform by specifying what data it learns from and your preference on various tradeoffs (such as precious vs. recall, or accuracy vs. cost).
        public let parameters: TransformParameters?
        /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform.    This role needs Glue service role permissions to allow access to resources in Glue. See Attach a Policy to IAM Users That Access Glue.   This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.
        public let role: String?
        /// A map of key-value pairs representing the columns and data types that this transform can run against. Has an upper bound of 100 columns.
        public let schema: [SchemaColumn]?
        /// The current status of the machine learning transform.
        public let status: TransformStatusType?
        /// The timeout in minutes of the machine learning transform.
        public let timeout: Int?
        /// The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.
        public let transformEncryption: TransformEncryption?
        /// The unique transform ID that is generated for the machine learning transform. The ID is guaranteed to be unique and does not change.
        public let transformId: String?
        /// The type of predefined worker that is allocated when a task of this transform runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.    MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.   If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.   If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.   If WorkerType is set, then NumberOfWorkers is required (and vice versa).    MaxCapacity and NumberOfWorkers must both be at least 1.
        public let workerType: WorkerType?

        @inlinable
        public init(createdOn: Date? = nil, description: String? = nil, evaluationMetrics: EvaluationMetrics? = nil, glueVersion: String? = nil, inputRecordTables: [GlueTable]? = nil, labelCount: Int? = nil, lastModifiedOn: Date? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String? = nil, numberOfWorkers: Int? = nil, parameters: TransformParameters? = nil, role: String? = nil, schema: [SchemaColumn]? = nil, status: TransformStatusType? = nil, timeout: Int? = nil, transformEncryption: TransformEncryption? = nil, transformId: String? = nil, workerType: WorkerType? = nil) {
            self.createdOn = createdOn
            self.description = description
            self.evaluationMetrics = evaluationMetrics
            self.glueVersion = glueVersion
            self.inputRecordTables = inputRecordTables
            self.labelCount = labelCount
            self.lastModifiedOn = lastModifiedOn
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.numberOfWorkers = numberOfWorkers
            self.parameters = parameters
            self.role = role
            self.schema = schema
            self.status = status
            self.timeout = timeout
            self.transformEncryption = transformEncryption
            self.transformId = transformId
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case createdOn = "CreatedOn"
            case description = "Description"
            case evaluationMetrics = "EvaluationMetrics"
            case glueVersion = "GlueVersion"
            case inputRecordTables = "InputRecordTables"
            case labelCount = "LabelCount"
            case lastModifiedOn = "LastModifiedOn"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case numberOfWorkers = "NumberOfWorkers"
            case parameters = "Parameters"
            case role = "Role"
            case schema = "Schema"
            case status = "Status"
            case timeout = "Timeout"
            case transformEncryption = "TransformEncryption"
            case transformId = "TransformId"
            case workerType = "WorkerType"
        }
    }

    public struct MLUserDataEncryption: AWSEncodableShape & AWSDecodableShape {
        /// The ID for the customer-provided KMS key.
        public let kmsKeyId: String?
        /// The encryption mode applied to user data. Valid values are:   DISABLED: encryption is disabled   SSEKMS: use of server-side encryption with Key Management Service (SSE-KMS) for user data stored in Amazon S3.
        public let mlUserDataEncryptionMode: MLUserDataEncryptionModeString

        @inlinable
        public init(kmsKeyId: String? = nil, mlUserDataEncryptionMode: MLUserDataEncryptionModeString) {
            self.kmsKeyId = kmsKeyId
            self.mlUserDataEncryptionMode = mlUserDataEncryptionMode
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 255)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case mlUserDataEncryptionMode = "MlUserDataEncryptionMode"
        }
    }

    public struct Mapping: AWSEncodableShape & AWSDecodableShape {
        /// Only applicable to nested data structures. If you want to change the parent structure, but also one of its children, you can fill out this data strucutre. It is also Mapping, but its FromPath will be the parent's FromPath plus the FromPath from this structure. For the children part, suppose you have the structure:  { "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }]
        /// }  You can specify a Mapping that looks like:  { "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double", "Dropped": false, }]
        /// }
        public let children: [Mapping]?
        /// If true, then the column is removed.
        public let dropped: Bool?
        /// The table or column to be modified.
        public let fromPath: [String]?
        /// The type of the data to be modified.
        public let fromType: String?
        /// After the apply mapping, what the name of the column should be. Can be the same as FromPath.
        public let toKey: String?
        /// The data type that the data is to be modified to.
        public let toType: String?

        @inlinable
        public init(children: [Mapping]? = nil, dropped: Bool? = nil, fromPath: [String]? = nil, fromType: String? = nil, toKey: String? = nil, toType: String? = nil) {
            self.children = children
            self.dropped = dropped
            self.fromPath = fromPath
            self.fromType = fromType
            self.toKey = toKey
            self.toType = toType
        }

        public func validate(name: String) throws {
            try self.children?.forEach {
                try $0.validate(name: "\(name).children[]")
            }
            try self.fromPath?.forEach {
                try validate($0, name: "fromPath[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.fromType, name: "fromType", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.toKey, name: "toKey", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.toType, name: "toType", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case children = "Children"
            case dropped = "Dropped"
            case fromPath = "FromPath"
            case fromType = "FromType"
            case toKey = "ToKey"
            case toType = "ToType"
        }
    }

    public struct MappingEntry: AWSEncodableShape & AWSDecodableShape {
        /// The source path.
        public let sourcePath: String?
        /// The name of the source table.
        public let sourceTable: String?
        /// The source type.
        public let sourceType: String?
        /// The target path.
        public let targetPath: String?
        /// The target table.
        public let targetTable: String?
        /// The target type.
        public let targetType: String?

        @inlinable
        public init(sourcePath: String? = nil, sourceTable: String? = nil, sourceType: String? = nil, targetPath: String? = nil, targetTable: String? = nil, targetType: String? = nil) {
            self.sourcePath = sourcePath
            self.sourceTable = sourceTable
            self.sourceType = sourceType
            self.targetPath = targetPath
            self.targetTable = targetTable
            self.targetType = targetType
        }

        private enum CodingKeys: String, CodingKey {
            case sourcePath = "SourcePath"
            case sourceTable = "SourceTable"
            case sourceType = "SourceType"
            case targetPath = "TargetPath"
            case targetTable = "TargetTable"
            case targetType = "TargetType"
        }
    }

    public struct Merge: AWSEncodableShape & AWSDecodableShape {
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String
        /// The list of primary key fields to match records from the source and staging dynamic frames.
        public let primaryKeys: [[String]]
        /// The source DynamicFrame that will be merged with a staging DynamicFrame.
        public let source: String

        @inlinable
        public init(inputs: [String], name: String, primaryKeys: [[String]], source: String) {
            self.inputs = inputs
            self.name = name
            self.primaryKeys = primaryKeys
            self.source = source
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 2)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 2)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.source, name: "source", parent: name, pattern: "^[A-Za-z0-9_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case primaryKeys = "PrimaryKeys"
            case source = "Source"
        }
    }

    public struct MetadataInfo: AWSDecodableShape {
        /// The time at which the entry was created.
        public let createdTime: String?
        /// The metadata keys corresponding value.
        public let metadataValue: String?
        /// Other metadata belonging to the same metadata key.
        public let otherMetadataValueList: [OtherMetadataValueListItem]?

        @inlinable
        public init(createdTime: String? = nil, metadataValue: String? = nil, otherMetadataValueList: [OtherMetadataValueListItem]? = nil) {
            self.createdTime = createdTime
            self.metadataValue = metadataValue
            self.otherMetadataValueList = otherMetadataValueList
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case metadataValue = "MetadataValue"
            case otherMetadataValueList = "OtherMetadataValueList"
        }
    }

    public struct MetadataKeyValuePair: AWSEncodableShape {
        /// A metadata key.
        public let metadataKey: String?
        /// A metadata keys corresponding value.
        public let metadataValue: String?

        @inlinable
        public init(metadataKey: String? = nil, metadataValue: String? = nil) {
            self.metadataKey = metadataKey
            self.metadataValue = metadataValue
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataKey, name: "metadataKey", parent: name, max: 128)
            try self.validate(self.metadataKey, name: "metadataKey", parent: name, min: 1)
            try self.validate(self.metadataKey, name: "metadataKey", parent: name, pattern: "^[a-zA-Z0-9+-=._./@]+$")
            try self.validate(self.metadataValue, name: "metadataValue", parent: name, max: 256)
            try self.validate(self.metadataValue, name: "metadataValue", parent: name, min: 1)
            try self.validate(self.metadataValue, name: "metadataValue", parent: name, pattern: "^[a-zA-Z0-9+-=._./@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataKey = "MetadataKey"
            case metadataValue = "MetadataValue"
        }
    }

    public struct MetricBasedObservation: AWSDecodableShape {
        /// The name of the data quality metric used for generating the observation.
        public let metricName: String?
        /// An object of type DataQualityMetricValues representing the analysis of the data quality metric value.
        public let metricValues: DataQualityMetricValues?
        /// A list of new data quality rules generated as part of the observation based on the data quality metric value.
        public let newRules: [String]?
        /// The Statistic ID.
        public let statisticId: String?

        @inlinable
        public init(metricName: String? = nil, metricValues: DataQualityMetricValues? = nil, newRules: [String]? = nil, statisticId: String? = nil) {
            self.metricName = metricName
            self.metricValues = metricValues
            self.newRules = newRules
            self.statisticId = statisticId
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case metricValues = "MetricValues"
            case newRules = "NewRules"
            case statisticId = "StatisticId"
        }
    }

    public struct MicrosoftSQLServerCatalogSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to read from.
        public let database: String
        /// The name of the data source.
        public let name: String
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(database: String, name: String, table: String) {
            self.database = database
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct MicrosoftSQLServerCatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to write to.
        public let database: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// The name of the table in the database to write to.
        public let table: String

        @inlinable
        public init(database: String, inputs: [String], name: String, table: String) {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case inputs = "Inputs"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct ModifyIntegrationRequest: AWSEncodableShape {
        /// Selects source tables for the integration using Maxwell filter syntax.
        public let dataFilter: String?
        /// A description of the integration.
        public let description: String?
        /// The Amazon Resource Name (ARN) for the integration.
        public let integrationIdentifier: String
        /// A unique name for an integration in Glue.
        public let integrationName: String?

        @inlinable
        public init(dataFilter: String? = nil, description: String? = nil, integrationIdentifier: String, integrationName: String? = nil) {
            self.dataFilter = dataFilter
            self.description = description
            self.integrationIdentifier = integrationIdentifier
            self.integrationName = integrationName
        }

        public func validate(name: String) throws {
            try self.validate(self.dataFilter, name: "dataFilter", parent: name, max: 2048)
            try self.validate(self.dataFilter, name: "dataFilter", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, max: 128)
            try self.validate(self.integrationIdentifier, name: "integrationIdentifier", parent: name, min: 1)
            try self.validate(self.integrationName, name: "integrationName", parent: name, max: 128)
            try self.validate(self.integrationName, name: "integrationName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataFilter = "DataFilter"
            case description = "Description"
            case integrationIdentifier = "IntegrationIdentifier"
            case integrationName = "IntegrationName"
        }
    }

    public struct ModifyIntegrationResponse: AWSDecodableShape {
        /// An optional set of non-secret keyvalue pairs that contains additional contextual information for encryption.
        public let additionalEncryptionContext: [String: String]?
        /// The time when the integration was created, in UTC.
        public let createTime: Date
        /// Selects source tables for the integration using Maxwell filter syntax.
        public let dataFilter: String?
        /// A description of the integration.
        public let description: String?
        /// A list of errors associated with the integration modification.
        public let errors: [IntegrationError]?
        /// The Amazon Resource Name (ARN) for the integration.
        public let integrationArn: String
        /// A unique name for an integration in Glue.
        public let integrationName: String
        /// The ARN of a KMS key used for encrypting the channel.
        public let kmsKeyId: String?
        /// The ARN of the source for the integration.
        public let sourceArn: String
        /// The status of the integration being modified. The possible statuses are:   CREATING: The integration is being created.   ACTIVE: The integration creation succeeds.   MODIFYING: The integration is being modified.   FAILED: The integration creation fails.    DELETING: The integration is deleted.   SYNCING: The integration is synchronizing.   NEEDS_ATTENTION: The integration needs attention, such as synchronization.
        public let status: IntegrationStatus
        /// Metadata assigned to the resource consisting of a list of key-value pairs.
        public let tags: [Tag]?
        /// The ARN of the target for the integration.
        public let targetArn: String

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, createTime: Date, dataFilter: String? = nil, description: String? = nil, errors: [IntegrationError]? = nil, integrationArn: String, integrationName: String, kmsKeyId: String? = nil, sourceArn: String, status: IntegrationStatus, tags: [Tag]? = nil, targetArn: String) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.createTime = createTime
            self.dataFilter = dataFilter
            self.description = description
            self.errors = errors
            self.integrationArn = integrationArn
            self.integrationName = integrationName
            self.kmsKeyId = kmsKeyId
            self.sourceArn = sourceArn
            self.status = status
            self.tags = tags
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "AdditionalEncryptionContext"
            case createTime = "CreateTime"
            case dataFilter = "DataFilter"
            case description = "Description"
            case errors = "Errors"
            case integrationArn = "IntegrationArn"
            case integrationName = "IntegrationName"
            case kmsKeyId = "KmsKeyId"
            case sourceArn = "SourceArn"
            case status = "Status"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct MongoDBTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.
        public let connectionName: String?
        /// The path of the Amazon DocumentDB or MongoDB target (database/collection).
        public let path: String?
        /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table. A value of true means to scan all records, while a value of false means to sample the records. If no value is specified, the value defaults to true.
        public let scanAll: Bool?

        @inlinable
        public init(connectionName: String? = nil, path: String? = nil, scanAll: Bool? = nil) {
            self.connectionName = connectionName
            self.path = path
            self.scanAll = scanAll
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case path = "Path"
            case scanAll = "ScanAll"
        }
    }

    public struct MySQLCatalogSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to read from.
        public let database: String
        /// The name of the data source.
        public let name: String
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(database: String, name: String, table: String) {
            self.database = database
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct MySQLCatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to write to.
        public let database: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// The name of the table in the database to write to.
        public let table: String

        @inlinable
        public init(database: String, inputs: [String], name: String, table: String) {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case inputs = "Inputs"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct Node: AWSDecodableShape {
        /// Details of the crawler when the node represents a crawler.
        public let crawlerDetails: CrawlerNodeDetails?
        /// Details of the Job when the node represents a Job.
        public let jobDetails: JobNodeDetails?
        /// The name of the Glue component represented by the node.
        public let name: String?
        /// Details of the Trigger when the node represents a Trigger.
        public let triggerDetails: TriggerNodeDetails?
        /// The type of Glue component represented by the node.
        public let type: NodeType?
        /// The unique Id assigned to the node within the workflow.
        public let uniqueId: String?

        @inlinable
        public init(crawlerDetails: CrawlerNodeDetails? = nil, jobDetails: JobNodeDetails? = nil, name: String? = nil, triggerDetails: TriggerNodeDetails? = nil, type: NodeType? = nil, uniqueId: String? = nil) {
            self.crawlerDetails = crawlerDetails
            self.jobDetails = jobDetails
            self.name = name
            self.triggerDetails = triggerDetails
            self.type = type
            self.uniqueId = uniqueId
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerDetails = "CrawlerDetails"
            case jobDetails = "JobDetails"
            case name = "Name"
            case triggerDetails = "TriggerDetails"
            case type = "Type"
            case uniqueId = "UniqueId"
        }
    }

    public struct NotificationProperty: AWSEncodableShape & AWSDecodableShape {
        /// After a job run starts, the number of minutes to wait before sending a job run delay notification.
        public let notifyDelayAfter: Int?

        @inlinable
        public init(notifyDelayAfter: Int? = nil) {
            self.notifyDelayAfter = notifyDelayAfter
        }

        public func validate(name: String) throws {
            try self.validate(self.notifyDelayAfter, name: "notifyDelayAfter", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case notifyDelayAfter = "NotifyDelayAfter"
        }
    }

    public struct NullCheckBoxList: AWSEncodableShape & AWSDecodableShape {
        /// Specifies that an empty string is considered as a null value.
        public let isEmpty: Bool?
        /// Specifies that an integer value of -1 is considered as a null value.
        public let isNegOne: Bool?
        /// Specifies that a value spelling out the word 'null' is considered as a null value.
        public let isNullString: Bool?

        @inlinable
        public init(isEmpty: Bool? = nil, isNegOne: Bool? = nil, isNullString: Bool? = nil) {
            self.isEmpty = isEmpty
            self.isNegOne = isNegOne
            self.isNullString = isNullString
        }

        private enum CodingKeys: String, CodingKey {
            case isEmpty = "IsEmpty"
            case isNegOne = "IsNegOne"
            case isNullString = "IsNullString"
        }
    }

    public struct NullValueField: AWSEncodableShape & AWSDecodableShape {
        /// The datatype of the value.
        public let datatype: Datatype
        /// The value of the null placeholder.
        public let value: String

        @inlinable
        public init(datatype: Datatype, value: String) {
            self.datatype = datatype
            self.value = value
        }

        public func validate(name: String) throws {
            try self.datatype.validate(name: "\(name).datatype")
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case datatype = "Datatype"
            case value = "Value"
        }
    }

    public struct OAuth2ClientApplication: AWSEncodableShape & AWSDecodableShape {
        /// The reference to the SaaS-side client app that is Amazon Web Services managed.
        public let awsManagedClientApplicationReference: String?
        /// The client application clientID if the ClientAppType is USER_MANAGED.
        public let userManagedClientApplicationClientId: String?

        @inlinable
        public init(awsManagedClientApplicationReference: String? = nil, userManagedClientApplicationClientId: String? = nil) {
            self.awsManagedClientApplicationReference = awsManagedClientApplicationReference
            self.userManagedClientApplicationClientId = userManagedClientApplicationClientId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsManagedClientApplicationReference, name: "awsManagedClientApplicationReference", parent: name, max: 2048)
            try self.validate(self.awsManagedClientApplicationReference, name: "awsManagedClientApplicationReference", parent: name, pattern: "^\\S+$")
            try self.validate(self.userManagedClientApplicationClientId, name: "userManagedClientApplicationClientId", parent: name, max: 2048)
            try self.validate(self.userManagedClientApplicationClientId, name: "userManagedClientApplicationClientId", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsManagedClientApplicationReference = "AWSManagedClientApplicationReference"
            case userManagedClientApplicationClientId = "UserManagedClientApplicationClientId"
        }
    }

    public struct OAuth2Credentials: AWSEncodableShape {
        /// The access token used when the authentication type is OAuth2.
        public let accessToken: String?
        /// The JSON Web Token (JWT) used when the authentication type is OAuth2.
        public let jwtToken: String?
        /// The refresh token used when the authentication type is OAuth2.
        public let refreshToken: String?
        /// The client application client secret if the client application is user managed.
        public let userManagedClientApplicationClientSecret: String?

        @inlinable
        public init(accessToken: String? = nil, jwtToken: String? = nil, refreshToken: String? = nil, userManagedClientApplicationClientSecret: String? = nil) {
            self.accessToken = accessToken
            self.jwtToken = jwtToken
            self.refreshToken = refreshToken
            self.userManagedClientApplicationClientSecret = userManagedClientApplicationClientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 4096)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^[\\x20-\\x7E]*$")
            try self.validate(self.jwtToken, name: "jwtToken", parent: name, max: 8000)
            try self.validate(self.jwtToken, name: "jwtToken", parent: name, pattern: "^([a-zA-Z0-9_=]+)\\.([a-zA-Z0-9_=]+)\\.([a-zA-Z0-9_\\-\\+\\/=]*)$")
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, max: 4096)
            try self.validate(self.refreshToken, name: "refreshToken", parent: name, pattern: "^[\\x20-\\x7E]*$")
            try self.validate(self.userManagedClientApplicationClientSecret, name: "userManagedClientApplicationClientSecret", parent: name, max: 512)
            try self.validate(self.userManagedClientApplicationClientSecret, name: "userManagedClientApplicationClientSecret", parent: name, pattern: "^[\\x20-\\x7E]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "AccessToken"
            case jwtToken = "JwtToken"
            case refreshToken = "RefreshToken"
            case userManagedClientApplicationClientSecret = "UserManagedClientApplicationClientSecret"
        }
    }

    public struct OAuth2Properties: AWSDecodableShape {
        /// The client application type. For example, AWS_MANAGED or USER_MANAGED.
        public let oAuth2ClientApplication: OAuth2ClientApplication?
        /// The OAuth2 grant type. For example, AUTHORIZATION_CODE, JWT_BEARER, or CLIENT_CREDENTIALS.
        public let oAuth2GrantType: OAuth2GrantType?
        /// The URL of the provider's authentication server, to exchange an authorization code for an access token.
        public let tokenUrl: String?
        /// A map of parameters that are added to the token GET request.
        public let tokenUrlParametersMap: [String: String]?

        @inlinable
        public init(oAuth2ClientApplication: OAuth2ClientApplication? = nil, oAuth2GrantType: OAuth2GrantType? = nil, tokenUrl: String? = nil, tokenUrlParametersMap: [String: String]? = nil) {
            self.oAuth2ClientApplication = oAuth2ClientApplication
            self.oAuth2GrantType = oAuth2GrantType
            self.tokenUrl = tokenUrl
            self.tokenUrlParametersMap = tokenUrlParametersMap
        }

        private enum CodingKeys: String, CodingKey {
            case oAuth2ClientApplication = "OAuth2ClientApplication"
            case oAuth2GrantType = "OAuth2GrantType"
            case tokenUrl = "TokenUrl"
            case tokenUrlParametersMap = "TokenUrlParametersMap"
        }
    }

    public struct OAuth2PropertiesInput: AWSEncodableShape {
        /// The set of properties required for the the OAuth2 AUTHORIZATION_CODE grant type.
        public let authorizationCodeProperties: AuthorizationCodeProperties?
        /// The client application type in the CreateConnection request. For example, AWS_MANAGED or USER_MANAGED.
        public let oAuth2ClientApplication: OAuth2ClientApplication?
        /// The credentials used when the authentication type is OAuth2 authentication.
        public let oAuth2Credentials: OAuth2Credentials?
        /// The OAuth2 grant type in the CreateConnection request. For example, AUTHORIZATION_CODE, JWT_BEARER, or CLIENT_CREDENTIALS.
        public let oAuth2GrantType: OAuth2GrantType?
        /// The URL of the provider's authentication server, to exchange an authorization code for an access token.
        public let tokenUrl: String?
        /// A map of parameters that are added to the token GET request.
        public let tokenUrlParametersMap: [String: String]?

        @inlinable
        public init(authorizationCodeProperties: AuthorizationCodeProperties? = nil, oAuth2ClientApplication: OAuth2ClientApplication? = nil, oAuth2Credentials: OAuth2Credentials? = nil, oAuth2GrantType: OAuth2GrantType? = nil, tokenUrl: String? = nil, tokenUrlParametersMap: [String: String]? = nil) {
            self.authorizationCodeProperties = authorizationCodeProperties
            self.oAuth2ClientApplication = oAuth2ClientApplication
            self.oAuth2Credentials = oAuth2Credentials
            self.oAuth2GrantType = oAuth2GrantType
            self.tokenUrl = tokenUrl
            self.tokenUrlParametersMap = tokenUrlParametersMap
        }

        public func validate(name: String) throws {
            try self.authorizationCodeProperties?.validate(name: "\(name).authorizationCodeProperties")
            try self.oAuth2ClientApplication?.validate(name: "\(name).oAuth2ClientApplication")
            try self.oAuth2Credentials?.validate(name: "\(name).oAuth2Credentials")
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, max: 256)
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, pattern: "^(https?)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$")
            try self.tokenUrlParametersMap?.forEach {
                try validate($0.key, name: "tokenUrlParametersMap.key", parent: name, max: 128)
                try validate($0.key, name: "tokenUrlParametersMap.key", parent: name, min: 1)
                try validate($0.value, name: "tokenUrlParametersMap[\"\($0.key)\"]", parent: name, max: 512)
                try validate($0.value, name: "tokenUrlParametersMap[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationCodeProperties = "AuthorizationCodeProperties"
            case oAuth2ClientApplication = "OAuth2ClientApplication"
            case oAuth2Credentials = "OAuth2Credentials"
            case oAuth2GrantType = "OAuth2GrantType"
            case tokenUrl = "TokenUrl"
            case tokenUrlParametersMap = "TokenUrlParametersMap"
        }
    }

    public struct OpenTableFormatInput: AWSEncodableShape {
        /// Specifies an IcebergInput structure that defines an Apache Iceberg metadata table.
        public let icebergInput: IcebergInput?

        @inlinable
        public init(icebergInput: IcebergInput? = nil) {
            self.icebergInput = icebergInput
        }

        public func validate(name: String) throws {
            try self.icebergInput?.validate(name: "\(name).icebergInput")
        }

        private enum CodingKeys: String, CodingKey {
            case icebergInput = "IcebergInput"
        }
    }

    public struct Option: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the description of the option.
        public let description: String?
        /// Specifies the label of the option.
        public let label: String?
        /// Specifies the value of the option.
        public let value: String?

        @inlinable
        public init(description: String? = nil, label: String? = nil, value: String? = nil) {
            self.description = description
            self.label = label
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.label, name: "label", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case label = "Label"
            case value = "Value"
        }
    }

    public struct OracleSQLCatalogSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to read from.
        public let database: String
        /// The name of the data source.
        public let name: String
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(database: String, name: String, table: String) {
            self.database = database
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct OracleSQLCatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to write to.
        public let database: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// The name of the table in the database to write to.
        public let table: String

        @inlinable
        public init(database: String, inputs: [String], name: String, table: String) {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case inputs = "Inputs"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct Order: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let column: String
        /// Indicates that the column is sorted in ascending order (== 1), or in descending order (==0).
        public let sortOrder: Int

        @inlinable
        public init(column: String, sortOrder: Int) {
            self.column = column
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.column, name: "column", parent: name, max: 255)
            try self.validate(self.column, name: "column", parent: name, min: 1)
            try self.validate(self.column, name: "column", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.sortOrder, name: "sortOrder", parent: name, max: 1)
            try self.validate(self.sortOrder, name: "sortOrder", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case sortOrder = "SortOrder"
        }
    }

    public struct OrphanFileDeletionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for an Iceberg orphan file deletion optimizer.
        public let icebergConfiguration: IcebergOrphanFileDeletionConfiguration?

        @inlinable
        public init(icebergConfiguration: IcebergOrphanFileDeletionConfiguration? = nil) {
            self.icebergConfiguration = icebergConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case icebergConfiguration = "icebergConfiguration"
        }
    }

    public struct OrphanFileDeletionMetrics: AWSDecodableShape {
        /// A structure containing the Iceberg orphan file deletion metrics for the optimizer run.
        public let icebergMetrics: IcebergOrphanFileDeletionMetrics?

        @inlinable
        public init(icebergMetrics: IcebergOrphanFileDeletionMetrics? = nil) {
            self.icebergMetrics = icebergMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case icebergMetrics = "IcebergMetrics"
        }
    }

    public struct OtherMetadataValueListItem: AWSDecodableShape {
        /// The time at which the entry was created.
        public let createdTime: String?
        /// The metadata keys corresponding value for the other metadata belonging to the same metadata key.
        public let metadataValue: String?

        @inlinable
        public init(createdTime: String? = nil, metadataValue: String? = nil) {
            self.createdTime = createdTime
            self.metadataValue = metadataValue
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case metadataValue = "MetadataValue"
        }
    }

    public struct PIIDetection: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the types of entities the PIIDetection transform will identify as PII data.   PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE
        public let entityTypesToDetect: [String]
        /// The node ID inputs to the transform.
        public let inputs: [String]
        /// Indicates the value that will replace the detected entity.
        public let maskValue: String?
        /// The name of the transform node.
        public let name: String
        /// Indicates the output column name that will contain any entity type detected in that row.
        public let outputColumnName: String?
        /// Indicates the type of PIIDetection transform.
        public let piiType: PiiType
        /// Indicates the fraction of the data to sample when scanning for PII entities.
        public let sampleFraction: Double?
        /// Indicates the fraction of the data that must be met in order for a column to be identified as PII data.
        public let thresholdFraction: Double?

        @inlinable
        public init(entityTypesToDetect: [String], inputs: [String], maskValue: String? = nil, name: String, outputColumnName: String? = nil, piiType: PiiType, sampleFraction: Double? = nil, thresholdFraction: Double? = nil) {
            self.entityTypesToDetect = entityTypesToDetect
            self.inputs = inputs
            self.maskValue = maskValue
            self.name = name
            self.outputColumnName = outputColumnName
            self.piiType = piiType
            self.sampleFraction = sampleFraction
            self.thresholdFraction = thresholdFraction
        }

        public func validate(name: String) throws {
            try self.entityTypesToDetect.forEach {
                try validate($0, name: "entityTypesToDetect[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.maskValue, name: "maskValue", parent: name, max: 256)
            try self.validate(self.maskValue, name: "maskValue", parent: name, pattern: "^[*A-Za-z0-9_-]*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.outputColumnName, name: "outputColumnName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.sampleFraction, name: "sampleFraction", parent: name, max: 1.0)
            try self.validate(self.sampleFraction, name: "sampleFraction", parent: name, min: 0.0)
            try self.validate(self.thresholdFraction, name: "thresholdFraction", parent: name, max: 1.0)
            try self.validate(self.thresholdFraction, name: "thresholdFraction", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case entityTypesToDetect = "EntityTypesToDetect"
            case inputs = "Inputs"
            case maskValue = "MaskValue"
            case name = "Name"
            case outputColumnName = "OutputColumnName"
            case piiType = "PiiType"
            case sampleFraction = "SampleFraction"
            case thresholdFraction = "ThresholdFraction"
        }
    }

    public struct Partition: AWSDecodableShape {
        /// The ID of the Data Catalog in which the partition resides.
        public let catalogId: String?
        /// The time at which the partition was created.
        public let creationTime: Date?
        /// The name of the catalog database in which to create the partition.
        public let databaseName: String?
        /// The last time at which the partition was accessed.
        public let lastAccessTime: Date?
        /// The last time at which column statistics were computed for this partition.
        public let lastAnalyzedTime: Date?
        /// These key-value pairs define partition parameters.
        public let parameters: [String: String]?
        /// Provides information about the physical location where the partition is stored.
        public let storageDescriptor: StorageDescriptor?
        /// The name of the database table in which to create the partition.
        public let tableName: String?
        /// The values of the partition.
        public let values: [String]?

        @inlinable
        public init(catalogId: String? = nil, creationTime: Date? = nil, databaseName: String? = nil, lastAccessTime: Date? = nil, lastAnalyzedTime: Date? = nil, parameters: [String: String]? = nil, storageDescriptor: StorageDescriptor? = nil, tableName: String? = nil, values: [String]? = nil) {
            self.catalogId = catalogId
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.parameters = parameters
            self.storageDescriptor = storageDescriptor
            self.tableName = tableName
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case parameters = "Parameters"
            case storageDescriptor = "StorageDescriptor"
            case tableName = "TableName"
            case values = "Values"
        }
    }

    public struct PartitionError: AWSDecodableShape {
        /// The details about the partition error.
        public let errorDetail: ErrorDetail?
        /// The values that define the partition.
        public let partitionValues: [String]?

        @inlinable
        public init(errorDetail: ErrorDetail? = nil, partitionValues: [String]? = nil) {
            self.errorDetail = errorDetail
            self.partitionValues = partitionValues
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case partitionValues = "PartitionValues"
        }
    }

    public struct PartitionIndex: AWSEncodableShape {
        /// The name of the partition index.
        public let indexName: String
        /// The keys for the partition index.
        public let keys: [String]

        @inlinable
        public init(indexName: String, keys: [String]) {
            self.indexName = indexName
            self.keys = keys
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 255)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.keys.forEach {
                try validate($0, name: "keys[]", parent: name, max: 255)
                try validate($0, name: "keys[]", parent: name, min: 1)
                try validate($0, name: "keys[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.keys, name: "keys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case indexName = "IndexName"
            case keys = "Keys"
        }
    }

    public struct PartitionIndexDescriptor: AWSDecodableShape {
        /// A list of errors that can occur when registering partition indexes for an existing table.
        public let backfillErrors: [BackfillError]?
        /// The name of the partition index.
        public let indexName: String
        /// The status of the partition index.  The possible statuses are:   CREATING: The index is being created. When an index is in a CREATING state, the index or its table cannot be deleted.   ACTIVE: The index creation succeeds.   FAILED: The index creation fails.    DELETING: The index is deleted from the list of indexes.
        public let indexStatus: PartitionIndexStatus
        /// A list of one or more keys, as KeySchemaElement structures, for the partition index.
        public let keys: [KeySchemaElement]

        @inlinable
        public init(backfillErrors: [BackfillError]? = nil, indexName: String, indexStatus: PartitionIndexStatus, keys: [KeySchemaElement]) {
            self.backfillErrors = backfillErrors
            self.indexName = indexName
            self.indexStatus = indexStatus
            self.keys = keys
        }

        private enum CodingKeys: String, CodingKey {
            case backfillErrors = "BackfillErrors"
            case indexName = "IndexName"
            case indexStatus = "IndexStatus"
            case keys = "Keys"
        }
    }

    public struct PartitionInput: AWSEncodableShape {
        /// The last time at which the partition was accessed.
        public let lastAccessTime: Date?
        /// The last time at which column statistics were computed for this partition.
        public let lastAnalyzedTime: Date?
        /// These key-value pairs define partition parameters.
        public let parameters: [String: String]?
        /// Provides information about the physical location where the partition is stored.
        public let storageDescriptor: StorageDescriptor?
        /// The values of the partition. Although this parameter is not required by the SDK, you must specify this parameter for a valid input. The values for the keys for the new partition must be passed as an array of String objects that must be ordered in the same order as the partition keys appearing in the Amazon S3 prefix. Otherwise Glue will add the values to the wrong keys.
        public let values: [String]?

        @inlinable
        public init(lastAccessTime: Date? = nil, lastAnalyzedTime: Date? = nil, parameters: [String: String]? = nil, storageDescriptor: StorageDescriptor? = nil, values: [String]? = nil) {
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.parameters = parameters
            self.storageDescriptor = storageDescriptor
            self.values = values
        }

        public func validate(name: String) throws {
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512000)
            }
            try self.storageDescriptor?.validate(name: "\(name).storageDescriptor")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case parameters = "Parameters"
            case storageDescriptor = "StorageDescriptor"
            case values = "Values"
        }
    }

    public struct PartitionValueList: AWSEncodableShape & AWSDecodableShape {
        /// The list of values.
        public let values: [String]

        @inlinable
        public init(values: [String]) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct PhysicalConnectionRequirements: AWSEncodableShape & AWSDecodableShape {
        /// The connection's Availability Zone.
        public let availabilityZone: String?
        /// The security group ID list used by the connection.
        public let securityGroupIdList: [String]?
        /// The subnet ID used by the connection.
        public let subnetId: String?

        @inlinable
        public init(availabilityZone: String? = nil, securityGroupIdList: [String]? = nil, subnetId: String? = nil) {
            self.availabilityZone = availabilityZone
            self.securityGroupIdList = securityGroupIdList
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, max: 255)
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, min: 1)
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.securityGroupIdList?.forEach {
                try validate($0, name: "securityGroupIdList[]", parent: name, max: 255)
                try validate($0, name: "securityGroupIdList[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIdList[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.securityGroupIdList, name: "securityGroupIdList", parent: name, max: 50)
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 255)
            try self.validate(self.subnetId, name: "subnetId", parent: name, min: 1)
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case securityGroupIdList = "SecurityGroupIdList"
            case subnetId = "SubnetId"
        }
    }

    public struct PostgreSQLCatalogSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to read from.
        public let database: String
        /// The name of the data source.
        public let name: String
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(database: String, name: String, table: String) {
            self.database = database
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct PostgreSQLCatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to write to.
        public let database: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// The name of the table in the database to write to.
        public let table: String

        @inlinable
        public init(database: String, inputs: [String], name: String, table: String) {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case inputs = "Inputs"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct Predecessor: AWSDecodableShape {
        /// The name of the job definition used by the predecessor job run.
        public let jobName: String?
        /// The job-run ID of the predecessor job run.
        public let runId: String?

        @inlinable
        public init(jobName: String? = nil, runId: String? = nil) {
            self.jobName = jobName
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case runId = "RunId"
        }
    }

    public struct Predicate: AWSEncodableShape & AWSDecodableShape {
        /// A list of the conditions that determine when the trigger will fire.
        public let conditions: [Condition]?
        /// An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.
        public let logical: Logical?

        @inlinable
        public init(conditions: [Condition]? = nil, logical: Logical? = nil) {
            self.conditions = conditions
            self.logical = logical
        }

        public func validate(name: String) throws {
            try self.conditions?.forEach {
                try $0.validate(name: "\(name).conditions[]")
            }
            try self.validate(self.conditions, name: "conditions", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case conditions = "Conditions"
            case logical = "Logical"
        }
    }

    public struct PrincipalPermissions: AWSEncodableShape & AWSDecodableShape {
        /// The permissions that are granted to the principal.
        public let permissions: [Permission]?
        /// The principal who is granted permissions.
        public let principal: DataLakePrincipal?

        @inlinable
        public init(permissions: [Permission]? = nil, principal: DataLakePrincipal? = nil) {
            self.permissions = permissions
            self.principal = principal
        }

        public func validate(name: String) throws {
            try self.principal?.validate(name: "\(name).principal")
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case principal = "Principal"
        }
    }

    public struct ProfileConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A key-value map of configuration parameters for Glue jobs.
        public let jobConfiguration: [String: ConfigurationObject]?
        /// A key-value map of configuration parameters for Glue sessions.
        public let sessionConfiguration: [String: ConfigurationObject]?

        @inlinable
        public init(jobConfiguration: [String: ConfigurationObject]? = nil, sessionConfiguration: [String: ConfigurationObject]? = nil) {
            self.jobConfiguration = jobConfiguration
            self.sessionConfiguration = sessionConfiguration
        }

        public func validate(name: String) throws {
            try self.jobConfiguration?.forEach {
                try validate($0.key, name: "jobConfiguration.key", parent: name, max: 255)
                try validate($0.key, name: "jobConfiguration.key", parent: name, min: 1)
                try validate($0.key, name: "jobConfiguration.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try $0.value.validate(name: "\(name).jobConfiguration[\"\($0.key)\"]")
            }
            try self.sessionConfiguration?.forEach {
                try validate($0.key, name: "sessionConfiguration.key", parent: name, max: 255)
                try validate($0.key, name: "sessionConfiguration.key", parent: name, min: 1)
                try validate($0.key, name: "sessionConfiguration.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try $0.value.validate(name: "\(name).sessionConfiguration[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case jobConfiguration = "JobConfiguration"
            case sessionConfiguration = "SessionConfiguration"
        }
    }

    public struct Property: AWSDecodableShape {
        /// A list of AllowedValue objects representing the values allowed for the property.
        public let allowedValues: [AllowedValue]?
        /// Indicates which data operations are applicable to the property.
        public let dataOperationScopes: [DataOperation]?
        /// The default value for the property.
        public let defaultValue: String?
        /// A description of the property.
        public let description: String
        /// The name of the property.
        public let name: String
        /// Describes the type of property.
        public let propertyTypes: [PropertyType]
        /// Indicates whether the property is required.
        public let required: Bool

        @inlinable
        public init(allowedValues: [AllowedValue]? = nil, dataOperationScopes: [DataOperation]? = nil, defaultValue: String? = nil, description: String, name: String, propertyTypes: [PropertyType], required: Bool) {
            self.allowedValues = allowedValues
            self.dataOperationScopes = dataOperationScopes
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.propertyTypes = propertyTypes
            self.required = required
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "AllowedValues"
            case dataOperationScopes = "DataOperationScopes"
            case defaultValue = "DefaultValue"
            case description = "Description"
            case name = "Name"
            case propertyTypes = "PropertyTypes"
            case required = "Required"
        }
    }

    public struct PropertyPredicate: AWSEncodableShape {
        /// The comparator used to compare this property to others.
        public let comparator: Comparator?
        /// The key of the property.
        public let key: String?
        /// The value of the property.
        public let value: String?

        @inlinable
        public init(comparator: Comparator? = nil, key: String? = nil, value: String? = nil) {
            self.comparator = comparator
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparator = "Comparator"
            case key = "Key"
            case value = "Value"
        }
    }

    public struct PutDataCatalogEncryptionSettingsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog to set the security configuration for. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The security configuration to set.
        public let dataCatalogEncryptionSettings: DataCatalogEncryptionSettings

        @inlinable
        public init(catalogId: String? = nil, dataCatalogEncryptionSettings: DataCatalogEncryptionSettings) {
            self.catalogId = catalogId
            self.dataCatalogEncryptionSettings = dataCatalogEncryptionSettings
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.dataCatalogEncryptionSettings.validate(name: "\(name).dataCatalogEncryptionSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case dataCatalogEncryptionSettings = "DataCatalogEncryptionSettings"
        }
    }

    public struct PutDataCatalogEncryptionSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutDataQualityProfileAnnotationRequest: AWSEncodableShape {
        /// The inclusion annotation value to apply to the profile.
        public let inclusionAnnotation: InclusionAnnotationValue
        /// The ID of the data quality monitoring profile to annotate.
        public let profileId: String

        @inlinable
        public init(inclusionAnnotation: InclusionAnnotationValue, profileId: String) {
            self.inclusionAnnotation = inclusionAnnotation
            self.profileId = profileId
        }

        public func validate(name: String) throws {
            try self.validate(self.profileId, name: "profileId", parent: name, max: 255)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inclusionAnnotation = "InclusionAnnotation"
            case profileId = "ProfileId"
        }
    }

    public struct PutDataQualityProfileAnnotationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// If 'TRUE', indicates that you are using both methods to grant cross-account access to Data Catalog resources:   By directly updating the resource policy with PutResourePolicy    By using the Grant permissions command on the Amazon Web Services Management Console.   Must be set to 'TRUE' if you have already used the Management Console to grant cross-account access, otherwise the call fails. Default is 'FALSE'.
        public let enableHybrid: EnableHybridValues?
        /// A value of MUST_EXIST is used to update a policy. A value of NOT_EXIST is used to create a new policy. If a value of NONE or a null value is used, the call does not depend on the existence of a policy.
        public let policyExistsCondition: ExistCondition?
        /// The hash value returned when the previous policy was set using PutResourcePolicy. Its purpose is to prevent concurrent modifications of a policy. Do not use this parameter if no previous policy has been set.
        public let policyHashCondition: String?
        /// Contains the policy document to set, in JSON format.
        public let policyInJson: String
        /// Do not use. For internal use only.
        public let resourceArn: String?

        @inlinable
        public init(enableHybrid: EnableHybridValues? = nil, policyExistsCondition: ExistCondition? = nil, policyHashCondition: String? = nil, policyInJson: String, resourceArn: String? = nil) {
            self.enableHybrid = enableHybrid
            self.policyExistsCondition = policyExistsCondition
            self.policyHashCondition = policyHashCondition
            self.policyInJson = policyInJson
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, max: 255)
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, min: 1)
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.policyInJson, name: "policyInJson", parent: name, min: 2)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:glue:")
        }

        private enum CodingKeys: String, CodingKey {
            case enableHybrid = "EnableHybrid"
            case policyExistsCondition = "PolicyExistsCondition"
            case policyHashCondition = "PolicyHashCondition"
            case policyInJson = "PolicyInJson"
            case resourceArn = "ResourceArn"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        /// A hash of the policy that has just been set. This must be included in a subsequent call that overwrites or updates this policy.
        public let policyHash: String?

        @inlinable
        public init(policyHash: String? = nil) {
            self.policyHash = policyHash
        }

        private enum CodingKeys: String, CodingKey {
            case policyHash = "PolicyHash"
        }
    }

    public struct PutSchemaVersionMetadataInput: AWSEncodableShape {
        /// The metadata key's corresponding value.
        public let metadataKeyValue: MetadataKeyValuePair
        /// The unique ID for the schema.
        public let schemaId: SchemaId?
        /// The unique version ID of the schema version.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let schemaVersionNumber: SchemaVersionNumber?

        @inlinable
        public init(metadataKeyValue: MetadataKeyValuePair, schemaId: SchemaId? = nil, schemaVersionId: String? = nil, schemaVersionNumber: SchemaVersionNumber? = nil) {
            self.metadataKeyValue = metadataKeyValue
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.metadataKeyValue.validate(name: "\(name).metadataKeyValue")
            try self.schemaId?.validate(name: "\(name).schemaId")
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.schemaVersionNumber?.validate(name: "\(name).schemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataKeyValue = "MetadataKeyValue"
            case schemaId = "SchemaId"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct PutSchemaVersionMetadataResponse: AWSDecodableShape {
        /// The latest version of the schema.
        public let latestVersion: Bool?
        /// The metadata key.
        public let metadataKey: String?
        /// The value of the metadata key.
        public let metadataValue: String?
        /// The name for the registry.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) for the schema.
        public let schemaArn: String?
        /// The name for the schema.
        public let schemaName: String?
        /// The unique version ID of the schema version.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let versionNumber: Int64?

        @inlinable
        public init(latestVersion: Bool? = nil, metadataKey: String? = nil, metadataValue: String? = nil, registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersionId: String? = nil, versionNumber: Int64? = nil) {
            self.latestVersion = latestVersion
            self.metadataKey = metadataKey
            self.metadataValue = metadataValue
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersionId = schemaVersionId
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case latestVersion = "LatestVersion"
            case metadataKey = "MetadataKey"
            case metadataValue = "MetadataValue"
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersionId = "SchemaVersionId"
            case versionNumber = "VersionNumber"
        }
    }

    public struct PutWorkflowRunPropertiesRequest: AWSEncodableShape {
        /// Name of the workflow which was run.
        public let name: String
        /// The ID of the workflow run for which the run properties should be updated.
        public let runId: String
        /// The properties to put for the specified run. Run properties may be logged. Do not pass plaintext secrets as properties. Retrieve secrets from a Glue Connection, Amazon Web Services Secrets Manager or other secret management mechanism if you intend to use them within the workflow run.
        public let runProperties: [String: String]

        @inlinable
        public init(name: String, runId: String, runProperties: [String: String]) {
            self.name = name
            self.runId = runId
            self.runProperties = runProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.runProperties.forEach {
                try validate($0.key, name: "runProperties.key", parent: name, max: 255)
                try validate($0.key, name: "runProperties.key", parent: name, min: 1)
                try validate($0.key, name: "runProperties.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case runId = "RunId"
            case runProperties = "RunProperties"
        }
    }

    public struct PutWorkflowRunPropertiesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct QuerySchemaVersionMetadataInput: AWSEncodableShape {
        /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
        public let maxResults: Int?
        /// Search key-value pairs for metadata, if they are not provided all the metadata information will be fetched.
        public let metadataList: [MetadataKeyValuePair]?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
        public let schemaId: SchemaId?
        /// The unique version ID of the schema version.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let schemaVersionNumber: SchemaVersionNumber?

        @inlinable
        public init(maxResults: Int? = nil, metadataList: [MetadataKeyValuePair]? = nil, nextToken: String? = nil, schemaId: SchemaId? = nil, schemaVersionId: String? = nil, schemaVersionNumber: SchemaVersionNumber? = nil) {
            self.maxResults = maxResults
            self.metadataList = metadataList
            self.nextToken = nextToken
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.metadataList?.forEach {
                try $0.validate(name: "\(name).metadataList[]")
            }
            try self.schemaId?.validate(name: "\(name).schemaId")
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.schemaVersionNumber?.validate(name: "\(name).schemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case metadataList = "MetadataList"
            case nextToken = "NextToken"
            case schemaId = "SchemaId"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct QuerySchemaVersionMetadataResponse: AWSDecodableShape {
        /// A map of a metadata key and associated values.
        public let metadataInfoMap: [String: MetadataInfo]?
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?
        /// The unique version ID of the schema version.
        public let schemaVersionId: String?

        @inlinable
        public init(metadataInfoMap: [String: MetadataInfo]? = nil, nextToken: String? = nil, schemaVersionId: String? = nil) {
            self.metadataInfoMap = metadataInfoMap
            self.nextToken = nextToken
            self.schemaVersionId = schemaVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case metadataInfoMap = "MetadataInfoMap"
            case nextToken = "NextToken"
            case schemaVersionId = "SchemaVersionId"
        }
    }

    public struct QuerySessionContext: AWSEncodableShape {
        /// An opaque string-string map passed by the query engine.
        public let additionalContext: [String: String]?
        /// An identifier string for the consumer cluster.
        public let clusterId: String?
        /// A cryptographically generated query identifier generated by Glue or Lake Formation.
        public let queryAuthorizationId: String?
        /// A unique identifier generated by the query engine for the query.
        public let queryId: String?
        /// A timestamp provided by the query engine for when the query started.
        public let queryStartTime: Date?

        @inlinable
        public init(additionalContext: [String: String]? = nil, clusterId: String? = nil, queryAuthorizationId: String? = nil, queryId: String? = nil, queryStartTime: Date? = nil) {
            self.additionalContext = additionalContext
            self.clusterId = clusterId
            self.queryAuthorizationId = queryAuthorizationId
            self.queryId = queryId
            self.queryStartTime = queryStartTime
        }

        public func validate(name: String) throws {
            try self.additionalContext?.forEach {
                try validate($0.key, name: "additionalContext.key", parent: name, max: 128)
                try validate($0.key, name: "additionalContext.key", parent: name, min: 1)
                try validate($0.value, name: "additionalContext[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.queryAuthorizationId, name: "queryAuthorizationId", parent: name, max: 255)
            try self.validate(self.queryAuthorizationId, name: "queryAuthorizationId", parent: name, min: 1)
            try self.validate(self.queryAuthorizationId, name: "queryAuthorizationId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.queryId, name: "queryId", parent: name, max: 255)
            try self.validate(self.queryId, name: "queryId", parent: name, min: 1)
            try self.validate(self.queryId, name: "queryId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalContext = "AdditionalContext"
            case clusterId = "ClusterId"
            case queryAuthorizationId = "QueryAuthorizationId"
            case queryId = "QueryId"
            case queryStartTime = "QueryStartTime"
        }
    }

    public struct Recipe: AWSEncodableShape & AWSDecodableShape {
        /// The nodes that are inputs to the recipe node, identified by id.
        public let inputs: [String]
        /// The name of the Glue Studio node.
        public let name: String
        /// A reference to the DataBrew recipe used by the node.
        public let recipeReference: RecipeReference?
        /// Transform steps used in the recipe node.
        public let recipeSteps: [RecipeStep]?

        @inlinable
        public init(inputs: [String], name: String, recipeReference: RecipeReference? = nil, recipeSteps: [RecipeStep]? = nil) {
            self.inputs = inputs
            self.name = name
            self.recipeReference = recipeReference
            self.recipeSteps = recipeSteps
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.recipeReference?.validate(name: "\(name).recipeReference")
            try self.recipeSteps?.forEach {
                try $0.validate(name: "\(name).recipeSteps[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case recipeReference = "RecipeReference"
            case recipeSteps = "RecipeSteps"
        }
    }

    public struct RecipeAction: AWSEncodableShape & AWSDecodableShape {
        /// The operation of the recipe action.
        public let operation: String
        /// The parameters of the recipe action.
        public let parameters: [String: String]?

        @inlinable
        public init(operation: String, parameters: [String: String]? = nil) {
            self.operation = operation
            self.parameters = parameters
        }

        public func validate(name: String) throws {
            try self.validate(self.operation, name: "operation", parent: name, max: 128)
            try self.validate(self.operation, name: "operation", parent: name, min: 1)
            try self.validate(self.operation, name: "operation", parent: name, pattern: "^[A-Z\\_]+$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 128)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[A-Za-z0-9]+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 32768)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case operation = "Operation"
            case parameters = "Parameters"
        }
    }

    public struct RecipeReference: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the DataBrew recipe.
        public let recipeArn: String
        /// The RecipeVersion of the DataBrew recipe.
        public let recipeVersion: String

        @inlinable
        public init(recipeArn: String, recipeVersion: String) {
            self.recipeArn = recipeArn
            self.recipeVersion = recipeVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.recipeArn, name: "recipeArn", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, max: 16)
            try self.validate(self.recipeVersion, name: "recipeVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case recipeArn = "RecipeArn"
            case recipeVersion = "RecipeVersion"
        }
    }

    public struct RecipeStep: AWSEncodableShape & AWSDecodableShape {
        /// The transformation action of the recipe step.
        public let action: RecipeAction
        /// The condition expressions for the recipe step.
        public let conditionExpressions: [ConditionExpression]?

        @inlinable
        public init(action: RecipeAction, conditionExpressions: [ConditionExpression]? = nil) {
            self.action = action
            self.conditionExpressions = conditionExpressions
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.conditionExpressions?.forEach {
                try $0.validate(name: "\(name).conditionExpressions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case conditionExpressions = "ConditionExpressions"
        }
    }

    public struct RecrawlPolicy: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run. A value of CRAWL_EVERYTHING specifies crawling the entire dataset again. A value of CRAWL_NEW_FOLDERS_ONLY specifies crawling only folders that were added since the last crawler run. A value of CRAWL_EVENT_MODE specifies crawling only the changes identified by Amazon S3 events.
        public let recrawlBehavior: RecrawlBehavior?

        @inlinable
        public init(recrawlBehavior: RecrawlBehavior? = nil) {
            self.recrawlBehavior = recrawlBehavior
        }

        private enum CodingKeys: String, CodingKey {
            case recrawlBehavior = "RecrawlBehavior"
        }
    }

    public struct RedshiftSource: AWSEncodableShape & AWSDecodableShape {
        /// The database to read from.
        public let database: String
        /// The name of the Amazon Redshift data store.
        public let name: String
        /// The Amazon S3 path where temporary data can be staged when copying out of the database.
        public let redshiftTmpDir: String?
        /// The database table to read from.
        public let table: String
        /// The IAM role with permissions.
        public let tmpDirIAMRole: String?

        @inlinable
        public init(database: String, name: String, redshiftTmpDir: String? = nil, table: String, tmpDirIAMRole: String? = nil) {
            self.database = database
            self.name = name
            self.redshiftTmpDir = redshiftTmpDir
            self.table = table
            self.tmpDirIAMRole = tmpDirIAMRole
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.redshiftTmpDir, name: "redshiftTmpDir", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.tmpDirIAMRole, name: "tmpDirIAMRole", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case name = "Name"
            case redshiftTmpDir = "RedshiftTmpDir"
            case table = "Table"
            case tmpDirIAMRole = "TmpDirIAMRole"
        }
    }

    public struct RedshiftTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to write to.
        public let database: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// The Amazon S3 path where temporary data can be staged when copying out of the database.
        public let redshiftTmpDir: String?
        /// The name of the table in the database to write to.
        public let table: String
        /// The IAM role with permissions.
        public let tmpDirIAMRole: String?
        /// The set of options to configure an upsert operation when writing to a Redshift target.
        public let upsertRedshiftOptions: UpsertRedshiftTargetOptions?

        @inlinable
        public init(database: String, inputs: [String], name: String, redshiftTmpDir: String? = nil, table: String, tmpDirIAMRole: String? = nil, upsertRedshiftOptions: UpsertRedshiftTargetOptions? = nil) {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.redshiftTmpDir = redshiftTmpDir
            self.table = table
            self.tmpDirIAMRole = tmpDirIAMRole
            self.upsertRedshiftOptions = upsertRedshiftOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.redshiftTmpDir, name: "redshiftTmpDir", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.tmpDirIAMRole, name: "tmpDirIAMRole", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.upsertRedshiftOptions?.validate(name: "\(name).upsertRedshiftOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case inputs = "Inputs"
            case name = "Name"
            case redshiftTmpDir = "RedshiftTmpDir"
            case table = "Table"
            case tmpDirIAMRole = "TmpDirIAMRole"
            case upsertRedshiftOptions = "UpsertRedshiftOptions"
        }
    }

    public struct RegisterSchemaVersionInput: AWSEncodableShape {
        /// The schema definition using the DataFormat setting for the SchemaName.
        public let schemaDefinition: String
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
        public let schemaId: SchemaId

        @inlinable
        public init(schemaDefinition: String, schemaId: SchemaId) {
            self.schemaDefinition = schemaDefinition
            self.schemaId = schemaId
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, max: 170000)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, min: 1)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, pattern: "\\S")
            try self.schemaId.validate(name: "\(name).schemaId")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaDefinition = "SchemaDefinition"
            case schemaId = "SchemaId"
        }
    }

    public struct RegisterSchemaVersionResponse: AWSDecodableShape {
        /// The unique ID that represents the version of this schema.
        public let schemaVersionId: String?
        /// The status of the schema version.
        public let status: SchemaVersionStatus?
        /// The version of this schema (for sync flow only, in case this is the first version).
        public let versionNumber: Int64?

        @inlinable
        public init(schemaVersionId: String? = nil, status: SchemaVersionStatus? = nil, versionNumber: Int64? = nil) {
            self.schemaVersionId = schemaVersionId
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case schemaVersionId = "SchemaVersionId"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct RegistryId: AWSEncodableShape {
        /// Arn of the registry to be updated. One of RegistryArn or RegistryName has to be provided.
        public let registryArn: String?
        /// Name of the registry. Used only for lookup. One of RegistryArn or RegistryName has to be provided.
        public let registryName: String?

        @inlinable
        public init(registryArn: String? = nil, registryName: String? = nil) {
            self.registryArn = registryArn
            self.registryName = registryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryArn, name: "registryArn", parent: name, max: 10240)
            try self.validate(self.registryArn, name: "registryArn", parent: name, min: 1)
            try self.validate(self.registryArn, name: "registryArn", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:glue:")
            try self.validate(self.registryName, name: "registryName", parent: name, max: 255)
            try self.validate(self.registryName, name: "registryName", parent: name, min: 1)
            try self.validate(self.registryName, name: "registryName", parent: name, pattern: "^[a-zA-Z0-9-_$#.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
        }
    }

    public struct RegistryListItem: AWSDecodableShape {
        /// The data the registry was created.
        public let createdTime: String?
        /// A description of the registry.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// The status of the registry.
        public let status: RegistryStatus?
        /// The date the registry was updated.
        public let updatedTime: String?

        @inlinable
        public init(createdTime: String? = nil, description: String? = nil, registryArn: String? = nil, registryName: String? = nil, status: RegistryStatus? = nil, updatedTime: String? = nil) {
            self.createdTime = createdTime
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.status = status
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case status = "Status"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct RelationalCatalogSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to read from.
        public let database: String
        /// The name of the data source.
        public let name: String
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(database: String, name: String, table: String) {
            self.database = database
            self.name = name
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case name = "Name"
            case table = "Table"
        }
    }

    public struct RemoveSchemaVersionMetadataInput: AWSEncodableShape {
        /// The value of the metadata key.
        public let metadataKeyValue: MetadataKeyValuePair
        /// A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
        public let schemaId: SchemaId?
        /// The unique version ID of the schema version.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let schemaVersionNumber: SchemaVersionNumber?

        @inlinable
        public init(metadataKeyValue: MetadataKeyValuePair, schemaId: SchemaId? = nil, schemaVersionId: String? = nil, schemaVersionNumber: SchemaVersionNumber? = nil) {
            self.metadataKeyValue = metadataKeyValue
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.metadataKeyValue.validate(name: "\(name).metadataKeyValue")
            try self.schemaId?.validate(name: "\(name).schemaId")
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.schemaVersionNumber?.validate(name: "\(name).schemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataKeyValue = "MetadataKeyValue"
            case schemaId = "SchemaId"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct RemoveSchemaVersionMetadataResponse: AWSDecodableShape {
        /// The latest version of the schema.
        public let latestVersion: Bool?
        /// The metadata key.
        public let metadataKey: String?
        /// The value of the metadata key.
        public let metadataValue: String?
        /// The name of the registry.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The version ID for the schema version.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let versionNumber: Int64?

        @inlinable
        public init(latestVersion: Bool? = nil, metadataKey: String? = nil, metadataValue: String? = nil, registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersionId: String? = nil, versionNumber: Int64? = nil) {
            self.latestVersion = latestVersion
            self.metadataKey = metadataKey
            self.metadataValue = metadataValue
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersionId = schemaVersionId
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case latestVersion = "LatestVersion"
            case metadataKey = "MetadataKey"
            case metadataValue = "MetadataValue"
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersionId = "SchemaVersionId"
            case versionNumber = "VersionNumber"
        }
    }

    public struct RenameField: AWSEncodableShape & AWSDecodableShape {
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String
        /// A JSON path to a variable in the data structure for the source data.
        public let sourcePath: [String]
        /// A JSON path to a variable in the data structure for the target data.
        public let targetPath: [String]

        @inlinable
        public init(inputs: [String], name: String, sourcePath: [String], targetPath: [String]) {
            self.inputs = inputs
            self.name = name
            self.sourcePath = sourcePath
            self.targetPath = targetPath
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.sourcePath.forEach {
                try validate($0, name: "sourcePath[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.targetPath.forEach {
                try validate($0, name: "targetPath[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case sourcePath = "SourcePath"
            case targetPath = "TargetPath"
        }
    }

    public struct ResetJobBookmarkRequest: AWSEncodableShape {
        /// The name of the job in question.
        public let jobName: String
        /// The unique run identifier associated with this job run.
        public let runId: String?

        @inlinable
        public init(jobName: String, runId: String? = nil) {
            self.jobName = jobName
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case runId = "RunId"
        }
    }

    public struct ResetJobBookmarkResponse: AWSDecodableShape {
        /// The reset bookmark entry.
        public let jobBookmarkEntry: JobBookmarkEntry?

        @inlinable
        public init(jobBookmarkEntry: JobBookmarkEntry? = nil) {
            self.jobBookmarkEntry = jobBookmarkEntry
        }

        private enum CodingKeys: String, CodingKey {
            case jobBookmarkEntry = "JobBookmarkEntry"
        }
    }

    public struct ResourceUri: AWSEncodableShape & AWSDecodableShape {
        /// The type of the resource.
        public let resourceType: ResourceType?
        /// The URI for accessing the resource.
        public let uri: String?

        @inlinable
        public init(resourceType: ResourceType? = nil, uri: String? = nil) {
            self.resourceType = resourceType
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "ResourceType"
            case uri = "Uri"
        }
    }

    public struct ResumeWorkflowRunRequest: AWSEncodableShape {
        /// The name of the workflow to resume.
        public let name: String
        /// A list of the node IDs for the nodes you want to restart. The nodes that are to be restarted must have a run attempt in the original run.
        public let nodeIds: [String]
        /// The ID of the workflow run to resume.
        public let runId: String

        @inlinable
        public init(name: String, nodeIds: [String], runId: String) {
            self.name = name
            self.nodeIds = nodeIds
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.nodeIds.forEach {
                try validate($0, name: "nodeIds[]", parent: name, max: 255)
                try validate($0, name: "nodeIds[]", parent: name, min: 1)
                try validate($0, name: "nodeIds[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case nodeIds = "NodeIds"
            case runId = "RunId"
        }
    }

    public struct ResumeWorkflowRunResponse: AWSDecodableShape {
        /// A list of the node IDs for the nodes that were actually restarted.
        public let nodeIds: [String]?
        /// The new ID assigned to the resumed workflow run. Each resume of a workflow run will have a new run ID.
        public let runId: String?

        @inlinable
        public init(nodeIds: [String]? = nil, runId: String? = nil) {
            self.nodeIds = nodeIds
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case nodeIds = "NodeIds"
            case runId = "RunId"
        }
    }

    public struct RetentionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for an Iceberg snapshot retention optimizer.
        public let icebergConfiguration: IcebergRetentionConfiguration?

        @inlinable
        public init(icebergConfiguration: IcebergRetentionConfiguration? = nil) {
            self.icebergConfiguration = icebergConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case icebergConfiguration = "icebergConfiguration"
        }
    }

    public struct RetentionMetrics: AWSDecodableShape {
        /// A structure containing the Iceberg retention metrics for the optimizer run.
        public let icebergMetrics: IcebergRetentionMetrics?

        @inlinable
        public init(icebergMetrics: IcebergRetentionMetrics? = nil) {
            self.icebergMetrics = icebergMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case icebergMetrics = "IcebergMetrics"
        }
    }

    public struct RunIdentifier: AWSDecodableShape {
        /// The Job Run ID.
        public let jobRunId: String?
        /// The Run ID.
        public let runId: String?

        @inlinable
        public init(jobRunId: String? = nil, runId: String? = nil) {
            self.jobRunId = jobRunId
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case jobRunId = "JobRunId"
            case runId = "RunId"
        }
    }

    public struct RunMetrics: AWSDecodableShape {
        /// The duration of the job in hours.
        public let jobDurationInHour: String?
        /// The number of bytes removed by the compaction job run.
        public let numberOfBytesCompacted: String?
        /// The number of DPUs consumed by the job, rounded up to the nearest whole number.
        public let numberOfDpus: String?
        /// The number of files removed by the compaction job run.
        public let numberOfFilesCompacted: String?

        @inlinable
        public init(jobDurationInHour: String? = nil, numberOfBytesCompacted: String? = nil, numberOfDpus: String? = nil, numberOfFilesCompacted: String? = nil) {
            self.jobDurationInHour = jobDurationInHour
            self.numberOfBytesCompacted = numberOfBytesCompacted
            self.numberOfDpus = numberOfDpus
            self.numberOfFilesCompacted = numberOfFilesCompacted
        }

        private enum CodingKeys: String, CodingKey {
            case jobDurationInHour = "JobDurationInHour"
            case numberOfBytesCompacted = "NumberOfBytesCompacted"
            case numberOfDpus = "NumberOfDpus"
            case numberOfFilesCompacted = "NumberOfFilesCompacted"
        }
    }

    public struct RunStatementRequest: AWSEncodableShape {
        /// The statement code to be run.
        public let code: String
        /// The origin of the request.
        public let requestOrigin: String?
        /// The Session Id of the statement to be run.
        public let sessionId: String

        @inlinable
        public init(code: String, requestOrigin: String? = nil, sessionId: String) {
            self.code = code
            self.requestOrigin = requestOrigin
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, max: 68000)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, max: 128)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, min: 1)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 255)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case requestOrigin = "RequestOrigin"
            case sessionId = "SessionId"
        }
    }

    public struct RunStatementResponse: AWSDecodableShape {
        /// Returns the Id of the statement that was run.
        public let id: Int?

        @inlinable
        public init(id: Int? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct S3CatalogDeltaSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalDeltaOptions: [String: String]?
        /// The name of the database to read from.
        public let database: String
        /// The name of the Delta Lake data source.
        public let name: String
        /// Specifies the data schema for the Delta Lake source.
        public let outputSchemas: [GlueSchema]?
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(additionalDeltaOptions: [String: String]? = nil, database: String, name: String, outputSchemas: [GlueSchema]? = nil, table: String) {
            self.additionalDeltaOptions = additionalDeltaOptions
            self.database = database
            self.name = name
            self.outputSchemas = outputSchemas
            self.table = table
        }

        public func validate(name: String) throws {
            try self.additionalDeltaOptions?.forEach {
                try validate($0.key, name: "additionalDeltaOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalDeltaOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalDeltaOptions = "AdditionalDeltaOptions"
            case database = "Database"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case table = "Table"
        }
    }

    public struct S3CatalogHudiSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalHudiOptions: [String: String]?
        /// The name of the database to read from.
        public let database: String
        /// The name of the Hudi data source.
        public let name: String
        /// Specifies the data schema for the Hudi source.
        public let outputSchemas: [GlueSchema]?
        /// The name of the table in the database to read from.
        public let table: String

        @inlinable
        public init(additionalHudiOptions: [String: String]? = nil, database: String, name: String, outputSchemas: [GlueSchema]? = nil, table: String) {
            self.additionalHudiOptions = additionalHudiOptions
            self.database = database
            self.name = name
            self.outputSchemas = outputSchemas
            self.table = table
        }

        public func validate(name: String) throws {
            try self.additionalHudiOptions?.forEach {
                try validate($0.key, name: "additionalHudiOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalHudiOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalHudiOptions = "AdditionalHudiOptions"
            case database = "Database"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case table = "Table"
        }
    }

    public struct S3CatalogSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalOptions: S3SourceAdditionalOptions?
        /// The database to read from.
        public let database: String
        /// The name of the data store.
        public let name: String
        /// Partitions satisfying this predicate are deleted. Files within the retention period in these partitions are not deleted. Set to ""  empty by default.
        public let partitionPredicate: String?
        /// The database table to read from.
        public let table: String

        @inlinable
        public init(additionalOptions: S3SourceAdditionalOptions? = nil, database: String, name: String, partitionPredicate: String? = nil, table: String) {
            self.additionalOptions = additionalOptions
            self.database = database
            self.name = name
            self.partitionPredicate = partitionPredicate
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.partitionPredicate, name: "partitionPredicate", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case database = "Database"
            case name = "Name"
            case partitionPredicate = "PartitionPredicate"
            case table = "Table"
        }
    }

    public struct S3CatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to write to.
        public let database: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// Specifies native partitioning using a sequence of keys.
        public let partitionKeys: [[String]]?
        /// A policy that specifies update behavior for the crawler.
        public let schemaChangePolicy: CatalogSchemaChangePolicy?
        /// The name of the table in the database to write to.
        public let table: String

        @inlinable
        public init(database: String, inputs: [String], name: String, partitionKeys: [[String]]? = nil, schemaChangePolicy: CatalogSchemaChangePolicy? = nil, table: String) {
            self.database = database
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaChangePolicy = schemaChangePolicy
            self.table = table
        }

        public func validate(name: String) throws {
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
            case inputs = "Inputs"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case schemaChangePolicy = "SchemaChangePolicy"
            case table = "Table"
        }
    }

    public struct S3CsvSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalOptions: S3DirectSourceAdditionalOptions?
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public let compressionType: CompressionType?
        /// Specifies a character to use for escaping. This option is used only when reading CSV files. The default value is none. If enabled, the character which immediately follows is used as-is, except for a small set of well-known escapes (\n, \r, \t, and \0).
        public let escaper: String?
        /// A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files.
        public let exclusions: [String]?
        /// Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to "none".
        public let groupFiles: String?
        /// The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, "groupFiles" must be set to "inPartition" for this to take effect.
        public let groupSize: String?
        /// This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.
        public let maxBand: Int?
        /// This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.
        public let maxFilesInBand: Int?
        /// A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is False, which allows for more aggressive file-splitting during parsing.
        public let multiline: Bool?
        /// The name of the data store.
        public let name: String
        /// A Boolean value that specifies whether to use the advanced SIMD CSV reader along with Apache Arrow based columnar memory formats. Only available in Glue version 3.0.
        public let optimizePerformance: Bool?
        /// Specifies the data schema for the S3 CSV source.
        public let outputSchemas: [GlueSchema]?
        /// A list of the Amazon S3 paths to read from.
        public let paths: [String]
        /// Specifies the character to use for quoting. The default is a double quote: '"'. Set this to -1 to turn off quoting entirely.
        public let quoteChar: QuoteChar
        /// If set to true, recursively reads files in all subdirectories under the specified paths.
        public let recurse: Bool?
        /// Specifies the delimiter character. The default is a comma: ",", but any other character can be specified.
        public let separator: Separator
        /// A Boolean value that specifies whether to skip the first data line. The default value is False.
        public let skipFirst: Bool?
        /// A Boolean value that specifies whether to treat the first line as a header. The default value is False.
        public let withHeader: Bool?
        /// A Boolean value that specifies whether to write the header to output. The default value is True.
        public let writeHeader: Bool?

        @inlinable
        public init(additionalOptions: S3DirectSourceAdditionalOptions? = nil, compressionType: CompressionType? = nil, escaper: String? = nil, exclusions: [String]? = nil, groupFiles: String? = nil, groupSize: String? = nil, maxBand: Int? = nil, maxFilesInBand: Int? = nil, multiline: Bool? = nil, name: String, optimizePerformance: Bool? = nil, outputSchemas: [GlueSchema]? = nil, paths: [String], quoteChar: QuoteChar, recurse: Bool? = nil, separator: Separator, skipFirst: Bool? = nil, withHeader: Bool? = nil, writeHeader: Bool? = nil) {
            self.additionalOptions = additionalOptions
            self.compressionType = compressionType
            self.escaper = escaper
            self.exclusions = exclusions
            self.groupFiles = groupFiles
            self.groupSize = groupSize
            self.maxBand = maxBand
            self.maxFilesInBand = maxFilesInBand
            self.multiline = multiline
            self.name = name
            self.optimizePerformance = optimizePerformance
            self.outputSchemas = outputSchemas
            self.paths = paths
            self.quoteChar = quoteChar
            self.recurse = recurse
            self.separator = separator
            self.skipFirst = skipFirst
            self.withHeader = withHeader
            self.writeHeader = writeHeader
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.validate(name: "\(name).additionalOptions")
            try self.validate(self.escaper, name: "escaper", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.exclusions?.forEach {
                try validate($0, name: "exclusions[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.groupFiles, name: "groupFiles", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.groupSize, name: "groupSize", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.maxBand, name: "maxBand", parent: name, min: 0)
            try self.validate(self.maxFilesInBand, name: "maxFilesInBand", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.paths.forEach {
                try validate($0, name: "paths[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case compressionType = "CompressionType"
            case escaper = "Escaper"
            case exclusions = "Exclusions"
            case groupFiles = "GroupFiles"
            case groupSize = "GroupSize"
            case maxBand = "MaxBand"
            case maxFilesInBand = "MaxFilesInBand"
            case multiline = "Multiline"
            case name = "Name"
            case optimizePerformance = "OptimizePerformance"
            case outputSchemas = "OutputSchemas"
            case paths = "Paths"
            case quoteChar = "QuoteChar"
            case recurse = "Recurse"
            case separator = "Separator"
            case skipFirst = "SkipFirst"
            case withHeader = "WithHeader"
            case writeHeader = "WriteHeader"
        }
    }

    public struct S3DeltaCatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options for the connector.
        public let additionalOptions: [String: String]?
        /// The name of the database to write to.
        public let database: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// Specifies native partitioning using a sequence of keys.
        public let partitionKeys: [[String]]?
        /// A policy that specifies update behavior for the crawler.
        public let schemaChangePolicy: CatalogSchemaChangePolicy?
        /// The name of the table in the database to write to.
        public let table: String

        @inlinable
        public init(additionalOptions: [String: String]? = nil, database: String, inputs: [String], name: String, partitionKeys: [[String]]? = nil, schemaChangePolicy: CatalogSchemaChangePolicy? = nil, table: String) {
            self.additionalOptions = additionalOptions
            self.database = database
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaChangePolicy = schemaChangePolicy
            self.table = table
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.forEach {
                try validate($0.key, name: "additionalOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case database = "Database"
            case inputs = "Inputs"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case schemaChangePolicy = "SchemaChangePolicy"
            case table = "Table"
        }
    }

    public struct S3DeltaDirectTarget: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options for the connector.
        public let additionalOptions: [String: String]?
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public let compression: DeltaTargetCompressionType
        /// Specifies the data output format for the target.
        public let format: TargetFormat
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// Specifies native partitioning using a sequence of keys.
        public let partitionKeys: [[String]]?
        /// The Amazon S3 path of your Delta Lake data source to write to.
        public let path: String
        /// A policy that specifies update behavior for the crawler.
        public let schemaChangePolicy: DirectSchemaChangePolicy?

        @inlinable
        public init(additionalOptions: [String: String]? = nil, compression: DeltaTargetCompressionType, format: TargetFormat, inputs: [String], name: String, partitionKeys: [[String]]? = nil, path: String, schemaChangePolicy: DirectSchemaChangePolicy? = nil) {
            self.additionalOptions = additionalOptions
            self.compression = compression
            self.format = format
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.path = path
            self.schemaChangePolicy = schemaChangePolicy
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.forEach {
                try validate($0.key, name: "additionalOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.path, name: "path", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.schemaChangePolicy?.validate(name: "\(name).schemaChangePolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case compression = "Compression"
            case format = "Format"
            case inputs = "Inputs"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case path = "Path"
            case schemaChangePolicy = "SchemaChangePolicy"
        }
    }

    public struct S3DeltaSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalDeltaOptions: [String: String]?
        /// Specifies additional options for the connector.
        public let additionalOptions: S3DirectSourceAdditionalOptions?
        /// The name of the Delta Lake source.
        public let name: String
        /// Specifies the data schema for the Delta Lake source.
        public let outputSchemas: [GlueSchema]?
        /// A list of the Amazon S3 paths to read from.
        public let paths: [String]

        @inlinable
        public init(additionalDeltaOptions: [String: String]? = nil, additionalOptions: S3DirectSourceAdditionalOptions? = nil, name: String, outputSchemas: [GlueSchema]? = nil, paths: [String]) {
            self.additionalDeltaOptions = additionalDeltaOptions
            self.additionalOptions = additionalOptions
            self.name = name
            self.outputSchemas = outputSchemas
            self.paths = paths
        }

        public func validate(name: String) throws {
            try self.additionalDeltaOptions?.forEach {
                try validate($0.key, name: "additionalDeltaOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalDeltaOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.additionalOptions?.validate(name: "\(name).additionalOptions")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.paths.forEach {
                try validate($0, name: "paths[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalDeltaOptions = "AdditionalDeltaOptions"
            case additionalOptions = "AdditionalOptions"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case paths = "Paths"
        }
    }

    public struct S3DirectSourceAdditionalOptions: AWSEncodableShape & AWSDecodableShape {
        /// Sets the upper limit for the target number of files that will be processed.
        public let boundedFiles: Int64?
        /// Sets the upper limit for the target size of the dataset in bytes that will be processed.
        public let boundedSize: Int64?
        /// Sets option to enable a sample path.
        public let enableSamplePath: Bool?
        /// If enabled, specifies the sample path.
        public let samplePath: String?

        @inlinable
        public init(boundedFiles: Int64? = nil, boundedSize: Int64? = nil, enableSamplePath: Bool? = nil, samplePath: String? = nil) {
            self.boundedFiles = boundedFiles
            self.boundedSize = boundedSize
            self.enableSamplePath = enableSamplePath
            self.samplePath = samplePath
        }

        public func validate(name: String) throws {
            try self.validate(self.samplePath, name: "samplePath", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case boundedFiles = "BoundedFiles"
            case boundedSize = "BoundedSize"
            case enableSamplePath = "EnableSamplePath"
            case samplePath = "SamplePath"
        }
    }

    public struct S3DirectTarget: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public let compression: String?
        /// Specifies the data output format for the target.
        public let format: TargetFormat
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// Specifies native partitioning using a sequence of keys.
        public let partitionKeys: [[String]]?
        /// A single Amazon S3 path to write to.
        public let path: String
        /// A policy that specifies update behavior for the crawler.
        public let schemaChangePolicy: DirectSchemaChangePolicy?

        @inlinable
        public init(compression: String? = nil, format: TargetFormat, inputs: [String], name: String, partitionKeys: [[String]]? = nil, path: String, schemaChangePolicy: DirectSchemaChangePolicy? = nil) {
            self.compression = compression
            self.format = format
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.path = path
            self.schemaChangePolicy = schemaChangePolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.compression, name: "compression", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.path, name: "path", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.schemaChangePolicy?.validate(name: "\(name).schemaChangePolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case compression = "Compression"
            case format = "Format"
            case inputs = "Inputs"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case path = "Path"
            case schemaChangePolicy = "SchemaChangePolicy"
        }
    }

    public struct S3Encryption: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        public let kmsKeyArn: String?
        /// The encryption mode to use for Amazon S3 data.
        public let s3EncryptionMode: S3EncryptionMode?

        @inlinable
        public init(kmsKeyArn: String? = nil, s3EncryptionMode: S3EncryptionMode? = nil) {
            self.kmsKeyArn = kmsKeyArn
            self.s3EncryptionMode = s3EncryptionMode
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KmsKeyArn"
            case s3EncryptionMode = "S3EncryptionMode"
        }
    }

    public struct S3GlueParquetTarget: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public let compression: ParquetCompressionType?
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// Specifies native partitioning using a sequence of keys.
        public let partitionKeys: [[String]]?
        /// A single Amazon S3 path to write to.
        public let path: String
        /// A policy that specifies update behavior for the crawler.
        public let schemaChangePolicy: DirectSchemaChangePolicy?

        @inlinable
        public init(compression: ParquetCompressionType? = nil, inputs: [String], name: String, partitionKeys: [[String]]? = nil, path: String, schemaChangePolicy: DirectSchemaChangePolicy? = nil) {
            self.compression = compression
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.path = path
            self.schemaChangePolicy = schemaChangePolicy
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.path, name: "path", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.schemaChangePolicy?.validate(name: "\(name).schemaChangePolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case compression = "Compression"
            case inputs = "Inputs"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case path = "Path"
            case schemaChangePolicy = "SchemaChangePolicy"
        }
    }

    public struct S3HudiCatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options for the connector.
        public let additionalOptions: [String: String]
        /// The name of the database to write to.
        public let database: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// Specifies native partitioning using a sequence of keys.
        public let partitionKeys: [[String]]?
        /// A policy that specifies update behavior for the crawler.
        public let schemaChangePolicy: CatalogSchemaChangePolicy?
        /// The name of the table in the database to write to.
        public let table: String

        @inlinable
        public init(additionalOptions: [String: String], database: String, inputs: [String], name: String, partitionKeys: [[String]]? = nil, schemaChangePolicy: CatalogSchemaChangePolicy? = nil, table: String) {
            self.additionalOptions = additionalOptions
            self.database = database
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaChangePolicy = schemaChangePolicy
            self.table = table
        }

        public func validate(name: String) throws {
            try self.additionalOptions.forEach {
                try validate($0.key, name: "additionalOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.database, name: "database", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.table, name: "table", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case database = "Database"
            case inputs = "Inputs"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case schemaChangePolicy = "SchemaChangePolicy"
            case table = "Table"
        }
    }

    public struct S3HudiDirectTarget: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options for the connector.
        public let additionalOptions: [String: String]
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public let compression: HudiTargetCompressionType
        /// Specifies the data output format for the target.
        public let format: TargetFormat
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// Specifies native partitioning using a sequence of keys.
        public let partitionKeys: [[String]]?
        /// The Amazon S3 path of your Hudi data source to write to.
        public let path: String
        /// A policy that specifies update behavior for the crawler.
        public let schemaChangePolicy: DirectSchemaChangePolicy?

        @inlinable
        public init(additionalOptions: [String: String], compression: HudiTargetCompressionType, format: TargetFormat, inputs: [String], name: String, partitionKeys: [[String]]? = nil, path: String, schemaChangePolicy: DirectSchemaChangePolicy? = nil) {
            self.additionalOptions = additionalOptions
            self.compression = compression
            self.format = format
            self.inputs = inputs
            self.name = name
            self.partitionKeys = partitionKeys
            self.path = path
            self.schemaChangePolicy = schemaChangePolicy
        }

        public func validate(name: String) throws {
            try self.additionalOptions.forEach {
                try validate($0.key, name: "additionalOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.path, name: "path", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.schemaChangePolicy?.validate(name: "\(name).schemaChangePolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case compression = "Compression"
            case format = "Format"
            case inputs = "Inputs"
            case name = "Name"
            case partitionKeys = "PartitionKeys"
            case path = "Path"
            case schemaChangePolicy = "SchemaChangePolicy"
        }
    }

    public struct S3HudiSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalHudiOptions: [String: String]?
        /// Specifies additional options for the connector.
        public let additionalOptions: S3DirectSourceAdditionalOptions?
        /// The name of the Hudi source.
        public let name: String
        /// Specifies the data schema for the Hudi source.
        public let outputSchemas: [GlueSchema]?
        /// A list of the Amazon S3 paths to read from.
        public let paths: [String]

        @inlinable
        public init(additionalHudiOptions: [String: String]? = nil, additionalOptions: S3DirectSourceAdditionalOptions? = nil, name: String, outputSchemas: [GlueSchema]? = nil, paths: [String]) {
            self.additionalHudiOptions = additionalHudiOptions
            self.additionalOptions = additionalOptions
            self.name = name
            self.outputSchemas = outputSchemas
            self.paths = paths
        }

        public func validate(name: String) throws {
            try self.additionalHudiOptions?.forEach {
                try validate($0.key, name: "additionalHudiOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalHudiOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.additionalOptions?.validate(name: "\(name).additionalOptions")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.paths.forEach {
                try validate($0, name: "paths[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalHudiOptions = "AdditionalHudiOptions"
            case additionalOptions = "AdditionalOptions"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case paths = "Paths"
        }
    }

    public struct S3JsonSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalOptions: S3DirectSourceAdditionalOptions?
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public let compressionType: CompressionType?
        /// A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files.
        public let exclusions: [String]?
        /// Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to "none".
        public let groupFiles: String?
        /// The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, "groupFiles" must be set to "inPartition" for this to take effect.
        public let groupSize: String?
        /// A JsonPath string defining the JSON data.
        public let jsonPath: String?
        /// This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.
        public let maxBand: Int?
        /// This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.
        public let maxFilesInBand: Int?
        /// A Boolean value that specifies whether a single record can span multiple lines. This can occur when a field contains a quoted new-line character. You must set this option to True if any record spans multiple lines. The default value is False, which allows for more aggressive file-splitting during parsing.
        public let multiline: Bool?
        /// The name of the data store.
        public let name: String
        /// Specifies the data schema for the S3 JSON source.
        public let outputSchemas: [GlueSchema]?
        /// A list of the Amazon S3 paths to read from.
        public let paths: [String]
        /// If set to true, recursively reads files in all subdirectories under the specified paths.
        public let recurse: Bool?

        @inlinable
        public init(additionalOptions: S3DirectSourceAdditionalOptions? = nil, compressionType: CompressionType? = nil, exclusions: [String]? = nil, groupFiles: String? = nil, groupSize: String? = nil, jsonPath: String? = nil, maxBand: Int? = nil, maxFilesInBand: Int? = nil, multiline: Bool? = nil, name: String, outputSchemas: [GlueSchema]? = nil, paths: [String], recurse: Bool? = nil) {
            self.additionalOptions = additionalOptions
            self.compressionType = compressionType
            self.exclusions = exclusions
            self.groupFiles = groupFiles
            self.groupSize = groupSize
            self.jsonPath = jsonPath
            self.maxBand = maxBand
            self.maxFilesInBand = maxFilesInBand
            self.multiline = multiline
            self.name = name
            self.outputSchemas = outputSchemas
            self.paths = paths
            self.recurse = recurse
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.validate(name: "\(name).additionalOptions")
            try self.exclusions?.forEach {
                try validate($0, name: "exclusions[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.groupFiles, name: "groupFiles", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.groupSize, name: "groupSize", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.jsonPath, name: "jsonPath", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.maxBand, name: "maxBand", parent: name, min: 0)
            try self.validate(self.maxFilesInBand, name: "maxFilesInBand", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.paths.forEach {
                try validate($0, name: "paths[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case compressionType = "CompressionType"
            case exclusions = "Exclusions"
            case groupFiles = "GroupFiles"
            case groupSize = "GroupSize"
            case jsonPath = "JsonPath"
            case maxBand = "MaxBand"
            case maxFilesInBand = "MaxFilesInBand"
            case multiline = "Multiline"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case paths = "Paths"
            case recurse = "Recurse"
        }
    }

    public struct S3ParquetSource: AWSEncodableShape & AWSDecodableShape {
        /// Specifies additional connection options.
        public let additionalOptions: S3DirectSourceAdditionalOptions?
        /// Specifies how the data is compressed. This is generally not necessary if the data has a standard file extension. Possible values are "gzip" and "bzip").
        public let compressionType: ParquetCompressionType?
        /// A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]" excludes all PDF files.
        public let exclusions: [String]?
        /// Grouping files is turned on by default when the input contains more than 50,000 files. To turn on grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when there are more than 50,000 files, set this parameter to "none".
        public let groupFiles: String?
        /// The target group size in bytes. The default is computed based on the input data size and the size of your cluster. When there are fewer than 50,000 input files, "groupFiles" must be set to "inPartition" for this to take effect.
        public let groupSize: String?
        /// This option controls the duration in milliseconds after which the s3 listing is likely to be consistent. Files with modification timestamps falling within the last maxBand milliseconds are tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users don't need to set this option. The default is 900000 milliseconds, or 15 minutes.
        public let maxBand: Int?
        /// This option specifies the maximum number of files to save from the last maxBand seconds. If this number is exceeded, extra files are skipped and only processed in the next job run.
        public let maxFilesInBand: Int?
        /// The name of the data store.
        public let name: String
        /// Specifies the data schema for the S3 Parquet source.
        public let outputSchemas: [GlueSchema]?
        /// A list of the Amazon S3 paths to read from.
        public let paths: [String]
        /// If set to true, recursively reads files in all subdirectories under the specified paths.
        public let recurse: Bool?

        @inlinable
        public init(additionalOptions: S3DirectSourceAdditionalOptions? = nil, compressionType: ParquetCompressionType? = nil, exclusions: [String]? = nil, groupFiles: String? = nil, groupSize: String? = nil, maxBand: Int? = nil, maxFilesInBand: Int? = nil, name: String, outputSchemas: [GlueSchema]? = nil, paths: [String], recurse: Bool? = nil) {
            self.additionalOptions = additionalOptions
            self.compressionType = compressionType
            self.exclusions = exclusions
            self.groupFiles = groupFiles
            self.groupSize = groupSize
            self.maxBand = maxBand
            self.maxFilesInBand = maxFilesInBand
            self.name = name
            self.outputSchemas = outputSchemas
            self.paths = paths
            self.recurse = recurse
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.validate(name: "\(name).additionalOptions")
            try self.exclusions?.forEach {
                try validate($0, name: "exclusions[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.groupFiles, name: "groupFiles", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.groupSize, name: "groupSize", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.maxBand, name: "maxBand", parent: name, min: 0)
            try self.validate(self.maxFilesInBand, name: "maxFilesInBand", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.paths.forEach {
                try validate($0, name: "paths[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case compressionType = "CompressionType"
            case exclusions = "Exclusions"
            case groupFiles = "GroupFiles"
            case groupSize = "GroupSize"
            case maxBand = "MaxBand"
            case maxFilesInBand = "MaxFilesInBand"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case paths = "Paths"
            case recurse = "Recurse"
        }
    }

    public struct S3SourceAdditionalOptions: AWSEncodableShape & AWSDecodableShape {
        /// Sets the upper limit for the target number of files that will be processed.
        public let boundedFiles: Int64?
        /// Sets the upper limit for the target size of the dataset in bytes that will be processed.
        public let boundedSize: Int64?

        @inlinable
        public init(boundedFiles: Int64? = nil, boundedSize: Int64? = nil) {
            self.boundedFiles = boundedFiles
            self.boundedSize = boundedSize
        }

        private enum CodingKeys: String, CodingKey {
            case boundedFiles = "BoundedFiles"
            case boundedSize = "BoundedSize"
        }
    }

    public struct S3Target: AWSEncodableShape & AWSDecodableShape {
        /// The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon Virtual Private Cloud environment (Amazon VPC).
        public let connectionName: String?
        /// A valid Amazon dead-letter SQS ARN. For example, arn:aws:sqs:region:account:deadLetterQueue.
        public let dlqEventQueueArn: String?
        /// A valid Amazon SQS ARN. For example, arn:aws:sqs:region:account:sqs.
        public let eventQueueArn: String?
        /// A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler.
        public let exclusions: [String]?
        /// The path to the Amazon S3 target.
        public let path: String?
        /// Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
        public let sampleSize: Int?

        @inlinable
        public init(connectionName: String? = nil, dlqEventQueueArn: String? = nil, eventQueueArn: String? = nil, exclusions: [String]? = nil, path: String? = nil, sampleSize: Int? = nil) {
            self.connectionName = connectionName
            self.dlqEventQueueArn = dlqEventQueueArn
            self.eventQueueArn = eventQueueArn
            self.exclusions = exclusions
            self.path = path
            self.sampleSize = sampleSize
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case dlqEventQueueArn = "DlqEventQueueArn"
            case eventQueueArn = "EventQueueArn"
            case exclusions = "Exclusions"
            case path = "Path"
            case sampleSize = "SampleSize"
        }
    }

    public struct Schedule: AWSDecodableShape {
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let scheduleExpression: String?
        /// The state of the schedule.
        public let state: ScheduleState?

        @inlinable
        public init(scheduleExpression: String? = nil, state: ScheduleState? = nil) {
            self.scheduleExpression = scheduleExpression
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleExpression = "ScheduleExpression"
            case state = "State"
        }
    }

    public struct SchemaChangePolicy: AWSEncodableShape & AWSDecodableShape {
        /// The deletion behavior when the crawler finds a deleted object.
        public let deleteBehavior: DeleteBehavior?
        /// The update behavior when the crawler finds a changed schema.
        public let updateBehavior: UpdateBehavior?

        @inlinable
        public init(deleteBehavior: DeleteBehavior? = nil, updateBehavior: UpdateBehavior? = nil) {
            self.deleteBehavior = deleteBehavior
            self.updateBehavior = updateBehavior
        }

        private enum CodingKeys: String, CodingKey {
            case deleteBehavior = "DeleteBehavior"
            case updateBehavior = "UpdateBehavior"
        }
    }

    public struct SchemaColumn: AWSEncodableShape & AWSDecodableShape {
        /// The type of data in the column.
        public let dataType: String?
        /// The name of the column.
        public let name: String?

        @inlinable
        public init(dataType: String? = nil, name: String? = nil) {
            self.dataType = dataType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.dataType, name: "dataType", parent: name, max: 131072)
            try self.validate(self.dataType, name: "dataType", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "DataType"
            case name = "Name"
        }
    }

    public struct SchemaId: AWSEncodableShape & AWSDecodableShape {
        /// The name of the schema registry that contains the schema.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.
        public let schemaArn: String?
        /// The name of the schema. One of SchemaArn or SchemaName has to be provided.
        public let schemaName: String?

        @inlinable
        public init(registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil) {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryName, name: "registryName", parent: name, max: 255)
            try self.validate(self.registryName, name: "registryName", parent: name, min: 1)
            try self.validate(self.registryName, name: "registryName", parent: name, pattern: "^[a-zA-Z0-9-_$#.]+$")
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, max: 10240)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, min: 1)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:glue:")
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[a-zA-Z0-9-_$#.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
        }
    }

    public struct SchemaListItem: AWSDecodableShape {
        /// The date and time that a schema was created.
        public let createdTime: String?
        /// A description for the schema.
        public let description: String?
        /// the name of the registry where the schema resides.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) for the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The status of the schema.
        public let schemaStatus: SchemaStatus?
        /// The date and time that a schema was updated.
        public let updatedTime: String?

        @inlinable
        public init(createdTime: String? = nil, description: String? = nil, registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaStatus: SchemaStatus? = nil, updatedTime: String? = nil) {
            self.createdTime = createdTime
            self.description = description
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaStatus = schemaStatus
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case description = "Description"
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaStatus = "SchemaStatus"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct SchemaReference: AWSEncodableShape & AWSDecodableShape {
        /// A structure that contains schema identity fields. Either this or the SchemaVersionId has to be provided.
        public let schemaId: SchemaId?
        /// The unique ID assigned to a version of the schema. Either this or the SchemaId has to be provided.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let schemaVersionNumber: Int64?

        @inlinable
        public init(schemaId: SchemaId? = nil, schemaVersionId: String? = nil, schemaVersionNumber: Int64? = nil) {
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.schemaId?.validate(name: "\(name).schemaId")
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.schemaVersionNumber, name: "schemaVersionNumber", parent: name, max: 100000)
            try self.validate(self.schemaVersionNumber, name: "schemaVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case schemaId = "SchemaId"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct SchemaVersionErrorItem: AWSDecodableShape {
        /// The details of the error for the schema version.
        public let errorDetails: ErrorDetails?
        /// The version number of the schema.
        public let versionNumber: Int64?

        @inlinable
        public init(errorDetails: ErrorDetails? = nil, versionNumber: Int64? = nil) {
            self.errorDetails = errorDetails
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetails = "ErrorDetails"
            case versionNumber = "VersionNumber"
        }
    }

    public struct SchemaVersionListItem: AWSDecodableShape {
        /// The date and time the schema version was created.
        public let createdTime: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The unique identifier of the schema version.
        public let schemaVersionId: String?
        /// The status of the schema version.
        public let status: SchemaVersionStatus?
        /// The version number of the schema.
        public let versionNumber: Int64?

        @inlinable
        public init(createdTime: String? = nil, schemaArn: String? = nil, schemaVersionId: String? = nil, status: SchemaVersionStatus? = nil, versionNumber: Int64? = nil) {
            self.createdTime = createdTime
            self.schemaArn = schemaArn
            self.schemaVersionId = schemaVersionId
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case schemaArn = "SchemaArn"
            case schemaVersionId = "SchemaVersionId"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct SchemaVersionNumber: AWSEncodableShape {
        /// The latest version available for the schema.
        public let latestVersion: Bool?
        /// The version number of the schema.
        public let versionNumber: Int64?

        @inlinable
        public init(latestVersion: Bool? = nil, versionNumber: Int64? = nil) {
            self.latestVersion = latestVersion
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, max: 100000)
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case latestVersion = "LatestVersion"
            case versionNumber = "VersionNumber"
        }
    }

    public struct SearchTablesRequest: AWSEncodableShape {
        /// A unique identifier, consisting of  account_id .
        public let catalogId: String?
        /// A list of key-value pairs, and a comparator used to filter the search results. Returns all entities matching the predicate. The Comparator member of the PropertyPredicate struct is used only for time fields, and can be omitted for other field types. Also, when comparing string values, such as when Key=Name, a fuzzy match algorithm is used. The Key field (for example, the value of the Name field) is split on certain punctuation characters, for example, -, :, #, etc. into tokens. Then each token is exact-match compared with the Value member of PropertyPredicate. For example, if Key=Name and Value=link, tables named customer-link and xx-link-yy are returned, but xxlinkyy is not returned.
        public let filters: [PropertyPredicate]?
        /// Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
        public let includeStatusDetails: Bool?
        /// The maximum number of tables to return in a single response.
        public let maxResults: Int?
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?
        /// Allows you to specify that you want to search the tables shared with your account. The allowable values are FOREIGN or ALL.    If set to FOREIGN, will search the tables shared with your account.    If set to ALL, will search the tables shared with your account, as well as the tables in yor local account.
        public let resourceShareType: ResourceShareType?
        /// A string used for a text search. Specifying a value in quotes filters based on an exact match to the value.
        public let searchText: String?
        /// A list of criteria for sorting the results by a field name, in an ascending or descending order.
        public let sortCriteria: [SortCriterion]?

        @inlinable
        public init(catalogId: String? = nil, filters: [PropertyPredicate]? = nil, includeStatusDetails: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceShareType: ResourceShareType? = nil, searchText: String? = nil, sortCriteria: [SortCriterion]? = nil) {
            self.catalogId = catalogId
            self.filters = filters
            self.includeStatusDetails = includeStatusDetails
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceShareType = resourceShareType
            self.searchText = searchText
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.searchText, name: "searchText", parent: name, max: 1024)
            try self.validate(self.searchText, name: "searchText", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case filters = "Filters"
            case includeStatusDetails = "IncludeStatusDetails"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceShareType = "ResourceShareType"
            case searchText = "SearchText"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct SearchTablesResponse: AWSDecodableShape {
        /// A continuation token, present if the current list segment is not the last.
        public let nextToken: String?
        /// A list of the requested Table objects. The SearchTables response returns only the tables that you have access to.
        public let tableList: [Table]?

        @inlinable
        public init(nextToken: String? = nil, tableList: [Table]? = nil) {
            self.nextToken = nextToken
            self.tableList = tableList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tableList = "TableList"
        }
    }

    public struct SecurityConfiguration: AWSDecodableShape {
        /// The time at which this security configuration was created.
        public let createdTimeStamp: Date?
        /// The encryption configuration associated with this security configuration.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The name of the security configuration.
        public let name: String?

        @inlinable
        public init(createdTimeStamp: Date? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, name: String? = nil) {
            self.createdTimeStamp = createdTimeStamp
            self.encryptionConfiguration = encryptionConfiguration
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimeStamp = "CreatedTimeStamp"
            case encryptionConfiguration = "EncryptionConfiguration"
            case name = "Name"
        }
    }

    public struct Segment: AWSEncodableShape {
        /// The zero-based index number of the segment. For example, if the total number of segments is 4, SegmentNumber values range from 0 through 3.
        public let segmentNumber: Int
        /// The total number of segments.
        public let totalSegments: Int

        @inlinable
        public init(segmentNumber: Int = 0, totalSegments: Int) {
            self.segmentNumber = segmentNumber
            self.totalSegments = totalSegments
        }

        public func validate(name: String) throws {
            try self.validate(self.segmentNumber, name: "segmentNumber", parent: name, min: 0)
            try self.validate(self.totalSegments, name: "totalSegments", parent: name, max: 10)
            try self.validate(self.totalSegments, name: "totalSegments", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case segmentNumber = "SegmentNumber"
            case totalSegments = "TotalSegments"
        }
    }

    public struct SelectFields: AWSEncodableShape & AWSDecodableShape {
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String
        /// A JSON path to a variable in the data structure.
        public let paths: [[String]]

        @inlinable
        public init(inputs: [String], name: String, paths: [[String]]) {
            self.inputs = inputs
            self.name = name
            self.paths = paths
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case paths = "Paths"
        }
    }

    public struct SelectFromCollection: AWSEncodableShape & AWSDecodableShape {
        /// The index for the DynamicFrame to be selected.
        public let index: Int
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String

        @inlinable
        public init(index: Int, inputs: [String], name: String) {
            self.index = index
            self.inputs = inputs
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.index, name: "index", parent: name, min: 0)
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case index = "Index"
            case inputs = "Inputs"
            case name = "Name"
        }
    }

    public struct SerDeInfo: AWSEncodableShape & AWSDecodableShape {
        /// Name of the SerDe.
        public let name: String?
        /// These key-value pairs define initialization parameters for the SerDe.
        public let parameters: [String: String]?
        /// Usually the class that implements the SerDe. An example is org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
        public let serializationLibrary: String?

        @inlinable
        public init(name: String? = nil, parameters: [String: String]? = nil, serializationLibrary: String? = nil) {
            self.name = name
            self.parameters = parameters
            self.serializationLibrary = serializationLibrary
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512000)
            }
            try self.validate(self.serializationLibrary, name: "serializationLibrary", parent: name, max: 255)
            try self.validate(self.serializationLibrary, name: "serializationLibrary", parent: name, min: 1)
            try self.validate(self.serializationLibrary, name: "serializationLibrary", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case parameters = "Parameters"
            case serializationLibrary = "SerializationLibrary"
        }
    }

    public struct Session: AWSDecodableShape {
        /// The command object.See SessionCommand.
        public let command: SessionCommand?
        /// The date and time that this session is completed.
        public let completedOn: Date?
        /// The number of connections used for the session.
        public let connections: ConnectionsList?
        /// The time and date when the session was created.
        public let createdOn: Date?
        /// A map array of key-value pairs. Max is 75 pairs.
        public let defaultArguments: [String: String]?
        /// The description of the session.
        public let description: String?
        /// The DPUs consumed by the session (formula: ExecutionTime * MaxCapacity).
        public let dpuSeconds: Double?
        /// The error message displayed during the session.
        public let errorMessage: String?
        /// The total time the session ran for.
        public let executionTime: Double?
        /// The Glue version determines the versions of Apache Spark and Python that Glue supports.  The GlueVersion must be greater than 2.0.
        public let glueVersion: String?
        /// The ID of the session.
        public let id: String?
        /// The number of minutes when idle before the session times out.
        public let idleTimeout: Int?
        /// The number of Glue data processing units (DPUs) that can be allocated when the job runs.  A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.
        public let maxCapacity: Double?
        /// The number of workers of a defined WorkerType to use for the session.
        public let numberOfWorkers: Int?
        /// The name of an Glue usage profile associated with the session.
        public let profileName: String?
        /// The code execution progress of the session.
        public let progress: Double?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with the Session.
        public let role: String?
        /// The name of the SecurityConfiguration structure to be used with the session.
        public let securityConfiguration: String?
        /// The session status.
        public let status: SessionStatus?
        /// The type of predefined worker that is allocated when a session runs. Accepts a value of G.1X, G.2X, G.4X, or G.8X for Spark sessions. Accepts the value Z.2X for Ray sessions.
        public let workerType: WorkerType?

        @inlinable
        public init(command: SessionCommand? = nil, completedOn: Date? = nil, connections: ConnectionsList? = nil, createdOn: Date? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, dpuSeconds: Double? = nil, errorMessage: String? = nil, executionTime: Double? = nil, glueVersion: String? = nil, id: String? = nil, idleTimeout: Int? = nil, maxCapacity: Double? = nil, numberOfWorkers: Int? = nil, profileName: String? = nil, progress: Double? = nil, role: String? = nil, securityConfiguration: String? = nil, status: SessionStatus? = nil, workerType: WorkerType? = nil) {
            self.command = command
            self.completedOn = completedOn
            self.connections = connections
            self.createdOn = createdOn
            self.defaultArguments = defaultArguments
            self.description = description
            self.dpuSeconds = dpuSeconds
            self.errorMessage = errorMessage
            self.executionTime = executionTime
            self.glueVersion = glueVersion
            self.id = id
            self.idleTimeout = idleTimeout
            self.maxCapacity = maxCapacity
            self.numberOfWorkers = numberOfWorkers
            self.profileName = profileName
            self.progress = progress
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.status = status
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case completedOn = "CompletedOn"
            case connections = "Connections"
            case createdOn = "CreatedOn"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case dpuSeconds = "DPUSeconds"
            case errorMessage = "ErrorMessage"
            case executionTime = "ExecutionTime"
            case glueVersion = "GlueVersion"
            case id = "Id"
            case idleTimeout = "IdleTimeout"
            case maxCapacity = "MaxCapacity"
            case numberOfWorkers = "NumberOfWorkers"
            case profileName = "ProfileName"
            case progress = "Progress"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case status = "Status"
            case workerType = "WorkerType"
        }
    }

    public struct SessionCommand: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the name of the SessionCommand. Can be 'glueetl' or 'gluestreaming'.
        public let name: String?
        /// Specifies the Python version. The Python version indicates the version supported for jobs of type Spark.
        public let pythonVersion: String?

        @inlinable
        public init(name: String? = nil, pythonVersion: String? = nil) {
            self.name = name
            self.pythonVersion = pythonVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.pythonVersion, name: "pythonVersion", parent: name, pattern: "^([2-3]|3[.]9)$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case pythonVersion = "PythonVersion"
        }
    }

    public struct SkewedInfo: AWSEncodableShape & AWSDecodableShape {
        /// A list of names of columns that contain skewed values.
        public let skewedColumnNames: [String]?
        /// A mapping of skewed values to the columns that contain them.
        public let skewedColumnValueLocationMaps: [String: String]?
        /// A list of values that appear so frequently as to be considered skewed.
        public let skewedColumnValues: [String]?

        @inlinable
        public init(skewedColumnNames: [String]? = nil, skewedColumnValueLocationMaps: [String: String]? = nil, skewedColumnValues: [String]? = nil) {
            self.skewedColumnNames = skewedColumnNames
            self.skewedColumnValueLocationMaps = skewedColumnValueLocationMaps
            self.skewedColumnValues = skewedColumnValues
        }

        public func validate(name: String) throws {
            try self.skewedColumnNames?.forEach {
                try validate($0, name: "skewedColumnNames[]", parent: name, max: 255)
                try validate($0, name: "skewedColumnNames[]", parent: name, min: 1)
                try validate($0, name: "skewedColumnNames[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case skewedColumnNames = "SkewedColumnNames"
            case skewedColumnValueLocationMaps = "SkewedColumnValueLocationMaps"
            case skewedColumnValues = "SkewedColumnValues"
        }
    }

    public struct SnowflakeNodeData: AWSEncodableShape & AWSDecodableShape {
        /// Specifies what action to take when writing to a table with preexisting data. Valid values:  append, merge, truncate, drop.
        public let action: String?
        /// Specifies additional options passed to the Snowflake connector. If options are specified elsewhere in this node, this will take precedence.
        public let additionalOptions: [String: String]?
        /// Specifies whether automatic query pushdown is enabled. If pushdown is enabled, then when a query is run on Spark, if part of the query can be "pushed down" to the Snowflake server, it is pushed down. This improves performance of some queries.
        public let autoPushdown: Bool?
        /// Specifies a Glue Data Catalog Connection to a Snowflake endpoint.
        public let connection: Option?
        /// Specifies a Snowflake database for your node to use.
        public let database: String?
        /// Not currently used.
        public let iamRole: Option?
        /// Specifies a merge action. Valid values: simple, custom. If simple, merge behavior is defined by MergeWhenMatched and  MergeWhenNotMatched. If custom, defined by MergeClause.
        public let mergeAction: String?
        /// A SQL statement that specifies a custom merge behavior.
        public let mergeClause: String?
        /// Specifies how to resolve records that match preexisting data when merging. Valid values:  update, delete.
        public let mergeWhenMatched: String?
        /// Specifies how to process records that do not match preexisting data when merging. Valid values: insert, none.
        public let mergeWhenNotMatched: String?
        /// A SQL string run after the Snowflake connector performs its standard actions.
        public let postAction: String?
        /// A SQL string run before the Snowflake connector performs its standard actions.
        public let preAction: String?
        /// A SQL string used to retrieve data with the query sourcetype.
        public let sampleQuery: String?
        /// Specifies a Snowflake database schema for your node to use.
        public let schema: String?
        /// Specifies the columns combined to identify a record when detecting matches for merges and upserts. A list of structures with value, label and  description keys. Each structure describes a column.
        public let selectedColumns: [Option]?
        /// Specifies how retrieved data is specified. Valid values: "table",  "query".
        public let sourceType: String?
        /// The name of a staging table used when performing merge or upsert append actions. Data is written to this table, then moved to table by a generated postaction.
        public let stagingTable: String?
        /// Specifies a Snowflake table for your node to use.
        public let table: String?
        /// Manually defines the target schema for the node. A list of structures with value , label and description keys. Each structure defines a column.
        public let tableSchema: [Option]?
        /// Not currently used.
        public let tempDir: String?
        /// Used when Action is append. Specifies the resolution behavior when a row already exists. If true, preexisting rows will be updated. If false, those rows will be inserted.
        public let upsert: Bool?

        @inlinable
        public init(action: String? = nil, additionalOptions: [String: String]? = nil, autoPushdown: Bool? = nil, connection: Option? = nil, database: String? = nil, iamRole: Option? = nil, mergeAction: String? = nil, mergeClause: String? = nil, mergeWhenMatched: String? = nil, mergeWhenNotMatched: String? = nil, postAction: String? = nil, preAction: String? = nil, sampleQuery: String? = nil, schema: String? = nil, selectedColumns: [Option]? = nil, sourceType: String? = nil, stagingTable: String? = nil, table: String? = nil, tableSchema: [Option]? = nil, tempDir: String? = nil, upsert: Bool? = nil) {
            self.action = action
            self.additionalOptions = additionalOptions
            self.autoPushdown = autoPushdown
            self.connection = connection
            self.database = database
            self.iamRole = iamRole
            self.mergeAction = mergeAction
            self.mergeClause = mergeClause
            self.mergeWhenMatched = mergeWhenMatched
            self.mergeWhenNotMatched = mergeWhenNotMatched
            self.postAction = postAction
            self.preAction = preAction
            self.sampleQuery = sampleQuery
            self.schema = schema
            self.selectedColumns = selectedColumns
            self.sourceType = sourceType
            self.stagingTable = stagingTable
            self.table = table
            self.tableSchema = tableSchema
            self.tempDir = tempDir
            self.upsert = upsert
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.forEach {
                try validate($0.key, name: "additionalOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.connection?.validate(name: "\(name).connection")
            try self.iamRole?.validate(name: "\(name).iamRole")
            try self.validate(self.mergeAction, name: "mergeAction", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.validate(self.mergeWhenMatched, name: "mergeWhenMatched", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.validate(self.mergeWhenNotMatched, name: "mergeWhenNotMatched", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.selectedColumns?.forEach {
                try $0.validate(name: "\(name).selectedColumns[]")
            }
            try self.validate(self.sourceType, name: "sourceType", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            try self.tableSchema?.forEach {
                try $0.validate(name: "\(name).tableSchema[]")
            }
            try self.validate(self.tempDir, name: "tempDir", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case additionalOptions = "AdditionalOptions"
            case autoPushdown = "AutoPushdown"
            case connection = "Connection"
            case database = "Database"
            case iamRole = "IamRole"
            case mergeAction = "MergeAction"
            case mergeClause = "MergeClause"
            case mergeWhenMatched = "MergeWhenMatched"
            case mergeWhenNotMatched = "MergeWhenNotMatched"
            case postAction = "PostAction"
            case preAction = "PreAction"
            case sampleQuery = "SampleQuery"
            case schema = "Schema"
            case selectedColumns = "SelectedColumns"
            case sourceType = "SourceType"
            case stagingTable = "StagingTable"
            case table = "Table"
            case tableSchema = "TableSchema"
            case tempDir = "TempDir"
            case upsert = "Upsert"
        }
    }

    public struct SnowflakeSource: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for the Snowflake data source.
        public let data: SnowflakeNodeData
        /// The name of the Snowflake data source.
        public let name: String
        /// Specifies user-defined schemas for your output data.
        public let outputSchemas: [GlueSchema]?

        @inlinable
        public init(data: SnowflakeNodeData, name: String, outputSchemas: [GlueSchema]? = nil) {
            self.data = data
            self.name = name
            self.outputSchemas = outputSchemas
        }

        public func validate(name: String) throws {
            try self.data.validate(name: "\(name).data")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
        }
    }

    public struct SnowflakeTarget: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the data of the Snowflake target node.
        public let data: SnowflakeNodeData
        /// The nodes that are inputs to the data target.
        public let inputs: [String]?
        /// The name of the Snowflake target.
        public let name: String

        @inlinable
        public init(data: SnowflakeNodeData, inputs: [String]? = nil, name: String) {
            self.data = data
            self.inputs = inputs
            self.name = name
        }

        public func validate(name: String) throws {
            try self.data.validate(name: "\(name).data")
            try self.inputs?.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
            case inputs = "Inputs"
            case name = "Name"
        }
    }

    public struct SortCriterion: AWSEncodableShape {
        /// The name of the field on which to sort.
        public let fieldName: String?
        /// An ascending or descending sort.
        public let sort: Sort?

        @inlinable
        public init(fieldName: String? = nil, sort: Sort? = nil) {
            self.fieldName = fieldName
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 1024)
            try self.validate(self.fieldName, name: "fieldName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "FieldName"
            case sort = "Sort"
        }
    }

    public struct SourceControlDetails: AWSEncodableShape & AWSDecodableShape {
        /// The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.
        public let authStrategy: SourceControlAuthStrategy?
        /// The value of an authorization token.
        public let authToken: String?
        /// An optional branch in the remote repository.
        public let branch: String?
        /// An optional folder in the remote repository.
        public let folder: String?
        /// The last commit ID for a commit in the remote repository.
        public let lastCommitId: String?
        /// The owner of the remote repository that contains the job artifacts.
        public let owner: String?
        /// The provider for the remote repository.
        public let provider: SourceControlProvider?
        /// The name of the remote repository that contains the job artifacts.
        public let repository: String?

        @inlinable
        public init(authStrategy: SourceControlAuthStrategy? = nil, authToken: String? = nil, branch: String? = nil, folder: String? = nil, lastCommitId: String? = nil, owner: String? = nil, provider: SourceControlProvider? = nil, repository: String? = nil) {
            self.authStrategy = authStrategy
            self.authToken = authToken
            self.branch = branch
            self.folder = folder
            self.lastCommitId = lastCommitId
            self.owner = owner
            self.provider = provider
            self.repository = repository
        }

        public func validate(name: String) throws {
            try self.validate(self.authToken, name: "authToken", parent: name, max: 512)
            try self.validate(self.authToken, name: "authToken", parent: name, min: 1)
            try self.validate(self.branch, name: "branch", parent: name, max: 512)
            try self.validate(self.branch, name: "branch", parent: name, min: 1)
            try self.validate(self.folder, name: "folder", parent: name, max: 512)
            try self.validate(self.folder, name: "folder", parent: name, min: 1)
            try self.validate(self.lastCommitId, name: "lastCommitId", parent: name, max: 512)
            try self.validate(self.lastCommitId, name: "lastCommitId", parent: name, min: 1)
            try self.validate(self.owner, name: "owner", parent: name, max: 512)
            try self.validate(self.owner, name: "owner", parent: name, min: 1)
            try self.validate(self.repository, name: "repository", parent: name, max: 512)
            try self.validate(self.repository, name: "repository", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authStrategy = "AuthStrategy"
            case authToken = "AuthToken"
            case branch = "Branch"
            case folder = "Folder"
            case lastCommitId = "LastCommitId"
            case owner = "Owner"
            case provider = "Provider"
            case repository = "Repository"
        }
    }

    public struct SourceProcessingProperties: AWSEncodableShape & AWSDecodableShape {
        /// The IAM role to access the Glue connection.
        public let roleArn: String?

        @inlinable
        public init(roleArn: String? = nil) {
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 128)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
        }
    }

    public struct SourceTableConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of fields used for column-level filtering.
        public let fields: [String]?
        /// A condition clause used for row-level filtering.
        public let filterPredicate: String?
        /// Unique identifier of a record.
        public let primaryKey: [String]?
        /// Incremental pull timestamp-based field.
        public let recordUpdateField: String?

        @inlinable
        public init(fields: [String]? = nil, filterPredicate: String? = nil, primaryKey: [String]? = nil, recordUpdateField: String? = nil) {
            self.fields = fields
            self.filterPredicate = filterPredicate
            self.primaryKey = primaryKey
            self.recordUpdateField = recordUpdateField
        }

        public func validate(name: String) throws {
            try self.fields?.forEach {
                try validate($0, name: "fields[]", parent: name, max: 128)
                try validate($0, name: "fields[]", parent: name, min: 1)
            }
            try self.validate(self.filterPredicate, name: "filterPredicate", parent: name, max: 128)
            try self.validate(self.filterPredicate, name: "filterPredicate", parent: name, min: 1)
            try self.primaryKey?.forEach {
                try validate($0, name: "primaryKey[]", parent: name, max: 128)
                try validate($0, name: "primaryKey[]", parent: name, min: 1)
            }
            try self.validate(self.recordUpdateField, name: "recordUpdateField", parent: name, max: 128)
            try self.validate(self.recordUpdateField, name: "recordUpdateField", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case filterPredicate = "FilterPredicate"
            case primaryKey = "PrimaryKey"
            case recordUpdateField = "RecordUpdateField"
        }
    }

    public struct SparkConnectorSource: AWSEncodableShape & AWSDecodableShape {
        /// Additional connection options for the connector.
        public let additionalOptions: [String: String]?
        /// The name of the connection that is associated with the connector.
        public let connectionName: String
        /// The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.
        public let connectionType: String
        /// The name of a connector that assists with accessing the data store in Glue Studio.
        public let connectorName: String
        /// The name of the data source.
        public let name: String
        /// Specifies data schema for the custom spark source.
        public let outputSchemas: [GlueSchema]?

        @inlinable
        public init(additionalOptions: [String: String]? = nil, connectionName: String, connectionType: String, connectorName: String, name: String, outputSchemas: [GlueSchema]? = nil) {
            self.additionalOptions = additionalOptions
            self.connectionName = connectionName
            self.connectionType = connectionType
            self.connectorName = connectorName
            self.name = name
            self.outputSchemas = outputSchemas
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.forEach {
                try validate($0.key, name: "additionalOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectionType, name: "connectionType", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectorName, name: "connectorName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case connectionName = "ConnectionName"
            case connectionType = "ConnectionType"
            case connectorName = "ConnectorName"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
        }
    }

    public struct SparkConnectorTarget: AWSEncodableShape & AWSDecodableShape {
        /// Additional connection options for the connector.
        public let additionalOptions: [String: String]?
        /// The name of a connection for an Apache Spark connector.
        public let connectionName: String
        /// The type of connection, such as marketplace.spark or custom.spark, designating a connection to an Apache Spark data store.
        public let connectionType: String
        /// The name of an Apache Spark connector.
        public let connectorName: String
        /// The nodes that are inputs to the data target.
        public let inputs: [String]
        /// The name of the data target.
        public let name: String
        /// Specifies the data schema for the custom spark target.
        public let outputSchemas: [GlueSchema]?

        @inlinable
        public init(additionalOptions: [String: String]? = nil, connectionName: String, connectionType: String, connectorName: String, inputs: [String], name: String, outputSchemas: [GlueSchema]? = nil) {
            self.additionalOptions = additionalOptions
            self.connectionName = connectionName
            self.connectionType = connectionType
            self.connectorName = connectorName
            self.inputs = inputs
            self.name = name
            self.outputSchemas = outputSchemas
        }

        public func validate(name: String) throws {
            try self.additionalOptions?.forEach {
                try validate($0.key, name: "additionalOptions.key", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
                try validate($0.value, name: "additionalOptions[\"\($0.key)\"]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectionType, name: "connectionType", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.connectorName, name: "connectorName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOptions = "AdditionalOptions"
            case connectionName = "ConnectionName"
            case connectionType = "ConnectionType"
            case connectorName = "ConnectorName"
            case inputs = "Inputs"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
        }
    }

    public struct SparkSQL: AWSEncodableShape & AWSDecodableShape {
        /// The data inputs identified by their node names. You can associate a table name with each input node to use in the SQL query. The name you choose must meet the Spark SQL naming restrictions.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String
        /// Specifies the data schema for the SparkSQL transform.
        public let outputSchemas: [GlueSchema]?
        /// A list of aliases. An alias allows you to specify what name to use in the SQL for a given input. For example, you have a datasource named "MyDataSource". If you specify From as MyDataSource, and Alias as SqlName, then in your SQL you can do:  select *
        /// from SqlName  and that gets data from MyDataSource.
        public let sqlAliases: [SqlAlias]
        /// A SQL query that must use Spark SQL syntax and return a single data set.
        public let sqlQuery: String

        @inlinable
        public init(inputs: [String], name: String, outputSchemas: [GlueSchema]? = nil, sqlAliases: [SqlAlias], sqlQuery: String) {
            self.inputs = inputs
            self.name = name
            self.outputSchemas = outputSchemas
            self.sqlAliases = sqlAliases
            self.sqlQuery = sqlQuery
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.outputSchemas?.forEach {
                try $0.validate(name: "\(name).outputSchemas[]")
            }
            try self.sqlAliases.forEach {
                try $0.validate(name: "\(name).sqlAliases[]")
            }
            try self.validate(self.sqlQuery, name: "sqlQuery", parent: name, pattern: "^([\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\s])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case outputSchemas = "OutputSchemas"
            case sqlAliases = "SqlAliases"
            case sqlQuery = "SqlQuery"
        }
    }

    public struct Spigot: AWSEncodableShape & AWSDecodableShape {
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String
        /// A path in Amazon S3 where the transform will write a subset of records from the dataset to a JSON file in an Amazon S3 bucket.
        public let path: String
        /// The probability (a decimal value with a maximum value of 1) of picking any given record. A value of 1 indicates that each row read from the dataset should be included in the sample output.
        public let prob: Double?
        /// Specifies a number of records to write starting from the beginning of the dataset.
        public let topk: Int?

        @inlinable
        public init(inputs: [String], name: String, path: String, prob: Double? = nil, topk: Int? = nil) {
            self.inputs = inputs
            self.name = name
            self.path = path
            self.prob = prob
            self.topk = topk
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
            try self.validate(self.path, name: "path", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.prob, name: "prob", parent: name, max: 1.0)
            try self.validate(self.prob, name: "prob", parent: name, min: 0.0)
            try self.validate(self.topk, name: "topk", parent: name, max: 100)
            try self.validate(self.topk, name: "topk", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case path = "Path"
            case prob = "Prob"
            case topk = "Topk"
        }
    }

    public struct SplitFields: AWSEncodableShape & AWSDecodableShape {
        /// The data inputs identified by their node names.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String
        /// A JSON path to a variable in the data structure.
        public let paths: [[String]]

        @inlinable
        public init(inputs: [String], name: String, paths: [[String]]) {
            self.inputs = inputs
            self.name = name
            self.paths = paths
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 1)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case paths = "Paths"
        }
    }

    public struct SqlAlias: AWSEncodableShape & AWSDecodableShape {
        /// A temporary name given to a table, or a column in a table.
        public let alias: String
        /// A table, or a column in a table.
        public let from: String

        @inlinable
        public init(alias: String, from: String) {
            self.alias = alias
            self.from = from
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.from, name: "from", parent: name, pattern: "^[A-Za-z0-9_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case from = "From"
        }
    }

    public struct StartBlueprintRunRequest: AWSEncodableShape {
        /// The name of the blueprint.
        public let blueprintName: String
        /// Specifies the parameters as a BlueprintParameters object.
        public let parameters: String?
        /// Specifies the IAM role used to create the workflow.
        public let roleArn: String

        @inlinable
        public init(blueprintName: String, parameters: String? = nil, roleArn: String) {
            self.blueprintName = blueprintName
            self.parameters = parameters
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, max: 128)
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, min: 1)
            try self.validate(self.blueprintName, name: "blueprintName", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
            try self.validate(self.parameters, name: "parameters", parent: name, max: 131072)
            try self.validate(self.parameters, name: "parameters", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1024)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[^:]*:iam::[0-9]*:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintName = "BlueprintName"
            case parameters = "Parameters"
            case roleArn = "RoleArn"
        }
    }

    public struct StartBlueprintRunResponse: AWSDecodableShape {
        /// The run ID for this blueprint run.
        public let runId: String?

        @inlinable
        public init(runId: String? = nil) {
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct StartColumnStatisticsTaskRunRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the table reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogID: String?
        /// A list of the column names to generate statistics. If none is supplied, all column names for the table will be used by default.
        public let columnNameList: [String]?
        /// The name of the database where the table resides.
        public let databaseName: String
        /// The IAM role that the service assumes to generate statistics.
        public let role: String
        /// The percentage of rows used to generate statistics. If none is supplied, the entire table will be used to generate stats.
        public let sampleSize: Double?
        /// Name of the security configuration that is used to encrypt CloudWatch logs for the column stats task run.
        public let securityConfiguration: String?
        /// The name of the table to generate statistics.
        public let tableName: String

        @inlinable
        public init(catalogID: String? = nil, columnNameList: [String]? = nil, databaseName: String, role: String, sampleSize: Double? = nil, securityConfiguration: String? = nil, tableName: String) {
            self.catalogID = catalogID
            self.columnNameList = columnNameList
            self.databaseName = databaseName
            self.role = role
            self.sampleSize = sampleSize
            self.securityConfiguration = securityConfiguration
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogID, name: "catalogID", parent: name, max: 255)
            try self.validate(self.catalogID, name: "catalogID", parent: name, min: 1)
            try self.validate(self.catalogID, name: "catalogID", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.columnNameList?.forEach {
                try validate($0, name: "columnNameList[]", parent: name, max: 255)
                try validate($0, name: "columnNameList[]", parent: name, min: 1)
                try validate($0, name: "columnNameList[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.role, name: "role", parent: name, max: 255)
            try self.validate(self.role, name: "role", parent: name, min: 1)
            try self.validate(self.role, name: "role", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.sampleSize, name: "sampleSize", parent: name, max: 100.0)
            try self.validate(self.sampleSize, name: "sampleSize", parent: name, min: 0.0)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogID = "CatalogID"
            case columnNameList = "ColumnNameList"
            case databaseName = "DatabaseName"
            case role = "Role"
            case sampleSize = "SampleSize"
            case securityConfiguration = "SecurityConfiguration"
            case tableName = "TableName"
        }
    }

    public struct StartColumnStatisticsTaskRunResponse: AWSDecodableShape {
        /// The identifier for the column statistics task run.
        public let columnStatisticsTaskRunId: String?

        @inlinable
        public init(columnStatisticsTaskRunId: String? = nil) {
            self.columnStatisticsTaskRunId = columnStatisticsTaskRunId
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsTaskRunId = "ColumnStatisticsTaskRunId"
        }
    }

    public struct StartColumnStatisticsTaskRunScheduleRequest: AWSEncodableShape {
        /// The name of the database where the table resides.
        public let databaseName: String
        /// The name of the table for which to start a column statistic task run schedule.
        public let tableName: String

        @inlinable
        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct StartColumnStatisticsTaskRunScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartCrawlerRequest: AWSEncodableShape {
        /// Name of the crawler to start.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartCrawlerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartCrawlerScheduleRequest: AWSEncodableShape {
        /// Name of the crawler to schedule.
        public let crawlerName: String

        @inlinable
        public init(crawlerName: String) {
            self.crawlerName = crawlerName
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
        }
    }

    public struct StartCrawlerScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartDataQualityRuleRecommendationRunRequest: AWSEncodableShape {
        /// Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.
        public let clientToken: String?
        /// A name for the ruleset.
        public let createdRulesetName: String?
        /// The name of the security configuration created with the data quality encryption option.
        public let dataQualitySecurityConfiguration: String?
        /// The data source (Glue table) associated with this run.
        public let dataSource: DataSource
        /// The number of G.1X workers to be used in the run. The default is 5.
        public let numberOfWorkers: Int?
        /// An IAM role supplied to encrypt the results of the run.
        public let role: String
        /// The timeout for a run in minutes. This is the maximum time that a run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?

        @inlinable
        public init(clientToken: String? = nil, createdRulesetName: String? = nil, dataQualitySecurityConfiguration: String? = nil, dataSource: DataSource, numberOfWorkers: Int? = nil, role: String, timeout: Int? = nil) {
            self.clientToken = clientToken
            self.createdRulesetName = createdRulesetName
            self.dataQualitySecurityConfiguration = dataQualitySecurityConfiguration
            self.dataSource = dataSource
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 255)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.createdRulesetName, name: "createdRulesetName", parent: name, max: 255)
            try self.validate(self.createdRulesetName, name: "createdRulesetName", parent: name, min: 1)
            try self.validate(self.createdRulesetName, name: "createdRulesetName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.dataQualitySecurityConfiguration, name: "dataQualitySecurityConfiguration", parent: name, max: 255)
            try self.validate(self.dataQualitySecurityConfiguration, name: "dataQualitySecurityConfiguration", parent: name, min: 1)
            try self.validate(self.dataQualitySecurityConfiguration, name: "dataQualitySecurityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.dataSource.validate(name: "\(name).dataSource")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case createdRulesetName = "CreatedRulesetName"
            case dataQualitySecurityConfiguration = "DataQualitySecurityConfiguration"
            case dataSource = "DataSource"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case timeout = "Timeout"
        }
    }

    public struct StartDataQualityRuleRecommendationRunResponse: AWSDecodableShape {
        /// The unique run identifier associated with this run.
        public let runId: String?

        @inlinable
        public init(runId: String? = nil) {
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct StartDataQualityRulesetEvaluationRunRequest: AWSEncodableShape {
        /// A map of reference strings to additional data sources you can specify for an evaluation run.
        public let additionalDataSources: [String: DataSource]?
        /// Additional run options you can specify for an evaluation run.
        public let additionalRunOptions: DataQualityEvaluationRunAdditionalRunOptions?
        /// Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.
        public let clientToken: String?
        /// The data source (Glue table) associated with this run.
        public let dataSource: DataSource
        /// The number of G.1X workers to be used in the run. The default is 5.
        public let numberOfWorkers: Int?
        /// An IAM role supplied to encrypt the results of the run.
        public let role: String
        /// A list of ruleset names.
        public let rulesetNames: [String]
        /// The timeout for a run in minutes. This is the maximum time that a run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?

        @inlinable
        public init(additionalDataSources: [String: DataSource]? = nil, additionalRunOptions: DataQualityEvaluationRunAdditionalRunOptions? = nil, clientToken: String? = nil, dataSource: DataSource, numberOfWorkers: Int? = nil, role: String, rulesetNames: [String], timeout: Int? = nil) {
            self.additionalDataSources = additionalDataSources
            self.additionalRunOptions = additionalRunOptions
            self.clientToken = clientToken
            self.dataSource = dataSource
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.rulesetNames = rulesetNames
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.additionalDataSources?.forEach {
                try validate($0.key, name: "additionalDataSources.key", parent: name, max: 255)
                try validate($0.key, name: "additionalDataSources.key", parent: name, min: 1)
                try validate($0.key, name: "additionalDataSources.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try $0.value.validate(name: "\(name).additionalDataSources[\"\($0.key)\"]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 255)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.dataSource.validate(name: "\(name).dataSource")
            try self.rulesetNames.forEach {
                try validate($0, name: "rulesetNames[]", parent: name, max: 255)
                try validate($0, name: "rulesetNames[]", parent: name, min: 1)
                try validate($0, name: "rulesetNames[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.rulesetNames, name: "rulesetNames", parent: name, max: 10)
            try self.validate(self.rulesetNames, name: "rulesetNames", parent: name, min: 1)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalDataSources = "AdditionalDataSources"
            case additionalRunOptions = "AdditionalRunOptions"
            case clientToken = "ClientToken"
            case dataSource = "DataSource"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case rulesetNames = "RulesetNames"
            case timeout = "Timeout"
        }
    }

    public struct StartDataQualityRulesetEvaluationRunResponse: AWSDecodableShape {
        /// The unique run identifier associated with this run.
        public let runId: String?

        @inlinable
        public init(runId: String? = nil) {
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct StartExportLabelsTaskRunRequest: AWSEncodableShape {
        /// The Amazon S3 path where you export the labels.
        public let outputS3Path: String
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        @inlinable
        public init(outputS3Path: String, transformId: String) {
            self.outputS3Path = outputS3Path
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case outputS3Path = "OutputS3Path"
            case transformId = "TransformId"
        }
    }

    public struct StartExportLabelsTaskRunResponse: AWSDecodableShape {
        /// The unique identifier for the task run.
        public let taskRunId: String?

        @inlinable
        public init(taskRunId: String? = nil) {
            self.taskRunId = taskRunId
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
        }
    }

    public struct StartImportLabelsTaskRunRequest: AWSEncodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path from where you import the labels.
        public let inputS3Path: String
        /// Indicates whether to overwrite your existing labels.
        public let replaceAllLabels: Bool?
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        @inlinable
        public init(inputS3Path: String, replaceAllLabels: Bool? = nil, transformId: String) {
            self.inputS3Path = inputS3Path
            self.replaceAllLabels = replaceAllLabels
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputS3Path = "InputS3Path"
            case replaceAllLabels = "ReplaceAllLabels"
            case transformId = "TransformId"
        }
    }

    public struct StartImportLabelsTaskRunResponse: AWSDecodableShape {
        /// The unique identifier for the task run.
        public let taskRunId: String?

        @inlinable
        public init(taskRunId: String? = nil) {
            self.taskRunId = taskRunId
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
        }
    }

    public struct StartJobRunRequest: AWSEncodableShape {
        /// This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs) to allocate to this JobRun. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.
        public let allocatedCapacity: Int?
        /// The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job.  For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see Using job parameters in Ray jobs in the developer guide.
        public let arguments: [String: String]?
        /// Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary.  Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
        public let executionClass: ExecutionClass?
        /// The name of the job definition to use.
        public let jobName: String
        /// The ID of a previous JobRun to retry.
        public let jobRunId: String?
        /// Specifies whether job run queuing is enabled for the job run. A value of true means job run queuing is enabled for the job run. If false or not populated, the job run will not be considered for queueing.
        public let jobRunQueuingEnabled: Bool?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the  Glue pricing page. For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache  Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs.  The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
        public let maxCapacity: Double?
        /// Specifies configuration properties of a job run notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs.
        public let numberOfWorkers: Int?
        /// The name of the SecurityConfiguration structure to be used with this job run.
        public let securityConfiguration: String?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. This value overrides the timeout value set in the parent job.  Jobs must have timeout values less than 7 days or 10080 minutes. Otherwise, the jobs will throw an exception. When the value is left blank, the timeout is defaulted to 2880 minutes. Any existing Glue jobs that had a timeout value greater than 7 days will be defaulted to 7 days. For instance if you have specified a timeout of 20 days for a batch job, it will be stopped on the 7th day. For streaming jobs, if you have set up a maintenance window, it will be restarted during the maintenance window after 7 days.
        public let timeout: Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 94GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 138GB disk, and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).   For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.   For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk, and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 or later streaming jobs.   For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk, and provides up to 8 Ray workers based on the autoscaler.
        public let workerType: WorkerType?

        @inlinable
        public init(arguments: [String: String]? = nil, executionClass: ExecutionClass? = nil, jobName: String, jobRunId: String? = nil, jobRunQueuingEnabled: Bool? = nil, maxCapacity: Double? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, securityConfiguration: String? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.allocatedCapacity = nil
            self.arguments = arguments
            self.executionClass = executionClass
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.maxCapacity = maxCapacity
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
            self.workerType = workerType
        }

        @available(*, deprecated, message: "Members allocatedCapacity have been deprecated")
        @inlinable
        public init(allocatedCapacity: Int? = nil, arguments: [String: String]? = nil, executionClass: ExecutionClass? = nil, jobName: String, jobRunId: String? = nil, jobRunQueuingEnabled: Bool? = nil, maxCapacity: Double? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, securityConfiguration: String? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.allocatedCapacity = allocatedCapacity
            self.arguments = arguments
            self.executionClass = executionClass
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.jobRunQueuingEnabled = jobRunQueuingEnabled
            self.maxCapacity = maxCapacity
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.jobRunId, name: "jobRunId", parent: name, max: 255)
            try self.validate(self.jobRunId, name: "jobRunId", parent: name, min: 1)
            try self.validate(self.jobRunId, name: "jobRunId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.notificationProperty?.validate(name: "\(name).notificationProperty")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedCapacity = "AllocatedCapacity"
            case arguments = "Arguments"
            case executionClass = "ExecutionClass"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
            case jobRunQueuingEnabled = "JobRunQueuingEnabled"
            case maxCapacity = "MaxCapacity"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case securityConfiguration = "SecurityConfiguration"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct StartJobRunResponse: AWSDecodableShape {
        /// The ID assigned to this job run.
        public let jobRunId: String?

        @inlinable
        public init(jobRunId: String? = nil) {
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case jobRunId = "JobRunId"
        }
    }

    public struct StartMLEvaluationTaskRunRequest: AWSEncodableShape {
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        @inlinable
        public init(transformId: String) {
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct StartMLEvaluationTaskRunResponse: AWSDecodableShape {
        /// The unique identifier associated with this run.
        public let taskRunId: String?

        @inlinable
        public init(taskRunId: String? = nil) {
            self.taskRunId = taskRunId
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
        }
    }

    public struct StartMLLabelingSetGenerationTaskRunRequest: AWSEncodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path where you generate the labeling set.
        public let outputS3Path: String
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        @inlinable
        public init(outputS3Path: String, transformId: String) {
            self.outputS3Path = outputS3Path
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case outputS3Path = "OutputS3Path"
            case transformId = "TransformId"
        }
    }

    public struct StartMLLabelingSetGenerationTaskRunResponse: AWSDecodableShape {
        /// The unique run identifier that is associated with this task run.
        public let taskRunId: String?

        @inlinable
        public init(taskRunId: String? = nil) {
            self.taskRunId = taskRunId
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
        }
    }

    public struct StartTriggerRequest: AWSEncodableShape {
        /// The name of the trigger to start.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartTriggerResponse: AWSDecodableShape {
        /// The name of the trigger that was started.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartWorkflowRunRequest: AWSEncodableShape {
        /// The name of the workflow to start.
        public let name: String
        /// The workflow run properties for the new workflow run. Run properties may be logged. Do not pass plaintext secrets as properties. Retrieve secrets from a Glue Connection, Amazon Web Services Secrets Manager or other secret management mechanism if you intend to use them within the workflow run.
        public let runProperties: [String: String]?

        @inlinable
        public init(name: String, runProperties: [String: String]? = nil) {
            self.name = name
            self.runProperties = runProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.runProperties?.forEach {
                try validate($0.key, name: "runProperties.key", parent: name, max: 255)
                try validate($0.key, name: "runProperties.key", parent: name, min: 1)
                try validate($0.key, name: "runProperties.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case runProperties = "RunProperties"
        }
    }

    public struct StartWorkflowRunResponse: AWSDecodableShape {
        /// An Id for the new run.
        public let runId: String?

        @inlinable
        public init(runId: String? = nil) {
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct StartingEventBatchCondition: AWSDecodableShape {
        /// Number of events in the batch.
        public let batchSize: Int?
        /// Duration of the batch window in seconds.
        public let batchWindow: Int?

        @inlinable
        public init(batchSize: Int? = nil, batchWindow: Int? = nil) {
            self.batchSize = batchSize
            self.batchWindow = batchWindow
        }

        private enum CodingKeys: String, CodingKey {
            case batchSize = "BatchSize"
            case batchWindow = "BatchWindow"
        }
    }

    public struct Statement: AWSDecodableShape {
        /// The execution code of the statement.
        public let code: String?
        /// The unix time and date that the job definition was completed.
        public let completedOn: Int64?
        /// The ID of the statement.
        public let id: Int?
        /// The output in JSON.
        public let output: StatementOutput?
        /// The code execution progress.
        public let progress: Double?
        /// The unix time and date that the job definition was started.
        public let startedOn: Int64?
        /// The state while request is actioned.
        public let state: StatementState?

        @inlinable
        public init(code: String? = nil, completedOn: Int64? = nil, id: Int? = nil, output: StatementOutput? = nil, progress: Double? = nil, startedOn: Int64? = nil, state: StatementState? = nil) {
            self.code = code
            self.completedOn = completedOn
            self.id = id
            self.output = output
            self.progress = progress
            self.startedOn = startedOn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case completedOn = "CompletedOn"
            case id = "Id"
            case output = "Output"
            case progress = "Progress"
            case startedOn = "StartedOn"
            case state = "State"
        }
    }

    public struct StatementOutput: AWSDecodableShape {
        /// The code execution output.
        public let data: StatementOutputData?
        /// The name of the error in the output.
        public let errorName: String?
        /// The error value of the output.
        public let errorValue: String?
        /// The execution count of the output.
        public let executionCount: Int?
        /// The status of the code execution output.
        public let status: StatementState?
        /// The traceback of the output.
        public let traceback: [String]?

        @inlinable
        public init(data: StatementOutputData? = nil, errorName: String? = nil, errorValue: String? = nil, executionCount: Int? = nil, status: StatementState? = nil, traceback: [String]? = nil) {
            self.data = data
            self.errorName = errorName
            self.errorValue = errorValue
            self.executionCount = executionCount
            self.status = status
            self.traceback = traceback
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
            case errorName = "ErrorName"
            case errorValue = "ErrorValue"
            case executionCount = "ExecutionCount"
            case status = "Status"
            case traceback = "Traceback"
        }
    }

    public struct StatementOutputData: AWSDecodableShape {
        /// The code execution output in text format.
        public let textPlain: String?

        @inlinable
        public init(textPlain: String? = nil) {
            self.textPlain = textPlain
        }

        private enum CodingKeys: String, CodingKey {
            case textPlain = "TextPlain"
        }
    }

    public struct StatisticAnnotation: AWSDecodableShape {
        /// The inclusion annotation applied to the statistic.
        public let inclusionAnnotation: TimestampedInclusionAnnotation?
        /// The Profile ID.
        public let profileId: String?
        /// The Statistic ID.
        public let statisticId: String?
        /// The timestamp when the annotated statistic was recorded.
        public let statisticRecordedOn: Date?

        @inlinable
        public init(inclusionAnnotation: TimestampedInclusionAnnotation? = nil, profileId: String? = nil, statisticId: String? = nil, statisticRecordedOn: Date? = nil) {
            self.inclusionAnnotation = inclusionAnnotation
            self.profileId = profileId
            self.statisticId = statisticId
            self.statisticRecordedOn = statisticRecordedOn
        }

        private enum CodingKeys: String, CodingKey {
            case inclusionAnnotation = "InclusionAnnotation"
            case profileId = "ProfileId"
            case statisticId = "StatisticId"
            case statisticRecordedOn = "StatisticRecordedOn"
        }
    }

    public struct StatisticModelResult: AWSDecodableShape {
        /// The actual value.
        public let actualValue: Double?
        /// The date.
        public let date: Date?
        /// The inclusion annotation.
        public let inclusionAnnotation: InclusionAnnotationValue?
        /// The lower bound.
        public let lowerBound: Double?
        /// The predicted value.
        public let predictedValue: Double?
        /// The upper bound.
        public let upperBound: Double?

        @inlinable
        public init(actualValue: Double? = nil, date: Date? = nil, inclusionAnnotation: InclusionAnnotationValue? = nil, lowerBound: Double? = nil, predictedValue: Double? = nil, upperBound: Double? = nil) {
            self.actualValue = actualValue
            self.date = date
            self.inclusionAnnotation = inclusionAnnotation
            self.lowerBound = lowerBound
            self.predictedValue = predictedValue
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case actualValue = "ActualValue"
            case date = "Date"
            case inclusionAnnotation = "InclusionAnnotation"
            case lowerBound = "LowerBound"
            case predictedValue = "PredictedValue"
            case upperBound = "UpperBound"
        }
    }

    public struct StatisticSummary: AWSDecodableShape {
        /// The list of columns referenced by the statistic.
        public let columnsReferenced: [String]?
        /// The value of the statistic.
        public let doubleValue: Double?
        /// The evaluation level of the statistic. Possible values: Dataset, Column, Multicolumn.
        public let evaluationLevel: StatisticEvaluationLevel?
        /// The inclusion annotation for the statistic.
        public let inclusionAnnotation: TimestampedInclusionAnnotation?
        /// The Profile ID.
        public let profileId: String?
        /// The timestamp when the statistic was recorded.
        public let recordedOn: Date?
        /// The list of datasets referenced by the statistic.
        public let referencedDatasets: [String]?
        /// The Run Identifier
        public let runIdentifier: RunIdentifier?
        /// The Statistic ID.
        public let statisticId: String?
        /// The name of the statistic.
        public let statisticName: String?
        /// A StatisticPropertiesMap, which contains a NameString and DescriptionString
        public let statisticProperties: [String: String]?

        @inlinable
        public init(columnsReferenced: [String]? = nil, doubleValue: Double? = nil, evaluationLevel: StatisticEvaluationLevel? = nil, inclusionAnnotation: TimestampedInclusionAnnotation? = nil, profileId: String? = nil, recordedOn: Date? = nil, referencedDatasets: [String]? = nil, runIdentifier: RunIdentifier? = nil, statisticId: String? = nil, statisticName: String? = nil, statisticProperties: [String: String]? = nil) {
            self.columnsReferenced = columnsReferenced
            self.doubleValue = doubleValue
            self.evaluationLevel = evaluationLevel
            self.inclusionAnnotation = inclusionAnnotation
            self.profileId = profileId
            self.recordedOn = recordedOn
            self.referencedDatasets = referencedDatasets
            self.runIdentifier = runIdentifier
            self.statisticId = statisticId
            self.statisticName = statisticName
            self.statisticProperties = statisticProperties
        }

        private enum CodingKeys: String, CodingKey {
            case columnsReferenced = "ColumnsReferenced"
            case doubleValue = "DoubleValue"
            case evaluationLevel = "EvaluationLevel"
            case inclusionAnnotation = "InclusionAnnotation"
            case profileId = "ProfileId"
            case recordedOn = "RecordedOn"
            case referencedDatasets = "ReferencedDatasets"
            case runIdentifier = "RunIdentifier"
            case statisticId = "StatisticId"
            case statisticName = "StatisticName"
            case statisticProperties = "StatisticProperties"
        }
    }

    public final class StatusDetails: AWSDecodableShape {
        /// A Table object representing the requested changes.
        public let requestedChange: Table?
        /// A list of ViewValidation objects that contain information for an analytical engine to validate a view.
        public let viewValidations: [ViewValidation]?

        @inlinable
        public init(requestedChange: Table? = nil, viewValidations: [ViewValidation]? = nil) {
            self.requestedChange = requestedChange
            self.viewValidations = viewValidations
        }

        private enum CodingKeys: String, CodingKey {
            case requestedChange = "RequestedChange"
            case viewValidations = "ViewValidations"
        }
    }

    public struct StopColumnStatisticsTaskRunRequest: AWSEncodableShape {
        /// The name of the database where the table resides.
        public let databaseName: String
        /// The name of the table.
        public let tableName: String

        @inlinable
        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct StopColumnStatisticsTaskRunResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopColumnStatisticsTaskRunScheduleRequest: AWSEncodableShape {
        /// The name of the database where the table resides.
        public let databaseName: String
        /// The name of the table for which to stop a column statistic task run schedule.
        public let tableName: String

        @inlinable
        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct StopColumnStatisticsTaskRunScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopCrawlerRequest: AWSEncodableShape {
        /// Name of the crawler to stop.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StopCrawlerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopCrawlerScheduleRequest: AWSEncodableShape {
        /// Name of the crawler whose schedule state to set.
        public let crawlerName: String

        @inlinable
        public init(crawlerName: String) {
            self.crawlerName = crawlerName
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
        }
    }

    public struct StopCrawlerScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopSessionRequest: AWSEncodableShape {
        /// The ID of the session to be stopped.
        public let id: String
        /// The origin of the request.
        public let requestOrigin: String?

        @inlinable
        public init(id: String, requestOrigin: String? = nil) {
            self.id = id
            self.requestOrigin = requestOrigin
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, max: 128)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, min: 1)
            try self.validate(self.requestOrigin, name: "requestOrigin", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case requestOrigin = "RequestOrigin"
        }
    }

    public struct StopSessionResponse: AWSDecodableShape {
        /// Returns the Id of the stopped session.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct StopTriggerRequest: AWSEncodableShape {
        /// The name of the trigger to stop.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StopTriggerResponse: AWSDecodableShape {
        /// The name of the trigger that was stopped.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StopWorkflowRunRequest: AWSEncodableShape {
        /// The name of the workflow to stop.
        public let name: String
        /// The ID of the workflow run to stop.
        public let runId: String

        @inlinable
        public init(name: String, runId: String) {
            self.name = name
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case runId = "RunId"
        }
    }

    public struct StopWorkflowRunResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StorageDescriptor: AWSEncodableShape & AWSDecodableShape {
        /// A list of locations that point to the path where a Delta table is located.
        public let additionalLocations: [String]?
        /// A list of reducer grouping columns, clustering columns, and bucketing columns in the table.
        public let bucketColumns: [String]?
        /// A list of the Columns in the table.
        public let columns: [Column]?
        ///  True if the data in the table is compressed, or False if not.
        public let compressed: Bool?
        /// The input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        public let inputFormat: String?
        /// The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        public let location: String?
        /// Must be specified if the table contains any dimension columns.
        public let numberOfBuckets: Int?
        /// The output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        public let outputFormat: String?
        /// The user-supplied properties in key-value form.
        public let parameters: [String: String]?
        /// An object that references a schema stored in the Glue Schema Registry. When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference.
        public let schemaReference: SchemaReference?
        /// The serialization/deserialization (SerDe) information.
        public let serdeInfo: SerDeInfo?
        /// The information about values that appear frequently in a column (skewed values).
        public let skewedInfo: SkewedInfo?
        /// A list specifying the sort order of each bucket in the table.
        public let sortColumns: [Order]?
        ///  True if the table data is stored in subdirectories, or False if not.
        public let storedAsSubDirectories: Bool?

        @inlinable
        public init(additionalLocations: [String]? = nil, bucketColumns: [String]? = nil, columns: [Column]? = nil, compressed: Bool? = nil, inputFormat: String? = nil, location: String? = nil, numberOfBuckets: Int? = nil, outputFormat: String? = nil, parameters: [String: String]? = nil, schemaReference: SchemaReference? = nil, serdeInfo: SerDeInfo? = nil, skewedInfo: SkewedInfo? = nil, sortColumns: [Order]? = nil, storedAsSubDirectories: Bool? = nil) {
            self.additionalLocations = additionalLocations
            self.bucketColumns = bucketColumns
            self.columns = columns
            self.compressed = compressed
            self.inputFormat = inputFormat
            self.location = location
            self.numberOfBuckets = numberOfBuckets
            self.outputFormat = outputFormat
            self.parameters = parameters
            self.schemaReference = schemaReference
            self.serdeInfo = serdeInfo
            self.skewedInfo = skewedInfo
            self.sortColumns = sortColumns
            self.storedAsSubDirectories = storedAsSubDirectories
        }

        public func validate(name: String) throws {
            try self.additionalLocations?.forEach {
                try validate($0, name: "additionalLocations[]", parent: name, max: 2056)
                try validate($0, name: "additionalLocations[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            }
            try self.bucketColumns?.forEach {
                try validate($0, name: "bucketColumns[]", parent: name, max: 255)
                try validate($0, name: "bucketColumns[]", parent: name, min: 1)
                try validate($0, name: "bucketColumns[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.inputFormat, name: "inputFormat", parent: name, max: 128)
            try self.validate(self.inputFormat, name: "inputFormat", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.location, name: "location", parent: name, max: 2056)
            try self.validate(self.location, name: "location", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.outputFormat, name: "outputFormat", parent: name, max: 128)
            try self.validate(self.outputFormat, name: "outputFormat", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512000)
            }
            try self.schemaReference?.validate(name: "\(name).schemaReference")
            try self.serdeInfo?.validate(name: "\(name).serdeInfo")
            try self.skewedInfo?.validate(name: "\(name).skewedInfo")
            try self.sortColumns?.forEach {
                try $0.validate(name: "\(name).sortColumns[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalLocations = "AdditionalLocations"
            case bucketColumns = "BucketColumns"
            case columns = "Columns"
            case compressed = "Compressed"
            case inputFormat = "InputFormat"
            case location = "Location"
            case numberOfBuckets = "NumberOfBuckets"
            case outputFormat = "OutputFormat"
            case parameters = "Parameters"
            case schemaReference = "SchemaReference"
            case serdeInfo = "SerdeInfo"
            case skewedInfo = "SkewedInfo"
            case sortColumns = "SortColumns"
            case storedAsSubDirectories = "StoredAsSubDirectories"
        }
    }

    public struct StreamingDataPreviewOptions: AWSEncodableShape & AWSDecodableShape {
        /// The polling time in milliseconds.
        public let pollingTime: Int64?
        /// The limit to the number of records polled.
        public let recordPollingLimit: Int64?

        @inlinable
        public init(pollingTime: Int64? = nil, recordPollingLimit: Int64? = nil) {
            self.pollingTime = pollingTime
            self.recordPollingLimit = recordPollingLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.pollingTime, name: "pollingTime", parent: name, min: 10)
            try self.validate(self.recordPollingLimit, name: "recordPollingLimit", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case pollingTime = "PollingTime"
            case recordPollingLimit = "RecordPollingLimit"
        }
    }

    public struct StringColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The average string length in the column.
        public let averageLength: Double
        /// The size of the longest string in the column.
        public let maximumLength: Int64
        /// The number of distinct values in a column.
        public let numberOfDistinctValues: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        @inlinable
        public init(averageLength: Double, maximumLength: Int64, numberOfDistinctValues: Int64, numberOfNulls: Int64) {
            self.averageLength = averageLength
            self.maximumLength = maximumLength
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.averageLength, name: "averageLength", parent: name, min: 0.0)
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, min: 0)
            try self.validate(self.numberOfDistinctValues, name: "numberOfDistinctValues", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case averageLength = "AverageLength"
            case maximumLength = "MaximumLength"
            case numberOfDistinctValues = "NumberOfDistinctValues"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct SupportedDialect: AWSEncodableShape {
        /// The dialect of the query engine.
        public let dialect: ViewDialect?
        /// The version of the dialect of the query engine. For example, 3.0.0.
        public let dialectVersion: String?

        @inlinable
        public init(dialect: ViewDialect? = nil, dialectVersion: String? = nil) {
            self.dialect = dialect
            self.dialectVersion = dialectVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.dialectVersion, name: "dialectVersion", parent: name, max: 255)
            try self.validate(self.dialectVersion, name: "dialectVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dialect = "Dialect"
            case dialectVersion = "DialectVersion"
        }
    }

    public final class Table: AWSDecodableShape {
        /// The ID of the Data Catalog in which the table resides.
        public let catalogId: String?
        /// The person or entity who created the table.
        public let createdBy: String?
        /// The time when the table definition was created in the Data Catalog.
        public let createTime: Date?
        /// The name of the database where the table metadata resides. For Hive compatibility, this must be all lowercase.
        public let databaseName: String?
        /// A description of the table.
        public let description: String?
        /// A FederatedTable structure that references an entity outside the Glue Data Catalog.
        public let federatedTable: FederatedTable?
        /// Specifies whether the view supports the SQL dialects of one or more different query engines and can therefore be read by those engines.
        public let isMultiDialectView: Bool?
        /// Indicates whether the table has been registered with Lake Formation.
        public let isRegisteredWithLakeFormation: Bool?
        /// The last time that the table was accessed. This is usually taken from HDFS, and might not be reliable.
        public let lastAccessTime: Date?
        /// The last time that column statistics were computed for this table.
        public let lastAnalyzedTime: Date?
        /// The table name. For Hive compatibility, this must be entirely lowercase.
        public let name: String
        /// The owner of the table.
        public let owner: String?
        /// These key-value pairs define properties associated with the table.
        public let parameters: [String: String]?
        /// A list of columns by which the table is partitioned. Only primitive types are supported as partition keys. When you create a table used by Amazon Athena, and you do not specify any partitionKeys, you must at least set the value of partitionKeys to an empty list. For example:  "PartitionKeys": []
        public let partitionKeys: [Column]?
        /// The retention time for this table.
        public let retention: Int?
        public let status: TableStatus?
        /// A storage descriptor containing information about the physical storage of this table.
        public let storageDescriptor: StorageDescriptor?
        /// The type of this table. Glue will create tables with the EXTERNAL_TABLE type. Other services, such as Athena, may create tables with additional table types.  Glue related table types:  EXTERNAL_TABLE  Hive compatible attribute - indicates a non-Hive managed table.  GOVERNED  Used by Lake Formation. The Glue Data Catalog understands GOVERNED.
        public let tableType: String?
        /// A TableIdentifier structure that describes a target table for resource linking.
        public let targetTable: TableIdentifier?
        /// The last time that the table was updated.
        public let updateTime: Date?
        /// The ID of the table version.
        public let versionId: String?
        /// A structure that contains all the information that defines the view, including the dialect or dialects for the view, and the query.
        public let viewDefinition: ViewDefinition?
        /// Included for Apache Hive compatibility. Not used in the normal course of Glue operations.
        public let viewExpandedText: String?
        /// Included for Apache Hive compatibility. Not used in the normal course of Glue operations. If the table is a VIRTUAL_VIEW, certain Athena configuration encoded in base64.
        public let viewOriginalText: String?

        @inlinable
        public init(catalogId: String? = nil, createdBy: String? = nil, createTime: Date? = nil, databaseName: String? = nil, description: String? = nil, federatedTable: FederatedTable? = nil, isMultiDialectView: Bool? = nil, isRegisteredWithLakeFormation: Bool? = nil, lastAccessTime: Date? = nil, lastAnalyzedTime: Date? = nil, name: String, owner: String? = nil, parameters: [String: String]? = nil, partitionKeys: [Column]? = nil, retention: Int? = nil, status: TableStatus? = nil, storageDescriptor: StorageDescriptor? = nil, tableType: String? = nil, targetTable: TableIdentifier? = nil, updateTime: Date? = nil, versionId: String? = nil, viewDefinition: ViewDefinition? = nil, viewExpandedText: String? = nil, viewOriginalText: String? = nil) {
            self.catalogId = catalogId
            self.createdBy = createdBy
            self.createTime = createTime
            self.databaseName = databaseName
            self.description = description
            self.federatedTable = federatedTable
            self.isMultiDialectView = isMultiDialectView
            self.isRegisteredWithLakeFormation = isRegisteredWithLakeFormation
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.retention = retention
            self.status = status
            self.storageDescriptor = storageDescriptor
            self.tableType = tableType
            self.targetTable = targetTable
            self.updateTime = updateTime
            self.versionId = versionId
            self.viewDefinition = viewDefinition
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case createdBy = "CreatedBy"
            case createTime = "CreateTime"
            case databaseName = "DatabaseName"
            case description = "Description"
            case federatedTable = "FederatedTable"
            case isMultiDialectView = "IsMultiDialectView"
            case isRegisteredWithLakeFormation = "IsRegisteredWithLakeFormation"
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case name = "Name"
            case owner = "Owner"
            case parameters = "Parameters"
            case partitionKeys = "PartitionKeys"
            case retention = "Retention"
            case status = "Status"
            case storageDescriptor = "StorageDescriptor"
            case tableType = "TableType"
            case targetTable = "TargetTable"
            case updateTime = "UpdateTime"
            case versionId = "VersionId"
            case viewDefinition = "ViewDefinition"
            case viewExpandedText = "ViewExpandedText"
            case viewOriginalText = "ViewOriginalText"
        }
    }

    public struct TableError: AWSDecodableShape {
        /// The details about the error.
        public let errorDetail: ErrorDetail?
        /// The name of the table. For Hive compatibility, this must be entirely lowercase.
        public let tableName: String?

        @inlinable
        public init(errorDetail: ErrorDetail? = nil, tableName: String? = nil) {
            self.errorDetail = errorDetail
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case tableName = "TableName"
        }
    }

    public struct TableIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the Data Catalog in which the table resides.
        public let catalogId: String?
        /// The name of the catalog database that contains the target table.
        public let databaseName: String?
        /// The name of the target table.
        public let name: String?
        /// Region of the target table.
        public let region: String?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String? = nil, name: String? = nil, region: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.region, name: "region", parent: name, max: 255)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.validate(self.region, name: "region", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case name = "Name"
            case region = "Region"
        }
    }

    public struct TableInput: AWSEncodableShape {
        /// A description of the table.
        public let description: String?
        /// The last time that the table was accessed.
        public let lastAccessTime: Date?
        /// The last time that column statistics were computed for this table.
        public let lastAnalyzedTime: Date?
        /// The table name. For Hive compatibility, this is folded to lowercase when it is stored.
        public let name: String
        /// The table owner. Included for Apache Hive compatibility. Not used in the normal course of Glue operations.
        public let owner: String?
        /// These key-value pairs define properties associated with the table.
        public let parameters: [String: String]?
        /// A list of columns by which the table is partitioned. Only primitive types are supported as partition keys. When you create a table used by Amazon Athena, and you do not specify any partitionKeys, you must at least set the value of partitionKeys to an empty list. For example:  "PartitionKeys": []
        public let partitionKeys: [Column]?
        /// The retention time for this table.
        public let retention: Int?
        /// A storage descriptor containing information about the physical storage of this table.
        public let storageDescriptor: StorageDescriptor?
        /// The type of this table. Glue will create tables with the EXTERNAL_TABLE type. Other services, such as Athena, may create tables with additional table types.  Glue related table types:  EXTERNAL_TABLE  Hive compatible attribute - indicates a non-Hive managed table.  GOVERNED  Used by Lake Formation. The Glue Data Catalog understands GOVERNED.
        public let tableType: String?
        /// A TableIdentifier structure that describes a target table for resource linking.
        public let targetTable: TableIdentifier?
        /// A structure that contains all the information that defines the view, including the dialect or dialects for the view, and the query.
        public let viewDefinition: ViewDefinitionInput?
        /// Included for Apache Hive compatibility. Not used in the normal course of Glue operations.
        public let viewExpandedText: String?
        /// Included for Apache Hive compatibility. Not used in the normal course of Glue operations. If the table is a VIRTUAL_VIEW, certain Athena configuration encoded in base64.
        public let viewOriginalText: String?

        @inlinable
        public init(description: String? = nil, lastAccessTime: Date? = nil, lastAnalyzedTime: Date? = nil, name: String, owner: String? = nil, parameters: [String: String]? = nil, partitionKeys: [Column]? = nil, retention: Int? = nil, storageDescriptor: StorageDescriptor? = nil, tableType: String? = nil, targetTable: TableIdentifier? = nil, viewDefinition: ViewDefinitionInput? = nil, viewExpandedText: String? = nil, viewOriginalText: String? = nil) {
            self.description = description
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.retention = retention
            self.storageDescriptor = storageDescriptor
            self.tableType = tableType
            self.targetTable = targetTable
            self.viewDefinition = viewDefinition
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.owner, name: "owner", parent: name, max: 255)
            try self.validate(self.owner, name: "owner", parent: name, min: 1)
            try self.validate(self.owner, name: "owner", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512000)
            }
            try self.partitionKeys?.forEach {
                try $0.validate(name: "\(name).partitionKeys[]")
            }
            try self.validate(self.retention, name: "retention", parent: name, min: 0)
            try self.storageDescriptor?.validate(name: "\(name).storageDescriptor")
            try self.validate(self.tableType, name: "tableType", parent: name, max: 255)
            try self.targetTable?.validate(name: "\(name).targetTable")
            try self.viewDefinition?.validate(name: "\(name).viewDefinition")
            try self.validate(self.viewExpandedText, name: "viewExpandedText", parent: name, max: 409600)
            try self.validate(self.viewOriginalText, name: "viewOriginalText", parent: name, max: 409600)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case name = "Name"
            case owner = "Owner"
            case parameters = "Parameters"
            case partitionKeys = "PartitionKeys"
            case retention = "Retention"
            case storageDescriptor = "StorageDescriptor"
            case tableType = "TableType"
            case targetTable = "TargetTable"
            case viewDefinition = "ViewDefinition"
            case viewExpandedText = "ViewExpandedText"
            case viewOriginalText = "ViewOriginalText"
        }
    }

    public struct TableOptimizer: AWSDecodableShape {
        /// A TableOptimizerConfiguration object that was specified when creating or updating a table optimizer.
        public let configuration: TableOptimizerConfiguration?
        /// A TableOptimizerRun object representing the last run of the table optimizer.
        public let lastRun: TableOptimizerRun?
        /// The type of table optimizer. The valid values are:    compaction: for managing compaction with a table optimizer.    retention: for managing the retention of snapshot with a table optimizer.    orphan_file_deletion: for managing the deletion of orphan files with a table optimizer.
        public let type: TableOptimizerType?

        @inlinable
        public init(configuration: TableOptimizerConfiguration? = nil, lastRun: TableOptimizerRun? = nil, type: TableOptimizerType? = nil) {
            self.configuration = configuration
            self.lastRun = lastRun
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case lastRun = "lastRun"
            case type = "type"
        }
    }

    public struct TableOptimizerConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Whether table optimization is enabled.
        public let enabled: Bool?
        /// The configuration for an orphan file deletion optimizer.
        public let orphanFileDeletionConfiguration: OrphanFileDeletionConfiguration?
        /// The configuration for a snapshot retention optimizer.
        public let retentionConfiguration: RetentionConfiguration?
        /// A role passed by the caller which gives the service permission to update the resources associated with the optimizer on the caller's behalf.
        public let roleArn: String?
        /// A TableOptimizerVpcConfiguration object representing the VPC configuration for a table optimizer. This configuration is necessary to perform optimization on tables that are in a customer VPC.
        public let vpcConfiguration: TableOptimizerVpcConfiguration?

        @inlinable
        public init(enabled: Bool? = nil, orphanFileDeletionConfiguration: OrphanFileDeletionConfiguration? = nil, retentionConfiguration: RetentionConfiguration? = nil, roleArn: String? = nil, vpcConfiguration: TableOptimizerVpcConfiguration? = nil) {
            self.enabled = enabled
            self.orphanFileDeletionConfiguration = orphanFileDeletionConfiguration
            self.retentionConfiguration = retentionConfiguration
            self.roleArn = roleArn
            self.vpcConfiguration = vpcConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case orphanFileDeletionConfiguration = "orphanFileDeletionConfiguration"
            case retentionConfiguration = "retentionConfiguration"
            case roleArn = "roleArn"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct TableOptimizerRun: AWSDecodableShape {
        /// A CompactionMetrics object containing metrics for the optimizer run.
        public let compactionMetrics: CompactionMetrics?
        /// Represents the epoch timestamp at which the compaction job ended.
        public let endTimestamp: Date?
        /// An error that occured during the optimizer run.
        public let error: String?
        /// An event type representing the status of the table optimizer run.
        public let eventType: TableOptimizerEventType?
        /// A RunMetrics object containing metrics for the optimizer run. This member is deprecated. See the individual metric members for compaction, retention, and orphan file deletion.
        public let metrics: RunMetrics?
        /// An OrphanFileDeletionMetrics object containing metrics for the optimizer run.
        public let orphanFileDeletionMetrics: OrphanFileDeletionMetrics?
        /// A RetentionMetrics object containing metrics for the optimizer run.
        public let retentionMetrics: RetentionMetrics?
        /// Represents the epoch timestamp at which the compaction job was started within Lake Formation.
        public let startTimestamp: Date?

        @inlinable
        public init(compactionMetrics: CompactionMetrics? = nil, endTimestamp: Date? = nil, error: String? = nil, eventType: TableOptimizerEventType? = nil, orphanFileDeletionMetrics: OrphanFileDeletionMetrics? = nil, retentionMetrics: RetentionMetrics? = nil, startTimestamp: Date? = nil) {
            self.compactionMetrics = compactionMetrics
            self.endTimestamp = endTimestamp
            self.error = error
            self.eventType = eventType
            self.metrics = nil
            self.orphanFileDeletionMetrics = orphanFileDeletionMetrics
            self.retentionMetrics = retentionMetrics
            self.startTimestamp = startTimestamp
        }

        @available(*, deprecated, message: "Members metrics have been deprecated")
        @inlinable
        public init(compactionMetrics: CompactionMetrics? = nil, endTimestamp: Date? = nil, error: String? = nil, eventType: TableOptimizerEventType? = nil, metrics: RunMetrics? = nil, orphanFileDeletionMetrics: OrphanFileDeletionMetrics? = nil, retentionMetrics: RetentionMetrics? = nil, startTimestamp: Date? = nil) {
            self.compactionMetrics = compactionMetrics
            self.endTimestamp = endTimestamp
            self.error = error
            self.eventType = eventType
            self.metrics = metrics
            self.orphanFileDeletionMetrics = orphanFileDeletionMetrics
            self.retentionMetrics = retentionMetrics
            self.startTimestamp = startTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case compactionMetrics = "compactionMetrics"
            case endTimestamp = "endTimestamp"
            case error = "error"
            case eventType = "eventType"
            case metrics = "metrics"
            case orphanFileDeletionMetrics = "orphanFileDeletionMetrics"
            case retentionMetrics = "retentionMetrics"
            case startTimestamp = "startTimestamp"
        }
    }

    public final class TableStatus: AWSDecodableShape {
        /// Indicates which action was called on the table, currently only CREATE or UPDATE.
        public let action: ResourceAction?
        /// A StatusDetails object with information about the requested change.
        public let details: StatusDetails?
        /// An error that will only appear when the state is "FAILED". This is a parent level exception message, there may be different Errors for each dialect.
        public let error: ErrorDetail?
        /// The ARN of the user who requested the asynchronous change.
        public let requestedBy: String?
        /// An ISO 8601 formatted date string indicating the time that the change was initiated.
        public let requestTime: Date?
        /// A generic status for the change in progress, such as QUEUED, IN_PROGRESS, SUCCESS, or FAILED.
        public let state: ResourceState?
        /// The ARN of the user to last manually alter the asynchronous change (requesting cancellation, etc).
        public let updatedBy: String?
        /// An ISO 8601 formatted date string indicating the time that the state was last updated.
        public let updateTime: Date?

        @inlinable
        public init(action: ResourceAction? = nil, details: StatusDetails? = nil, error: ErrorDetail? = nil, requestedBy: String? = nil, requestTime: Date? = nil, state: ResourceState? = nil, updatedBy: String? = nil, updateTime: Date? = nil) {
            self.action = action
            self.details = details
            self.error = error
            self.requestedBy = requestedBy
            self.requestTime = requestTime
            self.state = state
            self.updatedBy = updatedBy
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case details = "Details"
            case error = "Error"
            case requestedBy = "RequestedBy"
            case requestTime = "RequestTime"
            case state = "State"
            case updatedBy = "UpdatedBy"
            case updateTime = "UpdateTime"
        }
    }

    public struct TableVersion: AWSDecodableShape {
        /// The table in question.
        public let table: Table?
        /// The ID value that identifies this table version. A VersionId is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String?

        @inlinable
        public init(table: Table? = nil, versionId: String? = nil) {
            self.table = table
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
            case versionId = "VersionId"
        }
    }

    public struct TableVersionError: AWSDecodableShape {
        /// The details about the error.
        public let errorDetail: ErrorDetail?
        /// The name of the table in question.
        public let tableName: String?
        /// The ID value of the version in question. A VersionID is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String?

        @inlinable
        public init(errorDetail: ErrorDetail? = nil, tableName: String? = nil, versionId: String? = nil) {
            self.errorDetail = errorDetail
            self.tableName = tableName
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case tableName = "TableName"
            case versionId = "VersionId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key. The key is required when you create a tag on an object. The key is case-sensitive, and must not contain the prefix aws.
        public let key: String?
        /// The tag value. The value is optional when you create a tag on an object. The value is case-sensitive, and must not contain the prefix aws.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the Glue resource to which to add the tags. For more information about Glue resource ARNs, see the Glue ARN string pattern.
        public let resourceArn: String
        /// Tags to add to this resource.
        public let tagsToAdd: [String: String]

        @inlinable
        public init(resourceArn: String, tagsToAdd: [String: String]) {
            self.resourceArn = resourceArn
            self.tagsToAdd = tagsToAdd
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:glue:")
            try self.tagsToAdd.forEach {
                try validate($0.key, name: "tagsToAdd.key", parent: name, max: 128)
                try validate($0.key, name: "tagsToAdd.key", parent: name, min: 1)
                try validate($0.value, name: "tagsToAdd[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tagsToAdd, name: "tagsToAdd", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagsToAdd = "TagsToAdd"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetProcessingProperties: AWSEncodableShape & AWSDecodableShape {
        /// The Glue network connection to configure the Glue job running in the customer VPC.
        public let connectionName: String?
        /// The ARN of an Eventbridge event bus to receive the integration status notification.
        public let eventBusArn: String?
        /// The ARN of the KMS key used for encryption.
        public let kmsArn: String?
        /// The IAM role to access the Glue database.
        public let roleArn: String?

        @inlinable
        public init(connectionName: String? = nil, eventBusArn: String? = nil, kmsArn: String? = nil, roleArn: String? = nil) {
            self.connectionName = connectionName
            self.eventBusArn = eventBusArn
            self.kmsArn = kmsArn
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 128)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.eventBusArn, name: "eventBusArn", parent: name, max: 2048)
            try self.validate(self.eventBusArn, name: "eventBusArn", parent: name, min: 1)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, max: 2048)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 128)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case eventBusArn = "EventBusArn"
            case kmsArn = "KmsArn"
            case roleArn = "RoleArn"
        }
    }

    public struct TargetRedshiftCatalog: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the catalog resource.
        public let catalogArn: String

        @inlinable
        public init(catalogArn: String) {
            self.catalogArn = catalogArn
        }

        private enum CodingKeys: String, CodingKey {
            case catalogArn = "CatalogArn"
        }
    }

    public struct TargetTableConfig: AWSEncodableShape & AWSDecodableShape {
        /// Determines the file layout on the target.
        public let partitionSpec: [IntegrationPartition]?
        /// The optional name of a target table.
        public let targetTableName: String?
        /// Specifies how nested objects are flattened to top-level elements. Valid values are: "TOPLEVEL", "FULL", or "NOUNNEST".
        public let unnestSpec: UnnestSpec?

        @inlinable
        public init(partitionSpec: [IntegrationPartition]? = nil, targetTableName: String? = nil, unnestSpec: UnnestSpec? = nil) {
            self.partitionSpec = partitionSpec
            self.targetTableName = targetTableName
            self.unnestSpec = unnestSpec
        }

        public func validate(name: String) throws {
            try self.partitionSpec?.forEach {
                try $0.validate(name: "\(name).partitionSpec[]")
            }
            try self.validate(self.targetTableName, name: "targetTableName", parent: name, max: 128)
            try self.validate(self.targetTableName, name: "targetTableName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case partitionSpec = "PartitionSpec"
            case targetTableName = "TargetTableName"
            case unnestSpec = "UnnestSpec"
        }
    }

    public struct TaskRun: AWSDecodableShape {
        /// The last point in time that the requested task run was completed.
        public let completedOn: Date?
        /// The list of error strings associated with this task run.
        public let errorString: String?
        /// The amount of time (in seconds) that the task run consumed resources.
        public let executionTime: Int?
        /// The last point in time that the requested task run was updated.
        public let lastModifiedOn: Date?
        /// The names of the log group for secure logging, associated with this task run.
        public let logGroupName: String?
        /// Specifies configuration properties associated with this task run.
        public let properties: TaskRunProperties?
        /// The date and time that this task run started.
        public let startedOn: Date?
        /// The current status of the requested task run.
        public let status: TaskStatusType?
        /// The unique identifier for this task run.
        public let taskRunId: String?
        /// The unique identifier for the transform.
        public let transformId: String?

        @inlinable
        public init(completedOn: Date? = nil, errorString: String? = nil, executionTime: Int? = nil, lastModifiedOn: Date? = nil, logGroupName: String? = nil, properties: TaskRunProperties? = nil, startedOn: Date? = nil, status: TaskStatusType? = nil, taskRunId: String? = nil, transformId: String? = nil) {
            self.completedOn = completedOn
            self.errorString = errorString
            self.executionTime = executionTime
            self.lastModifiedOn = lastModifiedOn
            self.logGroupName = logGroupName
            self.properties = properties
            self.startedOn = startedOn
            self.status = status
            self.taskRunId = taskRunId
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case errorString = "ErrorString"
            case executionTime = "ExecutionTime"
            case lastModifiedOn = "LastModifiedOn"
            case logGroupName = "LogGroupName"
            case properties = "Properties"
            case startedOn = "StartedOn"
            case status = "Status"
            case taskRunId = "TaskRunId"
            case transformId = "TransformId"
        }
    }

    public struct TaskRunFilterCriteria: AWSEncodableShape {
        /// Filter on task runs started after this date.
        public let startedAfter: Date?
        /// Filter on task runs started before this date.
        public let startedBefore: Date?
        /// The current status of the task run.
        public let status: TaskStatusType?
        /// The type of task run.
        public let taskRunType: TaskType?

        @inlinable
        public init(startedAfter: Date? = nil, startedBefore: Date? = nil, status: TaskStatusType? = nil, taskRunType: TaskType? = nil) {
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
            self.status = status
            self.taskRunType = taskRunType
        }

        private enum CodingKeys: String, CodingKey {
            case startedAfter = "StartedAfter"
            case startedBefore = "StartedBefore"
            case status = "Status"
            case taskRunType = "TaskRunType"
        }
    }

    public struct TaskRunProperties: AWSDecodableShape {
        /// The configuration properties for an exporting labels task run.
        public let exportLabelsTaskRunProperties: ExportLabelsTaskRunProperties?
        /// The configuration properties for a find matches task run.
        public let findMatchesTaskRunProperties: FindMatchesTaskRunProperties?
        /// The configuration properties for an importing labels task run.
        public let importLabelsTaskRunProperties: ImportLabelsTaskRunProperties?
        /// The configuration properties for a labeling set generation task run.
        public let labelingSetGenerationTaskRunProperties: LabelingSetGenerationTaskRunProperties?
        /// The type of task run.
        public let taskType: TaskType?

        @inlinable
        public init(exportLabelsTaskRunProperties: ExportLabelsTaskRunProperties? = nil, findMatchesTaskRunProperties: FindMatchesTaskRunProperties? = nil, importLabelsTaskRunProperties: ImportLabelsTaskRunProperties? = nil, labelingSetGenerationTaskRunProperties: LabelingSetGenerationTaskRunProperties? = nil, taskType: TaskType? = nil) {
            self.exportLabelsTaskRunProperties = exportLabelsTaskRunProperties
            self.findMatchesTaskRunProperties = findMatchesTaskRunProperties
            self.importLabelsTaskRunProperties = importLabelsTaskRunProperties
            self.labelingSetGenerationTaskRunProperties = labelingSetGenerationTaskRunProperties
            self.taskType = taskType
        }

        private enum CodingKeys: String, CodingKey {
            case exportLabelsTaskRunProperties = "ExportLabelsTaskRunProperties"
            case findMatchesTaskRunProperties = "FindMatchesTaskRunProperties"
            case importLabelsTaskRunProperties = "ImportLabelsTaskRunProperties"
            case labelingSetGenerationTaskRunProperties = "LabelingSetGenerationTaskRunProperties"
            case taskType = "TaskType"
        }
    }

    public struct TaskRunSortCriteria: AWSEncodableShape {
        /// The column to be used to sort the list of task runs for the machine learning transform.
        public let column: TaskRunSortColumnType
        /// The sort direction to be used to sort the list of task runs for the machine learning transform.
        public let sortDirection: SortDirectionType

        @inlinable
        public init(column: TaskRunSortColumnType, sortDirection: SortDirectionType) {
            self.column = column
            self.sortDirection = sortDirection
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case sortDirection = "SortDirection"
        }
    }

    public struct TestConnectionInput: AWSEncodableShape {
        /// A structure containing the authentication configuration in the TestConnection request. Required for a connection to Salesforce using OAuth authentication.
        public let authenticationConfiguration: AuthenticationConfigurationInput?
        /// The key-value pairs that define parameters for the connection. JDBC connections use the following connection properties:   Required: All of (HOST, PORT, JDBC_ENGINE) or JDBC_CONNECTION_URL.   Required: All of (USERNAME, PASSWORD) or SECRET_ID.   Optional: JDBC_ENFORCE_SSL, CUSTOM_JDBC_CERT, CUSTOM_JDBC_CERT_STRING, SKIP_CUSTOM_JDBC_CERT_VALIDATION. These parameters are used to configure SSL with JDBC.   SALESFORCE connections require the AuthenticationConfiguration member to be configured.
        public let connectionProperties: [ConnectionPropertyKey: String]
        /// The type of connection to test. This operation is only available for the JDBC or SALESFORCE connection types.
        public let connectionType: ConnectionType

        @inlinable
        public init(authenticationConfiguration: AuthenticationConfigurationInput? = nil, connectionProperties: [ConnectionPropertyKey: String], connectionType: ConnectionType) {
            self.authenticationConfiguration = authenticationConfiguration
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
        }

        public func validate(name: String) throws {
            try self.authenticationConfiguration?.validate(name: "\(name).authenticationConfiguration")
            try self.connectionProperties.forEach {
                try validate($0.value, name: "connectionProperties[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "connectionProperties[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.connectionProperties, name: "connectionProperties", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationConfiguration = "AuthenticationConfiguration"
            case connectionProperties = "ConnectionProperties"
            case connectionType = "ConnectionType"
        }
    }

    public struct TestConnectionRequest: AWSEncodableShape {
        /// The catalog ID where the connection resides.
        public let catalogId: String?
        /// Optional. The name of the connection to test. If only name is provided, the operation will get the connection and use that for testing.
        public let connectionName: String?
        /// A structure that is used to specify testing a connection to a service.
        public let testConnectionInput: TestConnectionInput?

        @inlinable
        public init(catalogId: String? = nil, connectionName: String? = nil, testConnectionInput: TestConnectionInput? = nil) {
            self.catalogId = catalogId
            self.connectionName = connectionName
            self.testConnectionInput = testConnectionInput
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 255)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.testConnectionInput?.validate(name: "\(name).testConnectionInput")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionName = "ConnectionName"
            case testConnectionInput = "TestConnectionInput"
        }
    }

    public struct TestConnectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimestampFilter: AWSEncodableShape {
        /// The timestamp after which statistics should be included in the results.
        public let recordedAfter: Date?
        /// The timestamp before which statistics should be included in the results.
        public let recordedBefore: Date?

        @inlinable
        public init(recordedAfter: Date? = nil, recordedBefore: Date? = nil) {
            self.recordedAfter = recordedAfter
            self.recordedBefore = recordedBefore
        }

        private enum CodingKeys: String, CodingKey {
            case recordedAfter = "RecordedAfter"
            case recordedBefore = "RecordedBefore"
        }
    }

    public struct TimestampedInclusionAnnotation: AWSDecodableShape {
        /// The timestamp when the inclusion annotation was last modified.
        public let lastModifiedOn: Date?
        /// The inclusion annotation value.
        public let value: InclusionAnnotationValue?

        @inlinable
        public init(lastModifiedOn: Date? = nil, value: InclusionAnnotationValue? = nil) {
            self.lastModifiedOn = lastModifiedOn
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedOn = "LastModifiedOn"
            case value = "Value"
        }
    }

    public struct TransformConfigParameter: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the parameter is optional or not in the config file of the dynamic transform.
        public let isOptional: Bool?
        /// Specifies the list type of the parameter in the config file of the dynamic transform.
        public let listType: ParamType?
        /// Specifies the name of the parameter in the config file of the dynamic transform.
        public let name: String
        /// Specifies the parameter type in the config file of the dynamic transform.
        public let type: ParamType
        /// Specifies the validation message in the config file of the dynamic transform.
        public let validationMessage: String?
        /// Specifies the validation rule in the config file of the dynamic transform.
        public let validationRule: String?
        /// Specifies the value of the parameter in the config file of the dynamic transform.
        public let value: [String]?

        @inlinable
        public init(isOptional: Bool? = nil, listType: ParamType? = nil, name: String, type: ParamType, validationMessage: String? = nil, validationRule: String? = nil, value: [String]? = nil) {
            self.isOptional = isOptional
            self.listType = listType
            self.name = name
            self.type = type
            self.validationMessage = validationMessage
            self.validationRule = validationRule
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.validationMessage, name: "validationMessage", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.validationRule, name: "validationRule", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.value?.forEach {
                try validate($0, name: "value[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case isOptional = "IsOptional"
            case listType = "ListType"
            case name = "Name"
            case type = "Type"
            case validationMessage = "ValidationMessage"
            case validationRule = "ValidationRule"
            case value = "Value"
        }
    }

    public struct TransformEncryption: AWSEncodableShape & AWSDecodableShape {
        /// An MLUserDataEncryption object containing the encryption mode and customer-provided KMS key ID.
        public let mlUserDataEncryption: MLUserDataEncryption?
        /// The name of the security configuration.
        public let taskRunSecurityConfigurationName: String?

        @inlinable
        public init(mlUserDataEncryption: MLUserDataEncryption? = nil, taskRunSecurityConfigurationName: String? = nil) {
            self.mlUserDataEncryption = mlUserDataEncryption
            self.taskRunSecurityConfigurationName = taskRunSecurityConfigurationName
        }

        public func validate(name: String) throws {
            try self.mlUserDataEncryption?.validate(name: "\(name).mlUserDataEncryption")
            try self.validate(self.taskRunSecurityConfigurationName, name: "taskRunSecurityConfigurationName", parent: name, max: 255)
            try self.validate(self.taskRunSecurityConfigurationName, name: "taskRunSecurityConfigurationName", parent: name, min: 1)
            try self.validate(self.taskRunSecurityConfigurationName, name: "taskRunSecurityConfigurationName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case mlUserDataEncryption = "MlUserDataEncryption"
            case taskRunSecurityConfigurationName = "TaskRunSecurityConfigurationName"
        }
    }

    public struct TransformFilterCriteria: AWSEncodableShape {
        /// The time and date after which the transforms were created.
        public let createdAfter: Date?
        /// The time and date before which the transforms were created.
        public let createdBefore: Date?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see Glue Versions in the developer guide.
        public let glueVersion: String?
        /// Filter on transforms last modified after this date.
        public let lastModifiedAfter: Date?
        /// Filter on transforms last modified before this date.
        public let lastModifiedBefore: Date?
        /// A unique transform name that is used to filter the machine learning transforms.
        public let name: String?
        /// Filters on datasets with a specific schema. The Map object is an array of key-value pairs representing the schema this transform accepts, where Column is the name of a column, and Type is the type of the data such as an integer or string. Has an upper bound of 100 columns.
        public let schema: [SchemaColumn]?
        /// Filters the list of machine learning transforms by the last known status of the transforms (to indicate whether a transform can be used or not). One of "NOT_READY", "READY", or "DELETING".
        public let status: TransformStatusType?
        /// The type of machine learning transform that is used to filter the machine learning transforms.
        public let transformType: TransformType?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, glueVersion: String? = nil, lastModifiedAfter: Date? = nil, lastModifiedBefore: Date? = nil, name: String? = nil, schema: [SchemaColumn]? = nil, status: TransformStatusType? = nil, transformType: TransformType? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.glueVersion = glueVersion
            self.lastModifiedAfter = lastModifiedAfter
            self.lastModifiedBefore = lastModifiedBefore
            self.name = name
            self.schema = schema
            self.status = status
            self.transformType = transformType
        }

        public func validate(name: String) throws {
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^(\\w+\\.)+\\w+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.schema?.forEach {
                try $0.validate(name: "\(name).schema[]")
            }
            try self.validate(self.schema, name: "schema", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case glueVersion = "GlueVersion"
            case lastModifiedAfter = "LastModifiedAfter"
            case lastModifiedBefore = "LastModifiedBefore"
            case name = "Name"
            case schema = "Schema"
            case status = "Status"
            case transformType = "TransformType"
        }
    }

    public struct TransformParameters: AWSEncodableShape & AWSDecodableShape {
        /// The parameters for the find matches algorithm.
        public let findMatchesParameters: FindMatchesParameters?
        /// The type of machine learning transform. For information about the types of machine learning transforms, see Creating Machine Learning Transforms.
        public let transformType: TransformType

        @inlinable
        public init(findMatchesParameters: FindMatchesParameters? = nil, transformType: TransformType) {
            self.findMatchesParameters = findMatchesParameters
            self.transformType = transformType
        }

        public func validate(name: String) throws {
            try self.findMatchesParameters?.validate(name: "\(name).findMatchesParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case findMatchesParameters = "FindMatchesParameters"
            case transformType = "TransformType"
        }
    }

    public struct TransformSortCriteria: AWSEncodableShape {
        /// The column to be used in the sorting criteria that are associated with the machine learning transform.
        public let column: TransformSortColumnType
        /// The sort direction to be used in the sorting criteria that are associated with the machine learning transform.
        public let sortDirection: SortDirectionType

        @inlinable
        public init(column: TransformSortColumnType, sortDirection: SortDirectionType) {
            self.column = column
            self.sortDirection = sortDirection
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case sortDirection = "SortDirection"
        }
    }

    public struct Trigger: AWSDecodableShape {
        /// The actions initiated by this trigger.
        public let actions: [Action]?
        /// A description of this trigger.
        public let description: String?
        /// Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.
        public let eventBatchingCondition: EventBatchingCondition?
        /// Reserved for future use.
        public let id: String?
        /// The name of the trigger.
        public let name: String?
        /// The predicate of this trigger, which defines when it will fire.
        public let predicate: Predicate?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// The current state of the trigger.
        public let state: TriggerState?
        /// The type of trigger that this is.
        public let type: TriggerType?
        /// The name of the workflow associated with the trigger.
        public let workflowName: String?

        @inlinable
        public init(actions: [Action]? = nil, description: String? = nil, eventBatchingCondition: EventBatchingCondition? = nil, id: String? = nil, name: String? = nil, predicate: Predicate? = nil, schedule: String? = nil, state: TriggerState? = nil, type: TriggerType? = nil, workflowName: String? = nil) {
            self.actions = actions
            self.description = description
            self.eventBatchingCondition = eventBatchingCondition
            self.id = id
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
            self.state = state
            self.type = type
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case eventBatchingCondition = "EventBatchingCondition"
            case id = "Id"
            case name = "Name"
            case predicate = "Predicate"
            case schedule = "Schedule"
            case state = "State"
            case type = "Type"
            case workflowName = "WorkflowName"
        }
    }

    public struct TriggerNodeDetails: AWSDecodableShape {
        /// The information of the trigger represented by the trigger node.
        public let trigger: Trigger?

        @inlinable
        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public struct TriggerUpdate: AWSEncodableShape {
        /// The actions initiated by this trigger.
        public let actions: [Action]?
        /// A description of this trigger.
        public let description: String?
        /// Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.
        public let eventBatchingCondition: EventBatchingCondition?
        /// Reserved for future use.
        public let name: String?
        /// The predicate of this trigger, which defines when it will fire.
        public let predicate: Predicate?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?

        @inlinable
        public init(actions: [Action]? = nil, description: String? = nil, eventBatchingCondition: EventBatchingCondition? = nil, name: String? = nil, predicate: Predicate? = nil, schedule: String? = nil) {
            self.actions = actions
            self.description = description
            self.eventBatchingCondition = eventBatchingCondition
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.eventBatchingCondition?.validate(name: "\(name).eventBatchingCondition")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.predicate?.validate(name: "\(name).predicate")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case eventBatchingCondition = "EventBatchingCondition"
            case name = "Name"
            case predicate = "Predicate"
            case schedule = "Schedule"
        }
    }

    public struct UnfilteredPartition: AWSDecodableShape {
        /// The list of columns the user has permissions to access.
        public let authorizedColumns: [String]?
        /// A Boolean value indicating that the partition location is registered with Lake Formation.
        public let isRegisteredWithLakeFormation: Bool?
        /// The partition object.
        public let partition: Partition?

        @inlinable
        public init(authorizedColumns: [String]? = nil, isRegisteredWithLakeFormation: Bool? = nil, partition: Partition? = nil) {
            self.authorizedColumns = authorizedColumns
            self.isRegisteredWithLakeFormation = isRegisteredWithLakeFormation
            self.partition = partition
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedColumns = "AuthorizedColumns"
            case isRegisteredWithLakeFormation = "IsRegisteredWithLakeFormation"
            case partition = "Partition"
        }
    }

    public struct Union: AWSEncodableShape & AWSDecodableShape {
        /// The node ID inputs to the transform.
        public let inputs: [String]
        /// The name of the transform node.
        public let name: String
        /// Indicates the type of Union transform.  Specify ALL to join all rows from data sources to the resulting DynamicFrame. The resulting union does not remove duplicate rows. Specify DISTINCT to remove duplicate rows in the resulting DynamicFrame.
        public let unionType: UnionType

        @inlinable
        public init(inputs: [String], name: String, unionType: UnionType) {
            self.inputs = inputs
            self.name = name
            self.unionType = unionType
        }

        public func validate(name: String) throws {
            try self.inputs.forEach {
                try validate($0, name: "inputs[]", parent: name, pattern: "^[A-Za-z0-9_-]*$")
            }
            try self.validate(self.inputs, name: "inputs", parent: name, max: 2)
            try self.validate(self.inputs, name: "inputs", parent: name, min: 2)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([^\\r\\n])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputs = "Inputs"
            case name = "Name"
            case unionType = "UnionType"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which to remove the tags.
        public let resourceArn: String
        /// Tags to remove from this resource.
        public let tagsToRemove: [String]

        @inlinable
        public init(resourceArn: String, tagsToRemove: [String]) {
            self.resourceArn = resourceArn
            self.tagsToRemove = tagsToRemove
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-(cn|us-gov|iso(-[bef])?))?:glue:")
            try self.tagsToRemove.forEach {
                try validate($0, name: "tagsToRemove[]", parent: name, max: 128)
                try validate($0, name: "tagsToRemove[]", parent: name, min: 1)
            }
            try self.validate(self.tagsToRemove, name: "tagsToRemove", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagsToRemove = "TagsToRemove"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBlueprintRequest: AWSEncodableShape {
        /// Specifies a path in Amazon S3 where the blueprint is published.
        public let blueprintLocation: String
        /// A description of the blueprint.
        public let description: String?
        /// The name of the blueprint.
        public let name: String

        @inlinable
        public init(blueprintLocation: String, description: String? = nil, name: String) {
            self.blueprintLocation = blueprintLocation
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.blueprintLocation, name: "blueprintLocation", parent: name, max: 8192)
            try self.validate(self.blueprintLocation, name: "blueprintLocation", parent: name, min: 1)
            try self.validate(self.blueprintLocation, name: "blueprintLocation", parent: name, pattern: "^s3://([^/]+)/([^/]+/)*([^/]+)$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\.\\-_A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintLocation = "BlueprintLocation"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateBlueprintResponse: AWSDecodableShape {
        /// Returns the name of the blueprint that was updated.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateCatalogRequest: AWSEncodableShape {
        /// The ID of the catalog.
        public let catalogId: String
        /// A CatalogInput object specifying the new properties of an existing catalog.
        public let catalogInput: CatalogInput

        @inlinable
        public init(catalogId: String, catalogInput: CatalogInput) {
            self.catalogId = catalogId
            self.catalogInput = catalogInput
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.catalogInput.validate(name: "\(name).catalogInput")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case catalogInput = "CatalogInput"
        }
    }

    public struct UpdateCatalogResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateClassifierRequest: AWSEncodableShape {
        /// A CsvClassifier object with updated fields.
        public let csvClassifier: UpdateCsvClassifierRequest?
        /// A GrokClassifier object with updated fields.
        public let grokClassifier: UpdateGrokClassifierRequest?
        /// A JsonClassifier object with updated fields.
        public let jsonClassifier: UpdateJsonClassifierRequest?
        /// An XMLClassifier object with updated fields.
        public let xmlClassifier: UpdateXMLClassifierRequest?

        @inlinable
        public init(csvClassifier: UpdateCsvClassifierRequest? = nil, grokClassifier: UpdateGrokClassifierRequest? = nil, jsonClassifier: UpdateJsonClassifierRequest? = nil, xmlClassifier: UpdateXMLClassifierRequest? = nil) {
            self.csvClassifier = csvClassifier
            self.grokClassifier = grokClassifier
            self.jsonClassifier = jsonClassifier
            self.xmlClassifier = xmlClassifier
        }

        public func validate(name: String) throws {
            try self.csvClassifier?.validate(name: "\(name).csvClassifier")
            try self.grokClassifier?.validate(name: "\(name).grokClassifier")
            try self.jsonClassifier?.validate(name: "\(name).jsonClassifier")
            try self.xmlClassifier?.validate(name: "\(name).xmlClassifier")
        }

        private enum CodingKeys: String, CodingKey {
            case csvClassifier = "CsvClassifier"
            case grokClassifier = "GrokClassifier"
            case jsonClassifier = "JsonClassifier"
            case xmlClassifier = "XMLClassifier"
        }
    }

    public struct UpdateClassifierResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateColumnStatisticsForPartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A list of the column statistics.
        public let columnStatisticsList: [ColumnStatistics]
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// A list of partition values identifying the partition.
        public let partitionValues: [String]
        /// The name of the partitions' table.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, columnStatisticsList: [ColumnStatistics], databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.columnStatisticsList = columnStatisticsList
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.columnStatisticsList.forEach {
                try $0.validate(name: "\(name).columnStatisticsList[]")
            }
            try self.validate(self.columnStatisticsList, name: "columnStatisticsList", parent: name, max: 25)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
                try validate($0, name: "partitionValues[]", parent: name, min: 1)
            }
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnStatisticsList = "ColumnStatisticsList"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct UpdateColumnStatisticsForPartitionResponse: AWSDecodableShape {
        /// Error occurred during updating column statistics data.
        public let errors: [ColumnStatisticsError]?

        @inlinable
        public init(errors: [ColumnStatisticsError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct UpdateColumnStatisticsForTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A list of the column statistics.
        public let columnStatisticsList: [ColumnStatistics]
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// The name of the partitions' table.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, columnStatisticsList: [ColumnStatistics], databaseName: String, tableName: String) {
            self.catalogId = catalogId
            self.columnStatisticsList = columnStatisticsList
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.columnStatisticsList.forEach {
                try $0.validate(name: "\(name).columnStatisticsList[]")
            }
            try self.validate(self.columnStatisticsList, name: "columnStatisticsList", parent: name, max: 25)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnStatisticsList = "ColumnStatisticsList"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct UpdateColumnStatisticsForTableResponse: AWSDecodableShape {
        /// List of ColumnStatisticsErrors.
        public let errors: [ColumnStatisticsError]?

        @inlinable
        public init(errors: [ColumnStatisticsError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct UpdateColumnStatisticsTaskSettingsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the database resides.
        public let catalogID: String?
        /// A list of column names for which to run statistics.
        public let columnNameList: [String]?
        /// The name of the database where the table resides.
        public let databaseName: String
        /// The role used for running the column statistics.
        public let role: String?
        /// The percentage of data to sample.
        public let sampleSize: Double?
        /// A schedule for running the column statistics, specified in CRON syntax.
        public let schedule: String?
        /// Name of the security configuration that is used to encrypt CloudWatch logs.
        public let securityConfiguration: String?
        /// The name of the table for which to generate column statistics.
        public let tableName: String

        @inlinable
        public init(catalogID: String? = nil, columnNameList: [String]? = nil, databaseName: String, role: String? = nil, sampleSize: Double? = nil, schedule: String? = nil, securityConfiguration: String? = nil, tableName: String) {
            self.catalogID = catalogID
            self.columnNameList = columnNameList
            self.databaseName = databaseName
            self.role = role
            self.sampleSize = sampleSize
            self.schedule = schedule
            self.securityConfiguration = securityConfiguration
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogID, name: "catalogID", parent: name, max: 255)
            try self.validate(self.catalogID, name: "catalogID", parent: name, min: 1)
            try self.validate(self.catalogID, name: "catalogID", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.columnNameList?.forEach {
                try validate($0, name: "columnNameList[]", parent: name, max: 255)
                try validate($0, name: "columnNameList[]", parent: name, min: 1)
                try validate($0, name: "columnNameList[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.role, name: "role", parent: name, max: 255)
            try self.validate(self.role, name: "role", parent: name, min: 1)
            try self.validate(self.role, name: "role", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.sampleSize, name: "sampleSize", parent: name, max: 100.0)
            try self.validate(self.sampleSize, name: "sampleSize", parent: name, min: 0.0)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogID = "CatalogID"
            case columnNameList = "ColumnNameList"
            case databaseName = "DatabaseName"
            case role = "Role"
            case sampleSize = "SampleSize"
            case schedule = "Schedule"
            case securityConfiguration = "SecurityConfiguration"
            case tableName = "TableName"
        }
    }

    public struct UpdateColumnStatisticsTaskSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConnectionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A ConnectionInput object that redefines the connection in question.
        public let connectionInput: ConnectionInput
        /// The name of the connection definition to update.
        public let name: String

        @inlinable
        public init(catalogId: String? = nil, connectionInput: ConnectionInput, name: String) {
            self.catalogId = catalogId
            self.connectionInput = connectionInput
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.connectionInput.validate(name: "\(name).connectionInput")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionInput = "ConnectionInput"
            case name = "Name"
        }
    }

    public struct UpdateConnectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCrawlerRequest: AWSEncodableShape {
        /// A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
        public let classifiers: [String]?
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Setting crawler configuration options.
        public let configuration: String?
        /// The name of the SecurityConfiguration structure to be used by this crawler.
        public let crawlerSecurityConfiguration: String?
        /// The Glue database where results are stored, such as: arn:aws:daylight:us-east-1::database/sometable/*.
        public let databaseName: String?
        /// A description of the new crawler.
        public let description: String?
        /// Specifies Lake Formation configuration settings for the crawler.
        public let lakeFormationConfiguration: LakeFormationConfiguration?
        /// Specifies data lineage configuration settings for the crawler.
        public let lineageConfiguration: LineageConfiguration?
        /// Name of the new crawler.
        public let name: String
        /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
        public let recrawlPolicy: RecrawlPolicy?
        /// The IAM role or Amazon Resource Name (ARN) of an IAM role that is used by the new crawler to access customer resources.
        public let role: String?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// The policy for the crawler's update and deletion behavior.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// The table prefix used for catalog tables that are created.
        public let tablePrefix: String?
        /// A list of targets to crawl.
        public let targets: CrawlerTargets?

        @inlinable
        public init(classifiers: [String]? = nil, configuration: String? = nil, crawlerSecurityConfiguration: String? = nil, databaseName: String? = nil, description: String? = nil, lakeFormationConfiguration: LakeFormationConfiguration? = nil, lineageConfiguration: LineageConfiguration? = nil, name: String, recrawlPolicy: RecrawlPolicy? = nil, role: String? = nil, schedule: String? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, tablePrefix: String? = nil, targets: CrawlerTargets? = nil) {
            self.classifiers = classifiers
            self.configuration = configuration
            self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
            self.databaseName = databaseName
            self.description = description
            self.lakeFormationConfiguration = lakeFormationConfiguration
            self.lineageConfiguration = lineageConfiguration
            self.name = name
            self.recrawlPolicy = recrawlPolicy
            self.role = role
            self.schedule = schedule
            self.schemaChangePolicy = schemaChangePolicy
            self.tablePrefix = tablePrefix
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.classifiers?.forEach {
                try validate($0, name: "classifiers[]", parent: name, max: 255)
                try validate($0, name: "classifiers[]", parent: name, min: 1)
                try validate($0, name: "classifiers[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.crawlerSecurityConfiguration, name: "crawlerSecurityConfiguration", parent: name, max: 128)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.lakeFormationConfiguration?.validate(name: "\(name).lakeFormationConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tablePrefix, name: "tablePrefix", parent: name, max: 128)
            try self.targets?.validate(name: "\(name).targets")
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case configuration = "Configuration"
            case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
            case databaseName = "DatabaseName"
            case description = "Description"
            case lakeFormationConfiguration = "LakeFormationConfiguration"
            case lineageConfiguration = "LineageConfiguration"
            case name = "Name"
            case recrawlPolicy = "RecrawlPolicy"
            case role = "Role"
            case schedule = "Schedule"
            case schemaChangePolicy = "SchemaChangePolicy"
            case tablePrefix = "TablePrefix"
            case targets = "Targets"
        }
    }

    public struct UpdateCrawlerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCrawlerScheduleRequest: AWSEncodableShape {
        /// The name of the crawler whose schedule to update.
        public let crawlerName: String
        /// The updated cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?

        @inlinable
        public init(crawlerName: String, schedule: String? = nil) {
            self.crawlerName = crawlerName
            self.schedule = schedule
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
            case schedule = "Schedule"
        }
    }

    public struct UpdateCrawlerScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCsvClassifierRequest: AWSEncodableShape {
        /// Enables the processing of files that contain only one column.
        public let allowSingleColumn: Bool?
        /// Indicates whether the CSV file contains a header.
        public let containsHeader: CsvHeaderOption?
        /// Specifies the configuration of custom datatypes.
        public let customDatatypeConfigured: Bool?
        /// Specifies a list of supported custom datatypes.
        public let customDatatypes: [String]?
        /// A custom symbol to denote what separates each column entry in the row.
        public let delimiter: String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public let disableValueTrimming: Bool?
        /// A list of strings representing column names.
        public let header: [String]?
        /// The name of the classifier.
        public let name: String
        /// A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        public let quoteSymbol: String?
        /// Sets the SerDe for processing CSV in the classifier, which will be applied in the Data Catalog. Valid values are OpenCSVSerDe, LazySimpleSerDe, and None. You can specify the None value when you want the crawler to do the detection.
        public let serde: CsvSerdeOption?

        @inlinable
        public init(allowSingleColumn: Bool? = nil, containsHeader: CsvHeaderOption? = nil, customDatatypeConfigured: Bool? = nil, customDatatypes: [String]? = nil, delimiter: String? = nil, disableValueTrimming: Bool? = nil, header: [String]? = nil, name: String, quoteSymbol: String? = nil, serde: CsvSerdeOption? = nil) {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.customDatatypeConfigured = customDatatypeConfigured
            self.customDatatypes = customDatatypes
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.name = name
            self.quoteSymbol = quoteSymbol
            self.serde = serde
        }

        public func validate(name: String) throws {
            try self.customDatatypes?.forEach {
                try validate($0, name: "customDatatypes[]", parent: name, max: 255)
                try validate($0, name: "customDatatypes[]", parent: name, min: 1)
                try validate($0, name: "customDatatypes[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, pattern: "^[^\\r\\n]$")
            try self.header?.forEach {
                try validate($0, name: "header[]", parent: name, max: 255)
                try validate($0, name: "header[]", parent: name, min: 1)
                try validate($0, name: "header[]", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, max: 1)
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, min: 1)
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, pattern: "^[^\\r\\n]$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowSingleColumn = "AllowSingleColumn"
            case containsHeader = "ContainsHeader"
            case customDatatypeConfigured = "CustomDatatypeConfigured"
            case customDatatypes = "CustomDatatypes"
            case delimiter = "Delimiter"
            case disableValueTrimming = "DisableValueTrimming"
            case header = "Header"
            case name = "Name"
            case quoteSymbol = "QuoteSymbol"
            case serde = "Serde"
        }
    }

    public struct UpdateDataQualityRulesetRequest: AWSEncodableShape {
        /// A description of the ruleset.
        public let description: String?
        /// The name of the data quality ruleset.
        public let name: String
        /// A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer guide.
        public let ruleset: String?

        @inlinable
        public init(description: String? = nil, name: String, ruleset: String? = nil) {
            self.description = description
            self.name = name
            self.ruleset = ruleset
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.ruleset, name: "ruleset", parent: name, max: 65536)
            try self.validate(self.ruleset, name: "ruleset", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case ruleset = "Ruleset"
        }
    }

    public struct UpdateDataQualityRulesetResponse: AWSDecodableShape {
        /// A description of the ruleset.
        public let description: String?
        /// The name of the data quality ruleset.
        public let name: String?
        /// A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer guide.
        public let ruleset: String?

        @inlinable
        public init(description: String? = nil, name: String? = nil, ruleset: String? = nil) {
            self.description = description
            self.name = name
            self.ruleset = ruleset
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case ruleset = "Ruleset"
        }
    }

    public struct UpdateDatabaseRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the metadata database resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A DatabaseInput object specifying the new definition of the metadata database in the catalog.
        public let databaseInput: DatabaseInput
        /// The name of the database to update in the catalog. For Hive compatibility, this is folded to lowercase.
        public let name: String

        @inlinable
        public init(catalogId: String? = nil, databaseInput: DatabaseInput, name: String) {
            self.catalogId = catalogId
            self.databaseInput = databaseInput
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.databaseInput.validate(name: "\(name).databaseInput")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseInput = "DatabaseInput"
            case name = "Name"
        }
    }

    public struct UpdateDatabaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDevEndpointRequest: AWSEncodableShape {
        /// The map of arguments to add the map of arguments used to configure the DevEndpoint. Valid arguments are:    "--enable-glue-datacatalog": ""    You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public let addArguments: [String: String]?
        /// The list of public keys for the DevEndpoint to use.
        public let addPublicKeys: [String]?
        /// Custom Python or Java libraries to be loaded in the DevEndpoint.
        public let customLibraries: DevEndpointCustomLibraries?
        /// The list of argument keys to be deleted from the map of arguments used to configure the DevEndpoint.
        public let deleteArguments: [String]?
        /// The list of public keys to be deleted from the DevEndpoint.
        public let deletePublicKeys: [String]?
        /// The name of the DevEndpoint to be updated.
        public let endpointName: String
        /// The public key for the DevEndpoint to use.
        public let publicKey: String?
        ///  True if the list of custom libraries to be loaded in the development endpoint needs to be updated, or False if otherwise.
        public let updateEtlLibraries: Bool?

        @inlinable
        public init(addArguments: [String: String]? = nil, addPublicKeys: [String]? = nil, customLibraries: DevEndpointCustomLibraries? = nil, deleteArguments: [String]? = nil, deletePublicKeys: [String]? = nil, endpointName: String, publicKey: String? = nil, updateEtlLibraries: Bool? = nil) {
            self.addArguments = addArguments
            self.addPublicKeys = addPublicKeys
            self.customLibraries = customLibraries
            self.deleteArguments = deleteArguments
            self.deletePublicKeys = deletePublicKeys
            self.endpointName = endpointName
            self.publicKey = publicKey
            self.updateEtlLibraries = updateEtlLibraries
        }

        public func validate(name: String) throws {
            try self.validate(self.addArguments, name: "addArguments", parent: name, max: 100)
            try self.validate(self.addPublicKeys, name: "addPublicKeys", parent: name, max: 5)
            try self.validate(self.deletePublicKeys, name: "deletePublicKeys", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case addArguments = "AddArguments"
            case addPublicKeys = "AddPublicKeys"
            case customLibraries = "CustomLibraries"
            case deleteArguments = "DeleteArguments"
            case deletePublicKeys = "DeletePublicKeys"
            case endpointName = "EndpointName"
            case publicKey = "PublicKey"
            case updateEtlLibraries = "UpdateEtlLibraries"
        }
    }

    public struct UpdateDevEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGrokClassifierRequest: AWSEncodableShape {
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        public let classification: String?
        /// Optional custom grok patterns used by this classifier.
        public let customPatterns: String?
        /// The grok pattern used by this classifier.
        public let grokPattern: String?
        /// The name of the GrokClassifier.
        public let name: String

        @inlinable
        public init(classification: String? = nil, customPatterns: String? = nil, grokPattern: String? = nil, name: String) {
            self.classification = classification
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.customPatterns, name: "customPatterns", parent: name, max: 16000)
            try self.validate(self.customPatterns, name: "customPatterns", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, max: 2048)
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, min: 1)
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case customPatterns = "CustomPatterns"
            case grokPattern = "GrokPattern"
            case name = "Name"
        }
    }

    public struct UpdateIntegrationResourcePropertyRequest: AWSEncodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String
        /// The resource properties associated with the integration source.
        public let sourceProcessingProperties: SourceProcessingProperties?
        /// The resource properties associated with the integration target.
        public let targetProcessingProperties: TargetProcessingProperties?

        @inlinable
        public init(resourceArn: String, sourceProcessingProperties: SourceProcessingProperties? = nil, targetProcessingProperties: TargetProcessingProperties? = nil) {
            self.resourceArn = resourceArn
            self.sourceProcessingProperties = sourceProcessingProperties
            self.targetProcessingProperties = targetProcessingProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.sourceProcessingProperties?.validate(name: "\(name).sourceProcessingProperties")
            try self.targetProcessingProperties?.validate(name: "\(name).targetProcessingProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case sourceProcessingProperties = "SourceProcessingProperties"
            case targetProcessingProperties = "TargetProcessingProperties"
        }
    }

    public struct UpdateIntegrationResourcePropertyResponse: AWSDecodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String?
        /// The resource properties associated with the integration source.
        public let sourceProcessingProperties: SourceProcessingProperties?
        /// The resource properties associated with the integration target.
        public let targetProcessingProperties: TargetProcessingProperties?

        @inlinable
        public init(resourceArn: String? = nil, sourceProcessingProperties: SourceProcessingProperties? = nil, targetProcessingProperties: TargetProcessingProperties? = nil) {
            self.resourceArn = resourceArn
            self.sourceProcessingProperties = sourceProcessingProperties
            self.targetProcessingProperties = targetProcessingProperties
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case sourceProcessingProperties = "SourceProcessingProperties"
            case targetProcessingProperties = "TargetProcessingProperties"
        }
    }

    public struct UpdateIntegrationTablePropertiesRequest: AWSEncodableShape {
        /// The connection ARN of the source, or the database ARN of the target.
        public let resourceArn: String
        /// A structure for the source table configuration.
        public let sourceTableConfig: SourceTableConfig?
        /// The name of the table to be replicated.
        public let tableName: String
        /// A structure for the target table configuration.
        public let targetTableConfig: TargetTableConfig?

        @inlinable
        public init(resourceArn: String, sourceTableConfig: SourceTableConfig? = nil, tableName: String, targetTableConfig: TargetTableConfig? = nil) {
            self.resourceArn = resourceArn
            self.sourceTableConfig = sourceTableConfig
            self.tableName = tableName
            self.targetTableConfig = targetTableConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.sourceTableConfig?.validate(name: "\(name).sourceTableConfig")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 128)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.targetTableConfig?.validate(name: "\(name).targetTableConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case sourceTableConfig = "SourceTableConfig"
            case tableName = "TableName"
            case targetTableConfig = "TargetTableConfig"
        }
    }

    public struct UpdateIntegrationTablePropertiesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateJobFromSourceControlRequest: AWSEncodableShape {
        /// The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.
        public let authStrategy: SourceControlAuthStrategy?
        /// The value of the authorization token.
        public let authToken: String?
        /// An optional branch in the remote repository.
        public let branchName: String?
        /// A commit ID for a commit in the remote repository.
        public let commitId: String?
        /// An optional folder in the remote repository.
        public let folder: String?
        /// The name of the Glue job to be synchronized to or from the remote repository.
        public let jobName: String?
        ///  The provider for the remote repository. Possible values: GITHUB, AWS_CODE_COMMIT, GITLAB, BITBUCKET.
        public let provider: SourceControlProvider?
        /// The name of the remote repository that contains the job artifacts.  For BitBucket providers, RepositoryName should include WorkspaceName. Use the format /.
        public let repositoryName: String?
        /// The owner of the remote repository that contains the job artifacts.
        public let repositoryOwner: String?

        @inlinable
        public init(authStrategy: SourceControlAuthStrategy? = nil, authToken: String? = nil, branchName: String? = nil, commitId: String? = nil, folder: String? = nil, jobName: String? = nil, provider: SourceControlProvider? = nil, repositoryName: String? = nil, repositoryOwner: String? = nil) {
            self.authStrategy = authStrategy
            self.authToken = authToken
            self.branchName = branchName
            self.commitId = commitId
            self.folder = folder
            self.jobName = jobName
            self.provider = provider
            self.repositoryName = repositoryName
            self.repositoryOwner = repositoryOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.authToken, name: "authToken", parent: name, max: 255)
            try self.validate(self.authToken, name: "authToken", parent: name, min: 1)
            try self.validate(self.authToken, name: "authToken", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.commitId, name: "commitId", parent: name, max: 40)
            try self.validate(self.commitId, name: "commitId", parent: name, min: 1)
            try self.validate(self.commitId, name: "commitId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.folder, name: "folder", parent: name, max: 255)
            try self.validate(self.folder, name: "folder", parent: name, min: 1)
            try self.validate(self.folder, name: "folder", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 255)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.repositoryOwner, name: "repositoryOwner", parent: name, max: 255)
            try self.validate(self.repositoryOwner, name: "repositoryOwner", parent: name, min: 1)
            try self.validate(self.repositoryOwner, name: "repositoryOwner", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case authStrategy = "AuthStrategy"
            case authToken = "AuthToken"
            case branchName = "BranchName"
            case commitId = "CommitId"
            case folder = "Folder"
            case jobName = "JobName"
            case provider = "Provider"
            case repositoryName = "RepositoryName"
            case repositoryOwner = "RepositoryOwner"
        }
    }

    public struct UpdateJobFromSourceControlResponse: AWSDecodableShape {
        /// The name of the Glue job.
        public let jobName: String?

        @inlinable
        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct UpdateJobRequest: AWSEncodableShape {
        /// The name of the job definition to update.
        public let jobName: String
        /// Specifies the values with which to update the job definition. Unspecified configuration is removed or reset to default values.
        public let jobUpdate: JobUpdate

        @inlinable
        public init(jobName: String, jobUpdate: JobUpdate) {
            self.jobName = jobName
            self.jobUpdate = jobUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.jobUpdate.validate(name: "\(name).jobUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobUpdate = "JobUpdate"
        }
    }

    public struct UpdateJobResponse: AWSDecodableShape {
        /// Returns the name of the updated job definition.
        public let jobName: String?

        @inlinable
        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct UpdateJsonClassifierRequest: AWSEncodableShape {
        /// A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
        public let jsonPath: String?
        /// The name of the classifier.
        public let name: String

        @inlinable
        public init(jsonPath: String? = nil, name: String) {
            self.jsonPath = jsonPath
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case jsonPath = "JsonPath"
            case name = "Name"
        }
    }

    public struct UpdateMLTransformRequest: AWSEncodableShape {
        /// A description of the transform. The default is an empty string.
        public let description: String?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see Glue Versions in the developer guide.
        public let glueVersion: String?
        /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.  When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
        public let maxCapacity: Double?
        /// The maximum number of times to retry a task for this transform after a task run fails.
        public let maxRetries: Int?
        /// The unique name that you gave the transform when you created it.
        public let name: String?
        /// The number of workers of a defined workerType that are allocated when this task runs.
        public let numberOfWorkers: Int?
        /// The configuration parameters that are specific to the transform type (algorithm) used. Conditionally dependent on the transform type.
        public let parameters: TransformParameters?
        /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.
        public let role: String?
        /// The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?
        /// A unique identifier that was generated when the transform was created.
        public let transformId: String
        /// The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
        public let workerType: WorkerType?

        @inlinable
        public init(description: String? = nil, glueVersion: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String? = nil, numberOfWorkers: Int? = nil, parameters: TransformParameters? = nil, role: String? = nil, timeout: Int? = nil, transformId: String, workerType: WorkerType? = nil) {
            self.description = description
            self.glueVersion = glueVersion
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.numberOfWorkers = numberOfWorkers
            self.parameters = parameters
            self.role = role
            self.timeout = timeout
            self.transformId = transformId
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^(\\w+\\.)+\\w+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.parameters?.validate(name: "\(name).parameters")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case glueVersion = "GlueVersion"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case numberOfWorkers = "NumberOfWorkers"
            case parameters = "Parameters"
            case role = "Role"
            case timeout = "Timeout"
            case transformId = "TransformId"
            case workerType = "WorkerType"
        }
    }

    public struct UpdateMLTransformResponse: AWSDecodableShape {
        /// The unique identifier for the transform that was updated.
        public let transformId: String?

        @inlinable
        public init(transformId: String? = nil) {
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct UpdatePartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partition to be updated resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String
        /// The new partition object to update the partition to. The Values property can't be changed. If you want to change the partition key values for a partition, delete and recreate the partition.
        public let partitionInput: PartitionInput
        /// List of partition key values that define the partition to update.
        public let partitionValueList: [String]
        /// The name of the table in which the partition to be updated is located.
        public let tableName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, partitionInput: PartitionInput, partitionValueList: [String], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionInput = partitionInput
            self.partitionValueList = partitionValueList
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.partitionInput.validate(name: "\(name).partitionInput")
            try self.partitionValueList.forEach {
                try validate($0, name: "partitionValueList[]", parent: name, max: 1024)
                try validate($0, name: "partitionValueList[]", parent: name, min: 1)
            }
            try self.validate(self.partitionValueList, name: "partitionValueList", parent: name, max: 100)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionInput = "PartitionInput"
            case partitionValueList = "PartitionValueList"
            case tableName = "TableName"
        }
    }

    public struct UpdatePartitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRegistryInput: AWSEncodableShape {
        /// A description of the registry. If description is not provided, this field will not be updated.
        public let description: String
        /// This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
        public let registryId: RegistryId

        @inlinable
        public init(description: String, registryId: RegistryId) {
            self.description = description
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.registryId.validate(name: "\(name).registryId")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryId = "RegistryId"
        }
    }

    public struct UpdateRegistryResponse: AWSDecodableShape {
        /// The Amazon Resource name (ARN) of the updated registry.
        public let registryArn: String?
        /// The name of the updated registry.
        public let registryName: String?

        @inlinable
        public init(registryArn: String? = nil, registryName: String? = nil) {
            self.registryArn = registryArn
            self.registryName = registryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
        }
    }

    public struct UpdateSchemaInput: AWSEncodableShape {
        /// The new compatibility setting for the schema.
        public let compatibility: Compatibility?
        /// The new description for the schema.
        public let description: String?
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.   SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
        public let schemaId: SchemaId
        /// Version number required for check pointing. One of VersionNumber or Compatibility has to be provided.
        public let schemaVersionNumber: SchemaVersionNumber?

        @inlinable
        public init(compatibility: Compatibility? = nil, description: String? = nil, schemaId: SchemaId, schemaVersionNumber: SchemaVersionNumber? = nil) {
            self.compatibility = compatibility
            self.description = description
            self.schemaId = schemaId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.schemaId.validate(name: "\(name).schemaId")
            try self.schemaVersionNumber?.validate(name: "\(name).schemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case compatibility = "Compatibility"
            case description = "Description"
            case schemaId = "SchemaId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct UpdateSchemaResponse: AWSDecodableShape {
        /// The name of the registry that contains the schema.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?

        @inlinable
        public init(registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil) {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
        }

        private enum CodingKeys: String, CodingKey {
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
        }
    }

    public struct UpdateSourceControlFromJobRequest: AWSEncodableShape {
        /// The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.
        public let authStrategy: SourceControlAuthStrategy?
        /// The value of the authorization token.
        public let authToken: String?
        /// An optional branch in the remote repository.
        public let branchName: String?
        /// A commit ID for a commit in the remote repository.
        public let commitId: String?
        /// An optional folder in the remote repository.
        public let folder: String?
        /// The name of the Glue job to be synchronized to or from the remote repository.
        public let jobName: String?
        ///  The provider for the remote repository. Possible values: GITHUB, AWS_CODE_COMMIT, GITLAB, BITBUCKET.
        public let provider: SourceControlProvider?
        /// The name of the remote repository that contains the job artifacts.  For BitBucket providers, RepositoryName should include WorkspaceName. Use the format /.
        public let repositoryName: String?
        /// The owner of the remote repository that contains the job artifacts.
        public let repositoryOwner: String?

        @inlinable
        public init(authStrategy: SourceControlAuthStrategy? = nil, authToken: String? = nil, branchName: String? = nil, commitId: String? = nil, folder: String? = nil, jobName: String? = nil, provider: SourceControlProvider? = nil, repositoryName: String? = nil, repositoryOwner: String? = nil) {
            self.authStrategy = authStrategy
            self.authToken = authToken
            self.branchName = branchName
            self.commitId = commitId
            self.folder = folder
            self.jobName = jobName
            self.provider = provider
            self.repositoryName = repositoryName
            self.repositoryOwner = repositoryOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.authToken, name: "authToken", parent: name, max: 255)
            try self.validate(self.authToken, name: "authToken", parent: name, min: 1)
            try self.validate(self.authToken, name: "authToken", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.commitId, name: "commitId", parent: name, max: 40)
            try self.validate(self.commitId, name: "commitId", parent: name, min: 1)
            try self.validate(self.commitId, name: "commitId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.folder, name: "folder", parent: name, max: 255)
            try self.validate(self.folder, name: "folder", parent: name, min: 1)
            try self.validate(self.folder, name: "folder", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, max: 255)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, min: 1)
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.repositoryOwner, name: "repositoryOwner", parent: name, max: 255)
            try self.validate(self.repositoryOwner, name: "repositoryOwner", parent: name, min: 1)
            try self.validate(self.repositoryOwner, name: "repositoryOwner", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case authStrategy = "AuthStrategy"
            case authToken = "AuthToken"
            case branchName = "BranchName"
            case commitId = "CommitId"
            case folder = "Folder"
            case jobName = "JobName"
            case provider = "Provider"
            case repositoryName = "RepositoryName"
            case repositoryOwner = "RepositoryOwner"
        }
    }

    public struct UpdateSourceControlFromJobResponse: AWSDecodableShape {
        /// The name of the Glue job.
        public let jobName: String?

        @inlinable
        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct UpdateTableOptimizerRequest: AWSEncodableShape {
        /// The Catalog ID of the table.
        public let catalogId: String
        /// The name of the database in the catalog in which the table resides.
        public let databaseName: String
        /// The name of the table.
        public let tableName: String
        /// A TableOptimizerConfiguration object representing the configuration of a table optimizer.
        public let tableOptimizerConfiguration: TableOptimizerConfiguration
        /// The type of table optimizer.
        public let type: TableOptimizerType

        @inlinable
        public init(catalogId: String, databaseName: String, tableName: String, tableOptimizerConfiguration: TableOptimizerConfiguration, type: TableOptimizerType) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.tableOptimizerConfiguration = tableOptimizerConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tableOptimizerConfiguration.validate(name: "\(name).tableOptimizerConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case tableOptimizerConfiguration = "TableOptimizerConfiguration"
            case type = "Type"
        }
    }

    public struct UpdateTableOptimizerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// A flag that can be set to true to ignore matching storage descriptor and subobject matching requirements.
        public let force: Bool?
        /// By default, UpdateTable always creates an archived version of the table before updating it. However, if skipArchive is set to true, UpdateTable does not create the archived version.
        public let skipArchive: Bool?
        /// An updated TableInput object to define the metadata table in the catalog.
        public let tableInput: TableInput
        /// The transaction ID at which to update the table contents.
        public let transactionId: String?
        /// The version ID at which to update the table contents.
        public let versionId: String?
        /// The operation to be performed when updating the view.
        public let viewUpdateAction: ViewUpdateAction?

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, force: Bool? = nil, skipArchive: Bool? = nil, tableInput: TableInput, transactionId: String? = nil, versionId: String? = nil, viewUpdateAction: ViewUpdateAction? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.force = force
            self.skipArchive = skipArchive
            self.tableInput = tableInput
            self.transactionId = transactionId
            self.versionId = versionId
            self.viewUpdateAction = viewUpdateAction
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.tableInput.validate(name: "\(name).tableInput")
            try self.validate(self.transactionId, name: "transactionId", parent: name, max: 255)
            try self.validate(self.transactionId, name: "transactionId", parent: name, min: 1)
            try self.validate(self.transactionId, name: "transactionId", parent: name, pattern: "^[\\p{L}\\p{N}\\p{P}]*$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 255)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case force = "Force"
            case skipArchive = "SkipArchive"
            case tableInput = "TableInput"
            case transactionId = "TransactionId"
            case versionId = "VersionId"
            case viewUpdateAction = "ViewUpdateAction"
        }
    }

    public struct UpdateTableResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTriggerRequest: AWSEncodableShape {
        /// The name of the trigger to update.
        public let name: String
        /// The new values with which to update the trigger.
        public let triggerUpdate: TriggerUpdate

        @inlinable
        public init(name: String, triggerUpdate: TriggerUpdate) {
            self.name = name
            self.triggerUpdate = triggerUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.triggerUpdate.validate(name: "\(name).triggerUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case triggerUpdate = "TriggerUpdate"
        }
    }

    public struct UpdateTriggerResponse: AWSDecodableShape {
        /// The resulting trigger definition.
        public let trigger: Trigger?

        @inlinable
        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public struct UpdateUsageProfileRequest: AWSEncodableShape {
        /// A ProfileConfiguration object specifying the job and session values for the profile.
        public let configuration: ProfileConfiguration
        /// A description of the usage profile.
        public let description: String?
        /// The name of the usage profile.
        public let name: String

        @inlinable
        public init(configuration: ProfileConfiguration, description: String? = nil, name: String) {
            self.configuration = configuration
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateUsageProfileResponse: AWSDecodableShape {
        /// The name of the usage profile that was updated.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateUserDefinedFunctionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the function to be updated is located. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the function to be updated is located.
        public let databaseName: String
        /// A FunctionInput object that redefines the function in the Data Catalog.
        public let functionInput: UserDefinedFunctionInput
        /// The name of the function.
        public let functionName: String

        @inlinable
        public init(catalogId: String? = nil, databaseName: String, functionInput: UserDefinedFunctionInput, functionName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionInput = functionInput
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.functionInput.validate(name: "\(name).functionInput")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 255)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionInput = "FunctionInput"
            case functionName = "FunctionName"
        }
    }

    public struct UpdateUserDefinedFunctionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateWorkflowRequest: AWSEncodableShape {
        /// A collection of properties to be used as part of each execution of the workflow. Run properties may be logged. Do not pass plaintext secrets as properties. Retrieve secrets from a Glue Connection, Amazon Web Services Secrets Manager or other secret management mechanism if you intend to use them within the workflow run.
        public let defaultRunProperties: [String: String]?
        /// The description of the workflow.
        public let description: String?
        /// You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
        public let maxConcurrentRuns: Int?
        /// Name of the workflow to be updated.
        public let name: String

        @inlinable
        public init(defaultRunProperties: [String: String]? = nil, description: String? = nil, maxConcurrentRuns: Int? = nil, name: String) {
            self.defaultRunProperties = defaultRunProperties
            self.description = description
            self.maxConcurrentRuns = maxConcurrentRuns
            self.name = name
        }

        public func validate(name: String) throws {
            try self.defaultRunProperties?.forEach {
                try validate($0.key, name: "defaultRunProperties.key", parent: name, max: 255)
                try validate($0.key, name: "defaultRunProperties.key", parent: name, min: 1)
                try validate($0.key, name: "defaultRunProperties.key", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            }
            try self.validate(self.description, name: "description", parent: name, max: 120000)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultRunProperties = "DefaultRunProperties"
            case description = "Description"
            case maxConcurrentRuns = "MaxConcurrentRuns"
            case name = "Name"
        }
    }

    public struct UpdateWorkflowResponse: AWSDecodableShape {
        /// The name of the workflow which was specified in input.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateXMLClassifierRequest: AWSEncodableShape {
        /// An identifier of the data format that the classifier matches.
        public let classification: String?
        /// The name of the classifier.
        public let name: String
        /// The XML tag designating the element that contains each record in an XML document being parsed. This cannot identify a self-closing element (closed by />). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example,  is okay, but is not).
        public let rowTag: String?

        @inlinable
        public init(classification: String? = nil, name: String, rowTag: String? = nil) {
            self.classification = classification
            self.name = name
            self.rowTag = rowTag
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case name = "Name"
            case rowTag = "RowTag"
        }
    }

    public struct UpsertRedshiftTargetOptions: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection to use to write to Redshift.
        public let connectionName: String?
        /// The physical location of the Redshift table.
        public let tableLocation: String?
        /// The keys used to determine whether to perform an update or insert.
        public let upsertKeys: [String]?

        @inlinable
        public init(connectionName: String? = nil, tableLocation: String? = nil, upsertKeys: [String]? = nil) {
            self.connectionName = connectionName
            self.tableLocation = tableLocation
            self.upsertKeys = upsertKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.validate(self.tableLocation, name: "tableLocation", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            try self.upsertKeys?.forEach {
                try validate($0, name: "upsertKeys[]", parent: name, pattern: "^([\\u0009\\u000B\\u000C\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF])*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case tableLocation = "TableLocation"
            case upsertKeys = "UpsertKeys"
        }
    }

    public struct UsageProfileDefinition: AWSDecodableShape {
        /// The date and time when the usage profile was created.
        public let createdOn: Date?
        /// A description of the usage profile.
        public let description: String?
        /// The date and time when the usage profile was last modified.
        public let lastModifiedOn: Date?
        /// The name of the usage profile.
        public let name: String?

        @inlinable
        public init(createdOn: Date? = nil, description: String? = nil, lastModifiedOn: Date? = nil, name: String? = nil) {
            self.createdOn = createdOn
            self.description = description
            self.lastModifiedOn = lastModifiedOn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdOn = "CreatedOn"
            case description = "Description"
            case lastModifiedOn = "LastModifiedOn"
            case name = "Name"
        }
    }

    public struct UserDefinedFunction: AWSDecodableShape {
        /// The ID of the Data Catalog in which the function resides.
        public let catalogId: String?
        /// The Java class that contains the function code.
        public let className: String?
        /// The time at which the function was created.
        public let createTime: Date?
        /// The name of the catalog database that contains the function.
        public let databaseName: String?
        /// The name of the function.
        public let functionName: String?
        /// The owner of the function.
        public let ownerName: String?
        /// The owner type.
        public let ownerType: PrincipalType?
        /// The resource URIs for the function.
        public let resourceUris: [ResourceUri]?

        @inlinable
        public init(catalogId: String? = nil, className: String? = nil, createTime: Date? = nil, databaseName: String? = nil, functionName: String? = nil, ownerName: String? = nil, ownerType: PrincipalType? = nil, resourceUris: [ResourceUri]? = nil) {
            self.catalogId = catalogId
            self.className = className
            self.createTime = createTime
            self.databaseName = databaseName
            self.functionName = functionName
            self.ownerName = ownerName
            self.ownerType = ownerType
            self.resourceUris = resourceUris
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case className = "ClassName"
            case createTime = "CreateTime"
            case databaseName = "DatabaseName"
            case functionName = "FunctionName"
            case ownerName = "OwnerName"
            case ownerType = "OwnerType"
            case resourceUris = "ResourceUris"
        }
    }

    public struct UserDefinedFunctionInput: AWSEncodableShape {
        /// The Java class that contains the function code.
        public let className: String?
        /// The name of the function.
        public let functionName: String?
        /// The owner of the function.
        public let ownerName: String?
        /// The owner type.
        public let ownerType: PrincipalType?
        /// The resource URIs for the function.
        public let resourceUris: [ResourceUri]?

        @inlinable
        public init(className: String? = nil, functionName: String? = nil, ownerName: String? = nil, ownerType: PrincipalType? = nil, resourceUris: [ResourceUri]? = nil) {
            self.className = className
            self.functionName = functionName
            self.ownerName = ownerName
            self.ownerType = ownerType
            self.resourceUris = resourceUris
        }

        public func validate(name: String) throws {
            try self.validate(self.className, name: "className", parent: name, max: 255)
            try self.validate(self.className, name: "className", parent: name, min: 1)
            try self.validate(self.className, name: "className", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 255)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.ownerName, name: "ownerName", parent: name, max: 255)
            try self.validate(self.ownerName, name: "ownerName", parent: name, min: 1)
            try self.validate(self.ownerName, name: "ownerName", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.resourceUris?.forEach {
                try $0.validate(name: "\(name).resourceUris[]")
            }
            try self.validate(self.resourceUris, name: "resourceUris", parent: name, max: 1000)
        }

        private enum CodingKeys: String, CodingKey {
            case className = "ClassName"
            case functionName = "FunctionName"
            case ownerName = "OwnerName"
            case ownerType = "OwnerType"
            case resourceUris = "ResourceUris"
        }
    }

    public struct ViewDefinition: AWSDecodableShape {
        /// The definer of a view in SQL.
        public let definer: String?
        /// You can set this flag as true to instruct the engine not to push user-provided operations into the logical plan of the view during query planning. However, setting this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.
        public let isProtected: Bool?
        /// A list of representations.
        public let representations: [ViewRepresentation]?
        /// A list of table Amazon Resource Names (ARNs).
        public let subObjects: [String]?

        @inlinable
        public init(definer: String? = nil, isProtected: Bool? = nil, representations: [ViewRepresentation]? = nil, subObjects: [String]? = nil) {
            self.definer = definer
            self.isProtected = isProtected
            self.representations = representations
            self.subObjects = subObjects
        }

        private enum CodingKeys: String, CodingKey {
            case definer = "Definer"
            case isProtected = "IsProtected"
            case representations = "Representations"
            case subObjects = "SubObjects"
        }
    }

    public struct ViewDefinitionInput: AWSEncodableShape {
        /// The definer of a view in SQL.
        public let definer: String?
        /// You can set this flag as true to instruct the engine not to push user-provided operations into the logical plan of the view during query planning. However, setting this flag does not guarantee that the engine will comply. Refer to the engine's documentation to understand the guarantees provided, if any.
        public let isProtected: Bool?
        /// A list of structures that contains the dialect of the view, and the query that defines the view.
        public let representations: [ViewRepresentationInput]?
        /// A list of base table ARNs that make up the view.
        public let subObjects: [String]?

        @inlinable
        public init(definer: String? = nil, isProtected: Bool? = nil, representations: [ViewRepresentationInput]? = nil, subObjects: [String]? = nil) {
            self.definer = definer
            self.isProtected = isProtected
            self.representations = representations
            self.subObjects = subObjects
        }

        public func validate(name: String) throws {
            try self.validate(self.definer, name: "definer", parent: name, max: 2048)
            try self.validate(self.definer, name: "definer", parent: name, min: 20)
            try self.representations?.forEach {
                try $0.validate(name: "\(name).representations[]")
            }
            try self.validate(self.representations, name: "representations", parent: name, max: 10)
            try self.validate(self.representations, name: "representations", parent: name, min: 1)
            try self.subObjects?.forEach {
                try validate($0, name: "subObjects[]", parent: name, max: 2048)
                try validate($0, name: "subObjects[]", parent: name, min: 20)
            }
            try self.validate(self.subObjects, name: "subObjects", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case definer = "Definer"
            case isProtected = "IsProtected"
            case representations = "Representations"
            case subObjects = "SubObjects"
        }
    }

    public struct ViewRepresentation: AWSDecodableShape {
        /// The dialect of the query engine.
        public let dialect: ViewDialect?
        /// The version of the dialect of the query engine. For example, 3.0.0.
        public let dialectVersion: String?
        /// Dialects marked as stale are no longer valid and must be updated before they can be queried in their respective query engines.
        public let isStale: Bool?
        /// The name of the connection to be used to validate the specific representation of the view.
        public let validationConnection: String?
        /// The expanded SQL for the view. This SQL is used by engines while processing a query on a view. Engines may perform operations during view creation to transform ViewOriginalText to ViewExpandedText. For example:   Fully qualified identifiers: SELECT * from table1 -> SELECT * from db1.table1
        public let viewExpandedText: String?
        /// The SELECT query provided by the customer during CREATE VIEW DDL. This SQL is not used during a query on a view (ViewExpandedText is used instead). ViewOriginalText is used for cases like SHOW CREATE VIEW where users want to see the original DDL command that created the view.
        public let viewOriginalText: String?

        @inlinable
        public init(dialect: ViewDialect? = nil, dialectVersion: String? = nil, isStale: Bool? = nil, validationConnection: String? = nil, viewExpandedText: String? = nil, viewOriginalText: String? = nil) {
            self.dialect = dialect
            self.dialectVersion = dialectVersion
            self.isStale = isStale
            self.validationConnection = validationConnection
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }

        private enum CodingKeys: String, CodingKey {
            case dialect = "Dialect"
            case dialectVersion = "DialectVersion"
            case isStale = "IsStale"
            case validationConnection = "ValidationConnection"
            case viewExpandedText = "ViewExpandedText"
            case viewOriginalText = "ViewOriginalText"
        }
    }

    public struct ViewRepresentationInput: AWSEncodableShape {
        /// A parameter that specifies the engine type of a specific representation.
        public let dialect: ViewDialect?
        /// A parameter that specifies the version of the engine of a specific representation.
        public let dialectVersion: String?
        /// The name of the connection to be used to validate the specific representation of the view.
        public let validationConnection: String?
        /// A string that represents the SQL query that describes the view with expanded resource ARNs
        public let viewExpandedText: String?
        /// A string that represents the original SQL query that describes the view.
        public let viewOriginalText: String?

        @inlinable
        public init(dialect: ViewDialect? = nil, dialectVersion: String? = nil, validationConnection: String? = nil, viewExpandedText: String? = nil, viewOriginalText: String? = nil) {
            self.dialect = dialect
            self.dialectVersion = dialectVersion
            self.validationConnection = validationConnection
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }

        public func validate(name: String) throws {
            try self.validate(self.dialectVersion, name: "dialectVersion", parent: name, max: 255)
            try self.validate(self.dialectVersion, name: "dialectVersion", parent: name, min: 1)
            try self.validate(self.validationConnection, name: "validationConnection", parent: name, max: 255)
            try self.validate(self.validationConnection, name: "validationConnection", parent: name, min: 1)
            try self.validate(self.validationConnection, name: "validationConnection", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*$")
            try self.validate(self.viewExpandedText, name: "viewExpandedText", parent: name, max: 409600)
            try self.validate(self.viewOriginalText, name: "viewOriginalText", parent: name, max: 409600)
        }

        private enum CodingKeys: String, CodingKey {
            case dialect = "Dialect"
            case dialectVersion = "DialectVersion"
            case validationConnection = "ValidationConnection"
            case viewExpandedText = "ViewExpandedText"
            case viewOriginalText = "ViewOriginalText"
        }
    }

    public struct ViewValidation: AWSDecodableShape {
        /// The dialect of the query engine.
        public let dialect: ViewDialect?
        /// The version of the dialect of the query engine. For example, 3.0.0.
        public let dialectVersion: String?
        /// An error associated with the validation.
        public let error: ErrorDetail?
        /// The state of the validation.
        public let state: ResourceState?
        /// The time of the last update.
        public let updateTime: Date?
        /// The SELECT query that defines the view, as provided by the customer.
        public let viewValidationText: String?

        @inlinable
        public init(dialect: ViewDialect? = nil, dialectVersion: String? = nil, error: ErrorDetail? = nil, state: ResourceState? = nil, updateTime: Date? = nil, viewValidationText: String? = nil) {
            self.dialect = dialect
            self.dialectVersion = dialectVersion
            self.error = error
            self.state = state
            self.updateTime = updateTime
            self.viewValidationText = viewValidationText
        }

        private enum CodingKeys: String, CodingKey {
            case dialect = "Dialect"
            case dialectVersion = "DialectVersion"
            case error = "Error"
            case state = "State"
            case updateTime = "UpdateTime"
            case viewValidationText = "ViewValidationText"
        }
    }

    public struct Workflow: AWSDecodableShape {
        /// This structure indicates the details of the blueprint that this particular workflow is created from.
        public let blueprintDetails: BlueprintDetails?
        /// The date and time when the workflow was created.
        public let createdOn: Date?
        /// A collection of properties to be used as part of each execution of the workflow. The run properties are made available to each job in the workflow. A job can modify the properties for the next jobs in the flow.
        public let defaultRunProperties: [String: String]?
        /// A description of the workflow.
        public let description: String?
        /// The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.
        public let graph: WorkflowGraph?
        /// The date and time when the workflow was last modified.
        public let lastModifiedOn: Date?
        /// The information about the last execution of the workflow.
        public let lastRun: WorkflowRun?
        /// You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
        public let maxConcurrentRuns: Int?
        /// The name of the workflow.
        public let name: String?

        @inlinable
        public init(blueprintDetails: BlueprintDetails? = nil, createdOn: Date? = nil, defaultRunProperties: [String: String]? = nil, description: String? = nil, graph: WorkflowGraph? = nil, lastModifiedOn: Date? = nil, lastRun: WorkflowRun? = nil, maxConcurrentRuns: Int? = nil, name: String? = nil) {
            self.blueprintDetails = blueprintDetails
            self.createdOn = createdOn
            self.defaultRunProperties = defaultRunProperties
            self.description = description
            self.graph = graph
            self.lastModifiedOn = lastModifiedOn
            self.lastRun = lastRun
            self.maxConcurrentRuns = maxConcurrentRuns
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintDetails = "BlueprintDetails"
            case createdOn = "CreatedOn"
            case defaultRunProperties = "DefaultRunProperties"
            case description = "Description"
            case graph = "Graph"
            case lastModifiedOn = "LastModifiedOn"
            case lastRun = "LastRun"
            case maxConcurrentRuns = "MaxConcurrentRuns"
            case name = "Name"
        }
    }

    public struct WorkflowGraph: AWSDecodableShape {
        /// A list of all the directed connections between the nodes belonging to the workflow.
        public let edges: [Edge]?
        /// A list of the the Glue components belong to the workflow represented as nodes.
        public let nodes: [Node]?

        @inlinable
        public init(edges: [Edge]? = nil, nodes: [Node]? = nil) {
            self.edges = edges
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case edges = "Edges"
            case nodes = "Nodes"
        }
    }

    public struct WorkflowRun: AWSDecodableShape {
        /// The date and time when the workflow run completed.
        public let completedOn: Date?
        /// This error message describes any error that may have occurred in starting the workflow run. Currently the only error message is "Concurrent runs exceeded for workflow: foo."
        public let errorMessage: String?
        /// The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.
        public let graph: WorkflowGraph?
        /// Name of the workflow that was run.
        public let name: String?
        /// The ID of the previous workflow run.
        public let previousRunId: String?
        /// The date and time when the workflow run was started.
        public let startedOn: Date?
        /// The batch condition that started the workflow run.
        public let startingEventBatchCondition: StartingEventBatchCondition?
        /// The statistics of the run.
        public let statistics: WorkflowRunStatistics?
        /// The status of the workflow run.
        public let status: WorkflowRunStatus?
        /// The ID of this workflow run.
        public let workflowRunId: String?
        /// The workflow run properties which were set during the run.
        public let workflowRunProperties: [String: String]?

        @inlinable
        public init(completedOn: Date? = nil, errorMessage: String? = nil, graph: WorkflowGraph? = nil, name: String? = nil, previousRunId: String? = nil, startedOn: Date? = nil, startingEventBatchCondition: StartingEventBatchCondition? = nil, statistics: WorkflowRunStatistics? = nil, status: WorkflowRunStatus? = nil, workflowRunId: String? = nil, workflowRunProperties: [String: String]? = nil) {
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.graph = graph
            self.name = name
            self.previousRunId = previousRunId
            self.startedOn = startedOn
            self.startingEventBatchCondition = startingEventBatchCondition
            self.statistics = statistics
            self.status = status
            self.workflowRunId = workflowRunId
            self.workflowRunProperties = workflowRunProperties
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case errorMessage = "ErrorMessage"
            case graph = "Graph"
            case name = "Name"
            case previousRunId = "PreviousRunId"
            case startedOn = "StartedOn"
            case startingEventBatchCondition = "StartingEventBatchCondition"
            case statistics = "Statistics"
            case status = "Status"
            case workflowRunId = "WorkflowRunId"
            case workflowRunProperties = "WorkflowRunProperties"
        }
    }

    public struct WorkflowRunStatistics: AWSDecodableShape {
        /// Indicates the count of job runs in the ERROR state in the workflow run.
        public let erroredActions: Int?
        /// Total number of Actions that have failed.
        public let failedActions: Int?
        /// Total number Actions in running state.
        public let runningActions: Int?
        /// Total number of Actions that have stopped.
        public let stoppedActions: Int?
        /// Total number of Actions that have succeeded.
        public let succeededActions: Int?
        /// Total number of Actions that timed out.
        public let timeoutActions: Int?
        /// Total number of Actions in the workflow run.
        public let totalActions: Int?
        /// Indicates the count of job runs in WAITING state in the workflow run.
        public let waitingActions: Int?

        @inlinable
        public init(erroredActions: Int? = nil, failedActions: Int? = nil, runningActions: Int? = nil, stoppedActions: Int? = nil, succeededActions: Int? = nil, timeoutActions: Int? = nil, totalActions: Int? = nil, waitingActions: Int? = nil) {
            self.erroredActions = erroredActions
            self.failedActions = failedActions
            self.runningActions = runningActions
            self.stoppedActions = stoppedActions
            self.succeededActions = succeededActions
            self.timeoutActions = timeoutActions
            self.totalActions = totalActions
            self.waitingActions = waitingActions
        }

        private enum CodingKeys: String, CodingKey {
            case erroredActions = "ErroredActions"
            case failedActions = "FailedActions"
            case runningActions = "RunningActions"
            case stoppedActions = "StoppedActions"
            case succeededActions = "SucceededActions"
            case timeoutActions = "TimeoutActions"
            case totalActions = "TotalActions"
            case waitingActions = "WaitingActions"
        }
    }

    public struct XMLClassifier: AWSDecodableShape {
        /// An identifier of the data format that the classifier matches.
        public let classification: String
        /// The time that this classifier was registered.
        public let creationTime: Date?
        /// The time that this classifier was last updated.
        public let lastUpdated: Date?
        /// The name of the classifier.
        public let name: String
        /// The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by />). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example,  is okay, but is not).
        public let rowTag: String?
        /// The version of this classifier.
        public let version: Int64?

        @inlinable
        public init(classification: String, creationTime: Date? = nil, lastUpdated: Date? = nil, name: String, rowTag: String? = nil, version: Int64? = nil) {
            self.classification = classification
            self.creationTime = creationTime
            self.lastUpdated = lastUpdated
            self.name = name
            self.rowTag = rowTag
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case creationTime = "CreationTime"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case rowTag = "RowTag"
            case version = "Version"
        }
    }

    public struct TableOptimizerVpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Glue connection used for the VPC for the table optimizer.
        public let glueConnectionName: String?

        @inlinable
        public init(glueConnectionName: String? = nil) {
            self.glueConnectionName = glueConnectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.glueConnectionName, name: "glueConnectionName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case glueConnectionName = "glueConnectionName"
        }
    }
}

// MARK: - Errors

/// Error enum for Glue
public struct GlueErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case alreadyExistsException = "AlreadyExistsException"
        case columnStatisticsTaskNotRunningException = "ColumnStatisticsTaskNotRunningException"
        case columnStatisticsTaskRunningException = "ColumnStatisticsTaskRunningException"
        case columnStatisticsTaskStoppingException = "ColumnStatisticsTaskStoppingException"
        case concurrentModificationException = "ConcurrentModificationException"
        case concurrentRunsExceededException = "ConcurrentRunsExceededException"
        case conditionCheckFailureException = "ConditionCheckFailureException"
        case conflictException = "ConflictException"
        case crawlerNotRunningException = "CrawlerNotRunningException"
        case crawlerRunningException = "CrawlerRunningException"
        case crawlerStoppingException = "CrawlerStoppingException"
        case entityNotFoundException = "EntityNotFoundException"
        case federatedResourceAlreadyExistsException = "FederatedResourceAlreadyExistsException"
        case federationSourceException = "FederationSourceException"
        case federationSourceRetryableException = "FederationSourceRetryableException"
        case glueEncryptionException = "GlueEncryptionException"
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case illegalBlueprintStateException = "IllegalBlueprintStateException"
        case illegalSessionStateException = "IllegalSessionStateException"
        case illegalWorkflowStateException = "IllegalWorkflowStateException"
        case integrationConflictOperationFault = "IntegrationConflictOperationFault"
        case integrationNotFoundFault = "IntegrationNotFoundFault"
        case integrationQuotaExceededFault = "IntegrationQuotaExceededFault"
        case internalServerException = "InternalServerException"
        case internalServiceException = "InternalServiceException"
        case invalidInputException = "InvalidInputException"
        case invalidIntegrationStateFault = "InvalidIntegrationStateFault"
        case invalidStateException = "InvalidStateException"
        case kmsKeyNotAccessibleFault = "KMSKeyNotAccessibleFault"
        case mlTransformNotReadyException = "MLTransformNotReadyException"
        case noScheduleException = "NoScheduleException"
        case operationNotSupportedException = "OperationNotSupportedException"
        case operationTimeoutException = "OperationTimeoutException"
        case permissionTypeMismatchException = "PermissionTypeMismatchException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceNotReadyException = "ResourceNotReadyException"
        case resourceNumberLimitExceededException = "ResourceNumberLimitExceededException"
        case schedulerNotRunningException = "SchedulerNotRunningException"
        case schedulerRunningException = "SchedulerRunningException"
        case schedulerTransitioningException = "SchedulerTransitioningException"
        case targetResourceNotFound = "TargetResourceNotFound"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
        case versionMismatchException = "VersionMismatchException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Glue
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access to a resource was denied.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A resource to be created or added already exists.
    public static var alreadyExistsException: Self { .init(.alreadyExistsException) }
    /// An exception thrown when you try to stop a task run when there is no task running.
    public static var columnStatisticsTaskNotRunningException: Self { .init(.columnStatisticsTaskNotRunningException) }
    /// An exception thrown when you try to start another job while running a column stats generation job.
    public static var columnStatisticsTaskRunningException: Self { .init(.columnStatisticsTaskRunningException) }
    /// An exception thrown when you try to stop a task run.
    public static var columnStatisticsTaskStoppingException: Self { .init(.columnStatisticsTaskStoppingException) }
    /// Two processes are trying to modify a resource simultaneously.
    public static var concurrentModificationException: Self { .init(.concurrentModificationException) }
    /// Too many jobs are being run concurrently.
    public static var concurrentRunsExceededException: Self { .init(.concurrentRunsExceededException) }
    /// A specified condition was not satisfied.
    public static var conditionCheckFailureException: Self { .init(.conditionCheckFailureException) }
    /// The CreatePartitions API was called on a table that has indexes enabled.
    public static var conflictException: Self { .init(.conflictException) }
    /// The specified crawler is not running.
    public static var crawlerNotRunningException: Self { .init(.crawlerNotRunningException) }
    /// The operation cannot be performed because the crawler is already running.
    public static var crawlerRunningException: Self { .init(.crawlerRunningException) }
    /// The specified crawler is stopping.
    public static var crawlerStoppingException: Self { .init(.crawlerStoppingException) }
    /// A specified entity does not exist
    public static var entityNotFoundException: Self { .init(.entityNotFoundException) }
    /// A federated resource already exists.
    public static var federatedResourceAlreadyExistsException: Self { .init(.federatedResourceAlreadyExistsException) }
    /// A federation source failed.
    public static var federationSourceException: Self { .init(.federationSourceException) }
    /// A federation source failed, but the operation may be retried.
    public static var federationSourceRetryableException: Self { .init(.federationSourceRetryableException) }
    /// An encryption operation failed.
    public static var glueEncryptionException: Self { .init(.glueEncryptionException) }
    /// The same unique identifier was associated with two different records.
    public static var idempotentParameterMismatchException: Self { .init(.idempotentParameterMismatchException) }
    /// The blueprint is in an invalid state to perform a requested operation.
    public static var illegalBlueprintStateException: Self { .init(.illegalBlueprintStateException) }
    /// The session is in an invalid state to perform a requested operation.
    public static var illegalSessionStateException: Self { .init(.illegalSessionStateException) }
    /// The workflow is in an invalid state to perform a requested operation.
    public static var illegalWorkflowStateException: Self { .init(.illegalWorkflowStateException) }
    /// The requested operation conflicts with another operation.
    public static var integrationConflictOperationFault: Self { .init(.integrationConflictOperationFault) }
    /// The specified integration could not be found.
    public static var integrationNotFoundFault: Self { .init(.integrationNotFoundFault) }
    /// The data processed through your integration exceeded your quota.
    public static var integrationQuotaExceededFault: Self { .init(.integrationQuotaExceededFault) }
    /// An internal server error occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// An internal service error occurred.
    public static var internalServiceException: Self { .init(.internalServiceException) }
    /// The input provided was not valid.
    public static var invalidInputException: Self { .init(.invalidInputException) }
    /// The integration is in an invalid state.
    public static var invalidIntegrationStateFault: Self { .init(.invalidIntegrationStateFault) }
    /// An error that indicates your data is in an invalid state.
    public static var invalidStateException: Self { .init(.invalidStateException) }
    /// The KMS key specified is not accessible.
    public static var kmsKeyNotAccessibleFault: Self { .init(.kmsKeyNotAccessibleFault) }
    /// The machine learning transform is not ready to run.
    public static var mlTransformNotReadyException: Self { .init(.mlTransformNotReadyException) }
    /// There is no applicable schedule.
    public static var noScheduleException: Self { .init(.noScheduleException) }
    /// The operation is not available in the region.
    public static var operationNotSupportedException: Self { .init(.operationNotSupportedException) }
    /// The operation timed out.
    public static var operationTimeoutException: Self { .init(.operationTimeoutException) }
    /// The operation timed out.
    public static var permissionTypeMismatchException: Self { .init(.permissionTypeMismatchException) }
    /// The resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// A resource was not ready for a transaction.
    public static var resourceNotReadyException: Self { .init(.resourceNotReadyException) }
    /// A resource numerical limit was exceeded.
    public static var resourceNumberLimitExceededException: Self { .init(.resourceNumberLimitExceededException) }
    /// The specified scheduler is not running.
    public static var schedulerNotRunningException: Self { .init(.schedulerNotRunningException) }
    /// The specified scheduler is already running.
    public static var schedulerRunningException: Self { .init(.schedulerRunningException) }
    /// The specified scheduler is transitioning.
    public static var schedulerTransitioningException: Self { .init(.schedulerTransitioningException) }
    /// The target resource could not be found.
    public static var targetResourceNotFound: Self { .init(.targetResourceNotFound) }
    /// The throttling threshhold was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// A value could not be validated.
    public static var validationException: Self { .init(.validationException) }
    /// There was a version conflict.
    public static var versionMismatchException: Self { .init(.versionMismatchException) }
}

extension GlueErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "EntityNotFoundException": Glue.EntityNotFoundException.self,
        "FederatedResourceAlreadyExistsException": Glue.FederatedResourceAlreadyExistsException.self,
        "FederationSourceException": Glue.FederationSourceException.self,
        "InvalidInputException": Glue.InvalidInputException.self
    ]
}

extension GlueErrorType: Equatable {
    public static func == (lhs: GlueErrorType, rhs: GlueErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GlueErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
