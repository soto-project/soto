//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Glue service.
///
/// Glue Defines the public endpoint for the Glue service.
public struct Glue: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Glue client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "AWSGlue",
            serviceName: "Glue",
            serviceIdentifier: "glue",
            serviceProtocol: .json(version: "1.1"),
            apiVersion: "2017-03-31",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: GlueErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.dualstack]: .init(endpoints: [
            "us-gov-east-1": "glue.us-gov-east-1.api.aws",
            "us-gov-west-1": "glue.us-gov-west-1.api.aws"
        ]),
        [.dualstack, .fips]: .init(endpoints: [
            "us-gov-east-1": "glue-fips.us-gov-east-1.api.aws",
            "us-gov-west-1": "glue-fips.us-gov-west-1.api.aws"
        ]),
        [.fips]: .init(endpoints: [
            "us-east-1": "glue-fips.us-east-1.amazonaws.com",
            "us-east-2": "glue-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "glue-fips.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "glue-fips.us-gov-west-1.amazonaws.com",
            "us-west-1": "glue-fips.us-west-1.amazonaws.com",
            "us-west-2": "glue-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Creates one or more partitions in a batch operation.
    @Sendable
    @inlinable
    public func batchCreatePartition(_ input: BatchCreatePartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchCreatePartitionResponse {
        try await self.client.execute(
            operation: "BatchCreatePartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates one or more partitions in a batch operation.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the catalog in which the partition is to be created. Currently, this should be the Amazon Web Services account ID.
    ///   - databaseName: The name of the metadata database in which the partition is to be created.
    ///   - partitionInputList: A list of PartitionInput structures that define the partitions to be created.
    ///   - tableName: The name of the metadata table in which the partition is to be created.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchCreatePartition(
        catalogId: String? = nil,
        databaseName: String,
        partitionInputList: [PartitionInput],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchCreatePartitionResponse {
        let input = BatchCreatePartitionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            partitionInputList: partitionInputList, 
            tableName: tableName
        )
        return try await self.batchCreatePartition(input, logger: logger)
    }

    /// Deletes a list of connection definitions from the Data Catalog.
    @Sendable
    @inlinable
    public func batchDeleteConnection(_ input: BatchDeleteConnectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteConnectionResponse {
        try await self.client.execute(
            operation: "BatchDeleteConnection", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a list of connection definitions from the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - connectionNameList: A list of names of the connections to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteConnection(
        catalogId: String? = nil,
        connectionNameList: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteConnectionResponse {
        let input = BatchDeleteConnectionRequest(
            catalogId: catalogId, 
            connectionNameList: connectionNameList
        )
        return try await self.batchDeleteConnection(input, logger: logger)
    }

    /// Deletes one or more partitions in a batch operation.
    @Sendable
    @inlinable
    public func batchDeletePartition(_ input: BatchDeletePartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeletePartitionResponse {
        try await self.client.execute(
            operation: "BatchDeletePartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes one or more partitions in a batch operation.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partition to be deleted resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database in which the table in question resides.
    ///   - partitionsToDelete: A list of PartitionInput structures that define the partitions to be deleted.
    ///   - tableName: The name of the table that contains the partitions to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeletePartition(
        catalogId: String? = nil,
        databaseName: String,
        partitionsToDelete: [PartitionValueList],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeletePartitionResponse {
        let input = BatchDeletePartitionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            partitionsToDelete: partitionsToDelete, 
            tableName: tableName
        )
        return try await self.batchDeletePartition(input, logger: logger)
    }

    /// Deletes multiple tables at once.  After completing this operation, you no longer have access to the table versions and partitions that belong to the deleted table. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources, before calling BatchDeleteTable, use DeleteTableVersion or BatchDeleteTableVersion, and DeletePartition or BatchDeletePartition, to delete any resources that belong to the table.
    @Sendable
    @inlinable
    public func batchDeleteTable(_ input: BatchDeleteTableRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteTableResponse {
        try await self.client.execute(
            operation: "BatchDeleteTable", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes multiple tables at once.  After completing this operation, you no longer have access to the table versions and partitions that belong to the deleted table. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources, before calling BatchDeleteTable, use DeleteTableVersion or BatchDeleteTableVersion, and DeletePartition or BatchDeletePartition, to delete any resources that belong to the table.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database in which the tables to delete reside. For Hive compatibility, this name is entirely lowercase.
    ///   - tablesToDelete: A list of the table to delete.
    ///   - transactionId: The transaction ID at which to delete the table contents.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteTable(
        catalogId: String? = nil,
        databaseName: String,
        tablesToDelete: [String],
        transactionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteTableResponse {
        let input = BatchDeleteTableRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            tablesToDelete: tablesToDelete, 
            transactionId: transactionId
        )
        return try await self.batchDeleteTable(input, logger: logger)
    }

    /// Deletes a specified batch of versions of a table.
    @Sendable
    @inlinable
    public func batchDeleteTableVersion(_ input: BatchDeleteTableVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteTableVersionResponse {
        try await self.client.execute(
            operation: "BatchDeleteTableVersion", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specified batch of versions of a table.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    ///   - tableName: The name of the table. For Hive compatibility,  this name is entirely lowercase.
    ///   - versionIds: A list of the IDs of versions to be deleted. A VersionId is a string representation of an integer. Each version is incremented by 1.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteTableVersion(
        catalogId: String? = nil,
        databaseName: String,
        tableName: String,
        versionIds: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteTableVersionResponse {
        let input = BatchDeleteTableVersionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            tableName: tableName, 
            versionIds: versionIds
        )
        return try await self.batchDeleteTableVersion(input, logger: logger)
    }

    /// Retrieves information about a list of blueprints.
    @Sendable
    @inlinable
    public func batchGetBlueprints(_ input: BatchGetBlueprintsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetBlueprintsResponse {
        try await self.client.execute(
            operation: "BatchGetBlueprints", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a list of blueprints.
    ///
    /// Parameters:
    ///   - includeBlueprint: Specifies whether or not to include the blueprint in the response.
    ///   - includeParameterSpec: Specifies whether or not to include the parameters, as a JSON string, for the blueprint in the response.
    ///   - names: A list of blueprint names.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetBlueprints(
        includeBlueprint: Bool? = nil,
        includeParameterSpec: Bool? = nil,
        names: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetBlueprintsResponse {
        let input = BatchGetBlueprintsRequest(
            includeBlueprint: includeBlueprint, 
            includeParameterSpec: includeParameterSpec, 
            names: names
        )
        return try await self.batchGetBlueprints(input, logger: logger)
    }

    /// Returns a list of resource metadata for a given list of crawler names. After calling the ListCrawlers operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    @Sendable
    @inlinable
    public func batchGetCrawlers(_ input: BatchGetCrawlersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetCrawlersResponse {
        try await self.client.execute(
            operation: "BatchGetCrawlers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of resource metadata for a given list of crawler names. After calling the ListCrawlers operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    ///
    /// Parameters:
    ///   - crawlerNames: A list of crawler names, which might be the names returned from the ListCrawlers operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetCrawlers(
        crawlerNames: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetCrawlersResponse {
        let input = BatchGetCrawlersRequest(
            crawlerNames: crawlerNames
        )
        return try await self.batchGetCrawlers(input, logger: logger)
    }

    /// Retrieves the details for the custom patterns specified by a list of names.
    @Sendable
    @inlinable
    public func batchGetCustomEntityTypes(_ input: BatchGetCustomEntityTypesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetCustomEntityTypesResponse {
        try await self.client.execute(
            operation: "BatchGetCustomEntityTypes", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the details for the custom patterns specified by a list of names.
    ///
    /// Parameters:
    ///   - names: A list of names of the custom patterns that you want to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetCustomEntityTypes(
        names: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetCustomEntityTypesResponse {
        let input = BatchGetCustomEntityTypesRequest(
            names: names
        )
        return try await self.batchGetCustomEntityTypes(input, logger: logger)
    }

    /// Retrieves a list of data quality results for the specified result IDs.
    @Sendable
    @inlinable
    public func batchGetDataQualityResult(_ input: BatchGetDataQualityResultRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetDataQualityResultResponse {
        try await self.client.execute(
            operation: "BatchGetDataQualityResult", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of data quality results for the specified result IDs.
    ///
    /// Parameters:
    ///   - resultIds: A list of unique result IDs for the data quality results.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetDataQualityResult(
        resultIds: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetDataQualityResultResponse {
        let input = BatchGetDataQualityResultRequest(
            resultIds: resultIds
        )
        return try await self.batchGetDataQualityResult(input, logger: logger)
    }

    /// Returns a list of resource metadata for a given list of development endpoint names. After calling the ListDevEndpoints operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    @Sendable
    @inlinable
    public func batchGetDevEndpoints(_ input: BatchGetDevEndpointsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetDevEndpointsResponse {
        try await self.client.execute(
            operation: "BatchGetDevEndpoints", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of resource metadata for a given list of development endpoint names. After calling the ListDevEndpoints operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    ///
    /// Parameters:
    ///   - devEndpointNames: The list of DevEndpoint names, which might be the names returned from the ListDevEndpoint operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetDevEndpoints(
        devEndpointNames: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetDevEndpointsResponse {
        let input = BatchGetDevEndpointsRequest(
            devEndpointNames: devEndpointNames
        )
        return try await self.batchGetDevEndpoints(input, logger: logger)
    }

    /// Returns a list of resource metadata for a given list of job names. After calling the ListJobs operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    @Sendable
    @inlinable
    public func batchGetJobs(_ input: BatchGetJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetJobsResponse {
        try await self.client.execute(
            operation: "BatchGetJobs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of resource metadata for a given list of job names. After calling the ListJobs operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    ///
    /// Parameters:
    ///   - jobNames: A list of job names, which might be the names returned from the ListJobs operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetJobs(
        jobNames: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetJobsResponse {
        let input = BatchGetJobsRequest(
            jobNames: jobNames
        )
        return try await self.batchGetJobs(input, logger: logger)
    }

    /// Retrieves partitions in a batch request.
    @Sendable
    @inlinable
    public func batchGetPartition(_ input: BatchGetPartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetPartitionResponse {
        try await self.client.execute(
            operation: "BatchGetPartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves partitions in a batch request.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - partitionsToGet: A list of partition values identifying the partitions to retrieve.
    ///   - tableName: The name of the partitions' table.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetPartition(
        catalogId: String? = nil,
        databaseName: String,
        partitionsToGet: [PartitionValueList],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetPartitionResponse {
        let input = BatchGetPartitionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            partitionsToGet: partitionsToGet, 
            tableName: tableName
        )
        return try await self.batchGetPartition(input, logger: logger)
    }

    /// Returns the configuration for the specified table optimizers.
    @Sendable
    @inlinable
    public func batchGetTableOptimizer(_ input: BatchGetTableOptimizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetTableOptimizerResponse {
        try await self.client.execute(
            operation: "BatchGetTableOptimizer", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the configuration for the specified table optimizers.
    ///
    /// Parameters:
    ///   - entries: A list of BatchGetTableOptimizerEntry objects specifying the table optimizers to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetTableOptimizer(
        entries: [BatchGetTableOptimizerEntry],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetTableOptimizerResponse {
        let input = BatchGetTableOptimizerRequest(
            entries: entries
        )
        return try await self.batchGetTableOptimizer(input, logger: logger)
    }

    /// Returns a list of resource metadata for a given list of trigger names. After calling the ListTriggers operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    @Sendable
    @inlinable
    public func batchGetTriggers(_ input: BatchGetTriggersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetTriggersResponse {
        try await self.client.execute(
            operation: "BatchGetTriggers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of resource metadata for a given list of trigger names. After calling the ListTriggers operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    ///
    /// Parameters:
    ///   - triggerNames: A list of trigger names, which may be the names returned from the ListTriggers operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetTriggers(
        triggerNames: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetTriggersResponse {
        let input = BatchGetTriggersRequest(
            triggerNames: triggerNames
        )
        return try await self.batchGetTriggers(input, logger: logger)
    }

    /// Returns a list of resource metadata for a given list of workflow names. After calling the ListWorkflows operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    @Sendable
    @inlinable
    public func batchGetWorkflows(_ input: BatchGetWorkflowsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetWorkflowsResponse {
        try await self.client.execute(
            operation: "BatchGetWorkflows", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of resource metadata for a given list of workflow names. After calling the ListWorkflows operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
    ///
    /// Parameters:
    ///   - includeGraph: Specifies whether to include a graph when returning the workflow resource metadata.
    ///   - names: A list of workflow names, which may be the names returned from the ListWorkflows operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetWorkflows(
        includeGraph: Bool? = nil,
        names: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetWorkflowsResponse {
        let input = BatchGetWorkflowsRequest(
            includeGraph: includeGraph, 
            names: names
        )
        return try await self.batchGetWorkflows(input, logger: logger)
    }

    /// Annotate datapoints over time for a specific data quality statistic.
    @Sendable
    @inlinable
    public func batchPutDataQualityStatisticAnnotation(_ input: BatchPutDataQualityStatisticAnnotationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchPutDataQualityStatisticAnnotationResponse {
        try await self.client.execute(
            operation: "BatchPutDataQualityStatisticAnnotation", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Annotate datapoints over time for a specific data quality statistic.
    ///
    /// Parameters:
    ///   - clientToken: Client Token.
    ///   - inclusionAnnotations: A list of DatapointInclusionAnnotation's.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchPutDataQualityStatisticAnnotation(
        clientToken: String? = nil,
        inclusionAnnotations: [DatapointInclusionAnnotation],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchPutDataQualityStatisticAnnotationResponse {
        let input = BatchPutDataQualityStatisticAnnotationRequest(
            clientToken: clientToken, 
            inclusionAnnotations: inclusionAnnotations
        )
        return try await self.batchPutDataQualityStatisticAnnotation(input, logger: logger)
    }

    /// Stops one or more job runs for a specified job definition.
    @Sendable
    @inlinable
    public func batchStopJobRun(_ input: BatchStopJobRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchStopJobRunResponse {
        try await self.client.execute(
            operation: "BatchStopJobRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops one or more job runs for a specified job definition.
    ///
    /// Parameters:
    ///   - jobName: The name of the job definition for which to stop job runs.
    ///   - jobRunIds: A list of the JobRunIds that should be stopped for that job definition.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchStopJobRun(
        jobName: String,
        jobRunIds: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchStopJobRunResponse {
        let input = BatchStopJobRunRequest(
            jobName: jobName, 
            jobRunIds: jobRunIds
        )
        return try await self.batchStopJobRun(input, logger: logger)
    }

    /// Updates one or more partitions in a batch operation.
    @Sendable
    @inlinable
    public func batchUpdatePartition(_ input: BatchUpdatePartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdatePartitionResponse {
        try await self.client.execute(
            operation: "BatchUpdatePartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates one or more partitions in a batch operation.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the catalog in which the partition is to be updated. Currently, this should be the Amazon Web Services account ID.
    ///   - databaseName: The name of the metadata database in which the partition is to be updated.
    ///   - entries: A list of up to 100 BatchUpdatePartitionRequestEntry objects to update.
    ///   - tableName: The name of the metadata table in which the partition is to be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdatePartition(
        catalogId: String? = nil,
        databaseName: String,
        entries: [BatchUpdatePartitionRequestEntry],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdatePartitionResponse {
        let input = BatchUpdatePartitionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            entries: entries, 
            tableName: tableName
        )
        return try await self.batchUpdatePartition(input, logger: logger)
    }

    /// Cancels the specified recommendation run that was being used to generate rules.
    @Sendable
    @inlinable
    public func cancelDataQualityRuleRecommendationRun(_ input: CancelDataQualityRuleRecommendationRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelDataQualityRuleRecommendationRunResponse {
        try await self.client.execute(
            operation: "CancelDataQualityRuleRecommendationRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels the specified recommendation run that was being used to generate rules.
    ///
    /// Parameters:
    ///   - runId: The unique run identifier associated with this run.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelDataQualityRuleRecommendationRun(
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelDataQualityRuleRecommendationRunResponse {
        let input = CancelDataQualityRuleRecommendationRunRequest(
            runId: runId
        )
        return try await self.cancelDataQualityRuleRecommendationRun(input, logger: logger)
    }

    /// Cancels a run where a ruleset is being evaluated against a data source.
    @Sendable
    @inlinable
    public func cancelDataQualityRulesetEvaluationRun(_ input: CancelDataQualityRulesetEvaluationRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelDataQualityRulesetEvaluationRunResponse {
        try await self.client.execute(
            operation: "CancelDataQualityRulesetEvaluationRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels a run where a ruleset is being evaluated against a data source.
    ///
    /// Parameters:
    ///   - runId: The unique run identifier associated with this run.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelDataQualityRulesetEvaluationRun(
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelDataQualityRulesetEvaluationRunResponse {
        let input = CancelDataQualityRulesetEvaluationRunRequest(
            runId: runId
        )
        return try await self.cancelDataQualityRulesetEvaluationRun(input, logger: logger)
    }

    /// Cancels (stops) a task run. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can cancel a machine learning task run at any time by calling CancelMLTaskRun with a task run's parent transform's TransformID and the task run's TaskRunId.
    @Sendable
    @inlinable
    public func cancelMLTaskRun(_ input: CancelMLTaskRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelMLTaskRunResponse {
        try await self.client.execute(
            operation: "CancelMLTaskRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels (stops) a task run. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can cancel a machine learning task run at any time by calling CancelMLTaskRun with a task run's parent transform's TransformID and the task run's TaskRunId.
    ///
    /// Parameters:
    ///   - taskRunId: A unique identifier for the task run.
    ///   - transformId: The unique identifier of the machine learning transform.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelMLTaskRun(
        taskRunId: String,
        transformId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelMLTaskRunResponse {
        let input = CancelMLTaskRunRequest(
            taskRunId: taskRunId, 
            transformId: transformId
        )
        return try await self.cancelMLTaskRun(input, logger: logger)
    }

    /// Cancels the statement.
    @Sendable
    @inlinable
    public func cancelStatement(_ input: CancelStatementRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelStatementResponse {
        try await self.client.execute(
            operation: "CancelStatement", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels the statement.
    ///
    /// Parameters:
    ///   - id: The ID of the statement to be cancelled.
    ///   - requestOrigin: The origin of the request to cancel the statement.
    ///   - sessionId: The Session ID of the statement to be cancelled.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelStatement(
        id: Int = 0,
        requestOrigin: String? = nil,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelStatementResponse {
        let input = CancelStatementRequest(
            id: id, 
            requestOrigin: requestOrigin, 
            sessionId: sessionId
        )
        return try await self.cancelStatement(input, logger: logger)
    }

    /// Validates the supplied schema. This call has no side effects, it simply validates using the supplied schema using DataFormat as the format. Since it does not take a schema set name, no compatibility checks are performed.
    @Sendable
    @inlinable
    public func checkSchemaVersionValidity(_ input: CheckSchemaVersionValidityInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CheckSchemaVersionValidityResponse {
        try await self.client.execute(
            operation: "CheckSchemaVersionValidity", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Validates the supplied schema. This call has no side effects, it simply validates using the supplied schema using DataFormat as the format. Since it does not take a schema set name, no compatibility checks are performed.
    ///
    /// Parameters:
    ///   - dataFormat: The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
    ///   - schemaDefinition: The definition of the schema that has to be validated.
    ///   - logger: Logger use during operation
    @inlinable
    public func checkSchemaVersionValidity(
        dataFormat: DataFormat,
        schemaDefinition: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CheckSchemaVersionValidityResponse {
        let input = CheckSchemaVersionValidityInput(
            dataFormat: dataFormat, 
            schemaDefinition: schemaDefinition
        )
        return try await self.checkSchemaVersionValidity(input, logger: logger)
    }

    /// Registers a blueprint with Glue.
    @Sendable
    @inlinable
    public func createBlueprint(_ input: CreateBlueprintRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBlueprintResponse {
        try await self.client.execute(
            operation: "CreateBlueprint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Registers a blueprint with Glue.
    ///
    /// Parameters:
    ///   - blueprintLocation: Specifies a path in Amazon S3 where the blueprint is published.
    ///   - description: A description of the blueprint.
    ///   - name: The name of the blueprint.
    ///   - tags: The tags to be applied to this blueprint.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBlueprint(
        blueprintLocation: String,
        description: String? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBlueprintResponse {
        let input = CreateBlueprintRequest(
            blueprintLocation: blueprintLocation, 
            description: description, 
            name: name, 
            tags: tags
        )
        return try await self.createBlueprint(input, logger: logger)
    }

    /// Creates a new catalog in the Glue Data Catalog.
    @Sendable
    @inlinable
    public func createCatalog(_ input: CreateCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCatalogResponse {
        try await self.client.execute(
            operation: "CreateCatalog", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new catalog in the Glue Data Catalog.
    ///
    /// Parameters:
    ///   - catalogInput: A CatalogInput object that defines the metadata for the catalog.
    ///   - name: The name of the catalog to create.
    ///   - tags: A map array of key-value pairs, not more than 50 pairs. Each key is a UTF-8 string, not less than 1 or more than 128 bytes long. Each value is a UTF-8 string, not more than 256 bytes long. The tags you assign to the catalog.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCatalog(
        catalogInput: CatalogInput,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCatalogResponse {
        let input = CreateCatalogRequest(
            catalogInput: catalogInput, 
            name: name, 
            tags: tags
        )
        return try await self.createCatalog(input, logger: logger)
    }

    /// Creates a classifier in the user's account. This can be a GrokClassifier, an XMLClassifier, a JsonClassifier, or a CsvClassifier, depending on which field of the request is present.
    @Sendable
    @inlinable
    public func createClassifier(_ input: CreateClassifierRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateClassifierResponse {
        try await self.client.execute(
            operation: "CreateClassifier", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a classifier in the user's account. This can be a GrokClassifier, an XMLClassifier, a JsonClassifier, or a CsvClassifier, depending on which field of the request is present.
    ///
    /// Parameters:
    ///   - csvClassifier: A CsvClassifier object specifying the classifier to create.
    ///   - grokClassifier: A GrokClassifier object specifying the classifier to create.
    ///   - jsonClassifier: A JsonClassifier object specifying the classifier to create.
    ///   - xmlClassifier: An XMLClassifier object specifying the classifier to create.
    ///   - logger: Logger use during operation
    @inlinable
    public func createClassifier(
        csvClassifier: CreateCsvClassifierRequest? = nil,
        grokClassifier: CreateGrokClassifierRequest? = nil,
        jsonClassifier: CreateJsonClassifierRequest? = nil,
        xmlClassifier: CreateXMLClassifierRequest? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateClassifierResponse {
        let input = CreateClassifierRequest(
            csvClassifier: csvClassifier, 
            grokClassifier: grokClassifier, 
            jsonClassifier: jsonClassifier, 
            xmlClassifier: xmlClassifier
        )
        return try await self.createClassifier(input, logger: logger)
    }

    /// Creates settings for a column statistics task.
    @Sendable
    @inlinable
    public func createColumnStatisticsTaskSettings(_ input: CreateColumnStatisticsTaskSettingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateColumnStatisticsTaskSettingsResponse {
        try await self.client.execute(
            operation: "CreateColumnStatisticsTaskSettings", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates settings for a column statistics task.
    ///
    /// Parameters:
    ///   - catalogID: The ID of the Data Catalog in which the database resides.
    ///   - columnNameList: A list of column names for which to run statistics.
    ///   - databaseName: The name of the database where the table resides.
    ///   - role: The role used for running the column statistics.
    ///   - sampleSize: The percentage of data to sample.
    ///   - schedule: A schedule for running the column statistics, specified in CRON syntax.
    ///   - securityConfiguration: Name of the security configuration that is used to encrypt CloudWatch logs.
    ///   - tableName: The name of the table for which to generate column statistics.
    ///   - tags: A map of tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func createColumnStatisticsTaskSettings(
        catalogID: String? = nil,
        columnNameList: [String]? = nil,
        databaseName: String,
        role: String,
        sampleSize: Double? = nil,
        schedule: String? = nil,
        securityConfiguration: String? = nil,
        tableName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateColumnStatisticsTaskSettingsResponse {
        let input = CreateColumnStatisticsTaskSettingsRequest(
            catalogID: catalogID, 
            columnNameList: columnNameList, 
            databaseName: databaseName, 
            role: role, 
            sampleSize: sampleSize, 
            schedule: schedule, 
            securityConfiguration: securityConfiguration, 
            tableName: tableName, 
            tags: tags
        )
        return try await self.createColumnStatisticsTaskSettings(input, logger: logger)
    }

    /// Creates a connection definition in the Data Catalog. Connections used for creating federated resources require the IAM glue:PassConnection permission.
    @Sendable
    @inlinable
    public func createConnection(_ input: CreateConnectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateConnectionResponse {
        try await self.client.execute(
            operation: "CreateConnection", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a connection definition in the Data Catalog. Connections used for creating federated resources require the IAM glue:PassConnection permission.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which to create the connection. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - connectionInput: A ConnectionInput object defining the connection to create.
    ///   - tags: The tags you assign to the connection.
    ///   - logger: Logger use during operation
    @inlinable
    public func createConnection(
        catalogId: String? = nil,
        connectionInput: ConnectionInput,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateConnectionResponse {
        let input = CreateConnectionRequest(
            catalogId: catalogId, 
            connectionInput: connectionInput, 
            tags: tags
        )
        return try await self.createConnection(input, logger: logger)
    }

    /// Creates a new crawler with specified targets, role, configuration, and optional schedule. At least one crawl target must be specified, in the s3Targets field, the jdbcTargets field, or the DynamoDBTargets field.
    @Sendable
    @inlinable
    public func createCrawler(_ input: CreateCrawlerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCrawlerResponse {
        try await self.client.execute(
            operation: "CreateCrawler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new crawler with specified targets, role, configuration, and optional schedule. At least one crawl target must be specified, in the s3Targets field, the jdbcTargets field, or the DynamoDBTargets field.
    ///
    /// Parameters:
    ///   - classifiers: A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
    ///   - configuration: Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Setting crawler configuration options.
    ///   - crawlerSecurityConfiguration: The name of the SecurityConfiguration structure to be used by this crawler.
    ///   - databaseName: The Glue database where results are written, such as: arn:aws:daylight:us-east-1::database/sometable/*.
    ///   - description: A description of the new crawler.
    ///   - lakeFormationConfiguration: Specifies Lake Formation configuration settings for the crawler.
    ///   - lineageConfiguration: Specifies data lineage configuration settings for the crawler.
    ///   - name: Name of the new crawler.
    ///   - recrawlPolicy: A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
    ///   - role: The IAM role or Amazon Resource Name (ARN) of an IAM role used by the new crawler to access customer resources.
    ///   - schedule: A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
    ///   - schemaChangePolicy: The policy for the crawler's update and deletion behavior.
    ///   - tablePrefix: The table prefix used for catalog tables that are created.
    ///   - tags: The tags to use with this crawler request. You may use tags to limit access to the crawler. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
    ///   - targets: A list of collection of targets to crawl.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCrawler(
        classifiers: [String]? = nil,
        configuration: String? = nil,
        crawlerSecurityConfiguration: String? = nil,
        databaseName: String? = nil,
        description: String? = nil,
        lakeFormationConfiguration: LakeFormationConfiguration? = nil,
        lineageConfiguration: LineageConfiguration? = nil,
        name: String,
        recrawlPolicy: RecrawlPolicy? = nil,
        role: String,
        schedule: String? = nil,
        schemaChangePolicy: SchemaChangePolicy? = nil,
        tablePrefix: String? = nil,
        tags: [String: String]? = nil,
        targets: CrawlerTargets,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCrawlerResponse {
        let input = CreateCrawlerRequest(
            classifiers: classifiers, 
            configuration: configuration, 
            crawlerSecurityConfiguration: crawlerSecurityConfiguration, 
            databaseName: databaseName, 
            description: description, 
            lakeFormationConfiguration: lakeFormationConfiguration, 
            lineageConfiguration: lineageConfiguration, 
            name: name, 
            recrawlPolicy: recrawlPolicy, 
            role: role, 
            schedule: schedule, 
            schemaChangePolicy: schemaChangePolicy, 
            tablePrefix: tablePrefix, 
            tags: tags, 
            targets: targets
        )
        return try await self.createCrawler(input, logger: logger)
    }

    /// Creates a custom pattern that is used to detect sensitive data across the columns and rows of your structured data. Each custom pattern you create specifies a regular expression and an optional list of context words. If no context words are passed only a regular expression is checked.
    @Sendable
    @inlinable
    public func createCustomEntityType(_ input: CreateCustomEntityTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCustomEntityTypeResponse {
        try await self.client.execute(
            operation: "CreateCustomEntityType", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a custom pattern that is used to detect sensitive data across the columns and rows of your structured data. Each custom pattern you create specifies a regular expression and an optional list of context words. If no context words are passed only a regular expression is checked.
    ///
    /// Parameters:
    ///   - contextWords: A list of context words. If none of these context words are found within the vicinity of the regular expression the data will not be detected as sensitive data. If no context words are passed only a regular expression is checked.
    ///   - name: A name for the custom pattern that allows it to be retrieved or deleted later. This name must be unique per Amazon Web Services account.
    ///   - regexString: A regular expression string that is used for detecting sensitive data in a custom pattern.
    ///   - tags: A list of tags applied to the custom entity type.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCustomEntityType(
        contextWords: [String]? = nil,
        name: String,
        regexString: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCustomEntityTypeResponse {
        let input = CreateCustomEntityTypeRequest(
            contextWords: contextWords, 
            name: name, 
            regexString: regexString, 
            tags: tags
        )
        return try await self.createCustomEntityType(input, logger: logger)
    }

    /// Creates a data quality ruleset with DQDL rules applied to a specified Glue table. You create the ruleset using the Data Quality Definition Language (DQDL). For more information, see the Glue developer guide.
    @Sendable
    @inlinable
    public func createDataQualityRuleset(_ input: CreateDataQualityRulesetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDataQualityRulesetResponse {
        try await self.client.execute(
            operation: "CreateDataQualityRuleset", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a data quality ruleset with DQDL rules applied to a specified Glue table. You create the ruleset using the Data Quality Definition Language (DQDL). For more information, see the Glue developer guide.
    ///
    /// Parameters:
    ///   - clientToken: Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.
    ///   - dataQualitySecurityConfiguration: The name of the security configuration created with the data quality encryption option.
    ///   - description: A description of the data quality ruleset.
    ///   - name: A unique name for the data quality ruleset.
    ///   - ruleset: A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer guide.
    ///   - tags: A list of tags applied to the data quality ruleset.
    ///   - targetTable: A target table associated with the data quality ruleset.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDataQualityRuleset(
        clientToken: String? = nil,
        dataQualitySecurityConfiguration: String? = nil,
        description: String? = nil,
        name: String,
        ruleset: String,
        tags: [String: String]? = nil,
        targetTable: DataQualityTargetTable? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDataQualityRulesetResponse {
        let input = CreateDataQualityRulesetRequest(
            clientToken: clientToken, 
            dataQualitySecurityConfiguration: dataQualitySecurityConfiguration, 
            description: description, 
            name: name, 
            ruleset: ruleset, 
            tags: tags, 
            targetTable: targetTable
        )
        return try await self.createDataQualityRuleset(input, logger: logger)
    }

    /// Creates a new database in a Data Catalog.
    @Sendable
    @inlinable
    public func createDatabase(_ input: CreateDatabaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDatabaseResponse {
        try await self.client.execute(
            operation: "CreateDatabase", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new database in a Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which to create the database. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseInput: The metadata for the database.
    ///   - tags: The tags you assign to the database.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDatabase(
        catalogId: String? = nil,
        databaseInput: DatabaseInput,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDatabaseResponse {
        let input = CreateDatabaseRequest(
            catalogId: catalogId, 
            databaseInput: databaseInput, 
            tags: tags
        )
        return try await self.createDatabase(input, logger: logger)
    }

    /// Creates a new development endpoint.
    @Sendable
    @inlinable
    public func createDevEndpoint(_ input: CreateDevEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDevEndpointResponse {
        try await self.client.execute(
            operation: "CreateDevEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new development endpoint.
    ///
    /// Parameters:
    ///   - arguments: A map of arguments used to configure the DevEndpoint.
    ///   - endpointName: The name to be assigned to the new DevEndpoint.
    ///   - extraJarsS3Path: The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint.
    ///   - extraPythonLibsS3Path: The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma.  You can only use pure Python libraries with a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not yet supported.
    ///   - glueVersion: Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Development endpoints that are created without specifying a Glue version default to Glue 0.9. You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
    ///   - numberOfNodes: The number of Glue Data Processing Units (DPUs) to allocate to this DevEndpoint.
    ///   - numberOfWorkers: The number of workers of a defined workerType that are allocated to the development endpoint. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
    ///   - publicKey: The public key to be used by this DevEndpoint for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.
    ///   - publicKeys: A list of public keys to be used by the development endpoints for authentication. The use of this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.  If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the UpdateDevEndpoint API with the public key content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys attribute.
    ///   - roleArn: The IAM role for the DevEndpoint.
    ///   - securityConfiguration: The name of the SecurityConfiguration structure to be used with this DevEndpoint.
    ///   - securityGroupIds: Security group IDs for the security groups to be used by the new DevEndpoint.
    ///   - subnetId: The subnet ID for the new DevEndpoint to use.
    ///   - tags: The tags to use with this DevEndpoint. You may use tags to limit access to the DevEndpoint. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
    ///   - workerType: The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   Known issue: when a development endpoint is created with the G.2X WorkerType configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDevEndpoint(
        arguments: [String: String]? = nil,
        endpointName: String,
        extraJarsS3Path: String? = nil,
        extraPythonLibsS3Path: String? = nil,
        glueVersion: String? = nil,
        numberOfNodes: Int? = nil,
        numberOfWorkers: Int? = nil,
        publicKey: String? = nil,
        publicKeys: [String]? = nil,
        roleArn: String,
        securityConfiguration: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetId: String? = nil,
        tags: [String: String]? = nil,
        workerType: WorkerType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDevEndpointResponse {
        let input = CreateDevEndpointRequest(
            arguments: arguments, 
            endpointName: endpointName, 
            extraJarsS3Path: extraJarsS3Path, 
            extraPythonLibsS3Path: extraPythonLibsS3Path, 
            glueVersion: glueVersion, 
            numberOfNodes: numberOfNodes, 
            numberOfWorkers: numberOfWorkers, 
            publicKey: publicKey, 
            publicKeys: publicKeys, 
            roleArn: roleArn, 
            securityConfiguration: securityConfiguration, 
            securityGroupIds: securityGroupIds, 
            subnetId: subnetId, 
            tags: tags, 
            workerType: workerType
        )
        return try await self.createDevEndpoint(input, logger: logger)
    }

    /// Creates a Zero-ETL integration in the caller's account between two resources with Amazon Resource Names (ARNs): the SourceArn and TargetArn.
    @Sendable
    @inlinable
    public func createIntegration(_ input: CreateIntegrationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateIntegrationResponse {
        try await self.client.execute(
            operation: "CreateIntegration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a Zero-ETL integration in the caller's account between two resources with Amazon Resource Names (ARNs): the SourceArn and TargetArn.
    ///
    /// Parameters:
    ///   - additionalEncryptionContext: An optional set of non-secret key–value pairs that contains additional contextual information for encryption. This can only be provided if KMSKeyId is provided.
    ///   - dataFilter: Selects source tables for the integration using Maxwell filter syntax.
    ///   - description: A description of the integration.
    ///   - integrationName: A unique name for an integration in Glue.
    ///   - kmsKeyId: The ARN of a KMS key used for encrypting the channel.
    ///   - sourceArn: The ARN of the source resource for the integration.
    ///   - tags: Metadata assigned to the resource consisting of a list of key-value pairs.
    ///   - targetArn: The ARN of the target resource for the integration.
    ///   - logger: Logger use during operation
    @inlinable
    public func createIntegration(
        additionalEncryptionContext: [String: String]? = nil,
        dataFilter: String? = nil,
        description: String? = nil,
        integrationName: String,
        kmsKeyId: String? = nil,
        sourceArn: String,
        tags: [Tag]? = nil,
        targetArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateIntegrationResponse {
        let input = CreateIntegrationRequest(
            additionalEncryptionContext: additionalEncryptionContext, 
            dataFilter: dataFilter, 
            description: description, 
            integrationName: integrationName, 
            kmsKeyId: kmsKeyId, 
            sourceArn: sourceArn, 
            tags: tags, 
            targetArn: targetArn
        )
        return try await self.createIntegration(input, logger: logger)
    }

    /// This API can be used for setting up the ResourceProperty of the Glue connection (for the source) or Glue database ARN (for the target). These properties can include the role to access the connection or database. To set both source and target properties the same API needs to be invoked with the Glue connection ARN as ResourceArn with SourceProcessingProperties and the Glue database ARN as ResourceArn with TargetProcessingProperties respectively.
    @Sendable
    @inlinable
    public func createIntegrationResourceProperty(_ input: CreateIntegrationResourcePropertyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateIntegrationResourcePropertyResponse {
        try await self.client.execute(
            operation: "CreateIntegrationResourceProperty", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// This API can be used for setting up the ResourceProperty of the Glue connection (for the source) or Glue database ARN (for the target). These properties can include the role to access the connection or database. To set both source and target properties the same API needs to be invoked with the Glue connection ARN as ResourceArn with SourceProcessingProperties and the Glue database ARN as ResourceArn with TargetProcessingProperties respectively.
    ///
    /// Parameters:
    ///   - resourceArn: The connection ARN of the source, or the database ARN of the target.
    ///   - sourceProcessingProperties: The resource properties associated with the integration source.
    ///   - targetProcessingProperties: The resource properties associated with the integration target.
    ///   - logger: Logger use during operation
    @inlinable
    public func createIntegrationResourceProperty(
        resourceArn: String,
        sourceProcessingProperties: SourceProcessingProperties? = nil,
        targetProcessingProperties: TargetProcessingProperties? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateIntegrationResourcePropertyResponse {
        let input = CreateIntegrationResourcePropertyRequest(
            resourceArn: resourceArn, 
            sourceProcessingProperties: sourceProcessingProperties, 
            targetProcessingProperties: targetProcessingProperties
        )
        return try await self.createIntegrationResourceProperty(input, logger: logger)
    }

    /// This API is used to provide optional override properties for the the tables that need to be replicated. These properties can include properties for filtering and partitioning for the source and target tables. To set both source and target properties the same API need to be invoked with the Glue connection ARN as ResourceArn with SourceTableConfig, and the Glue database ARN as ResourceArn with TargetTableConfig respectively.
    @Sendable
    @inlinable
    public func createIntegrationTableProperties(_ input: CreateIntegrationTablePropertiesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateIntegrationTablePropertiesResponse {
        try await self.client.execute(
            operation: "CreateIntegrationTableProperties", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// This API is used to provide optional override properties for the the tables that need to be replicated. These properties can include properties for filtering and partitioning for the source and target tables. To set both source and target properties the same API need to be invoked with the Glue connection ARN as ResourceArn with SourceTableConfig, and the Glue database ARN as ResourceArn with TargetTableConfig respectively.
    ///
    /// Parameters:
    ///   - resourceArn: The connection ARN of the source, or the database ARN of the target.
    ///   - sourceTableConfig: A structure for the source table configuration.
    ///   - tableName: The name of the table to be replicated.
    ///   - targetTableConfig: A structure for the target table configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func createIntegrationTableProperties(
        resourceArn: String,
        sourceTableConfig: SourceTableConfig? = nil,
        tableName: String,
        targetTableConfig: TargetTableConfig? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateIntegrationTablePropertiesResponse {
        let input = CreateIntegrationTablePropertiesRequest(
            resourceArn: resourceArn, 
            sourceTableConfig: sourceTableConfig, 
            tableName: tableName, 
            targetTableConfig: targetTableConfig
        )
        return try await self.createIntegrationTableProperties(input, logger: logger)
    }

    /// Creates a new job definition.
    @Sendable
    @inlinable
    public func createJob(_ input: CreateJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateJobResponse {
        try await self.client.execute(
            operation: "CreateJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new job definition.
    ///
    /// Parameters:
    ///   - codeGenConfigurationNodes: The representation of a directed acyclic graph on which both the Glue Studio visual component and Glue Studio code generation is based.
    ///   - command: The JobCommand that runs this job.
    ///   - connections: The connections used for this job.
    ///   - defaultArguments: The default arguments for every run of this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job.  For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see Using job parameters in Ray jobs in the developer guide.
    ///   - description: Description of the job being defined.
    ///   - executionClass: Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary.  Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
    ///   - executionProperty: An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
    ///   - glueVersion: In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in a job. The Python version indicates the version supported for jobs of type Spark.  Ray jobs should set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries available in your Ray job are determined by the Runtime parameter of the Job command. For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
    ///   - jobMode: A mode that describes how a job was created. Valid values are:    SCRIPT - The job was created using the Glue Studio script editor.    VISUAL - The job was created using the Glue Studio visual editor.    NOTEBOOK - The job was created using an interactive sessions notebook.   When the JobMode field is missing or null, SCRIPT is assigned as the default value.
    ///   - jobRunQueuingEnabled: Specifies whether job run queuing is enabled for the job runs for this job. A value of true means job run queuing is enabled for the job runs. If false or not populated, the job runs will not be considered for queueing. If this field does not match the value set in the job run, then the value from the job run field will be used.
    ///   - logUri: This field is reserved for future use.
    ///   - maintenanceWindow: This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue periodically performs maintenance activities. During these maintenance windows, Glue will need to restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will be restarted between 10:00AM GMT to 1:00PM GMT.
    ///   - maxCapacity: For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the  Glue pricing page. For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache  Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs.  The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
    ///   - maxRetries: The maximum number of times to retry this job if it fails.
    ///   - name: The name you assign to this job definition. It must be unique in your account.
    ///   - nonOverridableArguments: Arguments for this job that are not overridden when providing job arguments in a job run, specified as name-value pairs.
    ///   - notificationProperty: Specifies configuration properties of a job notification.
    ///   - numberOfWorkers: The number of workers of a defined workerType that are allocated when a job runs.
    ///   - role: The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
    ///   - securityConfiguration: The name of the SecurityConfiguration structure to be used with this job.
    ///   - sourceControlDetails: The details for a source control configuration for a job, allowing synchronization of job artifacts to or from a remote repository.
    ///   - tags: The tags to use with this job. You may use tags to limit access to the job. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
    ///   - timeout: The job timeout in minutes.  This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours) for batch jobs. Streaming jobs must have timeout values less than 7 days or 10080 minutes. When the value is left blank, the job will be restarted after 7 days based if you have not setup a maintenance window. If you have setup maintenance window, it will be restarted during the maintenance window after 7 days.
    ///   - workerType: The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).   For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.   For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.   For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.
    ///   - logger: Logger use during operation
    @inlinable
    public func createJob(
        codeGenConfigurationNodes: [String: CodeGenConfigurationNode]? = nil,
        command: JobCommand,
        connections: ConnectionsList? = nil,
        defaultArguments: [String: String]? = nil,
        description: String? = nil,
        executionClass: ExecutionClass? = nil,
        executionProperty: ExecutionProperty? = nil,
        glueVersion: String? = nil,
        jobMode: JobMode? = nil,
        jobRunQueuingEnabled: Bool? = nil,
        logUri: String? = nil,
        maintenanceWindow: String? = nil,
        maxCapacity: Double? = nil,
        maxRetries: Int? = nil,
        name: String,
        nonOverridableArguments: [String: String]? = nil,
        notificationProperty: NotificationProperty? = nil,
        numberOfWorkers: Int? = nil,
        role: String,
        securityConfiguration: String? = nil,
        sourceControlDetails: SourceControlDetails? = nil,
        tags: [String: String]? = nil,
        timeout: Int? = nil,
        workerType: WorkerType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateJobResponse {
        let input = CreateJobRequest(
            codeGenConfigurationNodes: codeGenConfigurationNodes, 
            command: command, 
            connections: connections, 
            defaultArguments: defaultArguments, 
            description: description, 
            executionClass: executionClass, 
            executionProperty: executionProperty, 
            glueVersion: glueVersion, 
            jobMode: jobMode, 
            jobRunQueuingEnabled: jobRunQueuingEnabled, 
            logUri: logUri, 
            maintenanceWindow: maintenanceWindow, 
            maxCapacity: maxCapacity, 
            maxRetries: maxRetries, 
            name: name, 
            nonOverridableArguments: nonOverridableArguments, 
            notificationProperty: notificationProperty, 
            numberOfWorkers: numberOfWorkers, 
            role: role, 
            securityConfiguration: securityConfiguration, 
            sourceControlDetails: sourceControlDetails, 
            tags: tags, 
            timeout: timeout, 
            workerType: workerType
        )
        return try await self.createJob(input, logger: logger)
    }

    /// Creates an Glue machine learning transform. This operation creates the transform and all the necessary parameters to train it. Call this operation as the first step in the process of using a machine learning transform (such as the FindMatches transform) for deduplicating data. You can provide an optional Description, in addition to the parameters that you want to use for your algorithm. You must also specify certain parameters for the tasks that Glue runs on your behalf as part of learning from your data and creating a high-quality machine learning transform. These parameters include Role, and optionally, AllocatedCapacity, Timeout, and MaxRetries. For more information, see Jobs.
    @Sendable
    @inlinable
    public func createMLTransform(_ input: CreateMLTransformRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMLTransformResponse {
        try await self.client.execute(
            operation: "CreateMLTransform", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an Glue machine learning transform. This operation creates the transform and all the necessary parameters to train it. Call this operation as the first step in the process of using a machine learning transform (such as the FindMatches transform) for deduplicating data. You can provide an optional Description, in addition to the parameters that you want to use for your algorithm. You must also specify certain parameters for the tasks that Glue runs on your behalf as part of learning from your data and creating a high-quality machine learning transform. These parameters include Role, and optionally, AllocatedCapacity, Timeout, and MaxRetries. For more information, see Jobs.
    ///
    /// Parameters:
    ///   - description: A description of the machine learning transform that is being defined. The default is an empty string.
    ///   - glueVersion: This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see Glue Versions in the developer guide.
    ///   - inputRecordTables: A list of Glue table definitions used by the transform.
    ///   - maxCapacity: The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.   MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.   If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.   If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.   If WorkerType is set, then NumberOfWorkers is required (and vice versa).    MaxCapacity and NumberOfWorkers must both be at least 1.   When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only. When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
    ///   - maxRetries: The maximum number of times to retry a task for this transform after a task run fails.
    ///   - name: The unique name that you give the transform when you create it.
    ///   - numberOfWorkers: The number of workers of a defined workerType that are allocated when this task runs. If WorkerType is set, then NumberOfWorkers is required (and vice versa).
    ///   - parameters: The algorithmic parameters that are specific to the transform type used. Conditionally dependent on the transform type.
    ///   - role: The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform.    This role needs Glue service role permissions to allow access to resources in Glue. See Attach a Policy to IAM Users That Access Glue.   This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.
    ///   - tags: The tags to use with this machine learning transform. You may use tags to limit access to the machine learning transform. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
    ///   - timeout: The timeout of the task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    ///   - transformEncryption: The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.
    ///   - workerType: The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.    MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.   If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.   If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.   If WorkerType is set, then NumberOfWorkers is required (and vice versa).    MaxCapacity and NumberOfWorkers must both be at least 1.
    ///   - logger: Logger use during operation
    @inlinable
    public func createMLTransform(
        description: String? = nil,
        glueVersion: String? = nil,
        inputRecordTables: [GlueTable],
        maxCapacity: Double? = nil,
        maxRetries: Int? = nil,
        name: String,
        numberOfWorkers: Int? = nil,
        parameters: TransformParameters,
        role: String,
        tags: [String: String]? = nil,
        timeout: Int? = nil,
        transformEncryption: TransformEncryption? = nil,
        workerType: WorkerType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMLTransformResponse {
        let input = CreateMLTransformRequest(
            description: description, 
            glueVersion: glueVersion, 
            inputRecordTables: inputRecordTables, 
            maxCapacity: maxCapacity, 
            maxRetries: maxRetries, 
            name: name, 
            numberOfWorkers: numberOfWorkers, 
            parameters: parameters, 
            role: role, 
            tags: tags, 
            timeout: timeout, 
            transformEncryption: transformEncryption, 
            workerType: workerType
        )
        return try await self.createMLTransform(input, logger: logger)
    }

    /// Creates a new partition.
    @Sendable
    @inlinable
    public func createPartition(_ input: CreatePartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePartitionResponse {
        try await self.client.execute(
            operation: "CreatePartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new partition.
    ///
    /// Parameters:
    ///   - catalogId: The Amazon Web Services account ID of the catalog in which the partition is to be created.
    ///   - databaseName: The name of the metadata database in which the partition is to be created.
    ///   - partitionInput: A PartitionInput structure defining the partition to be created.
    ///   - tableName: The name of the metadata table in which the partition is to be created.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPartition(
        catalogId: String? = nil,
        databaseName: String,
        partitionInput: PartitionInput,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePartitionResponse {
        let input = CreatePartitionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            partitionInput: partitionInput, 
            tableName: tableName
        )
        return try await self.createPartition(input, logger: logger)
    }

    /// Creates a specified partition index in an existing table.
    @Sendable
    @inlinable
    public func createPartitionIndex(_ input: CreatePartitionIndexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePartitionIndexResponse {
        try await self.client.execute(
            operation: "CreatePartitionIndex", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a specified partition index in an existing table.
    ///
    /// Parameters:
    ///   - catalogId: The catalog ID where the table resides.
    ///   - databaseName: Specifies the name of a database in which you want to create a partition index.
    ///   - partitionIndex: Specifies a PartitionIndex structure to create a partition index in an existing table.
    ///   - tableName: Specifies the name of a table in which you want to create a partition index.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPartitionIndex(
        catalogId: String? = nil,
        databaseName: String,
        partitionIndex: PartitionIndex,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePartitionIndexResponse {
        let input = CreatePartitionIndexRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            partitionIndex: partitionIndex, 
            tableName: tableName
        )
        return try await self.createPartitionIndex(input, logger: logger)
    }

    /// Creates a new registry which may be used to hold a collection of schemas.
    @Sendable
    @inlinable
    public func createRegistry(_ input: CreateRegistryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRegistryResponse {
        try await self.client.execute(
            operation: "CreateRegistry", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new registry which may be used to hold a collection of schemas.
    ///
    /// Parameters:
    ///   - description: A description of the registry. If description is not provided, there will not be any default value for this.
    ///   - registryName: Name of the registry to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark.  No whitespace.
    ///   - tags: Amazon Web Services tags that contain a key value pair and may be searched by console, command line, or API.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRegistry(
        description: String? = nil,
        registryName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRegistryResponse {
        let input = CreateRegistryInput(
            description: description, 
            registryName: registryName, 
            tags: tags
        )
        return try await self.createRegistry(input, logger: logger)
    }

    /// Creates a new schema set and registers the schema definition. Returns an error if the schema set already exists without actually registering the version. When the schema set is created, a version checkpoint will be set to the first version. Compatibility mode "DISABLED" restricts any additional schema versions from being added after the first schema version. For all other compatibility modes, validation of compatibility settings will be applied only from the second version onwards when the RegisterSchemaVersion API is used. When this API is called without a RegistryId, this will create an entry for a "default-registry" in the registry database tables, if it is not already present.
    @Sendable
    @inlinable
    public func createSchema(_ input: CreateSchemaInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSchemaResponse {
        try await self.client.execute(
            operation: "CreateSchema", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new schema set and registers the schema definition. Returns an error if the schema set already exists without actually registering the version. When the schema set is created, a version checkpoint will be set to the first version. Compatibility mode "DISABLED" restricts any additional schema versions from being added after the first schema version. For all other compatibility modes, validation of compatibility settings will be applied only from the second version onwards when the RegisterSchemaVersion API is used. When this API is called without a RegistryId, this will create an entry for a "default-registry" in the registry database tables, if it is not already present.
    ///
    /// Parameters:
    ///   - compatibility: The compatibility mode of the schema. The possible values are:    NONE: No compatibility mode applies. You can use this choice in development scenarios or if you do not know the compatibility mode that you want to apply to schemas. Any new version added will be accepted without undergoing a compatibility check.    DISABLED: This compatibility choice prevents versioning for a particular schema. You can use this choice to prevent future versioning of a schema.    BACKWARD: This compatibility choice is recommended as it allows data receivers to read both the current and one previous schema version. This means that for instance, a new schema version cannot drop data fields or change the type of these fields, so they can't be read by readers using the previous version.    BACKWARD_ALL: This compatibility choice allows data receivers to read both the current and all previous schema versions. You can use this choice when you need to delete fields or add optional fields, and check compatibility against all previous schema versions.     FORWARD: This compatibility choice allows data receivers to read both the current and one next schema version, but not necessarily later versions. You can use this choice when you need to add fields or delete optional fields, but only check compatibility against the last schema version.    FORWARD_ALL: This compatibility choice allows data receivers to read written by producers of any new registered schema. You can use this choice when you need to add fields or delete optional fields, and check compatibility against all previous schema versions.    FULL: This compatibility choice allows data receivers to read data written by producers using the previous or next version of the schema, but not necessarily earlier or later versions. You can use this choice when you need to add or remove optional fields, but only check compatibility against the last schema version.    FULL_ALL: This compatibility choice allows data receivers to read data written by producers using all previous schema versions. You can use this choice when you need to add or remove optional fields, and check compatibility against all previous schema versions.
    ///   - dataFormat: The data format of the schema definition. Currently AVRO, JSON and PROTOBUF are supported.
    ///   - description: An optional description of the schema. If description is not provided, there will not be any automatic default value for this.
    ///   - registryId:  This is a wrapper shape to contain the registry identity fields. If this is not provided, the default registry will be used. The ARN format for the same will be: arn:aws:glue:us-east-2::registry/default-registry:random-5-letter-id.
    ///   - schemaDefinition: The schema definition using the DataFormat setting for SchemaName.
    ///   - schemaName: Name of the schema to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark. No whitespace.
    ///   - tags: Amazon Web Services tags that contain a key value pair and may be searched by console, command line, or API. If specified, follows the Amazon Web Services tags-on-create pattern.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSchema(
        compatibility: Compatibility? = nil,
        dataFormat: DataFormat,
        description: String? = nil,
        registryId: RegistryId? = nil,
        schemaDefinition: String? = nil,
        schemaName: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSchemaResponse {
        let input = CreateSchemaInput(
            compatibility: compatibility, 
            dataFormat: dataFormat, 
            description: description, 
            registryId: registryId, 
            schemaDefinition: schemaDefinition, 
            schemaName: schemaName, 
            tags: tags
        )
        return try await self.createSchema(input, logger: logger)
    }

    /// Transforms a directed acyclic graph (DAG) into code.
    @Sendable
    @inlinable
    public func createScript(_ input: CreateScriptRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateScriptResponse {
        try await self.client.execute(
            operation: "CreateScript", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Transforms a directed acyclic graph (DAG) into code.
    ///
    /// Parameters:
    ///   - dagEdges: A list of the edges in the DAG.
    ///   - dagNodes: A list of the nodes in the DAG.
    ///   - language: The programming language of the resulting code from the DAG.
    ///   - logger: Logger use during operation
    @inlinable
    public func createScript(
        dagEdges: [CodeGenEdge]? = nil,
        dagNodes: [CodeGenNode]? = nil,
        language: Language? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateScriptResponse {
        let input = CreateScriptRequest(
            dagEdges: dagEdges, 
            dagNodes: dagNodes, 
            language: language
        )
        return try await self.createScript(input, logger: logger)
    }

    /// Creates a new security configuration. A security configuration is a set of security properties that can be used by Glue. You can use a security configuration to encrypt data at rest. For information about using security configurations in Glue, see Encrypting Data Written by Crawlers, Jobs, and Development Endpoints.
    @Sendable
    @inlinable
    public func createSecurityConfiguration(_ input: CreateSecurityConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSecurityConfigurationResponse {
        try await self.client.execute(
            operation: "CreateSecurityConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new security configuration. A security configuration is a set of security properties that can be used by Glue. You can use a security configuration to encrypt data at rest. For information about using security configurations in Glue, see Encrypting Data Written by Crawlers, Jobs, and Development Endpoints.
    ///
    /// Parameters:
    ///   - encryptionConfiguration: The encryption configuration for the new security configuration.
    ///   - name: The name for the new security configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSecurityConfiguration(
        encryptionConfiguration: EncryptionConfiguration,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSecurityConfigurationResponse {
        let input = CreateSecurityConfigurationRequest(
            encryptionConfiguration: encryptionConfiguration, 
            name: name
        )
        return try await self.createSecurityConfiguration(input, logger: logger)
    }

    /// Creates a new session.
    @Sendable
    @inlinable
    public func createSession(_ input: CreateSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSessionResponse {
        try await self.client.execute(
            operation: "CreateSession", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new session.
    ///
    /// Parameters:
    ///   - command: The SessionCommand that runs the job.
    ///   - connections: The number of connections to use for the session.
    ///   - defaultArguments: A map array of key-value pairs. Max is 75 pairs.
    ///   - description: The description of the session.
    ///   - glueVersion: The Glue version determines the versions of Apache Spark and Python that Glue supports.  The GlueVersion must be greater than 2.0.
    ///   - id: The ID of the session request.
    ///   - idleTimeout:  The number of minutes when idle before session times out. Default for Spark ETL jobs is value of Timeout. Consult the documentation for other job types.
    ///   - maxCapacity: The number of Glue data processing units (DPUs) that can be allocated when the job runs.  A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.
    ///   - numberOfWorkers: The number of workers of a defined WorkerType to use for the session.
    ///   - requestOrigin: The origin of the request.
    ///   - role: The IAM Role ARN
    ///   - securityConfiguration: The name of the SecurityConfiguration structure to be used with the session
    ///   - tags: The map of key value pairs (tags) belonging to the session.
    ///   - timeout:  The number of minutes before session times out. Default for Spark ETL jobs is 48 hours (2880 minutes), the maximum session lifetime for this job type. Consult the documentation for other job types.
    ///   - workerType: The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, or G.8X for Spark jobs. Accepts the value Z.2X for Ray notebooks.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).   For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.   For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSession(
        command: SessionCommand,
        connections: ConnectionsList? = nil,
        defaultArguments: [String: String]? = nil,
        description: String? = nil,
        glueVersion: String? = nil,
        id: String,
        idleTimeout: Int? = nil,
        maxCapacity: Double? = nil,
        numberOfWorkers: Int? = nil,
        requestOrigin: String? = nil,
        role: String,
        securityConfiguration: String? = nil,
        tags: [String: String]? = nil,
        timeout: Int? = nil,
        workerType: WorkerType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSessionResponse {
        let input = CreateSessionRequest(
            command: command, 
            connections: connections, 
            defaultArguments: defaultArguments, 
            description: description, 
            glueVersion: glueVersion, 
            id: id, 
            idleTimeout: idleTimeout, 
            maxCapacity: maxCapacity, 
            numberOfWorkers: numberOfWorkers, 
            requestOrigin: requestOrigin, 
            role: role, 
            securityConfiguration: securityConfiguration, 
            tags: tags, 
            timeout: timeout, 
            workerType: workerType
        )
        return try await self.createSession(input, logger: logger)
    }

    /// Creates a new table definition in the Data Catalog.
    @Sendable
    @inlinable
    public func createTable(_ input: CreateTableRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTableResponse {
        try await self.client.execute(
            operation: "CreateTable", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new table definition in the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which to create the Table. If none is supplied, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The catalog database in which to create the new table. For Hive compatibility, this name is entirely lowercase.
    ///   - openTableFormatInput: Specifies an OpenTableFormatInput structure when creating an open format table.
    ///   - partitionIndexes: A list of partition indexes, PartitionIndex structures, to create in the table.
    ///   - tableInput: The TableInput object that defines the metadata table to create in the catalog.
    ///   - transactionId: The ID of the transaction.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTable(
        catalogId: String? = nil,
        databaseName: String,
        openTableFormatInput: OpenTableFormatInput? = nil,
        partitionIndexes: [PartitionIndex]? = nil,
        tableInput: TableInput,
        transactionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTableResponse {
        let input = CreateTableRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            openTableFormatInput: openTableFormatInput, 
            partitionIndexes: partitionIndexes, 
            tableInput: tableInput, 
            transactionId: transactionId
        )
        return try await self.createTable(input, logger: logger)
    }

    /// Creates a new table optimizer for a specific function.
    @Sendable
    @inlinable
    public func createTableOptimizer(_ input: CreateTableOptimizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTableOptimizerResponse {
        try await self.client.execute(
            operation: "CreateTableOptimizer", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new table optimizer for a specific function.
    ///
    /// Parameters:
    ///   - catalogId: The Catalog ID of the table.
    ///   - databaseName: The name of the database in the catalog in which the table resides.
    ///   - tableName: The name of the table.
    ///   - tableOptimizerConfiguration: A TableOptimizerConfiguration object representing the configuration of a table optimizer.
    ///   - type: The type of table optimizer.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTableOptimizer(
        catalogId: String,
        databaseName: String,
        tableName: String,
        tableOptimizerConfiguration: TableOptimizerConfiguration,
        type: TableOptimizerType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTableOptimizerResponse {
        let input = CreateTableOptimizerRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            tableName: tableName, 
            tableOptimizerConfiguration: tableOptimizerConfiguration, 
            type: type
        )
        return try await self.createTableOptimizer(input, logger: logger)
    }

    /// Creates a new trigger.
    @Sendable
    @inlinable
    public func createTrigger(_ input: CreateTriggerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTriggerResponse {
        try await self.client.execute(
            operation: "CreateTrigger", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new trigger.
    ///
    /// Parameters:
    ///   - actions: The actions initiated by this trigger when it fires.
    ///   - description: A description of the new trigger.
    ///   - eventBatchingCondition: Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.
    ///   - name: The name of the trigger.
    ///   - predicate: A predicate to specify when the new trigger should fire. This field is required when the trigger type is CONDITIONAL.
    ///   - schedule: A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *). This field is required when the trigger type is SCHEDULED.
    ///   - startOnCreation: Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
    ///   - tags: The tags to use with this trigger. You may use tags to limit access to the trigger. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
    ///   - type: The type of the new trigger.
    ///   - workflowName: The name of the workflow associated with the trigger.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTrigger(
        actions: [Action],
        description: String? = nil,
        eventBatchingCondition: EventBatchingCondition? = nil,
        name: String,
        predicate: Predicate? = nil,
        schedule: String? = nil,
        startOnCreation: Bool? = nil,
        tags: [String: String]? = nil,
        type: TriggerType,
        workflowName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTriggerResponse {
        let input = CreateTriggerRequest(
            actions: actions, 
            description: description, 
            eventBatchingCondition: eventBatchingCondition, 
            name: name, 
            predicate: predicate, 
            schedule: schedule, 
            startOnCreation: startOnCreation, 
            tags: tags, 
            type: type, 
            workflowName: workflowName
        )
        return try await self.createTrigger(input, logger: logger)
    }

    /// Creates an Glue usage profile.
    @Sendable
    @inlinable
    public func createUsageProfile(_ input: CreateUsageProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateUsageProfileResponse {
        try await self.client.execute(
            operation: "CreateUsageProfile", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an Glue usage profile.
    ///
    /// Parameters:
    ///   - configuration: A ProfileConfiguration object specifying the job and session values for the profile.
    ///   - description: A description of the usage profile.
    ///   - name: The name of the usage profile.
    ///   - tags: A list of tags applied to the usage profile.
    ///   - logger: Logger use during operation
    @inlinable
    public func createUsageProfile(
        configuration: ProfileConfiguration,
        description: String? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateUsageProfileResponse {
        let input = CreateUsageProfileRequest(
            configuration: configuration, 
            description: description, 
            name: name, 
            tags: tags
        )
        return try await self.createUsageProfile(input, logger: logger)
    }

    /// Creates a new function definition in the Data Catalog.
    @Sendable
    @inlinable
    public func createUserDefinedFunction(_ input: CreateUserDefinedFunctionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateUserDefinedFunctionResponse {
        try await self.client.execute(
            operation: "CreateUserDefinedFunction", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new function definition in the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which to create the function. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database in which to create the function.
    ///   - functionInput: A FunctionInput object that defines the function to create in the Data Catalog.
    ///   - logger: Logger use during operation
    @inlinable
    public func createUserDefinedFunction(
        catalogId: String? = nil,
        databaseName: String,
        functionInput: UserDefinedFunctionInput,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateUserDefinedFunctionResponse {
        let input = CreateUserDefinedFunctionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            functionInput: functionInput
        )
        return try await self.createUserDefinedFunction(input, logger: logger)
    }

    /// Creates a new workflow.
    @Sendable
    @inlinable
    public func createWorkflow(_ input: CreateWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkflowResponse {
        try await self.client.execute(
            operation: "CreateWorkflow", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new workflow.
    ///
    /// Parameters:
    ///   - defaultRunProperties: A collection of properties to be used as part of each execution of the workflow.
    ///   - description: A description of the workflow.
    ///   - maxConcurrentRuns: You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
    ///   - name: The name to be assigned to the workflow. It should be unique within your account.
    ///   - tags: The tags to be used with this workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func createWorkflow(
        defaultRunProperties: [String: String]? = nil,
        description: String? = nil,
        maxConcurrentRuns: Int? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateWorkflowResponse {
        let input = CreateWorkflowRequest(
            defaultRunProperties: defaultRunProperties, 
            description: description, 
            maxConcurrentRuns: maxConcurrentRuns, 
            name: name, 
            tags: tags
        )
        return try await self.createWorkflow(input, logger: logger)
    }

    /// Deletes an existing blueprint.
    @Sendable
    @inlinable
    public func deleteBlueprint(_ input: DeleteBlueprintRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBlueprintResponse {
        try await self.client.execute(
            operation: "DeleteBlueprint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing blueprint.
    ///
    /// Parameters:
    ///   - name: The name of the blueprint to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBlueprint(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBlueprintResponse {
        let input = DeleteBlueprintRequest(
            name: name
        )
        return try await self.deleteBlueprint(input, logger: logger)
    }

    /// Removes the specified catalog from the Glue Data Catalog. After completing this operation, you no longer have access to the databases, tables (and all table versions and partitions that might belong to the tables) and the user-defined functions in the deleted catalog. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources before calling the DeleteCatalog operation, use DeleteTableVersion (or BatchDeleteTableVersion), DeletePartition (or BatchDeletePartition), DeleteTable (or BatchDeleteTable), DeleteUserDefinedFunction and DeleteDatabase to delete any resources that belong to the catalog.
    @Sendable
    @inlinable
    public func deleteCatalog(_ input: DeleteCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCatalogResponse {
        try await self.client.execute(
            operation: "DeleteCatalog", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the specified catalog from the Glue Data Catalog. After completing this operation, you no longer have access to the databases, tables (and all table versions and partitions that might belong to the tables) and the user-defined functions in the deleted catalog. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources before calling the DeleteCatalog operation, use DeleteTableVersion (or BatchDeleteTableVersion), DeletePartition (or BatchDeletePartition), DeleteTable (or BatchDeleteTable), DeleteUserDefinedFunction and DeleteDatabase to delete any resources that belong to the catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the catalog.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCatalog(
        catalogId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCatalogResponse {
        let input = DeleteCatalogRequest(
            catalogId: catalogId
        )
        return try await self.deleteCatalog(input, logger: logger)
    }

    /// Removes a classifier from the Data Catalog.
    @Sendable
    @inlinable
    public func deleteClassifier(_ input: DeleteClassifierRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteClassifierResponse {
        try await self.client.execute(
            operation: "DeleteClassifier", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a classifier from the Data Catalog.
    ///
    /// Parameters:
    ///   - name: Name of the classifier to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteClassifier(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteClassifierResponse {
        let input = DeleteClassifierRequest(
            name: name
        )
        return try await self.deleteClassifier(input, logger: logger)
    }

    /// Delete the partition column statistics of a column. The Identity and Access Management (IAM) permission required for this operation is DeletePartition.
    @Sendable
    @inlinable
    public func deleteColumnStatisticsForPartition(_ input: DeleteColumnStatisticsForPartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteColumnStatisticsForPartitionResponse {
        try await self.client.execute(
            operation: "DeleteColumnStatisticsForPartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete the partition column statistics of a column. The Identity and Access Management (IAM) permission required for this operation is DeletePartition.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    ///   - columnName: Name of the column.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - partitionValues: A list of partition values identifying the partition.
    ///   - tableName: The name of the partitions' table.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteColumnStatisticsForPartition(
        catalogId: String? = nil,
        columnName: String,
        databaseName: String,
        partitionValues: [String],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteColumnStatisticsForPartitionResponse {
        let input = DeleteColumnStatisticsForPartitionRequest(
            catalogId: catalogId, 
            columnName: columnName, 
            databaseName: databaseName, 
            partitionValues: partitionValues, 
            tableName: tableName
        )
        return try await self.deleteColumnStatisticsForPartition(input, logger: logger)
    }

    /// Retrieves table statistics of columns. The Identity and Access Management (IAM) permission required for this operation is DeleteTable.
    @Sendable
    @inlinable
    public func deleteColumnStatisticsForTable(_ input: DeleteColumnStatisticsForTableRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteColumnStatisticsForTableResponse {
        try await self.client.execute(
            operation: "DeleteColumnStatisticsForTable", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves table statistics of columns. The Identity and Access Management (IAM) permission required for this operation is DeleteTable.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    ///   - columnName: The name of the column.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - tableName: The name of the partitions' table.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteColumnStatisticsForTable(
        catalogId: String? = nil,
        columnName: String,
        databaseName: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteColumnStatisticsForTableResponse {
        let input = DeleteColumnStatisticsForTableRequest(
            catalogId: catalogId, 
            columnName: columnName, 
            databaseName: databaseName, 
            tableName: tableName
        )
        return try await self.deleteColumnStatisticsForTable(input, logger: logger)
    }

    /// Deletes settings for a column statistics task.
    @Sendable
    @inlinable
    public func deleteColumnStatisticsTaskSettings(_ input: DeleteColumnStatisticsTaskSettingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteColumnStatisticsTaskSettingsResponse {
        try await self.client.execute(
            operation: "DeleteColumnStatisticsTaskSettings", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes settings for a column statistics task.
    ///
    /// Parameters:
    ///   - databaseName: The name of the database where the table resides.
    ///   - tableName: The name of the table for which to delete column statistics.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteColumnStatisticsTaskSettings(
        databaseName: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteColumnStatisticsTaskSettingsResponse {
        let input = DeleteColumnStatisticsTaskSettingsRequest(
            databaseName: databaseName, 
            tableName: tableName
        )
        return try await self.deleteColumnStatisticsTaskSettings(input, logger: logger)
    }

    /// Deletes a connection from the Data Catalog.
    @Sendable
    @inlinable
    public func deleteConnection(_ input: DeleteConnectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteConnectionResponse {
        try await self.client.execute(
            operation: "DeleteConnection", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a connection from the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - connectionName: The name of the connection to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteConnection(
        catalogId: String? = nil,
        connectionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteConnectionResponse {
        let input = DeleteConnectionRequest(
            catalogId: catalogId, 
            connectionName: connectionName
        )
        return try await self.deleteConnection(input, logger: logger)
    }

    /// Removes a specified crawler from the Glue Data Catalog, unless the crawler state is RUNNING.
    @Sendable
    @inlinable
    public func deleteCrawler(_ input: DeleteCrawlerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCrawlerResponse {
        try await self.client.execute(
            operation: "DeleteCrawler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a specified crawler from the Glue Data Catalog, unless the crawler state is RUNNING.
    ///
    /// Parameters:
    ///   - name: The name of the crawler to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCrawler(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCrawlerResponse {
        let input = DeleteCrawlerRequest(
            name: name
        )
        return try await self.deleteCrawler(input, logger: logger)
    }

    /// Deletes a custom pattern by specifying its name.
    @Sendable
    @inlinable
    public func deleteCustomEntityType(_ input: DeleteCustomEntityTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCustomEntityTypeResponse {
        try await self.client.execute(
            operation: "DeleteCustomEntityType", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a custom pattern by specifying its name.
    ///
    /// Parameters:
    ///   - name: The name of the custom pattern that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCustomEntityType(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCustomEntityTypeResponse {
        let input = DeleteCustomEntityTypeRequest(
            name: name
        )
        return try await self.deleteCustomEntityType(input, logger: logger)
    }

    /// Deletes a data quality ruleset.
    @Sendable
    @inlinable
    public func deleteDataQualityRuleset(_ input: DeleteDataQualityRulesetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDataQualityRulesetResponse {
        try await self.client.execute(
            operation: "DeleteDataQualityRuleset", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a data quality ruleset.
    ///
    /// Parameters:
    ///   - name: A name for the data quality ruleset.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDataQualityRuleset(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDataQualityRulesetResponse {
        let input = DeleteDataQualityRulesetRequest(
            name: name
        )
        return try await self.deleteDataQualityRuleset(input, logger: logger)
    }

    /// Removes a specified database from a Data Catalog.  After completing this operation, you no longer have access to the tables (and all table versions and partitions that might belong to the tables) and the user-defined functions in the deleted database. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources, before calling DeleteDatabase, use DeleteTableVersion or BatchDeleteTableVersion, DeletePartition or BatchDeletePartition, DeleteUserDefinedFunction, and DeleteTable or BatchDeleteTable, to delete any resources that belong to the database.
    @Sendable
    @inlinable
    public func deleteDatabase(_ input: DeleteDatabaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDatabaseResponse {
        try await self.client.execute(
            operation: "DeleteDatabase", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a specified database from a Data Catalog.  After completing this operation, you no longer have access to the tables (and all table versions and partitions that might belong to the tables) and the user-defined functions in the deleted database. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources, before calling DeleteDatabase, use DeleteTableVersion or BatchDeleteTableVersion, DeletePartition or BatchDeletePartition, DeleteUserDefinedFunction, and DeleteTable or BatchDeleteTable, to delete any resources that belong to the database.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - name: The name of the database to delete. For Hive compatibility, this must be all lowercase.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDatabase(
        catalogId: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDatabaseResponse {
        let input = DeleteDatabaseRequest(
            catalogId: catalogId, 
            name: name
        )
        return try await self.deleteDatabase(input, logger: logger)
    }

    /// Deletes a specified development endpoint.
    @Sendable
    @inlinable
    public func deleteDevEndpoint(_ input: DeleteDevEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDevEndpointResponse {
        try await self.client.execute(
            operation: "DeleteDevEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specified development endpoint.
    ///
    /// Parameters:
    ///   - endpointName: The name of the DevEndpoint.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDevEndpoint(
        endpointName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDevEndpointResponse {
        let input = DeleteDevEndpointRequest(
            endpointName: endpointName
        )
        return try await self.deleteDevEndpoint(input, logger: logger)
    }

    /// Deletes the specified Zero-ETL integration.
    @Sendable
    @inlinable
    public func deleteIntegration(_ input: DeleteIntegrationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteIntegrationResponse {
        try await self.client.execute(
            operation: "DeleteIntegration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified Zero-ETL integration.
    ///
    /// Parameters:
    ///   - integrationIdentifier: The Amazon Resource Name (ARN) for the integration.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteIntegration(
        integrationIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteIntegrationResponse {
        let input = DeleteIntegrationRequest(
            integrationIdentifier: integrationIdentifier
        )
        return try await self.deleteIntegration(input, logger: logger)
    }

    /// Deletes the table properties that have been created for the tables that need to be replicated.
    @Sendable
    @inlinable
    public func deleteIntegrationTableProperties(_ input: DeleteIntegrationTablePropertiesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteIntegrationTablePropertiesResponse {
        try await self.client.execute(
            operation: "DeleteIntegrationTableProperties", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the table properties that have been created for the tables that need to be replicated.
    ///
    /// Parameters:
    ///   - resourceArn: The connection ARN of the source, or the database ARN of the target.
    ///   - tableName: The name of the table to be replicated.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteIntegrationTableProperties(
        resourceArn: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteIntegrationTablePropertiesResponse {
        let input = DeleteIntegrationTablePropertiesRequest(
            resourceArn: resourceArn, 
            tableName: tableName
        )
        return try await self.deleteIntegrationTableProperties(input, logger: logger)
    }

    /// Deletes a specified job definition. If the job definition is not found, no exception is thrown.
    @Sendable
    @inlinable
    public func deleteJob(_ input: DeleteJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteJobResponse {
        try await self.client.execute(
            operation: "DeleteJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specified job definition. If the job definition is not found, no exception is thrown.
    ///
    /// Parameters:
    ///   - jobName: The name of the job definition to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteJob(
        jobName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteJobResponse {
        let input = DeleteJobRequest(
            jobName: jobName
        )
        return try await self.deleteJob(input, logger: logger)
    }

    /// Deletes an Glue machine learning transform. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue. If you no longer need a transform, you can delete it by calling DeleteMLTransforms. However, any Glue jobs that still reference the deleted transform will no longer succeed.
    @Sendable
    @inlinable
    public func deleteMLTransform(_ input: DeleteMLTransformRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMLTransformResponse {
        try await self.client.execute(
            operation: "DeleteMLTransform", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an Glue machine learning transform. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue. If you no longer need a transform, you can delete it by calling DeleteMLTransforms. However, any Glue jobs that still reference the deleted transform will no longer succeed.
    ///
    /// Parameters:
    ///   - transformId: The unique identifier of the transform to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMLTransform(
        transformId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMLTransformResponse {
        let input = DeleteMLTransformRequest(
            transformId: transformId
        )
        return try await self.deleteMLTransform(input, logger: logger)
    }

    /// Deletes a specified partition.
    @Sendable
    @inlinable
    public func deletePartition(_ input: DeletePartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePartitionResponse {
        try await self.client.execute(
            operation: "DeletePartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specified partition.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partition to be deleted resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database in which the table in question resides.
    ///   - partitionValues: The values that define the partition.
    ///   - tableName: The name of the table that contains the partition to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePartition(
        catalogId: String? = nil,
        databaseName: String,
        partitionValues: [String],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePartitionResponse {
        let input = DeletePartitionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            partitionValues: partitionValues, 
            tableName: tableName
        )
        return try await self.deletePartition(input, logger: logger)
    }

    /// Deletes a specified partition index from an existing table.
    @Sendable
    @inlinable
    public func deletePartitionIndex(_ input: DeletePartitionIndexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePartitionIndexResponse {
        try await self.client.execute(
            operation: "DeletePartitionIndex", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specified partition index from an existing table.
    ///
    /// Parameters:
    ///   - catalogId: The catalog ID where the table resides.
    ///   - databaseName: Specifies the name of a database from which you want to delete a partition index.
    ///   - indexName: The name of the partition index to be deleted.
    ///   - tableName: Specifies the name of a table from which you want to delete a partition index.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePartitionIndex(
        catalogId: String? = nil,
        databaseName: String,
        indexName: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePartitionIndexResponse {
        let input = DeletePartitionIndexRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            indexName: indexName, 
            tableName: tableName
        )
        return try await self.deletePartitionIndex(input, logger: logger)
    }

    /// Delete the entire registry including schema and all of its versions. To get the status of the delete operation, you can call the GetRegistry API after the asynchronous call. Deleting a registry will deactivate all online operations for the registry such as the UpdateRegistry, CreateSchema, UpdateSchema, and RegisterSchemaVersion APIs.
    @Sendable
    @inlinable
    public func deleteRegistry(_ input: DeleteRegistryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteRegistryResponse {
        try await self.client.execute(
            operation: "DeleteRegistry", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete the entire registry including schema and all of its versions. To get the status of the delete operation, you can call the GetRegistry API after the asynchronous call. Deleting a registry will deactivate all online operations for the registry such as the UpdateRegistry, CreateSchema, UpdateSchema, and RegisterSchemaVersion APIs.
    ///
    /// Parameters:
    ///   - registryId: This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRegistry(
        registryId: RegistryId,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteRegistryResponse {
        let input = DeleteRegistryInput(
            registryId: registryId
        )
        return try await self.deleteRegistry(input, logger: logger)
    }

    /// Deletes a specified policy.
    @Sendable
    @inlinable
    public func deleteResourcePolicy(_ input: DeleteResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResourcePolicyResponse {
        try await self.client.execute(
            operation: "DeleteResourcePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specified policy.
    ///
    /// Parameters:
    ///   - policyHashCondition: The hash value returned when this policy was set.
    ///   - resourceArn: The ARN of the Glue resource for the resource policy to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResourcePolicy(
        policyHashCondition: String? = nil,
        resourceArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteResourcePolicyResponse {
        let input = DeleteResourcePolicyRequest(
            policyHashCondition: policyHashCondition, 
            resourceArn: resourceArn
        )
        return try await self.deleteResourcePolicy(input, logger: logger)
    }

    /// Deletes the entire schema set, including the schema set and all of its versions. To get the status of the delete operation, you can call GetSchema API after the asynchronous call. Deleting a registry will deactivate all online operations for the schema, such as the GetSchemaByDefinition, and RegisterSchemaVersion APIs.
    @Sendable
    @inlinable
    public func deleteSchema(_ input: DeleteSchemaInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSchemaResponse {
        try await self.client.execute(
            operation: "DeleteSchema", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the entire schema set, including the schema set and all of its versions. To get the status of the delete operation, you can call GetSchema API after the asynchronous call. Deleting a registry will deactivate all online operations for the schema, such as the GetSchemaByDefinition, and RegisterSchemaVersion APIs.
    ///
    /// Parameters:
    ///   - schemaId: This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSchema(
        schemaId: SchemaId,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSchemaResponse {
        let input = DeleteSchemaInput(
            schemaId: schemaId
        )
        return try await self.deleteSchema(input, logger: logger)
    }

    /// Remove versions from the specified schema. A version number or range may be supplied. If the compatibility mode forbids deleting of a version that is necessary, such as BACKWARDS_FULL, an error is returned.  Calling the GetSchemaVersions API after this call will list the status of the deleted versions. When the range of version numbers contain check pointed version, the API will return a 409 conflict and will not proceed with the deletion. You have to remove the checkpoint first using the DeleteSchemaCheckpoint API before using this API. You cannot use the DeleteSchemaVersions API to delete the first schema version in the schema set. The first schema version can only be deleted by the DeleteSchema API. This operation will also delete the attached SchemaVersionMetadata under the schema versions. Hard deletes will be enforced on the database. If the compatibility mode forbids deleting of a version that is necessary, such as BACKWARDS_FULL, an error is returned.
    @Sendable
    @inlinable
    public func deleteSchemaVersions(_ input: DeleteSchemaVersionsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSchemaVersionsResponse {
        try await self.client.execute(
            operation: "DeleteSchemaVersions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Remove versions from the specified schema. A version number or range may be supplied. If the compatibility mode forbids deleting of a version that is necessary, such as BACKWARDS_FULL, an error is returned.  Calling the GetSchemaVersions API after this call will list the status of the deleted versions. When the range of version numbers contain check pointed version, the API will return a 409 conflict and will not proceed with the deletion. You have to remove the checkpoint first using the DeleteSchemaCheckpoint API before using this API. You cannot use the DeleteSchemaVersions API to delete the first schema version in the schema set. The first schema version can only be deleted by the DeleteSchema API. This operation will also delete the attached SchemaVersionMetadata under the schema versions. Hard deletes will be enforced on the database. If the compatibility mode forbids deleting of a version that is necessary, such as BACKWARDS_FULL, an error is returned.
    ///
    /// Parameters:
    ///   - schemaId: This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
    ///   - versions: A version range may be supplied which may be of the format:   a single version number, 5   a range, 5-8 : deletes versions 5, 6, 7, 8
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSchemaVersions(
        schemaId: SchemaId,
        versions: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSchemaVersionsResponse {
        let input = DeleteSchemaVersionsInput(
            schemaId: schemaId, 
            versions: versions
        )
        return try await self.deleteSchemaVersions(input, logger: logger)
    }

    /// Deletes a specified security configuration.
    @Sendable
    @inlinable
    public func deleteSecurityConfiguration(_ input: DeleteSecurityConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSecurityConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteSecurityConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specified security configuration.
    ///
    /// Parameters:
    ///   - name: The name of the security configuration to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSecurityConfiguration(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSecurityConfigurationResponse {
        let input = DeleteSecurityConfigurationRequest(
            name: name
        )
        return try await self.deleteSecurityConfiguration(input, logger: logger)
    }

    /// Deletes the session.
    @Sendable
    @inlinable
    public func deleteSession(_ input: DeleteSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSessionResponse {
        try await self.client.execute(
            operation: "DeleteSession", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the session.
    ///
    /// Parameters:
    ///   - id: The ID of the session to be deleted.
    ///   - requestOrigin: The name of the origin of the delete session request.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSession(
        id: String,
        requestOrigin: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSessionResponse {
        let input = DeleteSessionRequest(
            id: id, 
            requestOrigin: requestOrigin
        )
        return try await self.deleteSession(input, logger: logger)
    }

    /// Removes a table definition from the Data Catalog.  After completing this operation, you no longer have access to the table versions and partitions that belong to the deleted table. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources, before calling DeleteTable, use DeleteTableVersion or BatchDeleteTableVersion, and DeletePartition or BatchDeletePartition, to delete any resources that belong to the table.
    @Sendable
    @inlinable
    public func deleteTable(_ input: DeleteTableRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteTableResponse {
        try await self.client.execute(
            operation: "DeleteTable", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a table definition from the Data Catalog.  After completing this operation, you no longer have access to the table versions and partitions that belong to the deleted table. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service. To ensure the immediate deletion of all related resources, before calling DeleteTable, use DeleteTableVersion or BatchDeleteTableVersion, and DeletePartition or BatchDeletePartition, to delete any resources that belong to the table.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
    ///   - name: The name of the table to be deleted. For Hive compatibility, this name is entirely lowercase.
    ///   - transactionId: The transaction ID at which to delete the table contents.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTable(
        catalogId: String? = nil,
        databaseName: String,
        name: String,
        transactionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteTableResponse {
        let input = DeleteTableRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            name: name, 
            transactionId: transactionId
        )
        return try await self.deleteTable(input, logger: logger)
    }

    /// Deletes an optimizer and all associated metadata for a table. The optimization will no longer be performed on the table.
    @Sendable
    @inlinable
    public func deleteTableOptimizer(_ input: DeleteTableOptimizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteTableOptimizerResponse {
        try await self.client.execute(
            operation: "DeleteTableOptimizer", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an optimizer and all associated metadata for a table. The optimization will no longer be performed on the table.
    ///
    /// Parameters:
    ///   - catalogId: The Catalog ID of the table.
    ///   - databaseName: The name of the database in the catalog in which the table resides.
    ///   - tableName: The name of the table.
    ///   - type: The type of table optimizer.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTableOptimizer(
        catalogId: String,
        databaseName: String,
        tableName: String,
        type: TableOptimizerType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteTableOptimizerResponse {
        let input = DeleteTableOptimizerRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            tableName: tableName, 
            type: type
        )
        return try await self.deleteTableOptimizer(input, logger: logger)
    }

    /// Deletes a specified version of a table.
    @Sendable
    @inlinable
    public func deleteTableVersion(_ input: DeleteTableVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteTableVersionResponse {
        try await self.client.execute(
            operation: "DeleteTableVersion", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specified version of a table.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    ///   - tableName: The name of the table. For Hive compatibility,  this name is entirely lowercase.
    ///   - versionId: The ID of the table version to be deleted. A VersionID is a string representation of an integer. Each version is incremented by 1.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTableVersion(
        catalogId: String? = nil,
        databaseName: String,
        tableName: String,
        versionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteTableVersionResponse {
        let input = DeleteTableVersionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            tableName: tableName, 
            versionId: versionId
        )
        return try await self.deleteTableVersion(input, logger: logger)
    }

    /// Deletes a specified trigger. If the trigger is not found, no exception is thrown.
    @Sendable
    @inlinable
    public func deleteTrigger(_ input: DeleteTriggerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteTriggerResponse {
        try await self.client.execute(
            operation: "DeleteTrigger", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a specified trigger. If the trigger is not found, no exception is thrown.
    ///
    /// Parameters:
    ///   - name: The name of the trigger to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTrigger(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteTriggerResponse {
        let input = DeleteTriggerRequest(
            name: name
        )
        return try await self.deleteTrigger(input, logger: logger)
    }

    /// Deletes the Glue specified usage profile.
    @Sendable
    @inlinable
    public func deleteUsageProfile(_ input: DeleteUsageProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteUsageProfileResponse {
        try await self.client.execute(
            operation: "DeleteUsageProfile", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the Glue specified usage profile.
    ///
    /// Parameters:
    ///   - name: The name of the usage profile to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteUsageProfile(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteUsageProfileResponse {
        let input = DeleteUsageProfileRequest(
            name: name
        )
        return try await self.deleteUsageProfile(input, logger: logger)
    }

    /// Deletes an existing function definition from the Data Catalog.
    @Sendable
    @inlinable
    public func deleteUserDefinedFunction(_ input: DeleteUserDefinedFunctionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteUserDefinedFunctionResponse {
        try await self.client.execute(
            operation: "DeleteUserDefinedFunction", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing function definition from the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the function to be deleted is located. If none is supplied, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database where the function is located.
    ///   - functionName: The name of the function definition to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteUserDefinedFunction(
        catalogId: String? = nil,
        databaseName: String,
        functionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteUserDefinedFunctionResponse {
        let input = DeleteUserDefinedFunctionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            functionName: functionName
        )
        return try await self.deleteUserDefinedFunction(input, logger: logger)
    }

    /// Deletes a workflow.
    @Sendable
    @inlinable
    public func deleteWorkflow(_ input: DeleteWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteWorkflowResponse {
        try await self.client.execute(
            operation: "DeleteWorkflow", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a workflow.
    ///
    /// Parameters:
    ///   - name: Name of the workflow to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWorkflow(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteWorkflowResponse {
        let input = DeleteWorkflowRequest(
            name: name
        )
        return try await self.deleteWorkflow(input, logger: logger)
    }

    /// The DescribeConnectionType API provides full details of the supported options for a given connection type in Glue.
    @Sendable
    @inlinable
    public func describeConnectionType(_ input: DescribeConnectionTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConnectionTypeResponse {
        try await self.client.execute(
            operation: "DescribeConnectionType", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The DescribeConnectionType API provides full details of the supported options for a given connection type in Glue.
    ///
    /// Parameters:
    ///   - connectionType: The name of the connection type to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeConnectionType(
        connectionType: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeConnectionTypeResponse {
        let input = DescribeConnectionTypeRequest(
            connectionType: connectionType
        )
        return try await self.describeConnectionType(input, logger: logger)
    }

    /// Provides details regarding the entity used with the connection type, with a description of the data model for each field in the selected entity. The response includes all the fields which make up the entity.
    @Sendable
    @inlinable
    public func describeEntity(_ input: DescribeEntityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEntityResponse {
        try await self.client.execute(
            operation: "DescribeEntity", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides details regarding the entity used with the connection type, with a description of the data model for each field in the selected entity. The response includes all the fields which make up the entity.
    ///
    /// Parameters:
    ///   - catalogId: The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon Web Services Account ID is the catalog ID.
    ///   - connectionName: The name of the connection that contains the connection type credentials.
    ///   - dataStoreApiVersion: The version of the API used for the data store.
    ///   - entityName: The name of the entity that you want to describe from the connection type.
    ///   - nextToken: A continuation token, included if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeEntity(
        catalogId: String? = nil,
        connectionName: String,
        dataStoreApiVersion: String? = nil,
        entityName: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeEntityResponse {
        let input = DescribeEntityRequest(
            catalogId: catalogId, 
            connectionName: connectionName, 
            dataStoreApiVersion: dataStoreApiVersion, 
            entityName: entityName, 
            nextToken: nextToken
        )
        return try await self.describeEntity(input, logger: logger)
    }

    /// Returns a list of inbound integrations for the specified integration.
    @Sendable
    @inlinable
    public func describeInboundIntegrations(_ input: DescribeInboundIntegrationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeInboundIntegrationsResponse {
        try await self.client.execute(
            operation: "DescribeInboundIntegrations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of inbound integrations for the specified integration.
    ///
    /// Parameters:
    ///   - integrationArn: The Amazon Resource Name (ARN) of the integration.
    ///   - marker: A token to specify where to start paginating. This is the marker from a previously truncated response.
    ///   - maxRecords: The total number of items to return in the output.
    ///   - targetArn: The Amazon Resource Name (ARN) of the target resource in the integration.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeInboundIntegrations(
        integrationArn: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        targetArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeInboundIntegrationsResponse {
        let input = DescribeInboundIntegrationsRequest(
            integrationArn: integrationArn, 
            marker: marker, 
            maxRecords: maxRecords, 
            targetArn: targetArn
        )
        return try await self.describeInboundIntegrations(input, logger: logger)
    }

    /// The API is used to retrieve a list of integrations.
    @Sendable
    @inlinable
    public func describeIntegrations(_ input: DescribeIntegrationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeIntegrationsResponse {
        try await self.client.execute(
            operation: "DescribeIntegrations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The API is used to retrieve a list of integrations.
    ///
    /// Parameters:
    ///   - filters: A list of key and values, to filter down the results. Supported keys are "Status", "IntegrationName", and "SourceArn". IntegrationName is limited to only one value.
    ///   - integrationIdentifier: The Amazon Resource Name (ARN) for the integration.
    ///   - marker: A value that indicates the starting point for the next set of response records in a subsequent request.
    ///   - maxRecords: The total number of items to return in the output.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeIntegrations(
        filters: [IntegrationFilter]? = nil,
        integrationIdentifier: String? = nil,
        marker: String? = nil,
        maxRecords: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeIntegrationsResponse {
        let input = DescribeIntegrationsRequest(
            filters: filters, 
            integrationIdentifier: integrationIdentifier, 
            marker: marker, 
            maxRecords: maxRecords
        )
        return try await self.describeIntegrations(input, logger: logger)
    }

    /// Retrieves the details of a blueprint.
    @Sendable
    @inlinable
    public func getBlueprint(_ input: GetBlueprintRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBlueprintResponse {
        try await self.client.execute(
            operation: "GetBlueprint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the details of a blueprint.
    ///
    /// Parameters:
    ///   - includeBlueprint: Specifies whether or not to include the blueprint in the response.
    ///   - includeParameterSpec: Specifies whether or not to include the parameter specification.
    ///   - name: The name of the blueprint.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBlueprint(
        includeBlueprint: Bool? = nil,
        includeParameterSpec: Bool? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBlueprintResponse {
        let input = GetBlueprintRequest(
            includeBlueprint: includeBlueprint, 
            includeParameterSpec: includeParameterSpec, 
            name: name
        )
        return try await self.getBlueprint(input, logger: logger)
    }

    /// Retrieves the details of a blueprint run.
    @Sendable
    @inlinable
    public func getBlueprintRun(_ input: GetBlueprintRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBlueprintRunResponse {
        try await self.client.execute(
            operation: "GetBlueprintRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the details of a blueprint run.
    ///
    /// Parameters:
    ///   - blueprintName: The name of the blueprint.
    ///   - runId: The run ID for the blueprint run you want to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBlueprintRun(
        blueprintName: String,
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBlueprintRunResponse {
        let input = GetBlueprintRunRequest(
            blueprintName: blueprintName, 
            runId: runId
        )
        return try await self.getBlueprintRun(input, logger: logger)
    }

    /// Retrieves the details of blueprint runs for a specified blueprint.
    @Sendable
    @inlinable
    public func getBlueprintRuns(_ input: GetBlueprintRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBlueprintRunsResponse {
        try await self.client.execute(
            operation: "GetBlueprintRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the details of blueprint runs for a specified blueprint.
    ///
    /// Parameters:
    ///   - blueprintName: The name of the blueprint.
    ///   - maxResults: The maximum size of a list to return.
    ///   - nextToken: A continuation token, if this is a continuation request.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBlueprintRuns(
        blueprintName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBlueprintRunsResponse {
        let input = GetBlueprintRunsRequest(
            blueprintName: blueprintName, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getBlueprintRuns(input, logger: logger)
    }

    /// The name of the Catalog to retrieve. This should be all lowercase.
    @Sendable
    @inlinable
    public func getCatalog(_ input: GetCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCatalogResponse {
        try await self.client.execute(
            operation: "GetCatalog", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The name of the Catalog to retrieve. This should be all lowercase.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the parent catalog in which the catalog resides. If none is provided, the Amazon Web Services Account Number is used by default.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCatalog(
        catalogId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCatalogResponse {
        let input = GetCatalogRequest(
            catalogId: catalogId
        )
        return try await self.getCatalog(input, logger: logger)
    }

    /// Retrieves the status of a migration operation.
    @Sendable
    @inlinable
    public func getCatalogImportStatus(_ input: GetCatalogImportStatusRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCatalogImportStatusResponse {
        try await self.client.execute(
            operation: "GetCatalogImportStatus", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the status of a migration operation.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the catalog to migrate. Currently, this should be the Amazon Web Services account ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCatalogImportStatus(
        catalogId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCatalogImportStatusResponse {
        let input = GetCatalogImportStatusRequest(
            catalogId: catalogId
        )
        return try await self.getCatalogImportStatus(input, logger: logger)
    }

    /// Retrieves all catalogs defined in a catalog in the Glue Data Catalog. For a Redshift-federated catalog use case, this operation returns the list of catalogs mapped to Redshift databases in the Redshift namespace catalog.
    @Sendable
    @inlinable
    public func getCatalogs(_ input: GetCatalogsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCatalogsResponse {
        try await self.client.execute(
            operation: "GetCatalogs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves all catalogs defined in a catalog in the Glue Data Catalog. For a Redshift-federated catalog use case, this operation returns the list of catalogs mapped to Redshift databases in the Redshift namespace catalog.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of catalogs to return in one response.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - parentCatalogId: The ID of the parent catalog in which the catalog resides. If none is provided, the Amazon Web Services Account Number is used by default.
    ///   - recursive: When specified as true, iterates through the account and returns all catalog resources (including top-level resources and child resources)
    ///   - logger: Logger use during operation
    @inlinable
    public func getCatalogs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        parentCatalogId: String? = nil,
        recursive: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCatalogsResponse {
        let input = GetCatalogsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            parentCatalogId: parentCatalogId, 
            recursive: recursive
        )
        return try await self.getCatalogs(input, logger: logger)
    }

    /// Retrieve a classifier by name.
    @Sendable
    @inlinable
    public func getClassifier(_ input: GetClassifierRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetClassifierResponse {
        try await self.client.execute(
            operation: "GetClassifier", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a classifier by name.
    ///
    /// Parameters:
    ///   - name: Name of the classifier to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getClassifier(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetClassifierResponse {
        let input = GetClassifierRequest(
            name: name
        )
        return try await self.getClassifier(input, logger: logger)
    }

    /// Lists all classifier objects in the Data Catalog.
    @Sendable
    @inlinable
    public func getClassifiers(_ input: GetClassifiersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetClassifiersResponse {
        try await self.client.execute(
            operation: "GetClassifiers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all classifier objects in the Data Catalog.
    ///
    /// Parameters:
    ///   - maxResults: The size of the list to return (optional).
    ///   - nextToken: An optional continuation token.
    ///   - logger: Logger use during operation
    @inlinable
    public func getClassifiers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetClassifiersResponse {
        let input = GetClassifiersRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getClassifiers(input, logger: logger)
    }

    /// Retrieves partition statistics of columns. The Identity and Access Management (IAM) permission required for this operation is GetPartition.
    @Sendable
    @inlinable
    public func getColumnStatisticsForPartition(_ input: GetColumnStatisticsForPartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetColumnStatisticsForPartitionResponse {
        try await self.client.execute(
            operation: "GetColumnStatisticsForPartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves partition statistics of columns. The Identity and Access Management (IAM) permission required for this operation is GetPartition.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    ///   - columnNames: A list of the column names.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - partitionValues: A list of partition values identifying the partition.
    ///   - tableName: The name of the partitions' table.
    ///   - logger: Logger use during operation
    @inlinable
    public func getColumnStatisticsForPartition(
        catalogId: String? = nil,
        columnNames: [String],
        databaseName: String,
        partitionValues: [String],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetColumnStatisticsForPartitionResponse {
        let input = GetColumnStatisticsForPartitionRequest(
            catalogId: catalogId, 
            columnNames: columnNames, 
            databaseName: databaseName, 
            partitionValues: partitionValues, 
            tableName: tableName
        )
        return try await self.getColumnStatisticsForPartition(input, logger: logger)
    }

    /// Retrieves table statistics of columns. The Identity and Access Management (IAM) permission required for this operation is GetTable.
    @Sendable
    @inlinable
    public func getColumnStatisticsForTable(_ input: GetColumnStatisticsForTableRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetColumnStatisticsForTableResponse {
        try await self.client.execute(
            operation: "GetColumnStatisticsForTable", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves table statistics of columns. The Identity and Access Management (IAM) permission required for this operation is GetTable.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    ///   - columnNames: A list of the column names.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - tableName: The name of the partitions' table.
    ///   - logger: Logger use during operation
    @inlinable
    public func getColumnStatisticsForTable(
        catalogId: String? = nil,
        columnNames: [String],
        databaseName: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetColumnStatisticsForTableResponse {
        let input = GetColumnStatisticsForTableRequest(
            catalogId: catalogId, 
            columnNames: columnNames, 
            databaseName: databaseName, 
            tableName: tableName
        )
        return try await self.getColumnStatisticsForTable(input, logger: logger)
    }

    /// Get the associated metadata/information for a task run, given a task run ID.
    @Sendable
    @inlinable
    public func getColumnStatisticsTaskRun(_ input: GetColumnStatisticsTaskRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetColumnStatisticsTaskRunResponse {
        try await self.client.execute(
            operation: "GetColumnStatisticsTaskRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get the associated metadata/information for a task run, given a task run ID.
    ///
    /// Parameters:
    ///   - columnStatisticsTaskRunId: The identifier for the particular column statistics task run.
    ///   - logger: Logger use during operation
    @inlinable
    public func getColumnStatisticsTaskRun(
        columnStatisticsTaskRunId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetColumnStatisticsTaskRunResponse {
        let input = GetColumnStatisticsTaskRunRequest(
            columnStatisticsTaskRunId: columnStatisticsTaskRunId
        )
        return try await self.getColumnStatisticsTaskRun(input, logger: logger)
    }

    /// Retrieves information about all runs associated with the specified table.
    @Sendable
    @inlinable
    public func getColumnStatisticsTaskRuns(_ input: GetColumnStatisticsTaskRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetColumnStatisticsTaskRunsResponse {
        try await self.client.execute(
            operation: "GetColumnStatisticsTaskRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about all runs associated with the specified table.
    ///
    /// Parameters:
    ///   - databaseName: The name of the database where the table resides.
    ///   - maxResults: The maximum size of the response.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - tableName: The name of the table.
    ///   - logger: Logger use during operation
    @inlinable
    public func getColumnStatisticsTaskRuns(
        databaseName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetColumnStatisticsTaskRunsResponse {
        let input = GetColumnStatisticsTaskRunsRequest(
            databaseName: databaseName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            tableName: tableName
        )
        return try await self.getColumnStatisticsTaskRuns(input, logger: logger)
    }

    /// Gets settings for a column statistics task.
    @Sendable
    @inlinable
    public func getColumnStatisticsTaskSettings(_ input: GetColumnStatisticsTaskSettingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetColumnStatisticsTaskSettingsResponse {
        try await self.client.execute(
            operation: "GetColumnStatisticsTaskSettings", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets settings for a column statistics task.
    ///
    /// Parameters:
    ///   - databaseName: The name of the database where the table resides.
    ///   - tableName: The name of the table for which to retrieve column statistics.
    ///   - logger: Logger use during operation
    @inlinable
    public func getColumnStatisticsTaskSettings(
        databaseName: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetColumnStatisticsTaskSettingsResponse {
        let input = GetColumnStatisticsTaskSettingsRequest(
            databaseName: databaseName, 
            tableName: tableName
        )
        return try await self.getColumnStatisticsTaskSettings(input, logger: logger)
    }

    /// Retrieves a connection definition from the Data Catalog.
    @Sendable
    @inlinable
    public func getConnection(_ input: GetConnectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetConnectionResponse {
        try await self.client.execute(
            operation: "GetConnection", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a connection definition from the Data Catalog.
    ///
    /// Parameters:
    ///   - applyOverrideForComputeEnvironment: For connections that may be used in multiple services, specifies returning properties for the specified compute environment.
    ///   - catalogId: The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - hidePassword: Allows you to retrieve the connection metadata without returning the password. For instance, the Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the KMS key to decrypt the password, but it does have permission to access the rest of the connection properties.
    ///   - name: The name of the connection definition to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getConnection(
        applyOverrideForComputeEnvironment: ComputeEnvironment? = nil,
        catalogId: String? = nil,
        hidePassword: Bool? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetConnectionResponse {
        let input = GetConnectionRequest(
            applyOverrideForComputeEnvironment: applyOverrideForComputeEnvironment, 
            catalogId: catalogId, 
            hidePassword: hidePassword, 
            name: name
        )
        return try await self.getConnection(input, logger: logger)
    }

    /// Retrieves a list of connection definitions from the Data Catalog.
    @Sendable
    @inlinable
    public func getConnections(_ input: GetConnectionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetConnectionsResponse {
        try await self.client.execute(
            operation: "GetConnections", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of connection definitions from the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - filter: A filter that controls which connections are returned.
    ///   - hidePassword: Allows you to retrieve the connection metadata without returning the password. For instance, the Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the KMS key to decrypt the password, but it does have permission to access the rest of the connection properties.
    ///   - maxResults: The maximum number of connections to return in one response.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func getConnections(
        catalogId: String? = nil,
        filter: GetConnectionsFilter? = nil,
        hidePassword: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetConnectionsResponse {
        let input = GetConnectionsRequest(
            catalogId: catalogId, 
            filter: filter, 
            hidePassword: hidePassword, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getConnections(input, logger: logger)
    }

    /// Retrieves metadata for a specified crawler.
    @Sendable
    @inlinable
    public func getCrawler(_ input: GetCrawlerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCrawlerResponse {
        try await self.client.execute(
            operation: "GetCrawler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves metadata for a specified crawler.
    ///
    /// Parameters:
    ///   - name: The name of the crawler to retrieve metadata for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCrawler(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCrawlerResponse {
        let input = GetCrawlerRequest(
            name: name
        )
        return try await self.getCrawler(input, logger: logger)
    }

    /// Retrieves metrics about specified crawlers.
    @Sendable
    @inlinable
    public func getCrawlerMetrics(_ input: GetCrawlerMetricsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCrawlerMetricsResponse {
        try await self.client.execute(
            operation: "GetCrawlerMetrics", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves metrics about specified crawlers.
    ///
    /// Parameters:
    ///   - crawlerNameList: A list of the names of crawlers about which to retrieve metrics.
    ///   - maxResults: The maximum size of a list to return.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCrawlerMetrics(
        crawlerNameList: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCrawlerMetricsResponse {
        let input = GetCrawlerMetricsRequest(
            crawlerNameList: crawlerNameList, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getCrawlerMetrics(input, logger: logger)
    }

    /// Retrieves metadata for all crawlers defined in the customer account.
    @Sendable
    @inlinable
    public func getCrawlers(_ input: GetCrawlersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCrawlersResponse {
        try await self.client.execute(
            operation: "GetCrawlers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves metadata for all crawlers defined in the customer account.
    ///
    /// Parameters:
    ///   - maxResults: The number of crawlers to return on each call.
    ///   - nextToken: A continuation token, if this is a continuation request.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCrawlers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCrawlersResponse {
        let input = GetCrawlersRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getCrawlers(input, logger: logger)
    }

    /// Retrieves the details of a custom pattern by specifying its name.
    @Sendable
    @inlinable
    public func getCustomEntityType(_ input: GetCustomEntityTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCustomEntityTypeResponse {
        try await self.client.execute(
            operation: "GetCustomEntityType", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the details of a custom pattern by specifying its name.
    ///
    /// Parameters:
    ///   - name: The name of the custom pattern that you want to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCustomEntityType(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCustomEntityTypeResponse {
        let input = GetCustomEntityTypeRequest(
            name: name
        )
        return try await self.getCustomEntityType(input, logger: logger)
    }

    /// Retrieves the security configuration for a specified catalog.
    @Sendable
    @inlinable
    public func getDataCatalogEncryptionSettings(_ input: GetDataCatalogEncryptionSettingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataCatalogEncryptionSettingsResponse {
        try await self.client.execute(
            operation: "GetDataCatalogEncryptionSettings", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the security configuration for a specified catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog to retrieve the security configuration for. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataCatalogEncryptionSettings(
        catalogId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataCatalogEncryptionSettingsResponse {
        let input = GetDataCatalogEncryptionSettingsRequest(
            catalogId: catalogId
        )
        return try await self.getDataCatalogEncryptionSettings(input, logger: logger)
    }

    /// Retrieve the training status of the model along with more information (CompletedOn, StartedOn, FailureReason).
    @Sendable
    @inlinable
    public func getDataQualityModel(_ input: GetDataQualityModelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataQualityModelResponse {
        try await self.client.execute(
            operation: "GetDataQualityModel", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the training status of the model along with more information (CompletedOn, StartedOn, FailureReason).
    ///
    /// Parameters:
    ///   - profileId: The Profile ID.
    ///   - statisticId: The Statistic ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataQualityModel(
        profileId: String,
        statisticId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataQualityModelResponse {
        let input = GetDataQualityModelRequest(
            profileId: profileId, 
            statisticId: statisticId
        )
        return try await self.getDataQualityModel(input, logger: logger)
    }

    /// Retrieve a statistic's predictions for a given Profile ID.
    @Sendable
    @inlinable
    public func getDataQualityModelResult(_ input: GetDataQualityModelResultRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataQualityModelResultResponse {
        try await self.client.execute(
            operation: "GetDataQualityModelResult", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a statistic's predictions for a given Profile ID.
    ///
    /// Parameters:
    ///   - profileId: The Profile ID.
    ///   - statisticId: The Statistic ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataQualityModelResult(
        profileId: String,
        statisticId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataQualityModelResultResponse {
        let input = GetDataQualityModelResultRequest(
            profileId: profileId, 
            statisticId: statisticId
        )
        return try await self.getDataQualityModelResult(input, logger: logger)
    }

    /// Retrieves the result of a data quality rule evaluation.
    @Sendable
    @inlinable
    public func getDataQualityResult(_ input: GetDataQualityResultRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataQualityResultResponse {
        try await self.client.execute(
            operation: "GetDataQualityResult", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the result of a data quality rule evaluation.
    ///
    /// Parameters:
    ///   - resultId: A unique result ID for the data quality result.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataQualityResult(
        resultId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataQualityResultResponse {
        let input = GetDataQualityResultRequest(
            resultId: resultId
        )
        return try await self.getDataQualityResult(input, logger: logger)
    }

    /// Gets the specified recommendation run that was used to generate rules.
    @Sendable
    @inlinable
    public func getDataQualityRuleRecommendationRun(_ input: GetDataQualityRuleRecommendationRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataQualityRuleRecommendationRunResponse {
        try await self.client.execute(
            operation: "GetDataQualityRuleRecommendationRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the specified recommendation run that was used to generate rules.
    ///
    /// Parameters:
    ///   - runId: The unique run identifier associated with this run.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataQualityRuleRecommendationRun(
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataQualityRuleRecommendationRunResponse {
        let input = GetDataQualityRuleRecommendationRunRequest(
            runId: runId
        )
        return try await self.getDataQualityRuleRecommendationRun(input, logger: logger)
    }

    /// Returns an existing ruleset by identifier or name.
    @Sendable
    @inlinable
    public func getDataQualityRuleset(_ input: GetDataQualityRulesetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataQualityRulesetResponse {
        try await self.client.execute(
            operation: "GetDataQualityRuleset", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns an existing ruleset by identifier or name.
    ///
    /// Parameters:
    ///   - name: The name of the ruleset.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataQualityRuleset(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataQualityRulesetResponse {
        let input = GetDataQualityRulesetRequest(
            name: name
        )
        return try await self.getDataQualityRuleset(input, logger: logger)
    }

    /// Retrieves a specific run where a ruleset is evaluated against a data source.
    @Sendable
    @inlinable
    public func getDataQualityRulesetEvaluationRun(_ input: GetDataQualityRulesetEvaluationRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataQualityRulesetEvaluationRunResponse {
        try await self.client.execute(
            operation: "GetDataQualityRulesetEvaluationRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a specific run where a ruleset is evaluated against a data source.
    ///
    /// Parameters:
    ///   - runId: The unique run identifier associated with this run.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataQualityRulesetEvaluationRun(
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataQualityRulesetEvaluationRunResponse {
        let input = GetDataQualityRulesetEvaluationRunRequest(
            runId: runId
        )
        return try await self.getDataQualityRulesetEvaluationRun(input, logger: logger)
    }

    /// Retrieves the definition of a specified database.
    @Sendable
    @inlinable
    public func getDatabase(_ input: GetDatabaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDatabaseResponse {
        try await self.client.execute(
            operation: "GetDatabase", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the definition of a specified database.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - name: The name of the database to retrieve. For Hive compatibility, this  should be all lowercase.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDatabase(
        catalogId: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDatabaseResponse {
        let input = GetDatabaseRequest(
            catalogId: catalogId, 
            name: name
        )
        return try await self.getDatabase(input, logger: logger)
    }

    /// Retrieves all databases defined in a given Data Catalog.
    @Sendable
    @inlinable
    public func getDatabases(_ input: GetDatabasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDatabasesResponse {
        try await self.client.execute(
            operation: "GetDatabases", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves all databases defined in a given Data Catalog.
    ///
    /// Parameters:
    ///   - attributesToGet: Specifies the database fields returned by the GetDatabases call. This parameter doesn’t accept an empty list. The request must include the NAME.
    ///   - catalogId: The ID of the Data Catalog from which to retrieve Databases. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - maxResults: The maximum number of databases to return in one response.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - resourceShareType: Allows you to specify that you want to list the databases shared with your account. The allowable values are FEDERATED, FOREIGN or ALL.    If set to FEDERATED, will list the federated databases (referencing an external entity) shared with your account.   If set to FOREIGN, will list the databases shared with your account.    If set to ALL, will list the databases shared with your account, as well as the databases in yor local account.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDatabases(
        attributesToGet: [DatabaseAttributes]? = nil,
        catalogId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceShareType: ResourceShareType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDatabasesResponse {
        let input = GetDatabasesRequest(
            attributesToGet: attributesToGet, 
            catalogId: catalogId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceShareType: resourceShareType
        )
        return try await self.getDatabases(input, logger: logger)
    }

    /// Transforms a Python script into a directed acyclic graph (DAG).
    @Sendable
    @inlinable
    public func getDataflowGraph(_ input: GetDataflowGraphRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDataflowGraphResponse {
        try await self.client.execute(
            operation: "GetDataflowGraph", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Transforms a Python script into a directed acyclic graph (DAG).
    ///
    /// Parameters:
    ///   - pythonScript: The Python script to transform.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDataflowGraph(
        pythonScript: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDataflowGraphResponse {
        let input = GetDataflowGraphRequest(
            pythonScript: pythonScript
        )
        return try await self.getDataflowGraph(input, logger: logger)
    }

    /// Retrieves information about a specified development endpoint.  When you create a development endpoint in a virtual private cloud (VPC), Glue returns only a private IP address, and the public IP address field is not populated. When you create a non-VPC development endpoint, Glue returns only a public IP address.
    @Sendable
    @inlinable
    public func getDevEndpoint(_ input: GetDevEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDevEndpointResponse {
        try await self.client.execute(
            operation: "GetDevEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a specified development endpoint.  When you create a development endpoint in a virtual private cloud (VPC), Glue returns only a private IP address, and the public IP address field is not populated. When you create a non-VPC development endpoint, Glue returns only a public IP address.
    ///
    /// Parameters:
    ///   - endpointName: Name of the DevEndpoint to retrieve information for.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDevEndpoint(
        endpointName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDevEndpointResponse {
        let input = GetDevEndpointRequest(
            endpointName: endpointName
        )
        return try await self.getDevEndpoint(input, logger: logger)
    }

    /// Retrieves all the development endpoints in this Amazon Web Services account.  When you create a development endpoint in a virtual private cloud (VPC), Glue returns only a private IP address and the public IP address field is not populated. When you create a non-VPC development endpoint, Glue returns only a public IP address.
    @Sendable
    @inlinable
    public func getDevEndpoints(_ input: GetDevEndpointsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDevEndpointsResponse {
        try await self.client.execute(
            operation: "GetDevEndpoints", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves all the development endpoints in this Amazon Web Services account.  When you create a development endpoint in a virtual private cloud (VPC), Glue returns only a private IP address and the public IP address field is not populated. When you create a non-VPC development endpoint, Glue returns only a public IP address.
    ///
    /// Parameters:
    ///   - maxResults: The maximum size of information to return.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDevEndpoints(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDevEndpointsResponse {
        let input = GetDevEndpointsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getDevEndpoints(input, logger: logger)
    }

    /// This API is used to query preview data from a given connection type or from a native Amazon S3 based Glue Data Catalog. Returns records as an array of JSON blobs. Each record is formatted using Jackson JsonNode based on the field type defined by the DescribeEntity API. Spark connectors generate schemas according to the same data type mapping as in the DescribeEntity API. Spark connectors convert data to the appropriate data types matching the schema when returning rows.
    @Sendable
    @inlinable
    public func getEntityRecords(_ input: GetEntityRecordsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEntityRecordsResponse {
        try await self.client.execute(
            operation: "GetEntityRecords", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// This API is used to query preview data from a given connection type or from a native Amazon S3 based Glue Data Catalog. Returns records as an array of JSON blobs. Each record is formatted using Jackson JsonNode based on the field type defined by the DescribeEntity API. Spark connectors generate schemas according to the same data type mapping as in the DescribeEntity API. Spark connectors convert data to the appropriate data types matching the schema when returning rows.
    ///
    /// Parameters:
    ///   - catalogId: The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon Web Services Account ID is the catalog ID.
    ///   - connectionName: The name of the connection that contains the connection type credentials.
    ///   - connectionOptions: Connector options that are required to query the data.
    ///   - dataStoreApiVersion: The API version of the SaaS connector.
    ///   - entityName: Name of the entity that we want to query the preview data from the given connection type.
    ///   - filterPredicate: A filter predicate that you can apply in the query request.
    ///   - limit: Limits the number of records fetched with the request.
    ///   - nextToken: A continuation token, included if this is a continuation call.
    ///   - orderBy: A parameter that orders the response preview data.
    ///   - selectedFields:  List of fields that we want to fetch as part of preview data.
    ///   - logger: Logger use during operation
    @inlinable
    public func getEntityRecords(
        catalogId: String? = nil,
        connectionName: String? = nil,
        connectionOptions: [String: String]? = nil,
        dataStoreApiVersion: String? = nil,
        entityName: String,
        filterPredicate: String? = nil,
        limit: Int64,
        nextToken: String? = nil,
        orderBy: String? = nil,
        selectedFields: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEntityRecordsResponse {
        let input = GetEntityRecordsRequest(
            catalogId: catalogId, 
            connectionName: connectionName, 
            connectionOptions: connectionOptions, 
            dataStoreApiVersion: dataStoreApiVersion, 
            entityName: entityName, 
            filterPredicate: filterPredicate, 
            limit: limit, 
            nextToken: nextToken, 
            orderBy: orderBy, 
            selectedFields: selectedFields
        )
        return try await self.getEntityRecords(input, logger: logger)
    }

    /// This API is used for fetching the ResourceProperty of the Glue connection (for the source) or Glue database ARN (for the target)
    @Sendable
    @inlinable
    public func getIntegrationResourceProperty(_ input: GetIntegrationResourcePropertyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIntegrationResourcePropertyResponse {
        try await self.client.execute(
            operation: "GetIntegrationResourceProperty", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// This API is used for fetching the ResourceProperty of the Glue connection (for the source) or Glue database ARN (for the target)
    ///
    /// Parameters:
    ///   - resourceArn: The connection ARN of the source, or the database ARN of the target.
    ///   - logger: Logger use during operation
    @inlinable
    public func getIntegrationResourceProperty(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIntegrationResourcePropertyResponse {
        let input = GetIntegrationResourcePropertyRequest(
            resourceArn: resourceArn
        )
        return try await self.getIntegrationResourceProperty(input, logger: logger)
    }

    /// This API is used to retrieve optional override properties for the tables that need to be replicated. These properties can include properties for filtering and partition for source and target tables.
    @Sendable
    @inlinable
    public func getIntegrationTableProperties(_ input: GetIntegrationTablePropertiesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIntegrationTablePropertiesResponse {
        try await self.client.execute(
            operation: "GetIntegrationTableProperties", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// This API is used to retrieve optional override properties for the tables that need to be replicated. These properties can include properties for filtering and partition for source and target tables.
    ///
    /// Parameters:
    ///   - resourceArn: The connection ARN of the source, or the database ARN of the target.
    ///   - tableName: The name of the table to be replicated.
    ///   - logger: Logger use during operation
    @inlinable
    public func getIntegrationTableProperties(
        resourceArn: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIntegrationTablePropertiesResponse {
        let input = GetIntegrationTablePropertiesRequest(
            resourceArn: resourceArn, 
            tableName: tableName
        )
        return try await self.getIntegrationTableProperties(input, logger: logger)
    }

    /// Retrieves an existing job definition.
    @Sendable
    @inlinable
    public func getJob(_ input: GetJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetJobResponse {
        try await self.client.execute(
            operation: "GetJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves an existing job definition.
    ///
    /// Parameters:
    ///   - jobName: The name of the job definition to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getJob(
        jobName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetJobResponse {
        let input = GetJobRequest(
            jobName: jobName
        )
        return try await self.getJob(input, logger: logger)
    }

    /// Returns information on a job bookmark entry. For more information about enabling and using job bookmarks, see:    Tracking processed data using job bookmarks     Job parameters used by Glue     Job structure
    @Sendable
    @inlinable
    public func getJobBookmark(_ input: GetJobBookmarkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetJobBookmarkResponse {
        try await self.client.execute(
            operation: "GetJobBookmark", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information on a job bookmark entry. For more information about enabling and using job bookmarks, see:    Tracking processed data using job bookmarks     Job parameters used by Glue     Job structure
    ///
    /// Parameters:
    ///   - jobName: The name of the job in question.
    ///   - runId: The unique run identifier associated with this job run.
    ///   - logger: Logger use during operation
    @inlinable
    public func getJobBookmark(
        jobName: String,
        runId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetJobBookmarkResponse {
        let input = GetJobBookmarkRequest(
            jobName: jobName, 
            runId: runId
        )
        return try await self.getJobBookmark(input, logger: logger)
    }

    /// Retrieves the metadata for a given job run. Job run history is accessible for 90 days for your workflow and job run.
    @Sendable
    @inlinable
    public func getJobRun(_ input: GetJobRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetJobRunResponse {
        try await self.client.execute(
            operation: "GetJobRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the metadata for a given job run. Job run history is accessible for 90 days for your workflow and job run.
    ///
    /// Parameters:
    ///   - jobName: Name of the job definition being run.
    ///   - predecessorsIncluded: True if a list of predecessor runs should be returned.
    ///   - runId: The ID of the job run.
    ///   - logger: Logger use during operation
    @inlinable
    public func getJobRun(
        jobName: String,
        predecessorsIncluded: Bool? = nil,
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetJobRunResponse {
        let input = GetJobRunRequest(
            jobName: jobName, 
            predecessorsIncluded: predecessorsIncluded, 
            runId: runId
        )
        return try await self.getJobRun(input, logger: logger)
    }

    /// Retrieves metadata for all runs of a given job definition.
    @Sendable
    @inlinable
    public func getJobRuns(_ input: GetJobRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetJobRunsResponse {
        try await self.client.execute(
            operation: "GetJobRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves metadata for all runs of a given job definition.
    ///
    /// Parameters:
    ///   - jobName: The name of the job definition for which to retrieve all job runs.
    ///   - maxResults: The maximum size of the response.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func getJobRuns(
        jobName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetJobRunsResponse {
        let input = GetJobRunsRequest(
            jobName: jobName, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getJobRuns(input, logger: logger)
    }

    /// Retrieves all current job definitions.
    @Sendable
    @inlinable
    public func getJobs(_ input: GetJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetJobsResponse {
        try await self.client.execute(
            operation: "GetJobs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves all current job definitions.
    ///
    /// Parameters:
    ///   - maxResults: The maximum size of the response.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func getJobs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetJobsResponse {
        let input = GetJobsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getJobs(input, logger: logger)
    }

    /// Gets details for a specific task run on a machine learning transform. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can check the stats of any task run by calling GetMLTaskRun with the TaskRunID and its parent transform's TransformID.
    @Sendable
    @inlinable
    public func getMLTaskRun(_ input: GetMLTaskRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMLTaskRunResponse {
        try await self.client.execute(
            operation: "GetMLTaskRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets details for a specific task run on a machine learning transform. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can check the stats of any task run by calling GetMLTaskRun with the TaskRunID and its parent transform's TransformID.
    ///
    /// Parameters:
    ///   - taskRunId: The unique identifier of the task run.
    ///   - transformId: The unique identifier of the machine learning transform.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMLTaskRun(
        taskRunId: String,
        transformId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMLTaskRunResponse {
        let input = GetMLTaskRunRequest(
            taskRunId: taskRunId, 
            transformId: transformId
        )
        return try await self.getMLTaskRun(input, logger: logger)
    }

    /// Gets a list of runs for a machine learning transform. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can get a sortable, filterable list of machine learning task runs by calling GetMLTaskRuns with their parent transform's TransformID and other optional parameters as documented in this section. This operation returns a list of historic runs and must be paginated.
    @Sendable
    @inlinable
    public func getMLTaskRuns(_ input: GetMLTaskRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMLTaskRunsResponse {
        try await self.client.execute(
            operation: "GetMLTaskRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a list of runs for a machine learning transform. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can get a sortable, filterable list of machine learning task runs by calling GetMLTaskRuns with their parent transform's TransformID and other optional parameters as documented in this section. This operation returns a list of historic runs and must be paginated.
    ///
    /// Parameters:
    ///   - filter: The filter criteria, in the TaskRunFilterCriteria structure, for the task run.
    ///   - maxResults: The maximum number of results to return.
    ///   - nextToken: A token for pagination of the results. The default is empty.
    ///   - sort: The sorting criteria, in the TaskRunSortCriteria structure, for the task run.
    ///   - transformId: The unique identifier of the machine learning transform.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMLTaskRuns(
        filter: TaskRunFilterCriteria? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: TaskRunSortCriteria? = nil,
        transformId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMLTaskRunsResponse {
        let input = GetMLTaskRunsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sort: sort, 
            transformId: transformId
        )
        return try await self.getMLTaskRuns(input, logger: logger)
    }

    /// Gets an Glue machine learning transform artifact and all its corresponding metadata. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue. You can retrieve their metadata by calling GetMLTransform.
    @Sendable
    @inlinable
    public func getMLTransform(_ input: GetMLTransformRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMLTransformResponse {
        try await self.client.execute(
            operation: "GetMLTransform", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets an Glue machine learning transform artifact and all its corresponding metadata. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue. You can retrieve their metadata by calling GetMLTransform.
    ///
    /// Parameters:
    ///   - transformId: The unique identifier of the transform, generated at the time that the transform was created.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMLTransform(
        transformId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMLTransformResponse {
        let input = GetMLTransformRequest(
            transformId: transformId
        )
        return try await self.getMLTransform(input, logger: logger)
    }

    /// Gets a sortable, filterable list of existing Glue machine learning transforms. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue, and you can retrieve their metadata by calling GetMLTransforms.
    @Sendable
    @inlinable
    public func getMLTransforms(_ input: GetMLTransformsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMLTransformsResponse {
        try await self.client.execute(
            operation: "GetMLTransforms", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a sortable, filterable list of existing Glue machine learning transforms. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue, and you can retrieve their metadata by calling GetMLTransforms.
    ///
    /// Parameters:
    ///   - filter: The filter transformation criteria.
    ///   - maxResults: The maximum number of results to return.
    ///   - nextToken: A paginated token to offset the results.
    ///   - sort: The sorting criteria.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMLTransforms(
        filter: TransformFilterCriteria? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: TransformSortCriteria? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMLTransformsResponse {
        let input = GetMLTransformsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sort: sort
        )
        return try await self.getMLTransforms(input, logger: logger)
    }

    /// Creates mappings.
    @Sendable
    @inlinable
    public func getMapping(_ input: GetMappingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMappingResponse {
        try await self.client.execute(
            operation: "GetMapping", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates mappings.
    ///
    /// Parameters:
    ///   - location: Parameters for the mapping.
    ///   - sinks: A list of target tables.
    ///   - source: Specifies the source table.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMapping(
        location: Location? = nil,
        sinks: [CatalogEntry]? = nil,
        source: CatalogEntry,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMappingResponse {
        let input = GetMappingRequest(
            location: location, 
            sinks: sinks, 
            source: source
        )
        return try await self.getMapping(input, logger: logger)
    }

    /// Retrieves information about a specified partition.
    @Sendable
    @inlinable
    public func getPartition(_ input: GetPartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPartitionResponse {
        try await self.client.execute(
            operation: "GetPartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a specified partition.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database where the partition resides.
    ///   - partitionValues: The values that define the partition.
    ///   - tableName: The name of the partition's table.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPartition(
        catalogId: String? = nil,
        databaseName: String,
        partitionValues: [String],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPartitionResponse {
        let input = GetPartitionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            partitionValues: partitionValues, 
            tableName: tableName
        )
        return try await self.getPartition(input, logger: logger)
    }

    /// Retrieves the partition indexes associated with a table.
    @Sendable
    @inlinable
    public func getPartitionIndexes(_ input: GetPartitionIndexesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPartitionIndexesResponse {
        try await self.client.execute(
            operation: "GetPartitionIndexes", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the partition indexes associated with a table.
    ///
    /// Parameters:
    ///   - catalogId: The catalog ID where the table resides.
    ///   - databaseName: Specifies the name of a database from which you want to retrieve partition indexes.
    ///   - nextToken: A continuation token, included if this is a continuation call.
    ///   - tableName: Specifies the name of a table for which you want to retrieve the partition indexes.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPartitionIndexes(
        catalogId: String? = nil,
        databaseName: String,
        nextToken: String? = nil,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPartitionIndexesResponse {
        let input = GetPartitionIndexesRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            nextToken: nextToken, 
            tableName: tableName
        )
        return try await self.getPartitionIndexes(input, logger: logger)
    }

    /// Retrieves information about the partitions in a table.
    @Sendable
    @inlinable
    public func getPartitions(_ input: GetPartitionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPartitionsResponse {
        try await self.client.execute(
            operation: "GetPartitions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about the partitions in a table.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - excludeColumnSchema: When true, specifies not returning the partition column schema. Useful when you are interested only in other partition attributes such as partition values or location. This approach avoids the problem of a large response by not returning duplicate data.
    ///   - expression: An expression that filters the partitions to be returned. The expression uses SQL syntax similar to the SQL WHERE filter clause. The SQL statement parser JSQLParser parses the expression.   Operators: The following are the operators that you can use in the Expression API call:  =  Checks whether the values of the two operands are equal; if yes, then the condition becomes true. Example: Assume 'variable a' holds 10 and 'variable b' holds 20.  (a = b) is not true.    Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true. Example: (a  b) is true.  >  Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true. Example: (a > b) is not true.    Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true. Example: (a   >=  Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a >= b) is not true.    Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a   AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL  Logical operators.    Supported Partition Key Types: The following are the supported partition keys.    string     date     timestamp     int     bigint     long     tinyint     smallint     decimal    If an type is encountered that is not valid, an exception is thrown.  The following list shows the valid operators on each type. When you define a crawler, the partitionKey type is created as a STRING, to be compatible with the catalog partitions.   Sample API Call:
    ///   - maxResults: The maximum number of partitions to return in a single response.
    ///   - nextToken: A continuation token, if this is not the first call to retrieve these partitions.
    ///   - queryAsOfTime: The time as of when to read the partition contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
    ///   - segment: The segment of the table's partitions to scan in this request.
    ///   - tableName: The name of the partitions' table.
    ///   - transactionId: The transaction ID at which to read the partition contents.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPartitions(
        catalogId: String? = nil,
        databaseName: String,
        excludeColumnSchema: Bool? = nil,
        expression: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queryAsOfTime: Date? = nil,
        segment: Segment? = nil,
        tableName: String,
        transactionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPartitionsResponse {
        let input = GetPartitionsRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            excludeColumnSchema: excludeColumnSchema, 
            expression: expression, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queryAsOfTime: queryAsOfTime, 
            segment: segment, 
            tableName: tableName, 
            transactionId: transactionId
        )
        return try await self.getPartitions(input, logger: logger)
    }

    /// Gets code to perform a specified mapping.
    @Sendable
    @inlinable
    public func getPlan(_ input: GetPlanRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPlanResponse {
        try await self.client.execute(
            operation: "GetPlan", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets code to perform a specified mapping.
    ///
    /// Parameters:
    ///   - additionalPlanOptionsMap: A map to hold additional optional key-value parameters. Currently, these key-value pairs are supported:    inferSchema  —  Specifies whether to set inferSchema to true or false for the default script generated by an Glue job. For example, to set inferSchema to true, pass the following key value pair:  --additional-plan-options-map '{"inferSchema":"true"}'
    ///   - language: The programming language of the code to perform the mapping.
    ///   - location: The parameters for the mapping.
    ///   - mapping: The list of mappings from a source table to target tables.
    ///   - sinks: The target tables.
    ///   - source: The source table.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPlan(
        additionalPlanOptionsMap: [String: String]? = nil,
        language: Language? = nil,
        location: Location? = nil,
        mapping: [MappingEntry],
        sinks: [CatalogEntry]? = nil,
        source: CatalogEntry,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPlanResponse {
        let input = GetPlanRequest(
            additionalPlanOptionsMap: additionalPlanOptionsMap, 
            language: language, 
            location: location, 
            mapping: mapping, 
            sinks: sinks, 
            source: source
        )
        return try await self.getPlan(input, logger: logger)
    }

    /// Describes the specified registry in detail.
    @Sendable
    @inlinable
    public func getRegistry(_ input: GetRegistryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRegistryResponse {
        try await self.client.execute(
            operation: "GetRegistry", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes the specified registry in detail.
    ///
    /// Parameters:
    ///   - registryId: This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
    ///   - logger: Logger use during operation
    @inlinable
    public func getRegistry(
        registryId: RegistryId,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetRegistryResponse {
        let input = GetRegistryInput(
            registryId: registryId
        )
        return try await self.getRegistry(input, logger: logger)
    }

    /// Retrieves the resource policies set on individual resources by Resource Access Manager during cross-account permission grants. Also retrieves the Data Catalog resource policy. If you enabled metadata encryption in Data Catalog settings, and you do not have permission on the KMS key, the operation can't return the Data Catalog resource policy.
    @Sendable
    @inlinable
    public func getResourcePolicies(_ input: GetResourcePoliciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResourcePoliciesResponse {
        try await self.client.execute(
            operation: "GetResourcePolicies", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the resource policies set on individual resources by Resource Access Manager during cross-account permission grants. Also retrieves the Data Catalog resource policy. If you enabled metadata encryption in Data Catalog settings, and you do not have permission on the KMS key, the operation can't return the Data Catalog resource policy.
    ///
    /// Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - nextToken: A continuation token, if this is a continuation request.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResourcePolicies(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResourcePoliciesResponse {
        let input = GetResourcePoliciesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getResourcePolicies(input, logger: logger)
    }

    /// Retrieves a specified resource policy.
    @Sendable
    @inlinable
    public func getResourcePolicy(_ input: GetResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResourcePolicyResponse {
        try await self.client.execute(
            operation: "GetResourcePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a specified resource policy.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the Glue resource for which to retrieve the resource policy. If not supplied, the Data Catalog resource policy is returned. Use GetResourcePolicies to view all existing resource policies. For more information see Specifying Glue Resource ARNs.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResourcePolicy(
        resourceArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResourcePolicyResponse {
        let input = GetResourcePolicyRequest(
            resourceArn: resourceArn
        )
        return try await self.getResourcePolicy(input, logger: logger)
    }

    /// Describes the specified schema in detail.
    @Sendable
    @inlinable
    public func getSchema(_ input: GetSchemaInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSchemaResponse {
        try await self.client.execute(
            operation: "GetSchema", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes the specified schema in detail.
    ///
    /// Parameters:
    ///   - schemaId: This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSchema(
        schemaId: SchemaId,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSchemaResponse {
        let input = GetSchemaInput(
            schemaId: schemaId
        )
        return try await self.getSchema(input, logger: logger)
    }

    /// Retrieves a schema by the SchemaDefinition. The schema definition is sent to the Schema Registry, canonicalized, and hashed. If the hash is matched within the scope of the SchemaName or ARN (or the default registry, if none is supplied), that schema’s metadata is returned. Otherwise, a 404 or NotFound error is returned. Schema versions in Deleted statuses will not be included in the results.
    @Sendable
    @inlinable
    public func getSchemaByDefinition(_ input: GetSchemaByDefinitionInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSchemaByDefinitionResponse {
        try await self.client.execute(
            operation: "GetSchemaByDefinition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a schema by the SchemaDefinition. The schema definition is sent to the Schema Registry, canonicalized, and hashed. If the hash is matched within the scope of the SchemaName or ARN (or the default registry, if none is supplied), that schema’s metadata is returned. Otherwise, a 404 or NotFound error is returned. Schema versions in Deleted statuses will not be included in the results.
    ///
    /// Parameters:
    ///   - schemaDefinition: The definition of the schema for which schema details are required.
    ///   - schemaId: This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.   SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSchemaByDefinition(
        schemaDefinition: String,
        schemaId: SchemaId,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSchemaByDefinitionResponse {
        let input = GetSchemaByDefinitionInput(
            schemaDefinition: schemaDefinition, 
            schemaId: schemaId
        )
        return try await self.getSchemaByDefinition(input, logger: logger)
    }

    /// Get the specified schema by its unique ID assigned when a version of the schema is created or registered. Schema versions in Deleted status will not be included in the results.
    @Sendable
    @inlinable
    public func getSchemaVersion(_ input: GetSchemaVersionInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSchemaVersionResponse {
        try await self.client.execute(
            operation: "GetSchemaVersion", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get the specified schema by its unique ID assigned when a version of the schema is created or registered. Schema versions in Deleted status will not be included in the results.
    ///
    /// Parameters:
    ///   - schemaId: This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    ///   - schemaVersionId: The SchemaVersionId of the schema version. This field is required for fetching by schema ID. Either this or the SchemaId wrapper has to be provided.
    ///   - schemaVersionNumber: The version number of the schema.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSchemaVersion(
        schemaId: SchemaId? = nil,
        schemaVersionId: String? = nil,
        schemaVersionNumber: SchemaVersionNumber? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSchemaVersionResponse {
        let input = GetSchemaVersionInput(
            schemaId: schemaId, 
            schemaVersionId: schemaVersionId, 
            schemaVersionNumber: schemaVersionNumber
        )
        return try await self.getSchemaVersion(input, logger: logger)
    }

    /// Fetches the schema version difference in the specified difference type between two stored schema versions in the Schema Registry. This API allows you to compare two schema versions between two schema definitions under the same schema.
    @Sendable
    @inlinable
    public func getSchemaVersionsDiff(_ input: GetSchemaVersionsDiffInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSchemaVersionsDiffResponse {
        try await self.client.execute(
            operation: "GetSchemaVersionsDiff", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Fetches the schema version difference in the specified difference type between two stored schema versions in the Schema Registry. This API allows you to compare two schema versions between two schema definitions under the same schema.
    ///
    /// Parameters:
    ///   - firstSchemaVersionNumber: The first of the two schema versions to be compared.
    ///   - schemaDiffType: Refers to SYNTAX_DIFF, which is the currently supported diff type.
    ///   - schemaId: This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.   SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
    ///   - secondSchemaVersionNumber: The second of the two schema versions to be compared.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSchemaVersionsDiff(
        firstSchemaVersionNumber: SchemaVersionNumber,
        schemaDiffType: SchemaDiffType,
        schemaId: SchemaId,
        secondSchemaVersionNumber: SchemaVersionNumber,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSchemaVersionsDiffResponse {
        let input = GetSchemaVersionsDiffInput(
            firstSchemaVersionNumber: firstSchemaVersionNumber, 
            schemaDiffType: schemaDiffType, 
            schemaId: schemaId, 
            secondSchemaVersionNumber: secondSchemaVersionNumber
        )
        return try await self.getSchemaVersionsDiff(input, logger: logger)
    }

    /// Retrieves a specified security configuration.
    @Sendable
    @inlinable
    public func getSecurityConfiguration(_ input: GetSecurityConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSecurityConfigurationResponse {
        try await self.client.execute(
            operation: "GetSecurityConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a specified security configuration.
    ///
    /// Parameters:
    ///   - name: The name of the security configuration to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSecurityConfiguration(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSecurityConfigurationResponse {
        let input = GetSecurityConfigurationRequest(
            name: name
        )
        return try await self.getSecurityConfiguration(input, logger: logger)
    }

    /// Retrieves a list of all security configurations.
    @Sendable
    @inlinable
    public func getSecurityConfigurations(_ input: GetSecurityConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSecurityConfigurationsResponse {
        try await self.client.execute(
            operation: "GetSecurityConfigurations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of all security configurations.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSecurityConfigurations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSecurityConfigurationsResponse {
        let input = GetSecurityConfigurationsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getSecurityConfigurations(input, logger: logger)
    }

    /// Retrieves the session.
    @Sendable
    @inlinable
    public func getSession(_ input: GetSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSessionResponse {
        try await self.client.execute(
            operation: "GetSession", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the session.
    ///
    /// Parameters:
    ///   - id: The ID of the session.
    ///   - requestOrigin: The origin of the request.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSession(
        id: String,
        requestOrigin: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSessionResponse {
        let input = GetSessionRequest(
            id: id, 
            requestOrigin: requestOrigin
        )
        return try await self.getSession(input, logger: logger)
    }

    /// Retrieves the statement.
    @Sendable
    @inlinable
    public func getStatement(_ input: GetStatementRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStatementResponse {
        try await self.client.execute(
            operation: "GetStatement", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the statement.
    ///
    /// Parameters:
    ///   - id: The Id of the statement.
    ///   - requestOrigin: The origin of the request.
    ///   - sessionId: The Session ID of the statement.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStatement(
        id: Int = 0,
        requestOrigin: String? = nil,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStatementResponse {
        let input = GetStatementRequest(
            id: id, 
            requestOrigin: requestOrigin, 
            sessionId: sessionId
        )
        return try await self.getStatement(input, logger: logger)
    }

    /// Retrieves the Table definition in a Data Catalog for a specified table.
    @Sendable
    @inlinable
    public func getTable(_ input: GetTableRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTableResponse {
        try await self.client.execute(
            operation: "GetTable", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the Table definition in a Data Catalog for a specified table.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    ///   - includeStatusDetails: Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
    ///   - name: The name of the table for which to retrieve the definition. For Hive compatibility, this name is entirely lowercase.
    ///   - queryAsOfTime: The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
    ///   - transactionId: The transaction ID at which to read the table contents.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTable(
        catalogId: String? = nil,
        databaseName: String,
        includeStatusDetails: Bool? = nil,
        name: String,
        queryAsOfTime: Date? = nil,
        transactionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTableResponse {
        let input = GetTableRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            includeStatusDetails: includeStatusDetails, 
            name: name, 
            queryAsOfTime: queryAsOfTime, 
            transactionId: transactionId
        )
        return try await self.getTable(input, logger: logger)
    }

    /// Returns the configuration of all optimizers associated with a specified table.
    @Sendable
    @inlinable
    public func getTableOptimizer(_ input: GetTableOptimizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTableOptimizerResponse {
        try await self.client.execute(
            operation: "GetTableOptimizer", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the configuration of all optimizers associated with a specified table.
    ///
    /// Parameters:
    ///   - catalogId: The Catalog ID of the table.
    ///   - databaseName: The name of the database in the catalog in which the table resides.
    ///   - tableName: The name of the table.
    ///   - type: The type of table optimizer.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTableOptimizer(
        catalogId: String,
        databaseName: String,
        tableName: String,
        type: TableOptimizerType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTableOptimizerResponse {
        let input = GetTableOptimizerRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            tableName: tableName, 
            type: type
        )
        return try await self.getTableOptimizer(input, logger: logger)
    }

    /// Retrieves a specified version of a table.
    @Sendable
    @inlinable
    public func getTableVersion(_ input: GetTableVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTableVersionResponse {
        try await self.client.execute(
            operation: "GetTableVersion", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a specified version of a table.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    ///   - tableName: The name of the table. For Hive compatibility, this name is entirely lowercase.
    ///   - versionId: The ID value of the table version to be retrieved. A VersionID is a string representation of an integer. Each version is incremented by 1.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTableVersion(
        catalogId: String? = nil,
        databaseName: String,
        tableName: String,
        versionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTableVersionResponse {
        let input = GetTableVersionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            tableName: tableName, 
            versionId: versionId
        )
        return try await self.getTableVersion(input, logger: logger)
    }

    /// Retrieves a list of strings that identify available versions of a specified table.
    @Sendable
    @inlinable
    public func getTableVersions(_ input: GetTableVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTableVersionsResponse {
        try await self.client.execute(
            operation: "GetTableVersions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of strings that identify available versions of a specified table.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    ///   - maxResults: The maximum number of table versions to return in one response.
    ///   - nextToken: A continuation token, if this is not the first call.
    ///   - tableName: The name of the table. For Hive compatibility, this name is entirely lowercase.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTableVersions(
        catalogId: String? = nil,
        databaseName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTableVersionsResponse {
        let input = GetTableVersionsRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            tableName: tableName
        )
        return try await self.getTableVersions(input, logger: logger)
    }

    /// Retrieves the definitions of some or all of the tables in a given Database.
    @Sendable
    @inlinable
    public func getTables(_ input: GetTablesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTablesResponse {
        try await self.client.execute(
            operation: "GetTables", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the definitions of some or all of the tables in a given Database.
    ///
    /// Parameters:
    ///   - attributesToGet:  Specifies the table fields returned by the GetTables call. This parameter doesn’t accept an empty list. The request must include NAME. The following are the valid combinations of values:    NAME - Names of all tables in the database.    NAME, TABLE_TYPE - Names of all tables and the table types.
    ///   - catalogId: The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The database in the catalog whose tables to list. For Hive compatibility, this name is entirely lowercase.
    ///   - expression: A regular expression pattern. If present, only those tables whose names match the pattern are returned.
    ///   - includeStatusDetails: Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
    ///   - maxResults: The maximum number of tables to return in a single response.
    ///   - nextToken: A continuation token, included if this is a continuation call.
    ///   - queryAsOfTime: The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
    ///   - transactionId: The transaction ID at which to read the table contents.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTables(
        attributesToGet: [TableAttributes]? = nil,
        catalogId: String? = nil,
        databaseName: String,
        expression: String? = nil,
        includeStatusDetails: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queryAsOfTime: Date? = nil,
        transactionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTablesResponse {
        let input = GetTablesRequest(
            attributesToGet: attributesToGet, 
            catalogId: catalogId, 
            databaseName: databaseName, 
            expression: expression, 
            includeStatusDetails: includeStatusDetails, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queryAsOfTime: queryAsOfTime, 
            transactionId: transactionId
        )
        return try await self.getTables(input, logger: logger)
    }

    /// Retrieves a list of tags associated with a resource.
    @Sendable
    @inlinable
    public func getTags(_ input: GetTagsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTagsResponse {
        try await self.client.execute(
            operation: "GetTags", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of tags associated with a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which to retrieve tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTags(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTagsResponse {
        let input = GetTagsRequest(
            resourceArn: resourceArn
        )
        return try await self.getTags(input, logger: logger)
    }

    /// Retrieves the definition of a trigger.
    @Sendable
    @inlinable
    public func getTrigger(_ input: GetTriggerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTriggerResponse {
        try await self.client.execute(
            operation: "GetTrigger", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the definition of a trigger.
    ///
    /// Parameters:
    ///   - name: The name of the trigger to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTrigger(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTriggerResponse {
        let input = GetTriggerRequest(
            name: name
        )
        return try await self.getTrigger(input, logger: logger)
    }

    /// Gets all the triggers associated with a job.
    @Sendable
    @inlinable
    public func getTriggers(_ input: GetTriggersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTriggersResponse {
        try await self.client.execute(
            operation: "GetTriggers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets all the triggers associated with a job.
    ///
    /// Parameters:
    ///   - dependentJobName: The name of the job to retrieve triggers for. The trigger that can start this job is returned, and if there is no such trigger, all triggers are returned.
    ///   - maxResults: The maximum size of the response.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTriggers(
        dependentJobName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTriggersResponse {
        let input = GetTriggersRequest(
            dependentJobName: dependentJobName, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getTriggers(input, logger: logger)
    }

    /// Retrieves partition metadata from the Data Catalog that contains unfiltered  metadata. For IAM authorization, the public IAM action associated with this API is glue:GetPartition.
    @Sendable
    @inlinable
    public func getUnfilteredPartitionMetadata(_ input: GetUnfilteredPartitionMetadataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetUnfilteredPartitionMetadataResponse {
        try await self.client.execute(
            operation: "GetUnfilteredPartitionMetadata", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves partition metadata from the Data Catalog that contains unfiltered  metadata. For IAM authorization, the public IAM action associated with this API is glue:GetPartition.
    ///
    /// Parameters:
    ///   - auditContext: A structure containing Lake Formation audit context information.
    ///   - catalogId: The catalog ID where the partition resides.
    ///   - databaseName: (Required) Specifies the name of a database that contains the partition.
    ///   - partitionValues: (Required) A list of partition key values.
    ///   - querySessionContext: A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
    ///   - region: Specified only if the base tables belong to a different Amazon Web Services Region.
    ///   - supportedPermissionTypes: (Required) A list of supported permission types.
    ///   - tableName: (Required) Specifies the name of a table that contains the partition.
    ///   - logger: Logger use during operation
    @inlinable
    public func getUnfilteredPartitionMetadata(
        auditContext: AuditContext? = nil,
        catalogId: String,
        databaseName: String,
        partitionValues: [String],
        querySessionContext: QuerySessionContext? = nil,
        region: String? = nil,
        supportedPermissionTypes: [PermissionType],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetUnfilteredPartitionMetadataResponse {
        let input = GetUnfilteredPartitionMetadataRequest(
            auditContext: auditContext, 
            catalogId: catalogId, 
            databaseName: databaseName, 
            partitionValues: partitionValues, 
            querySessionContext: querySessionContext, 
            region: region, 
            supportedPermissionTypes: supportedPermissionTypes, 
            tableName: tableName
        )
        return try await self.getUnfilteredPartitionMetadata(input, logger: logger)
    }

    /// Retrieves partition metadata from the Data Catalog that contains unfiltered  metadata. For IAM authorization, the public IAM action associated with this API is glue:GetPartitions.
    @Sendable
    @inlinable
    public func getUnfilteredPartitionsMetadata(_ input: GetUnfilteredPartitionsMetadataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetUnfilteredPartitionsMetadataResponse {
        try await self.client.execute(
            operation: "GetUnfilteredPartitionsMetadata", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves partition metadata from the Data Catalog that contains unfiltered  metadata. For IAM authorization, the public IAM action associated with this API is glue:GetPartitions.
    ///
    /// Parameters:
    ///   - auditContext: A structure containing Lake Formation audit context information.
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is provided,  the AWS account ID is used by default.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - expression: An expression that filters the partitions to be returned. The expression uses SQL syntax similar to the SQL WHERE filter clause. The SQL statement parser JSQLParser parses the expression.   Operators: The following are the operators that you can use in the Expression API call:  =  Checks whether the values of the two operands are equal; if yes, then the condition becomes true. Example: Assume 'variable a' holds 10 and 'variable b' holds 20.  (a = b) is not true.    Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true. Example: (a  b) is true.  >  Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true. Example: (a > b) is not true.    Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true. Example: (a   >=  Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a >= b) is not true.    Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a   AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL  Logical operators.    Supported Partition Key Types: The following are the supported partition keys.    string     date     timestamp     int     bigint     long     tinyint     smallint     decimal    If an type is encountered that is not valid, an exception is thrown.
    ///   - maxResults: The maximum number of partitions to return in a single response.
    ///   - nextToken: A continuation token, if this is not the first call to retrieve these partitions.
    ///   - querySessionContext: A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
    ///   - region: Specified only if the base tables belong to a different Amazon Web Services Region.
    ///   - segment: The segment of the table's partitions to scan in this request.
    ///   - supportedPermissionTypes: A list of supported permission types.
    ///   - tableName: The name of the table that contains the partition.
    ///   - logger: Logger use during operation
    @inlinable
    public func getUnfilteredPartitionsMetadata(
        auditContext: AuditContext? = nil,
        catalogId: String,
        databaseName: String,
        expression: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        querySessionContext: QuerySessionContext? = nil,
        region: String? = nil,
        segment: Segment? = nil,
        supportedPermissionTypes: [PermissionType],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetUnfilteredPartitionsMetadataResponse {
        let input = GetUnfilteredPartitionsMetadataRequest(
            auditContext: auditContext, 
            catalogId: catalogId, 
            databaseName: databaseName, 
            expression: expression, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            querySessionContext: querySessionContext, 
            region: region, 
            segment: segment, 
            supportedPermissionTypes: supportedPermissionTypes, 
            tableName: tableName
        )
        return try await self.getUnfilteredPartitionsMetadata(input, logger: logger)
    }

    /// Allows a third-party analytical engine to retrieve unfiltered table metadata from the Data Catalog. For IAM authorization, the public IAM action associated with this API is glue:GetTable.
    @Sendable
    @inlinable
    public func getUnfilteredTableMetadata(_ input: GetUnfilteredTableMetadataRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetUnfilteredTableMetadataResponse {
        try await self.client.execute(
            operation: "GetUnfilteredTableMetadata", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Allows a third-party analytical engine to retrieve unfiltered table metadata from the Data Catalog. For IAM authorization, the public IAM action associated with this API is glue:GetTable.
    ///
    /// Parameters:
    ///   - auditContext: A structure containing Lake Formation audit context information.
    ///   - catalogId: The catalog ID where the table resides.
    ///   - databaseName: (Required) Specifies the name of a database that contains the table.
    ///   - name: (Required) Specifies the name of a table for which you are requesting metadata.
    ///   - parentResourceArn: The resource ARN of the view.
    ///   - permissions: The Lake Formation data permissions of the caller on the table. Used to authorize the call when no view context is found.
    ///   - querySessionContext: A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
    ///   - region: Specified only if the base tables belong to a different Amazon Web Services Region.
    ///   - rootResourceArn: The resource ARN of the root view in a chain of nested views.
    ///   - supportedDialect: A structure specifying the dialect and dialect version used by the query engine.
    ///   - supportedPermissionTypes: Indicates the level of filtering a third-party analytical engine is capable of enforcing when calling the GetUnfilteredTableMetadata API operation. Accepted values are:    COLUMN_PERMISSION - Column permissions ensure that users can access only specific columns in the table. If there are particular columns contain sensitive data, data lake administrators can define column filters that exclude access to specific columns.    CELL_FILTER_PERMISSION - Cell-level filtering combines column filtering (include or exclude columns) and row filter expressions to restrict access to individual elements in the table.    NESTED_PERMISSION - Nested permissions combines cell-level filtering and nested column filtering to restrict access to columns and/or nested columns in specific rows based on row filter expressions.    NESTED_CELL_PERMISSION - Nested cell permissions combines nested permission with nested cell-level filtering. This allows different subsets of nested columns to be restricted based on an array of row filter expressions.    Note: Each of these permission types follows a hierarchical order where each subsequent permission type includes all permission of the previous type. Important: If you provide a supported permission type that doesn't match the user's level of permissions on the table, then Lake Formation raises an exception. For example, if the third-party engine calling the GetUnfilteredTableMetadata operation can enforce only column-level filtering, and the user has nested cell filtering applied on the table, Lake Formation throws an exception, and will not return unfiltered table metadata and data access credentials.
    ///   - logger: Logger use during operation
    @inlinable
    public func getUnfilteredTableMetadata(
        auditContext: AuditContext? = nil,
        catalogId: String,
        databaseName: String,
        name: String,
        parentResourceArn: String? = nil,
        permissions: [Permission]? = nil,
        querySessionContext: QuerySessionContext? = nil,
        region: String? = nil,
        rootResourceArn: String? = nil,
        supportedDialect: SupportedDialect? = nil,
        supportedPermissionTypes: [PermissionType],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetUnfilteredTableMetadataResponse {
        let input = GetUnfilteredTableMetadataRequest(
            auditContext: auditContext, 
            catalogId: catalogId, 
            databaseName: databaseName, 
            name: name, 
            parentResourceArn: parentResourceArn, 
            permissions: permissions, 
            querySessionContext: querySessionContext, 
            region: region, 
            rootResourceArn: rootResourceArn, 
            supportedDialect: supportedDialect, 
            supportedPermissionTypes: supportedPermissionTypes
        )
        return try await self.getUnfilteredTableMetadata(input, logger: logger)
    }

    /// Retrieves information about the specified Glue usage profile.
    @Sendable
    @inlinable
    public func getUsageProfile(_ input: GetUsageProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetUsageProfileResponse {
        try await self.client.execute(
            operation: "GetUsageProfile", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about the specified Glue usage profile.
    ///
    /// Parameters:
    ///   - name: The name of the usage profile to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getUsageProfile(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetUsageProfileResponse {
        let input = GetUsageProfileRequest(
            name: name
        )
        return try await self.getUsageProfile(input, logger: logger)
    }

    /// Retrieves a specified function definition from the Data Catalog.
    @Sendable
    @inlinable
    public func getUserDefinedFunction(_ input: GetUserDefinedFunctionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetUserDefinedFunctionResponse {
        try await self.client.execute(
            operation: "GetUserDefinedFunction", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a specified function definition from the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the function to be retrieved is located. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database where the function is located.
    ///   - functionName: The name of the function.
    ///   - logger: Logger use during operation
    @inlinable
    public func getUserDefinedFunction(
        catalogId: String? = nil,
        databaseName: String,
        functionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetUserDefinedFunctionResponse {
        let input = GetUserDefinedFunctionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            functionName: functionName
        )
        return try await self.getUserDefinedFunction(input, logger: logger)
    }

    /// Retrieves multiple function definitions from the Data Catalog.
    @Sendable
    @inlinable
    public func getUserDefinedFunctions(_ input: GetUserDefinedFunctionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetUserDefinedFunctionsResponse {
        try await self.client.execute(
            operation: "GetUserDefinedFunctions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves multiple function definitions from the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the functions to be retrieved are located. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database where the functions are located. If none is provided, functions from all the databases across the catalog will be returned.
    ///   - maxResults: The maximum number of functions to return in one response.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - pattern: An optional function-name pattern string that filters the function definitions returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func getUserDefinedFunctions(
        catalogId: String? = nil,
        databaseName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pattern: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetUserDefinedFunctionsResponse {
        let input = GetUserDefinedFunctionsRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            pattern: pattern
        )
        return try await self.getUserDefinedFunctions(input, logger: logger)
    }

    /// Retrieves resource metadata for a workflow.
    @Sendable
    @inlinable
    public func getWorkflow(_ input: GetWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowResponse {
        try await self.client.execute(
            operation: "GetWorkflow", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves resource metadata for a workflow.
    ///
    /// Parameters:
    ///   - includeGraph: Specifies whether to include a graph when returning the workflow resource metadata.
    ///   - name: The name of the workflow to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkflow(
        includeGraph: Bool? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkflowResponse {
        let input = GetWorkflowRequest(
            includeGraph: includeGraph, 
            name: name
        )
        return try await self.getWorkflow(input, logger: logger)
    }

    /// Retrieves the metadata for a given workflow run. Job run history is accessible for 90 days for your workflow and job run.
    @Sendable
    @inlinable
    public func getWorkflowRun(_ input: GetWorkflowRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowRunResponse {
        try await self.client.execute(
            operation: "GetWorkflowRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the metadata for a given workflow run. Job run history is accessible for 90 days for your workflow and job run.
    ///
    /// Parameters:
    ///   - includeGraph: Specifies whether to include the workflow graph in response or not.
    ///   - name: Name of the workflow being run.
    ///   - runId: The ID of the workflow run.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkflowRun(
        includeGraph: Bool? = nil,
        name: String,
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkflowRunResponse {
        let input = GetWorkflowRunRequest(
            includeGraph: includeGraph, 
            name: name, 
            runId: runId
        )
        return try await self.getWorkflowRun(input, logger: logger)
    }

    /// Retrieves the workflow run properties which were set during the run.
    @Sendable
    @inlinable
    public func getWorkflowRunProperties(_ input: GetWorkflowRunPropertiesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowRunPropertiesResponse {
        try await self.client.execute(
            operation: "GetWorkflowRunProperties", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the workflow run properties which were set during the run.
    ///
    /// Parameters:
    ///   - name: Name of the workflow which was run.
    ///   - runId: The ID of the workflow run whose run properties should be returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkflowRunProperties(
        name: String,
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkflowRunPropertiesResponse {
        let input = GetWorkflowRunPropertiesRequest(
            name: name, 
            runId: runId
        )
        return try await self.getWorkflowRunProperties(input, logger: logger)
    }

    /// Retrieves metadata for all runs of a given workflow.
    @Sendable
    @inlinable
    public func getWorkflowRuns(_ input: GetWorkflowRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkflowRunsResponse {
        try await self.client.execute(
            operation: "GetWorkflowRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves metadata for all runs of a given workflow.
    ///
    /// Parameters:
    ///   - includeGraph: Specifies whether to include the workflow graph in response or not.
    ///   - maxResults: The maximum number of workflow runs to be included in the response.
    ///   - name: Name of the workflow whose metadata of runs should be returned.
    ///   - nextToken: The maximum size of the response.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkflowRuns(
        includeGraph: Bool? = nil,
        maxResults: Int? = nil,
        name: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkflowRunsResponse {
        let input = GetWorkflowRunsRequest(
            includeGraph: includeGraph, 
            maxResults: maxResults, 
            name: name, 
            nextToken: nextToken
        )
        return try await self.getWorkflowRuns(input, logger: logger)
    }

    /// Imports an existing Amazon Athena Data Catalog to Glue.
    @Sendable
    @inlinable
    public func importCatalogToGlue(_ input: ImportCatalogToGlueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportCatalogToGlueResponse {
        try await self.client.execute(
            operation: "ImportCatalogToGlue", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Imports an existing Amazon Athena Data Catalog to Glue.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the catalog to import. Currently, this should be the Amazon Web Services account ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func importCatalogToGlue(
        catalogId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportCatalogToGlueResponse {
        let input = ImportCatalogToGlueRequest(
            catalogId: catalogId
        )
        return try await self.importCatalogToGlue(input, logger: logger)
    }

    /// Lists all the blueprint names in an account.
    @Sendable
    @inlinable
    public func listBlueprints(_ input: ListBlueprintsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBlueprintsResponse {
        try await self.client.execute(
            operation: "ListBlueprints", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the blueprint names in an account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - nextToken: A continuation token, if this is a continuation request.
    ///   - tags: Filters the list by an Amazon Web Services resource tag.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBlueprints(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBlueprintsResponse {
        let input = ListBlueprintsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            tags: tags
        )
        return try await self.listBlueprints(input, logger: logger)
    }

    /// List all task runs for a particular account.
    @Sendable
    @inlinable
    public func listColumnStatisticsTaskRuns(_ input: ListColumnStatisticsTaskRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListColumnStatisticsTaskRunsResponse {
        try await self.client.execute(
            operation: "ListColumnStatisticsTaskRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all task runs for a particular account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum size of the response.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func listColumnStatisticsTaskRuns(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListColumnStatisticsTaskRunsResponse {
        let input = ListColumnStatisticsTaskRunsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listColumnStatisticsTaskRuns(input, logger: logger)
    }

    /// The ListConnectionTypes API provides a discovery mechanism to learn available connection types in Glue. The response contains a list of connection types with high-level details of what is supported for each connection type. The connection types listed are the set of supported options for the ConnectionType value in the CreateConnection API.
    @Sendable
    @inlinable
    public func listConnectionTypes(_ input: ListConnectionTypesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListConnectionTypesResponse {
        try await self.client.execute(
            operation: "ListConnectionTypes", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The ListConnectionTypes API provides a discovery mechanism to learn available connection types in Glue. The response contains a list of connection types with high-level details of what is supported for each connection type. The connection types listed are the set of supported options for the ConnectionType value in the CreateConnection API.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func listConnectionTypes(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListConnectionTypesResponse {
        let input = ListConnectionTypesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listConnectionTypes(input, logger: logger)
    }

    /// Retrieves the names of all crawler resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    @Sendable
    @inlinable
    public func listCrawlers(_ input: ListCrawlersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCrawlersResponse {
        try await self.client.execute(
            operation: "ListCrawlers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the names of all crawler resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    ///
    /// Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - nextToken: A continuation token, if this is a continuation request.
    ///   - tags: Specifies to return only these tagged resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCrawlers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCrawlersResponse {
        let input = ListCrawlersRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            tags: tags
        )
        return try await self.listCrawlers(input, logger: logger)
    }

    /// Returns all the crawls of a specified crawler. Returns only the crawls that have occurred since the launch date of the crawler history feature, and only retains up to 12 months of crawls. Older crawls will not be returned. You may use this API to:   Retrive all the crawls of a specified crawler.   Retrieve all the crawls of a specified crawler within a limited count.   Retrieve all the crawls of a specified crawler in a specific time range.   Retrieve all the crawls of a specified crawler with a particular state, crawl ID, or DPU hour value.
    @Sendable
    @inlinable
    public func listCrawls(_ input: ListCrawlsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCrawlsResponse {
        try await self.client.execute(
            operation: "ListCrawls", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns all the crawls of a specified crawler. Returns only the crawls that have occurred since the launch date of the crawler history feature, and only retains up to 12 months of crawls. Older crawls will not be returned. You may use this API to:   Retrive all the crawls of a specified crawler.   Retrieve all the crawls of a specified crawler within a limited count.   Retrieve all the crawls of a specified crawler in a specific time range.   Retrieve all the crawls of a specified crawler with a particular state, crawl ID, or DPU hour value.
    ///
    /// Parameters:
    ///   - crawlerName: The name of the crawler whose runs you want to retrieve.
    ///   - filters: Filters the crawls by the criteria you specify in a list of CrawlsFilter objects.
    ///   - maxResults: The maximum number of results to return. The default is 20, and maximum is 100.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCrawls(
        crawlerName: String,
        filters: [CrawlsFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCrawlsResponse {
        let input = ListCrawlsRequest(
            crawlerName: crawlerName, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listCrawls(input, logger: logger)
    }

    /// Lists all the custom patterns that have been created.
    @Sendable
    @inlinable
    public func listCustomEntityTypes(_ input: ListCustomEntityTypesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCustomEntityTypesResponse {
        try await self.client.execute(
            operation: "ListCustomEntityTypes", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the custom patterns that have been created.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return.
    ///   - nextToken: A paginated token to offset the results.
    ///   - tags: A list of key-value pair tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCustomEntityTypes(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCustomEntityTypesResponse {
        let input = ListCustomEntityTypesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            tags: tags
        )
        return try await self.listCustomEntityTypes(input, logger: logger)
    }

    /// Returns all data quality execution results for your account.
    @Sendable
    @inlinable
    public func listDataQualityResults(_ input: ListDataQualityResultsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataQualityResultsResponse {
        try await self.client.execute(
            operation: "ListDataQualityResults", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns all data quality execution results for your account.
    ///
    /// Parameters:
    ///   - filter: The filter criteria.
    ///   - maxResults: The maximum number of results to return.
    ///   - nextToken: A paginated token to offset the results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataQualityResults(
        filter: DataQualityResultFilterCriteria? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataQualityResultsResponse {
        let input = ListDataQualityResultsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDataQualityResults(input, logger: logger)
    }

    /// Lists the recommendation runs meeting the filter criteria.
    @Sendable
    @inlinable
    public func listDataQualityRuleRecommendationRuns(_ input: ListDataQualityRuleRecommendationRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataQualityRuleRecommendationRunsResponse {
        try await self.client.execute(
            operation: "ListDataQualityRuleRecommendationRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the recommendation runs meeting the filter criteria.
    ///
    /// Parameters:
    ///   - filter: The filter criteria.
    ///   - maxResults: The maximum number of results to return.
    ///   - nextToken: A paginated token to offset the results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataQualityRuleRecommendationRuns(
        filter: DataQualityRuleRecommendationRunFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataQualityRuleRecommendationRunsResponse {
        let input = ListDataQualityRuleRecommendationRunsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDataQualityRuleRecommendationRuns(input, logger: logger)
    }

    /// Lists all the runs meeting the filter criteria, where a ruleset is evaluated against a data source.
    @Sendable
    @inlinable
    public func listDataQualityRulesetEvaluationRuns(_ input: ListDataQualityRulesetEvaluationRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataQualityRulesetEvaluationRunsResponse {
        try await self.client.execute(
            operation: "ListDataQualityRulesetEvaluationRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the runs meeting the filter criteria, where a ruleset is evaluated against a data source.
    ///
    /// Parameters:
    ///   - filter: The filter criteria.
    ///   - maxResults: The maximum number of results to return.
    ///   - nextToken: A paginated token to offset the results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataQualityRulesetEvaluationRuns(
        filter: DataQualityRulesetEvaluationRunFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataQualityRulesetEvaluationRunsResponse {
        let input = ListDataQualityRulesetEvaluationRunsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDataQualityRulesetEvaluationRuns(input, logger: logger)
    }

    /// Returns a paginated list of rulesets for the specified list of Glue tables.
    @Sendable
    @inlinable
    public func listDataQualityRulesets(_ input: ListDataQualityRulesetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataQualityRulesetsResponse {
        try await self.client.execute(
            operation: "ListDataQualityRulesets", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a paginated list of rulesets for the specified list of Glue tables.
    ///
    /// Parameters:
    ///   - filter: The filter criteria.
    ///   - maxResults: The maximum number of results to return.
    ///   - nextToken: A paginated token to offset the results.
    ///   - tags: A list of key-value pair tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataQualityRulesets(
        filter: DataQualityRulesetFilterCriteria? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataQualityRulesetsResponse {
        let input = ListDataQualityRulesetsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            tags: tags
        )
        return try await self.listDataQualityRulesets(input, logger: logger)
    }

    /// Retrieve annotations for a data quality statistic.
    @Sendable
    @inlinable
    public func listDataQualityStatisticAnnotations(_ input: ListDataQualityStatisticAnnotationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataQualityStatisticAnnotationsResponse {
        try await self.client.execute(
            operation: "ListDataQualityStatisticAnnotations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve annotations for a data quality statistic.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A pagination token to retrieve the next set of results.
    ///   - profileId: The Profile ID.
    ///   - statisticId: The Statistic ID.
    ///   - timestampFilter: A timestamp filter.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataQualityStatisticAnnotations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        profileId: String? = nil,
        statisticId: String? = nil,
        timestampFilter: TimestampFilter? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataQualityStatisticAnnotationsResponse {
        let input = ListDataQualityStatisticAnnotationsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            profileId: profileId, 
            statisticId: statisticId, 
            timestampFilter: timestampFilter
        )
        return try await self.listDataQualityStatisticAnnotations(input, logger: logger)
    }

    /// Retrieves a list of data quality statistics.
    @Sendable
    @inlinable
    public func listDataQualityStatistics(_ input: ListDataQualityStatisticsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataQualityStatisticsResponse {
        try await self.client.execute(
            operation: "ListDataQualityStatistics", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of data quality statistics.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in this request.
    ///   - nextToken: A pagination token to request the next page of results.
    ///   - profileId: The Profile ID.
    ///   - statisticId: The Statistic ID.
    ///   - timestampFilter: A timestamp filter.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataQualityStatistics(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        profileId: String? = nil,
        statisticId: String? = nil,
        timestampFilter: TimestampFilter? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataQualityStatisticsResponse {
        let input = ListDataQualityStatisticsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            profileId: profileId, 
            statisticId: statisticId, 
            timestampFilter: timestampFilter
        )
        return try await self.listDataQualityStatistics(input, logger: logger)
    }

    /// Retrieves the names of all DevEndpoint resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    @Sendable
    @inlinable
    public func listDevEndpoints(_ input: ListDevEndpointsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDevEndpointsResponse {
        try await self.client.execute(
            operation: "ListDevEndpoints", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the names of all DevEndpoint resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    ///
    /// Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - nextToken: A continuation token, if this is a continuation request.
    ///   - tags: Specifies to return only these tagged resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDevEndpoints(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDevEndpointsResponse {
        let input = ListDevEndpointsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            tags: tags
        )
        return try await self.listDevEndpoints(input, logger: logger)
    }

    /// Returns the available entities supported by the connection type.
    @Sendable
    @inlinable
    public func listEntities(_ input: ListEntitiesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEntitiesResponse {
        try await self.client.execute(
            operation: "ListEntities", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the available entities supported by the connection type.
    ///
    /// Parameters:
    ///   - catalogId: The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon Web Services Account ID is the catalog ID.
    ///   - connectionName: A name for the connection that has required credentials to query any connection type.
    ///   - dataStoreApiVersion: The API version of the SaaS connector.
    ///   - nextToken: A continuation token, included if this is a continuation call.
    ///   - parentEntityName: Name of the parent entity for which you want to list the children. This parameter takes a fully-qualified path of the entity in order to list the child entities.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEntities(
        catalogId: String? = nil,
        connectionName: String? = nil,
        dataStoreApiVersion: String? = nil,
        nextToken: String? = nil,
        parentEntityName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEntitiesResponse {
        let input = ListEntitiesRequest(
            catalogId: catalogId, 
            connectionName: connectionName, 
            dataStoreApiVersion: dataStoreApiVersion, 
            nextToken: nextToken, 
            parentEntityName: parentEntityName
        )
        return try await self.listEntities(input, logger: logger)
    }

    /// Retrieves the names of all job resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    @Sendable
    @inlinable
    public func listJobs(_ input: ListJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobsResponse {
        try await self.client.execute(
            operation: "ListJobs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the names of all job resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    ///
    /// Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - nextToken: A continuation token, if this is a continuation request.
    ///   - tags: Specifies to return only these tagged resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobsResponse {
        let input = ListJobsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            tags: tags
        )
        return try await self.listJobs(input, logger: logger)
    }

    ///  Retrieves a sortable, filterable list of existing Glue machine learning transforms in this Amazon Web Services account, or the resources with the specified tag. This operation takes the optional Tags field, which you can use as a filter of the responses so that tagged resources can be retrieved as a group. If you choose to use tag filtering, only resources with the tags are retrieved.
    @Sendable
    @inlinable
    public func listMLTransforms(_ input: ListMLTransformsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMLTransformsResponse {
        try await self.client.execute(
            operation: "ListMLTransforms", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves a sortable, filterable list of existing Glue machine learning transforms in this Amazon Web Services account, or the resources with the specified tag. This operation takes the optional Tags field, which you can use as a filter of the responses so that tagged resources can be retrieved as a group. If you choose to use tag filtering, only resources with the tags are retrieved.
    ///
    /// Parameters:
    ///   - filter: A TransformFilterCriteria used to filter the machine learning transforms.
    ///   - maxResults: The maximum size of a list to return.
    ///   - nextToken: A continuation token, if this is a continuation request.
    ///   - sort: A TransformSortCriteria used to sort the machine learning transforms.
    ///   - tags: Specifies to return only these tagged resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMLTransforms(
        filter: TransformFilterCriteria? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: TransformSortCriteria? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMLTransformsResponse {
        let input = ListMLTransformsRequest(
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sort: sort, 
            tags: tags
        )
        return try await self.listMLTransforms(input, logger: logger)
    }

    /// Returns a list of registries that you have created, with minimal registry information. Registries in the Deleting status will not be included in the results. Empty results will be returned if there are no registries available.
    @Sendable
    @inlinable
    public func listRegistries(_ input: ListRegistriesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRegistriesResponse {
        try await self.client.execute(
            operation: "ListRegistries", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of registries that you have created, with minimal registry information. Registries in the Deleting status will not be included in the results. Empty results will be returned if there are no registries available.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRegistries(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRegistriesResponse {
        let input = ListRegistriesInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listRegistries(input, logger: logger)
    }

    /// Returns a list of schema versions that you have created, with minimal information. Schema versions in Deleted status will not be included in the results. Empty results will be returned if there are no schema versions available.
    @Sendable
    @inlinable
    public func listSchemaVersions(_ input: ListSchemaVersionsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSchemaVersionsResponse {
        try await self.client.execute(
            operation: "ListSchemaVersions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of schema versions that you have created, with minimal information. Schema versions in Deleted status will not be included in the results. Empty results will be returned if there are no schema versions available.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - schemaId: This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSchemaVersions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        schemaId: SchemaId,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSchemaVersionsResponse {
        let input = ListSchemaVersionsInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            schemaId: schemaId
        )
        return try await self.listSchemaVersions(input, logger: logger)
    }

    /// Returns a list of schemas with minimal details. Schemas in Deleting status will not be included in the results. Empty results will be returned if there are no schemas available. When the RegistryId is not provided, all the schemas across registries will be part of the API response.
    @Sendable
    @inlinable
    public func listSchemas(_ input: ListSchemasInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSchemasResponse {
        try await self.client.execute(
            operation: "ListSchemas", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of schemas with minimal details. Schemas in Deleting status will not be included in the results. Empty results will be returned if there are no schemas available. When the RegistryId is not provided, all the schemas across registries will be part of the API response.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - registryId: A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
    ///   - logger: Logger use during operation
    @inlinable
    public func listSchemas(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registryId: RegistryId? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSchemasResponse {
        let input = ListSchemasInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            registryId: registryId
        )
        return try await self.listSchemas(input, logger: logger)
    }

    /// Retrieve a list of sessions.
    @Sendable
    @inlinable
    public func listSessions(_ input: ListSessionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSessionsResponse {
        try await self.client.execute(
            operation: "ListSessions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a list of sessions.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results.
    ///   - nextToken: The token for the next set of results, or null if there are no more result.
    ///   - requestOrigin: The origin of the request.
    ///   - tags: Tags belonging to the session.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSessions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        requestOrigin: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSessionsResponse {
        let input = ListSessionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            requestOrigin: requestOrigin, 
            tags: tags
        )
        return try await self.listSessions(input, logger: logger)
    }

    /// Lists statements for the session.
    @Sendable
    @inlinable
    public func listStatements(_ input: ListStatementsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStatementsResponse {
        try await self.client.execute(
            operation: "ListStatements", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists statements for the session.
    ///
    /// Parameters:
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - requestOrigin: The origin of the request to list statements.
    ///   - sessionId: The Session ID of the statements.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStatements(
        nextToken: String? = nil,
        requestOrigin: String? = nil,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStatementsResponse {
        let input = ListStatementsRequest(
            nextToken: nextToken, 
            requestOrigin: requestOrigin, 
            sessionId: sessionId
        )
        return try await self.listStatements(input, logger: logger)
    }

    /// Lists the history of previous optimizer runs for a specific table.
    @Sendable
    @inlinable
    public func listTableOptimizerRuns(_ input: ListTableOptimizerRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTableOptimizerRunsResponse {
        try await self.client.execute(
            operation: "ListTableOptimizerRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the history of previous optimizer runs for a specific table.
    ///
    /// Parameters:
    ///   - catalogId: The Catalog ID of the table.
    ///   - databaseName: The name of the database in the catalog in which the table resides.
    ///   - maxResults: The maximum number of optimizer runs to return on each call.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - tableName: The name of the table.
    ///   - type: The type of table optimizer.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTableOptimizerRuns(
        catalogId: String,
        databaseName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tableName: String,
        type: TableOptimizerType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTableOptimizerRunsResponse {
        let input = ListTableOptimizerRunsRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            tableName: tableName, 
            type: type
        )
        return try await self.listTableOptimizerRuns(input, logger: logger)
    }

    /// Retrieves the names of all trigger resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    @Sendable
    @inlinable
    public func listTriggers(_ input: ListTriggersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTriggersResponse {
        try await self.client.execute(
            operation: "ListTriggers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the names of all trigger resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names. This operation takes the optional Tags field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.
    ///
    /// Parameters:
    ///   - dependentJobName:  The name of the job for which to retrieve triggers. The trigger that can start this job is returned. If there is no such trigger, all triggers are returned.
    ///   - maxResults: The maximum size of a list to return.
    ///   - nextToken: A continuation token, if this is a continuation request.
    ///   - tags: Specifies to return only these tagged resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTriggers(
        dependentJobName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTriggersResponse {
        let input = ListTriggersRequest(
            dependentJobName: dependentJobName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            tags: tags
        )
        return try await self.listTriggers(input, logger: logger)
    }

    /// List all the Glue usage profiles.
    @Sendable
    @inlinable
    public func listUsageProfiles(_ input: ListUsageProfilesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListUsageProfilesResponse {
        try await self.client.execute(
            operation: "ListUsageProfiles", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all the Glue usage profiles.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of usage profiles to return in a single response.
    ///   - nextToken: A continuation token, included if this is a continuation call.
    ///   - logger: Logger use during operation
    @inlinable
    public func listUsageProfiles(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListUsageProfilesResponse {
        let input = ListUsageProfilesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listUsageProfiles(input, logger: logger)
    }

    /// Lists names of workflows created in the account.
    @Sendable
    @inlinable
    public func listWorkflows(_ input: ListWorkflowsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkflowsResponse {
        try await self.client.execute(
            operation: "ListWorkflows", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists names of workflows created in the account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - nextToken: A continuation token, if this is a continuation request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkflows(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkflowsResponse {
        let input = ListWorkflowsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listWorkflows(input, logger: logger)
    }

    /// Modifies a Zero-ETL integration in the caller's account.
    @Sendable
    @inlinable
    public func modifyIntegration(_ input: ModifyIntegrationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyIntegrationResponse {
        try await self.client.execute(
            operation: "ModifyIntegration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies a Zero-ETL integration in the caller's account.
    ///
    /// Parameters:
    ///   - dataFilter: Selects source tables for the integration using Maxwell filter syntax.
    ///   - description: A description of the integration.
    ///   - integrationIdentifier: The Amazon Resource Name (ARN) for the integration.
    ///   - integrationName: A unique name for an integration in Glue.
    ///   - logger: Logger use during operation
    @inlinable
    public func modifyIntegration(
        dataFilter: String? = nil,
        description: String? = nil,
        integrationIdentifier: String,
        integrationName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ModifyIntegrationResponse {
        let input = ModifyIntegrationRequest(
            dataFilter: dataFilter, 
            description: description, 
            integrationIdentifier: integrationIdentifier, 
            integrationName: integrationName
        )
        return try await self.modifyIntegration(input, logger: logger)
    }

    /// Sets the security configuration for a specified catalog. After the configuration has been set, the specified encryption is applied to every catalog write thereafter.
    @Sendable
    @inlinable
    public func putDataCatalogEncryptionSettings(_ input: PutDataCatalogEncryptionSettingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutDataCatalogEncryptionSettingsResponse {
        try await self.client.execute(
            operation: "PutDataCatalogEncryptionSettings", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets the security configuration for a specified catalog. After the configuration has been set, the specified encryption is applied to every catalog write thereafter.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog to set the security configuration for. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - dataCatalogEncryptionSettings: The security configuration to set.
    ///   - logger: Logger use during operation
    @inlinable
    public func putDataCatalogEncryptionSettings(
        catalogId: String? = nil,
        dataCatalogEncryptionSettings: DataCatalogEncryptionSettings,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutDataCatalogEncryptionSettingsResponse {
        let input = PutDataCatalogEncryptionSettingsRequest(
            catalogId: catalogId, 
            dataCatalogEncryptionSettings: dataCatalogEncryptionSettings
        )
        return try await self.putDataCatalogEncryptionSettings(input, logger: logger)
    }

    /// Annotate all datapoints for a Profile.
    @Sendable
    @inlinable
    public func putDataQualityProfileAnnotation(_ input: PutDataQualityProfileAnnotationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutDataQualityProfileAnnotationResponse {
        try await self.client.execute(
            operation: "PutDataQualityProfileAnnotation", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Annotate all datapoints for a Profile.
    ///
    /// Parameters:
    ///   - inclusionAnnotation: The inclusion annotation value to apply to the profile.
    ///   - profileId: The ID of the data quality monitoring profile to annotate.
    ///   - logger: Logger use during operation
    @inlinable
    public func putDataQualityProfileAnnotation(
        inclusionAnnotation: InclusionAnnotationValue,
        profileId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutDataQualityProfileAnnotationResponse {
        let input = PutDataQualityProfileAnnotationRequest(
            inclusionAnnotation: inclusionAnnotation, 
            profileId: profileId
        )
        return try await self.putDataQualityProfileAnnotation(input, logger: logger)
    }

    /// Sets the Data Catalog resource policy for access control.
    @Sendable
    @inlinable
    public func putResourcePolicy(_ input: PutResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutResourcePolicyResponse {
        try await self.client.execute(
            operation: "PutResourcePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets the Data Catalog resource policy for access control.
    ///
    /// Parameters:
    ///   - enableHybrid: If 'TRUE', indicates that you are using both methods to grant cross-account access to Data Catalog resources:   By directly updating the resource policy with PutResourePolicy    By using the Grant permissions command on the Amazon Web Services Management Console.   Must be set to 'TRUE' if you have already used the Management Console to grant cross-account access, otherwise the call fails. Default is 'FALSE'.
    ///   - policyExistsCondition: A value of MUST_EXIST is used to update a policy. A value of NOT_EXIST is used to create a new policy. If a value of NONE or a null value is used, the call does not depend on the existence of a policy.
    ///   - policyHashCondition: The hash value returned when the previous policy was set using PutResourcePolicy. Its purpose is to prevent concurrent modifications of a policy. Do not use this parameter if no previous policy has been set.
    ///   - policyInJson: Contains the policy document to set, in JSON format.
    ///   - resourceArn: Do not use. For internal use only.
    ///   - logger: Logger use during operation
    @inlinable
    public func putResourcePolicy(
        enableHybrid: EnableHybridValues? = nil,
        policyExistsCondition: ExistCondition? = nil,
        policyHashCondition: String? = nil,
        policyInJson: String,
        resourceArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutResourcePolicyResponse {
        let input = PutResourcePolicyRequest(
            enableHybrid: enableHybrid, 
            policyExistsCondition: policyExistsCondition, 
            policyHashCondition: policyHashCondition, 
            policyInJson: policyInJson, 
            resourceArn: resourceArn
        )
        return try await self.putResourcePolicy(input, logger: logger)
    }

    /// Puts the metadata key value pair for a specified schema version ID. A maximum of 10 key value pairs will be allowed per schema version. They can be added over one or more calls.
    @Sendable
    @inlinable
    public func putSchemaVersionMetadata(_ input: PutSchemaVersionMetadataInput, logger: Logger = AWSClient.loggingDisabled) async throws -> PutSchemaVersionMetadataResponse {
        try await self.client.execute(
            operation: "PutSchemaVersionMetadata", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Puts the metadata key value pair for a specified schema version ID. A maximum of 10 key value pairs will be allowed per schema version. They can be added over one or more calls.
    ///
    /// Parameters:
    ///   - metadataKeyValue: The metadata key's corresponding value.
    ///   - schemaId: The unique ID for the schema.
    ///   - schemaVersionId: The unique version ID of the schema version.
    ///   - schemaVersionNumber: The version number of the schema.
    ///   - logger: Logger use during operation
    @inlinable
    public func putSchemaVersionMetadata(
        metadataKeyValue: MetadataKeyValuePair,
        schemaId: SchemaId? = nil,
        schemaVersionId: String? = nil,
        schemaVersionNumber: SchemaVersionNumber? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutSchemaVersionMetadataResponse {
        let input = PutSchemaVersionMetadataInput(
            metadataKeyValue: metadataKeyValue, 
            schemaId: schemaId, 
            schemaVersionId: schemaVersionId, 
            schemaVersionNumber: schemaVersionNumber
        )
        return try await self.putSchemaVersionMetadata(input, logger: logger)
    }

    /// Puts the specified workflow run properties for the given workflow run. If a property already exists for the specified run, then it overrides the value otherwise adds the property to existing properties.
    @Sendable
    @inlinable
    public func putWorkflowRunProperties(_ input: PutWorkflowRunPropertiesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutWorkflowRunPropertiesResponse {
        try await self.client.execute(
            operation: "PutWorkflowRunProperties", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Puts the specified workflow run properties for the given workflow run. If a property already exists for the specified run, then it overrides the value otherwise adds the property to existing properties.
    ///
    /// Parameters:
    ///   - name: Name of the workflow which was run.
    ///   - runId: The ID of the workflow run for which the run properties should be updated.
    ///   - runProperties: The properties to put for the specified run.
    ///   - logger: Logger use during operation
    @inlinable
    public func putWorkflowRunProperties(
        name: String,
        runId: String,
        runProperties: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutWorkflowRunPropertiesResponse {
        let input = PutWorkflowRunPropertiesRequest(
            name: name, 
            runId: runId, 
            runProperties: runProperties
        )
        return try await self.putWorkflowRunProperties(input, logger: logger)
    }

    /// Queries for the schema version metadata information.
    @Sendable
    @inlinable
    public func querySchemaVersionMetadata(_ input: QuerySchemaVersionMetadataInput, logger: Logger = AWSClient.loggingDisabled) async throws -> QuerySchemaVersionMetadataResponse {
        try await self.client.execute(
            operation: "QuerySchemaVersionMetadata", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Queries for the schema version metadata information.
    ///
    /// Parameters:
    ///   - maxResults: Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    ///   - metadataList: Search key-value pairs for metadata, if they are not provided all the metadata information will be fetched.
    ///   - nextToken: A continuation token, if this is a continuation call.
    ///   - schemaId: A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
    ///   - schemaVersionId: The unique version ID of the schema version.
    ///   - schemaVersionNumber: The version number of the schema.
    ///   - logger: Logger use during operation
    @inlinable
    public func querySchemaVersionMetadata(
        maxResults: Int? = nil,
        metadataList: [MetadataKeyValuePair]? = nil,
        nextToken: String? = nil,
        schemaId: SchemaId? = nil,
        schemaVersionId: String? = nil,
        schemaVersionNumber: SchemaVersionNumber? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> QuerySchemaVersionMetadataResponse {
        let input = QuerySchemaVersionMetadataInput(
            maxResults: maxResults, 
            metadataList: metadataList, 
            nextToken: nextToken, 
            schemaId: schemaId, 
            schemaVersionId: schemaVersionId, 
            schemaVersionNumber: schemaVersionNumber
        )
        return try await self.querySchemaVersionMetadata(input, logger: logger)
    }

    /// Adds a new version to the existing schema. Returns an error if new version of schema does not meet the compatibility requirements of the schema set. This API will not create a new schema set and will return a 404 error if the schema set is not already present in the Schema Registry. If this is the first schema definition to be registered in the Schema Registry, this API will store the schema version and return immediately. Otherwise, this call has the potential to run longer than other operations due to compatibility modes. You can call the GetSchemaVersion API with the SchemaVersionId to check compatibility modes. If the same schema definition is already stored in Schema Registry as a version, the schema ID of the existing schema is returned to the caller.
    @Sendable
    @inlinable
    public func registerSchemaVersion(_ input: RegisterSchemaVersionInput, logger: Logger = AWSClient.loggingDisabled) async throws -> RegisterSchemaVersionResponse {
        try await self.client.execute(
            operation: "RegisterSchemaVersion", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds a new version to the existing schema. Returns an error if new version of schema does not meet the compatibility requirements of the schema set. This API will not create a new schema set and will return a 404 error if the schema set is not already present in the Schema Registry. If this is the first schema definition to be registered in the Schema Registry, this API will store the schema version and return immediately. Otherwise, this call has the potential to run longer than other operations due to compatibility modes. You can call the GetSchemaVersion API with the SchemaVersionId to check compatibility modes. If the same schema definition is already stored in Schema Registry as a version, the schema ID of the existing schema is returned to the caller.
    ///
    /// Parameters:
    ///   - schemaDefinition: The schema definition using the DataFormat setting for the SchemaName.
    ///   - schemaId: This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    ///   - logger: Logger use during operation
    @inlinable
    public func registerSchemaVersion(
        schemaDefinition: String,
        schemaId: SchemaId,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RegisterSchemaVersionResponse {
        let input = RegisterSchemaVersionInput(
            schemaDefinition: schemaDefinition, 
            schemaId: schemaId
        )
        return try await self.registerSchemaVersion(input, logger: logger)
    }

    /// Removes a key value pair from the schema version metadata for the specified schema version ID.
    @Sendable
    @inlinable
    public func removeSchemaVersionMetadata(_ input: RemoveSchemaVersionMetadataInput, logger: Logger = AWSClient.loggingDisabled) async throws -> RemoveSchemaVersionMetadataResponse {
        try await self.client.execute(
            operation: "RemoveSchemaVersionMetadata", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a key value pair from the schema version metadata for the specified schema version ID.
    ///
    /// Parameters:
    ///   - metadataKeyValue: The value of the metadata key.
    ///   - schemaId: A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
    ///   - schemaVersionId: The unique version ID of the schema version.
    ///   - schemaVersionNumber: The version number of the schema.
    ///   - logger: Logger use during operation
    @inlinable
    public func removeSchemaVersionMetadata(
        metadataKeyValue: MetadataKeyValuePair,
        schemaId: SchemaId? = nil,
        schemaVersionId: String? = nil,
        schemaVersionNumber: SchemaVersionNumber? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RemoveSchemaVersionMetadataResponse {
        let input = RemoveSchemaVersionMetadataInput(
            metadataKeyValue: metadataKeyValue, 
            schemaId: schemaId, 
            schemaVersionId: schemaVersionId, 
            schemaVersionNumber: schemaVersionNumber
        )
        return try await self.removeSchemaVersionMetadata(input, logger: logger)
    }

    /// Resets a bookmark entry. For more information about enabling and using job bookmarks, see:    Tracking processed data using job bookmarks     Job parameters used by Glue     Job structure
    @Sendable
    @inlinable
    public func resetJobBookmark(_ input: ResetJobBookmarkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ResetJobBookmarkResponse {
        try await self.client.execute(
            operation: "ResetJobBookmark", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Resets a bookmark entry. For more information about enabling and using job bookmarks, see:    Tracking processed data using job bookmarks     Job parameters used by Glue     Job structure
    ///
    /// Parameters:
    ///   - jobName: The name of the job in question.
    ///   - runId: The unique run identifier associated with this job run.
    ///   - logger: Logger use during operation
    @inlinable
    public func resetJobBookmark(
        jobName: String,
        runId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ResetJobBookmarkResponse {
        let input = ResetJobBookmarkRequest(
            jobName: jobName, 
            runId: runId
        )
        return try await self.resetJobBookmark(input, logger: logger)
    }

    /// Restarts selected nodes of a previous partially completed workflow run and resumes the workflow run. The selected nodes and all nodes that are downstream from the selected nodes are run.
    @Sendable
    @inlinable
    public func resumeWorkflowRun(_ input: ResumeWorkflowRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ResumeWorkflowRunResponse {
        try await self.client.execute(
            operation: "ResumeWorkflowRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Restarts selected nodes of a previous partially completed workflow run and resumes the workflow run. The selected nodes and all nodes that are downstream from the selected nodes are run.
    ///
    /// Parameters:
    ///   - name: The name of the workflow to resume.
    ///   - nodeIds: A list of the node IDs for the nodes you want to restart. The nodes that are to be restarted must have a run attempt in the original run.
    ///   - runId: The ID of the workflow run to resume.
    ///   - logger: Logger use during operation
    @inlinable
    public func resumeWorkflowRun(
        name: String,
        nodeIds: [String],
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ResumeWorkflowRunResponse {
        let input = ResumeWorkflowRunRequest(
            name: name, 
            nodeIds: nodeIds, 
            runId: runId
        )
        return try await self.resumeWorkflowRun(input, logger: logger)
    }

    /// Executes the statement.
    @Sendable
    @inlinable
    public func runStatement(_ input: RunStatementRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RunStatementResponse {
        try await self.client.execute(
            operation: "RunStatement", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Executes the statement.
    ///
    /// Parameters:
    ///   - code: The statement code to be run.
    ///   - requestOrigin: The origin of the request.
    ///   - sessionId: The Session Id of the statement to be run.
    ///   - logger: Logger use during operation
    @inlinable
    public func runStatement(
        code: String,
        requestOrigin: String? = nil,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RunStatementResponse {
        let input = RunStatementRequest(
            code: code, 
            requestOrigin: requestOrigin, 
            sessionId: sessionId
        )
        return try await self.runStatement(input, logger: logger)
    }

    /// Searches a set of tables based on properties in the table metadata as well as on the parent database. You can search against text or filter conditions.  You can only get tables that you have access to based on the security policies defined in Lake Formation. You need at least a read-only access to the table for it to be returned. If you do not have access to all the columns in the table, these columns will not be searched against when returning the list of tables back to you. If you have access to the columns but not the data in the columns, those columns and the associated metadata for those columns will be included in the search.
    @Sendable
    @inlinable
    public func searchTables(_ input: SearchTablesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchTablesResponse {
        try await self.client.execute(
            operation: "SearchTables", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Searches a set of tables based on properties in the table metadata as well as on the parent database. You can search against text or filter conditions.  You can only get tables that you have access to based on the security policies defined in Lake Formation. You need at least a read-only access to the table for it to be returned. If you do not have access to all the columns in the table, these columns will not be searched against when returning the list of tables back to you. If you have access to the columns but not the data in the columns, those columns and the associated metadata for those columns will be included in the search.
    ///
    /// Parameters:
    ///   - catalogId: A unique identifier, consisting of  account_id .
    ///   - filters: A list of key-value pairs, and a comparator used to filter the search results. Returns all entities matching the predicate. The Comparator member of the PropertyPredicate struct is used only for time fields, and can be omitted for other field types. Also, when comparing string values, such as when Key=Name, a fuzzy match algorithm is used. The Key field (for example, the value of the Name field) is split on certain punctuation characters, for example, -, :, #, etc. into tokens. Then each token is exact-match compared with the Value member of PropertyPredicate. For example, if Key=Name and Value=link, tables named customer-link and xx-link-yy are returned, but xxlinkyy is not returned.
    ///   - includeStatusDetails: Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
    ///   - maxResults: The maximum number of tables to return in a single response.
    ///   - nextToken: A continuation token, included if this is a continuation call.
    ///   - resourceShareType: Allows you to specify that you want to search the tables shared with your account. The allowable values are FOREIGN or ALL.    If set to FOREIGN, will search the tables shared with your account.    If set to ALL, will search the tables shared with your account, as well as the tables in yor local account.
    ///   - searchText: A string used for a text search. Specifying a value in quotes filters based on an exact match to the value.
    ///   - sortCriteria: A list of criteria for sorting the results by a field name, in an ascending or descending order.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchTables(
        catalogId: String? = nil,
        filters: [PropertyPredicate]? = nil,
        includeStatusDetails: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceShareType: ResourceShareType? = nil,
        searchText: String? = nil,
        sortCriteria: [SortCriterion]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchTablesResponse {
        let input = SearchTablesRequest(
            catalogId: catalogId, 
            filters: filters, 
            includeStatusDetails: includeStatusDetails, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceShareType: resourceShareType, 
            searchText: searchText, 
            sortCriteria: sortCriteria
        )
        return try await self.searchTables(input, logger: logger)
    }

    /// Starts a new run of the specified blueprint.
    @Sendable
    @inlinable
    public func startBlueprintRun(_ input: StartBlueprintRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartBlueprintRunResponse {
        try await self.client.execute(
            operation: "StartBlueprintRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a new run of the specified blueprint.
    ///
    /// Parameters:
    ///   - blueprintName: The name of the blueprint.
    ///   - parameters: Specifies the parameters as a BlueprintParameters object.
    ///   - roleArn: Specifies the IAM role used to create the workflow.
    ///   - logger: Logger use during operation
    @inlinable
    public func startBlueprintRun(
        blueprintName: String,
        parameters: String? = nil,
        roleArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartBlueprintRunResponse {
        let input = StartBlueprintRunRequest(
            blueprintName: blueprintName, 
            parameters: parameters, 
            roleArn: roleArn
        )
        return try await self.startBlueprintRun(input, logger: logger)
    }

    /// Starts a column statistics task run, for a specified table and columns.
    @Sendable
    @inlinable
    public func startColumnStatisticsTaskRun(_ input: StartColumnStatisticsTaskRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartColumnStatisticsTaskRunResponse {
        try await self.client.execute(
            operation: "StartColumnStatisticsTaskRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a column statistics task run, for a specified table and columns.
    ///
    /// Parameters:
    ///   - catalogID: The ID of the Data Catalog where the table reside. If none is supplied, the Amazon Web Services account ID is used by default.
    ///   - columnNameList: A list of the column names to generate statistics. If none is supplied, all column names for the table will be used by default.
    ///   - databaseName: The name of the database where the table resides.
    ///   - role: The IAM role that the service assumes to generate statistics.
    ///   - sampleSize: The percentage of rows used to generate statistics. If none is supplied, the entire table will be used to generate stats.
    ///   - securityConfiguration: Name of the security configuration that is used to encrypt CloudWatch logs for the column stats task run.
    ///   - tableName: The name of the table to generate statistics.
    ///   - logger: Logger use during operation
    @inlinable
    public func startColumnStatisticsTaskRun(
        catalogID: String? = nil,
        columnNameList: [String]? = nil,
        databaseName: String,
        role: String,
        sampleSize: Double? = nil,
        securityConfiguration: String? = nil,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartColumnStatisticsTaskRunResponse {
        let input = StartColumnStatisticsTaskRunRequest(
            catalogID: catalogID, 
            columnNameList: columnNameList, 
            databaseName: databaseName, 
            role: role, 
            sampleSize: sampleSize, 
            securityConfiguration: securityConfiguration, 
            tableName: tableName
        )
        return try await self.startColumnStatisticsTaskRun(input, logger: logger)
    }

    /// Starts a column statistics task run schedule.
    @Sendable
    @inlinable
    public func startColumnStatisticsTaskRunSchedule(_ input: StartColumnStatisticsTaskRunScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartColumnStatisticsTaskRunScheduleResponse {
        try await self.client.execute(
            operation: "StartColumnStatisticsTaskRunSchedule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a column statistics task run schedule.
    ///
    /// Parameters:
    ///   - databaseName: The name of the database where the table resides.
    ///   - tableName: The name of the table for which to start a column statistic task run schedule.
    ///   - logger: Logger use during operation
    @inlinable
    public func startColumnStatisticsTaskRunSchedule(
        databaseName: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartColumnStatisticsTaskRunScheduleResponse {
        let input = StartColumnStatisticsTaskRunScheduleRequest(
            databaseName: databaseName, 
            tableName: tableName
        )
        return try await self.startColumnStatisticsTaskRunSchedule(input, logger: logger)
    }

    /// Starts a crawl using the specified crawler, regardless of what is scheduled. If the crawler is already running, returns a CrawlerRunningException.
    @Sendable
    @inlinable
    public func startCrawler(_ input: StartCrawlerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartCrawlerResponse {
        try await self.client.execute(
            operation: "StartCrawler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a crawl using the specified crawler, regardless of what is scheduled. If the crawler is already running, returns a CrawlerRunningException.
    ///
    /// Parameters:
    ///   - name: Name of the crawler to start.
    ///   - logger: Logger use during operation
    @inlinable
    public func startCrawler(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartCrawlerResponse {
        let input = StartCrawlerRequest(
            name: name
        )
        return try await self.startCrawler(input, logger: logger)
    }

    /// Changes the schedule state of the specified crawler to SCHEDULED, unless the crawler is already running or the schedule state is already SCHEDULED.
    @Sendable
    @inlinable
    public func startCrawlerSchedule(_ input: StartCrawlerScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartCrawlerScheduleResponse {
        try await self.client.execute(
            operation: "StartCrawlerSchedule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Changes the schedule state of the specified crawler to SCHEDULED, unless the crawler is already running or the schedule state is already SCHEDULED.
    ///
    /// Parameters:
    ///   - crawlerName: Name of the crawler to schedule.
    ///   - logger: Logger use during operation
    @inlinable
    public func startCrawlerSchedule(
        crawlerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartCrawlerScheduleResponse {
        let input = StartCrawlerScheduleRequest(
            crawlerName: crawlerName
        )
        return try await self.startCrawlerSchedule(input, logger: logger)
    }

    /// Starts a recommendation run that is used to generate rules when you don't know what rules to write. Glue Data Quality analyzes the data and comes up with recommendations for a potential ruleset. You can then triage the ruleset and modify the generated ruleset to your liking. Recommendation runs are automatically deleted after 90 days.
    @Sendable
    @inlinable
    public func startDataQualityRuleRecommendationRun(_ input: StartDataQualityRuleRecommendationRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartDataQualityRuleRecommendationRunResponse {
        try await self.client.execute(
            operation: "StartDataQualityRuleRecommendationRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a recommendation run that is used to generate rules when you don't know what rules to write. Glue Data Quality analyzes the data and comes up with recommendations for a potential ruleset. You can then triage the ruleset and modify the generated ruleset to your liking. Recommendation runs are automatically deleted after 90 days.
    ///
    /// Parameters:
    ///   - clientToken: Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.
    ///   - createdRulesetName: A name for the ruleset.
    ///   - dataQualitySecurityConfiguration: The name of the security configuration created with the data quality encryption option.
    ///   - dataSource: The data source (Glue table) associated with this run.
    ///   - numberOfWorkers: The number of G.1X workers to be used in the run. The default is 5.
    ///   - role: An IAM role supplied to encrypt the results of the run.
    ///   - timeout: The timeout for a run in minutes. This is the maximum time that a run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    ///   - logger: Logger use during operation
    @inlinable
    public func startDataQualityRuleRecommendationRun(
        clientToken: String? = nil,
        createdRulesetName: String? = nil,
        dataQualitySecurityConfiguration: String? = nil,
        dataSource: DataSource,
        numberOfWorkers: Int? = nil,
        role: String,
        timeout: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartDataQualityRuleRecommendationRunResponse {
        let input = StartDataQualityRuleRecommendationRunRequest(
            clientToken: clientToken, 
            createdRulesetName: createdRulesetName, 
            dataQualitySecurityConfiguration: dataQualitySecurityConfiguration, 
            dataSource: dataSource, 
            numberOfWorkers: numberOfWorkers, 
            role: role, 
            timeout: timeout
        )
        return try await self.startDataQualityRuleRecommendationRun(input, logger: logger)
    }

    /// Once you have a ruleset definition (either recommended or your own), you call this operation to evaluate the ruleset against a data source (Glue table). The evaluation computes results which you can retrieve with the GetDataQualityResult API.
    @Sendable
    @inlinable
    public func startDataQualityRulesetEvaluationRun(_ input: StartDataQualityRulesetEvaluationRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartDataQualityRulesetEvaluationRunResponse {
        try await self.client.execute(
            operation: "StartDataQualityRulesetEvaluationRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Once you have a ruleset definition (either recommended or your own), you call this operation to evaluate the ruleset against a data source (Glue table). The evaluation computes results which you can retrieve with the GetDataQualityResult API.
    ///
    /// Parameters:
    ///   - additionalDataSources: A map of reference strings to additional data sources you can specify for an evaluation run.
    ///   - additionalRunOptions: Additional run options you can specify for an evaluation run.
    ///   - clientToken: Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating or starting multiple instances of the same resource.
    ///   - dataSource: The data source (Glue table) associated with this run.
    ///   - numberOfWorkers: The number of G.1X workers to be used in the run. The default is 5.
    ///   - role: An IAM role supplied to encrypt the results of the run.
    ///   - rulesetNames: A list of ruleset names.
    ///   - timeout: The timeout for a run in minutes. This is the maximum time that a run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    ///   - logger: Logger use during operation
    @inlinable
    public func startDataQualityRulesetEvaluationRun(
        additionalDataSources: [String: DataSource]? = nil,
        additionalRunOptions: DataQualityEvaluationRunAdditionalRunOptions? = nil,
        clientToken: String? = nil,
        dataSource: DataSource,
        numberOfWorkers: Int? = nil,
        role: String,
        rulesetNames: [String],
        timeout: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartDataQualityRulesetEvaluationRunResponse {
        let input = StartDataQualityRulesetEvaluationRunRequest(
            additionalDataSources: additionalDataSources, 
            additionalRunOptions: additionalRunOptions, 
            clientToken: clientToken, 
            dataSource: dataSource, 
            numberOfWorkers: numberOfWorkers, 
            role: role, 
            rulesetNames: rulesetNames, 
            timeout: timeout
        )
        return try await self.startDataQualityRulesetEvaluationRun(input, logger: logger)
    }

    /// Begins an asynchronous task to export all labeled data for a particular transform. This task is the only label-related API call that is not part of the typical active learning workflow. You typically use StartExportLabelsTaskRun when you want to work with all of your existing labels at the same time, such as when you want to remove or change labels that were previously submitted as truth. This API operation accepts the TransformId whose labels you want to export and an Amazon Simple Storage Service (Amazon S3) path to export the labels to. The operation returns a TaskRunId. You can check on the status of your task run by calling the GetMLTaskRun API.
    @Sendable
    @inlinable
    public func startExportLabelsTaskRun(_ input: StartExportLabelsTaskRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartExportLabelsTaskRunResponse {
        try await self.client.execute(
            operation: "StartExportLabelsTaskRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Begins an asynchronous task to export all labeled data for a particular transform. This task is the only label-related API call that is not part of the typical active learning workflow. You typically use StartExportLabelsTaskRun when you want to work with all of your existing labels at the same time, such as when you want to remove or change labels that were previously submitted as truth. This API operation accepts the TransformId whose labels you want to export and an Amazon Simple Storage Service (Amazon S3) path to export the labels to. The operation returns a TaskRunId. You can check on the status of your task run by calling the GetMLTaskRun API.
    ///
    /// Parameters:
    ///   - outputS3Path: The Amazon S3 path where you export the labels.
    ///   - transformId: The unique identifier of the machine learning transform.
    ///   - logger: Logger use during operation
    @inlinable
    public func startExportLabelsTaskRun(
        outputS3Path: String,
        transformId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartExportLabelsTaskRunResponse {
        let input = StartExportLabelsTaskRunRequest(
            outputS3Path: outputS3Path, 
            transformId: transformId
        )
        return try await self.startExportLabelsTaskRun(input, logger: logger)
    }

    /// Enables you to provide additional labels (examples of truth) to be used to teach the machine learning transform and improve its quality. This API operation is generally used as part of the active learning workflow that starts with the StartMLLabelingSetGenerationTaskRun call and that ultimately results in improving the quality of your machine learning transform.  After the StartMLLabelingSetGenerationTaskRun finishes, Glue machine learning will have generated a series of questions for humans to answer. (Answering these questions is often called 'labeling' in the machine learning workflows). In the case of the FindMatches transform, these questions are of the form, “What is the correct way to group these rows together into groups composed entirely of matching records?” After the labeling process is finished, users upload their answers/labels with a call to StartImportLabelsTaskRun. After StartImportLabelsTaskRun finishes, all future runs of the machine learning transform use the new and improved labels and perform a higher-quality transformation. By default, StartMLLabelingSetGenerationTaskRun continually learns from and combines all labels that you upload unless you set Replace to true. If you set Replace to true, StartImportLabelsTaskRun deletes and forgets all previously uploaded labels and learns only from the exact set that you upload. Replacing labels can be helpful if you realize that you previously uploaded incorrect labels, and you believe that they are having a negative effect on your transform quality. You can check on the status of your task run by calling the GetMLTaskRun operation.
    @Sendable
    @inlinable
    public func startImportLabelsTaskRun(_ input: StartImportLabelsTaskRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartImportLabelsTaskRunResponse {
        try await self.client.execute(
            operation: "StartImportLabelsTaskRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables you to provide additional labels (examples of truth) to be used to teach the machine learning transform and improve its quality. This API operation is generally used as part of the active learning workflow that starts with the StartMLLabelingSetGenerationTaskRun call and that ultimately results in improving the quality of your machine learning transform.  After the StartMLLabelingSetGenerationTaskRun finishes, Glue machine learning will have generated a series of questions for humans to answer. (Answering these questions is often called 'labeling' in the machine learning workflows). In the case of the FindMatches transform, these questions are of the form, “What is the correct way to group these rows together into groups composed entirely of matching records?” After the labeling process is finished, users upload their answers/labels with a call to StartImportLabelsTaskRun. After StartImportLabelsTaskRun finishes, all future runs of the machine learning transform use the new and improved labels and perform a higher-quality transformation. By default, StartMLLabelingSetGenerationTaskRun continually learns from and combines all labels that you upload unless you set Replace to true. If you set Replace to true, StartImportLabelsTaskRun deletes and forgets all previously uploaded labels and learns only from the exact set that you upload. Replacing labels can be helpful if you realize that you previously uploaded incorrect labels, and you believe that they are having a negative effect on your transform quality. You can check on the status of your task run by calling the GetMLTaskRun operation.
    ///
    /// Parameters:
    ///   - inputS3Path: The Amazon Simple Storage Service (Amazon S3) path from where you import the labels.
    ///   - replaceAllLabels: Indicates whether to overwrite your existing labels.
    ///   - transformId: The unique identifier of the machine learning transform.
    ///   - logger: Logger use during operation
    @inlinable
    public func startImportLabelsTaskRun(
        inputS3Path: String,
        replaceAllLabels: Bool? = nil,
        transformId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartImportLabelsTaskRunResponse {
        let input = StartImportLabelsTaskRunRequest(
            inputS3Path: inputS3Path, 
            replaceAllLabels: replaceAllLabels, 
            transformId: transformId
        )
        return try await self.startImportLabelsTaskRun(input, logger: logger)
    }

    /// Starts a job run using a job definition.
    @Sendable
    @inlinable
    public func startJobRun(_ input: StartJobRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartJobRunResponse {
        try await self.client.execute(
            operation: "StartJobRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a job run using a job definition.
    ///
    /// Parameters:
    ///   - arguments: The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep them within the Job.  For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the arguments you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue topic in the developer guide. For information about the arguments you can provide to this field when configuring Ray jobs, see Using job parameters in Ray jobs in the developer guide.
    ///   - executionClass: Indicates whether the job is run with a standard or flexible execution class. The standard execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated resources. The flexible execution class is appropriate for time-insensitive jobs whose start and completion times may vary.  Only jobs with Glue version 3.0 and above and command type glueetl will be allowed to set ExecutionClass to FLEX. The flexible execution class is available for Spark jobs.
    ///   - jobName: The name of the job definition to use.
    ///   - jobRunId: The ID of a previous JobRun to retry.
    ///   - jobRunQueuingEnabled: Specifies whether job run queuing is enabled for the job run. A value of true means job run queuing is enabled for the job run. If false or not populated, the job run will not be considered for queueing.
    ///   - maxCapacity: For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the  Glue pricing page. For Glue version 2.0+ jobs, you cannot specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers. Do not set MaxCapacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache  Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs.  The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
    ///   - notificationProperty: Specifies configuration properties of a job run notification.
    ///   - numberOfWorkers: The number of workers of a defined workerType that are allocated when a job runs.
    ///   - securityConfiguration: The name of the SecurityConfiguration structure to be used with this job run.
    ///   - timeout: The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. This value overrides the timeout value set in the parent job.  Streaming jobs must have timeout values less than 7 days or 10080 minutes. When the value is left blank, the job will be restarted after 7 days based if you have not setup a maintenance window. If you have setup maintenance window, it will be restarted during the maintenance window after 7 days.
    ///   - workerType: The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPUs, 32 GB of memory) with 128GB disk (approximately 77GB free), and provides 1 executor per worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to offers a scalable and cost effective way to run most jobs.   For the G.4X worker type, each worker maps to 4 DPU (16 vCPUs, 64 GB of memory) with 256GB disk (approximately 235GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm).   For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk (approximately 487GB free), and provides 1 executor per worker. We recommend this worker type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type.   For the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk (approximately 34GB free), and provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This worker type is only available for Glue version 3.0 streaming jobs.   For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk (approximately 120GB free), and provides up to 8 Ray workers based on the autoscaler.
    ///   - logger: Logger use during operation
    @inlinable
    public func startJobRun(
        arguments: [String: String]? = nil,
        executionClass: ExecutionClass? = nil,
        jobName: String,
        jobRunId: String? = nil,
        jobRunQueuingEnabled: Bool? = nil,
        maxCapacity: Double? = nil,
        notificationProperty: NotificationProperty? = nil,
        numberOfWorkers: Int? = nil,
        securityConfiguration: String? = nil,
        timeout: Int? = nil,
        workerType: WorkerType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartJobRunResponse {
        let input = StartJobRunRequest(
            arguments: arguments, 
            executionClass: executionClass, 
            jobName: jobName, 
            jobRunId: jobRunId, 
            jobRunQueuingEnabled: jobRunQueuingEnabled, 
            maxCapacity: maxCapacity, 
            notificationProperty: notificationProperty, 
            numberOfWorkers: numberOfWorkers, 
            securityConfiguration: securityConfiguration, 
            timeout: timeout, 
            workerType: workerType
        )
        return try await self.startJobRun(input, logger: logger)
    }

    /// Starts a task to estimate the quality of the transform.  When you provide label sets as examples of truth, Glue machine learning uses some of those examples to learn from them. The rest of the labels are used as a test to estimate quality. Returns a unique identifier for the run. You can call GetMLTaskRun to get more information about the stats of the EvaluationTaskRun.
    @Sendable
    @inlinable
    public func startMLEvaluationTaskRun(_ input: StartMLEvaluationTaskRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartMLEvaluationTaskRunResponse {
        try await self.client.execute(
            operation: "StartMLEvaluationTaskRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a task to estimate the quality of the transform.  When you provide label sets as examples of truth, Glue machine learning uses some of those examples to learn from them. The rest of the labels are used as a test to estimate quality. Returns a unique identifier for the run. You can call GetMLTaskRun to get more information about the stats of the EvaluationTaskRun.
    ///
    /// Parameters:
    ///   - transformId: The unique identifier of the machine learning transform.
    ///   - logger: Logger use during operation
    @inlinable
    public func startMLEvaluationTaskRun(
        transformId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartMLEvaluationTaskRunResponse {
        let input = StartMLEvaluationTaskRunRequest(
            transformId: transformId
        )
        return try await self.startMLEvaluationTaskRun(input, logger: logger)
    }

    /// Starts the active learning workflow for your machine learning transform to improve the transform's quality by generating label sets and adding labels. When the StartMLLabelingSetGenerationTaskRun finishes, Glue will have generated a "labeling set" or a set of questions for humans to answer. In the case of the FindMatches transform, these questions are of the form, “What is the correct way to group these rows together into groups composed entirely of matching records?”  After the labeling process is finished, you can upload your labels with a call to StartImportLabelsTaskRun. After StartImportLabelsTaskRun finishes, all future runs of the machine learning transform will use the new and improved labels and perform a higher-quality transformation.
    @Sendable
    @inlinable
    public func startMLLabelingSetGenerationTaskRun(_ input: StartMLLabelingSetGenerationTaskRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartMLLabelingSetGenerationTaskRunResponse {
        try await self.client.execute(
            operation: "StartMLLabelingSetGenerationTaskRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts the active learning workflow for your machine learning transform to improve the transform's quality by generating label sets and adding labels. When the StartMLLabelingSetGenerationTaskRun finishes, Glue will have generated a "labeling set" or a set of questions for humans to answer. In the case of the FindMatches transform, these questions are of the form, “What is the correct way to group these rows together into groups composed entirely of matching records?”  After the labeling process is finished, you can upload your labels with a call to StartImportLabelsTaskRun. After StartImportLabelsTaskRun finishes, all future runs of the machine learning transform will use the new and improved labels and perform a higher-quality transformation.
    ///
    /// Parameters:
    ///   - outputS3Path: The Amazon Simple Storage Service (Amazon S3) path where you generate the labeling set.
    ///   - transformId: The unique identifier of the machine learning transform.
    ///   - logger: Logger use during operation
    @inlinable
    public func startMLLabelingSetGenerationTaskRun(
        outputS3Path: String,
        transformId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartMLLabelingSetGenerationTaskRunResponse {
        let input = StartMLLabelingSetGenerationTaskRunRequest(
            outputS3Path: outputS3Path, 
            transformId: transformId
        )
        return try await self.startMLLabelingSetGenerationTaskRun(input, logger: logger)
    }

    /// Starts an existing trigger. See Triggering Jobs for information about how different types of trigger are started.
    @Sendable
    @inlinable
    public func startTrigger(_ input: StartTriggerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartTriggerResponse {
        try await self.client.execute(
            operation: "StartTrigger", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts an existing trigger. See Triggering Jobs for information about how different types of trigger are started.
    ///
    /// Parameters:
    ///   - name: The name of the trigger to start.
    ///   - logger: Logger use during operation
    @inlinable
    public func startTrigger(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartTriggerResponse {
        let input = StartTriggerRequest(
            name: name
        )
        return try await self.startTrigger(input, logger: logger)
    }

    /// Starts a new run of the specified workflow.
    @Sendable
    @inlinable
    public func startWorkflowRun(_ input: StartWorkflowRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartWorkflowRunResponse {
        try await self.client.execute(
            operation: "StartWorkflowRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a new run of the specified workflow.
    ///
    /// Parameters:
    ///   - name: The name of the workflow to start.
    ///   - runProperties: The workflow run properties for the new workflow run.
    ///   - logger: Logger use during operation
    @inlinable
    public func startWorkflowRun(
        name: String,
        runProperties: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartWorkflowRunResponse {
        let input = StartWorkflowRunRequest(
            name: name, 
            runProperties: runProperties
        )
        return try await self.startWorkflowRun(input, logger: logger)
    }

    /// Stops a task run for the specified table.
    @Sendable
    @inlinable
    public func stopColumnStatisticsTaskRun(_ input: StopColumnStatisticsTaskRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopColumnStatisticsTaskRunResponse {
        try await self.client.execute(
            operation: "StopColumnStatisticsTaskRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops a task run for the specified table.
    ///
    /// Parameters:
    ///   - databaseName: The name of the database where the table resides.
    ///   - tableName: The name of the table.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopColumnStatisticsTaskRun(
        databaseName: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopColumnStatisticsTaskRunResponse {
        let input = StopColumnStatisticsTaskRunRequest(
            databaseName: databaseName, 
            tableName: tableName
        )
        return try await self.stopColumnStatisticsTaskRun(input, logger: logger)
    }

    /// Stops a column statistics task run schedule.
    @Sendable
    @inlinable
    public func stopColumnStatisticsTaskRunSchedule(_ input: StopColumnStatisticsTaskRunScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopColumnStatisticsTaskRunScheduleResponse {
        try await self.client.execute(
            operation: "StopColumnStatisticsTaskRunSchedule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops a column statistics task run schedule.
    ///
    /// Parameters:
    ///   - databaseName: The name of the database where the table resides.
    ///   - tableName: The name of the table for which to stop a column statistic task run schedule.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopColumnStatisticsTaskRunSchedule(
        databaseName: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopColumnStatisticsTaskRunScheduleResponse {
        let input = StopColumnStatisticsTaskRunScheduleRequest(
            databaseName: databaseName, 
            tableName: tableName
        )
        return try await self.stopColumnStatisticsTaskRunSchedule(input, logger: logger)
    }

    /// If the specified crawler is running, stops the crawl.
    @Sendable
    @inlinable
    public func stopCrawler(_ input: StopCrawlerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopCrawlerResponse {
        try await self.client.execute(
            operation: "StopCrawler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// If the specified crawler is running, stops the crawl.
    ///
    /// Parameters:
    ///   - name: Name of the crawler to stop.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopCrawler(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopCrawlerResponse {
        let input = StopCrawlerRequest(
            name: name
        )
        return try await self.stopCrawler(input, logger: logger)
    }

    /// Sets the schedule state of the specified crawler to NOT_SCHEDULED, but does not stop the crawler if it is already running.
    @Sendable
    @inlinable
    public func stopCrawlerSchedule(_ input: StopCrawlerScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopCrawlerScheduleResponse {
        try await self.client.execute(
            operation: "StopCrawlerSchedule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets the schedule state of the specified crawler to NOT_SCHEDULED, but does not stop the crawler if it is already running.
    ///
    /// Parameters:
    ///   - crawlerName: Name of the crawler whose schedule state to set.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopCrawlerSchedule(
        crawlerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopCrawlerScheduleResponse {
        let input = StopCrawlerScheduleRequest(
            crawlerName: crawlerName
        )
        return try await self.stopCrawlerSchedule(input, logger: logger)
    }

    /// Stops the session.
    @Sendable
    @inlinable
    public func stopSession(_ input: StopSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopSessionResponse {
        try await self.client.execute(
            operation: "StopSession", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops the session.
    ///
    /// Parameters:
    ///   - id: The ID of the session to be stopped.
    ///   - requestOrigin: The origin of the request.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopSession(
        id: String,
        requestOrigin: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopSessionResponse {
        let input = StopSessionRequest(
            id: id, 
            requestOrigin: requestOrigin
        )
        return try await self.stopSession(input, logger: logger)
    }

    /// Stops a specified trigger.
    @Sendable
    @inlinable
    public func stopTrigger(_ input: StopTriggerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopTriggerResponse {
        try await self.client.execute(
            operation: "StopTrigger", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops a specified trigger.
    ///
    /// Parameters:
    ///   - name: The name of the trigger to stop.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopTrigger(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopTriggerResponse {
        let input = StopTriggerRequest(
            name: name
        )
        return try await self.stopTrigger(input, logger: logger)
    }

    /// Stops the execution of the specified workflow run.
    @Sendable
    @inlinable
    public func stopWorkflowRun(_ input: StopWorkflowRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopWorkflowRunResponse {
        try await self.client.execute(
            operation: "StopWorkflowRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops the execution of the specified workflow run.
    ///
    /// Parameters:
    ///   - name: The name of the workflow to stop.
    ///   - runId: The ID of the workflow run to stop.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopWorkflowRun(
        name: String,
        runId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopWorkflowRunResponse {
        let input = StopWorkflowRunRequest(
            name: name, 
            runId: runId
        )
        return try await self.stopWorkflowRun(input, logger: logger)
    }

    /// Adds tags to a resource. A tag is a label you can assign to an Amazon Web Services resource. In Glue, you can tag only certain resources. For information about what resources you can tag, see Amazon Web Services Tags in Glue.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds tags to a resource. A tag is a label you can assign to an Amazon Web Services resource. In Glue, you can tag only certain resources. For information about what resources you can tag, see Amazon Web Services Tags in Glue.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the Glue resource to which to add the tags. For more information about Glue resource ARNs, see the Glue ARN string pattern.
    ///   - tagsToAdd: Tags to add to this resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tagsToAdd: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tagsToAdd: tagsToAdd
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Tests a connection to a service to validate the service credentials that you provide. You can either provide an existing connection name or a TestConnectionInput for testing a non-existing connection input. Providing both at the same time will cause an error. If the action is successful, the service sends back an HTTP 200 response.
    @Sendable
    @inlinable
    public func testConnection(_ input: TestConnectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TestConnectionResponse {
        try await self.client.execute(
            operation: "TestConnection", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Tests a connection to a service to validate the service credentials that you provide. You can either provide an existing connection name or a TestConnectionInput for testing a non-existing connection input. Providing both at the same time will cause an error. If the action is successful, the service sends back an HTTP 200 response.
    ///
    /// Parameters:
    ///   - catalogId: The catalog ID where the connection resides.
    ///   - connectionName: Optional. The name of the connection to test. If only name is provided, the operation will get the connection and use that for testing.
    ///   - testConnectionInput: A structure that is used to specify testing a connection to a service.
    ///   - logger: Logger use during operation
    @inlinable
    public func testConnection(
        catalogId: String? = nil,
        connectionName: String? = nil,
        testConnectionInput: TestConnectionInput? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TestConnectionResponse {
        let input = TestConnectionRequest(
            catalogId: catalogId, 
            connectionName: connectionName, 
            testConnectionInput: testConnectionInput
        )
        return try await self.testConnection(input, logger: logger)
    }

    /// Removes tags from a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes tags from a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource from which to remove the tags.
    ///   - tagsToRemove: Tags to remove from this resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagsToRemove: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagsToRemove: tagsToRemove
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates a registered blueprint.
    @Sendable
    @inlinable
    public func updateBlueprint(_ input: UpdateBlueprintRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBlueprintResponse {
        try await self.client.execute(
            operation: "UpdateBlueprint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a registered blueprint.
    ///
    /// Parameters:
    ///   - blueprintLocation: Specifies a path in Amazon S3 where the blueprint is published.
    ///   - description: A description of the blueprint.
    ///   - name: The name of the blueprint.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBlueprint(
        blueprintLocation: String,
        description: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBlueprintResponse {
        let input = UpdateBlueprintRequest(
            blueprintLocation: blueprintLocation, 
            description: description, 
            name: name
        )
        return try await self.updateBlueprint(input, logger: logger)
    }

    /// Updates an existing catalog's properties in the Glue Data Catalog.
    @Sendable
    @inlinable
    public func updateCatalog(_ input: UpdateCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCatalogResponse {
        try await self.client.execute(
            operation: "UpdateCatalog", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing catalog's properties in the Glue Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the catalog.
    ///   - catalogInput: A CatalogInput object specifying the new properties of an existing catalog.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCatalog(
        catalogId: String,
        catalogInput: CatalogInput,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCatalogResponse {
        let input = UpdateCatalogRequest(
            catalogId: catalogId, 
            catalogInput: catalogInput
        )
        return try await self.updateCatalog(input, logger: logger)
    }

    /// Modifies an existing classifier (a GrokClassifier, an XMLClassifier, a JsonClassifier, or a CsvClassifier, depending on which field is present).
    @Sendable
    @inlinable
    public func updateClassifier(_ input: UpdateClassifierRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateClassifierResponse {
        try await self.client.execute(
            operation: "UpdateClassifier", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modifies an existing classifier (a GrokClassifier, an XMLClassifier, a JsonClassifier, or a CsvClassifier, depending on which field is present).
    ///
    /// Parameters:
    ///   - csvClassifier: A CsvClassifier object with updated fields.
    ///   - grokClassifier: A GrokClassifier object with updated fields.
    ///   - jsonClassifier: A JsonClassifier object with updated fields.
    ///   - xmlClassifier: An XMLClassifier object with updated fields.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateClassifier(
        csvClassifier: UpdateCsvClassifierRequest? = nil,
        grokClassifier: UpdateGrokClassifierRequest? = nil,
        jsonClassifier: UpdateJsonClassifierRequest? = nil,
        xmlClassifier: UpdateXMLClassifierRequest? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateClassifierResponse {
        let input = UpdateClassifierRequest(
            csvClassifier: csvClassifier, 
            grokClassifier: grokClassifier, 
            jsonClassifier: jsonClassifier, 
            xmlClassifier: xmlClassifier
        )
        return try await self.updateClassifier(input, logger: logger)
    }

    /// Creates or updates partition statistics of columns. The Identity and Access Management (IAM) permission required for this operation is UpdatePartition.
    @Sendable
    @inlinable
    public func updateColumnStatisticsForPartition(_ input: UpdateColumnStatisticsForPartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateColumnStatisticsForPartitionResponse {
        try await self.client.execute(
            operation: "UpdateColumnStatisticsForPartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates or updates partition statistics of columns. The Identity and Access Management (IAM) permission required for this operation is UpdatePartition.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    ///   - columnStatisticsList: A list of the column statistics.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - partitionValues: A list of partition values identifying the partition.
    ///   - tableName: The name of the partitions' table.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateColumnStatisticsForPartition(
        catalogId: String? = nil,
        columnStatisticsList: [ColumnStatistics],
        databaseName: String,
        partitionValues: [String],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateColumnStatisticsForPartitionResponse {
        let input = UpdateColumnStatisticsForPartitionRequest(
            catalogId: catalogId, 
            columnStatisticsList: columnStatisticsList, 
            databaseName: databaseName, 
            partitionValues: partitionValues, 
            tableName: tableName
        )
        return try await self.updateColumnStatisticsForPartition(input, logger: logger)
    }

    /// Creates or updates table statistics of columns. The Identity and Access Management (IAM) permission required for this operation is UpdateTable.
    @Sendable
    @inlinable
    public func updateColumnStatisticsForTable(_ input: UpdateColumnStatisticsForTableRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateColumnStatisticsForTableResponse {
        try await self.client.execute(
            operation: "UpdateColumnStatisticsForTable", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates or updates table statistics of columns. The Identity and Access Management (IAM) permission required for this operation is UpdateTable.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
    ///   - columnStatisticsList: A list of the column statistics.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - tableName: The name of the partitions' table.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateColumnStatisticsForTable(
        catalogId: String? = nil,
        columnStatisticsList: [ColumnStatistics],
        databaseName: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateColumnStatisticsForTableResponse {
        let input = UpdateColumnStatisticsForTableRequest(
            catalogId: catalogId, 
            columnStatisticsList: columnStatisticsList, 
            databaseName: databaseName, 
            tableName: tableName
        )
        return try await self.updateColumnStatisticsForTable(input, logger: logger)
    }

    /// Updates settings for a column statistics task.
    @Sendable
    @inlinable
    public func updateColumnStatisticsTaskSettings(_ input: UpdateColumnStatisticsTaskSettingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateColumnStatisticsTaskSettingsResponse {
        try await self.client.execute(
            operation: "UpdateColumnStatisticsTaskSettings", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates settings for a column statistics task.
    ///
    /// Parameters:
    ///   - catalogID: The ID of the Data Catalog in which the database resides.
    ///   - columnNameList: A list of column names for which to run statistics.
    ///   - databaseName: The name of the database where the table resides.
    ///   - role: The role used for running the column statistics.
    ///   - sampleSize: The percentage of data to sample.
    ///   - schedule: A schedule for running the column statistics, specified in CRON syntax.
    ///   - securityConfiguration: Name of the security configuration that is used to encrypt CloudWatch logs.
    ///   - tableName: The name of the table for which to generate column statistics.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateColumnStatisticsTaskSettings(
        catalogID: String? = nil,
        columnNameList: [String]? = nil,
        databaseName: String,
        role: String? = nil,
        sampleSize: Double? = nil,
        schedule: String? = nil,
        securityConfiguration: String? = nil,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateColumnStatisticsTaskSettingsResponse {
        let input = UpdateColumnStatisticsTaskSettingsRequest(
            catalogID: catalogID, 
            columnNameList: columnNameList, 
            databaseName: databaseName, 
            role: role, 
            sampleSize: sampleSize, 
            schedule: schedule, 
            securityConfiguration: securityConfiguration, 
            tableName: tableName
        )
        return try await self.updateColumnStatisticsTaskSettings(input, logger: logger)
    }

    /// Updates a connection definition in the Data Catalog.
    @Sendable
    @inlinable
    public func updateConnection(_ input: UpdateConnectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateConnectionResponse {
        try await self.client.execute(
            operation: "UpdateConnection", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a connection definition in the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - connectionInput: A ConnectionInput object that redefines the connection in question.
    ///   - name: The name of the connection definition to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateConnection(
        catalogId: String? = nil,
        connectionInput: ConnectionInput,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateConnectionResponse {
        let input = UpdateConnectionRequest(
            catalogId: catalogId, 
            connectionInput: connectionInput, 
            name: name
        )
        return try await self.updateConnection(input, logger: logger)
    }

    /// Updates a crawler. If a crawler is running, you must stop it using StopCrawler before updating it.
    @Sendable
    @inlinable
    public func updateCrawler(_ input: UpdateCrawlerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCrawlerResponse {
        try await self.client.execute(
            operation: "UpdateCrawler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a crawler. If a crawler is running, you must stop it using StopCrawler before updating it.
    ///
    /// Parameters:
    ///   - classifiers: A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
    ///   - configuration: Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Setting crawler configuration options.
    ///   - crawlerSecurityConfiguration: The name of the SecurityConfiguration structure to be used by this crawler.
    ///   - databaseName: The Glue database where results are stored, such as: arn:aws:daylight:us-east-1::database/sometable/*.
    ///   - description: A description of the new crawler.
    ///   - lakeFormationConfiguration: Specifies Lake Formation configuration settings for the crawler.
    ///   - lineageConfiguration: Specifies data lineage configuration settings for the crawler.
    ///   - name: Name of the new crawler.
    ///   - recrawlPolicy: A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
    ///   - role: The IAM role or Amazon Resource Name (ARN) of an IAM role that is used by the new crawler to access customer resources.
    ///   - schedule: A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
    ///   - schemaChangePolicy: The policy for the crawler's update and deletion behavior.
    ///   - tablePrefix: The table prefix used for catalog tables that are created.
    ///   - targets: A list of targets to crawl.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCrawler(
        classifiers: [String]? = nil,
        configuration: String? = nil,
        crawlerSecurityConfiguration: String? = nil,
        databaseName: String? = nil,
        description: String? = nil,
        lakeFormationConfiguration: LakeFormationConfiguration? = nil,
        lineageConfiguration: LineageConfiguration? = nil,
        name: String,
        recrawlPolicy: RecrawlPolicy? = nil,
        role: String? = nil,
        schedule: String? = nil,
        schemaChangePolicy: SchemaChangePolicy? = nil,
        tablePrefix: String? = nil,
        targets: CrawlerTargets? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCrawlerResponse {
        let input = UpdateCrawlerRequest(
            classifiers: classifiers, 
            configuration: configuration, 
            crawlerSecurityConfiguration: crawlerSecurityConfiguration, 
            databaseName: databaseName, 
            description: description, 
            lakeFormationConfiguration: lakeFormationConfiguration, 
            lineageConfiguration: lineageConfiguration, 
            name: name, 
            recrawlPolicy: recrawlPolicy, 
            role: role, 
            schedule: schedule, 
            schemaChangePolicy: schemaChangePolicy, 
            tablePrefix: tablePrefix, 
            targets: targets
        )
        return try await self.updateCrawler(input, logger: logger)
    }

    /// Updates the schedule of a crawler using a cron expression.
    @Sendable
    @inlinable
    public func updateCrawlerSchedule(_ input: UpdateCrawlerScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCrawlerScheduleResponse {
        try await self.client.execute(
            operation: "UpdateCrawlerSchedule", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the schedule of a crawler using a cron expression.
    ///
    /// Parameters:
    ///   - crawlerName: The name of the crawler whose schedule to update.
    ///   - schedule: The updated cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCrawlerSchedule(
        crawlerName: String,
        schedule: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCrawlerScheduleResponse {
        let input = UpdateCrawlerScheduleRequest(
            crawlerName: crawlerName, 
            schedule: schedule
        )
        return try await self.updateCrawlerSchedule(input, logger: logger)
    }

    /// Updates the specified data quality ruleset.
    @Sendable
    @inlinable
    public func updateDataQualityRuleset(_ input: UpdateDataQualityRulesetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDataQualityRulesetResponse {
        try await self.client.execute(
            operation: "UpdateDataQualityRuleset", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified data quality ruleset.
    ///
    /// Parameters:
    ///   - description: A description of the ruleset.
    ///   - name: The name of the data quality ruleset.
    ///   - ruleset: A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer guide.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDataQualityRuleset(
        description: String? = nil,
        name: String,
        ruleset: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDataQualityRulesetResponse {
        let input = UpdateDataQualityRulesetRequest(
            description: description, 
            name: name, 
            ruleset: ruleset
        )
        return try await self.updateDataQualityRuleset(input, logger: logger)
    }

    /// Updates an existing database definition in a Data Catalog.
    @Sendable
    @inlinable
    public func updateDatabase(_ input: UpdateDatabaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDatabaseResponse {
        try await self.client.execute(
            operation: "UpdateDatabase", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing database definition in a Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog in which the metadata database resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseInput: A DatabaseInput object specifying the new definition of the metadata database in the catalog.
    ///   - name: The name of the database to update in the catalog. For Hive compatibility, this is folded to lowercase.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDatabase(
        catalogId: String? = nil,
        databaseInput: DatabaseInput,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDatabaseResponse {
        let input = UpdateDatabaseRequest(
            catalogId: catalogId, 
            databaseInput: databaseInput, 
            name: name
        )
        return try await self.updateDatabase(input, logger: logger)
    }

    /// Updates a specified development endpoint.
    @Sendable
    @inlinable
    public func updateDevEndpoint(_ input: UpdateDevEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDevEndpointResponse {
        try await self.client.execute(
            operation: "UpdateDevEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a specified development endpoint.
    ///
    /// Parameters:
    ///   - addArguments: The map of arguments to add the map of arguments used to configure the DevEndpoint. Valid arguments are:    "--enable-glue-datacatalog": ""    You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
    ///   - addPublicKeys: The list of public keys for the DevEndpoint to use.
    ///   - customLibraries: Custom Python or Java libraries to be loaded in the DevEndpoint.
    ///   - deleteArguments: The list of argument keys to be deleted from the map of arguments used to configure the DevEndpoint.
    ///   - deletePublicKeys: The list of public keys to be deleted from the DevEndpoint.
    ///   - endpointName: The name of the DevEndpoint to be updated.
    ///   - publicKey: The public key for the DevEndpoint to use.
    ///   - updateEtlLibraries:  True if the list of custom libraries to be loaded in the development endpoint needs to be updated, or False if otherwise.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDevEndpoint(
        addArguments: [String: String]? = nil,
        addPublicKeys: [String]? = nil,
        customLibraries: DevEndpointCustomLibraries? = nil,
        deleteArguments: [String]? = nil,
        deletePublicKeys: [String]? = nil,
        endpointName: String,
        publicKey: String? = nil,
        updateEtlLibraries: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDevEndpointResponse {
        let input = UpdateDevEndpointRequest(
            addArguments: addArguments, 
            addPublicKeys: addPublicKeys, 
            customLibraries: customLibraries, 
            deleteArguments: deleteArguments, 
            deletePublicKeys: deletePublicKeys, 
            endpointName: endpointName, 
            publicKey: publicKey, 
            updateEtlLibraries: updateEtlLibraries
        )
        return try await self.updateDevEndpoint(input, logger: logger)
    }

    /// This API can be used for updating the ResourceProperty of the Glue connection (for the source) or Glue database ARN (for the target). These properties can include the role to access the connection or database. Since the same resource can be used across multiple integrations, updating resource properties will impact all the integrations using it.
    @Sendable
    @inlinable
    public func updateIntegrationResourceProperty(_ input: UpdateIntegrationResourcePropertyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIntegrationResourcePropertyResponse {
        try await self.client.execute(
            operation: "UpdateIntegrationResourceProperty", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// This API can be used for updating the ResourceProperty of the Glue connection (for the source) or Glue database ARN (for the target). These properties can include the role to access the connection or database. Since the same resource can be used across multiple integrations, updating resource properties will impact all the integrations using it.
    ///
    /// Parameters:
    ///   - resourceArn: The connection ARN of the source, or the database ARN of the target.
    ///   - sourceProcessingProperties: The resource properties associated with the integration source.
    ///   - targetProcessingProperties: The resource properties associated with the integration target.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIntegrationResourceProperty(
        resourceArn: String,
        sourceProcessingProperties: SourceProcessingProperties? = nil,
        targetProcessingProperties: TargetProcessingProperties? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateIntegrationResourcePropertyResponse {
        let input = UpdateIntegrationResourcePropertyRequest(
            resourceArn: resourceArn, 
            sourceProcessingProperties: sourceProcessingProperties, 
            targetProcessingProperties: targetProcessingProperties
        )
        return try await self.updateIntegrationResourceProperty(input, logger: logger)
    }

    /// This API is used to provide optional override properties for the tables that need to be replicated. These properties can include properties for filtering and partitioning for the source and target tables. To set both source and target properties the same API need to be invoked with the Glue connection ARN as ResourceArn with SourceTableConfig, and the Glue database ARN as ResourceArn with TargetTableConfig respectively. The override will be reflected across all the integrations using same ResourceArn and source table.
    @Sendable
    @inlinable
    public func updateIntegrationTableProperties(_ input: UpdateIntegrationTablePropertiesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIntegrationTablePropertiesResponse {
        try await self.client.execute(
            operation: "UpdateIntegrationTableProperties", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// This API is used to provide optional override properties for the tables that need to be replicated. These properties can include properties for filtering and partitioning for the source and target tables. To set both source and target properties the same API need to be invoked with the Glue connection ARN as ResourceArn with SourceTableConfig, and the Glue database ARN as ResourceArn with TargetTableConfig respectively. The override will be reflected across all the integrations using same ResourceArn and source table.
    ///
    /// Parameters:
    ///   - resourceArn: The connection ARN of the source, or the database ARN of the target.
    ///   - sourceTableConfig: A structure for the source table configuration.
    ///   - tableName: The name of the table to be replicated.
    ///   - targetTableConfig: A structure for the target table configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIntegrationTableProperties(
        resourceArn: String,
        sourceTableConfig: SourceTableConfig? = nil,
        tableName: String,
        targetTableConfig: TargetTableConfig? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateIntegrationTablePropertiesResponse {
        let input = UpdateIntegrationTablePropertiesRequest(
            resourceArn: resourceArn, 
            sourceTableConfig: sourceTableConfig, 
            tableName: tableName, 
            targetTableConfig: targetTableConfig
        )
        return try await self.updateIntegrationTableProperties(input, logger: logger)
    }

    /// Updates an existing job definition. The previous job definition is completely overwritten by this information.
    @Sendable
    @inlinable
    public func updateJob(_ input: UpdateJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateJobResponse {
        try await self.client.execute(
            operation: "UpdateJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing job definition. The previous job definition is completely overwritten by this information.
    ///
    /// Parameters:
    ///   - jobName: The name of the job definition to update.
    ///   - jobUpdate: Specifies the values with which to update the job definition. Unspecified configuration is removed or reset to default values.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateJob(
        jobName: String,
        jobUpdate: JobUpdate,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateJobResponse {
        let input = UpdateJobRequest(
            jobName: jobName, 
            jobUpdate: jobUpdate
        )
        return try await self.updateJob(input, logger: logger)
    }

    /// Synchronizes a job from the source control repository. This operation takes the job artifacts that are located in the remote repository and updates the Glue internal stores with these artifacts. This API supports optional parameters which take in the repository information.
    @Sendable
    @inlinable
    public func updateJobFromSourceControl(_ input: UpdateJobFromSourceControlRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateJobFromSourceControlResponse {
        try await self.client.execute(
            operation: "UpdateJobFromSourceControl", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Synchronizes a job from the source control repository. This operation takes the job artifacts that are located in the remote repository and updates the Glue internal stores with these artifacts. This API supports optional parameters which take in the repository information.
    ///
    /// Parameters:
    ///   - authStrategy: The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.
    ///   - authToken: The value of the authorization token.
    ///   - branchName: An optional branch in the remote repository.
    ///   - commitId: A commit ID for a commit in the remote repository.
    ///   - folder: An optional folder in the remote repository.
    ///   - jobName: The name of the Glue job to be synchronized to or from the remote repository.
    ///   - provider:  The provider for the remote repository. Possible values: GITHUB, AWS_CODE_COMMIT, GITLAB, BITBUCKET.
    ///   - repositoryName: The name of the remote repository that contains the job artifacts.  For BitBucket providers, RepositoryName should include WorkspaceName. Use the format /.
    ///   - repositoryOwner: The owner of the remote repository that contains the job artifacts.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateJobFromSourceControl(
        authStrategy: SourceControlAuthStrategy? = nil,
        authToken: String? = nil,
        branchName: String? = nil,
        commitId: String? = nil,
        folder: String? = nil,
        jobName: String? = nil,
        provider: SourceControlProvider? = nil,
        repositoryName: String? = nil,
        repositoryOwner: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateJobFromSourceControlResponse {
        let input = UpdateJobFromSourceControlRequest(
            authStrategy: authStrategy, 
            authToken: authToken, 
            branchName: branchName, 
            commitId: commitId, 
            folder: folder, 
            jobName: jobName, 
            provider: provider, 
            repositoryName: repositoryName, 
            repositoryOwner: repositoryOwner
        )
        return try await self.updateJobFromSourceControl(input, logger: logger)
    }

    /// Updates an existing machine learning transform. Call this operation to tune the algorithm parameters to achieve better results. After calling this operation, you can call the StartMLEvaluationTaskRun operation to assess how well your new parameters achieved your goals (such as improving the quality of your machine learning transform, or making it more cost-effective).
    @Sendable
    @inlinable
    public func updateMLTransform(_ input: UpdateMLTransformRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateMLTransformResponse {
        try await self.client.execute(
            operation: "UpdateMLTransform", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing machine learning transform. Call this operation to tune the algorithm parameters to achieve better results. After calling this operation, you can call the StartMLEvaluationTaskRun operation to assess how well your new parameters achieved your goals (such as improving the quality of your machine learning transform, or making it more cost-effective).
    ///
    /// Parameters:
    ///   - description: A description of the transform. The default is an empty string.
    ///   - glueVersion: This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9.  For more information, see Glue Versions in the developer guide.
    ///   - maxCapacity: The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.  When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
    ///   - maxRetries: The maximum number of times to retry a task for this transform after a task run fails.
    ///   - name: The unique name that you gave the transform when you created it.
    ///   - numberOfWorkers: The number of workers of a defined workerType that are allocated when this task runs.
    ///   - parameters: The configuration parameters that are specific to the transform type (algorithm) used. Conditionally dependent on the transform type.
    ///   - role: The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.
    ///   - timeout: The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
    ///   - transformId: A unique identifier that was generated when the transform was created.
    ///   - workerType: The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateMLTransform(
        description: String? = nil,
        glueVersion: String? = nil,
        maxCapacity: Double? = nil,
        maxRetries: Int? = nil,
        name: String? = nil,
        numberOfWorkers: Int? = nil,
        parameters: TransformParameters? = nil,
        role: String? = nil,
        timeout: Int? = nil,
        transformId: String,
        workerType: WorkerType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateMLTransformResponse {
        let input = UpdateMLTransformRequest(
            description: description, 
            glueVersion: glueVersion, 
            maxCapacity: maxCapacity, 
            maxRetries: maxRetries, 
            name: name, 
            numberOfWorkers: numberOfWorkers, 
            parameters: parameters, 
            role: role, 
            timeout: timeout, 
            transformId: transformId, 
            workerType: workerType
        )
        return try await self.updateMLTransform(input, logger: logger)
    }

    /// Updates a partition.
    @Sendable
    @inlinable
    public func updatePartition(_ input: UpdatePartitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePartitionResponse {
        try await self.client.execute(
            operation: "UpdatePartition", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a partition.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partition to be updated resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database in which the table in question resides.
    ///   - partitionInput: The new partition object to update the partition to. The Values property can't be changed. If you want to change the partition key values for a partition, delete and recreate the partition.
    ///   - partitionValueList: List of partition key values that define the partition to update.
    ///   - tableName: The name of the table in which the partition to be updated is located.
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePartition(
        catalogId: String? = nil,
        databaseName: String,
        partitionInput: PartitionInput,
        partitionValueList: [String],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePartitionResponse {
        let input = UpdatePartitionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            partitionInput: partitionInput, 
            partitionValueList: partitionValueList, 
            tableName: tableName
        )
        return try await self.updatePartition(input, logger: logger)
    }

    /// Updates an existing registry which is used to hold a collection of schemas. The updated properties relate to the registry, and do not modify any of the schemas within the registry.
    @Sendable
    @inlinable
    public func updateRegistry(_ input: UpdateRegistryInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRegistryResponse {
        try await self.client.execute(
            operation: "UpdateRegistry", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing registry which is used to hold a collection of schemas. The updated properties relate to the registry, and do not modify any of the schemas within the registry.
    ///
    /// Parameters:
    ///   - description: A description of the registry. If description is not provided, this field will not be updated.
    ///   - registryId: This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRegistry(
        description: String,
        registryId: RegistryId,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRegistryResponse {
        let input = UpdateRegistryInput(
            description: description, 
            registryId: registryId
        )
        return try await self.updateRegistry(input, logger: logger)
    }

    /// Updates the description, compatibility setting, or version checkpoint for a schema set. For updating the compatibility setting, the call will not validate compatibility for the entire set of schema versions with the new compatibility setting. If the value for Compatibility is provided, the VersionNumber (a checkpoint) is also required. The API will validate the checkpoint version number for consistency. If the value for the VersionNumber (checkpoint) is provided, Compatibility is optional and this can be used to set/reset a checkpoint for the schema. This update will happen only if the schema is in the AVAILABLE state.
    @Sendable
    @inlinable
    public func updateSchema(_ input: UpdateSchemaInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSchemaResponse {
        try await self.client.execute(
            operation: "UpdateSchema", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the description, compatibility setting, or version checkpoint for a schema set. For updating the compatibility setting, the call will not validate compatibility for the entire set of schema versions with the new compatibility setting. If the value for Compatibility is provided, the VersionNumber (a checkpoint) is also required. The API will validate the checkpoint version number for consistency. If the value for the VersionNumber (checkpoint) is provided, Compatibility is optional and this can be used to set/reset a checkpoint for the schema. This update will happen only if the schema is in the AVAILABLE state.
    ///
    /// Parameters:
    ///   - compatibility: The new compatibility setting for the schema.
    ///   - description: The new description for the schema.
    ///   - schemaId: This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.   SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
    ///   - schemaVersionNumber: Version number required for check pointing. One of VersionNumber or Compatibility has to be provided.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSchema(
        compatibility: Compatibility? = nil,
        description: String? = nil,
        schemaId: SchemaId,
        schemaVersionNumber: SchemaVersionNumber? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSchemaResponse {
        let input = UpdateSchemaInput(
            compatibility: compatibility, 
            description: description, 
            schemaId: schemaId, 
            schemaVersionNumber: schemaVersionNumber
        )
        return try await self.updateSchema(input, logger: logger)
    }

    /// Synchronizes a job to the source control repository. This operation takes the job artifacts from the Glue internal stores and makes a commit to the remote repository that is configured on the job. This API supports optional parameters which take in the repository information.
    @Sendable
    @inlinable
    public func updateSourceControlFromJob(_ input: UpdateSourceControlFromJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSourceControlFromJobResponse {
        try await self.client.execute(
            operation: "UpdateSourceControlFromJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Synchronizes a job to the source control repository. This operation takes the job artifacts from the Glue internal stores and makes a commit to the remote repository that is configured on the job. This API supports optional parameters which take in the repository information.
    ///
    /// Parameters:
    ///   - authStrategy: The type of authentication, which can be an authentication token stored in Amazon Web Services Secrets Manager, or a personal access token.
    ///   - authToken: The value of the authorization token.
    ///   - branchName: An optional branch in the remote repository.
    ///   - commitId: A commit ID for a commit in the remote repository.
    ///   - folder: An optional folder in the remote repository.
    ///   - jobName: The name of the Glue job to be synchronized to or from the remote repository.
    ///   - provider:  The provider for the remote repository. Possible values: GITHUB, AWS_CODE_COMMIT, GITLAB, BITBUCKET.
    ///   - repositoryName: The name of the remote repository that contains the job artifacts.  For BitBucket providers, RepositoryName should include WorkspaceName. Use the format /.
    ///   - repositoryOwner: The owner of the remote repository that contains the job artifacts.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSourceControlFromJob(
        authStrategy: SourceControlAuthStrategy? = nil,
        authToken: String? = nil,
        branchName: String? = nil,
        commitId: String? = nil,
        folder: String? = nil,
        jobName: String? = nil,
        provider: SourceControlProvider? = nil,
        repositoryName: String? = nil,
        repositoryOwner: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSourceControlFromJobResponse {
        let input = UpdateSourceControlFromJobRequest(
            authStrategy: authStrategy, 
            authToken: authToken, 
            branchName: branchName, 
            commitId: commitId, 
            folder: folder, 
            jobName: jobName, 
            provider: provider, 
            repositoryName: repositoryName, 
            repositoryOwner: repositoryOwner
        )
        return try await self.updateSourceControlFromJob(input, logger: logger)
    }

    /// Updates a metadata table in the Data Catalog.
    @Sendable
    @inlinable
    public func updateTable(_ input: UpdateTableRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTableResponse {
        try await self.client.execute(
            operation: "UpdateTable", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a metadata table in the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
    ///   - force: A flag that can be set to true to ignore matching storage descriptor and subobject matching requirements.
    ///   - skipArchive: By default, UpdateTable always creates an archived version of the table before updating it. However, if skipArchive is set to true, UpdateTable does not create the archived version.
    ///   - tableInput: An updated TableInput object to define the metadata table in the catalog.
    ///   - transactionId: The transaction ID at which to update the table contents.
    ///   - versionId: The version ID at which to update the table contents.
    ///   - viewUpdateAction: The operation to be performed when updating the view.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateTable(
        catalogId: String? = nil,
        databaseName: String,
        force: Bool? = nil,
        skipArchive: Bool? = nil,
        tableInput: TableInput,
        transactionId: String? = nil,
        versionId: String? = nil,
        viewUpdateAction: ViewUpdateAction? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateTableResponse {
        let input = UpdateTableRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            force: force, 
            skipArchive: skipArchive, 
            tableInput: tableInput, 
            transactionId: transactionId, 
            versionId: versionId, 
            viewUpdateAction: viewUpdateAction
        )
        return try await self.updateTable(input, logger: logger)
    }

    /// Updates the configuration for an existing table optimizer.
    @Sendable
    @inlinable
    public func updateTableOptimizer(_ input: UpdateTableOptimizerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTableOptimizerResponse {
        try await self.client.execute(
            operation: "UpdateTableOptimizer", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration for an existing table optimizer.
    ///
    /// Parameters:
    ///   - catalogId: The Catalog ID of the table.
    ///   - databaseName: The name of the database in the catalog in which the table resides.
    ///   - tableName: The name of the table.
    ///   - tableOptimizerConfiguration: A TableOptimizerConfiguration object representing the configuration of a table optimizer.
    ///   - type: The type of table optimizer.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateTableOptimizer(
        catalogId: String,
        databaseName: String,
        tableName: String,
        tableOptimizerConfiguration: TableOptimizerConfiguration,
        type: TableOptimizerType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateTableOptimizerResponse {
        let input = UpdateTableOptimizerRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            tableName: tableName, 
            tableOptimizerConfiguration: tableOptimizerConfiguration, 
            type: type
        )
        return try await self.updateTableOptimizer(input, logger: logger)
    }

    /// Updates a trigger definition.
    @Sendable
    @inlinable
    public func updateTrigger(_ input: UpdateTriggerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTriggerResponse {
        try await self.client.execute(
            operation: "UpdateTrigger", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a trigger definition.
    ///
    /// Parameters:
    ///   - name: The name of the trigger to update.
    ///   - triggerUpdate: The new values with which to update the trigger.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateTrigger(
        name: String,
        triggerUpdate: TriggerUpdate,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateTriggerResponse {
        let input = UpdateTriggerRequest(
            name: name, 
            triggerUpdate: triggerUpdate
        )
        return try await self.updateTrigger(input, logger: logger)
    }

    /// Update an Glue usage profile.
    @Sendable
    @inlinable
    public func updateUsageProfile(_ input: UpdateUsageProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateUsageProfileResponse {
        try await self.client.execute(
            operation: "UpdateUsageProfile", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update an Glue usage profile.
    ///
    /// Parameters:
    ///   - configuration: A ProfileConfiguration object specifying the job and session values for the profile.
    ///   - description: A description of the usage profile.
    ///   - name: The name of the usage profile.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateUsageProfile(
        configuration: ProfileConfiguration,
        description: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateUsageProfileResponse {
        let input = UpdateUsageProfileRequest(
            configuration: configuration, 
            description: description, 
            name: name
        )
        return try await self.updateUsageProfile(input, logger: logger)
    }

    /// Updates an existing function definition in the Data Catalog.
    @Sendable
    @inlinable
    public func updateUserDefinedFunction(_ input: UpdateUserDefinedFunctionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateUserDefinedFunctionResponse {
        try await self.client.execute(
            operation: "UpdateUserDefinedFunction", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing function definition in the Data Catalog.
    ///
    /// Parameters:
    ///   - catalogId: The ID of the Data Catalog where the function to be updated is located. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database where the function to be updated is located.
    ///   - functionInput: A FunctionInput object that redefines the function in the Data Catalog.
    ///   - functionName: The name of the function.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateUserDefinedFunction(
        catalogId: String? = nil,
        databaseName: String,
        functionInput: UserDefinedFunctionInput,
        functionName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateUserDefinedFunctionResponse {
        let input = UpdateUserDefinedFunctionRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            functionInput: functionInput, 
            functionName: functionName
        )
        return try await self.updateUserDefinedFunction(input, logger: logger)
    }

    /// Updates an existing workflow.
    @Sendable
    @inlinable
    public func updateWorkflow(_ input: UpdateWorkflowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateWorkflowResponse {
        try await self.client.execute(
            operation: "UpdateWorkflow", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing workflow.
    ///
    /// Parameters:
    ///   - defaultRunProperties: A collection of properties to be used as part of each execution of the workflow.
    ///   - description: The description of the workflow.
    ///   - maxConcurrentRuns: You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
    ///   - name: Name of the workflow to be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateWorkflow(
        defaultRunProperties: [String: String]? = nil,
        description: String? = nil,
        maxConcurrentRuns: Int? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateWorkflowResponse {
        let input = UpdateWorkflowRequest(
            defaultRunProperties: defaultRunProperties, 
            description: description, 
            maxConcurrentRuns: maxConcurrentRuns, 
            name: name
        )
        return try await self.updateWorkflow(input, logger: logger)
    }
}

extension Glue {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Glue, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Glue {
    /// Return PaginatorSequence for operation ``describeEntity(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeEntityPaginator(
        _ input: DescribeEntityRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeEntityRequest, DescribeEntityResponse> {
        return .init(
            input: input,
            command: self.describeEntity,
            inputKey: \DescribeEntityRequest.nextToken,
            outputKey: \DescribeEntityResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeEntity(_:logger:)``.
    ///
    /// - Parameters:
    ///   - catalogId: The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon Web Services Account ID is the catalog ID.
    ///   - connectionName: The name of the connection that contains the connection type credentials.
    ///   - dataStoreApiVersion: The version of the API used for the data store.
    ///   - entityName: The name of the entity that you want to describe from the connection type.
    ///   - logger: Logger used for logging
    @inlinable
    public func describeEntityPaginator(
        catalogId: String? = nil,
        connectionName: String,
        dataStoreApiVersion: String? = nil,
        entityName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeEntityRequest, DescribeEntityResponse> {
        let input = DescribeEntityRequest(
            catalogId: catalogId, 
            connectionName: connectionName, 
            dataStoreApiVersion: dataStoreApiVersion, 
            entityName: entityName
        )
        return self.describeEntityPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getBlueprintRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getBlueprintRunsPaginator(
        _ input: GetBlueprintRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetBlueprintRunsRequest, GetBlueprintRunsResponse> {
        return .init(
            input: input,
            command: self.getBlueprintRuns,
            inputKey: \GetBlueprintRunsRequest.nextToken,
            outputKey: \GetBlueprintRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getBlueprintRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - blueprintName: The name of the blueprint.
    ///   - maxResults: The maximum size of a list to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func getBlueprintRunsPaginator(
        blueprintName: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetBlueprintRunsRequest, GetBlueprintRunsResponse> {
        let input = GetBlueprintRunsRequest(
            blueprintName: blueprintName, 
            maxResults: maxResults
        )
        return self.getBlueprintRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getClassifiers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getClassifiersPaginator(
        _ input: GetClassifiersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetClassifiersRequest, GetClassifiersResponse> {
        return .init(
            input: input,
            command: self.getClassifiers,
            inputKey: \GetClassifiersRequest.nextToken,
            outputKey: \GetClassifiersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getClassifiers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The size of the list to return (optional).
    ///   - logger: Logger used for logging
    @inlinable
    public func getClassifiersPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetClassifiersRequest, GetClassifiersResponse> {
        let input = GetClassifiersRequest(
            maxResults: maxResults
        )
        return self.getClassifiersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getColumnStatisticsTaskRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getColumnStatisticsTaskRunsPaginator(
        _ input: GetColumnStatisticsTaskRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetColumnStatisticsTaskRunsRequest, GetColumnStatisticsTaskRunsResponse> {
        return .init(
            input: input,
            command: self.getColumnStatisticsTaskRuns,
            inputKey: \GetColumnStatisticsTaskRunsRequest.nextToken,
            outputKey: \GetColumnStatisticsTaskRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getColumnStatisticsTaskRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - databaseName: The name of the database where the table resides.
    ///   - maxResults: The maximum size of the response.
    ///   - tableName: The name of the table.
    ///   - logger: Logger used for logging
    @inlinable
    public func getColumnStatisticsTaskRunsPaginator(
        databaseName: String,
        maxResults: Int? = nil,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetColumnStatisticsTaskRunsRequest, GetColumnStatisticsTaskRunsResponse> {
        let input = GetColumnStatisticsTaskRunsRequest(
            databaseName: databaseName, 
            maxResults: maxResults, 
            tableName: tableName
        )
        return self.getColumnStatisticsTaskRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getConnections(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getConnectionsPaginator(
        _ input: GetConnectionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetConnectionsRequest, GetConnectionsResponse> {
        return .init(
            input: input,
            command: self.getConnections,
            inputKey: \GetConnectionsRequest.nextToken,
            outputKey: \GetConnectionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getConnections(_:logger:)``.
    ///
    /// - Parameters:
    ///   - catalogId: The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - filter: A filter that controls which connections are returned.
    ///   - hidePassword: Allows you to retrieve the connection metadata without returning the password. For instance, the Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the KMS key to decrypt the password, but it does have permission to access the rest of the connection properties.
    ///   - maxResults: The maximum number of connections to return in one response.
    ///   - logger: Logger used for logging
    @inlinable
    public func getConnectionsPaginator(
        catalogId: String? = nil,
        filter: GetConnectionsFilter? = nil,
        hidePassword: Bool? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetConnectionsRequest, GetConnectionsResponse> {
        let input = GetConnectionsRequest(
            catalogId: catalogId, 
            filter: filter, 
            hidePassword: hidePassword, 
            maxResults: maxResults
        )
        return self.getConnectionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getCrawlerMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getCrawlerMetricsPaginator(
        _ input: GetCrawlerMetricsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetCrawlerMetricsRequest, GetCrawlerMetricsResponse> {
        return .init(
            input: input,
            command: self.getCrawlerMetrics,
            inputKey: \GetCrawlerMetricsRequest.nextToken,
            outputKey: \GetCrawlerMetricsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getCrawlerMetrics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - crawlerNameList: A list of the names of crawlers about which to retrieve metrics.
    ///   - maxResults: The maximum size of a list to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func getCrawlerMetricsPaginator(
        crawlerNameList: [String]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetCrawlerMetricsRequest, GetCrawlerMetricsResponse> {
        let input = GetCrawlerMetricsRequest(
            crawlerNameList: crawlerNameList, 
            maxResults: maxResults
        )
        return self.getCrawlerMetricsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getCrawlers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getCrawlersPaginator(
        _ input: GetCrawlersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetCrawlersRequest, GetCrawlersResponse> {
        return .init(
            input: input,
            command: self.getCrawlers,
            inputKey: \GetCrawlersRequest.nextToken,
            outputKey: \GetCrawlersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getCrawlers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The number of crawlers to return on each call.
    ///   - logger: Logger used for logging
    @inlinable
    public func getCrawlersPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetCrawlersRequest, GetCrawlersResponse> {
        let input = GetCrawlersRequest(
            maxResults: maxResults
        )
        return self.getCrawlersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getDatabases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getDatabasesPaginator(
        _ input: GetDatabasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetDatabasesRequest, GetDatabasesResponse> {
        return .init(
            input: input,
            command: self.getDatabases,
            inputKey: \GetDatabasesRequest.nextToken,
            outputKey: \GetDatabasesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getDatabases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - attributesToGet: Specifies the database fields returned by the GetDatabases call. This parameter doesn’t accept an empty list. The request must include the NAME.
    ///   - catalogId: The ID of the Data Catalog from which to retrieve Databases. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - maxResults: The maximum number of databases to return in one response.
    ///   - resourceShareType: Allows you to specify that you want to list the databases shared with your account. The allowable values are FEDERATED, FOREIGN or ALL.    If set to FEDERATED, will list the federated databases (referencing an external entity) shared with your account.   If set to FOREIGN, will list the databases shared with your account.    If set to ALL, will list the databases shared with your account, as well as the databases in yor local account.
    ///   - logger: Logger used for logging
    @inlinable
    public func getDatabasesPaginator(
        attributesToGet: [DatabaseAttributes]? = nil,
        catalogId: String? = nil,
        maxResults: Int? = nil,
        resourceShareType: ResourceShareType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetDatabasesRequest, GetDatabasesResponse> {
        let input = GetDatabasesRequest(
            attributesToGet: attributesToGet, 
            catalogId: catalogId, 
            maxResults: maxResults, 
            resourceShareType: resourceShareType
        )
        return self.getDatabasesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getDevEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getDevEndpointsPaginator(
        _ input: GetDevEndpointsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetDevEndpointsRequest, GetDevEndpointsResponse> {
        return .init(
            input: input,
            command: self.getDevEndpoints,
            inputKey: \GetDevEndpointsRequest.nextToken,
            outputKey: \GetDevEndpointsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getDevEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum size of information to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func getDevEndpointsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetDevEndpointsRequest, GetDevEndpointsResponse> {
        let input = GetDevEndpointsRequest(
            maxResults: maxResults
        )
        return self.getDevEndpointsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getJobRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getJobRunsPaginator(
        _ input: GetJobRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetJobRunsRequest, GetJobRunsResponse> {
        return .init(
            input: input,
            command: self.getJobRuns,
            inputKey: \GetJobRunsRequest.nextToken,
            outputKey: \GetJobRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getJobRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - jobName: The name of the job definition for which to retrieve all job runs.
    ///   - maxResults: The maximum size of the response.
    ///   - logger: Logger used for logging
    @inlinable
    public func getJobRunsPaginator(
        jobName: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetJobRunsRequest, GetJobRunsResponse> {
        let input = GetJobRunsRequest(
            jobName: jobName, 
            maxResults: maxResults
        )
        return self.getJobRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getJobsPaginator(
        _ input: GetJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetJobsRequest, GetJobsResponse> {
        return .init(
            input: input,
            command: self.getJobs,
            inputKey: \GetJobsRequest.nextToken,
            outputKey: \GetJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum size of the response.
    ///   - logger: Logger used for logging
    @inlinable
    public func getJobsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetJobsRequest, GetJobsResponse> {
        let input = GetJobsRequest(
            maxResults: maxResults
        )
        return self.getJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getMLTaskRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getMLTaskRunsPaginator(
        _ input: GetMLTaskRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetMLTaskRunsRequest, GetMLTaskRunsResponse> {
        return .init(
            input: input,
            command: self.getMLTaskRuns,
            inputKey: \GetMLTaskRunsRequest.nextToken,
            outputKey: \GetMLTaskRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getMLTaskRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: The filter criteria, in the TaskRunFilterCriteria structure, for the task run.
    ///   - maxResults: The maximum number of results to return.
    ///   - sort: The sorting criteria, in the TaskRunSortCriteria structure, for the task run.
    ///   - transformId: The unique identifier of the machine learning transform.
    ///   - logger: Logger used for logging
    @inlinable
    public func getMLTaskRunsPaginator(
        filter: TaskRunFilterCriteria? = nil,
        maxResults: Int? = nil,
        sort: TaskRunSortCriteria? = nil,
        transformId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetMLTaskRunsRequest, GetMLTaskRunsResponse> {
        let input = GetMLTaskRunsRequest(
            filter: filter, 
            maxResults: maxResults, 
            sort: sort, 
            transformId: transformId
        )
        return self.getMLTaskRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getMLTransforms(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getMLTransformsPaginator(
        _ input: GetMLTransformsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetMLTransformsRequest, GetMLTransformsResponse> {
        return .init(
            input: input,
            command: self.getMLTransforms,
            inputKey: \GetMLTransformsRequest.nextToken,
            outputKey: \GetMLTransformsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getMLTransforms(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: The filter transformation criteria.
    ///   - maxResults: The maximum number of results to return.
    ///   - sort: The sorting criteria.
    ///   - logger: Logger used for logging
    @inlinable
    public func getMLTransformsPaginator(
        filter: TransformFilterCriteria? = nil,
        maxResults: Int? = nil,
        sort: TransformSortCriteria? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetMLTransformsRequest, GetMLTransformsResponse> {
        let input = GetMLTransformsRequest(
            filter: filter, 
            maxResults: maxResults, 
            sort: sort
        )
        return self.getMLTransformsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getPartitionIndexes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getPartitionIndexesPaginator(
        _ input: GetPartitionIndexesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetPartitionIndexesRequest, GetPartitionIndexesResponse> {
        return .init(
            input: input,
            command: self.getPartitionIndexes,
            inputKey: \GetPartitionIndexesRequest.nextToken,
            outputKey: \GetPartitionIndexesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getPartitionIndexes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - catalogId: The catalog ID where the table resides.
    ///   - databaseName: Specifies the name of a database from which you want to retrieve partition indexes.
    ///   - tableName: Specifies the name of a table for which you want to retrieve the partition indexes.
    ///   - logger: Logger used for logging
    @inlinable
    public func getPartitionIndexesPaginator(
        catalogId: String? = nil,
        databaseName: String,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetPartitionIndexesRequest, GetPartitionIndexesResponse> {
        let input = GetPartitionIndexesRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            tableName: tableName
        )
        return self.getPartitionIndexesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getPartitions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getPartitionsPaginator(
        _ input: GetPartitionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetPartitionsRequest, GetPartitionsResponse> {
        return .init(
            input: input,
            command: self.getPartitions,
            inputKey: \GetPartitionsRequest.nextToken,
            outputKey: \GetPartitionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getPartitions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - excludeColumnSchema: When true, specifies not returning the partition column schema. Useful when you are interested only in other partition attributes such as partition values or location. This approach avoids the problem of a large response by not returning duplicate data.
    ///   - expression: An expression that filters the partitions to be returned. The expression uses SQL syntax similar to the SQL WHERE filter clause. The SQL statement parser JSQLParser parses the expression.   Operators: The following are the operators that you can use in the Expression API call:  =  Checks whether the values of the two operands are equal; if yes, then the condition becomes true. Example: Assume 'variable a' holds 10 and 'variable b' holds 20.  (a = b) is not true.    Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true. Example: (a  b) is true.  >  Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true. Example: (a > b) is not true.    Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true. Example: (a   >=  Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a >= b) is not true.    Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a   AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL  Logical operators.    Supported Partition Key Types: The following are the supported partition keys.    string     date     timestamp     int     bigint     long     tinyint     smallint     decimal    If an type is encountered that is not valid, an exception is thrown.  The following list shows the valid operators on each type. When you define a crawler, the partitionKey type is created as a STRING, to be compatible with the catalog partitions.   Sample API Call:
    ///   - maxResults: The maximum number of partitions to return in a single response.
    ///   - queryAsOfTime: The time as of when to read the partition contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
    ///   - segment: The segment of the table's partitions to scan in this request.
    ///   - tableName: The name of the partitions' table.
    ///   - transactionId: The transaction ID at which to read the partition contents.
    ///   - logger: Logger used for logging
    @inlinable
    public func getPartitionsPaginator(
        catalogId: String? = nil,
        databaseName: String,
        excludeColumnSchema: Bool? = nil,
        expression: String? = nil,
        maxResults: Int? = nil,
        queryAsOfTime: Date? = nil,
        segment: Segment? = nil,
        tableName: String,
        transactionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetPartitionsRequest, GetPartitionsResponse> {
        let input = GetPartitionsRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            excludeColumnSchema: excludeColumnSchema, 
            expression: expression, 
            maxResults: maxResults, 
            queryAsOfTime: queryAsOfTime, 
            segment: segment, 
            tableName: tableName, 
            transactionId: transactionId
        )
        return self.getPartitionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getResourcePolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getResourcePoliciesPaginator(
        _ input: GetResourcePoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetResourcePoliciesRequest, GetResourcePoliciesResponse> {
        return .init(
            input: input,
            command: self.getResourcePolicies,
            inputKey: \GetResourcePoliciesRequest.nextToken,
            outputKey: \GetResourcePoliciesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getResourcePolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func getResourcePoliciesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetResourcePoliciesRequest, GetResourcePoliciesResponse> {
        let input = GetResourcePoliciesRequest(
            maxResults: maxResults
        )
        return self.getResourcePoliciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getSecurityConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getSecurityConfigurationsPaginator(
        _ input: GetSecurityConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetSecurityConfigurationsRequest, GetSecurityConfigurationsResponse> {
        return .init(
            input: input,
            command: self.getSecurityConfigurations,
            inputKey: \GetSecurityConfigurationsRequest.nextToken,
            outputKey: \GetSecurityConfigurationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getSecurityConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func getSecurityConfigurationsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetSecurityConfigurationsRequest, GetSecurityConfigurationsResponse> {
        let input = GetSecurityConfigurationsRequest(
            maxResults: maxResults
        )
        return self.getSecurityConfigurationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getTableVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getTableVersionsPaginator(
        _ input: GetTableVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetTableVersionsRequest, GetTableVersionsResponse> {
        return .init(
            input: input,
            command: self.getTableVersions,
            inputKey: \GetTableVersionsRequest.nextToken,
            outputKey: \GetTableVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getTableVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - catalogId: The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
    ///   - maxResults: The maximum number of table versions to return in one response.
    ///   - tableName: The name of the table. For Hive compatibility, this name is entirely lowercase.
    ///   - logger: Logger used for logging
    @inlinable
    public func getTableVersionsPaginator(
        catalogId: String? = nil,
        databaseName: String,
        maxResults: Int? = nil,
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetTableVersionsRequest, GetTableVersionsResponse> {
        let input = GetTableVersionsRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            maxResults: maxResults, 
            tableName: tableName
        )
        return self.getTableVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getTables(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getTablesPaginator(
        _ input: GetTablesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetTablesRequest, GetTablesResponse> {
        return .init(
            input: input,
            command: self.getTables,
            inputKey: \GetTablesRequest.nextToken,
            outputKey: \GetTablesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getTables(_:logger:)``.
    ///
    /// - Parameters:
    ///   - attributesToGet:  Specifies the table fields returned by the GetTables call. This parameter doesn’t accept an empty list. The request must include NAME. The following are the valid combinations of values:    NAME - Names of all tables in the database.    NAME, TABLE_TYPE - Names of all tables and the table types.
    ///   - catalogId: The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The database in the catalog whose tables to list. For Hive compatibility, this name is entirely lowercase.
    ///   - expression: A regular expression pattern. If present, only those tables whose names match the pattern are returned.
    ///   - includeStatusDetails: Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
    ///   - maxResults: The maximum number of tables to return in a single response.
    ///   - queryAsOfTime: The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
    ///   - transactionId: The transaction ID at which to read the table contents.
    ///   - logger: Logger used for logging
    @inlinable
    public func getTablesPaginator(
        attributesToGet: [TableAttributes]? = nil,
        catalogId: String? = nil,
        databaseName: String,
        expression: String? = nil,
        includeStatusDetails: Bool? = nil,
        maxResults: Int? = nil,
        queryAsOfTime: Date? = nil,
        transactionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetTablesRequest, GetTablesResponse> {
        let input = GetTablesRequest(
            attributesToGet: attributesToGet, 
            catalogId: catalogId, 
            databaseName: databaseName, 
            expression: expression, 
            includeStatusDetails: includeStatusDetails, 
            maxResults: maxResults, 
            queryAsOfTime: queryAsOfTime, 
            transactionId: transactionId
        )
        return self.getTablesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getTriggers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getTriggersPaginator(
        _ input: GetTriggersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetTriggersRequest, GetTriggersResponse> {
        return .init(
            input: input,
            command: self.getTriggers,
            inputKey: \GetTriggersRequest.nextToken,
            outputKey: \GetTriggersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getTriggers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - dependentJobName: The name of the job to retrieve triggers for. The trigger that can start this job is returned, and if there is no such trigger, all triggers are returned.
    ///   - maxResults: The maximum size of the response.
    ///   - logger: Logger used for logging
    @inlinable
    public func getTriggersPaginator(
        dependentJobName: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetTriggersRequest, GetTriggersResponse> {
        let input = GetTriggersRequest(
            dependentJobName: dependentJobName, 
            maxResults: maxResults
        )
        return self.getTriggersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getUnfilteredPartitionsMetadata(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getUnfilteredPartitionsMetadataPaginator(
        _ input: GetUnfilteredPartitionsMetadataRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetUnfilteredPartitionsMetadataRequest, GetUnfilteredPartitionsMetadataResponse> {
        return .init(
            input: input,
            command: self.getUnfilteredPartitionsMetadata,
            inputKey: \GetUnfilteredPartitionsMetadataRequest.nextToken,
            outputKey: \GetUnfilteredPartitionsMetadataResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getUnfilteredPartitionsMetadata(_:logger:)``.
    ///
    /// - Parameters:
    ///   - auditContext: A structure containing Lake Formation audit context information.
    ///   - catalogId: The ID of the Data Catalog where the partitions in question reside. If none is provided,  the AWS account ID is used by default.
    ///   - databaseName: The name of the catalog database where the partitions reside.
    ///   - expression: An expression that filters the partitions to be returned. The expression uses SQL syntax similar to the SQL WHERE filter clause. The SQL statement parser JSQLParser parses the expression.   Operators: The following are the operators that you can use in the Expression API call:  =  Checks whether the values of the two operands are equal; if yes, then the condition becomes true. Example: Assume 'variable a' holds 10 and 'variable b' holds 20.  (a = b) is not true.    Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true. Example: (a  b) is true.  >  Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true. Example: (a > b) is not true.    Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true. Example: (a   >=  Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a >= b) is not true.    Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a   AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL  Logical operators.    Supported Partition Key Types: The following are the supported partition keys.    string     date     timestamp     int     bigint     long     tinyint     smallint     decimal    If an type is encountered that is not valid, an exception is thrown.
    ///   - maxResults: The maximum number of partitions to return in a single response.
    ///   - querySessionContext: A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
    ///   - region: Specified only if the base tables belong to a different Amazon Web Services Region.
    ///   - segment: The segment of the table's partitions to scan in this request.
    ///   - supportedPermissionTypes: A list of supported permission types.
    ///   - tableName: The name of the table that contains the partition.
    ///   - logger: Logger used for logging
    @inlinable
    public func getUnfilteredPartitionsMetadataPaginator(
        auditContext: AuditContext? = nil,
        catalogId: String,
        databaseName: String,
        expression: String? = nil,
        maxResults: Int? = nil,
        querySessionContext: QuerySessionContext? = nil,
        region: String? = nil,
        segment: Segment? = nil,
        supportedPermissionTypes: [PermissionType],
        tableName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetUnfilteredPartitionsMetadataRequest, GetUnfilteredPartitionsMetadataResponse> {
        let input = GetUnfilteredPartitionsMetadataRequest(
            auditContext: auditContext, 
            catalogId: catalogId, 
            databaseName: databaseName, 
            expression: expression, 
            maxResults: maxResults, 
            querySessionContext: querySessionContext, 
            region: region, 
            segment: segment, 
            supportedPermissionTypes: supportedPermissionTypes, 
            tableName: tableName
        )
        return self.getUnfilteredPartitionsMetadataPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getUserDefinedFunctions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getUserDefinedFunctionsPaginator(
        _ input: GetUserDefinedFunctionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetUserDefinedFunctionsRequest, GetUserDefinedFunctionsResponse> {
        return .init(
            input: input,
            command: self.getUserDefinedFunctions,
            inputKey: \GetUserDefinedFunctionsRequest.nextToken,
            outputKey: \GetUserDefinedFunctionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getUserDefinedFunctions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - catalogId: The ID of the Data Catalog where the functions to be retrieved are located. If none is provided, the Amazon Web Services account ID is used by default.
    ///   - databaseName: The name of the catalog database where the functions are located. If none is provided, functions from all the databases across the catalog will be returned.
    ///   - maxResults: The maximum number of functions to return in one response.
    ///   - pattern: An optional function-name pattern string that filters the function definitions returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func getUserDefinedFunctionsPaginator(
        catalogId: String? = nil,
        databaseName: String? = nil,
        maxResults: Int? = nil,
        pattern: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetUserDefinedFunctionsRequest, GetUserDefinedFunctionsResponse> {
        let input = GetUserDefinedFunctionsRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            maxResults: maxResults, 
            pattern: pattern
        )
        return self.getUserDefinedFunctionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getWorkflowRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getWorkflowRunsPaginator(
        _ input: GetWorkflowRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetWorkflowRunsRequest, GetWorkflowRunsResponse> {
        return .init(
            input: input,
            command: self.getWorkflowRuns,
            inputKey: \GetWorkflowRunsRequest.nextToken,
            outputKey: \GetWorkflowRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getWorkflowRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - includeGraph: Specifies whether to include the workflow graph in response or not.
    ///   - maxResults: The maximum number of workflow runs to be included in the response.
    ///   - name: Name of the workflow whose metadata of runs should be returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func getWorkflowRunsPaginator(
        includeGraph: Bool? = nil,
        maxResults: Int? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetWorkflowRunsRequest, GetWorkflowRunsResponse> {
        let input = GetWorkflowRunsRequest(
            includeGraph: includeGraph, 
            maxResults: maxResults, 
            name: name
        )
        return self.getWorkflowRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBlueprints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBlueprintsPaginator(
        _ input: ListBlueprintsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBlueprintsRequest, ListBlueprintsResponse> {
        return .init(
            input: input,
            command: self.listBlueprints,
            inputKey: \ListBlueprintsRequest.nextToken,
            outputKey: \ListBlueprintsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBlueprints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - tags: Filters the list by an Amazon Web Services resource tag.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBlueprintsPaginator(
        maxResults: Int? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBlueprintsRequest, ListBlueprintsResponse> {
        let input = ListBlueprintsRequest(
            maxResults: maxResults, 
            tags: tags
        )
        return self.listBlueprintsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listColumnStatisticsTaskRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listColumnStatisticsTaskRunsPaginator(
        _ input: ListColumnStatisticsTaskRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListColumnStatisticsTaskRunsRequest, ListColumnStatisticsTaskRunsResponse> {
        return .init(
            input: input,
            command: self.listColumnStatisticsTaskRuns,
            inputKey: \ListColumnStatisticsTaskRunsRequest.nextToken,
            outputKey: \ListColumnStatisticsTaskRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listColumnStatisticsTaskRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum size of the response.
    ///   - logger: Logger used for logging
    @inlinable
    public func listColumnStatisticsTaskRunsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListColumnStatisticsTaskRunsRequest, ListColumnStatisticsTaskRunsResponse> {
        let input = ListColumnStatisticsTaskRunsRequest(
            maxResults: maxResults
        )
        return self.listColumnStatisticsTaskRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listConnectionTypes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listConnectionTypesPaginator(
        _ input: ListConnectionTypesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListConnectionTypesRequest, ListConnectionTypesResponse> {
        return .init(
            input: input,
            command: self.listConnectionTypes,
            inputKey: \ListConnectionTypesRequest.nextToken,
            outputKey: \ListConnectionTypesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listConnectionTypes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listConnectionTypesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListConnectionTypesRequest, ListConnectionTypesResponse> {
        let input = ListConnectionTypesRequest(
            maxResults: maxResults
        )
        return self.listConnectionTypesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCrawlers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCrawlersPaginator(
        _ input: ListCrawlersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCrawlersRequest, ListCrawlersResponse> {
        return .init(
            input: input,
            command: self.listCrawlers,
            inputKey: \ListCrawlersRequest.nextToken,
            outputKey: \ListCrawlersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCrawlers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - tags: Specifies to return only these tagged resources.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCrawlersPaginator(
        maxResults: Int? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCrawlersRequest, ListCrawlersResponse> {
        let input = ListCrawlersRequest(
            maxResults: maxResults, 
            tags: tags
        )
        return self.listCrawlersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCustomEntityTypes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCustomEntityTypesPaginator(
        _ input: ListCustomEntityTypesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCustomEntityTypesRequest, ListCustomEntityTypesResponse> {
        return .init(
            input: input,
            command: self.listCustomEntityTypes,
            inputKey: \ListCustomEntityTypesRequest.nextToken,
            outputKey: \ListCustomEntityTypesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCustomEntityTypes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return.
    ///   - tags: A list of key-value pair tags.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCustomEntityTypesPaginator(
        maxResults: Int? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCustomEntityTypesRequest, ListCustomEntityTypesResponse> {
        let input = ListCustomEntityTypesRequest(
            maxResults: maxResults, 
            tags: tags
        )
        return self.listCustomEntityTypesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDataQualityResults(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataQualityResultsPaginator(
        _ input: ListDataQualityResultsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataQualityResultsRequest, ListDataQualityResultsResponse> {
        return .init(
            input: input,
            command: self.listDataQualityResults,
            inputKey: \ListDataQualityResultsRequest.nextToken,
            outputKey: \ListDataQualityResultsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDataQualityResults(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: The filter criteria.
    ///   - maxResults: The maximum number of results to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataQualityResultsPaginator(
        filter: DataQualityResultFilterCriteria? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDataQualityResultsRequest, ListDataQualityResultsResponse> {
        let input = ListDataQualityResultsRequest(
            filter: filter, 
            maxResults: maxResults
        )
        return self.listDataQualityResultsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDataQualityRuleRecommendationRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataQualityRuleRecommendationRunsPaginator(
        _ input: ListDataQualityRuleRecommendationRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataQualityRuleRecommendationRunsRequest, ListDataQualityRuleRecommendationRunsResponse> {
        return .init(
            input: input,
            command: self.listDataQualityRuleRecommendationRuns,
            inputKey: \ListDataQualityRuleRecommendationRunsRequest.nextToken,
            outputKey: \ListDataQualityRuleRecommendationRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDataQualityRuleRecommendationRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: The filter criteria.
    ///   - maxResults: The maximum number of results to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataQualityRuleRecommendationRunsPaginator(
        filter: DataQualityRuleRecommendationRunFilter? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDataQualityRuleRecommendationRunsRequest, ListDataQualityRuleRecommendationRunsResponse> {
        let input = ListDataQualityRuleRecommendationRunsRequest(
            filter: filter, 
            maxResults: maxResults
        )
        return self.listDataQualityRuleRecommendationRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDataQualityRulesetEvaluationRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataQualityRulesetEvaluationRunsPaginator(
        _ input: ListDataQualityRulesetEvaluationRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataQualityRulesetEvaluationRunsRequest, ListDataQualityRulesetEvaluationRunsResponse> {
        return .init(
            input: input,
            command: self.listDataQualityRulesetEvaluationRuns,
            inputKey: \ListDataQualityRulesetEvaluationRunsRequest.nextToken,
            outputKey: \ListDataQualityRulesetEvaluationRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDataQualityRulesetEvaluationRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: The filter criteria.
    ///   - maxResults: The maximum number of results to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataQualityRulesetEvaluationRunsPaginator(
        filter: DataQualityRulesetEvaluationRunFilter? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDataQualityRulesetEvaluationRunsRequest, ListDataQualityRulesetEvaluationRunsResponse> {
        let input = ListDataQualityRulesetEvaluationRunsRequest(
            filter: filter, 
            maxResults: maxResults
        )
        return self.listDataQualityRulesetEvaluationRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDataQualityRulesets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataQualityRulesetsPaginator(
        _ input: ListDataQualityRulesetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataQualityRulesetsRequest, ListDataQualityRulesetsResponse> {
        return .init(
            input: input,
            command: self.listDataQualityRulesets,
            inputKey: \ListDataQualityRulesetsRequest.nextToken,
            outputKey: \ListDataQualityRulesetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDataQualityRulesets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: The filter criteria.
    ///   - maxResults: The maximum number of results to return.
    ///   - tags: A list of key-value pair tags.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataQualityRulesetsPaginator(
        filter: DataQualityRulesetFilterCriteria? = nil,
        maxResults: Int? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDataQualityRulesetsRequest, ListDataQualityRulesetsResponse> {
        let input = ListDataQualityRulesetsRequest(
            filter: filter, 
            maxResults: maxResults, 
            tags: tags
        )
        return self.listDataQualityRulesetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDevEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevEndpointsPaginator(
        _ input: ListDevEndpointsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDevEndpointsRequest, ListDevEndpointsResponse> {
        return .init(
            input: input,
            command: self.listDevEndpoints,
            inputKey: \ListDevEndpointsRequest.nextToken,
            outputKey: \ListDevEndpointsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDevEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - tags: Specifies to return only these tagged resources.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDevEndpointsPaginator(
        maxResults: Int? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDevEndpointsRequest, ListDevEndpointsResponse> {
        let input = ListDevEndpointsRequest(
            maxResults: maxResults, 
            tags: tags
        )
        return self.listDevEndpointsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listEntities(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEntitiesPaginator(
        _ input: ListEntitiesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEntitiesRequest, ListEntitiesResponse> {
        return .init(
            input: input,
            command: self.listEntities,
            inputKey: \ListEntitiesRequest.nextToken,
            outputKey: \ListEntitiesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEntities(_:logger:)``.
    ///
    /// - Parameters:
    ///   - catalogId: The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon Web Services Account ID is the catalog ID.
    ///   - connectionName: A name for the connection that has required credentials to query any connection type.
    ///   - dataStoreApiVersion: The API version of the SaaS connector.
    ///   - parentEntityName: Name of the parent entity for which you want to list the children. This parameter takes a fully-qualified path of the entity in order to list the child entities.
    ///   - logger: Logger used for logging
    @inlinable
    public func listEntitiesPaginator(
        catalogId: String? = nil,
        connectionName: String? = nil,
        dataStoreApiVersion: String? = nil,
        parentEntityName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEntitiesRequest, ListEntitiesResponse> {
        let input = ListEntitiesRequest(
            catalogId: catalogId, 
            connectionName: connectionName, 
            dataStoreApiVersion: dataStoreApiVersion, 
            parentEntityName: parentEntityName
        )
        return self.listEntitiesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobsPaginator(
        _ input: ListJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobsRequest, ListJobsResponse> {
        return .init(
            input: input,
            command: self.listJobs,
            inputKey: \ListJobsRequest.nextToken,
            outputKey: \ListJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - tags: Specifies to return only these tagged resources.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobsPaginator(
        maxResults: Int? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobsRequest, ListJobsResponse> {
        let input = ListJobsRequest(
            maxResults: maxResults, 
            tags: tags
        )
        return self.listJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMLTransforms(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMLTransformsPaginator(
        _ input: ListMLTransformsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMLTransformsRequest, ListMLTransformsResponse> {
        return .init(
            input: input,
            command: self.listMLTransforms,
            inputKey: \ListMLTransformsRequest.nextToken,
            outputKey: \ListMLTransformsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMLTransforms(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filter: A TransformFilterCriteria used to filter the machine learning transforms.
    ///   - maxResults: The maximum size of a list to return.
    ///   - sort: A TransformSortCriteria used to sort the machine learning transforms.
    ///   - tags: Specifies to return only these tagged resources.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMLTransformsPaginator(
        filter: TransformFilterCriteria? = nil,
        maxResults: Int? = nil,
        sort: TransformSortCriteria? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMLTransformsRequest, ListMLTransformsResponse> {
        let input = ListMLTransformsRequest(
            filter: filter, 
            maxResults: maxResults, 
            sort: sort, 
            tags: tags
        )
        return self.listMLTransformsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRegistries(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRegistriesPaginator(
        _ input: ListRegistriesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRegistriesInput, ListRegistriesResponse> {
        return .init(
            input: input,
            command: self.listRegistries,
            inputKey: \ListRegistriesInput.nextToken,
            outputKey: \ListRegistriesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRegistries(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRegistriesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRegistriesInput, ListRegistriesResponse> {
        let input = ListRegistriesInput(
            maxResults: maxResults
        )
        return self.listRegistriesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSchemaVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSchemaVersionsPaginator(
        _ input: ListSchemaVersionsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsResponse> {
        return .init(
            input: input,
            command: self.listSchemaVersions,
            inputKey: \ListSchemaVersionsInput.nextToken,
            outputKey: \ListSchemaVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSchemaVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    ///   - schemaId: This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSchemaVersionsPaginator(
        maxResults: Int? = nil,
        schemaId: SchemaId,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsResponse> {
        let input = ListSchemaVersionsInput(
            maxResults: maxResults, 
            schemaId: schemaId
        )
        return self.listSchemaVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSchemas(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSchemasPaginator(
        _ input: ListSchemasInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSchemasInput, ListSchemasResponse> {
        return .init(
            input: input,
            command: self.listSchemas,
            inputKey: \ListSchemasInput.nextToken,
            outputKey: \ListSchemasResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSchemas(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
    ///   - registryId: A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
    ///   - logger: Logger used for logging
    @inlinable
    public func listSchemasPaginator(
        maxResults: Int? = nil,
        registryId: RegistryId? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSchemasInput, ListSchemasResponse> {
        let input = ListSchemasInput(
            maxResults: maxResults, 
            registryId: registryId
        )
        return self.listSchemasPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSessions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionsPaginator(
        _ input: ListSessionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSessionsRequest, ListSessionsResponse> {
        return .init(
            input: input,
            command: self.listSessions,
            inputKey: \ListSessionsRequest.nextToken,
            outputKey: \ListSessionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSessions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results.
    ///   - requestOrigin: The origin of the request.
    ///   - tags: Tags belonging to the session.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionsPaginator(
        maxResults: Int? = nil,
        requestOrigin: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSessionsRequest, ListSessionsResponse> {
        let input = ListSessionsRequest(
            maxResults: maxResults, 
            requestOrigin: requestOrigin, 
            tags: tags
        )
        return self.listSessionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTableOptimizerRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTableOptimizerRunsPaginator(
        _ input: ListTableOptimizerRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTableOptimizerRunsRequest, ListTableOptimizerRunsResponse> {
        return .init(
            input: input,
            command: self.listTableOptimizerRuns,
            inputKey: \ListTableOptimizerRunsRequest.nextToken,
            outputKey: \ListTableOptimizerRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTableOptimizerRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - catalogId: The Catalog ID of the table.
    ///   - databaseName: The name of the database in the catalog in which the table resides.
    ///   - maxResults: The maximum number of optimizer runs to return on each call.
    ///   - tableName: The name of the table.
    ///   - type: The type of table optimizer.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTableOptimizerRunsPaginator(
        catalogId: String,
        databaseName: String,
        maxResults: Int? = nil,
        tableName: String,
        type: TableOptimizerType,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTableOptimizerRunsRequest, ListTableOptimizerRunsResponse> {
        let input = ListTableOptimizerRunsRequest(
            catalogId: catalogId, 
            databaseName: databaseName, 
            maxResults: maxResults, 
            tableName: tableName, 
            type: type
        )
        return self.listTableOptimizerRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTriggers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTriggersPaginator(
        _ input: ListTriggersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTriggersRequest, ListTriggersResponse> {
        return .init(
            input: input,
            command: self.listTriggers,
            inputKey: \ListTriggersRequest.nextToken,
            outputKey: \ListTriggersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTriggers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - dependentJobName:  The name of the job for which to retrieve triggers. The trigger that can start this job is returned. If there is no such trigger, all triggers are returned.
    ///   - maxResults: The maximum size of a list to return.
    ///   - tags: Specifies to return only these tagged resources.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTriggersPaginator(
        dependentJobName: String? = nil,
        maxResults: Int? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTriggersRequest, ListTriggersResponse> {
        let input = ListTriggersRequest(
            dependentJobName: dependentJobName, 
            maxResults: maxResults, 
            tags: tags
        )
        return self.listTriggersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listUsageProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listUsageProfilesPaginator(
        _ input: ListUsageProfilesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListUsageProfilesRequest, ListUsageProfilesResponse> {
        return .init(
            input: input,
            command: self.listUsageProfiles,
            inputKey: \ListUsageProfilesRequest.nextToken,
            outputKey: \ListUsageProfilesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listUsageProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of usage profiles to return in a single response.
    ///   - logger: Logger used for logging
    @inlinable
    public func listUsageProfilesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListUsageProfilesRequest, ListUsageProfilesResponse> {
        let input = ListUsageProfilesRequest(
            maxResults: maxResults
        )
        return self.listUsageProfilesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkflows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowsPaginator(
        _ input: ListWorkflowsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkflowsRequest, ListWorkflowsResponse> {
        return .init(
            input: input,
            command: self.listWorkflows,
            inputKey: \ListWorkflowsRequest.nextToken,
            outputKey: \ListWorkflowsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkflows(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum size of a list to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkflowsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkflowsRequest, ListWorkflowsResponse> {
        let input = ListWorkflowsRequest(
            maxResults: maxResults
        )
        return self.listWorkflowsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``searchTables(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func searchTablesPaginator(
        _ input: SearchTablesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<SearchTablesRequest, SearchTablesResponse> {
        return .init(
            input: input,
            command: self.searchTables,
            inputKey: \SearchTablesRequest.nextToken,
            outputKey: \SearchTablesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``searchTables(_:logger:)``.
    ///
    /// - Parameters:
    ///   - catalogId: A unique identifier, consisting of  account_id .
    ///   - filters: A list of key-value pairs, and a comparator used to filter the search results. Returns all entities matching the predicate. The Comparator member of the PropertyPredicate struct is used only for time fields, and can be omitted for other field types. Also, when comparing string values, such as when Key=Name, a fuzzy match algorithm is used. The Key field (for example, the value of the Name field) is split on certain punctuation characters, for example, -, :, #, etc. into tokens. Then each token is exact-match compared with the Value member of PropertyPredicate. For example, if Key=Name and Value=link, tables named customer-link and xx-link-yy are returned, but xxlinkyy is not returned.
    ///   - includeStatusDetails: Specifies whether to include status details related to a request to create or update an Glue Data Catalog view.
    ///   - maxResults: The maximum number of tables to return in a single response.
    ///   - resourceShareType: Allows you to specify that you want to search the tables shared with your account. The allowable values are FOREIGN or ALL.    If set to FOREIGN, will search the tables shared with your account.    If set to ALL, will search the tables shared with your account, as well as the tables in yor local account.
    ///   - searchText: A string used for a text search. Specifying a value in quotes filters based on an exact match to the value.
    ///   - sortCriteria: A list of criteria for sorting the results by a field name, in an ascending or descending order.
    ///   - logger: Logger used for logging
    @inlinable
    public func searchTablesPaginator(
        catalogId: String? = nil,
        filters: [PropertyPredicate]? = nil,
        includeStatusDetails: Bool? = nil,
        maxResults: Int? = nil,
        resourceShareType: ResourceShareType? = nil,
        searchText: String? = nil,
        sortCriteria: [SortCriterion]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<SearchTablesRequest, SearchTablesResponse> {
        let input = SearchTablesRequest(
            catalogId: catalogId, 
            filters: filters, 
            includeStatusDetails: includeStatusDetails, 
            maxResults: maxResults, 
            resourceShareType: resourceShareType, 
            searchText: searchText, 
            sortCriteria: sortCriteria
        )
        return self.searchTablesPaginator(input, logger: logger)
    }
}

extension Glue.DescribeEntityRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.DescribeEntityRequest {
        return .init(
            catalogId: self.catalogId,
            connectionName: self.connectionName,
            dataStoreApiVersion: self.dataStoreApiVersion,
            entityName: self.entityName,
            nextToken: token
        )
    }
}

extension Glue.GetBlueprintRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetBlueprintRunsRequest {
        return .init(
            blueprintName: self.blueprintName,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetClassifiersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetClassifiersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetColumnStatisticsTaskRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetColumnStatisticsTaskRunsRequest {
        return .init(
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName
        )
    }
}

extension Glue.GetConnectionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetConnectionsRequest {
        return .init(
            catalogId: self.catalogId,
            filter: self.filter,
            hidePassword: self.hidePassword,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetCrawlerMetricsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetCrawlerMetricsRequest {
        return .init(
            crawlerNameList: self.crawlerNameList,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetCrawlersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetCrawlersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetDatabasesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetDatabasesRequest {
        return .init(
            attributesToGet: self.attributesToGet,
            catalogId: self.catalogId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareType: self.resourceShareType
        )
    }
}

extension Glue.GetDevEndpointsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetDevEndpointsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetJobRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetJobRunsRequest {
        return .init(
            jobName: self.jobName,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetJobsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetMLTaskRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetMLTaskRunsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            transformId: self.transformId
        )
    }
}

extension Glue.GetMLTransformsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetMLTransformsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort
        )
    }
}

extension Glue.GetPartitionIndexesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetPartitionIndexesRequest {
        return .init(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            nextToken: token,
            tableName: self.tableName
        )
    }
}

extension Glue.GetPartitionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetPartitionsRequest {
        return .init(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            excludeColumnSchema: self.excludeColumnSchema,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            queryAsOfTime: self.queryAsOfTime,
            segment: self.segment,
            tableName: self.tableName,
            transactionId: self.transactionId
        )
    }
}

extension Glue.GetResourcePoliciesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetResourcePoliciesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetSecurityConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetSecurityConfigurationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetTableVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetTableVersionsRequest {
        return .init(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName
        )
    }
}

extension Glue.GetTablesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetTablesRequest {
        return .init(
            attributesToGet: self.attributesToGet,
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            expression: self.expression,
            includeStatusDetails: self.includeStatusDetails,
            maxResults: self.maxResults,
            nextToken: token,
            queryAsOfTime: self.queryAsOfTime,
            transactionId: self.transactionId
        )
    }
}

extension Glue.GetTriggersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetTriggersRequest {
        return .init(
            dependentJobName: self.dependentJobName,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.GetUnfilteredPartitionsMetadataRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetUnfilteredPartitionsMetadataRequest {
        return .init(
            auditContext: self.auditContext,
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            querySessionContext: self.querySessionContext,
            region: self.region,
            segment: self.segment,
            supportedPermissionTypes: self.supportedPermissionTypes,
            tableName: self.tableName
        )
    }
}

extension Glue.GetUserDefinedFunctionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetUserDefinedFunctionsRequest {
        return .init(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            pattern: self.pattern
        )
    }
}

extension Glue.GetWorkflowRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.GetWorkflowRunsRequest {
        return .init(
            includeGraph: self.includeGraph,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension Glue.ListBlueprintsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListBlueprintsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )
    }
}

extension Glue.ListColumnStatisticsTaskRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListColumnStatisticsTaskRunsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.ListConnectionTypesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListConnectionTypesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.ListCrawlersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListCrawlersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )
    }
}

extension Glue.ListCustomEntityTypesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListCustomEntityTypesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )
    }
}

extension Glue.ListDataQualityResultsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListDataQualityResultsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.ListDataQualityRuleRecommendationRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListDataQualityRuleRecommendationRunsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.ListDataQualityRulesetEvaluationRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListDataQualityRulesetEvaluationRunsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.ListDataQualityRulesetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListDataQualityRulesetsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )
    }
}

extension Glue.ListDevEndpointsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListDevEndpointsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )
    }
}

extension Glue.ListEntitiesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListEntitiesRequest {
        return .init(
            catalogId: self.catalogId,
            connectionName: self.connectionName,
            dataStoreApiVersion: self.dataStoreApiVersion,
            nextToken: token,
            parentEntityName: self.parentEntityName
        )
    }
}

extension Glue.ListJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListJobsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )
    }
}

extension Glue.ListMLTransformsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListMLTransformsRequest {
        return .init(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            tags: self.tags
        )
    }
}

extension Glue.ListRegistriesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListRegistriesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.ListSchemaVersionsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListSchemaVersionsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            schemaId: self.schemaId
        )
    }
}

extension Glue.ListSchemasInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListSchemasInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            registryId: self.registryId
        )
    }
}

extension Glue.ListSessionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListSessionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            requestOrigin: self.requestOrigin,
            tags: self.tags
        )
    }
}

extension Glue.ListTableOptimizerRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListTableOptimizerRunsRequest {
        return .init(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName,
            type: self.type
        )
    }
}

extension Glue.ListTriggersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListTriggersRequest {
        return .init(
            dependentJobName: self.dependentJobName,
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )
    }
}

extension Glue.ListUsageProfilesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListUsageProfilesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.ListWorkflowsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.ListWorkflowsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Glue.SearchTablesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Glue.SearchTablesRequest {
        return .init(
            catalogId: self.catalogId,
            filters: self.filters,
            includeStatusDetails: self.includeStatusDetails,
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareType: self.resourceShareType,
            searchText: self.searchText,
            sortCriteria: self.sortCriteria
        )
    }
}
