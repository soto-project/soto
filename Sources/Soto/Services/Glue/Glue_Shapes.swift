//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Glue {
    // MARK: Enums

    public enum BackfillErrorCode: String, CustomStringConvertible, Codable {
        case encryptedPartitionError = "ENCRYPTED_PARTITION_ERROR"
        case internalError = "INTERNAL_ERROR"
        case invalidPartitionTypeDataError = "INVALID_PARTITION_TYPE_DATA_ERROR"
        case missingPartitionValueError = "MISSING_PARTITION_VALUE_ERROR"
        case unsupportedPartitionCharacterError = "UNSUPPORTED_PARTITION_CHARACTER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum CatalogEncryptionMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case sseKms = "SSE-KMS"
        public var description: String { return self.rawValue }
    }

    public enum CloudWatchEncryptionMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case sseKms = "SSE-KMS"
        public var description: String { return self.rawValue }
    }

    public enum ColumnStatisticsType: String, CustomStringConvertible, Codable {
        case binary = "BINARY"
        case boolean = "BOOLEAN"
        case date = "DATE"
        case decimal = "DECIMAL"
        case double = "DOUBLE"
        case long = "LONG"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum Comparator: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        case greaterThan = "GREATER_THAN"
        case greaterThanEquals = "GREATER_THAN_EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanEquals = "LESS_THAN_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum Compatibility: String, CustomStringConvertible, Codable {
        case backward = "BACKWARD"
        case backwardAll = "BACKWARD_ALL"
        case disabled = "DISABLED"
        case forward = "FORWARD"
        case forwardAll = "FORWARD_ALL"
        case full = "FULL"
        case fullAll = "FULL_ALL"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionPropertyKey: String, CustomStringConvertible, Codable {
        case configFiles = "CONFIG_FILES"
        case connectionUrl = "CONNECTION_URL"
        case connectorClassName = "CONNECTOR_CLASS_NAME"
        case connectorType = "CONNECTOR_TYPE"
        case connectorUrl = "CONNECTOR_URL"
        case customJdbcCert = "CUSTOM_JDBC_CERT"
        case customJdbcCertString = "CUSTOM_JDBC_CERT_STRING"
        case encryptedKafkaClientKeyPassword = "ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD"
        case encryptedKafkaClientKeystorePassword = "ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD"
        case encryptedPassword = "ENCRYPTED_PASSWORD"
        case host = "HOST"
        case instanceId = "INSTANCE_ID"
        case jdbcConnectionUrl = "JDBC_CONNECTION_URL"
        case jdbcDriverClassName = "JDBC_DRIVER_CLASS_NAME"
        case jdbcDriverJarUri = "JDBC_DRIVER_JAR_URI"
        case jdbcEnforceSsl = "JDBC_ENFORCE_SSL"
        case jdbcEngine = "JDBC_ENGINE"
        case jdbcEngineVersion = "JDBC_ENGINE_VERSION"
        case kafkaBootstrapServers = "KAFKA_BOOTSTRAP_SERVERS"
        case kafkaClientKeyPassword = "KAFKA_CLIENT_KEY_PASSWORD"
        case kafkaClientKeystore = "KAFKA_CLIENT_KEYSTORE"
        case kafkaClientKeystorePassword = "KAFKA_CLIENT_KEYSTORE_PASSWORD"
        case kafkaCustomCert = "KAFKA_CUSTOM_CERT"
        case kafkaSkipCustomCertValidation = "KAFKA_SKIP_CUSTOM_CERT_VALIDATION"
        case kafkaSslEnabled = "KAFKA_SSL_ENABLED"
        case password = "PASSWORD"
        case port = "PORT"
        case secretId = "SECRET_ID"
        case skipCustomJdbcCertValidation = "SKIP_CUSTOM_JDBC_CERT_VALIDATION"
        case username = "USERNAME"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable {
        case custom = "CUSTOM"
        case jdbc = "JDBC"
        case kafka = "KAFKA"
        case marketplace = "MARKETPLACE"
        case mongodb = "MONGODB"
        case network = "NETWORK"
        case sftp = "SFTP"
        public var description: String { return self.rawValue }
    }

    public enum CrawlState: String, CustomStringConvertible, Codable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case failed = "FAILED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum CrawlerLineageSettings: String, CustomStringConvertible, Codable {
        case disable = "DISABLE"
        case enable = "ENABLE"
        public var description: String { return self.rawValue }
    }

    public enum CrawlerState: String, CustomStringConvertible, Codable {
        case ready = "READY"
        case running = "RUNNING"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum CsvHeaderOption: String, CustomStringConvertible, Codable {
        case absent = "ABSENT"
        case present = "PRESENT"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum DataFormat: String, CustomStringConvertible, Codable {
        case avro = "AVRO"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum DeleteBehavior: String, CustomStringConvertible, Codable {
        case deleteFromDatabase = "DELETE_FROM_DATABASE"
        case deprecateInDatabase = "DEPRECATE_IN_DATABASE"
        case log = "LOG"
        public var description: String { return self.rawValue }
    }

    public enum EnableHybridValues: String, CustomStringConvertible, Codable {
        case `false` = "FALSE"
        case `true` = "TRUE"
        public var description: String { return self.rawValue }
    }

    public enum ExistCondition: String, CustomStringConvertible, Codable {
        case mustExist = "MUST_EXIST"
        case none = "NONE"
        case notExist = "NOT_EXIST"
        public var description: String { return self.rawValue }
    }

    public enum JobBookmarksEncryptionMode: String, CustomStringConvertible, Codable {
        case cseKms = "CSE-KMS"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum JobRunState: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case succeeded = "SUCCEEDED"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public enum Language: String, CustomStringConvertible, Codable {
        case python = "PYTHON"
        case scala = "SCALA"
        public var description: String { return self.rawValue }
    }

    public enum LastCrawlStatus: String, CustomStringConvertible, Codable {
        case cancelled = "CANCELLED"
        case failed = "FAILED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum Logical: String, CustomStringConvertible, Codable {
        case and = "AND"
        case any = "ANY"
        public var description: String { return self.rawValue }
    }

    public enum LogicalOperator: String, CustomStringConvertible, Codable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum MLUserDataEncryptionModeString: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case sseKms = "SSE-KMS"
        public var description: String { return self.rawValue }
    }

    public enum NodeType: String, CustomStringConvertible, Codable {
        case crawler = "CRAWLER"
        case job = "JOB"
        case trigger = "TRIGGER"
        public var description: String { return self.rawValue }
    }

    public enum PartitionIndexStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum Permission: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case alter = "ALTER"
        case createDatabase = "CREATE_DATABASE"
        case createTable = "CREATE_TABLE"
        case dataLocationAccess = "DATA_LOCATION_ACCESS"
        case delete = "DELETE"
        case drop = "DROP"
        case insert = "INSERT"
        case select = "SELECT"
        public var description: String { return self.rawValue }
    }

    public enum PrincipalType: String, CustomStringConvertible, Codable {
        case group = "GROUP"
        case role = "ROLE"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum RecrawlBehavior: String, CustomStringConvertible, Codable {
        case crawlEverything = "CRAWL_EVERYTHING"
        case crawlNewFoldersOnly = "CRAWL_NEW_FOLDERS_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum RegistryStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum ResourceShareType: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case foreign = "FOREIGN"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable {
        case archive = "ARCHIVE"
        case file = "FILE"
        case jar = "JAR"
        public var description: String { return self.rawValue }
    }

    public enum S3EncryptionMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case sseKms = "SSE-KMS"
        case sseS3 = "SSE-S3"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleState: String, CustomStringConvertible, Codable {
        case notScheduled = "NOT_SCHEDULED"
        case scheduled = "SCHEDULED"
        case transitioning = "TRANSITIONING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaDiffType: String, CustomStringConvertible, Codable {
        case syntaxDiff = "SYNTAX_DIFF"
        public var description: String { return self.rawValue }
    }

    public enum SchemaStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum SchemaVersionStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case failure = "FAILURE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum Sort: String, CustomStringConvertible, Codable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum SortDirectionType: String, CustomStringConvertible, Codable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum TaskRunSortColumnType: String, CustomStringConvertible, Codable {
        case started = "STARTED"
        case status = "STATUS"
        case taskRunType = "TASK_RUN_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum TaskStatusType: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case running = "RUNNING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case succeeded = "SUCCEEDED"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public enum TaskType: String, CustomStringConvertible, Codable {
        case evaluation = "EVALUATION"
        case exportLabels = "EXPORT_LABELS"
        case findMatches = "FIND_MATCHES"
        case importLabels = "IMPORT_LABELS"
        case labelingSetGeneration = "LABELING_SET_GENERATION"
        public var description: String { return self.rawValue }
    }

    public enum TransformSortColumnType: String, CustomStringConvertible, Codable {
        case created = "CREATED"
        case lastModified = "LAST_MODIFIED"
        case name = "NAME"
        case status = "STATUS"
        case transformType = "TRANSFORM_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum TransformStatusType: String, CustomStringConvertible, Codable {
        case deleting = "DELETING"
        case notReady = "NOT_READY"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum TransformType: String, CustomStringConvertible, Codable {
        case findMatches = "FIND_MATCHES"
        public var description: String { return self.rawValue }
    }

    public enum TriggerState: String, CustomStringConvertible, Codable {
        case activated = "ACTIVATED"
        case activating = "ACTIVATING"
        case created = "CREATED"
        case creating = "CREATING"
        case deactivated = "DEACTIVATED"
        case deactivating = "DEACTIVATING"
        case deleting = "DELETING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum TriggerType: String, CustomStringConvertible, Codable {
        case conditional = "CONDITIONAL"
        case event = "EVENT"
        case onDemand = "ON_DEMAND"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum UpdateBehavior: String, CustomStringConvertible, Codable {
        case log = "LOG"
        case updateInDatabase = "UPDATE_IN_DATABASE"
        public var description: String { return self.rawValue }
    }

    public enum WorkerType: String, CustomStringConvertible, Codable {
        case g1X = "G.1X"
        case g2X = "G.2X"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowRunStatus: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case error = "ERROR"
        case running = "RUNNING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// The job arguments used when this trigger fires. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the key-value pairs that Glue consumes to set up your job, see the Special Parameters Used by Glue topic in the developer guide.
        public let arguments: [String: String]?
        /// The name of the crawler to be used with this action.
        public let crawlerName: String?
        /// The name of a job to be run.
        public let jobName: String?
        /// Specifies configuration properties of a job run notification.
        public let notificationProperty: NotificationProperty?
        /// The name of the SecurityConfiguration structure to be used with this action.
        public let securityConfiguration: String?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.
        public let timeout: Int?

        public init(arguments: [String: String]? = nil, crawlerName: String? = nil, jobName: String? = nil, notificationProperty: NotificationProperty? = nil, securityConfiguration: String? = nil, timeout: Int? = nil) {
            self.arguments = arguments
            self.crawlerName = crawlerName
            self.jobName = jobName
            self.notificationProperty = notificationProperty
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.notificationProperty?.validate(name: "\(name).notificationProperty")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case crawlerName = "CrawlerName"
            case jobName = "JobName"
            case notificationProperty = "NotificationProperty"
            case securityConfiguration = "SecurityConfiguration"
            case timeout = "Timeout"
        }
    }

    public struct BackfillError: AWSDecodableShape {
        /// The error code for an error that occurred when registering partition indexes for an existing table.
        public let code: BackfillErrorCode?
        /// A list of a limited number of partitions in the response.
        public let partitions: [PartitionValueList]?

        public init(code: BackfillErrorCode? = nil, partitions: [PartitionValueList]? = nil) {
            self.code = code
            self.partitions = partitions
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case partitions = "Partitions"
        }
    }

    public struct BatchCreatePartitionRequest: AWSEncodableShape {
        /// The ID of the catalog in which the partition is to be created. Currently, this should be the Amazon Web Services account ID.
        public let catalogId: String?
        /// The name of the metadata database in which the partition is to be created.
        public let databaseName: String
        /// A list of PartitionInput structures that define the partitions to be created.
        public let partitionInputList: [PartitionInput]
        /// The name of the metadata table in which the partition is to be created.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionInputList: [PartitionInput], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionInputList = partitionInputList
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionInputList.forEach {
                try $0.validate(name: "\(name).partitionInputList[]")
            }
            try self.validate(self.partitionInputList, name: "partitionInputList", parent: name, max: 100)
            try self.validate(self.partitionInputList, name: "partitionInputList", parent: name, min: 0)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionInputList = "PartitionInputList"
            case tableName = "TableName"
        }
    }

    public struct BatchCreatePartitionResponse: AWSDecodableShape {
        /// The errors encountered when trying to create the requested partitions.
        public let errors: [PartitionError]?

        public init(errors: [PartitionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteConnectionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A list of names of the connections to delete.
        public let connectionNameList: [String]

        public init(catalogId: String? = nil, connectionNameList: [String]) {
            self.catalogId = catalogId
            self.connectionNameList = connectionNameList
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.connectionNameList.forEach {
                try validate($0, name: "connectionNameList[]", parent: name, max: 255)
                try validate($0, name: "connectionNameList[]", parent: name, min: 1)
                try validate($0, name: "connectionNameList[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.connectionNameList, name: "connectionNameList", parent: name, max: 25)
            try self.validate(self.connectionNameList, name: "connectionNameList", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionNameList = "ConnectionNameList"
        }
    }

    public struct BatchDeleteConnectionResponse: AWSDecodableShape {
        /// A map of the names of connections that were not successfully deleted to error details.
        public let errors: [String: ErrorDetail]?
        /// A list of names of the connection definitions that were successfully deleted.
        public let succeeded: [String]?

        public init(errors: [String: ErrorDetail]? = nil, succeeded: [String]? = nil) {
            self.errors = errors
            self.succeeded = succeeded
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case succeeded = "Succeeded"
        }
    }

    public struct BatchDeletePartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partition to be deleted resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String
        /// A list of PartitionInput structures that define the partitions to be deleted.
        public let partitionsToDelete: [PartitionValueList]
        /// The name of the table that contains the partitions to be deleted.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionsToDelete: [PartitionValueList], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionsToDelete = partitionsToDelete
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionsToDelete.forEach {
                try $0.validate(name: "\(name).partitionsToDelete[]")
            }
            try self.validate(self.partitionsToDelete, name: "partitionsToDelete", parent: name, max: 25)
            try self.validate(self.partitionsToDelete, name: "partitionsToDelete", parent: name, min: 0)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionsToDelete = "PartitionsToDelete"
            case tableName = "TableName"
        }
    }

    public struct BatchDeletePartitionResponse: AWSDecodableShape {
        /// The errors encountered when trying to delete the requested partitions.
        public let errors: [PartitionError]?

        public init(errors: [PartitionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the tables to delete reside. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// A list of the table to delete.
        public let tablesToDelete: [String]

        public init(catalogId: String? = nil, databaseName: String, tablesToDelete: [String]) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tablesToDelete = tablesToDelete
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.tablesToDelete.forEach {
                try validate($0, name: "tablesToDelete[]", parent: name, max: 255)
                try validate($0, name: "tablesToDelete[]", parent: name, min: 1)
                try validate($0, name: "tablesToDelete[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.tablesToDelete, name: "tablesToDelete", parent: name, max: 100)
            try self.validate(self.tablesToDelete, name: "tablesToDelete", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tablesToDelete = "TablesToDelete"
        }
    }

    public struct BatchDeleteTableResponse: AWSDecodableShape {
        /// A list of errors encountered in attempting to delete the specified tables.
        public let errors: [TableError]?

        public init(errors: [TableError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchDeleteTableVersionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table. For Hive compatibility, this name is entirely lowercase.
        public let tableName: String
        /// A list of the IDs of versions to be deleted. A VersionId is a string representation of an integer. Each version is incremented by 1.
        public let versionIds: [String]

        public init(catalogId: String? = nil, databaseName: String, tableName: String, versionIds: [String]) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.versionIds = versionIds
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.versionIds.forEach {
                try validate($0, name: "versionIds[]", parent: name, max: 255)
                try validate($0, name: "versionIds[]", parent: name, min: 1)
                try validate($0, name: "versionIds[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.versionIds, name: "versionIds", parent: name, max: 100)
            try self.validate(self.versionIds, name: "versionIds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case versionIds = "VersionIds"
        }
    }

    public struct BatchDeleteTableVersionResponse: AWSDecodableShape {
        /// A list of errors encountered while trying to delete the specified table versions.
        public let errors: [TableVersionError]?

        public init(errors: [TableVersionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BatchGetCrawlersRequest: AWSEncodableShape {
        /// A list of crawler names, which might be the names returned from the ListCrawlers operation.
        public let crawlerNames: [String]

        public init(crawlerNames: [String]) {
            self.crawlerNames = crawlerNames
        }

        public func validate(name: String) throws {
            try self.crawlerNames.forEach {
                try validate($0, name: "crawlerNames[]", parent: name, max: 255)
                try validate($0, name: "crawlerNames[]", parent: name, min: 1)
                try validate($0, name: "crawlerNames[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.crawlerNames, name: "crawlerNames", parent: name, max: 100)
            try self.validate(self.crawlerNames, name: "crawlerNames", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerNames = "CrawlerNames"
        }
    }

    public struct BatchGetCrawlersResponse: AWSDecodableShape {
        /// A list of crawler definitions.
        public let crawlers: [Crawler]?
        /// A list of names of crawlers that were not found.
        public let crawlersNotFound: [String]?

        public init(crawlers: [Crawler]? = nil, crawlersNotFound: [String]? = nil) {
            self.crawlers = crawlers
            self.crawlersNotFound = crawlersNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case crawlers = "Crawlers"
            case crawlersNotFound = "CrawlersNotFound"
        }
    }

    public struct BatchGetDevEndpointsRequest: AWSEncodableShape {
        /// The list of DevEndpoint names, which might be the names returned from the ListDevEndpoint operation.
        public let devEndpointNames: [String]

        public init(devEndpointNames: [String]) {
            self.devEndpointNames = devEndpointNames
        }

        public func validate(name: String) throws {
            try self.validate(self.devEndpointNames, name: "devEndpointNames", parent: name, max: 25)
            try self.validate(self.devEndpointNames, name: "devEndpointNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpointNames = "DevEndpointNames"
        }
    }

    public struct BatchGetDevEndpointsResponse: AWSDecodableShape {
        /// A list of DevEndpoint definitions.
        public let devEndpoints: [DevEndpoint]?
        /// A list of DevEndpoints not found.
        public let devEndpointsNotFound: [String]?

        public init(devEndpoints: [DevEndpoint]? = nil, devEndpointsNotFound: [String]? = nil) {
            self.devEndpoints = devEndpoints
            self.devEndpointsNotFound = devEndpointsNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpoints = "DevEndpoints"
            case devEndpointsNotFound = "DevEndpointsNotFound"
        }
    }

    public struct BatchGetJobsRequest: AWSEncodableShape {
        /// A list of job names, which might be the names returned from the ListJobs operation.
        public let jobNames: [String]

        public init(jobNames: [String]) {
            self.jobNames = jobNames
        }

        public func validate(name: String) throws {
            try self.jobNames.forEach {
                try validate($0, name: "jobNames[]", parent: name, max: 255)
                try validate($0, name: "jobNames[]", parent: name, min: 1)
                try validate($0, name: "jobNames[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case jobNames = "JobNames"
        }
    }

    public struct BatchGetJobsResponse: AWSDecodableShape {
        /// A list of job definitions.
        public let jobs: [Job]?
        /// A list of names of jobs not found.
        public let jobsNotFound: [String]?

        public init(jobs: [Job]? = nil, jobsNotFound: [String]? = nil) {
            self.jobs = jobs
            self.jobsNotFound = jobsNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case jobsNotFound = "JobsNotFound"
        }
    }

    public struct BatchGetPartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// A list of partition values identifying the partitions to retrieve.
        public let partitionsToGet: [PartitionValueList]
        /// The name of the partitions' table.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionsToGet: [PartitionValueList], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionsToGet = partitionsToGet
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionsToGet.forEach {
                try $0.validate(name: "\(name).partitionsToGet[]")
            }
            try self.validate(self.partitionsToGet, name: "partitionsToGet", parent: name, max: 1000)
            try self.validate(self.partitionsToGet, name: "partitionsToGet", parent: name, min: 0)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionsToGet = "PartitionsToGet"
            case tableName = "TableName"
        }
    }

    public struct BatchGetPartitionResponse: AWSDecodableShape {
        /// A list of the requested partitions.
        public let partitions: [Partition]?
        /// A list of the partition values in the request for which partitions were not returned.
        public let unprocessedKeys: [PartitionValueList]?

        public init(partitions: [Partition]? = nil, unprocessedKeys: [PartitionValueList]? = nil) {
            self.partitions = partitions
            self.unprocessedKeys = unprocessedKeys
        }

        private enum CodingKeys: String, CodingKey {
            case partitions = "Partitions"
            case unprocessedKeys = "UnprocessedKeys"
        }
    }

    public struct BatchGetTriggersRequest: AWSEncodableShape {
        /// A list of trigger names, which may be the names returned from the ListTriggers operation.
        public let triggerNames: [String]

        public init(triggerNames: [String]) {
            self.triggerNames = triggerNames
        }

        public func validate(name: String) throws {
            try self.triggerNames.forEach {
                try validate($0, name: "triggerNames[]", parent: name, max: 255)
                try validate($0, name: "triggerNames[]", parent: name, min: 1)
                try validate($0, name: "triggerNames[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case triggerNames = "TriggerNames"
        }
    }

    public struct BatchGetTriggersResponse: AWSDecodableShape {
        /// A list of trigger definitions.
        public let triggers: [Trigger]?
        /// A list of names of triggers not found.
        public let triggersNotFound: [String]?

        public init(triggers: [Trigger]? = nil, triggersNotFound: [String]? = nil) {
            self.triggers = triggers
            self.triggersNotFound = triggersNotFound
        }

        private enum CodingKeys: String, CodingKey {
            case triggers = "Triggers"
            case triggersNotFound = "TriggersNotFound"
        }
    }

    public struct BatchGetWorkflowsRequest: AWSEncodableShape {
        /// Specifies whether to include a graph when returning the workflow resource metadata.
        public let includeGraph: Bool?
        /// A list of workflow names, which may be the names returned from the ListWorkflows operation.
        public let names: [String]

        public init(includeGraph: Bool? = nil, names: [String]) {
            self.includeGraph = includeGraph
            self.names = names
        }

        public func validate(name: String) throws {
            try self.names.forEach {
                try validate($0, name: "names[]", parent: name, max: 255)
                try validate($0, name: "names[]", parent: name, min: 1)
                try validate($0, name: "names[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.names, name: "names", parent: name, max: 25)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case names = "Names"
        }
    }

    public struct BatchGetWorkflowsResponse: AWSDecodableShape {
        /// A list of names of workflows not found.
        public let missingWorkflows: [String]?
        /// A list of workflow resource metadata.
        public let workflows: [Workflow]?

        public init(missingWorkflows: [String]? = nil, workflows: [Workflow]? = nil) {
            self.missingWorkflows = missingWorkflows
            self.workflows = workflows
        }

        private enum CodingKeys: String, CodingKey {
            case missingWorkflows = "MissingWorkflows"
            case workflows = "Workflows"
        }
    }

    public struct BatchStopJobRunError: AWSDecodableShape {
        /// Specifies details about the error that was encountered.
        public let errorDetail: ErrorDetail?
        /// The name of the job definition that is used in the job run in question.
        public let jobName: String?
        /// The JobRunId of the job run in question.
        public let jobRunId: String?

        public init(errorDetail: ErrorDetail? = nil, jobName: String? = nil, jobRunId: String? = nil) {
            self.errorDetail = errorDetail
            self.jobName = jobName
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
        }
    }

    public struct BatchStopJobRunRequest: AWSEncodableShape {
        /// The name of the job definition for which to stop job runs.
        public let jobName: String
        /// A list of the JobRunIds that should be stopped for that job definition.
        public let jobRunIds: [String]

        public init(jobName: String, jobRunIds: [String]) {
            self.jobName = jobName
            self.jobRunIds = jobRunIds
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.jobRunIds.forEach {
                try validate($0, name: "jobRunIds[]", parent: name, max: 255)
                try validate($0, name: "jobRunIds[]", parent: name, min: 1)
                try validate($0, name: "jobRunIds[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.jobRunIds, name: "jobRunIds", parent: name, max: 25)
            try self.validate(self.jobRunIds, name: "jobRunIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobRunIds = "JobRunIds"
        }
    }

    public struct BatchStopJobRunResponse: AWSDecodableShape {
        /// A list of the errors that were encountered in trying to stop JobRuns, including the JobRunId for which each error was encountered and details about the error.
        public let errors: [BatchStopJobRunError]?
        /// A list of the JobRuns that were successfully submitted for stopping.
        public let successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]?

        public init(errors: [BatchStopJobRunError]? = nil, successfulSubmissions: [BatchStopJobRunSuccessfulSubmission]? = nil) {
            self.errors = errors
            self.successfulSubmissions = successfulSubmissions
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case successfulSubmissions = "SuccessfulSubmissions"
        }
    }

    public struct BatchStopJobRunSuccessfulSubmission: AWSDecodableShape {
        /// The name of the job definition used in the job run that was stopped.
        public let jobName: String?
        /// The JobRunId of the job run that was stopped.
        public let jobRunId: String?

        public init(jobName: String? = nil, jobRunId: String? = nil) {
            self.jobName = jobName
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobRunId = "JobRunId"
        }
    }

    public struct BatchUpdatePartitionFailureEntry: AWSDecodableShape {
        /// The details about the batch update partition error.
        public let errorDetail: ErrorDetail?
        /// A list of values defining the partitions.
        public let partitionValueList: [String]?

        public init(errorDetail: ErrorDetail? = nil, partitionValueList: [String]? = nil) {
            self.errorDetail = errorDetail
            self.partitionValueList = partitionValueList
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case partitionValueList = "PartitionValueList"
        }
    }

    public struct BatchUpdatePartitionRequest: AWSEncodableShape {
        /// The ID of the catalog in which the partition is to be updated. Currently, this should be the Amazon Web Services account ID.
        public let catalogId: String?
        /// The name of the metadata database in which the partition is to be updated.
        public let databaseName: String
        /// A list of up to 100 BatchUpdatePartitionRequestEntry objects to update.
        public let entries: [BatchUpdatePartitionRequestEntry]
        /// The name of the metadata table in which the partition is to be updated.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, entries: [BatchUpdatePartitionRequestEntry], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.entries = entries
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.entries, name: "entries", parent: name, max: 100)
            try self.validate(self.entries, name: "entries", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case entries = "Entries"
            case tableName = "TableName"
        }
    }

    public struct BatchUpdatePartitionRequestEntry: AWSEncodableShape {
        /// The structure used to update a partition.
        public let partitionInput: PartitionInput
        /// A list of values defining the partitions.
        public let partitionValueList: [String]

        public init(partitionInput: PartitionInput, partitionValueList: [String]) {
            self.partitionInput = partitionInput
            self.partitionValueList = partitionValueList
        }

        public func validate(name: String) throws {
            try self.partitionInput.validate(name: "\(name).partitionInput")
            try self.partitionValueList.forEach {
                try validate($0, name: "partitionValueList[]", parent: name, max: 1024)
            }
            try self.validate(self.partitionValueList, name: "partitionValueList", parent: name, max: 100)
            try self.validate(self.partitionValueList, name: "partitionValueList", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case partitionInput = "PartitionInput"
            case partitionValueList = "PartitionValueList"
        }
    }

    public struct BatchUpdatePartitionResponse: AWSDecodableShape {
        /// The errors encountered when trying to update the requested partitions. A list of BatchUpdatePartitionFailureEntry objects.
        public let errors: [BatchUpdatePartitionFailureEntry]?

        public init(errors: [BatchUpdatePartitionFailureEntry]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct BinaryColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The average bit sequence length in the column.
        public let averageLength: Double
        /// The size of the longest bit sequence in the column.
        public let maximumLength: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        public init(averageLength: Double, maximumLength: Int64, numberOfNulls: Int64) {
            self.averageLength = averageLength
            self.maximumLength = maximumLength
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.averageLength, name: "averageLength", parent: name, min: 0)
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case averageLength = "AverageLength"
            case maximumLength = "MaximumLength"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct BooleanColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The number of false values in the column.
        public let numberOfFalses: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64
        /// The number of true values in the column.
        public let numberOfTrues: Int64

        public init(numberOfFalses: Int64, numberOfNulls: Int64, numberOfTrues: Int64) {
            self.numberOfFalses = numberOfFalses
            self.numberOfNulls = numberOfNulls
            self.numberOfTrues = numberOfTrues
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfFalses, name: "numberOfFalses", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
            try self.validate(self.numberOfTrues, name: "numberOfTrues", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfFalses = "NumberOfFalses"
            case numberOfNulls = "NumberOfNulls"
            case numberOfTrues = "NumberOfTrues"
        }
    }

    public struct CancelMLTaskRunRequest: AWSEncodableShape {
        /// A unique identifier for the task run.
        public let taskRunId: String
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        public init(taskRunId: String, transformId: String) {
            self.taskRunId = taskRunId
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, max: 255)
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, min: 1)
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
            case transformId = "TransformId"
        }
    }

    public struct CancelMLTaskRunResponse: AWSDecodableShape {
        /// The status for this run.
        public let status: TaskStatusType?
        /// The unique identifier for the task run.
        public let taskRunId: String?
        /// The unique identifier of the machine learning transform.
        public let transformId: String?

        public init(status: TaskStatusType? = nil, taskRunId: String? = nil, transformId: String? = nil) {
            self.status = status
            self.taskRunId = taskRunId
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case taskRunId = "TaskRunId"
            case transformId = "TransformId"
        }
    }

    public struct CatalogEntry: AWSEncodableShape {
        /// The database in which the table metadata resides.
        public let databaseName: String
        /// The name of the table in question.
        public let tableName: String

        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct CatalogImportStatus: AWSDecodableShape {
        ///  True if the migration has completed, or False otherwise.
        public let importCompleted: Bool?
        /// The name of the person who initiated the migration.
        public let importedBy: String?
        /// The time that the migration was started.
        public let importTime: Date?

        public init(importCompleted: Bool? = nil, importedBy: String? = nil, importTime: Date? = nil) {
            self.importCompleted = importCompleted
            self.importedBy = importedBy
            self.importTime = importTime
        }

        private enum CodingKeys: String, CodingKey {
            case importCompleted = "ImportCompleted"
            case importedBy = "ImportedBy"
            case importTime = "ImportTime"
        }
    }

    public struct CatalogTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database to be synchronized.
        public let databaseName: String
        /// A list of the tables to be synchronized.
        public let tables: [String]

        public init(databaseName: String, tables: [String]) {
            self.databaseName = databaseName
            self.tables = tables
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.tables.forEach {
                try validate($0, name: "tables[]", parent: name, max: 255)
                try validate($0, name: "tables[]", parent: name, min: 1)
                try validate($0, name: "tables[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.tables, name: "tables", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case tables = "Tables"
        }
    }

    public struct CheckSchemaVersionValidityInput: AWSEncodableShape {
        /// The data format of the schema definition. Currently AVRO and JSON are supported.
        public let dataFormat: DataFormat
        /// The definition of the schema that has to be validated.
        public let schemaDefinition: String

        public init(dataFormat: DataFormat, schemaDefinition: String) {
            self.dataFormat = dataFormat
            self.schemaDefinition = schemaDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, max: 170_000)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, min: 1)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case dataFormat = "DataFormat"
            case schemaDefinition = "SchemaDefinition"
        }
    }

    public struct CheckSchemaVersionValidityResponse: AWSDecodableShape {
        /// A validation failure error message.
        public let error: String?
        /// Return true, if the schema is valid and false otherwise.
        public let valid: Bool?

        public init(error: String? = nil, valid: Bool? = nil) {
            self.error = error
            self.valid = valid
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case valid = "Valid"
        }
    }

    public struct Classifier: AWSDecodableShape {
        /// A classifier for comma-separated values (CSV).
        public let csvClassifier: CsvClassifier?
        /// A classifier that uses grok.
        public let grokClassifier: GrokClassifier?
        /// A classifier for JSON content.
        public let jsonClassifier: JsonClassifier?
        /// A classifier for XML content.
        public let xMLClassifier: XMLClassifier?

        public init(csvClassifier: CsvClassifier? = nil, grokClassifier: GrokClassifier? = nil, jsonClassifier: JsonClassifier? = nil, xMLClassifier: XMLClassifier? = nil) {
            self.csvClassifier = csvClassifier
            self.grokClassifier = grokClassifier
            self.jsonClassifier = jsonClassifier
            self.xMLClassifier = xMLClassifier
        }

        private enum CodingKeys: String, CodingKey {
            case csvClassifier = "CsvClassifier"
            case grokClassifier = "GrokClassifier"
            case jsonClassifier = "JsonClassifier"
            case xMLClassifier = "XMLClassifier"
        }
    }

    public struct CloudWatchEncryption: AWSEncodableShape & AWSDecodableShape {
        /// The encryption mode to use for CloudWatch data.
        public let cloudWatchEncryptionMode: CloudWatchEncryptionMode?
        /// The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        public let kmsKeyArn: String?

        public init(cloudWatchEncryptionMode: CloudWatchEncryptionMode? = nil, kmsKeyArn: String? = nil) {
            self.cloudWatchEncryptionMode = cloudWatchEncryptionMode
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "arn:aws:kms:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchEncryptionMode = "CloudWatchEncryptionMode"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct CodeGenEdge: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the node at which the edge starts.
        public let source: String
        /// The ID of the node at which the edge ends.
        public let target: String
        /// The target of the edge.
        public let targetParameter: String?

        public init(source: String, target: String, targetParameter: String? = nil) {
            self.source = source
            self.target = target
            self.targetParameter = targetParameter
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, max: 255)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "[A-Za-z_][A-Za-z0-9_]*")
            try self.validate(self.target, name: "target", parent: name, max: 255)
            try self.validate(self.target, name: "target", parent: name, min: 1)
            try self.validate(self.target, name: "target", parent: name, pattern: "[A-Za-z_][A-Za-z0-9_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "Source"
            case target = "Target"
            case targetParameter = "TargetParameter"
        }
    }

    public struct CodeGenNode: AWSEncodableShape & AWSDecodableShape {
        /// Properties of the node, in the form of name-value pairs.
        public let args: [CodeGenNodeArg]
        /// A node identifier that is unique within the node's graph.
        public let id: String
        /// The line number of the node.
        public let lineNumber: Int?
        /// The type of node that this is.
        public let nodeType: String

        public init(args: [CodeGenNodeArg], id: String, lineNumber: Int? = nil, nodeType: String) {
            self.args = args
            self.id = id
            self.lineNumber = lineNumber
            self.nodeType = nodeType
        }

        public func validate(name: String) throws {
            try self.validate(self.args, name: "args", parent: name, max: 50)
            try self.validate(self.args, name: "args", parent: name, min: 0)
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "[A-Za-z_][A-Za-z0-9_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case args = "Args"
            case id = "Id"
            case lineNumber = "LineNumber"
            case nodeType = "NodeType"
        }
    }

    public struct CodeGenNodeArg: AWSEncodableShape & AWSDecodableShape {
        /// The name of the argument or property.
        public let name: String
        /// True if the value is used as a parameter.
        public let param: Bool?
        /// The value of the argument or property.
        public let value: String

        public init(name: String, param: Bool? = nil, value: String) {
            self.name = name
            self.param = param
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case param = "Param"
            case value = "Value"
        }
    }

    public struct Column: AWSEncodableShape & AWSDecodableShape {
        /// A free-form text comment.
        public let comment: String?
        /// The name of the Column.
        public let name: String
        /// These key-value pairs define properties associated with the column.
        public let parameters: [String: String]?
        /// The data type of the Column.
        public let type: String?

        public init(comment: String? = nil, name: String, parameters: [String: String]? = nil, type: String? = nil) {
            self.comment = comment
            self.name = name
            self.parameters = parameters
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 255)
            try self.validate(self.comment, name: "comment", parent: name, min: 0)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512_000)
            }
            try self.validate(self.type, name: "type", parent: name, max: 131_072)
            try self.validate(self.type, name: "type", parent: name, min: 0)
            try self.validate(self.type, name: "type", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "Comment"
            case name = "Name"
            case parameters = "Parameters"
            case type = "Type"
        }
    }

    public struct ColumnError: AWSDecodableShape {
        /// The name of the column that failed.
        public let columnName: String?
        /// An error message with the reason for the failure of an operation.
        public let error: ErrorDetail?

        public init(columnName: String? = nil, error: ErrorDetail? = nil) {
            self.columnName = columnName
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case error = "Error"
        }
    }

    public struct ColumnImportance: AWSDecodableShape {
        /// The name of a column.
        public let columnName: String?
        /// The column importance score for the column, as a decimal.
        public let importance: Double?

        public init(columnName: String? = nil, importance: Double? = nil) {
            self.columnName = columnName
            self.importance = importance
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "ColumnName"
            case importance = "Importance"
        }
    }

    public struct ColumnStatistics: AWSEncodableShape & AWSDecodableShape {
        /// The timestamp of when column statistics were generated.
        public let analyzedTime: Date
        /// Name of column which statistics belong to.
        public let columnName: String
        /// The data type of the column.
        public let columnType: String
        /// A ColumnStatisticData object that contains the statistics data values.
        public let statisticsData: ColumnStatisticsData

        public init(analyzedTime: Date, columnName: String, columnType: String, statisticsData: ColumnStatisticsData) {
            self.analyzedTime = analyzedTime
            self.columnName = columnName
            self.columnType = columnType
            self.statisticsData = statisticsData
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 255)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.columnType, name: "columnType", parent: name, max: 20000)
            try self.validate(self.columnType, name: "columnType", parent: name, min: 0)
            try self.validate(self.columnType, name: "columnType", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.statisticsData.validate(name: "\(name).statisticsData")
        }

        private enum CodingKeys: String, CodingKey {
            case analyzedTime = "AnalyzedTime"
            case columnName = "ColumnName"
            case columnType = "ColumnType"
            case statisticsData = "StatisticsData"
        }
    }

    public struct ColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// Binary column statistics data.
        public let binaryColumnStatisticsData: BinaryColumnStatisticsData?
        /// Boolean column statistics data.
        public let booleanColumnStatisticsData: BooleanColumnStatisticsData?
        /// Date column statistics data.
        public let dateColumnStatisticsData: DateColumnStatisticsData?
        /// Decimal column statistics data.
        public let decimalColumnStatisticsData: DecimalColumnStatisticsData?
        /// Double column statistics data.
        public let doubleColumnStatisticsData: DoubleColumnStatisticsData?
        /// Long column statistics data.
        public let longColumnStatisticsData: LongColumnStatisticsData?
        /// String column statistics data.
        public let stringColumnStatisticsData: StringColumnStatisticsData?
        /// The type of column statistics data.
        public let type: ColumnStatisticsType

        public init(binaryColumnStatisticsData: BinaryColumnStatisticsData? = nil, booleanColumnStatisticsData: BooleanColumnStatisticsData? = nil, dateColumnStatisticsData: DateColumnStatisticsData? = nil, decimalColumnStatisticsData: DecimalColumnStatisticsData? = nil, doubleColumnStatisticsData: DoubleColumnStatisticsData? = nil, longColumnStatisticsData: LongColumnStatisticsData? = nil, stringColumnStatisticsData: StringColumnStatisticsData? = nil, type: ColumnStatisticsType) {
            self.binaryColumnStatisticsData = binaryColumnStatisticsData
            self.booleanColumnStatisticsData = booleanColumnStatisticsData
            self.dateColumnStatisticsData = dateColumnStatisticsData
            self.decimalColumnStatisticsData = decimalColumnStatisticsData
            self.doubleColumnStatisticsData = doubleColumnStatisticsData
            self.longColumnStatisticsData = longColumnStatisticsData
            self.stringColumnStatisticsData = stringColumnStatisticsData
            self.type = type
        }

        public func validate(name: String) throws {
            try self.binaryColumnStatisticsData?.validate(name: "\(name).binaryColumnStatisticsData")
            try self.booleanColumnStatisticsData?.validate(name: "\(name).booleanColumnStatisticsData")
            try self.dateColumnStatisticsData?.validate(name: "\(name).dateColumnStatisticsData")
            try self.decimalColumnStatisticsData?.validate(name: "\(name).decimalColumnStatisticsData")
            try self.doubleColumnStatisticsData?.validate(name: "\(name).doubleColumnStatisticsData")
            try self.longColumnStatisticsData?.validate(name: "\(name).longColumnStatisticsData")
            try self.stringColumnStatisticsData?.validate(name: "\(name).stringColumnStatisticsData")
        }

        private enum CodingKeys: String, CodingKey {
            case binaryColumnStatisticsData = "BinaryColumnStatisticsData"
            case booleanColumnStatisticsData = "BooleanColumnStatisticsData"
            case dateColumnStatisticsData = "DateColumnStatisticsData"
            case decimalColumnStatisticsData = "DecimalColumnStatisticsData"
            case doubleColumnStatisticsData = "DoubleColumnStatisticsData"
            case longColumnStatisticsData = "LongColumnStatisticsData"
            case stringColumnStatisticsData = "StringColumnStatisticsData"
            case type = "Type"
        }
    }

    public struct ColumnStatisticsError: AWSDecodableShape {
        /// The ColumnStatistics of the column.
        public let columnStatistics: ColumnStatistics?
        /// An error message with the reason for the failure of an operation.
        public let error: ErrorDetail?

        public init(columnStatistics: ColumnStatistics? = nil, error: ErrorDetail? = nil) {
            self.columnStatistics = columnStatistics
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatistics = "ColumnStatistics"
            case error = "Error"
        }
    }

    public struct Condition: AWSEncodableShape & AWSDecodableShape {
        /// The name of the crawler to which this condition applies.
        public let crawlerName: String?
        /// The state of the crawler to which this condition applies.
        public let crawlState: CrawlState?
        /// The name of the job whose JobRuns this condition applies to, and on which this trigger waits.
        public let jobName: String?
        /// A logical operator.
        public let logicalOperator: LogicalOperator?
        /// The condition state. Currently, the only job states that a trigger can listen for are SUCCEEDED, STOPPED, FAILED, and TIMEOUT. The only crawler states that a trigger can listen for are SUCCEEDED, FAILED, and CANCELLED.
        public let state: JobRunState?

        public init(crawlerName: String? = nil, crawlState: CrawlState? = nil, jobName: String? = nil, logicalOperator: LogicalOperator? = nil, state: JobRunState? = nil) {
            self.crawlerName = crawlerName
            self.crawlState = crawlState
            self.jobName = jobName
            self.logicalOperator = logicalOperator
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
            case crawlState = "CrawlState"
            case jobName = "JobName"
            case logicalOperator = "LogicalOperator"
            case state = "State"
        }
    }

    public struct ConfusionMatrix: AWSDecodableShape {
        /// The number of matches in the data that the transform didn't find, in the confusion matrix for your transform.
        public let numFalseNegatives: Int64?
        /// The number of nonmatches in the data that the transform incorrectly classified as a match, in the confusion matrix for your transform.
        public let numFalsePositives: Int64?
        /// The number of nonmatches in the data that the transform correctly rejected, in the confusion matrix for your transform.
        public let numTrueNegatives: Int64?
        /// The number of matches in the data that the transform correctly found, in the confusion matrix for your transform.
        public let numTruePositives: Int64?

        public init(numFalseNegatives: Int64? = nil, numFalsePositives: Int64? = nil, numTrueNegatives: Int64? = nil, numTruePositives: Int64? = nil) {
            self.numFalseNegatives = numFalseNegatives
            self.numFalsePositives = numFalsePositives
            self.numTrueNegatives = numTrueNegatives
            self.numTruePositives = numTruePositives
        }

        private enum CodingKeys: String, CodingKey {
            case numFalseNegatives = "NumFalseNegatives"
            case numFalsePositives = "NumFalsePositives"
            case numTrueNegatives = "NumTrueNegatives"
            case numTruePositives = "NumTruePositives"
        }
    }

    public struct Connection: AWSDecodableShape {
        /// These key-value pairs define parameters for the connection:    HOST - The host URI: either the fully qualified domain name (FQDN) or the IPv4 address of the database host.    PORT - The port number, between 1024 and 65535, of the port on which the database host is listening for database connections.    USER_NAME - The name under which to log in to the database. The value string for USER_NAME is "USERNAME".    PASSWORD - A password, if one is used, for the user name.    ENCRYPTED_PASSWORD - When you enable connection password protection by setting ConnectionPasswordEncryption in the Data Catalog encryption settings, this field stores the encrypted password.    JDBC_DRIVER_JAR_URI - The Amazon Simple Storage Service (Amazon S3) path of the JAR file that contains the JDBC driver to use.    JDBC_DRIVER_CLASS_NAME - The class name of the JDBC driver to use.    JDBC_ENGINE - The name of the JDBC engine to use.    JDBC_ENGINE_VERSION - The version of the JDBC engine to use.    CONFIG_FILES - (Reserved for future use.)    INSTANCE_ID - The instance ID to use.    JDBC_CONNECTION_URL - The URL for connecting to a JDBC data source.    JDBC_ENFORCE_SSL - A Boolean string (true, false) specifying whether Secure Sockets Layer (SSL) with hostname matching is enforced for the JDBC connection on the client. The default is false.    CUSTOM_JDBC_CERT - An Amazon S3 location specifying the customer's root certificate. Glue uses this root certificate to validate the customer’s certificate when connecting to the customer database. Glue only handles X.509 certificates. The certificate provided must be DER-encoded and supplied in Base64 encoding PEM format.    SKIP_CUSTOM_JDBC_CERT_VALIDATION - By default, this is false. Glue validates the Signature algorithm and Subject Public Key Algorithm for the customer certificate. The only permitted algorithms for the Signature algorithm are SHA256withRSA, SHA384withRSA or SHA512withRSA. For the Subject Public Key Algorithm, the key length must be at least 2048. You can set the value of this property to true to skip Glue’s validation of the customer certificate.    CUSTOM_JDBC_CERT_STRING - A custom JDBC certificate string which is used for domain match or distinguished name match to prevent a man-in-the-middle attack. In Oracle database, this is used as the SSL_SERVER_CERT_DN; in Microsoft SQL Server, this is used as the hostNameInCertificate.    CONNECTION_URL - The URL for connecting to a general (non-JDBC) data source.    KAFKA_BOOTSTRAP_SERVERS - A comma-separated list of host and port pairs that are the addresses of the Apache Kafka brokers in a Kafka cluster to which a Kafka client will connect to and bootstrap itself.    KAFKA_SSL_ENABLED - Whether to enable or disable SSL on an Apache Kafka connection. Default value is "true".    KAFKA_CUSTOM_CERT - The Amazon S3 URL for the private CA cert file (.pem format). The default is an empty string.    KAFKA_SKIP_CUSTOM_CERT_VALIDATION - Whether to skip the validation of the CA cert file or not. Glue validates for three algorithms: SHA256withRSA, SHA384withRSA and SHA512withRSA. Default value is "false".    SECRET_ID - The secret ID used for the secret manager of credentials.    CONNECTOR_URL - The connector URL for a MARKETPLACE or CUSTOM connection.    CONNECTOR_TYPE - The connector type for a MARKETPLACE or CUSTOM connection.    CONNECTOR_CLASS_NAME - The connector class name for a MARKETPLACE or CUSTOM connection.    KAFKA_CLIENT_KEYSTORE - The Amazon S3 location of the client keystore file for Kafka client side authentication (Optional).    KAFKA_CLIENT_KEYSTORE_PASSWORD - The password to access the provided keystore (Optional).    KAFKA_CLIENT_KEY_PASSWORD - A keystore can consist of multiple keys, so this is the password to access the client key to be used with the Kafka server side key (Optional).    ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD - The encrypted version of the Kafka client keystore password (if the user has the Glue encrypt passwords setting selected).    ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD - The encrypted version of the Kafka client key password (if the user has the Glue encrypt passwords setting selected).
        public let connectionProperties: [ConnectionPropertyKey: String]?
        /// The type of the connection. Currently, SFTP is not supported.
        public let connectionType: ConnectionType?
        /// The time that this connection definition was created.
        public let creationTime: Date?
        /// The description of the connection.
        public let description: String?
        /// The user, group, or role that last updated this connection definition.
        public let lastUpdatedBy: String?
        /// The last time that this connection definition was updated.
        public let lastUpdatedTime: Date?
        /// A list of criteria that can be used in selecting this connection.
        public let matchCriteria: [String]?
        /// The name of the connection definition.
        public let name: String?
        /// A map of physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup, that are needed to make this connection successfully.
        public let physicalConnectionRequirements: PhysicalConnectionRequirements?

        public init(connectionProperties: [ConnectionPropertyKey: String]? = nil, connectionType: ConnectionType? = nil, creationTime: Date? = nil, description: String? = nil, lastUpdatedBy: String? = nil, lastUpdatedTime: Date? = nil, matchCriteria: [String]? = nil, name: String? = nil, physicalConnectionRequirements: PhysicalConnectionRequirements? = nil) {
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
            self.creationTime = creationTime
            self.description = description
            self.lastUpdatedBy = lastUpdatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.matchCriteria = matchCriteria
            self.name = name
            self.physicalConnectionRequirements = physicalConnectionRequirements
        }

        private enum CodingKeys: String, CodingKey {
            case connectionProperties = "ConnectionProperties"
            case connectionType = "ConnectionType"
            case creationTime = "CreationTime"
            case description = "Description"
            case lastUpdatedBy = "LastUpdatedBy"
            case lastUpdatedTime = "LastUpdatedTime"
            case matchCriteria = "MatchCriteria"
            case name = "Name"
            case physicalConnectionRequirements = "PhysicalConnectionRequirements"
        }
    }

    public struct ConnectionInput: AWSEncodableShape {
        /// These key-value pairs define parameters for the connection.
        public let connectionProperties: [ConnectionPropertyKey: String]
        /// The type of the connection. Currently, these types are supported:    JDBC - Designates a connection to a database through Java Database Connectivity (JDBC).    KAFKA - Designates a connection to an Apache Kafka streaming platform.    MONGODB - Designates a connection to a MongoDB document database.    NETWORK - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).    MARKETPLACE - Uses configuration settings contained in a connector purchased from Marketplace to read from and write to data stores that are not natively supported by Glue.    CUSTOM - Uses configuration settings contained in a custom connector to read from and write to data stores that are not natively supported by Glue.   SFTP is not supported.
        public let connectionType: ConnectionType
        /// The description of the connection.
        public let description: String?
        /// A list of criteria that can be used in selecting this connection.
        public let matchCriteria: [String]?
        /// The name of the connection.
        public let name: String
        /// A map of physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup, that are needed to successfully make this connection.
        public let physicalConnectionRequirements: PhysicalConnectionRequirements?

        public init(connectionProperties: [ConnectionPropertyKey: String], connectionType: ConnectionType, description: String? = nil, matchCriteria: [String]? = nil, name: String, physicalConnectionRequirements: PhysicalConnectionRequirements? = nil) {
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
            self.description = description
            self.matchCriteria = matchCriteria
            self.name = name
            self.physicalConnectionRequirements = physicalConnectionRequirements
        }

        public func validate(name: String) throws {
            try self.connectionProperties.forEach {
                try validate($0.value, name: "connectionProperties[\"\($0.key)\"]", parent: name, max: 1024)
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.matchCriteria?.forEach {
                try validate($0, name: "matchCriteria[]", parent: name, max: 255)
                try validate($0, name: "matchCriteria[]", parent: name, min: 1)
                try validate($0, name: "matchCriteria[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.matchCriteria, name: "matchCriteria", parent: name, max: 10)
            try self.validate(self.matchCriteria, name: "matchCriteria", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.physicalConnectionRequirements?.validate(name: "\(name).physicalConnectionRequirements")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionProperties = "ConnectionProperties"
            case connectionType = "ConnectionType"
            case description = "Description"
            case matchCriteria = "MatchCriteria"
            case name = "Name"
            case physicalConnectionRequirements = "PhysicalConnectionRequirements"
        }
    }

    public struct ConnectionPasswordEncryption: AWSEncodableShape & AWSDecodableShape {
        /// An KMS key that is used to encrypt the connection password.  If connection password protection is enabled, the caller of CreateConnection and UpdateConnection needs at least kms:Encrypt permission on the specified KMS key, to encrypt passwords before storing them in the Data Catalog.  You can set the decrypt permission to enable or restrict access on the password key according to your security requirements.
        public let awsKmsKeyId: String?
        /// When the ReturnConnectionPasswordEncrypted flag is set to "true", passwords remain encrypted in the responses of GetConnection and GetConnections. This encryption takes effect independently from catalog encryption.
        public let returnConnectionPasswordEncrypted: Bool

        public init(awsKmsKeyId: String? = nil, returnConnectionPasswordEncrypted: Bool) {
            self.awsKmsKeyId = awsKmsKeyId
            self.returnConnectionPasswordEncrypted = returnConnectionPasswordEncrypted
        }

        public func validate(name: String) throws {
            try self.validate(self.awsKmsKeyId, name: "awsKmsKeyId", parent: name, max: 255)
            try self.validate(self.awsKmsKeyId, name: "awsKmsKeyId", parent: name, min: 1)
            try self.validate(self.awsKmsKeyId, name: "awsKmsKeyId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case awsKmsKeyId = "AwsKmsKeyId"
            case returnConnectionPasswordEncrypted = "ReturnConnectionPasswordEncrypted"
        }
    }

    public struct ConnectionsList: AWSEncodableShape & AWSDecodableShape {
        /// A list of connections used by the job.
        public let connections: [String]?

        public init(connections: [String]? = nil) {
            self.connections = connections
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
        }
    }

    public struct Crawl: AWSDecodableShape {
        /// The date and time on which the crawl completed.
        public let completedOn: Date?
        /// The error message associated with the crawl.
        public let errorMessage: String?
        /// The log group associated with the crawl.
        public let logGroup: String?
        /// The log stream associated with the crawl.
        public let logStream: String?
        /// The date and time on which the crawl started.
        public let startedOn: Date?
        /// The state of the crawler.
        public let state: CrawlState?

        public init(completedOn: Date? = nil, errorMessage: String? = nil, logGroup: String? = nil, logStream: String? = nil, startedOn: Date? = nil, state: CrawlState? = nil) {
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.logGroup = logGroup
            self.logStream = logStream
            self.startedOn = startedOn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case errorMessage = "ErrorMessage"
            case logGroup = "LogGroup"
            case logStream = "LogStream"
            case startedOn = "StartedOn"
            case state = "State"
        }
    }

    public struct Crawler: AWSDecodableShape {
        /// A list of UTF-8 strings that specify the custom classifiers that are associated with the crawler.
        public let classifiers: [String]?
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Include and Exclude Patterns.
        public let configuration: String?
        /// If the crawler is running, contains the total time elapsed since the last crawl began.
        public let crawlElapsedTime: Int64?
        /// The name of the SecurityConfiguration structure to be used by this crawler.
        public let crawlerSecurityConfiguration: String?
        /// The time that the crawler was created.
        public let creationTime: Date?
        /// The name of the database in which the crawler's output is stored.
        public let databaseName: String?
        /// A description of the crawler.
        public let description: String?
        /// The status of the last crawl, and potentially error information if an error occurred.
        public let lastCrawl: LastCrawlInfo?
        /// The time that the crawler was last updated.
        public let lastUpdated: Date?
        /// A configuration that specifies whether data lineage is enabled for the crawler.
        public let lineageConfiguration: LineageConfiguration?
        /// The name of the crawler.
        public let name: String?
        /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
        public let recrawlPolicy: RecrawlPolicy?
        /// The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as Amazon Simple Storage Service (Amazon S3) data.
        public let role: String?
        /// For scheduled crawlers, the schedule when the crawler runs.
        public let schedule: Schedule?
        /// The policy that specifies update and delete behaviors for the crawler.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// Indicates whether the crawler is running, or whether a run is pending.
        public let state: CrawlerState?
        /// The prefix added to the names of tables that are created.
        public let tablePrefix: String?
        /// A collection of targets to crawl.
        public let targets: CrawlerTargets?
        /// The version of the crawler.
        public let version: Int64?

        public init(classifiers: [String]? = nil, configuration: String? = nil, crawlElapsedTime: Int64? = nil, crawlerSecurityConfiguration: String? = nil, creationTime: Date? = nil, databaseName: String? = nil, description: String? = nil, lastCrawl: LastCrawlInfo? = nil, lastUpdated: Date? = nil, lineageConfiguration: LineageConfiguration? = nil, name: String? = nil, recrawlPolicy: RecrawlPolicy? = nil, role: String? = nil, schedule: Schedule? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, state: CrawlerState? = nil, tablePrefix: String? = nil, targets: CrawlerTargets? = nil, version: Int64? = nil) {
            self.classifiers = classifiers
            self.configuration = configuration
            self.crawlElapsedTime = crawlElapsedTime
            self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.description = description
            self.lastCrawl = lastCrawl
            self.lastUpdated = lastUpdated
            self.lineageConfiguration = lineageConfiguration
            self.name = name
            self.recrawlPolicy = recrawlPolicy
            self.role = role
            self.schedule = schedule
            self.schemaChangePolicy = schemaChangePolicy
            self.state = state
            self.tablePrefix = tablePrefix
            self.targets = targets
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case configuration = "Configuration"
            case crawlElapsedTime = "CrawlElapsedTime"
            case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case description = "Description"
            case lastCrawl = "LastCrawl"
            case lastUpdated = "LastUpdated"
            case lineageConfiguration = "LineageConfiguration"
            case name = "Name"
            case recrawlPolicy = "RecrawlPolicy"
            case role = "Role"
            case schedule = "Schedule"
            case schemaChangePolicy = "SchemaChangePolicy"
            case state = "State"
            case tablePrefix = "TablePrefix"
            case targets = "Targets"
            case version = "Version"
        }
    }

    public struct CrawlerMetrics: AWSDecodableShape {
        /// The name of the crawler.
        public let crawlerName: String?
        /// The duration of the crawler's most recent run, in seconds.
        public let lastRuntimeSeconds: Double?
        /// The median duration of this crawler's runs, in seconds.
        public let medianRuntimeSeconds: Double?
        /// True if the crawler is still estimating how long it will take to complete this run.
        public let stillEstimating: Bool?
        /// The number of tables created by this crawler.
        public let tablesCreated: Int?
        /// The number of tables deleted by this crawler.
        public let tablesDeleted: Int?
        /// The number of tables updated by this crawler.
        public let tablesUpdated: Int?
        /// The estimated time left to complete a running crawl.
        public let timeLeftSeconds: Double?

        public init(crawlerName: String? = nil, lastRuntimeSeconds: Double? = nil, medianRuntimeSeconds: Double? = nil, stillEstimating: Bool? = nil, tablesCreated: Int? = nil, tablesDeleted: Int? = nil, tablesUpdated: Int? = nil, timeLeftSeconds: Double? = nil) {
            self.crawlerName = crawlerName
            self.lastRuntimeSeconds = lastRuntimeSeconds
            self.medianRuntimeSeconds = medianRuntimeSeconds
            self.stillEstimating = stillEstimating
            self.tablesCreated = tablesCreated
            self.tablesDeleted = tablesDeleted
            self.tablesUpdated = tablesUpdated
            self.timeLeftSeconds = timeLeftSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
            case lastRuntimeSeconds = "LastRuntimeSeconds"
            case medianRuntimeSeconds = "MedianRuntimeSeconds"
            case stillEstimating = "StillEstimating"
            case tablesCreated = "TablesCreated"
            case tablesDeleted = "TablesDeleted"
            case tablesUpdated = "TablesUpdated"
            case timeLeftSeconds = "TimeLeftSeconds"
        }
    }

    public struct CrawlerNodeDetails: AWSDecodableShape {
        /// A list of crawls represented by the crawl node.
        public let crawls: [Crawl]?

        public init(crawls: [Crawl]? = nil) {
            self.crawls = crawls
        }

        private enum CodingKeys: String, CodingKey {
            case crawls = "Crawls"
        }
    }

    public struct CrawlerTargets: AWSEncodableShape & AWSDecodableShape {
        /// Specifies Glue Data Catalog targets.
        public let catalogTargets: [CatalogTarget]?
        /// Specifies Amazon DynamoDB targets.
        public let dynamoDBTargets: [DynamoDBTarget]?
        /// Specifies JDBC targets.
        public let jdbcTargets: [JdbcTarget]?
        /// Specifies Amazon DocumentDB or MongoDB targets.
        public let mongoDBTargets: [MongoDBTarget]?
        /// Specifies Amazon Simple Storage Service (Amazon S3) targets.
        public let s3Targets: [S3Target]?

        public init(catalogTargets: [CatalogTarget]? = nil, dynamoDBTargets: [DynamoDBTarget]? = nil, jdbcTargets: [JdbcTarget]? = nil, mongoDBTargets: [MongoDBTarget]? = nil, s3Targets: [S3Target]? = nil) {
            self.catalogTargets = catalogTargets
            self.dynamoDBTargets = dynamoDBTargets
            self.jdbcTargets = jdbcTargets
            self.mongoDBTargets = mongoDBTargets
            self.s3Targets = s3Targets
        }

        public func validate(name: String) throws {
            try self.catalogTargets?.forEach {
                try $0.validate(name: "\(name).catalogTargets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case catalogTargets = "CatalogTargets"
            case dynamoDBTargets = "DynamoDBTargets"
            case jdbcTargets = "JdbcTargets"
            case mongoDBTargets = "MongoDBTargets"
            case s3Targets = "S3Targets"
        }
    }

    public struct CreateClassifierRequest: AWSEncodableShape {
        /// A CsvClassifier object specifying the classifier to create.
        public let csvClassifier: CreateCsvClassifierRequest?
        /// A GrokClassifier object specifying the classifier to create.
        public let grokClassifier: CreateGrokClassifierRequest?
        /// A JsonClassifier object specifying the classifier to create.
        public let jsonClassifier: CreateJsonClassifierRequest?
        /// An XMLClassifier object specifying the classifier to create.
        public let xMLClassifier: CreateXMLClassifierRequest?

        public init(csvClassifier: CreateCsvClassifierRequest? = nil, grokClassifier: CreateGrokClassifierRequest? = nil, jsonClassifier: CreateJsonClassifierRequest? = nil, xMLClassifier: CreateXMLClassifierRequest? = nil) {
            self.csvClassifier = csvClassifier
            self.grokClassifier = grokClassifier
            self.jsonClassifier = jsonClassifier
            self.xMLClassifier = xMLClassifier
        }

        public func validate(name: String) throws {
            try self.csvClassifier?.validate(name: "\(name).csvClassifier")
            try self.grokClassifier?.validate(name: "\(name).grokClassifier")
            try self.jsonClassifier?.validate(name: "\(name).jsonClassifier")
            try self.xMLClassifier?.validate(name: "\(name).xMLClassifier")
        }

        private enum CodingKeys: String, CodingKey {
            case csvClassifier = "CsvClassifier"
            case grokClassifier = "GrokClassifier"
            case jsonClassifier = "JsonClassifier"
            case xMLClassifier = "XMLClassifier"
        }
    }

    public struct CreateClassifierResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateConnectionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which to create the connection. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A ConnectionInput object defining the connection to create.
        public let connectionInput: ConnectionInput

        public init(catalogId: String? = nil, connectionInput: ConnectionInput) {
            self.catalogId = catalogId
            self.connectionInput = connectionInput
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.connectionInput.validate(name: "\(name).connectionInput")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionInput = "ConnectionInput"
        }
    }

    public struct CreateConnectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateCrawlerRequest: AWSEncodableShape {
        /// A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
        public let classifiers: [String]?
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
        public let configuration: String?
        /// The name of the SecurityConfiguration structure to be used by this crawler.
        public let crawlerSecurityConfiguration: String?
        /// The Glue database where results are written, such as: arn:aws:daylight:us-east-1::database/sometable/*.
        public let databaseName: String?
        /// A description of the new crawler.
        public let description: String?
        /// Specifies data lineage configuration settings for the crawler.
        public let lineageConfiguration: LineageConfiguration?
        /// Name of the new crawler.
        public let name: String
        /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
        public let recrawlPolicy: RecrawlPolicy?
        /// The IAM role or Amazon Resource Name (ARN) of an IAM role used by the new crawler to access customer resources.
        public let role: String
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// The policy for the crawler's update and deletion behavior.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// The table prefix used for catalog tables that are created.
        public let tablePrefix: String?
        /// The tags to use with this crawler request. You may use tags to limit access to the crawler. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
        public let tags: [String: String]?
        /// A list of collection of targets to crawl.
        public let targets: CrawlerTargets

        public init(classifiers: [String]? = nil, configuration: String? = nil, crawlerSecurityConfiguration: String? = nil, databaseName: String? = nil, description: String? = nil, lineageConfiguration: LineageConfiguration? = nil, name: String, recrawlPolicy: RecrawlPolicy? = nil, role: String, schedule: String? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, tablePrefix: String? = nil, tags: [String: String]? = nil, targets: CrawlerTargets) {
            self.classifiers = classifiers
            self.configuration = configuration
            self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
            self.databaseName = databaseName
            self.description = description
            self.lineageConfiguration = lineageConfiguration
            self.name = name
            self.recrawlPolicy = recrawlPolicy
            self.role = role
            self.schedule = schedule
            self.schemaChangePolicy = schemaChangePolicy
            self.tablePrefix = tablePrefix
            self.tags = tags
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.classifiers?.forEach {
                try validate($0, name: "classifiers[]", parent: name, max: 255)
                try validate($0, name: "classifiers[]", parent: name, min: 1)
                try validate($0, name: "classifiers[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.crawlerSecurityConfiguration, name: "crawlerSecurityConfiguration", parent: name, max: 128)
            try self.validate(self.crawlerSecurityConfiguration, name: "crawlerSecurityConfiguration", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tablePrefix, name: "tablePrefix", parent: name, max: 128)
            try self.validate(self.tablePrefix, name: "tablePrefix", parent: name, min: 0)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
            try self.targets.validate(name: "\(name).targets")
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case configuration = "Configuration"
            case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
            case databaseName = "DatabaseName"
            case description = "Description"
            case lineageConfiguration = "LineageConfiguration"
            case name = "Name"
            case recrawlPolicy = "RecrawlPolicy"
            case role = "Role"
            case schedule = "Schedule"
            case schemaChangePolicy = "SchemaChangePolicy"
            case tablePrefix = "TablePrefix"
            case tags = "Tags"
            case targets = "Targets"
        }
    }

    public struct CreateCrawlerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateCsvClassifierRequest: AWSEncodableShape {
        /// Enables the processing of files that contain only one column.
        public let allowSingleColumn: Bool?
        /// Indicates whether the CSV file contains a header.
        public let containsHeader: CsvHeaderOption?
        /// A custom symbol to denote what separates each column entry in the row.
        public let delimiter: String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public let disableValueTrimming: Bool?
        /// A list of strings representing column names.
        public let header: [String]?
        /// The name of the classifier.
        public let name: String
        /// A custom symbol to denote what combines content into a single column value. Must be different from the column delimiter.
        public let quoteSymbol: String?

        public init(allowSingleColumn: Bool? = nil, containsHeader: CsvHeaderOption? = nil, delimiter: String? = nil, disableValueTrimming: Bool? = nil, header: [String]? = nil, name: String, quoteSymbol: String? = nil) {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.name = name
            self.quoteSymbol = quoteSymbol
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, pattern: "[^\\r\\n]")
            try self.header?.forEach {
                try validate($0, name: "header[]", parent: name, max: 255)
                try validate($0, name: "header[]", parent: name, min: 1)
                try validate($0, name: "header[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, max: 1)
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, min: 1)
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, pattern: "[^\\r\\n]")
        }

        private enum CodingKeys: String, CodingKey {
            case allowSingleColumn = "AllowSingleColumn"
            case containsHeader = "ContainsHeader"
            case delimiter = "Delimiter"
            case disableValueTrimming = "DisableValueTrimming"
            case header = "Header"
            case name = "Name"
            case quoteSymbol = "QuoteSymbol"
        }
    }

    public struct CreateDatabaseRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which to create the database. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The metadata for the database.
        public let databaseInput: DatabaseInput

        public init(catalogId: String? = nil, databaseInput: DatabaseInput) {
            self.catalogId = catalogId
            self.databaseInput = databaseInput
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.databaseInput.validate(name: "\(name).databaseInput")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseInput = "DatabaseInput"
        }
    }

    public struct CreateDatabaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateDevEndpointRequest: AWSEncodableShape {
        /// A map of arguments used to configure the DevEndpoint.
        public let arguments: [String: String]?
        /// The name to be assigned to the new DevEndpoint.
        public let endpointName: String
        /// The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint.
        public let extraJarsS3Path: String?
        /// The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma.  You can only use pure Python libraries with a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not yet supported.
        public let extraPythonLibsS3Path: String?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Development endpoints that are created without specifying a Glue version default to Glue 0.9. You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public let glueVersion: String?
        /// The number of Glue Data Processing Units (DPUs) to allocate to this DevEndpoint.
        public let numberOfNodes: Int?
        /// The number of workers of a defined workerType that are allocated to the development endpoint. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
        public let numberOfWorkers: Int?
        /// The public key to be used by this DevEndpoint for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.
        public let publicKey: String?
        /// A list of public keys to be used by the development endpoints for authentication. The use of this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.  If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the UpdateDevEndpoint API with the public key content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys attribute.
        public let publicKeys: [String]?
        /// The IAM role for the DevEndpoint.
        public let roleArn: String
        /// The name of the SecurityConfiguration structure to be used with this DevEndpoint.
        public let securityConfiguration: String?
        /// Security group IDs for the security groups to be used by the new DevEndpoint.
        public let securityGroupIds: [String]?
        /// The subnet ID for the new DevEndpoint to use.
        public let subnetId: String?
        /// The tags to use with this DevEndpoint. You may use tags to limit access to the DevEndpoint. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
        public let tags: [String: String]?
        /// The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   Known issue: when a development endpoint is created with the G.2X WorkerType configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk.
        public let workerType: WorkerType?

        public init(arguments: [String: String]? = nil, endpointName: String, extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil, glueVersion: String? = nil, numberOfNodes: Int? = nil, numberOfWorkers: Int? = nil, publicKey: String? = nil, publicKeys: [String]? = nil, roleArn: String, securityConfiguration: String? = nil, securityGroupIds: [String]? = nil, subnetId: String? = nil, tags: [String: String]? = nil, workerType: WorkerType? = nil) {
            self.arguments = arguments
            self.endpointName = endpointName
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.glueVersion = glueVersion
            self.numberOfNodes = numberOfNodes
            self.numberOfWorkers = numberOfWorkers
            self.publicKey = publicKey
            self.publicKeys = publicKeys
            self.roleArn = roleArn
            self.securityConfiguration = securityConfiguration
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
            self.tags = tags
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^\\w+\\.\\w+$")
            try self.validate(self.publicKeys, name: "publicKeys", parent: name, max: 5)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:aws:iam::\\d{12}:role/.*")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case endpointName = "EndpointName"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case glueVersion = "GlueVersion"
            case numberOfNodes = "NumberOfNodes"
            case numberOfWorkers = "NumberOfWorkers"
            case publicKey = "PublicKey"
            case publicKeys = "PublicKeys"
            case roleArn = "RoleArn"
            case securityConfiguration = "SecurityConfiguration"
            case securityGroupIds = "SecurityGroupIds"
            case subnetId = "SubnetId"
            case tags = "Tags"
            case workerType = "WorkerType"
        }
    }

    public struct CreateDevEndpointResponse: AWSDecodableShape {
        /// The map of arguments used to configure this DevEndpoint. Valid arguments are:    "--enable-glue-datacatalog": ""    You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public let arguments: [String: String]?
        /// The AWS Availability Zone where this DevEndpoint is located.
        public let availabilityZone: String?
        /// The point in time at which this DevEndpoint was created.
        public let createdTimestamp: Date?
        /// The name assigned to the new DevEndpoint.
        public let endpointName: String?
        /// Path to one or more Java .jar files in an S3 bucket that will be loaded in your DevEndpoint.
        public let extraJarsS3Path: String?
        /// The paths to one or more Python libraries in an S3 bucket that will be loaded in your DevEndpoint.
        public let extraPythonLibsS3Path: String?
        /// The reason for a current failure in this DevEndpoint.
        public let failureReason: String?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide.
        public let glueVersion: String?
        /// The number of Glue Data Processing Units (DPUs) allocated to this DevEndpoint.
        public let numberOfNodes: Int?
        /// The number of workers of a defined workerType that are allocated to the development endpoint.
        public let numberOfWorkers: Int?
        /// The Amazon Resource Name (ARN) of the role assigned to the new DevEndpoint.
        public let roleArn: String?
        /// The name of the SecurityConfiguration structure being used with this DevEndpoint.
        public let securityConfiguration: String?
        /// The security groups assigned to the new DevEndpoint.
        public let securityGroupIds: [String]?
        /// The current status of the new DevEndpoint.
        public let status: String?
        /// The subnet ID assigned to the new DevEndpoint.
        public let subnetId: String?
        /// The ID of the virtual private cloud (VPC) used by this DevEndpoint.
        public let vpcId: String?
        /// The type of predefined worker that is allocated to the development endpoint. May be a value of Standard, G.1X, or G.2X.
        public let workerType: WorkerType?
        /// The address of the YARN endpoint used by this DevEndpoint.
        public let yarnEndpointAddress: String?
        /// The Apache Zeppelin port for the remote Apache Spark interpreter.
        public let zeppelinRemoteSparkInterpreterPort: Int?

        public init(arguments: [String: String]? = nil, availabilityZone: String? = nil, createdTimestamp: Date? = nil, endpointName: String? = nil, extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil, failureReason: String? = nil, glueVersion: String? = nil, numberOfNodes: Int? = nil, numberOfWorkers: Int? = nil, roleArn: String? = nil, securityConfiguration: String? = nil, securityGroupIds: [String]? = nil, status: String? = nil, subnetId: String? = nil, vpcId: String? = nil, workerType: WorkerType? = nil, yarnEndpointAddress: String? = nil, zeppelinRemoteSparkInterpreterPort: Int? = nil) {
            self.arguments = arguments
            self.availabilityZone = availabilityZone
            self.createdTimestamp = createdTimestamp
            self.endpointName = endpointName
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.failureReason = failureReason
            self.glueVersion = glueVersion
            self.numberOfNodes = numberOfNodes
            self.numberOfWorkers = numberOfWorkers
            self.roleArn = roleArn
            self.securityConfiguration = securityConfiguration
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetId = subnetId
            self.vpcId = vpcId
            self.workerType = workerType
            self.yarnEndpointAddress = yarnEndpointAddress
            self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case availabilityZone = "AvailabilityZone"
            case createdTimestamp = "CreatedTimestamp"
            case endpointName = "EndpointName"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case failureReason = "FailureReason"
            case glueVersion = "GlueVersion"
            case numberOfNodes = "NumberOfNodes"
            case numberOfWorkers = "NumberOfWorkers"
            case roleArn = "RoleArn"
            case securityConfiguration = "SecurityConfiguration"
            case securityGroupIds = "SecurityGroupIds"
            case status = "Status"
            case subnetId = "SubnetId"
            case vpcId = "VpcId"
            case workerType = "WorkerType"
            case yarnEndpointAddress = "YarnEndpointAddress"
            case zeppelinRemoteSparkInterpreterPort = "ZeppelinRemoteSparkInterpreterPort"
        }
    }

    public struct CreateGrokClassifierRequest: AWSEncodableShape {
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        public let classification: String
        /// Optional custom grok patterns used by this classifier.
        public let customPatterns: String?
        /// The grok pattern used by this classifier.
        public let grokPattern: String
        /// The name of the new classifier.
        public let name: String

        public init(classification: String, customPatterns: String? = nil, grokPattern: String, name: String) {
            self.classification = classification
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.customPatterns, name: "customPatterns", parent: name, max: 16000)
            try self.validate(self.customPatterns, name: "customPatterns", parent: name, min: 0)
            try self.validate(self.customPatterns, name: "customPatterns", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, max: 2048)
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, min: 1)
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case customPatterns = "CustomPatterns"
            case grokPattern = "GrokPattern"
            case name = "Name"
        }
    }

    public struct CreateJobRequest: AWSEncodableShape {
        /// The JobCommand that runs this job.
        public let command: JobCommand
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// The default arguments for this job. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the key-value pairs that Glue consumes to set up your job, see the Special Parameters Used by Glue topic in the developer guide.
        public let defaultArguments: [String: String]?
        /// Description of the job being defined.
        public let description: String?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
        public let glueVersion: String?
        /// This field is reserved for future use.
        public let logUri: String?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.   For Glue version 2.0 jobs, you cannot instead specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers.
        public let maxCapacity: Double?
        /// The maximum number of times to retry this job if it fails.
        public let maxRetries: Int?
        /// The name you assign to this job definition. It must be unique in your account.
        public let name: String
        /// Non-overridable arguments for this job, specified as name-value pairs.
        public let nonOverridableArguments: [String: String]?
        /// Specifies configuration properties of a job notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
        public let numberOfWorkers: Int?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
        public let role: String
        /// The name of the SecurityConfiguration structure to be used with this job.
        public let securityConfiguration: String?
        /// The tags to use with this job. You may use tags to limit access to the job. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
        public let tags: [String: String]?
        /// The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.
        public let workerType: WorkerType?

        public init(command: JobCommand, connections: ConnectionsList? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionProperty: ExecutionProperty? = nil, glueVersion: String? = nil, logUri: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String, nonOverridableArguments: [String: String]? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, role: String, securityConfiguration: String? = nil, tags: [String: String]? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.command = command
            self.connections = connections
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.logUri = logUri
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.tags = tags
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.command.validate(name: "\(name).command")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^\\w+\\.\\w+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.notificationProperty?.validate(name: "\(name).notificationProperty")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case connections = "Connections"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case executionProperty = "ExecutionProperty"
            case glueVersion = "GlueVersion"
            case logUri = "LogUri"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case nonOverridableArguments = "NonOverridableArguments"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case tags = "Tags"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct CreateJobResponse: AWSDecodableShape {
        /// The unique name that was provided for this job definition.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateJsonClassifierRequest: AWSEncodableShape {
        /// A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
        public let jsonPath: String
        /// The name of the classifier.
        public let name: String

        public init(jsonPath: String, name: String) {
            self.jsonPath = jsonPath
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jsonPath = "JsonPath"
            case name = "Name"
        }
    }

    public struct CreateMLTransformRequest: AWSEncodableShape {
        /// A description of the machine learning transform that is being defined. The default is an empty string.
        public let description: String?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see Glue Versions in the developer guide.
        public let glueVersion: String?
        /// A list of Glue table definitions used by the transform.
        public let inputRecordTables: [GlueTable]
        /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.   MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.   If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.   If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.   If WorkerType is set, then NumberOfWorkers is required (and vice versa).    MaxCapacity and NumberOfWorkers must both be at least 1.   When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only. When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
        public let maxCapacity: Double?
        /// The maximum number of times to retry a task for this transform after a task run fails.
        public let maxRetries: Int?
        /// The unique name that you give the transform when you create it.
        public let name: String
        /// The number of workers of a defined workerType that are allocated when this task runs. If WorkerType is set, then NumberOfWorkers is required (and vice versa).
        public let numberOfWorkers: Int?
        /// The algorithmic parameters that are specific to the transform type used. Conditionally dependent on the transform type.
        public let parameters: TransformParameters
        /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform.    This role needs Glue service role permissions to allow access to resources in Glue. See Attach a Policy to IAM Users That Access Glue.   This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.
        public let role: String
        /// The tags to use with this machine learning transform. You may use tags to limit access to the machine learning transform. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
        public let tags: [String: String]?
        /// The timeout of the task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?
        /// The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.
        public let transformEncryption: TransformEncryption?
        /// The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.    MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.   If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.   If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.   If WorkerType is set, then NumberOfWorkers is required (and vice versa).    MaxCapacity and NumberOfWorkers must both be at least 1.
        public let workerType: WorkerType?

        public init(description: String? = nil, glueVersion: String? = nil, inputRecordTables: [GlueTable], maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String, numberOfWorkers: Int? = nil, parameters: TransformParameters, role: String, tags: [String: String]? = nil, timeout: Int? = nil, transformEncryption: TransformEncryption? = nil, workerType: WorkerType? = nil) {
            self.description = description
            self.glueVersion = glueVersion
            self.inputRecordTables = inputRecordTables
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.numberOfWorkers = numberOfWorkers
            self.parameters = parameters
            self.role = role
            self.tags = tags
            self.timeout = timeout
            self.transformEncryption = transformEncryption
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^\\w+\\.\\w+$")
            try self.inputRecordTables.forEach {
                try $0.validate(name: "\(name).inputRecordTables[]")
            }
            try self.validate(self.inputRecordTables, name: "inputRecordTables", parent: name, max: 10)
            try self.validate(self.inputRecordTables, name: "inputRecordTables", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.parameters.validate(name: "\(name).parameters")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
            try self.transformEncryption?.validate(name: "\(name).transformEncryption")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case glueVersion = "GlueVersion"
            case inputRecordTables = "InputRecordTables"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case numberOfWorkers = "NumberOfWorkers"
            case parameters = "Parameters"
            case role = "Role"
            case tags = "Tags"
            case timeout = "Timeout"
            case transformEncryption = "TransformEncryption"
            case workerType = "WorkerType"
        }
    }

    public struct CreateMLTransformResponse: AWSDecodableShape {
        /// A unique identifier that is generated for the transform.
        public let transformId: String?

        public init(transformId: String? = nil) {
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct CreatePartitionIndexRequest: AWSEncodableShape {
        /// The catalog ID where the table resides.
        public let catalogId: String?
        /// Specifies the name of a database in which you want to create a partition index.
        public let databaseName: String
        /// Specifies a PartitionIndex structure to create a partition index in an existing table.
        public let partitionIndex: PartitionIndex
        /// Specifies the name of a table in which you want to create a partition index.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionIndex: PartitionIndex, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionIndex = partitionIndex
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionIndex.validate(name: "\(name).partitionIndex")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionIndex = "PartitionIndex"
            case tableName = "TableName"
        }
    }

    public struct CreatePartitionIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreatePartitionRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the catalog in which the partition is to be created.
        public let catalogId: String?
        /// The name of the metadata database in which the partition is to be created.
        public let databaseName: String
        /// A PartitionInput structure defining the partition to be created.
        public let partitionInput: PartitionInput
        /// The name of the metadata table in which the partition is to be created.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionInput: PartitionInput, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionInput = partitionInput
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionInput.validate(name: "\(name).partitionInput")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionInput = "PartitionInput"
            case tableName = "TableName"
        }
    }

    public struct CreatePartitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateRegistryInput: AWSEncodableShape {
        /// A description of the registry. If description is not provided, there will not be any default value for this.
        public let description: String?
        /// Name of the registry to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark. No whitespace.
        public let registryName: String
        /// Amazon Web Services tags that contain a key value pair and may be searched by console, command line, or API.
        public let tags: [String: String]?

        public init(description: String? = nil, registryName: String, tags: [String: String]? = nil) {
            self.description = description
            self.registryName = registryName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.registryName, name: "registryName", parent: name, max: 255)
            try self.validate(self.registryName, name: "registryName", parent: name, min: 1)
            try self.validate(self.registryName, name: "registryName", parent: name, pattern: "[a-zA-Z0-9-_$#.]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryName = "RegistryName"
            case tags = "Tags"
        }
    }

    public struct CreateRegistryResponse: AWSDecodableShape {
        /// A description of the registry.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the newly created registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// The tags for the registry.
        public let tags: [String: String]?

        public init(description: String? = nil, registryArn: String? = nil, registryName: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case tags = "Tags"
        }
    }

    public struct CreateSchemaInput: AWSEncodableShape {
        /// The compatibility mode of the schema. The possible values are:    NONE: No compatibility mode applies. You can use this choice in development scenarios or if you do not know the compatibility mode that you want to apply to schemas. Any new version added will be accepted without undergoing a compatibility check.    DISABLED: This compatibility choice prevents versioning for a particular schema. You can use this choice to prevent future versioning of a schema.    BACKWARD: This compatibility choice is recommended as it allows data receivers to read both the current and one previous schema version. This means that for instance, a new schema version cannot drop data fields or change the type of these fields, so they can't be read by readers using the previous version.    BACKWARD_ALL: This compatibility choice allows data receivers to read both the current and all previous schema versions. You can use this choice when you need to delete fields or add optional fields, and check compatibility against all previous schema versions.     FORWARD: This compatibility choice allows data receivers to read both the current and one next schema version, but not necessarily later versions. You can use this choice when you need to add fields or delete optional fields, but only check compatibility against the last schema version.    FORWARD_ALL: This compatibility choice allows data receivers to read written by producers of any new registered schema. You can use this choice when you need to add fields or delete optional fields, and check compatibility against all previous schema versions.    FULL: This compatibility choice allows data receivers to read data written by producers using the previous or next version of the schema, but not necessarily earlier or later versions. You can use this choice when you need to add or remove optional fields, but only check compatibility against the last schema version.    FULL_ALL: This compatibility choice allows data receivers to read data written by producers using all previous schema versions. You can use this choice when you need to add or remove optional fields, and check compatibility against all previous schema versions.
        public let compatibility: Compatibility?
        /// The data format of the schema definition. Currently AVRO and JSON are supported.
        public let dataFormat: DataFormat
        /// An optional description of the schema. If description is not provided, there will not be any automatic default value for this.
        public let description: String?
        ///  This is a wrapper shape to contain the registry identity fields. If this is not provided, the default registry will be used. The ARN format for the same will be: arn:aws:glue:us-east-2:&lt;customer id&gt;:registry/default-registry:random-5-letter-id.
        public let registryId: RegistryId?
        /// The schema definition using the DataFormat setting for SchemaName.
        public let schemaDefinition: String?
        /// Name of the schema to be created of max length of 255, and may only contain letters, numbers, hyphen, underscore, dollar sign, or hash mark. No whitespace.
        public let schemaName: String
        /// Amazon Web Services tags that contain a key value pair and may be searched by console, command line, or API. If specified, follows the Amazon Web Services tags-on-create pattern.
        public let tags: [String: String]?

        public init(compatibility: Compatibility? = nil, dataFormat: DataFormat, description: String? = nil, registryId: RegistryId? = nil, schemaDefinition: String? = nil, schemaName: String, tags: [String: String]? = nil) {
            self.compatibility = compatibility
            self.dataFormat = dataFormat
            self.description = description
            self.registryId = registryId
            self.schemaDefinition = schemaDefinition
            self.schemaName = schemaName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.registryId?.validate(name: "\(name).registryId")
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, max: 170_000)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, min: 1)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, pattern: ".*\\S.*")
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "[a-zA-Z0-9-_$#.]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case compatibility = "Compatibility"
            case dataFormat = "DataFormat"
            case description = "Description"
            case registryId = "RegistryId"
            case schemaDefinition = "SchemaDefinition"
            case schemaName = "SchemaName"
            case tags = "Tags"
        }
    }

    public struct CreateSchemaResponse: AWSDecodableShape {
        /// The schema compatibility mode.
        public let compatibility: Compatibility?
        /// The data format of the schema definition. Currently AVRO and JSON are supported.
        public let dataFormat: DataFormat?
        /// A description of the schema if specified when created.
        public let description: String?
        /// The latest version of the schema associated with the returned schema definition.
        public let latestSchemaVersion: Int64?
        /// The next version of the schema associated with the returned schema definition.
        public let nextSchemaVersion: Int64?
        /// The Amazon Resource Name (ARN) of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The version number of the checkpoint (the last time the compatibility mode was changed).
        public let schemaCheckpoint: Int64?
        /// The name of the schema.
        public let schemaName: String?
        /// The status of the schema.
        public let schemaStatus: SchemaStatus?
        /// The unique identifier of the first schema version.
        public let schemaVersionId: String?
        /// The status of the first schema version created.
        public let schemaVersionStatus: SchemaVersionStatus?
        /// The tags for the schema.
        public let tags: [String: String]?

        public init(compatibility: Compatibility? = nil, dataFormat: DataFormat? = nil, description: String? = nil, latestSchemaVersion: Int64? = nil, nextSchemaVersion: Int64? = nil, registryArn: String? = nil, registryName: String? = nil, schemaArn: String? = nil, schemaCheckpoint: Int64? = nil, schemaName: String? = nil, schemaStatus: SchemaStatus? = nil, schemaVersionId: String? = nil, schemaVersionStatus: SchemaVersionStatus? = nil, tags: [String: String]? = nil) {
            self.compatibility = compatibility
            self.dataFormat = dataFormat
            self.description = description
            self.latestSchemaVersion = latestSchemaVersion
            self.nextSchemaVersion = nextSchemaVersion
            self.registryArn = registryArn
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaCheckpoint = schemaCheckpoint
            self.schemaName = schemaName
            self.schemaStatus = schemaStatus
            self.schemaVersionId = schemaVersionId
            self.schemaVersionStatus = schemaVersionStatus
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case compatibility = "Compatibility"
            case dataFormat = "DataFormat"
            case description = "Description"
            case latestSchemaVersion = "LatestSchemaVersion"
            case nextSchemaVersion = "NextSchemaVersion"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaCheckpoint = "SchemaCheckpoint"
            case schemaName = "SchemaName"
            case schemaStatus = "SchemaStatus"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionStatus = "SchemaVersionStatus"
            case tags = "Tags"
        }
    }

    public struct CreateScriptRequest: AWSEncodableShape {
        /// A list of the edges in the DAG.
        public let dagEdges: [CodeGenEdge]?
        /// A list of the nodes in the DAG.
        public let dagNodes: [CodeGenNode]?
        /// The programming language of the resulting code from the DAG.
        public let language: Language?

        public init(dagEdges: [CodeGenEdge]? = nil, dagNodes: [CodeGenNode]? = nil, language: Language? = nil) {
            self.dagEdges = dagEdges
            self.dagNodes = dagNodes
            self.language = language
        }

        public func validate(name: String) throws {
            try self.dagEdges?.forEach {
                try $0.validate(name: "\(name).dagEdges[]")
            }
            try self.dagNodes?.forEach {
                try $0.validate(name: "\(name).dagNodes[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dagEdges = "DagEdges"
            case dagNodes = "DagNodes"
            case language = "Language"
        }
    }

    public struct CreateScriptResponse: AWSDecodableShape {
        /// The Python script generated from the DAG.
        public let pythonScript: String?
        /// The Scala code generated from the DAG.
        public let scalaCode: String?

        public init(pythonScript: String? = nil, scalaCode: String? = nil) {
            self.pythonScript = pythonScript
            self.scalaCode = scalaCode
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
            case scalaCode = "ScalaCode"
        }
    }

    public struct CreateSecurityConfigurationRequest: AWSEncodableShape {
        /// The encryption configuration for the new security configuration.
        public let encryptionConfiguration: EncryptionConfiguration
        /// The name for the new security configuration.
        public let name: String

        public init(encryptionConfiguration: EncryptionConfiguration, name: String) {
            self.encryptionConfiguration = encryptionConfiguration
            self.name = name
        }

        public func validate(name: String) throws {
            try self.encryptionConfiguration.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "EncryptionConfiguration"
            case name = "Name"
        }
    }

    public struct CreateSecurityConfigurationResponse: AWSDecodableShape {
        /// The time at which the new security configuration was created.
        public let createdTimestamp: Date?
        /// The name assigned to the new security configuration.
        public let name: String?

        public init(createdTimestamp: Date? = nil, name: String? = nil) {
            self.createdTimestamp = createdTimestamp
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case name = "Name"
        }
    }

    public struct CreateTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which to create the Table. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The catalog database in which to create the new table. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// A list of partition indexes, PartitionIndex structures, to create in the table.
        public let partitionIndexes: [PartitionIndex]?
        /// The TableInput object that defines the metadata table to create in the catalog.
        public let tableInput: TableInput

        public init(catalogId: String? = nil, databaseName: String, partitionIndexes: [PartitionIndex]? = nil, tableInput: TableInput) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionIndexes = partitionIndexes
            self.tableInput = tableInput
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionIndexes?.forEach {
                try $0.validate(name: "\(name).partitionIndexes[]")
            }
            try self.validate(self.partitionIndexes, name: "partitionIndexes", parent: name, max: 3)
            try self.tableInput.validate(name: "\(name).tableInput")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionIndexes = "PartitionIndexes"
            case tableInput = "TableInput"
        }
    }

    public struct CreateTableResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateTriggerRequest: AWSEncodableShape {
        /// The actions initiated by this trigger when it fires.
        public let actions: [Action]
        /// A description of the new trigger.
        public let description: String?
        public let eventBatchingCondition: EventBatchingCondition?
        /// The name of the trigger.
        public let name: String
        /// A predicate to specify when the new trigger should fire. This field is required when the trigger type is CONDITIONAL.
        public let predicate: Predicate?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *). This field is required when the trigger type is SCHEDULED.
        public let schedule: String?
        /// Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
        public let startOnCreation: Bool?
        /// The tags to use with this trigger. You may use tags to limit access to the trigger. For more information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.
        public let tags: [String: String]?
        /// The type of the new trigger.
        public let type: TriggerType
        /// The name of the workflow associated with the trigger.
        public let workflowName: String?

        public init(actions: [Action], description: String? = nil, eventBatchingCondition: EventBatchingCondition? = nil, name: String, predicate: Predicate? = nil, schedule: String? = nil, startOnCreation: Bool? = nil, tags: [String: String]? = nil, type: TriggerType, workflowName: String? = nil) {
            self.actions = actions
            self.description = description
            self.eventBatchingCondition = eventBatchingCondition
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
            self.startOnCreation = startOnCreation
            self.tags = tags
            self.type = type
            self.workflowName = workflowName
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.eventBatchingCondition?.validate(name: "\(name).eventBatchingCondition")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.predicate?.validate(name: "\(name).predicate")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
            try self.validate(self.workflowName, name: "workflowName", parent: name, max: 255)
            try self.validate(self.workflowName, name: "workflowName", parent: name, min: 1)
            try self.validate(self.workflowName, name: "workflowName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case eventBatchingCondition = "EventBatchingCondition"
            case name = "Name"
            case predicate = "Predicate"
            case schedule = "Schedule"
            case startOnCreation = "StartOnCreation"
            case tags = "Tags"
            case type = "Type"
            case workflowName = "WorkflowName"
        }
    }

    public struct CreateTriggerResponse: AWSDecodableShape {
        /// The name of the trigger.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateUserDefinedFunctionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which to create the function. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which to create the function.
        public let databaseName: String
        /// A FunctionInput object that defines the function to create in the Data Catalog.
        public let functionInput: UserDefinedFunctionInput

        public init(catalogId: String? = nil, databaseName: String, functionInput: UserDefinedFunctionInput) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionInput = functionInput
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.functionInput.validate(name: "\(name).functionInput")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionInput = "FunctionInput"
        }
    }

    public struct CreateUserDefinedFunctionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateWorkflowRequest: AWSEncodableShape {
        /// A collection of properties to be used as part of each execution of the workflow.
        public let defaultRunProperties: [String: String]?
        /// A description of the workflow.
        public let description: String?
        /// You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
        public let maxConcurrentRuns: Int?
        /// The name to be assigned to the workflow. It should be unique within your account.
        public let name: String
        /// The tags to be used with this workflow.
        public let tags: [String: String]?

        public init(defaultRunProperties: [String: String]? = nil, description: String? = nil, maxConcurrentRuns: Int? = nil, name: String, tags: [String: String]? = nil) {
            self.defaultRunProperties = defaultRunProperties
            self.description = description
            self.maxConcurrentRuns = maxConcurrentRuns
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.defaultRunProperties?.forEach {
                try validate($0.key, name: "defaultRunProperties.key", parent: name, max: 255)
                try validate($0.key, name: "defaultRunProperties.key", parent: name, min: 1)
                try validate($0.key, name: "defaultRunProperties.key", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case defaultRunProperties = "DefaultRunProperties"
            case description = "Description"
            case maxConcurrentRuns = "MaxConcurrentRuns"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateWorkflowResponse: AWSDecodableShape {
        /// The name of the workflow which was provided as part of the request.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateXMLClassifierRequest: AWSEncodableShape {
        /// An identifier of the data format that the classifier matches.
        public let classification: String
        /// The name of the classifier.
        public let name: String
        /// The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by /&gt;). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, &lt;row item_a="A" item_b="B"&gt;&lt;/row&gt; is okay, but &lt;row item_a="A" item_b="B" /&gt; is not).
        public let rowTag: String?

        public init(classification: String, name: String, rowTag: String? = nil) {
            self.classification = classification
            self.name = name
            self.rowTag = rowTag
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case name = "Name"
            case rowTag = "RowTag"
        }
    }

    public struct CsvClassifier: AWSDecodableShape {
        /// Enables the processing of files that contain only one column.
        public let allowSingleColumn: Bool?
        /// Indicates whether the CSV file contains a header.
        public let containsHeader: CsvHeaderOption?
        /// The time that this classifier was registered.
        public let creationTime: Date?
        /// A custom symbol to denote what separates each column entry in the row.
        public let delimiter: String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public let disableValueTrimming: Bool?
        /// A list of strings representing column names.
        public let header: [String]?
        /// The time that this classifier was last updated.
        public let lastUpdated: Date?
        /// The name of the classifier.
        public let name: String
        /// A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        public let quoteSymbol: String?
        /// The version of this classifier.
        public let version: Int64?

        public init(allowSingleColumn: Bool? = nil, containsHeader: CsvHeaderOption? = nil, creationTime: Date? = nil, delimiter: String? = nil, disableValueTrimming: Bool? = nil, header: [String]? = nil, lastUpdated: Date? = nil, name: String, quoteSymbol: String? = nil, version: Int64? = nil) {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.creationTime = creationTime
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.lastUpdated = lastUpdated
            self.name = name
            self.quoteSymbol = quoteSymbol
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case allowSingleColumn = "AllowSingleColumn"
            case containsHeader = "ContainsHeader"
            case creationTime = "CreationTime"
            case delimiter = "Delimiter"
            case disableValueTrimming = "DisableValueTrimming"
            case header = "Header"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case quoteSymbol = "QuoteSymbol"
            case version = "Version"
        }
    }

    public struct DataCatalogEncryptionSettings: AWSEncodableShape & AWSDecodableShape {
        /// When connection password protection is enabled, the Data Catalog uses a customer-provided key to encrypt the password as part of CreateConnection or UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only password encryption.
        public let connectionPasswordEncryption: ConnectionPasswordEncryption?
        /// Specifies the encryption-at-rest configuration for the Data Catalog.
        public let encryptionAtRest: EncryptionAtRest?

        public init(connectionPasswordEncryption: ConnectionPasswordEncryption? = nil, encryptionAtRest: EncryptionAtRest? = nil) {
            self.connectionPasswordEncryption = connectionPasswordEncryption
            self.encryptionAtRest = encryptionAtRest
        }

        public func validate(name: String) throws {
            try self.connectionPasswordEncryption?.validate(name: "\(name).connectionPasswordEncryption")
            try self.encryptionAtRest?.validate(name: "\(name).encryptionAtRest")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionPasswordEncryption = "ConnectionPasswordEncryption"
            case encryptionAtRest = "EncryptionAtRest"
        }
    }

    public struct DataLakePrincipal: AWSEncodableShape & AWSDecodableShape {
        /// An identifier for the Lake Formation principal.
        public let dataLakePrincipalIdentifier: String?

        public init(dataLakePrincipalIdentifier: String? = nil) {
            self.dataLakePrincipalIdentifier = dataLakePrincipalIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.dataLakePrincipalIdentifier, name: "dataLakePrincipalIdentifier", parent: name, max: 255)
            try self.validate(self.dataLakePrincipalIdentifier, name: "dataLakePrincipalIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataLakePrincipalIdentifier = "DataLakePrincipalIdentifier"
        }
    }

    public struct Database: AWSDecodableShape {
        /// The ID of the Data Catalog in which the database resides.
        public let catalogId: String?
        /// Creates a set of default permissions on the table for principals.
        public let createTableDefaultPermissions: [PrincipalPermissions]?
        /// The time at which the metadata database was created in the catalog.
        public let createTime: Date?
        /// A description of the database.
        public let description: String?
        /// The location of the database (for example, an HDFS path).
        public let locationUri: String?
        /// The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
        public let name: String
        /// These key-value pairs define parameters and properties of the database.
        public let parameters: [String: String]?
        /// A DatabaseIdentifier structure that describes a target database for resource linking.
        public let targetDatabase: DatabaseIdentifier?

        public init(catalogId: String? = nil, createTableDefaultPermissions: [PrincipalPermissions]? = nil, createTime: Date? = nil, description: String? = nil, locationUri: String? = nil, name: String, parameters: [String: String]? = nil, targetDatabase: DatabaseIdentifier? = nil) {
            self.catalogId = catalogId
            self.createTableDefaultPermissions = createTableDefaultPermissions
            self.createTime = createTime
            self.description = description
            self.locationUri = locationUri
            self.name = name
            self.parameters = parameters
            self.targetDatabase = targetDatabase
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case createTableDefaultPermissions = "CreateTableDefaultPermissions"
            case createTime = "CreateTime"
            case description = "Description"
            case locationUri = "LocationUri"
            case name = "Name"
            case parameters = "Parameters"
            case targetDatabase = "TargetDatabase"
        }
    }

    public struct DatabaseIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the Data Catalog in which the database resides.
        public let catalogId: String?
        /// The name of the catalog database.
        public let databaseName: String?

        public init(catalogId: String? = nil, databaseName: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
        }
    }

    public struct DatabaseInput: AWSEncodableShape {
        /// Creates a set of default permissions on the table for principals.
        public let createTableDefaultPermissions: [PrincipalPermissions]?
        /// A description of the database.
        public let description: String?
        /// The location of the database (for example, an HDFS path).
        public let locationUri: String?
        /// The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
        public let name: String
        /// These key-value pairs define parameters and properties of the database. These key-value pairs define parameters and properties of the database.
        public let parameters: [String: String]?
        /// A DatabaseIdentifier structure that describes a target database for resource linking.
        public let targetDatabase: DatabaseIdentifier?

        public init(createTableDefaultPermissions: [PrincipalPermissions]? = nil, description: String? = nil, locationUri: String? = nil, name: String, parameters: [String: String]? = nil, targetDatabase: DatabaseIdentifier? = nil) {
            self.createTableDefaultPermissions = createTableDefaultPermissions
            self.description = description
            self.locationUri = locationUri
            self.name = name
            self.parameters = parameters
            self.targetDatabase = targetDatabase
        }

        public func validate(name: String) throws {
            try self.createTableDefaultPermissions?.forEach {
                try $0.validate(name: "\(name).createTableDefaultPermissions[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.locationUri, name: "locationUri", parent: name, max: 1024)
            try self.validate(self.locationUri, name: "locationUri", parent: name, min: 1)
            try self.validate(self.locationUri, name: "locationUri", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512_000)
            }
            try self.targetDatabase?.validate(name: "\(name).targetDatabase")
        }

        private enum CodingKeys: String, CodingKey {
            case createTableDefaultPermissions = "CreateTableDefaultPermissions"
            case description = "Description"
            case locationUri = "LocationUri"
            case name = "Name"
            case parameters = "Parameters"
            case targetDatabase = "TargetDatabase"
        }
    }

    public struct DateColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The highest value in the column.
        public let maximumValue: Date?
        /// The lowest value in the column.
        public let minimumValue: Date?
        /// The number of distinct values in a column.
        public let numberOfDistinctValues: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        public init(maximumValue: Date? = nil, minimumValue: Date? = nil, numberOfDistinctValues: Int64, numberOfNulls: Int64) {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDistinctValues, name: "numberOfDistinctValues", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case numberOfDistinctValues = "NumberOfDistinctValues"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct DecimalColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The highest value in the column.
        public let maximumValue: DecimalNumber?
        /// The lowest value in the column.
        public let minimumValue: DecimalNumber?
        /// The number of distinct values in a column.
        public let numberOfDistinctValues: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        public init(maximumValue: DecimalNumber? = nil, minimumValue: DecimalNumber? = nil, numberOfDistinctValues: Int64, numberOfNulls: Int64) {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDistinctValues, name: "numberOfDistinctValues", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case numberOfDistinctValues = "NumberOfDistinctValues"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct DecimalNumber: AWSEncodableShape & AWSDecodableShape {
        /// The scale that determines where the decimal point falls in the unscaled value.
        public let scale: Int
        /// The unscaled numeric value.
        public let unscaledValue: Data

        public init(scale: Int, unscaledValue: Data) {
            self.scale = scale
            self.unscaledValue = unscaledValue
        }

        private enum CodingKeys: String, CodingKey {
            case scale = "Scale"
            case unscaledValue = "UnscaledValue"
        }
    }

    public struct DeleteClassifierRequest: AWSEncodableShape {
        /// Name of the classifier to remove.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteClassifierResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteColumnStatisticsForPartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// Name of the column.
        public let columnName: String
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// A list of partition values identifying the partition.
        public let partitionValues: [String]
        /// The name of the partitions' table.
        public let tableName: String

        public init(catalogId: String? = nil, columnName: String, databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.columnName = columnName
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.columnName, name: "columnName", parent: name, max: 255)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
            }
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnName = "ColumnName"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct DeleteColumnStatisticsForPartitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteColumnStatisticsForTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the column.
        public let columnName: String
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// The name of the partitions' table.
        public let tableName: String

        public init(catalogId: String? = nil, columnName: String, databaseName: String, tableName: String) {
            self.catalogId = catalogId
            self.columnName = columnName
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.columnName, name: "columnName", parent: name, max: 255)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnName = "ColumnName"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct DeleteColumnStatisticsForTableResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConnectionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the connection to delete.
        public let connectionName: String

        public init(catalogId: String? = nil, connectionName: String) {
            self.catalogId = catalogId
            self.connectionName = connectionName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 255)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionName = "ConnectionName"
        }
    }

    public struct DeleteConnectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCrawlerRequest: AWSEncodableShape {
        /// The name of the crawler to remove.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteCrawlerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDatabaseRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the database to delete. For Hive compatibility, this must be all lowercase.
        public let name: String

        public init(catalogId: String? = nil, name: String) {
            self.catalogId = catalogId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
        }
    }

    public struct DeleteDatabaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDevEndpointRequest: AWSEncodableShape {
        /// The name of the DevEndpoint.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct DeleteDevEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteJobRequest: AWSEncodableShape {
        /// The name of the job definition to delete.
        public let jobName: String

        public init(jobName: String) {
            self.jobName = jobName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct DeleteJobResponse: AWSDecodableShape {
        /// The name of the job definition that was deleted.
        public let jobName: String?

        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct DeleteMLTransformRequest: AWSEncodableShape {
        /// The unique identifier of the transform to delete.
        public let transformId: String

        public init(transformId: String) {
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct DeleteMLTransformResponse: AWSDecodableShape {
        /// The unique identifier of the transform that was deleted.
        public let transformId: String?

        public init(transformId: String? = nil) {
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct DeletePartitionIndexRequest: AWSEncodableShape {
        /// The catalog ID where the table resides.
        public let catalogId: String?
        /// Specifies the name of a database from which you want to delete a partition index.
        public let databaseName: String
        /// The name of the partition index to be deleted.
        public let indexName: String
        /// Specifies the name of a table from which you want to delete a partition index.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, indexName: String, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.indexName = indexName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.indexName, name: "indexName", parent: name, max: 255)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case indexName = "IndexName"
            case tableName = "TableName"
        }
    }

    public struct DeletePartitionIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partition to be deleted resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String
        /// The values that define the partition.
        public let partitionValues: [String]
        /// The name of the table that contains the partition to be deleted.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
            }
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct DeletePartitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRegistryInput: AWSEncodableShape {
        /// This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
        public let registryId: RegistryId

        public init(registryId: RegistryId) {
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.registryId.validate(name: "\(name).registryId")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "RegistryId"
        }
    }

    public struct DeleteRegistryResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the registry being deleted.
        public let registryArn: String?
        /// The name of the registry being deleted.
        public let registryName: String?
        /// The status of the registry. A successful operation will return the Deleting status.
        public let status: RegistryStatus?

        public init(registryArn: String? = nil, registryName: String? = nil, status: RegistryStatus? = nil) {
            self.registryArn = registryArn
            self.registryName = registryName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case status = "Status"
        }
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The hash value returned when this policy was set.
        public let policyHashCondition: String?
        /// The ARN of the Glue resource for the resource policy to be deleted.
        public let resourceArn: String?

        public init(policyHashCondition: String? = nil, resourceArn: String? = nil) {
            self.policyHashCondition = policyHashCondition
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, max: 255)
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, min: 1)
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws:glue:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case policyHashCondition = "PolicyHashCondition"
            case resourceArn = "ResourceArn"
        }
    }

    public struct DeleteResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSchemaInput: AWSEncodableShape {
        /// This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
        public let schemaId: SchemaId

        public init(schemaId: SchemaId) {
            self.schemaId = schemaId
        }

        public func validate(name: String) throws {
            try self.schemaId.validate(name: "\(name).schemaId")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaId = "SchemaId"
        }
    }

    public struct DeleteSchemaResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the schema being deleted.
        public let schemaArn: String?
        /// The name of the schema being deleted.
        public let schemaName: String?
        /// The status of the schema.
        public let status: SchemaStatus?

        public init(schemaArn: String? = nil, schemaName: String? = nil, status: SchemaStatus? = nil) {
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case status = "Status"
        }
    }

    public struct DeleteSchemaVersionsInput: AWSEncodableShape {
        /// This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
        public let schemaId: SchemaId
        /// A version range may be supplied which may be of the format:   a single version number, 5   a range, 5-8 : deletes versions 5, 6, 7, 8
        public let versions: String

        public init(schemaId: SchemaId, versions: String) {
            self.schemaId = schemaId
            self.versions = versions
        }

        public func validate(name: String) throws {
            try self.schemaId.validate(name: "\(name).schemaId")
            try self.validate(self.versions, name: "versions", parent: name, max: 100_000)
            try self.validate(self.versions, name: "versions", parent: name, min: 1)
            try self.validate(self.versions, name: "versions", parent: name, pattern: "[1-9][0-9]*|[1-9][0-9]*-[1-9][0-9]*")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaId = "SchemaId"
            case versions = "Versions"
        }
    }

    public struct DeleteSchemaVersionsResponse: AWSDecodableShape {
        /// A list of SchemaVersionErrorItem objects, each containing an error and schema version.
        public let schemaVersionErrors: [SchemaVersionErrorItem]?

        public init(schemaVersionErrors: [SchemaVersionErrorItem]? = nil) {
            self.schemaVersionErrors = schemaVersionErrors
        }

        private enum CodingKeys: String, CodingKey {
            case schemaVersionErrors = "SchemaVersionErrors"
        }
    }

    public struct DeleteSecurityConfigurationRequest: AWSEncodableShape {
        /// The name of the security configuration to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteSecurityConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table to be deleted. For Hive compatibility, this name is entirely lowercase.
        public let name: String

        public init(catalogId: String? = nil, databaseName: String, name: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case name = "Name"
        }
    }

    public struct DeleteTableResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTableVersionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table. For Hive compatibility, this name is entirely lowercase.
        public let tableName: String
        /// The ID of the table version to be deleted. A VersionID is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String

        public init(catalogId: String? = nil, databaseName: String, tableName: String, versionId: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 255)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case versionId = "VersionId"
        }
    }

    public struct DeleteTableVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTriggerRequest: AWSEncodableShape {
        /// The name of the trigger to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteTriggerResponse: AWSDecodableShape {
        /// The name of the trigger that was deleted.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteUserDefinedFunctionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the function to be deleted is located. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the function is located.
        public let databaseName: String
        /// The name of the function definition to be deleted.
        public let functionName: String

        public init(catalogId: String? = nil, databaseName: String, functionName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 255)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionName = "FunctionName"
        }
    }

    public struct DeleteUserDefinedFunctionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorkflowRequest: AWSEncodableShape {
        /// Name of the workflow to be deleted.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DeleteWorkflowResponse: AWSDecodableShape {
        /// Name of the workflow specified in input.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct DevEndpoint: AWSDecodableShape {
        /// A map of arguments used to configure the DevEndpoint. Valid arguments are:    "--enable-glue-datacatalog": ""    You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public let arguments: [String: String]?
        /// The AWS Availability Zone where this DevEndpoint is located.
        public let availabilityZone: String?
        /// The point in time at which this DevEndpoint was created.
        public let createdTimestamp: Date?
        /// The name of the DevEndpoint.
        public let endpointName: String?
        /// The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint.  You can only use pure Java/Scala libraries with a DevEndpoint.
        public let extraJarsS3Path: String?
        /// The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma.  You can only use pure Python libraries with a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not currently supported.
        public let extraPythonLibsS3Path: String?
        /// The reason for a current failure in this DevEndpoint.
        public let failureReason: String?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for running your ETL scripts on development endpoints.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Development endpoints that are created without specifying a Glue version default to Glue 0.9. You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public let glueVersion: String?
        /// The point in time at which this DevEndpoint was last modified.
        public let lastModifiedTimestamp: Date?
        /// The status of the last update.
        public let lastUpdateStatus: String?
        /// The number of Glue Data Processing Units (DPUs) allocated to this DevEndpoint.
        public let numberOfNodes: Int?
        /// The number of workers of a defined workerType that are allocated to the development endpoint. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
        public let numberOfWorkers: Int?
        /// A private IP address to access the DevEndpoint within a VPC if the DevEndpoint is created within one. The PrivateAddress field is present only when you create the DevEndpoint within your VPC.
        public let privateAddress: String?
        /// The public IP address used by this DevEndpoint. The PublicAddress field is present only when you create a non-virtual private cloud (VPC) DevEndpoint.
        public let publicAddress: String?
        /// The public key to be used by this DevEndpoint for authentication. This attribute is provided for backward compatibility because the recommended attribute to use is public keys.
        public let publicKey: String?
        /// A list of public keys to be used by the DevEndpoints for authentication. Using this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.  If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys. Call the UpdateDevEndpoint API operation with the public key content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys attribute.
        public let publicKeys: [String]?
        /// The Amazon Resource Name (ARN) of the IAM role used in this DevEndpoint.
        public let roleArn: String?
        /// The name of the SecurityConfiguration structure to be used with this DevEndpoint.
        public let securityConfiguration: String?
        /// A list of security group identifiers used in this DevEndpoint.
        public let securityGroupIds: [String]?
        /// The current status of this DevEndpoint.
        public let status: String?
        /// The subnet ID for this DevEndpoint.
        public let subnetId: String?
        /// The ID of the virtual private cloud (VPC) used by this DevEndpoint.
        public let vpcId: String?
        /// The type of predefined worker that is allocated to the development endpoint. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   Known issue: when a development endpoint is created with the G.2X WorkerType configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk.
        public let workerType: WorkerType?
        /// The YARN endpoint address used by this DevEndpoint.
        public let yarnEndpointAddress: String?
        /// The Apache Zeppelin port for the remote Apache Spark interpreter.
        public let zeppelinRemoteSparkInterpreterPort: Int?

        public init(arguments: [String: String]? = nil, availabilityZone: String? = nil, createdTimestamp: Date? = nil, endpointName: String? = nil, extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil, failureReason: String? = nil, glueVersion: String? = nil, lastModifiedTimestamp: Date? = nil, lastUpdateStatus: String? = nil, numberOfNodes: Int? = nil, numberOfWorkers: Int? = nil, privateAddress: String? = nil, publicAddress: String? = nil, publicKey: String? = nil, publicKeys: [String]? = nil, roleArn: String? = nil, securityConfiguration: String? = nil, securityGroupIds: [String]? = nil, status: String? = nil, subnetId: String? = nil, vpcId: String? = nil, workerType: WorkerType? = nil, yarnEndpointAddress: String? = nil, zeppelinRemoteSparkInterpreterPort: Int? = nil) {
            self.arguments = arguments
            self.availabilityZone = availabilityZone
            self.createdTimestamp = createdTimestamp
            self.endpointName = endpointName
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
            self.failureReason = failureReason
            self.glueVersion = glueVersion
            self.lastModifiedTimestamp = lastModifiedTimestamp
            self.lastUpdateStatus = lastUpdateStatus
            self.numberOfNodes = numberOfNodes
            self.numberOfWorkers = numberOfWorkers
            self.privateAddress = privateAddress
            self.publicAddress = publicAddress
            self.publicKey = publicKey
            self.publicKeys = publicKeys
            self.roleArn = roleArn
            self.securityConfiguration = securityConfiguration
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetId = subnetId
            self.vpcId = vpcId
            self.workerType = workerType
            self.yarnEndpointAddress = yarnEndpointAddress
            self.zeppelinRemoteSparkInterpreterPort = zeppelinRemoteSparkInterpreterPort
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case availabilityZone = "AvailabilityZone"
            case createdTimestamp = "CreatedTimestamp"
            case endpointName = "EndpointName"
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
            case failureReason = "FailureReason"
            case glueVersion = "GlueVersion"
            case lastModifiedTimestamp = "LastModifiedTimestamp"
            case lastUpdateStatus = "LastUpdateStatus"
            case numberOfNodes = "NumberOfNodes"
            case numberOfWorkers = "NumberOfWorkers"
            case privateAddress = "PrivateAddress"
            case publicAddress = "PublicAddress"
            case publicKey = "PublicKey"
            case publicKeys = "PublicKeys"
            case roleArn = "RoleArn"
            case securityConfiguration = "SecurityConfiguration"
            case securityGroupIds = "SecurityGroupIds"
            case status = "Status"
            case subnetId = "SubnetId"
            case vpcId = "VpcId"
            case workerType = "WorkerType"
            case yarnEndpointAddress = "YarnEndpointAddress"
            case zeppelinRemoteSparkInterpreterPort = "ZeppelinRemoteSparkInterpreterPort"
        }
    }

    public struct DevEndpointCustomLibraries: AWSEncodableShape {
        /// The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint.  You can only use pure Java/Scala libraries with a DevEndpoint.
        public let extraJarsS3Path: String?
        /// The paths to one or more Python libraries in an Amazon Simple Storage Service (Amazon S3) bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma.  You can only use pure Python libraries with a DevEndpoint. Libraries that rely on C extensions, such as the pandas Python data analysis library, are not currently supported.
        public let extraPythonLibsS3Path: String?

        public init(extraJarsS3Path: String? = nil, extraPythonLibsS3Path: String? = nil) {
            self.extraJarsS3Path = extraJarsS3Path
            self.extraPythonLibsS3Path = extraPythonLibsS3Path
        }

        private enum CodingKeys: String, CodingKey {
            case extraJarsS3Path = "ExtraJarsS3Path"
            case extraPythonLibsS3Path = "ExtraPythonLibsS3Path"
        }
    }

    public struct DoubleColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The highest value in the column.
        public let maximumValue: Double?
        /// The lowest value in the column.
        public let minimumValue: Double?
        /// The number of distinct values in a column.
        public let numberOfDistinctValues: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        public init(maximumValue: Double? = nil, minimumValue: Double? = nil, numberOfDistinctValues: Int64, numberOfNulls: Int64) {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDistinctValues, name: "numberOfDistinctValues", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case numberOfDistinctValues = "NumberOfDistinctValues"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct DynamoDBTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the DynamoDB table to crawl.
        public let path: String?
        /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table. A value of true means to scan all records, while a value of false means to sample the records. If no value is specified, the value defaults to true.
        public let scanAll: Bool?
        /// The percentage of the configured read capacity units to use by the Glue crawler. Read capacity units is a term defined by DynamoDB, and is a numeric value that acts as rate limiter for the number of reads that can be performed on that table per second. The valid values are null or a value between 0.1 to 1.5. A null value is used when user does not provide a value, and defaults to 0.5 of the configured Read Capacity Unit (for provisioned tables), or 0.25 of the max configured Read Capacity Unit (for tables using on-demand mode).
        public let scanRate: Double?

        public init(path: String? = nil, scanAll: Bool? = nil, scanRate: Double? = nil) {
            self.path = path
            self.scanAll = scanAll
            self.scanRate = scanRate
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
            case scanAll
            case scanRate
        }
    }

    public struct Edge: AWSDecodableShape {
        /// The unique of the node within the workflow where the edge ends.
        public let destinationId: String?
        /// The unique of the node within the workflow where the edge starts.
        public let sourceId: String?

        public init(destinationId: String? = nil, sourceId: String? = nil) {
            self.destinationId = destinationId
            self.sourceId = sourceId
        }

        private enum CodingKeys: String, CodingKey {
            case destinationId = "DestinationId"
            case sourceId = "SourceId"
        }
    }

    public struct EncryptionAtRest: AWSEncodableShape & AWSDecodableShape {
        /// The encryption-at-rest mode for encrypting Data Catalog data.
        public let catalogEncryptionMode: CatalogEncryptionMode
        /// The ID of the KMS key to use for encryption at rest.
        public let sseAwsKmsKeyId: String?

        public init(catalogEncryptionMode: CatalogEncryptionMode, sseAwsKmsKeyId: String? = nil) {
            self.catalogEncryptionMode = catalogEncryptionMode
            self.sseAwsKmsKeyId = sseAwsKmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.sseAwsKmsKeyId, name: "sseAwsKmsKeyId", parent: name, max: 255)
            try self.validate(self.sseAwsKmsKeyId, name: "sseAwsKmsKeyId", parent: name, min: 1)
            try self.validate(self.sseAwsKmsKeyId, name: "sseAwsKmsKeyId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogEncryptionMode = "CatalogEncryptionMode"
            case sseAwsKmsKeyId = "SseAwsKmsKeyId"
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The encryption configuration for Amazon CloudWatch.
        public let cloudWatchEncryption: CloudWatchEncryption?
        /// The encryption configuration for job bookmarks.
        public let jobBookmarksEncryption: JobBookmarksEncryption?
        /// The encryption configuration for Amazon Simple Storage Service (Amazon S3) data.
        public let s3Encryption: [S3Encryption]?

        public init(cloudWatchEncryption: CloudWatchEncryption? = nil, jobBookmarksEncryption: JobBookmarksEncryption? = nil, s3Encryption: [S3Encryption]? = nil) {
            self.cloudWatchEncryption = cloudWatchEncryption
            self.jobBookmarksEncryption = jobBookmarksEncryption
            self.s3Encryption = s3Encryption
        }

        public func validate(name: String) throws {
            try self.cloudWatchEncryption?.validate(name: "\(name).cloudWatchEncryption")
            try self.jobBookmarksEncryption?.validate(name: "\(name).jobBookmarksEncryption")
            try self.s3Encryption?.forEach {
                try $0.validate(name: "\(name).s3Encryption[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchEncryption = "CloudWatchEncryption"
            case jobBookmarksEncryption = "JobBookmarksEncryption"
            case s3Encryption = "S3Encryption"
        }
    }

    public struct ErrorDetail: AWSDecodableShape {
        /// The code associated with this error.
        public let errorCode: String?
        /// A message describing the error.
        public let errorMessage: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// The error code for an error.
        public let errorCode: String?
        /// The error message for an error.
        public let errorMessage: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct EvaluationMetrics: AWSDecodableShape {
        /// The evaluation metrics for the find matches algorithm.
        public let findMatchesMetrics: FindMatchesMetrics?
        /// The type of machine learning transform.
        public let transformType: TransformType

        public init(findMatchesMetrics: FindMatchesMetrics? = nil, transformType: TransformType) {
            self.findMatchesMetrics = findMatchesMetrics
            self.transformType = transformType
        }

        private enum CodingKeys: String, CodingKey {
            case findMatchesMetrics = "FindMatchesMetrics"
            case transformType = "TransformType"
        }
    }

    public struct EventBatchingCondition: AWSEncodableShape & AWSDecodableShape {
        /// Number of events that must be received from Amazon EventBridge before EventBridge event trigger fires.
        public let batchSize: Int
        /// Window of time in seconds after which EventBridge event trigger fires. Window starts when first event is received.
        public let batchWindow: Int?

        public init(batchSize: Int, batchWindow: Int? = nil) {
            self.batchSize = batchSize
            self.batchWindow = batchWindow
        }

        public func validate(name: String) throws {
            try self.validate(self.batchSize, name: "batchSize", parent: name, max: 100)
            try self.validate(self.batchSize, name: "batchSize", parent: name, min: 1)
            try self.validate(self.batchWindow, name: "batchWindow", parent: name, max: 900)
            try self.validate(self.batchWindow, name: "batchWindow", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case batchSize = "BatchSize"
            case batchWindow = "BatchWindow"
        }
    }

    public struct ExecutionProperty: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.
        public let maxConcurrentRuns: Int?

        public init(maxConcurrentRuns: Int? = nil) {
            self.maxConcurrentRuns = maxConcurrentRuns
        }

        private enum CodingKeys: String, CodingKey {
            case maxConcurrentRuns = "MaxConcurrentRuns"
        }
    }

    public struct ExportLabelsTaskRunProperties: AWSDecodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path where you will export the labels.
        public let outputS3Path: String?

        public init(outputS3Path: String? = nil) {
            self.outputS3Path = outputS3Path
        }

        private enum CodingKeys: String, CodingKey {
            case outputS3Path = "OutputS3Path"
        }
    }

    public struct FindMatchesMetrics: AWSDecodableShape {
        /// The area under the precision/recall curve (AUPRC) is a single number measuring the overall quality of the transform, that is independent of the choice made for precision vs. recall. Higher values indicate that you have a more attractive precision vs. recall tradeoff. For more information, see Precision and recall in Wikipedia.
        public let areaUnderPRCurve: Double?
        /// A list of ColumnImportance structures containing column importance metrics, sorted in order of descending importance.
        public let columnImportances: [ColumnImportance]?
        /// The confusion matrix shows you what your transform is predicting accurately and what types of errors it is making. For more information, see Confusion matrix in Wikipedia.
        public let confusionMatrix: ConfusionMatrix?
        /// The maximum F1 metric indicates the transform's accuracy between 0 and 1, where 1 is the best accuracy. For more information, see F1 score in Wikipedia.
        public let f1: Double?
        /// The precision metric indicates when often your transform is correct when it predicts a match. Specifically, it measures how well the transform finds true positives from the total true positives possible. For more information, see Precision and recall in Wikipedia.
        public let precision: Double?
        /// The recall metric indicates that for an actual match, how often your transform predicts the match. Specifically, it measures how well the transform finds true positives from the total records in the source data. For more information, see Precision and recall in Wikipedia.
        public let recall: Double?

        public init(areaUnderPRCurve: Double? = nil, columnImportances: [ColumnImportance]? = nil, confusionMatrix: ConfusionMatrix? = nil, f1: Double? = nil, precision: Double? = nil, recall: Double? = nil) {
            self.areaUnderPRCurve = areaUnderPRCurve
            self.columnImportances = columnImportances
            self.confusionMatrix = confusionMatrix
            self.f1 = f1
            self.precision = precision
            self.recall = recall
        }

        private enum CodingKeys: String, CodingKey {
            case areaUnderPRCurve = "AreaUnderPRCurve"
            case columnImportances = "ColumnImportances"
            case confusionMatrix = "ConfusionMatrix"
            case f1 = "F1"
            case precision = "Precision"
            case recall = "Recall"
        }
    }

    public struct FindMatchesParameters: AWSEncodableShape & AWSDecodableShape {
        /// The value that is selected when tuning your transform for a balance between accuracy and cost. A value of 0.5 means that the system balances accuracy and cost concerns. A value of 1.0 means a bias purely for accuracy, which typically results in a higher cost, sometimes substantially higher. A value of 0.0 means a bias purely for cost, which results in a less accurate FindMatches transform, sometimes with unacceptable accuracy. Accuracy measures how well the transform finds true positives and true negatives. Increasing accuracy requires more machine resources and cost. But it also results in increased recall.  Cost measures how many compute resources, and thus money, are consumed to run the transform.
        public let accuracyCostTradeoff: Double?
        /// The value to switch on or off to force the output to match the provided labels from users. If the value is True, the find matches transform forces the output to match the provided labels. The results override the normal conflation results. If the value is False, the find matches transform does not ensure all the labels provided are respected, and the results rely on the trained model. Note that setting this value to true may increase the conflation execution time.
        public let enforceProvidedLabels: Bool?
        /// The value selected when tuning your transform for a balance between precision and recall. A value of 0.5 means no preference; a value of 1.0 means a bias purely for precision, and a value of 0.0 means a bias for recall. Because this is a tradeoff, choosing values close to 1.0 means very low recall, and choosing values close to 0.0 results in very low precision. The precision metric indicates how often your model is correct when it predicts a match.  The recall metric indicates that for an actual match, how often your model predicts the match.
        public let precisionRecallTradeoff: Double?
        /// The name of a column that uniquely identifies rows in the source table. Used to help identify matching records.
        public let primaryKeyColumnName: String?

        public init(accuracyCostTradeoff: Double? = nil, enforceProvidedLabels: Bool? = nil, precisionRecallTradeoff: Double? = nil, primaryKeyColumnName: String? = nil) {
            self.accuracyCostTradeoff = accuracyCostTradeoff
            self.enforceProvidedLabels = enforceProvidedLabels
            self.precisionRecallTradeoff = precisionRecallTradeoff
            self.primaryKeyColumnName = primaryKeyColumnName
        }

        public func validate(name: String) throws {
            try self.validate(self.accuracyCostTradeoff, name: "accuracyCostTradeoff", parent: name, max: 1)
            try self.validate(self.accuracyCostTradeoff, name: "accuracyCostTradeoff", parent: name, min: 0)
            try self.validate(self.precisionRecallTradeoff, name: "precisionRecallTradeoff", parent: name, max: 1)
            try self.validate(self.precisionRecallTradeoff, name: "precisionRecallTradeoff", parent: name, min: 0)
            try self.validate(self.primaryKeyColumnName, name: "primaryKeyColumnName", parent: name, max: 1024)
            try self.validate(self.primaryKeyColumnName, name: "primaryKeyColumnName", parent: name, min: 1)
            try self.validate(self.primaryKeyColumnName, name: "primaryKeyColumnName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case accuracyCostTradeoff = "AccuracyCostTradeoff"
            case enforceProvidedLabels = "EnforceProvidedLabels"
            case precisionRecallTradeoff = "PrecisionRecallTradeoff"
            case primaryKeyColumnName = "PrimaryKeyColumnName"
        }
    }

    public struct FindMatchesTaskRunProperties: AWSDecodableShape {
        /// The job ID for the Find Matches task run.
        public let jobId: String?
        /// The name assigned to the job for the Find Matches task run.
        public let jobName: String?
        /// The job run ID for the Find Matches task run.
        public let jobRunId: String?

        public init(jobId: String? = nil, jobName: String? = nil, jobRunId: String? = nil) {
            self.jobId = jobId
            self.jobName = jobName
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
        }
    }

    public struct GetCatalogImportStatusRequest: AWSEncodableShape {
        /// The ID of the catalog to migrate. Currently, this should be the Amazon Web Services account ID.
        public let catalogId: String?

        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct GetCatalogImportStatusResponse: AWSDecodableShape {
        /// The status of the specified catalog migration.
        public let importStatus: CatalogImportStatus?

        public init(importStatus: CatalogImportStatus? = nil) {
            self.importStatus = importStatus
        }

        private enum CodingKeys: String, CodingKey {
            case importStatus = "ImportStatus"
        }
    }

    public struct GetClassifierRequest: AWSEncodableShape {
        /// Name of the classifier to retrieve.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetClassifierResponse: AWSDecodableShape {
        /// The requested classifier.
        public let classifier: Classifier?

        public init(classifier: Classifier? = nil) {
            self.classifier = classifier
        }

        private enum CodingKeys: String, CodingKey {
            case classifier = "Classifier"
        }
    }

    public struct GetClassifiersRequest: AWSEncodableShape {
        /// The size of the list to return (optional).
        public let maxResults: Int?
        /// An optional continuation token.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetClassifiersResponse: AWSDecodableShape {
        /// The requested list of classifier objects.
        public let classifiers: [Classifier]?
        /// A continuation token.
        public let nextToken: String?

        public init(classifiers: [Classifier]? = nil, nextToken: String? = nil) {
            self.classifiers = classifiers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case nextToken = "NextToken"
        }
    }

    public struct GetColumnStatisticsForPartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A list of the column names.
        public let columnNames: [String]
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// A list of partition values identifying the partition.
        public let partitionValues: [String]
        /// The name of the partitions' table.
        public let tableName: String

        public init(catalogId: String? = nil, columnNames: [String], databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.columnNames = columnNames
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.columnNames.forEach {
                try validate($0, name: "columnNames[]", parent: name, max: 255)
                try validate($0, name: "columnNames[]", parent: name, min: 1)
                try validate($0, name: "columnNames[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.columnNames, name: "columnNames", parent: name, max: 100)
            try self.validate(self.columnNames, name: "columnNames", parent: name, min: 0)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
            }
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnNames = "ColumnNames"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct GetColumnStatisticsForPartitionResponse: AWSDecodableShape {
        /// List of ColumnStatistics that failed to be retrieved.
        public let columnStatisticsList: [ColumnStatistics]?
        /// Error occurred during retrieving column statistics data.
        public let errors: [ColumnError]?

        public init(columnStatisticsList: [ColumnStatistics]? = nil, errors: [ColumnError]? = nil) {
            self.columnStatisticsList = columnStatisticsList
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsList = "ColumnStatisticsList"
            case errors = "Errors"
        }
    }

    public struct GetColumnStatisticsForTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A list of the column names.
        public let columnNames: [String]
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// The name of the partitions' table.
        public let tableName: String

        public init(catalogId: String? = nil, columnNames: [String], databaseName: String, tableName: String) {
            self.catalogId = catalogId
            self.columnNames = columnNames
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.columnNames.forEach {
                try validate($0, name: "columnNames[]", parent: name, max: 255)
                try validate($0, name: "columnNames[]", parent: name, min: 1)
                try validate($0, name: "columnNames[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.columnNames, name: "columnNames", parent: name, max: 100)
            try self.validate(self.columnNames, name: "columnNames", parent: name, min: 0)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnNames = "ColumnNames"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct GetColumnStatisticsForTableResponse: AWSDecodableShape {
        /// List of ColumnStatistics that failed to be retrieved.
        public let columnStatisticsList: [ColumnStatistics]?
        /// List of ColumnStatistics that failed to be retrieved.
        public let errors: [ColumnError]?

        public init(columnStatisticsList: [ColumnStatistics]? = nil, errors: [ColumnError]? = nil) {
            self.columnStatisticsList = columnStatisticsList
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case columnStatisticsList = "ColumnStatisticsList"
            case errors = "Errors"
        }
    }

    public struct GetConnectionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// Allows you to retrieve the connection metadata without returning the password. For instance, the AWS Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the KMS key to decrypt the password, but it does have permission to access the rest of the connection properties.
        public let hidePassword: Bool?
        /// The name of the connection definition to retrieve.
        public let name: String

        public init(catalogId: String? = nil, hidePassword: Bool? = nil, name: String) {
            self.catalogId = catalogId
            self.hidePassword = hidePassword
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case hidePassword = "HidePassword"
            case name = "Name"
        }
    }

    public struct GetConnectionResponse: AWSDecodableShape {
        /// The requested connection definition.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct GetConnectionsFilter: AWSEncodableShape {
        /// The type of connections to return. Currently, SFTP is not supported.
        public let connectionType: ConnectionType?
        /// A criteria string that must match the criteria recorded in the connection definition for that connection definition to be returned.
        public let matchCriteria: [String]?

        public init(connectionType: ConnectionType? = nil, matchCriteria: [String]? = nil) {
            self.connectionType = connectionType
            self.matchCriteria = matchCriteria
        }

        public func validate(name: String) throws {
            try self.matchCriteria?.forEach {
                try validate($0, name: "matchCriteria[]", parent: name, max: 255)
                try validate($0, name: "matchCriteria[]", parent: name, min: 1)
                try validate($0, name: "matchCriteria[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.matchCriteria, name: "matchCriteria", parent: name, max: 10)
            try self.validate(self.matchCriteria, name: "matchCriteria", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case connectionType = "ConnectionType"
            case matchCriteria = "MatchCriteria"
        }
    }

    public struct GetConnectionsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A filter that controls which connections are returned.
        public let filter: GetConnectionsFilter?
        /// Allows you to retrieve the connection metadata without returning the password. For instance, the AWS Glue console uses this flag to retrieve the connection, and does not display the password. Set this parameter when the caller might not have permission to use the KMS key to decrypt the password, but it does have permission to access the rest of the connection properties.
        public let hidePassword: Bool?
        /// The maximum number of connections to return in one response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(catalogId: String? = nil, filter: GetConnectionsFilter? = nil, hidePassword: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.catalogId = catalogId
            self.filter = filter
            self.hidePassword = hidePassword
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case filter = "Filter"
            case hidePassword = "HidePassword"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetConnectionsResponse: AWSDecodableShape {
        /// A list of requested connection definitions.
        public let connectionList: [Connection]?
        /// A continuation token, if the list of connections returned does not include the last of the filtered connections.
        public let nextToken: String?

        public init(connectionList: [Connection]? = nil, nextToken: String? = nil) {
            self.connectionList = connectionList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectionList = "ConnectionList"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlerMetricsRequest: AWSEncodableShape {
        /// A list of the names of crawlers about which to retrieve metrics.
        public let crawlerNameList: [String]?
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(crawlerNameList: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.crawlerNameList = crawlerNameList
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.crawlerNameList?.forEach {
                try validate($0, name: "crawlerNameList[]", parent: name, max: 255)
                try validate($0, name: "crawlerNameList[]", parent: name, min: 1)
                try validate($0, name: "crawlerNameList[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.crawlerNameList, name: "crawlerNameList", parent: name, max: 100)
            try self.validate(self.crawlerNameList, name: "crawlerNameList", parent: name, min: 0)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerNameList = "CrawlerNameList"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlerMetricsResponse: AWSDecodableShape {
        /// A list of metrics for the specified crawler.
        public let crawlerMetricsList: [CrawlerMetrics]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        public init(crawlerMetricsList: [CrawlerMetrics]? = nil, nextToken: String? = nil) {
            self.crawlerMetricsList = crawlerMetricsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerMetricsList = "CrawlerMetricsList"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlerRequest: AWSEncodableShape {
        /// The name of the crawler to retrieve metadata for.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetCrawlerResponse: AWSDecodableShape {
        /// The metadata for the specified crawler.
        public let crawler: Crawler?

        public init(crawler: Crawler? = nil) {
            self.crawler = crawler
        }

        private enum CodingKeys: String, CodingKey {
            case crawler = "Crawler"
        }
    }

    public struct GetCrawlersRequest: AWSEncodableShape {
        /// The number of crawlers to return on each call.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCrawlersResponse: AWSDecodableShape {
        /// A list of crawler metadata.
        public let crawlers: [Crawler]?
        /// A continuation token, if the returned list has not reached the end of those defined in this customer account.
        public let nextToken: String?

        public init(crawlers: [Crawler]? = nil, nextToken: String? = nil) {
            self.crawlers = crawlers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case crawlers = "Crawlers"
            case nextToken = "NextToken"
        }
    }

    public struct GetDataCatalogEncryptionSettingsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog to retrieve the security configuration for. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?

        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct GetDataCatalogEncryptionSettingsResponse: AWSDecodableShape {
        /// The requested security configuration.
        public let dataCatalogEncryptionSettings: DataCatalogEncryptionSettings?

        public init(dataCatalogEncryptionSettings: DataCatalogEncryptionSettings? = nil) {
            self.dataCatalogEncryptionSettings = dataCatalogEncryptionSettings
        }

        private enum CodingKeys: String, CodingKey {
            case dataCatalogEncryptionSettings = "DataCatalogEncryptionSettings"
        }
    }

    public struct GetDatabaseRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the database to retrieve. For Hive compatibility, this should be all lowercase.
        public let name: String

        public init(catalogId: String? = nil, name: String) {
            self.catalogId = catalogId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case name = "Name"
        }
    }

    public struct GetDatabaseResponse: AWSDecodableShape {
        /// The definition of the specified database in the Data Catalog.
        public let database: Database?

        public init(database: Database? = nil) {
            self.database = database
        }

        private enum CodingKeys: String, CodingKey {
            case database = "Database"
        }
    }

    public struct GetDatabasesRequest: AWSEncodableShape {
        /// The ID of the Data Catalog from which to retrieve Databases. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The maximum number of databases to return in one response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// Allows you to specify that you want to list the databases shared with your account. The allowable values are FOREIGN or ALL.    If set to FOREIGN, will list the databases shared with your account.    If set to ALL, will list the databases shared with your account, as well as the databases in yor local account.
        public let resourceShareType: ResourceShareType?

        public init(catalogId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceShareType: ResourceShareType? = nil) {
            self.catalogId = catalogId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceShareType = resourceShareType
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceShareType = "ResourceShareType"
        }
    }

    public struct GetDatabasesResponse: AWSDecodableShape {
        /// A list of Database objects from the specified catalog.
        public let databaseList: [Database]
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?

        public init(databaseList: [Database], nextToken: String? = nil) {
            self.databaseList = databaseList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case databaseList = "DatabaseList"
            case nextToken = "NextToken"
        }
    }

    public struct GetDataflowGraphRequest: AWSEncodableShape {
        /// The Python script to transform.
        public let pythonScript: String?

        public init(pythonScript: String? = nil) {
            self.pythonScript = pythonScript
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
        }
    }

    public struct GetDataflowGraphResponse: AWSDecodableShape {
        /// A list of the edges in the resulting DAG.
        public let dagEdges: [CodeGenEdge]?
        /// A list of the nodes in the resulting DAG.
        public let dagNodes: [CodeGenNode]?

        public init(dagEdges: [CodeGenEdge]? = nil, dagNodes: [CodeGenNode]? = nil) {
            self.dagEdges = dagEdges
            self.dagNodes = dagNodes
        }

        private enum CodingKeys: String, CodingKey {
            case dagEdges = "DagEdges"
            case dagNodes = "DagNodes"
        }
    }

    public struct GetDevEndpointRequest: AWSEncodableShape {
        /// Name of the DevEndpoint to retrieve information for.
        public let endpointName: String

        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "EndpointName"
        }
    }

    public struct GetDevEndpointResponse: AWSDecodableShape {
        /// A DevEndpoint definition.
        public let devEndpoint: DevEndpoint?

        public init(devEndpoint: DevEndpoint? = nil) {
            self.devEndpoint = devEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpoint = "DevEndpoint"
        }
    }

    public struct GetDevEndpointsRequest: AWSEncodableShape {
        /// The maximum size of information to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetDevEndpointsResponse: AWSDecodableShape {
        /// A list of DevEndpoint definitions.
        public let devEndpoints: [DevEndpoint]?
        /// A continuation token, if not all DevEndpoint definitions have yet been returned.
        public let nextToken: String?

        public init(devEndpoints: [DevEndpoint]? = nil, nextToken: String? = nil) {
            self.devEndpoints = devEndpoints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpoints = "DevEndpoints"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobBookmarkRequest: AWSEncodableShape {
        /// The name of the job in question.
        public let jobName: String
        /// The unique run identifier associated with this job run.
        public let runId: String?

        public init(jobName: String, runId: String? = nil) {
            self.jobName = jobName
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case runId = "RunId"
        }
    }

    public struct GetJobBookmarkResponse: AWSDecodableShape {
        /// A structure that defines a point that a job can resume processing.
        public let jobBookmarkEntry: JobBookmarkEntry?

        public init(jobBookmarkEntry: JobBookmarkEntry? = nil) {
            self.jobBookmarkEntry = jobBookmarkEntry
        }

        private enum CodingKeys: String, CodingKey {
            case jobBookmarkEntry = "JobBookmarkEntry"
        }
    }

    public struct GetJobRequest: AWSEncodableShape {
        /// The name of the job definition to retrieve.
        public let jobName: String

        public init(jobName: String) {
            self.jobName = jobName
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct GetJobResponse: AWSDecodableShape {
        /// The requested job definition.
        public let job: Job?

        public init(job: Job? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "Job"
        }
    }

    public struct GetJobRunRequest: AWSEncodableShape {
        /// Name of the job definition being run.
        public let jobName: String
        /// True if a list of predecessor runs should be returned.
        public let predecessorsIncluded: Bool?
        /// The ID of the job run.
        public let runId: String

        public init(jobName: String, predecessorsIncluded: Bool? = nil, runId: String) {
            self.jobName = jobName
            self.predecessorsIncluded = predecessorsIncluded
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case predecessorsIncluded = "PredecessorsIncluded"
            case runId = "RunId"
        }
    }

    public struct GetJobRunResponse: AWSDecodableShape {
        /// The requested job-run metadata.
        public let jobRun: JobRun?

        public init(jobRun: JobRun? = nil) {
            self.jobRun = jobRun
        }

        private enum CodingKeys: String, CodingKey {
            case jobRun = "JobRun"
        }
    }

    public struct GetJobRunsRequest: AWSEncodableShape {
        /// The name of the job definition for which to retrieve all job runs.
        public let jobName: String
        /// The maximum size of the response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(jobName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.jobName = jobName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobRunsResponse: AWSDecodableShape {
        /// A list of job-run metadata objects.
        public let jobRuns: [JobRun]?
        /// A continuation token, if not all requested job runs have been returned.
        public let nextToken: String?

        public init(jobRuns: [JobRun]? = nil, nextToken: String? = nil) {
            self.jobRuns = jobRuns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobRuns = "JobRuns"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobsRequest: AWSEncodableShape {
        /// The maximum size of the response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetJobsResponse: AWSDecodableShape {
        /// A list of job definitions.
        public let jobs: [Job]?
        /// A continuation token, if not all job definitions have yet been returned.
        public let nextToken: String?

        public init(jobs: [Job]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct GetMLTaskRunRequest: AWSEncodableShape {
        /// The unique identifier of the task run.
        public let taskRunId: String
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        public init(taskRunId: String, transformId: String) {
            self.taskRunId = taskRunId
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, max: 255)
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, min: 1)
            try self.validate(self.taskRunId, name: "taskRunId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
            case transformId = "TransformId"
        }
    }

    public struct GetMLTaskRunResponse: AWSDecodableShape {
        /// The date and time when this task run was completed.
        public let completedOn: Date?
        /// The error strings that are associated with the task run.
        public let errorString: String?
        /// The amount of time (in seconds) that the task run consumed resources.
        public let executionTime: Int?
        /// The date and time when this task run was last modified.
        public let lastModifiedOn: Date?
        /// The names of the log groups that are associated with the task run.
        public let logGroupName: String?
        /// The list of properties that are associated with the task run.
        public let properties: TaskRunProperties?
        /// The date and time when this task run started.
        public let startedOn: Date?
        /// The status for this task run.
        public let status: TaskStatusType?
        /// The unique run identifier associated with this run.
        public let taskRunId: String?
        /// The unique identifier of the task run.
        public let transformId: String?

        public init(completedOn: Date? = nil, errorString: String? = nil, executionTime: Int? = nil, lastModifiedOn: Date? = nil, logGroupName: String? = nil, properties: TaskRunProperties? = nil, startedOn: Date? = nil, status: TaskStatusType? = nil, taskRunId: String? = nil, transformId: String? = nil) {
            self.completedOn = completedOn
            self.errorString = errorString
            self.executionTime = executionTime
            self.lastModifiedOn = lastModifiedOn
            self.logGroupName = logGroupName
            self.properties = properties
            self.startedOn = startedOn
            self.status = status
            self.taskRunId = taskRunId
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case errorString = "ErrorString"
            case executionTime = "ExecutionTime"
            case lastModifiedOn = "LastModifiedOn"
            case logGroupName = "LogGroupName"
            case properties = "Properties"
            case startedOn = "StartedOn"
            case status = "Status"
            case taskRunId = "TaskRunId"
            case transformId = "TransformId"
        }
    }

    public struct GetMLTaskRunsRequest: AWSEncodableShape {
        /// The filter criteria, in the TaskRunFilterCriteria structure, for the task run.
        public let filter: TaskRunFilterCriteria?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A token for pagination of the results. The default is empty.
        public let nextToken: String?
        /// The sorting criteria, in the TaskRunSortCriteria structure, for the task run.
        public let sort: TaskRunSortCriteria?
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        public init(filter: TaskRunFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: TaskRunSortCriteria? = nil, transformId: String) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sort = "Sort"
            case transformId = "TransformId"
        }
    }

    public struct GetMLTaskRunsResponse: AWSDecodableShape {
        /// A pagination token, if more results are available.
        public let nextToken: String?
        /// A list of task runs that are associated with the transform.
        public let taskRuns: [TaskRun]?

        public init(nextToken: String? = nil, taskRuns: [TaskRun]? = nil) {
            self.nextToken = nextToken
            self.taskRuns = taskRuns
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case taskRuns = "TaskRuns"
        }
    }

    public struct GetMLTransformRequest: AWSEncodableShape {
        /// The unique identifier of the transform, generated at the time that the transform was created.
        public let transformId: String

        public init(transformId: String) {
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct GetMLTransformResponse: AWSDecodableShape {
        /// The date and time when the transform was created.
        public let createdOn: Date?
        /// A description of the transform.
        public let description: String?
        /// The latest evaluation metrics.
        public let evaluationMetrics: EvaluationMetrics?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see Glue Versions in the developer guide.
        public let glueVersion: String?
        /// A list of Glue table definitions used by the transform.
        public let inputRecordTables: [GlueTable]?
        /// The number of labels available for this transform.
        public let labelCount: Int?
        /// The date and time when the transform was last modified.
        public let lastModifiedOn: Date?
        /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.  When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
        public let maxCapacity: Double?
        /// The maximum number of times to retry a task for this transform after a task run fails.
        public let maxRetries: Int?
        /// The unique name given to the transform when it was created.
        public let name: String?
        /// The number of workers of a defined workerType that are allocated when this task runs.
        public let numberOfWorkers: Int?
        /// The configuration parameters that are specific to the algorithm used.
        public let parameters: TransformParameters?
        /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.
        public let role: String?
        /// The Map&lt;Column, Type&gt; object that represents the schema that this transform accepts. Has an upper bound of 100 columns.
        public let schema: [SchemaColumn]?
        /// The last known status of the transform (to indicate whether it can be used or not). One of "NOT_READY", "READY", or "DELETING".
        public let status: TransformStatusType?
        /// The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?
        /// The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.
        public let transformEncryption: TransformEncryption?
        /// The unique identifier of the transform, generated at the time that the transform was created.
        public let transformId: String?
        /// The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
        public let workerType: WorkerType?

        public init(createdOn: Date? = nil, description: String? = nil, evaluationMetrics: EvaluationMetrics? = nil, glueVersion: String? = nil, inputRecordTables: [GlueTable]? = nil, labelCount: Int? = nil, lastModifiedOn: Date? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String? = nil, numberOfWorkers: Int? = nil, parameters: TransformParameters? = nil, role: String? = nil, schema: [SchemaColumn]? = nil, status: TransformStatusType? = nil, timeout: Int? = nil, transformEncryption: TransformEncryption? = nil, transformId: String? = nil, workerType: WorkerType? = nil) {
            self.createdOn = createdOn
            self.description = description
            self.evaluationMetrics = evaluationMetrics
            self.glueVersion = glueVersion
            self.inputRecordTables = inputRecordTables
            self.labelCount = labelCount
            self.lastModifiedOn = lastModifiedOn
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.numberOfWorkers = numberOfWorkers
            self.parameters = parameters
            self.role = role
            self.schema = schema
            self.status = status
            self.timeout = timeout
            self.transformEncryption = transformEncryption
            self.transformId = transformId
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case createdOn = "CreatedOn"
            case description = "Description"
            case evaluationMetrics = "EvaluationMetrics"
            case glueVersion = "GlueVersion"
            case inputRecordTables = "InputRecordTables"
            case labelCount = "LabelCount"
            case lastModifiedOn = "LastModifiedOn"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case numberOfWorkers = "NumberOfWorkers"
            case parameters = "Parameters"
            case role = "Role"
            case schema = "Schema"
            case status = "Status"
            case timeout = "Timeout"
            case transformEncryption = "TransformEncryption"
            case transformId = "TransformId"
            case workerType = "WorkerType"
        }
    }

    public struct GetMLTransformsRequest: AWSEncodableShape {
        /// The filter transformation criteria.
        public let filter: TransformFilterCriteria?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A paginated token to offset the results.
        public let nextToken: String?
        /// The sorting criteria.
        public let sort: TransformSortCriteria?

        public init(filter: TransformFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: TransformSortCriteria? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sort = "Sort"
        }
    }

    public struct GetMLTransformsResponse: AWSDecodableShape {
        /// A pagination token, if more results are available.
        public let nextToken: String?
        /// A list of machine learning transforms.
        public let transforms: [MLTransform]

        public init(nextToken: String? = nil, transforms: [MLTransform]) {
            self.nextToken = nextToken
            self.transforms = transforms
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case transforms = "Transforms"
        }
    }

    public struct GetMappingRequest: AWSEncodableShape {
        /// Parameters for the mapping.
        public let location: Location?
        /// A list of target tables.
        public let sinks: [CatalogEntry]?
        /// Specifies the source table.
        public let source: CatalogEntry

        public init(location: Location? = nil, sinks: [CatalogEntry]? = nil, source: CatalogEntry) {
            self.location = location
            self.sinks = sinks
            self.source = source
        }

        public func validate(name: String) throws {
            try self.location?.validate(name: "\(name).location")
            try self.sinks?.forEach {
                try $0.validate(name: "\(name).sinks[]")
            }
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
            case sinks = "Sinks"
            case source = "Source"
        }
    }

    public struct GetMappingResponse: AWSDecodableShape {
        /// A list of mappings to the specified targets.
        public let mapping: [MappingEntry]

        public init(mapping: [MappingEntry]) {
            self.mapping = mapping
        }

        private enum CodingKeys: String, CodingKey {
            case mapping = "Mapping"
        }
    }

    public struct GetPartitionIndexesRequest: AWSEncodableShape {
        /// The catalog ID where the table resides.
        public let catalogId: String?
        /// Specifies the name of a database from which you want to retrieve partition indexes.
        public let databaseName: String
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?
        /// Specifies the name of a table for which you want to retrieve the partition indexes.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, nextToken: String? = nil, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.nextToken = nextToken
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case nextToken = "NextToken"
            case tableName = "TableName"
        }
    }

    public struct GetPartitionIndexesResponse: AWSDecodableShape {
        /// A continuation token, present if the current list segment is not the last.
        public let nextToken: String?
        /// A list of index descriptors.
        public let partitionIndexDescriptorList: [PartitionIndexDescriptor]?

        public init(nextToken: String? = nil, partitionIndexDescriptorList: [PartitionIndexDescriptor]? = nil) {
            self.nextToken = nextToken
            self.partitionIndexDescriptorList = partitionIndexDescriptorList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case partitionIndexDescriptorList = "PartitionIndexDescriptorList"
        }
    }

    public struct GetPartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partition resides.
        public let databaseName: String
        /// The values that define the partition.
        public let partitionValues: [String]
        /// The name of the partition's table.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
            }
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct GetPartitionResponse: AWSDecodableShape {
        /// The requested information, in the form of a Partition object.
        public let partition: Partition?

        public init(partition: Partition? = nil) {
            self.partition = partition
        }

        private enum CodingKeys: String, CodingKey {
            case partition = "Partition"
        }
    }

    public struct GetPartitionsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        public let excludeColumnSchema: Bool?
        /// An expression that filters the partitions to be returned. The expression uses SQL syntax similar to the SQL WHERE filter clause. The SQL statement parser JSQLParser parses the expression.   Operators: The following are the operators that you can use in the Expression API call:  =  Checks whether the values of the two operands are equal; if yes, then the condition becomes true. Example: Assume 'variable a' holds 10 and 'variable b' holds 20.  (a = b) is not true.  &lt; &gt;  Checks whether the values of two operands are equal; if the values are not equal, then the condition becomes true. Example: (a &lt; &gt; b) is true.  &gt;  Checks whether the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true. Example: (a &gt; b) is not true.  &lt;  Checks whether the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true. Example: (a &lt; b) is true.  &gt;=  Checks whether the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a &gt;= b) is not true.  &lt;=  Checks whether the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true. Example: (a &lt;= b) is true.  AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL  Logical operators.    Supported Partition Key Types: The following are the supported partition keys.    string     date     timestamp     int     bigint     long     tinyint     smallint     decimal    If an type is encountered that is not valid, an exception is thrown.  The following list shows the valid operators on each type. When you define a crawler, the partitionKey type is created as a STRING, to be compatible with the catalog partitions.   Sample API Call:
        public let expression: String?
        /// The maximum number of partitions to return in a single response.
        public let maxResults: Int?
        /// A continuation token, if this is not the first call to retrieve these partitions.
        public let nextToken: String?
        /// The segment of the table's partitions to scan in this request.
        public let segment: Segment?
        /// The name of the partitions' table.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, excludeColumnSchema: Bool? = nil, expression: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, segment: Segment? = nil, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.excludeColumnSchema = excludeColumnSchema
            self.expression = expression
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.segment = segment
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, min: 0)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.segment?.validate(name: "\(name).segment")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case excludeColumnSchema = "ExcludeColumnSchema"
            case expression = "Expression"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case segment = "Segment"
            case tableName = "TableName"
        }
    }

    public struct GetPartitionsResponse: AWSDecodableShape {
        /// A continuation token, if the returned list of partitions does not include the last one.
        public let nextToken: String?
        /// A list of requested partitions.
        public let partitions: [Partition]?

        public init(nextToken: String? = nil, partitions: [Partition]? = nil) {
            self.nextToken = nextToken
            self.partitions = partitions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case partitions = "Partitions"
        }
    }

    public struct GetPlanRequest: AWSEncodableShape {
        /// A map to hold additional optional key-value parameters. Currently, these key-value pairs are supported:    inferSchema  —  Specifies whether to set inferSchema to true or false for the default script generated by an Glue job. For example, to set inferSchema to true, pass the following key value pair:  --additional-plan-options-map '{"inferSchema":"true"}'
        public let additionalPlanOptionsMap: [String: String]?
        /// The programming language of the code to perform the mapping.
        public let language: Language?
        /// The parameters for the mapping.
        public let location: Location?
        /// The list of mappings from a source table to target tables.
        public let mapping: [MappingEntry]
        /// The target tables.
        public let sinks: [CatalogEntry]?
        /// The source table.
        public let source: CatalogEntry

        public init(additionalPlanOptionsMap: [String: String]? = nil, language: Language? = nil, location: Location? = nil, mapping: [MappingEntry], sinks: [CatalogEntry]? = nil, source: CatalogEntry) {
            self.additionalPlanOptionsMap = additionalPlanOptionsMap
            self.language = language
            self.location = location
            self.mapping = mapping
            self.sinks = sinks
            self.source = source
        }

        public func validate(name: String) throws {
            try self.location?.validate(name: "\(name).location")
            try self.sinks?.forEach {
                try $0.validate(name: "\(name).sinks[]")
            }
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalPlanOptionsMap = "AdditionalPlanOptionsMap"
            case language = "Language"
            case location = "Location"
            case mapping = "Mapping"
            case sinks = "Sinks"
            case source = "Source"
        }
    }

    public struct GetPlanResponse: AWSDecodableShape {
        /// A Python script to perform the mapping.
        public let pythonScript: String?
        /// The Scala code to perform the mapping.
        public let scalaCode: String?

        public init(pythonScript: String? = nil, scalaCode: String? = nil) {
            self.pythonScript = pythonScript
            self.scalaCode = scalaCode
        }

        private enum CodingKeys: String, CodingKey {
            case pythonScript = "PythonScript"
            case scalaCode = "ScalaCode"
        }
    }

    public struct GetRegistryInput: AWSEncodableShape {
        /// This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
        public let registryId: RegistryId

        public init(registryId: RegistryId) {
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.registryId.validate(name: "\(name).registryId")
        }

        private enum CodingKeys: String, CodingKey {
            case registryId = "RegistryId"
        }
    }

    public struct GetRegistryResponse: AWSDecodableShape {
        /// The date and time the registry was created.
        public let createdTime: String?
        /// A description of the registry.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// The status of the registry.
        public let status: RegistryStatus?
        /// The date and time the registry was updated.
        public let updatedTime: String?

        public init(createdTime: String? = nil, description: String? = nil, registryArn: String? = nil, registryName: String? = nil, status: RegistryStatus? = nil, updatedTime: String? = nil) {
            self.createdTime = createdTime
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.status = status
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case status = "Status"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct GetResourcePoliciesRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetResourcePoliciesResponse: AWSDecodableShape {
        /// A list of the individual resource policies and the account-level resource policy.
        public let getResourcePoliciesResponseList: [GluePolicy]?
        /// A continuation token, if the returned list does not contain the last resource policy available.
        public let nextToken: String?

        public init(getResourcePoliciesResponseList: [GluePolicy]? = nil, nextToken: String? = nil) {
            self.getResourcePoliciesResponseList = getResourcePoliciesResponseList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case getResourcePoliciesResponseList = "GetResourcePoliciesResponseList"
            case nextToken = "NextToken"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// The ARN of the Glue resource for which to retrieve the resource policy. If not supplied, the Data Catalog resource policy is returned. Use GetResourcePolicies to view all existing resource policies. For more information see Specifying Glue Resource ARNs.
        public let resourceArn: String?

        public init(resourceArn: String? = nil) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws:glue:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// The date and time at which the policy was created.
        public let createTime: Date?
        /// Contains the hash value associated with this policy.
        public let policyHash: String?
        /// Contains the requested policy document, in JSON format.
        public let policyInJson: String?
        /// The date and time at which the policy was last updated.
        public let updateTime: Date?

        public init(createTime: Date? = nil, policyHash: String? = nil, policyInJson: String? = nil, updateTime: Date? = nil) {
            self.createTime = createTime
            self.policyHash = policyHash
            self.policyInJson = policyInJson
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case policyHash = "PolicyHash"
            case policyInJson = "PolicyInJson"
            case updateTime = "UpdateTime"
        }
    }

    public struct GetSchemaByDefinitionInput: AWSEncodableShape {
        /// The definition of the schema for which schema details are required.
        public let schemaDefinition: String
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.   SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
        public let schemaId: SchemaId

        public init(schemaDefinition: String, schemaId: SchemaId) {
            self.schemaDefinition = schemaDefinition
            self.schemaId = schemaId
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, max: 170_000)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, min: 1)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, pattern: ".*\\S.*")
            try self.schemaId.validate(name: "\(name).schemaId")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaDefinition = "SchemaDefinition"
            case schemaId = "SchemaId"
        }
    }

    public struct GetSchemaByDefinitionResponse: AWSDecodableShape {
        /// The date and time the schema was created.
        public let createdTime: String?
        /// The data format of the schema definition. Currently only AVRO and JSON are supported.
        public let dataFormat: DataFormat?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The schema ID of the schema version.
        public let schemaVersionId: String?
        /// The status of the schema version.
        public let status: SchemaVersionStatus?

        public init(createdTime: String? = nil, dataFormat: DataFormat? = nil, schemaArn: String? = nil, schemaVersionId: String? = nil, status: SchemaVersionStatus? = nil) {
            self.createdTime = createdTime
            self.dataFormat = dataFormat
            self.schemaArn = schemaArn
            self.schemaVersionId = schemaVersionId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case dataFormat = "DataFormat"
            case schemaArn = "SchemaArn"
            case schemaVersionId = "SchemaVersionId"
            case status = "Status"
        }
    }

    public struct GetSchemaInput: AWSEncodableShape {
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
        public let schemaId: SchemaId

        public init(schemaId: SchemaId) {
            self.schemaId = schemaId
        }

        public func validate(name: String) throws {
            try self.schemaId.validate(name: "\(name).schemaId")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaId = "SchemaId"
        }
    }

    public struct GetSchemaResponse: AWSDecodableShape {
        /// The compatibility mode of the schema.
        public let compatibility: Compatibility?
        /// The date and time the schema was created.
        public let createdTime: String?
        /// The data format of the schema definition. Currently AVRO and JSON are supported.
        public let dataFormat: DataFormat?
        /// A description of schema if specified when created
        public let description: String?
        /// The latest version of the schema associated with the returned schema definition.
        public let latestSchemaVersion: Int64?
        /// The next version of the schema associated with the returned schema definition.
        public let nextSchemaVersion: Int64?
        /// The Amazon Resource Name (ARN) of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The version number of the checkpoint (the last time the compatibility mode was changed).
        public let schemaCheckpoint: Int64?
        /// The name of the schema.
        public let schemaName: String?
        /// The status of the schema.
        public let schemaStatus: SchemaStatus?
        /// The date and time the schema was updated.
        public let updatedTime: String?

        public init(compatibility: Compatibility? = nil, createdTime: String? = nil, dataFormat: DataFormat? = nil, description: String? = nil, latestSchemaVersion: Int64? = nil, nextSchemaVersion: Int64? = nil, registryArn: String? = nil, registryName: String? = nil, schemaArn: String? = nil, schemaCheckpoint: Int64? = nil, schemaName: String? = nil, schemaStatus: SchemaStatus? = nil, updatedTime: String? = nil) {
            self.compatibility = compatibility
            self.createdTime = createdTime
            self.dataFormat = dataFormat
            self.description = description
            self.latestSchemaVersion = latestSchemaVersion
            self.nextSchemaVersion = nextSchemaVersion
            self.registryArn = registryArn
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaCheckpoint = schemaCheckpoint
            self.schemaName = schemaName
            self.schemaStatus = schemaStatus
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case compatibility = "Compatibility"
            case createdTime = "CreatedTime"
            case dataFormat = "DataFormat"
            case description = "Description"
            case latestSchemaVersion = "LatestSchemaVersion"
            case nextSchemaVersion = "NextSchemaVersion"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaCheckpoint = "SchemaCheckpoint"
            case schemaName = "SchemaName"
            case schemaStatus = "SchemaStatus"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct GetSchemaVersionInput: AWSEncodableShape {
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
        public let schemaId: SchemaId?
        /// The SchemaVersionId of the schema version. This field is required for fetching by schema ID. Either this or the SchemaId wrapper has to be provided.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let schemaVersionNumber: SchemaVersionNumber?

        public init(schemaId: SchemaId? = nil, schemaVersionId: String? = nil, schemaVersionNumber: SchemaVersionNumber? = nil) {
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.schemaId?.validate(name: "\(name).schemaId")
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
            try self.schemaVersionNumber?.validate(name: "\(name).schemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaId = "SchemaId"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct GetSchemaVersionResponse: AWSDecodableShape {
        /// The date and time the schema version was created.
        public let createdTime: String?
        /// The data format of the schema definition. Currently AVRO and JSON are supported.
        public let dataFormat: DataFormat?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The schema definition for the schema ID.
        public let schemaDefinition: String?
        /// The SchemaVersionId of the schema version.
        public let schemaVersionId: String?
        /// The status of the schema version.
        public let status: SchemaVersionStatus?
        /// The version number of the schema.
        public let versionNumber: Int64?

        public init(createdTime: String? = nil, dataFormat: DataFormat? = nil, schemaArn: String? = nil, schemaDefinition: String? = nil, schemaVersionId: String? = nil, status: SchemaVersionStatus? = nil, versionNumber: Int64? = nil) {
            self.createdTime = createdTime
            self.dataFormat = dataFormat
            self.schemaArn = schemaArn
            self.schemaDefinition = schemaDefinition
            self.schemaVersionId = schemaVersionId
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case dataFormat = "DataFormat"
            case schemaArn = "SchemaArn"
            case schemaDefinition = "SchemaDefinition"
            case schemaVersionId = "SchemaVersionId"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct GetSchemaVersionsDiffInput: AWSEncodableShape {
        /// The first of the two schema versions to be compared.
        public let firstSchemaVersionNumber: SchemaVersionNumber
        /// Refers to SYNTAX_DIFF, which is the currently supported diff type.
        public let schemaDiffType: SchemaDiffType
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.   SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
        public let schemaId: SchemaId
        /// The second of the two schema versions to be compared.
        public let secondSchemaVersionNumber: SchemaVersionNumber

        public init(firstSchemaVersionNumber: SchemaVersionNumber, schemaDiffType: SchemaDiffType, schemaId: SchemaId, secondSchemaVersionNumber: SchemaVersionNumber) {
            self.firstSchemaVersionNumber = firstSchemaVersionNumber
            self.schemaDiffType = schemaDiffType
            self.schemaId = schemaId
            self.secondSchemaVersionNumber = secondSchemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.firstSchemaVersionNumber.validate(name: "\(name).firstSchemaVersionNumber")
            try self.schemaId.validate(name: "\(name).schemaId")
            try self.secondSchemaVersionNumber.validate(name: "\(name).secondSchemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case firstSchemaVersionNumber = "FirstSchemaVersionNumber"
            case schemaDiffType = "SchemaDiffType"
            case schemaId = "SchemaId"
            case secondSchemaVersionNumber = "SecondSchemaVersionNumber"
        }
    }

    public struct GetSchemaVersionsDiffResponse: AWSDecodableShape {
        /// The difference between schemas as a string in JsonPatch format.
        public let diff: String?

        public init(diff: String? = nil) {
            self.diff = diff
        }

        private enum CodingKeys: String, CodingKey {
            case diff = "Diff"
        }
    }

    public struct GetSecurityConfigurationRequest: AWSEncodableShape {
        /// The name of the security configuration to retrieve.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetSecurityConfigurationResponse: AWSDecodableShape {
        /// The requested security configuration.
        public let securityConfiguration: SecurityConfiguration?

        public init(securityConfiguration: SecurityConfiguration? = nil) {
            self.securityConfiguration = securityConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case securityConfiguration = "SecurityConfiguration"
        }
    }

    public struct GetSecurityConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetSecurityConfigurationsResponse: AWSDecodableShape {
        /// A continuation token, if there are more security configurations to return.
        public let nextToken: String?
        /// A list of security configurations.
        public let securityConfigurations: [SecurityConfiguration]?

        public init(nextToken: String? = nil, securityConfigurations: [SecurityConfiguration]? = nil) {
            self.nextToken = nextToken
            self.securityConfigurations = securityConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case securityConfigurations = "SecurityConfigurations"
        }
    }

    public struct GetTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table for which to retrieve the definition. For Hive compatibility, this name is entirely lowercase.
        public let name: String

        public init(catalogId: String? = nil, databaseName: String, name: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case name = "Name"
        }
    }

    public struct GetTableResponse: AWSDecodableShape {
        /// The Table object that defines the specified table.
        public let table: Table?

        public init(table: Table? = nil) {
            self.table = table
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
        }
    }

    public struct GetTableVersionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The name of the table. For Hive compatibility, this name is entirely lowercase.
        public let tableName: String
        /// The ID value of the table version to be retrieved. A VersionID is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String?

        public init(catalogId: String? = nil, databaseName: String, tableName: String, versionId: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 255)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
            case versionId = "VersionId"
        }
    }

    public struct GetTableVersionResponse: AWSDecodableShape {
        /// The requested table version.
        public let tableVersion: TableVersion?

        public init(tableVersion: TableVersion? = nil) {
            self.tableVersion = tableVersion
        }

        private enum CodingKeys: String, CodingKey {
            case tableVersion = "TableVersion"
        }
    }

    public struct GetTableVersionsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// The maximum number of table versions to return in one response.
        public let maxResults: Int?
        /// A continuation token, if this is not the first call.
        public let nextToken: String?
        /// The name of the table. For Hive compatibility, this name is entirely lowercase.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, maxResults: Int? = nil, nextToken: String? = nil, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tableName = "TableName"
        }
    }

    public struct GetTableVersionsResponse: AWSDecodableShape {
        /// A continuation token, if the list of available versions does not include the last one.
        public let nextToken: String?
        /// A list of strings identifying available versions of the specified table.
        public let tableVersions: [TableVersion]?

        public init(nextToken: String? = nil, tableVersions: [TableVersion]? = nil) {
            self.nextToken = nextToken
            self.tableVersions = tableVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tableVersions = "TableVersions"
        }
    }

    public struct GetTablesRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The database in the catalog whose tables to list. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// A regular expression pattern. If present, only those tables whose names match the pattern are returned.
        public let expression: String?
        /// The maximum number of tables to return in a single response.
        public let maxResults: Int?
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?

        public init(catalogId: String? = nil, databaseName: String, expression: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.expression = expression
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, min: 0)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case expression = "Expression"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetTablesResponse: AWSDecodableShape {
        /// A continuation token, present if the current list segment is not the last.
        public let nextToken: String?
        /// A list of the requested Table objects.
        public let tableList: [Table]?

        public init(nextToken: String? = nil, tableList: [Table]? = nil) {
            self.nextToken = nextToken
            self.tableList = tableList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tableList = "TableList"
        }
    }

    public struct GetTagsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which to retrieve tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws:glue:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct GetTagsResponse: AWSDecodableShape {
        /// The requested tags.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct GetTriggerRequest: AWSEncodableShape {
        /// The name of the trigger to retrieve.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct GetTriggerResponse: AWSDecodableShape {
        /// The requested trigger definition.
        public let trigger: Trigger?

        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public struct GetTriggersRequest: AWSEncodableShape {
        /// The name of the job to retrieve triggers for. The trigger that can start this job is returned, and if there is no such trigger, all triggers are returned.
        public let dependentJobName: String?
        /// The maximum size of the response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(dependentJobName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dependentJobName = dependentJobName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, max: 255)
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, min: 1)
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dependentJobName = "DependentJobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetTriggersResponse: AWSDecodableShape {
        /// A continuation token, if not all the requested triggers have yet been returned.
        public let nextToken: String?
        /// A list of triggers for the specified job.
        public let triggers: [Trigger]?

        public init(nextToken: String? = nil, triggers: [Trigger]? = nil) {
            self.nextToken = nextToken
            self.triggers = triggers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case triggers = "Triggers"
        }
    }

    public struct GetUserDefinedFunctionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the function to be retrieved is located. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the function is located.
        public let databaseName: String
        /// The name of the function.
        public let functionName: String

        public init(catalogId: String? = nil, databaseName: String, functionName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 255)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionName = "FunctionName"
        }
    }

    public struct GetUserDefinedFunctionResponse: AWSDecodableShape {
        /// The requested function definition.
        public let userDefinedFunction: UserDefinedFunction?

        public init(userDefinedFunction: UserDefinedFunction? = nil) {
            self.userDefinedFunction = userDefinedFunction
        }

        private enum CodingKeys: String, CodingKey {
            case userDefinedFunction = "UserDefinedFunction"
        }
    }

    public struct GetUserDefinedFunctionsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the functions to be retrieved are located. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the functions are located. If none is provided, functions from all the databases across the catalog will be returned.
        public let databaseName: String?
        /// The maximum number of functions to return in one response.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// An optional function-name pattern string that filters the function definitions returned.
        public let pattern: String

        public init(catalogId: String? = nil, databaseName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, pattern: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pattern = pattern
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.pattern, name: "pattern", parent: name, max: 255)
            try self.validate(self.pattern, name: "pattern", parent: name, min: 1)
            try self.validate(self.pattern, name: "pattern", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case pattern = "Pattern"
        }
    }

    public struct GetUserDefinedFunctionsResponse: AWSDecodableShape {
        /// A continuation token, if the list of functions returned does not include the last requested function.
        public let nextToken: String?
        /// A list of requested function definitions.
        public let userDefinedFunctions: [UserDefinedFunction]?

        public init(nextToken: String? = nil, userDefinedFunctions: [UserDefinedFunction]? = nil) {
            self.nextToken = nextToken
            self.userDefinedFunctions = userDefinedFunctions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userDefinedFunctions = "UserDefinedFunctions"
        }
    }

    public struct GetWorkflowRequest: AWSEncodableShape {
        /// Specifies whether to include a graph when returning the workflow resource metadata.
        public let includeGraph: Bool?
        /// The name of the workflow to retrieve.
        public let name: String

        public init(includeGraph: Bool? = nil, name: String) {
            self.includeGraph = includeGraph
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case name = "Name"
        }
    }

    public struct GetWorkflowResponse: AWSDecodableShape {
        /// The resource metadata for the workflow.
        public let workflow: Workflow?

        public init(workflow: Workflow? = nil) {
            self.workflow = workflow
        }

        private enum CodingKeys: String, CodingKey {
            case workflow = "Workflow"
        }
    }

    public struct GetWorkflowRunPropertiesRequest: AWSEncodableShape {
        /// Name of the workflow which was run.
        public let name: String
        /// The ID of the workflow run whose run properties should be returned.
        public let runId: String

        public init(name: String, runId: String) {
            self.name = name
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case runId = "RunId"
        }
    }

    public struct GetWorkflowRunPropertiesResponse: AWSDecodableShape {
        /// The workflow run properties which were set during the specified run.
        public let runProperties: [String: String]?

        public init(runProperties: [String: String]? = nil) {
            self.runProperties = runProperties
        }

        private enum CodingKeys: String, CodingKey {
            case runProperties = "RunProperties"
        }
    }

    public struct GetWorkflowRunRequest: AWSEncodableShape {
        /// Specifies whether to include the workflow graph in response or not.
        public let includeGraph: Bool?
        /// Name of the workflow being run.
        public let name: String
        /// The ID of the workflow run.
        public let runId: String

        public init(includeGraph: Bool? = nil, name: String, runId: String) {
            self.includeGraph = includeGraph
            self.name = name
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case name = "Name"
            case runId = "RunId"
        }
    }

    public struct GetWorkflowRunResponse: AWSDecodableShape {
        /// The requested workflow run metadata.
        public let run: WorkflowRun?

        public init(run: WorkflowRun? = nil) {
            self.run = run
        }

        private enum CodingKeys: String, CodingKey {
            case run = "Run"
        }
    }

    public struct GetWorkflowRunsRequest: AWSEncodableShape {
        /// Specifies whether to include the workflow graph in response or not.
        public let includeGraph: Bool?
        /// The maximum number of workflow runs to be included in the response.
        public let maxResults: Int?
        /// Name of the workflow whose metadata of runs should be returned.
        public let name: String
        /// The maximum size of the response.
        public let nextToken: String?

        public init(includeGraph: Bool? = nil, maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.includeGraph = includeGraph
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case includeGraph = "IncludeGraph"
            case maxResults = "MaxResults"
            case name = "Name"
            case nextToken = "NextToken"
        }
    }

    public struct GetWorkflowRunsResponse: AWSDecodableShape {
        /// A continuation token, if not all requested workflow runs have been returned.
        public let nextToken: String?
        /// A list of workflow run metadata objects.
        public let runs: [WorkflowRun]?

        public init(nextToken: String? = nil, runs: [WorkflowRun]? = nil) {
            self.nextToken = nextToken
            self.runs = runs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case runs = "Runs"
        }
    }

    public struct GluePolicy: AWSDecodableShape {
        /// The date and time at which the policy was created.
        public let createTime: Date?
        /// Contains the hash value associated with this policy.
        public let policyHash: String?
        /// Contains the requested policy document, in JSON format.
        public let policyInJson: String?
        /// The date and time at which the policy was last updated.
        public let updateTime: Date?

        public init(createTime: Date? = nil, policyHash: String? = nil, policyInJson: String? = nil, updateTime: Date? = nil) {
            self.createTime = createTime
            self.policyHash = policyHash
            self.policyInJson = policyInJson
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "CreateTime"
            case policyHash = "PolicyHash"
            case policyInJson = "PolicyInJson"
            case updateTime = "UpdateTime"
        }
    }

    public struct GlueTable: AWSEncodableShape & AWSDecodableShape {
        /// A unique identifier for the Glue Data Catalog.
        public let catalogId: String?
        /// The name of the connection to the Glue Data Catalog.
        public let connectionName: String?
        /// A database name in the Glue Data Catalog.
        public let databaseName: String
        /// A table name in the Glue Data Catalog.
        public let tableName: String

        public init(catalogId: String? = nil, connectionName: String? = nil, databaseName: String, tableName: String) {
            self.catalogId = catalogId
            self.connectionName = connectionName
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 255)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 1)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionName = "ConnectionName"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct GrokClassifier: AWSDecodableShape {
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, and so on.
        public let classification: String
        /// The time that this classifier was registered.
        public let creationTime: Date?
        /// Optional custom grok patterns defined by this classifier. For more information, see custom patterns in Writing Custom Classifiers.
        public let customPatterns: String?
        /// The grok pattern applied to a data store by this classifier. For more information, see built-in patterns in Writing Custom Classifiers.
        public let grokPattern: String
        /// The time that this classifier was last updated.
        public let lastUpdated: Date?
        /// The name of the classifier.
        public let name: String
        /// The version of this classifier.
        public let version: Int64?

        public init(classification: String, creationTime: Date? = nil, customPatterns: String? = nil, grokPattern: String, lastUpdated: Date? = nil, name: String, version: Int64? = nil) {
            self.classification = classification
            self.creationTime = creationTime
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.lastUpdated = lastUpdated
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case creationTime = "CreationTime"
            case customPatterns = "CustomPatterns"
            case grokPattern = "GrokPattern"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct ImportCatalogToGlueRequest: AWSEncodableShape {
        /// The ID of the catalog to import. Currently, this should be the Amazon Web Services account ID.
        public let catalogId: String?

        public init(catalogId: String? = nil) {
            self.catalogId = catalogId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
        }
    }

    public struct ImportCatalogToGlueResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ImportLabelsTaskRunProperties: AWSDecodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path from where you will import the labels.
        public let inputS3Path: String?
        /// Indicates whether to overwrite your existing labels.
        public let replace: Bool?

        public init(inputS3Path: String? = nil, replace: Bool? = nil) {
            self.inputS3Path = inputS3Path
            self.replace = replace
        }

        private enum CodingKeys: String, CodingKey {
            case inputS3Path = "InputS3Path"
            case replace = "Replace"
        }
    }

    public struct JdbcTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection to use to connect to the JDBC target.
        public let connectionName: String?
        /// A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler.
        public let exclusions: [String]?
        /// The path of the JDBC target.
        public let path: String?

        public init(connectionName: String? = nil, exclusions: [String]? = nil, path: String? = nil) {
            self.connectionName = connectionName
            self.exclusions = exclusions
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case exclusions = "Exclusions"
            case path = "Path"
        }
    }

    public struct Job: AWSDecodableShape {
        /// The JobCommand that runs this job.
        public let command: JobCommand?
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// The time and date that this job definition was created.
        public let createdOn: Date?
        /// The default arguments for this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the key-value pairs that Glue consumes to set up your job, see the Special Parameters Used by Glue topic in the developer guide.
        public let defaultArguments: [String: String]?
        /// A description of the job.
        public let description: String?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
        public let glueVersion: String?
        /// The last point in time when this job definition was modified.
        public let lastModifiedOn: Date?
        /// This field is reserved for future use.
        public let logUri: String?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an Apache Spark streaming ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.   For Glue version 2.0 jobs, you cannot instead specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers.
        public let maxCapacity: Double?
        /// The maximum number of times to retry this job after a JobRun fails.
        public let maxRetries: Int?
        /// The name you assign to this job definition.
        public let name: String?
        /// Non-overridable arguments for this job, specified as name-value pairs.
        public let nonOverridableArguments: [String: String]?
        /// Specifies configuration properties of a job notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
        public let numberOfWorkers: Int?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
        public let role: String?
        /// The name of the SecurityConfiguration structure to be used with this job.
        public let securityConfiguration: String?
        /// The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.
        public let workerType: WorkerType?

        public init(command: JobCommand? = nil, connections: ConnectionsList? = nil, createdOn: Date? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionProperty: ExecutionProperty? = nil, glueVersion: String? = nil, lastModifiedOn: Date? = nil, logUri: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String? = nil, nonOverridableArguments: [String: String]? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, role: String? = nil, securityConfiguration: String? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.command = command
            self.connections = connections
            self.createdOn = createdOn
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.lastModifiedOn = lastModifiedOn
            self.logUri = logUri
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case connections = "Connections"
            case createdOn = "CreatedOn"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case executionProperty = "ExecutionProperty"
            case glueVersion = "GlueVersion"
            case lastModifiedOn = "LastModifiedOn"
            case logUri = "LogUri"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case nonOverridableArguments = "NonOverridableArguments"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct JobBookmarkEntry: AWSDecodableShape {
        /// The attempt ID number.
        public let attempt: Int?
        /// The bookmark itself.
        public let jobBookmark: String?
        /// The name of the job in question.
        public let jobName: String?
        /// The unique run identifier associated with the previous job run.
        public let previousRunId: String?
        /// The run ID number.
        public let run: Int?
        /// The run ID number.
        public let runId: String?
        /// The version of the job.
        public let version: Int?

        public init(attempt: Int? = nil, jobBookmark: String? = nil, jobName: String? = nil, previousRunId: String? = nil, run: Int? = nil, runId: String? = nil, version: Int? = nil) {
            self.attempt = attempt
            self.jobBookmark = jobBookmark
            self.jobName = jobName
            self.previousRunId = previousRunId
            self.run = run
            self.runId = runId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case attempt = "Attempt"
            case jobBookmark = "JobBookmark"
            case jobName = "JobName"
            case previousRunId = "PreviousRunId"
            case run = "Run"
            case runId = "RunId"
            case version = "Version"
        }
    }

    public struct JobBookmarksEncryption: AWSEncodableShape & AWSDecodableShape {
        /// The encryption mode to use for job bookmarks data.
        public let jobBookmarksEncryptionMode: JobBookmarksEncryptionMode?
        /// The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        public let kmsKeyArn: String?

        public init(jobBookmarksEncryptionMode: JobBookmarksEncryptionMode? = nil, kmsKeyArn: String? = nil) {
            self.jobBookmarksEncryptionMode = jobBookmarksEncryptionMode
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "arn:aws:kms:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case jobBookmarksEncryptionMode = "JobBookmarksEncryptionMode"
            case kmsKeyArn = "KmsKeyArn"
        }
    }

    public struct JobCommand: AWSEncodableShape & AWSDecodableShape {
        /// The name of the job command. For an Apache Spark ETL job, this must be glueetl. For a Python shell job, it must be pythonshell. For an Apache Spark streaming ETL job, this must be gluestreaming.
        public let name: String?
        /// The Python version being used to run a Python shell job. Allowed values are 2 or 3.
        public let pythonVersion: String?
        /// Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that runs a job.
        public let scriptLocation: String?

        public init(name: String? = nil, pythonVersion: String? = nil, scriptLocation: String? = nil) {
            self.name = name
            self.pythonVersion = pythonVersion
            self.scriptLocation = scriptLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.pythonVersion, name: "pythonVersion", parent: name, pattern: "^[2-3]$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case pythonVersion = "PythonVersion"
            case scriptLocation = "ScriptLocation"
        }
    }

    public struct JobNodeDetails: AWSDecodableShape {
        /// The information for the job runs represented by the job node.
        public let jobRuns: [JobRun]?

        public init(jobRuns: [JobRun]? = nil) {
            self.jobRuns = jobRuns
        }

        private enum CodingKeys: String, CodingKey {
            case jobRuns = "JobRuns"
        }
    }

    public struct JobRun: AWSDecodableShape {
        /// The job arguments associated with this run. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. For information about how to specify and consume your own job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the key-value pairs that Glue consumes to set up your job, see the Special Parameters Used by Glue topic in the developer guide.
        public let arguments: [String: String]?
        /// The number of the attempt to run this job.
        public let attempt: Int?
        /// The date and time that this job run completed.
        public let completedOn: Date?
        /// An error message associated with this job run.
        public let errorMessage: String?
        /// The amount of time (in seconds) that the job run consumed resources.
        public let executionTime: Int?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide. Jobs that are created without specifying a Glue version default to Glue 0.9.
        public let glueVersion: String?
        /// The ID of this job run.
        public let id: String?
        /// The name of the job definition being used in this run.
        public let jobName: String?
        /// The current state of the job run. For more information about the statuses of jobs that have terminated abnormally, see Glue Job Run Statuses.
        public let jobRunState: JobRunState?
        /// The last time that this job run was modified.
        public let lastModifiedOn: Date?
        /// The name of the log group for secure logging that can be server-side encrypted in Amazon CloudWatch using KMS. This name can be /aws-glue/jobs/, in which case the default encryption is NONE. If you add a role name and SecurityConfiguration name (in other words, /aws-glue/jobs-yourRoleName-yourSecurityConfigurationName/), then that security configuration is used to encrypt the log group.
        public let logGroupName: String?
        /// The number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
        public let maxCapacity: Double?
        /// Specifies configuration properties of a job run notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
        public let numberOfWorkers: Int?
        /// A list of predecessors to this job run.
        public let predecessorRuns: [Predecessor]?
        /// The ID of the previous run of this job. For example, the JobRunId specified in the StartJobRun action.
        public let previousRunId: String?
        /// The name of the SecurityConfiguration structure to be used with this job run.
        public let securityConfiguration: String?
        /// The date and time at which this job run was started.
        public let startedOn: Date?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.
        public let timeout: Int?
        /// The name of the trigger that started this job run.
        public let triggerName: String?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
        public let workerType: WorkerType?

        public init(arguments: [String: String]? = nil, attempt: Int? = nil, completedOn: Date? = nil, errorMessage: String? = nil, executionTime: Int? = nil, glueVersion: String? = nil, id: String? = nil, jobName: String? = nil, jobRunState: JobRunState? = nil, lastModifiedOn: Date? = nil, logGroupName: String? = nil, maxCapacity: Double? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, predecessorRuns: [Predecessor]? = nil, previousRunId: String? = nil, securityConfiguration: String? = nil, startedOn: Date? = nil, timeout: Int? = nil, triggerName: String? = nil, workerType: WorkerType? = nil) {
            self.arguments = arguments
            self.attempt = attempt
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.executionTime = executionTime
            self.glueVersion = glueVersion
            self.id = id
            self.jobName = jobName
            self.jobRunState = jobRunState
            self.lastModifiedOn = lastModifiedOn
            self.logGroupName = logGroupName
            self.maxCapacity = maxCapacity
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.predecessorRuns = predecessorRuns
            self.previousRunId = previousRunId
            self.securityConfiguration = securityConfiguration
            self.startedOn = startedOn
            self.timeout = timeout
            self.triggerName = triggerName
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case attempt = "Attempt"
            case completedOn = "CompletedOn"
            case errorMessage = "ErrorMessage"
            case executionTime = "ExecutionTime"
            case glueVersion = "GlueVersion"
            case id = "Id"
            case jobName = "JobName"
            case jobRunState = "JobRunState"
            case lastModifiedOn = "LastModifiedOn"
            case logGroupName = "LogGroupName"
            case maxCapacity = "MaxCapacity"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case predecessorRuns = "PredecessorRuns"
            case previousRunId = "PreviousRunId"
            case securityConfiguration = "SecurityConfiguration"
            case startedOn = "StartedOn"
            case timeout = "Timeout"
            case triggerName = "TriggerName"
            case workerType = "WorkerType"
        }
    }

    public struct JobUpdate: AWSEncodableShape {
        /// The JobCommand that runs this job (required).
        public let command: JobCommand?
        /// The connections used for this job.
        public let connections: ConnectionsList?
        /// The default arguments for this job. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the key-value pairs that Glue consumes to set up your job, see the Special Parameters Used by Glue topic in the developer guide.
        public let defaultArguments: [String: String]?
        /// Description of the job being defined.
        public let description: String?
        /// An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
        public let executionProperty: ExecutionProperty?
        /// Glue version determines the versions of Apache Spark and Python that Glue supports. The Python version indicates the version supported for jobs of type Spark.  For more information about the available Glue versions and corresponding Spark and Python versions, see Glue version in the developer guide.
        public let glueVersion: String?
        /// This field is reserved for future use.
        public let logUri: String?
        /// For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl") or Apache Spark streaming ETL job (JobCommand.Name="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.   For Glue version 2.0 jobs, you cannot instead specify a Maximum capacity. Instead, you should specify a Worker type and the Number of workers.
        public let maxCapacity: Double?
        /// The maximum number of times to retry this job if it fails.
        public let maxRetries: Int?
        /// Non-overridable arguments for this job, specified as name-value pairs.
        public let nonOverridableArguments: [String: String]?
        /// Specifies the configuration properties of a job notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
        public let numberOfWorkers: Int?
        /// The name or Amazon Resource Name (ARN) of the IAM role associated with this job (required).
        public let role: String?
        /// The name of the SecurityConfiguration structure to be used with this job.
        public let securityConfiguration: String?
        /// The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.   For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for memory-intensive jobs.
        public let workerType: WorkerType?

        public init(command: JobCommand? = nil, connections: ConnectionsList? = nil, defaultArguments: [String: String]? = nil, description: String? = nil, executionProperty: ExecutionProperty? = nil, glueVersion: String? = nil, logUri: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, nonOverridableArguments: [String: String]? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, role: String? = nil, securityConfiguration: String? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.command = command
            self.connections = connections
            self.defaultArguments = defaultArguments
            self.description = description
            self.executionProperty = executionProperty
            self.glueVersion = glueVersion
            self.logUri = logUri
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.nonOverridableArguments = nonOverridableArguments
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.role = role
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.command?.validate(name: "\(name).command")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^\\w+\\.\\w+$")
            try self.notificationProperty?.validate(name: "\(name).notificationProperty")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case connections = "Connections"
            case defaultArguments = "DefaultArguments"
            case description = "Description"
            case executionProperty = "ExecutionProperty"
            case glueVersion = "GlueVersion"
            case logUri = "LogUri"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case nonOverridableArguments = "NonOverridableArguments"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case role = "Role"
            case securityConfiguration = "SecurityConfiguration"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct JsonClassifier: AWSDecodableShape {
        /// The time that this classifier was registered.
        public let creationTime: Date?
        /// A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
        public let jsonPath: String
        /// The time that this classifier was last updated.
        public let lastUpdated: Date?
        /// The name of the classifier.
        public let name: String
        /// The version of this classifier.
        public let version: Int64?

        public init(creationTime: Date? = nil, jsonPath: String, lastUpdated: Date? = nil, name: String, version: Int64? = nil) {
            self.creationTime = creationTime
            self.jsonPath = jsonPath
            self.lastUpdated = lastUpdated
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case jsonPath = "JsonPath"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct KeySchemaElement: AWSDecodableShape {
        /// The name of a partition key.
        public let name: String
        /// The type of a partition key.
        public let type: String

        public init(name: String, type: String) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct LabelingSetGenerationTaskRunProperties: AWSDecodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path where you will generate the labeling set.
        public let outputS3Path: String?

        public init(outputS3Path: String? = nil) {
            self.outputS3Path = outputS3Path
        }

        private enum CodingKeys: String, CodingKey {
            case outputS3Path = "OutputS3Path"
        }
    }

    public struct LastCrawlInfo: AWSDecodableShape {
        /// If an error occurred, the error information about the last crawl.
        public let errorMessage: String?
        /// The log group for the last crawl.
        public let logGroup: String?
        /// The log stream for the last crawl.
        public let logStream: String?
        /// The prefix for a message about this crawl.
        public let messagePrefix: String?
        /// The time at which the crawl started.
        public let startTime: Date?
        /// Status of the last crawl.
        public let status: LastCrawlStatus?

        public init(errorMessage: String? = nil, logGroup: String? = nil, logStream: String? = nil, messagePrefix: String? = nil, startTime: Date? = nil, status: LastCrawlStatus? = nil) {
            self.errorMessage = errorMessage
            self.logGroup = logGroup
            self.logStream = logStream
            self.messagePrefix = messagePrefix
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case logGroup = "LogGroup"
            case logStream = "LogStream"
            case messagePrefix = "MessagePrefix"
            case startTime = "StartTime"
            case status = "Status"
        }
    }

    public struct LineageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether data lineage is enabled for the crawler. Valid values are:   ENABLE: enables data lineage for the crawler   DISABLE: disables data lineage for the crawler
        public let crawlerLineageSettings: CrawlerLineageSettings?

        public init(crawlerLineageSettings: CrawlerLineageSettings? = nil) {
            self.crawlerLineageSettings = crawlerLineageSettings
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerLineageSettings = "CrawlerLineageSettings"
        }
    }

    public struct ListCrawlersRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListCrawlersResponse: AWSDecodableShape {
        /// The names of all crawlers in the account, or the crawlers with the specified tags.
        public let crawlerNames: [String]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        public init(crawlerNames: [String]? = nil, nextToken: String? = nil) {
            self.crawlerNames = crawlerNames
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerNames = "CrawlerNames"
            case nextToken = "NextToken"
        }
    }

    public struct ListDevEndpointsRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListDevEndpointsResponse: AWSDecodableShape {
        /// The names of all the DevEndpoints in the account, or the DevEndpoints with the specified tags.
        public let devEndpointNames: [String]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        public init(devEndpointNames: [String]? = nil, nextToken: String? = nil) {
            self.devEndpointNames = devEndpointNames
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devEndpointNames = "DevEndpointNames"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListJobsResponse: AWSDecodableShape {
        /// The names of all jobs in the account, or the jobs with the specified tags.
        public let jobNames: [String]?
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?

        public init(jobNames: [String]? = nil, nextToken: String? = nil) {
            self.jobNames = jobNames
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobNames = "JobNames"
            case nextToken = "NextToken"
        }
    }

    public struct ListMLTransformsRequest: AWSEncodableShape {
        /// A TransformFilterCriteria used to filter the machine learning transforms.
        public let filter: TransformFilterCriteria?
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// A TransformSortCriteria used to sort the machine learning transforms.
        public let sort: TransformSortCriteria?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        public init(filter: TransformFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: TransformSortCriteria? = nil, tags: [String: String]? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sort = "Sort"
            case tags = "Tags"
        }
    }

    public struct ListMLTransformsResponse: AWSDecodableShape {
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?
        /// The identifiers of all the machine learning transforms in the account, or the machine learning transforms with the specified tags.
        public let transformIds: [String]

        public init(nextToken: String? = nil, transformIds: [String]) {
            self.nextToken = nextToken
            self.transformIds = transformIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case transformIds = "TransformIds"
        }
    }

    public struct ListRegistriesInput: AWSEncodableShape {
        /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListRegistriesResponse: AWSDecodableShape {
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?
        /// An array of RegistryDetailedListItem objects containing minimal details of each registry.
        public let registries: [RegistryListItem]?

        public init(nextToken: String? = nil, registries: [RegistryListItem]? = nil) {
            self.nextToken = nextToken
            self.registries = registries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case registries = "Registries"
        }
    }

    public struct ListSchemaVersionsInput: AWSEncodableShape {
        /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
        public let schemaId: SchemaId

        public init(maxResults: Int? = nil, nextToken: String? = nil, schemaId: SchemaId) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.schemaId = schemaId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.schemaId.validate(name: "\(name).schemaId")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case schemaId = "SchemaId"
        }
    }

    public struct ListSchemaVersionsResponse: AWSDecodableShape {
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?
        /// An array of SchemaVersionList objects containing details of each schema version.
        public let schemas: [SchemaVersionListItem]?

        public init(nextToken: String? = nil, schemas: [SchemaVersionListItem]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schemas = "Schemas"
        }
    }

    public struct ListSchemasInput: AWSEncodableShape {
        /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
        public let registryId: RegistryId?

        public init(maxResults: Int? = nil, nextToken: String? = nil, registryId: RegistryId? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.registryId?.validate(name: "\(name).registryId")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case registryId = "RegistryId"
        }
    }

    public struct ListSchemasResponse: AWSDecodableShape {
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?
        /// An array of SchemaListItem objects containing details of each schema.
        public let schemas: [SchemaListItem]?

        public init(nextToken: String? = nil, schemas: [SchemaListItem]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case schemas = "Schemas"
        }
    }

    public struct ListTriggersRequest: AWSEncodableShape {
        ///  The name of the job for which to retrieve triggers. The trigger that can start this job is returned. If there is no such trigger, all triggers are returned.
        public let dependentJobName: String?
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?
        /// Specifies to return only these tagged resources.
        public let tags: [String: String]?

        public init(dependentJobName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, tags: [String: String]? = nil) {
            self.dependentJobName = dependentJobName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, max: 255)
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, min: 1)
            try self.validate(self.dependentJobName, name: "dependentJobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dependentJobName = "DependentJobName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct ListTriggersResponse: AWSDecodableShape {
        /// A continuation token, if the returned list does not contain the last metric available.
        public let nextToken: String?
        /// The names of all triggers in the account, or the triggers with the specified tags.
        public let triggerNames: [String]?

        public init(nextToken: String? = nil, triggerNames: [String]? = nil) {
            self.nextToken = nextToken
            self.triggerNames = triggerNames
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case triggerNames = "TriggerNames"
        }
    }

    public struct ListWorkflowsRequest: AWSEncodableShape {
        /// The maximum size of a list to return.
        public let maxResults: Int?
        /// A continuation token, if this is a continuation request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListWorkflowsResponse: AWSDecodableShape {
        /// A continuation token, if not all workflow names have been returned.
        public let nextToken: String?
        /// List of names of workflows in the account.
        public let workflows: [String]?

        public init(nextToken: String? = nil, workflows: [String]? = nil) {
            self.nextToken = nextToken
            self.workflows = workflows
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case workflows = "Workflows"
        }
    }

    public struct Location: AWSEncodableShape {
        /// An Amazon DynamoDB table location.
        public let dynamoDB: [CodeGenNodeArg]?
        /// A JDBC location.
        public let jdbc: [CodeGenNodeArg]?
        /// An Amazon Simple Storage Service (Amazon S3) location.
        public let s3: [CodeGenNodeArg]?

        public init(dynamoDB: [CodeGenNodeArg]? = nil, jdbc: [CodeGenNodeArg]? = nil, s3: [CodeGenNodeArg]? = nil) {
            self.dynamoDB = dynamoDB
            self.jdbc = jdbc
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.validate(self.dynamoDB, name: "dynamoDB", parent: name, max: 50)
            try self.validate(self.dynamoDB, name: "dynamoDB", parent: name, min: 0)
            try self.validate(self.jdbc, name: "jdbc", parent: name, max: 50)
            try self.validate(self.jdbc, name: "jdbc", parent: name, min: 0)
            try self.validate(self.s3, name: "s3", parent: name, max: 50)
            try self.validate(self.s3, name: "s3", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dynamoDB = "DynamoDB"
            case jdbc = "Jdbc"
            case s3 = "S3"
        }
    }

    public struct LongColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The highest value in the column.
        public let maximumValue: Int64?
        /// The lowest value in the column.
        public let minimumValue: Int64?
        /// The number of distinct values in a column.
        public let numberOfDistinctValues: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        public init(maximumValue: Int64? = nil, minimumValue: Int64? = nil, numberOfDistinctValues: Int64, numberOfNulls: Int64) {
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfDistinctValues, name: "numberOfDistinctValues", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumValue = "MaximumValue"
            case minimumValue = "MinimumValue"
            case numberOfDistinctValues = "NumberOfDistinctValues"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct MLTransform: AWSDecodableShape {
        /// A timestamp. The time and date that this machine learning transform was created.
        public let createdOn: Date?
        /// A user-defined, long-form description text for the machine learning transform. Descriptions are not guaranteed to be unique and can be changed at any time.
        public let description: String?
        /// An EvaluationMetrics object. Evaluation metrics provide an estimate of the quality of your machine learning transform.
        public let evaluationMetrics: EvaluationMetrics?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see Glue Versions in the developer guide.
        public let glueVersion: String?
        /// A list of Glue table definitions used by the transform.
        public let inputRecordTables: [GlueTable]?
        /// A count identifier for the labeling files generated by Glue for this transform. As you create a better transform, you can iteratively download, label, and upload the labeling file.
        public let labelCount: Int?
        /// A timestamp. The last point in time when this machine learning transform was modified.
        public let lastModifiedOn: Date?
        /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.   MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.   If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.   If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.   If WorkerType is set, then NumberOfWorkers is required (and vice versa).    MaxCapacity and NumberOfWorkers must both be at least 1.   When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
        public let maxCapacity: Double?
        /// The maximum number of times to retry after an MLTaskRun of the machine learning transform fails.
        public let maxRetries: Int?
        /// A user-defined name for the machine learning transform. Names are not guaranteed unique and can be changed at any time.
        public let name: String?
        /// The number of workers of a defined workerType that are allocated when a task of the transform runs. If WorkerType is set, then NumberOfWorkers is required (and vice versa).
        public let numberOfWorkers: Int?
        /// A TransformParameters object. You can use parameters to tune (customize) the behavior of the machine learning transform by specifying what data it learns from and your preference on various tradeoffs (such as precious vs. recall, or accuracy vs. cost).
        public let parameters: TransformParameters?
        /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions required by the transform.    This role needs Glue service role permissions to allow access to resources in Glue. See Attach a Policy to IAM Users That Access Glue.   This role needs permission to your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and any libraries used by the task run for this transform.
        public let role: String?
        /// A map of key-value pairs representing the columns and data types that this transform can run against. Has an upper bound of 100 columns.
        public let schema: [SchemaColumn]?
        /// The current status of the machine learning transform.
        public let status: TransformStatusType?
        /// The timeout in minutes of the machine learning transform.
        public let timeout: Int?
        /// The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning transforms can access user data encrypted in Amazon S3 using KMS.
        public let transformEncryption: TransformEncryption?
        /// The unique transform ID that is generated for the machine learning transform. The ID is guaranteed to be unique and does not change.
        public let transformId: String?
        /// The type of predefined worker that is allocated when a task of this transform runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.    MaxCapacity is a mutually exclusive option with NumberOfWorkers and WorkerType.   If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set.   If MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set.   If WorkerType is set, then NumberOfWorkers is required (and vice versa).    MaxCapacity and NumberOfWorkers must both be at least 1.
        public let workerType: WorkerType?

        public init(createdOn: Date? = nil, description: String? = nil, evaluationMetrics: EvaluationMetrics? = nil, glueVersion: String? = nil, inputRecordTables: [GlueTable]? = nil, labelCount: Int? = nil, lastModifiedOn: Date? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String? = nil, numberOfWorkers: Int? = nil, parameters: TransformParameters? = nil, role: String? = nil, schema: [SchemaColumn]? = nil, status: TransformStatusType? = nil, timeout: Int? = nil, transformEncryption: TransformEncryption? = nil, transformId: String? = nil, workerType: WorkerType? = nil) {
            self.createdOn = createdOn
            self.description = description
            self.evaluationMetrics = evaluationMetrics
            self.glueVersion = glueVersion
            self.inputRecordTables = inputRecordTables
            self.labelCount = labelCount
            self.lastModifiedOn = lastModifiedOn
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.numberOfWorkers = numberOfWorkers
            self.parameters = parameters
            self.role = role
            self.schema = schema
            self.status = status
            self.timeout = timeout
            self.transformEncryption = transformEncryption
            self.transformId = transformId
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case createdOn = "CreatedOn"
            case description = "Description"
            case evaluationMetrics = "EvaluationMetrics"
            case glueVersion = "GlueVersion"
            case inputRecordTables = "InputRecordTables"
            case labelCount = "LabelCount"
            case lastModifiedOn = "LastModifiedOn"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case numberOfWorkers = "NumberOfWorkers"
            case parameters = "Parameters"
            case role = "Role"
            case schema = "Schema"
            case status = "Status"
            case timeout = "Timeout"
            case transformEncryption = "TransformEncryption"
            case transformId = "TransformId"
            case workerType = "WorkerType"
        }
    }

    public struct MLUserDataEncryption: AWSEncodableShape & AWSDecodableShape {
        /// The ID for the customer-provided KMS key.
        public let kmsKeyId: String?
        /// The encryption mode applied to user data. Valid values are:   DISABLED: encryption is disabled   SSEKMS: use of server-side encryption with Key Management Service (SSE-KMS) for user data stored in Amazon S3.
        public let mlUserDataEncryptionMode: MLUserDataEncryptionModeString

        public init(kmsKeyId: String? = nil, mlUserDataEncryptionMode: MLUserDataEncryptionModeString) {
            self.kmsKeyId = kmsKeyId
            self.mlUserDataEncryptionMode = mlUserDataEncryptionMode
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 255)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case mlUserDataEncryptionMode = "MlUserDataEncryptionMode"
        }
    }

    public struct MappingEntry: AWSEncodableShape & AWSDecodableShape {
        /// The source path.
        public let sourcePath: String?
        /// The name of the source table.
        public let sourceTable: String?
        /// The source type.
        public let sourceType: String?
        /// The target path.
        public let targetPath: String?
        /// The target table.
        public let targetTable: String?
        /// The target type.
        public let targetType: String?

        public init(sourcePath: String? = nil, sourceTable: String? = nil, sourceType: String? = nil, targetPath: String? = nil, targetTable: String? = nil, targetType: String? = nil) {
            self.sourcePath = sourcePath
            self.sourceTable = sourceTable
            self.sourceType = sourceType
            self.targetPath = targetPath
            self.targetTable = targetTable
            self.targetType = targetType
        }

        private enum CodingKeys: String, CodingKey {
            case sourcePath = "SourcePath"
            case sourceTable = "SourceTable"
            case sourceType = "SourceType"
            case targetPath = "TargetPath"
            case targetTable = "TargetTable"
            case targetType = "TargetType"
        }
    }

    public struct MetadataInfo: AWSDecodableShape {
        /// The time at which the entry was created.
        public let createdTime: String?
        /// The metadata key’s corresponding value.
        public let metadataValue: String?
        /// Other metadata belonging to the same metadata key.
        public let otherMetadataValueList: [OtherMetadataValueListItem]?

        public init(createdTime: String? = nil, metadataValue: String? = nil, otherMetadataValueList: [OtherMetadataValueListItem]? = nil) {
            self.createdTime = createdTime
            self.metadataValue = metadataValue
            self.otherMetadataValueList = otherMetadataValueList
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case metadataValue = "MetadataValue"
            case otherMetadataValueList = "OtherMetadataValueList"
        }
    }

    public struct MetadataKeyValuePair: AWSEncodableShape {
        /// A metadata key.
        public let metadataKey: String?
        /// A metadata key’s corresponding value.
        public let metadataValue: String?

        public init(metadataKey: String? = nil, metadataValue: String? = nil) {
            self.metadataKey = metadataKey
            self.metadataValue = metadataValue
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataKey, name: "metadataKey", parent: name, max: 128)
            try self.validate(self.metadataKey, name: "metadataKey", parent: name, min: 1)
            try self.validate(self.metadataKey, name: "metadataKey", parent: name, pattern: "[a-zA-Z0-9+-=._./@]+")
            try self.validate(self.metadataValue, name: "metadataValue", parent: name, max: 256)
            try self.validate(self.metadataValue, name: "metadataValue", parent: name, min: 1)
            try self.validate(self.metadataValue, name: "metadataValue", parent: name, pattern: "[a-zA-Z0-9+-=._./@]+")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataKey = "MetadataKey"
            case metadataValue = "MetadataValue"
        }
    }

    public struct MongoDBTarget: AWSEncodableShape & AWSDecodableShape {
        /// The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.
        public let connectionName: String?
        /// The path of the Amazon DocumentDB or MongoDB target (database/collection).
        public let path: String?
        /// Indicates whether to scan all the records, or to sample rows from the table. Scanning all the records can take a long time when the table is not a high throughput table. A value of true means to scan all records, while a value of false means to sample the records. If no value is specified, the value defaults to true.
        public let scanAll: Bool?

        public init(connectionName: String? = nil, path: String? = nil, scanAll: Bool? = nil) {
            self.connectionName = connectionName
            self.path = path
            self.scanAll = scanAll
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case path = "Path"
            case scanAll = "ScanAll"
        }
    }

    public struct Node: AWSDecodableShape {
        /// Details of the crawler when the node represents a crawler.
        public let crawlerDetails: CrawlerNodeDetails?
        /// Details of the Job when the node represents a Job.
        public let jobDetails: JobNodeDetails?
        /// The name of the Glue component represented by the node.
        public let name: String?
        /// Details of the Trigger when the node represents a Trigger.
        public let triggerDetails: TriggerNodeDetails?
        /// The type of Glue component represented by the node.
        public let type: NodeType?
        /// The unique Id assigned to the node within the workflow.
        public let uniqueId: String?

        public init(crawlerDetails: CrawlerNodeDetails? = nil, jobDetails: JobNodeDetails? = nil, name: String? = nil, triggerDetails: TriggerNodeDetails? = nil, type: NodeType? = nil, uniqueId: String? = nil) {
            self.crawlerDetails = crawlerDetails
            self.jobDetails = jobDetails
            self.name = name
            self.triggerDetails = triggerDetails
            self.type = type
            self.uniqueId = uniqueId
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerDetails = "CrawlerDetails"
            case jobDetails = "JobDetails"
            case name = "Name"
            case triggerDetails = "TriggerDetails"
            case type = "Type"
            case uniqueId = "UniqueId"
        }
    }

    public struct NotificationProperty: AWSEncodableShape & AWSDecodableShape {
        /// After a job run starts, the number of minutes to wait before sending a job run delay notification.
        public let notifyDelayAfter: Int?

        public init(notifyDelayAfter: Int? = nil) {
            self.notifyDelayAfter = notifyDelayAfter
        }

        public func validate(name: String) throws {
            try self.validate(self.notifyDelayAfter, name: "notifyDelayAfter", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case notifyDelayAfter = "NotifyDelayAfter"
        }
    }

    public struct Order: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let column: String
        /// Indicates that the column is sorted in ascending order (== 1), or in descending order (==0).
        public let sortOrder: Int

        public init(column: String, sortOrder: Int) {
            self.column = column
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.column, name: "column", parent: name, max: 255)
            try self.validate(self.column, name: "column", parent: name, min: 1)
            try self.validate(self.column, name: "column", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.sortOrder, name: "sortOrder", parent: name, max: 1)
            try self.validate(self.sortOrder, name: "sortOrder", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case sortOrder = "SortOrder"
        }
    }

    public struct OtherMetadataValueListItem: AWSDecodableShape {
        /// The time at which the entry was created.
        public let createdTime: String?
        /// The metadata key’s corresponding value for the other metadata belonging to the same metadata key.
        public let metadataValue: String?

        public init(createdTime: String? = nil, metadataValue: String? = nil) {
            self.createdTime = createdTime
            self.metadataValue = metadataValue
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case metadataValue = "MetadataValue"
        }
    }

    public struct Partition: AWSDecodableShape {
        /// The ID of the Data Catalog in which the partition resides.
        public let catalogId: String?
        /// The time at which the partition was created.
        public let creationTime: Date?
        /// The name of the catalog database in which to create the partition.
        public let databaseName: String?
        /// The last time at which the partition was accessed.
        public let lastAccessTime: Date?
        /// The last time at which column statistics were computed for this partition.
        public let lastAnalyzedTime: Date?
        /// These key-value pairs define partition parameters.
        public let parameters: [String: String]?
        /// Provides information about the physical location where the partition is stored.
        public let storageDescriptor: StorageDescriptor?
        /// The name of the database table in which to create the partition.
        public let tableName: String?
        /// The values of the partition.
        public let values: [String]?

        public init(catalogId: String? = nil, creationTime: Date? = nil, databaseName: String? = nil, lastAccessTime: Date? = nil, lastAnalyzedTime: Date? = nil, parameters: [String: String]? = nil, storageDescriptor: StorageDescriptor? = nil, tableName: String? = nil, values: [String]? = nil) {
            self.catalogId = catalogId
            self.creationTime = creationTime
            self.databaseName = databaseName
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.parameters = parameters
            self.storageDescriptor = storageDescriptor
            self.tableName = tableName
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case creationTime = "CreationTime"
            case databaseName = "DatabaseName"
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case parameters = "Parameters"
            case storageDescriptor = "StorageDescriptor"
            case tableName = "TableName"
            case values = "Values"
        }
    }

    public struct PartitionError: AWSDecodableShape {
        /// The details about the partition error.
        public let errorDetail: ErrorDetail?
        /// The values that define the partition.
        public let partitionValues: [String]?

        public init(errorDetail: ErrorDetail? = nil, partitionValues: [String]? = nil) {
            self.errorDetail = errorDetail
            self.partitionValues = partitionValues
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case partitionValues = "PartitionValues"
        }
    }

    public struct PartitionIndex: AWSEncodableShape {
        /// The name of the partition index.
        public let indexName: String
        /// The keys for the partition index.
        public let keys: [String]

        public init(indexName: String, keys: [String]) {
            self.indexName = indexName
            self.keys = keys
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, max: 255)
            try self.validate(self.indexName, name: "indexName", parent: name, min: 1)
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.keys.forEach {
                try validate($0, name: "keys[]", parent: name, max: 255)
                try validate($0, name: "keys[]", parent: name, min: 1)
                try validate($0, name: "keys[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.keys, name: "keys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case indexName = "IndexName"
            case keys = "Keys"
        }
    }

    public struct PartitionIndexDescriptor: AWSDecodableShape {
        /// A list of errors that can occur when registering partition indexes for an existing table.
        public let backfillErrors: [BackfillError]?
        /// The name of the partition index.
        public let indexName: String
        /// The status of the partition index.  The possible statuses are:   CREATING: The index is being created. When an index is in a CREATING state, the index or its table cannot be deleted.   ACTIVE: The index creation succeeds.   FAILED: The index creation fails.    DELETING: The index is deleted from the list of indexes.
        public let indexStatus: PartitionIndexStatus
        /// A list of one or more keys, as KeySchemaElement structures, for the partition index.
        public let keys: [KeySchemaElement]

        public init(backfillErrors: [BackfillError]? = nil, indexName: String, indexStatus: PartitionIndexStatus, keys: [KeySchemaElement]) {
            self.backfillErrors = backfillErrors
            self.indexName = indexName
            self.indexStatus = indexStatus
            self.keys = keys
        }

        private enum CodingKeys: String, CodingKey {
            case backfillErrors = "BackfillErrors"
            case indexName = "IndexName"
            case indexStatus = "IndexStatus"
            case keys = "Keys"
        }
    }

    public struct PartitionInput: AWSEncodableShape {
        /// The last time at which the partition was accessed.
        public let lastAccessTime: Date?
        /// The last time at which column statistics were computed for this partition.
        public let lastAnalyzedTime: Date?
        /// These key-value pairs define partition parameters.
        public let parameters: [String: String]?
        /// Provides information about the physical location where the partition is stored.
        public let storageDescriptor: StorageDescriptor?
        /// The values of the partition. Although this parameter is not required by the SDK, you must specify this parameter for a valid input. The values for the keys for the new partition must be passed as an array of String objects that must be ordered in the same order as the partition keys appearing in the Amazon S3 prefix. Otherwise Glue will add the values to the wrong keys.
        public let values: [String]?

        public init(lastAccessTime: Date? = nil, lastAnalyzedTime: Date? = nil, parameters: [String: String]? = nil, storageDescriptor: StorageDescriptor? = nil, values: [String]? = nil) {
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.parameters = parameters
            self.storageDescriptor = storageDescriptor
            self.values = values
        }

        public func validate(name: String) throws {
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512_000)
            }
            try self.storageDescriptor?.validate(name: "\(name).storageDescriptor")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case parameters = "Parameters"
            case storageDescriptor = "StorageDescriptor"
            case values = "Values"
        }
    }

    public struct PartitionValueList: AWSEncodableShape & AWSDecodableShape {
        /// The list of values.
        public let values: [String]

        public init(values: [String]) {
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct PhysicalConnectionRequirements: AWSEncodableShape & AWSDecodableShape {
        /// The connection's Availability Zone. This field is redundant because the specified subnet implies the Availability Zone to be used. Currently the field must be populated, but it will be deprecated in the future.
        public let availabilityZone: String?
        /// The security group ID list used by the connection.
        public let securityGroupIdList: [String]?
        /// The subnet ID used by the connection.
        public let subnetId: String?

        public init(availabilityZone: String? = nil, securityGroupIdList: [String]? = nil, subnetId: String? = nil) {
            self.availabilityZone = availabilityZone
            self.securityGroupIdList = securityGroupIdList
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, max: 255)
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, min: 1)
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.securityGroupIdList?.forEach {
                try validate($0, name: "securityGroupIdList[]", parent: name, max: 255)
                try validate($0, name: "securityGroupIdList[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIdList[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.securityGroupIdList, name: "securityGroupIdList", parent: name, max: 50)
            try self.validate(self.securityGroupIdList, name: "securityGroupIdList", parent: name, min: 0)
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 255)
            try self.validate(self.subnetId, name: "subnetId", parent: name, min: 1)
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case securityGroupIdList = "SecurityGroupIdList"
            case subnetId = "SubnetId"
        }
    }

    public struct Predecessor: AWSDecodableShape {
        /// The name of the job definition used by the predecessor job run.
        public let jobName: String?
        /// The job-run ID of the predecessor job run.
        public let runId: String?

        public init(jobName: String? = nil, runId: String? = nil) {
            self.jobName = jobName
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case runId = "RunId"
        }
    }

    public struct Predicate: AWSEncodableShape & AWSDecodableShape {
        /// A list of the conditions that determine when the trigger will fire.
        public let conditions: [Condition]?
        /// An optional field if only one condition is listed. If multiple conditions are listed, then this field is required.
        public let logical: Logical?

        public init(conditions: [Condition]? = nil, logical: Logical? = nil) {
            self.conditions = conditions
            self.logical = logical
        }

        public func validate(name: String) throws {
            try self.conditions?.forEach {
                try $0.validate(name: "\(name).conditions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case conditions = "Conditions"
            case logical = "Logical"
        }
    }

    public struct PrincipalPermissions: AWSEncodableShape & AWSDecodableShape {
        /// The permissions that are granted to the principal.
        public let permissions: [Permission]?
        /// The principal who is granted permissions.
        public let principal: DataLakePrincipal?

        public init(permissions: [Permission]? = nil, principal: DataLakePrincipal? = nil) {
            self.permissions = permissions
            self.principal = principal
        }

        public func validate(name: String) throws {
            try self.principal?.validate(name: "\(name).principal")
        }

        private enum CodingKeys: String, CodingKey {
            case permissions = "Permissions"
            case principal = "Principal"
        }
    }

    public struct PropertyPredicate: AWSEncodableShape {
        /// The comparator used to compare this property to others.
        public let comparator: Comparator?
        /// The key of the property.
        public let key: String?
        /// The value of the property.
        public let value: String?

        public init(comparator: Comparator? = nil, key: String? = nil, value: String? = nil) {
            self.comparator = comparator
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case comparator = "Comparator"
            case key = "Key"
            case value = "Value"
        }
    }

    public struct PutDataCatalogEncryptionSettingsRequest: AWSEncodableShape {
        /// The ID of the Data Catalog to set the security configuration for. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The security configuration to set.
        public let dataCatalogEncryptionSettings: DataCatalogEncryptionSettings

        public init(catalogId: String? = nil, dataCatalogEncryptionSettings: DataCatalogEncryptionSettings) {
            self.catalogId = catalogId
            self.dataCatalogEncryptionSettings = dataCatalogEncryptionSettings
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.dataCatalogEncryptionSettings.validate(name: "\(name).dataCatalogEncryptionSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case dataCatalogEncryptionSettings = "DataCatalogEncryptionSettings"
        }
    }

    public struct PutDataCatalogEncryptionSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// If 'TRUE', indicates that you are using both methods to grant cross-account access to Data Catalog resources:   By directly updating the resource policy with PutResourePolicy    By using the Grant permissions command on the Management Console.   Must be set to 'TRUE' if you have already used the Management Console to grant cross-account access, otherwise the call fails. Default is 'FALSE'.
        public let enableHybrid: EnableHybridValues?
        /// A value of MUST_EXIST is used to update a policy. A value of NOT_EXIST is used to create a new policy. If a value of NONE or a null value is used, the call does not depend on the existence of a policy.
        public let policyExistsCondition: ExistCondition?
        /// The hash value returned when the previous policy was set using PutResourcePolicy. Its purpose is to prevent concurrent modifications of a policy. Do not use this parameter if no previous policy has been set.
        public let policyHashCondition: String?
        /// Contains the policy document to set, in JSON format.
        public let policyInJson: String
        /// Do not use. For internal use only.
        public let resourceArn: String?

        public init(enableHybrid: EnableHybridValues? = nil, policyExistsCondition: ExistCondition? = nil, policyHashCondition: String? = nil, policyInJson: String, resourceArn: String? = nil) {
            self.enableHybrid = enableHybrid
            self.policyExistsCondition = policyExistsCondition
            self.policyHashCondition = policyHashCondition
            self.policyInJson = policyInJson
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, max: 255)
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, min: 1)
            try self.validate(self.policyHashCondition, name: "policyHashCondition", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.policyInJson, name: "policyInJson", parent: name, max: 10240)
            try self.validate(self.policyInJson, name: "policyInJson", parent: name, min: 2)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws:glue:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case enableHybrid = "EnableHybrid"
            case policyExistsCondition = "PolicyExistsCondition"
            case policyHashCondition = "PolicyHashCondition"
            case policyInJson = "PolicyInJson"
            case resourceArn = "ResourceArn"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        /// A hash of the policy that has just been set. This must be included in a subsequent call that overwrites or updates this policy.
        public let policyHash: String?

        public init(policyHash: String? = nil) {
            self.policyHash = policyHash
        }

        private enum CodingKeys: String, CodingKey {
            case policyHash = "PolicyHash"
        }
    }

    public struct PutSchemaVersionMetadataInput: AWSEncodableShape {
        /// The metadata key's corresponding value.
        public let metadataKeyValue: MetadataKeyValuePair
        /// The unique ID for the schema.
        public let schemaId: SchemaId?
        /// The unique version ID of the schema version.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let schemaVersionNumber: SchemaVersionNumber?

        public init(metadataKeyValue: MetadataKeyValuePair, schemaId: SchemaId? = nil, schemaVersionId: String? = nil, schemaVersionNumber: SchemaVersionNumber? = nil) {
            self.metadataKeyValue = metadataKeyValue
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.metadataKeyValue.validate(name: "\(name).metadataKeyValue")
            try self.schemaId?.validate(name: "\(name).schemaId")
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
            try self.schemaVersionNumber?.validate(name: "\(name).schemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataKeyValue = "MetadataKeyValue"
            case schemaId = "SchemaId"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct PutSchemaVersionMetadataResponse: AWSDecodableShape {
        /// The latest version of the schema.
        public let latestVersion: Bool?
        /// The metadata key.
        public let metadataKey: String?
        /// The value of the metadata key.
        public let metadataValue: String?
        /// The name for the registry.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) for the schema.
        public let schemaArn: String?
        /// The name for the schema.
        public let schemaName: String?
        /// The unique version ID of the schema version.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let versionNumber: Int64?

        public init(latestVersion: Bool? = nil, metadataKey: String? = nil, metadataValue: String? = nil, registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersionId: String? = nil, versionNumber: Int64? = nil) {
            self.latestVersion = latestVersion
            self.metadataKey = metadataKey
            self.metadataValue = metadataValue
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersionId = schemaVersionId
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case latestVersion = "LatestVersion"
            case metadataKey = "MetadataKey"
            case metadataValue = "MetadataValue"
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersionId = "SchemaVersionId"
            case versionNumber = "VersionNumber"
        }
    }

    public struct PutWorkflowRunPropertiesRequest: AWSEncodableShape {
        /// Name of the workflow which was run.
        public let name: String
        /// The ID of the workflow run for which the run properties should be updated.
        public let runId: String
        /// The properties to put for the specified run.
        public let runProperties: [String: String]

        public init(name: String, runId: String, runProperties: [String: String]) {
            self.name = name
            self.runId = runId
            self.runProperties = runProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.runProperties.forEach {
                try validate($0.key, name: "runProperties.key", parent: name, max: 255)
                try validate($0.key, name: "runProperties.key", parent: name, min: 1)
                try validate($0.key, name: "runProperties.key", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case runId = "RunId"
            case runProperties = "RunProperties"
        }
    }

    public struct PutWorkflowRunPropertiesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct QuerySchemaVersionMetadataInput: AWSEncodableShape {
        /// Maximum number of results required per page. If the value is not supplied, this will be defaulted to 25 per page.
        public let maxResults: Int?
        /// Search key-value pairs for metadata, if they are not provided all the metadata information will be fetched.
        public let metadataList: [MetadataKeyValuePair]?
        /// A continuation token, if this is a continuation call.
        public let nextToken: String?
        /// A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
        public let schemaId: SchemaId?
        /// The unique version ID of the schema version.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let schemaVersionNumber: SchemaVersionNumber?

        public init(maxResults: Int? = nil, metadataList: [MetadataKeyValuePair]? = nil, nextToken: String? = nil, schemaId: SchemaId? = nil, schemaVersionId: String? = nil, schemaVersionNumber: SchemaVersionNumber? = nil) {
            self.maxResults = maxResults
            self.metadataList = metadataList
            self.nextToken = nextToken
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.metadataList?.forEach {
                try $0.validate(name: "\(name).metadataList[]")
            }
            try self.schemaId?.validate(name: "\(name).schemaId")
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
            try self.schemaVersionNumber?.validate(name: "\(name).schemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case metadataList = "MetadataList"
            case nextToken = "NextToken"
            case schemaId = "SchemaId"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct QuerySchemaVersionMetadataResponse: AWSDecodableShape {
        /// A map of a metadata key and associated values.
        public let metadataInfoMap: [String: MetadataInfo]?
        /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
        public let nextToken: String?
        /// The unique version ID of the schema version.
        public let schemaVersionId: String?

        public init(metadataInfoMap: [String: MetadataInfo]? = nil, nextToken: String? = nil, schemaVersionId: String? = nil) {
            self.metadataInfoMap = metadataInfoMap
            self.nextToken = nextToken
            self.schemaVersionId = schemaVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case metadataInfoMap = "MetadataInfoMap"
            case nextToken = "NextToken"
            case schemaVersionId = "SchemaVersionId"
        }
    }

    public struct RecrawlPolicy: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run. A value of CRAWL_EVERYTHING specifies crawling the entire dataset again. A value of CRAWL_NEW_FOLDERS_ONLY specifies crawling only folders that were added since the last crawler run.
        public let recrawlBehavior: RecrawlBehavior?

        public init(recrawlBehavior: RecrawlBehavior? = nil) {
            self.recrawlBehavior = recrawlBehavior
        }

        private enum CodingKeys: String, CodingKey {
            case recrawlBehavior = "RecrawlBehavior"
        }
    }

    public struct RegisterSchemaVersionInput: AWSEncodableShape {
        /// The schema definition using the DataFormat setting for the SchemaName.
        public let schemaDefinition: String
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.   SchemaId$SchemaName: The name of the schema. Either SchemaArn or SchemaName and RegistryName has to be provided.
        public let schemaId: SchemaId

        public init(schemaDefinition: String, schemaId: SchemaId) {
            self.schemaDefinition = schemaDefinition
            self.schemaId = schemaId
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, max: 170_000)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, min: 1)
            try self.validate(self.schemaDefinition, name: "schemaDefinition", parent: name, pattern: ".*\\S.*")
            try self.schemaId.validate(name: "\(name).schemaId")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaDefinition = "SchemaDefinition"
            case schemaId = "SchemaId"
        }
    }

    public struct RegisterSchemaVersionResponse: AWSDecodableShape {
        /// The unique ID that represents the version of this schema.
        public let schemaVersionId: String?
        /// The status of the schema version.
        public let status: SchemaVersionStatus?
        /// The version of this schema (for sync flow only, in case this is the first version).
        public let versionNumber: Int64?

        public init(schemaVersionId: String? = nil, status: SchemaVersionStatus? = nil, versionNumber: Int64? = nil) {
            self.schemaVersionId = schemaVersionId
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case schemaVersionId = "SchemaVersionId"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct RegistryId: AWSEncodableShape {
        /// Arn of the registry to be updated. One of RegistryArn or RegistryName has to be provided.
        public let registryArn: String?
        /// Name of the registry. Used only for lookup. One of RegistryArn or RegistryName has to be provided.
        public let registryName: String?

        public init(registryArn: String? = nil, registryName: String? = nil) {
            self.registryArn = registryArn
            self.registryName = registryName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryArn, name: "registryArn", parent: name, max: 10240)
            try self.validate(self.registryArn, name: "registryArn", parent: name, min: 1)
            try self.validate(self.registryArn, name: "registryArn", parent: name, pattern: "arn:aws:glue:.*")
            try self.validate(self.registryName, name: "registryName", parent: name, max: 255)
            try self.validate(self.registryName, name: "registryName", parent: name, min: 1)
            try self.validate(self.registryName, name: "registryName", parent: name, pattern: "[a-zA-Z0-9-_$#.]+")
        }

        private enum CodingKeys: String, CodingKey {
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
        }
    }

    public struct RegistryListItem: AWSDecodableShape {
        /// The data the registry was created.
        public let createdTime: String?
        /// A description of the registry.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the registry.
        public let registryArn: String?
        /// The name of the registry.
        public let registryName: String?
        /// The status of the registry.
        public let status: RegistryStatus?
        /// The date the registry was updated.
        public let updatedTime: String?

        public init(createdTime: String? = nil, description: String? = nil, registryArn: String? = nil, registryName: String? = nil, status: RegistryStatus? = nil, updatedTime: String? = nil) {
            self.createdTime = createdTime
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
            self.status = status
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
            case status = "Status"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct RemoveSchemaVersionMetadataInput: AWSEncodableShape {
        /// The value of the metadata key.
        public let metadataKeyValue: MetadataKeyValuePair
        /// A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).
        public let schemaId: SchemaId?
        /// The unique version ID of the schema version.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let schemaVersionNumber: SchemaVersionNumber?

        public init(metadataKeyValue: MetadataKeyValuePair, schemaId: SchemaId? = nil, schemaVersionId: String? = nil, schemaVersionNumber: SchemaVersionNumber? = nil) {
            self.metadataKeyValue = metadataKeyValue
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.metadataKeyValue.validate(name: "\(name).metadataKeyValue")
            try self.schemaId?.validate(name: "\(name).schemaId")
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
            try self.schemaVersionNumber?.validate(name: "\(name).schemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataKeyValue = "MetadataKeyValue"
            case schemaId = "SchemaId"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct RemoveSchemaVersionMetadataResponse: AWSDecodableShape {
        /// The latest version of the schema.
        public let latestVersion: Bool?
        /// The metadata key.
        public let metadataKey: String?
        /// The value of the metadata key.
        public let metadataValue: String?
        /// The name of the registry.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The version ID for the schema version.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let versionNumber: Int64?

        public init(latestVersion: Bool? = nil, metadataKey: String? = nil, metadataValue: String? = nil, registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaVersionId: String? = nil, versionNumber: Int64? = nil) {
            self.latestVersion = latestVersion
            self.metadataKey = metadataKey
            self.metadataValue = metadataValue
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaVersionId = schemaVersionId
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case latestVersion = "LatestVersion"
            case metadataKey = "MetadataKey"
            case metadataValue = "MetadataValue"
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaVersionId = "SchemaVersionId"
            case versionNumber = "VersionNumber"
        }
    }

    public struct ResetJobBookmarkRequest: AWSEncodableShape {
        /// The name of the job in question.
        public let jobName: String
        /// The unique run identifier associated with this job run.
        public let runId: String?

        public init(jobName: String, runId: String? = nil) {
            self.jobName = jobName
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case runId = "RunId"
        }
    }

    public struct ResetJobBookmarkResponse: AWSDecodableShape {
        /// The reset bookmark entry.
        public let jobBookmarkEntry: JobBookmarkEntry?

        public init(jobBookmarkEntry: JobBookmarkEntry? = nil) {
            self.jobBookmarkEntry = jobBookmarkEntry
        }

        private enum CodingKeys: String, CodingKey {
            case jobBookmarkEntry = "JobBookmarkEntry"
        }
    }

    public struct ResourceUri: AWSEncodableShape & AWSDecodableShape {
        /// The type of the resource.
        public let resourceType: ResourceType?
        /// The URI for accessing the resource.
        public let uri: String?

        public init(resourceType: ResourceType? = nil, uri: String? = nil) {
            self.resourceType = resourceType
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "ResourceType"
            case uri = "Uri"
        }
    }

    public struct ResumeWorkflowRunRequest: AWSEncodableShape {
        /// The name of the workflow to resume.
        public let name: String
        /// A list of the node IDs for the nodes you want to restart. The nodes that are to be restarted must have a run attempt in the original run.
        public let nodeIds: [String]
        /// The ID of the workflow run to resume.
        public let runId: String

        public init(name: String, nodeIds: [String], runId: String) {
            self.name = name
            self.nodeIds = nodeIds
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.nodeIds.forEach {
                try validate($0, name: "nodeIds[]", parent: name, max: 255)
                try validate($0, name: "nodeIds[]", parent: name, min: 1)
                try validate($0, name: "nodeIds[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case nodeIds = "NodeIds"
            case runId = "RunId"
        }
    }

    public struct ResumeWorkflowRunResponse: AWSDecodableShape {
        /// A list of the node IDs for the nodes that were actually restarted.
        public let nodeIds: [String]?
        /// The new ID assigned to the resumed workflow run. Each resume of a workflow run will have a new run ID.
        public let runId: String?

        public init(nodeIds: [String]? = nil, runId: String? = nil) {
            self.nodeIds = nodeIds
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case nodeIds = "NodeIds"
            case runId = "RunId"
        }
    }

    public struct S3Encryption: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.
        public let kmsKeyArn: String?
        /// The encryption mode to use for Amazon S3 data.
        public let s3EncryptionMode: S3EncryptionMode?

        public init(kmsKeyArn: String? = nil, s3EncryptionMode: S3EncryptionMode? = nil) {
            self.kmsKeyArn = kmsKeyArn
            self.s3EncryptionMode = s3EncryptionMode
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "arn:aws:kms:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KmsKeyArn"
            case s3EncryptionMode = "S3EncryptionMode"
        }
    }

    public struct S3Target: AWSEncodableShape & AWSDecodableShape {
        /// The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon Virtual Private Cloud environment (Amazon VPC).
        public let connectionName: String?
        /// A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables with a Crawler.
        public let exclusions: [String]?
        /// The path to the Amazon S3 target.
        public let path: String?
        /// Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
        public let sampleSize: Int?

        public init(connectionName: String? = nil, exclusions: [String]? = nil, path: String? = nil, sampleSize: Int? = nil) {
            self.connectionName = connectionName
            self.exclusions = exclusions
            self.path = path
            self.sampleSize = sampleSize
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case exclusions = "Exclusions"
            case path = "Path"
            case sampleSize = "SampleSize"
        }
    }

    public struct Schedule: AWSDecodableShape {
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let scheduleExpression: String?
        /// The state of the schedule.
        public let state: ScheduleState?

        public init(scheduleExpression: String? = nil, state: ScheduleState? = nil) {
            self.scheduleExpression = scheduleExpression
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleExpression = "ScheduleExpression"
            case state = "State"
        }
    }

    public struct SchemaChangePolicy: AWSEncodableShape & AWSDecodableShape {
        /// The deletion behavior when the crawler finds a deleted object.
        public let deleteBehavior: DeleteBehavior?
        /// The update behavior when the crawler finds a changed schema.
        public let updateBehavior: UpdateBehavior?

        public init(deleteBehavior: DeleteBehavior? = nil, updateBehavior: UpdateBehavior? = nil) {
            self.deleteBehavior = deleteBehavior
            self.updateBehavior = updateBehavior
        }

        private enum CodingKeys: String, CodingKey {
            case deleteBehavior = "DeleteBehavior"
            case updateBehavior = "UpdateBehavior"
        }
    }

    public struct SchemaColumn: AWSEncodableShape & AWSDecodableShape {
        /// The type of data in the column.
        public let dataType: String?
        /// The name of the column.
        public let name: String?

        public init(dataType: String? = nil, name: String? = nil) {
            self.dataType = dataType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.dataType, name: "dataType", parent: name, max: 131_072)
            try self.validate(self.dataType, name: "dataType", parent: name, min: 0)
            try self.validate(self.dataType, name: "dataType", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "DataType"
            case name = "Name"
        }
    }

    public struct SchemaId: AWSEncodableShape & AWSDecodableShape {
        /// The name of the schema registry that contains the schema.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.
        public let schemaArn: String?
        /// The name of the schema. One of SchemaArn or SchemaName has to be provided.
        public let schemaName: String?

        public init(registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil) {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
        }

        public func validate(name: String) throws {
            try self.validate(self.registryName, name: "registryName", parent: name, max: 255)
            try self.validate(self.registryName, name: "registryName", parent: name, min: 1)
            try self.validate(self.registryName, name: "registryName", parent: name, pattern: "[a-zA-Z0-9-_$#.]+")
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, max: 10240)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, min: 1)
            try self.validate(self.schemaArn, name: "schemaArn", parent: name, pattern: "arn:aws:glue:.*")
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 255)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "[a-zA-Z0-9-_$#.]+")
        }

        private enum CodingKeys: String, CodingKey {
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
        }
    }

    public struct SchemaListItem: AWSDecodableShape {
        /// The date and time that a schema was created.
        public let createdTime: String?
        /// A description for the schema.
        public let description: String?
        /// the name of the registry where the schema resides.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) for the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?
        /// The status of the schema.
        public let schemaStatus: SchemaStatus?
        /// The date and time that a schema was updated.
        public let updatedTime: String?

        public init(createdTime: String? = nil, description: String? = nil, registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil, schemaStatus: SchemaStatus? = nil, updatedTime: String? = nil) {
            self.createdTime = createdTime
            self.description = description
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
            self.schemaStatus = schemaStatus
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case description = "Description"
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
            case schemaStatus = "SchemaStatus"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct SchemaReference: AWSEncodableShape & AWSDecodableShape {
        /// A structure that contains schema identity fields. Either this or the SchemaVersionId has to be provided.
        public let schemaId: SchemaId?
        /// The unique ID assigned to a version of the schema. Either this or the SchemaId has to be provided.
        public let schemaVersionId: String?
        /// The version number of the schema.
        public let schemaVersionNumber: Int64?

        public init(schemaId: SchemaId? = nil, schemaVersionId: String? = nil, schemaVersionNumber: Int64? = nil) {
            self.schemaId = schemaId
            self.schemaVersionId = schemaVersionId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.schemaId?.validate(name: "\(name).schemaId")
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, max: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, min: 36)
            try self.validate(self.schemaVersionId, name: "schemaVersionId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
            try self.validate(self.schemaVersionNumber, name: "schemaVersionNumber", parent: name, max: 100_000)
            try self.validate(self.schemaVersionNumber, name: "schemaVersionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case schemaId = "SchemaId"
            case schemaVersionId = "SchemaVersionId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct SchemaVersionErrorItem: AWSDecodableShape {
        /// The details of the error for the schema version.
        public let errorDetails: ErrorDetails?
        /// The version number of the schema.
        public let versionNumber: Int64?

        public init(errorDetails: ErrorDetails? = nil, versionNumber: Int64? = nil) {
            self.errorDetails = errorDetails
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetails = "ErrorDetails"
            case versionNumber = "VersionNumber"
        }
    }

    public struct SchemaVersionListItem: AWSDecodableShape {
        /// The date and time the schema version was created.
        public let createdTime: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The unique identifier of the schema version.
        public let schemaVersionId: String?
        /// The status of the schema version.
        public let status: SchemaVersionStatus?
        /// The version number of the schema.
        public let versionNumber: Int64?

        public init(createdTime: String? = nil, schemaArn: String? = nil, schemaVersionId: String? = nil, status: SchemaVersionStatus? = nil, versionNumber: Int64? = nil) {
            self.createdTime = createdTime
            self.schemaArn = schemaArn
            self.schemaVersionId = schemaVersionId
            self.status = status
            self.versionNumber = versionNumber
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case schemaArn = "SchemaArn"
            case schemaVersionId = "SchemaVersionId"
            case status = "Status"
            case versionNumber = "VersionNumber"
        }
    }

    public struct SchemaVersionNumber: AWSEncodableShape {
        /// The latest version available for the schema.
        public let latestVersion: Bool?
        /// The version number of the schema.
        public let versionNumber: Int64?

        public init(latestVersion: Bool? = nil, versionNumber: Int64? = nil) {
            self.latestVersion = latestVersion
            self.versionNumber = versionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, max: 100_000)
            try self.validate(self.versionNumber, name: "versionNumber", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case latestVersion = "LatestVersion"
            case versionNumber = "VersionNumber"
        }
    }

    public struct SearchTablesRequest: AWSEncodableShape {
        /// A unique identifier, consisting of  account_id .
        public let catalogId: String?
        /// A list of key-value pairs, and a comparator used to filter the search results. Returns all entities matching the predicate. The Comparator member of the PropertyPredicate struct is used only for time fields, and can be omitted for other field types. Also, when comparing string values, such as when Key=Name, a fuzzy match algorithm is used. The Key field (for example, the value of the Name field) is split on certain punctuation characters, for example, -, :, #, etc. into tokens. Then each token is exact-match compared with the Value member of PropertyPredicate. For example, if Key=Name and Value=link, tables named customer-link and xx-link-yy are returned, but xxlinkyy is not returned.
        public let filters: [PropertyPredicate]?
        /// The maximum number of tables to return in a single response.
        public let maxResults: Int?
        /// A continuation token, included if this is a continuation call.
        public let nextToken: String?
        /// Allows you to specify that you want to search the tables shared with your account. The allowable values are FOREIGN or ALL.    If set to FOREIGN, will search the tables shared with your account.    If set to ALL, will search the tables shared with your account, as well as the tables in yor local account.
        public let resourceShareType: ResourceShareType?
        /// A string used for a text search. Specifying a value in quotes filters based on an exact match to the value.
        public let searchText: String?
        /// A list of criteria for sorting the results by a field name, in an ascending or descending order.
        public let sortCriteria: [SortCriterion]?

        public init(catalogId: String? = nil, filters: [PropertyPredicate]? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceShareType: ResourceShareType? = nil, searchText: String? = nil, sortCriteria: [SortCriterion]? = nil) {
            self.catalogId = catalogId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceShareType = resourceShareType
            self.searchText = searchText
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.searchText, name: "searchText", parent: name, max: 1024)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 1)
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceShareType = "ResourceShareType"
            case searchText = "SearchText"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct SearchTablesResponse: AWSDecodableShape {
        /// A continuation token, present if the current list segment is not the last.
        public let nextToken: String?
        /// A list of the requested Table objects. The SearchTables response returns only the tables that you have access to.
        public let tableList: [Table]?

        public init(nextToken: String? = nil, tableList: [Table]? = nil) {
            self.nextToken = nextToken
            self.tableList = tableList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tableList = "TableList"
        }
    }

    public struct SecurityConfiguration: AWSDecodableShape {
        /// The time at which this security configuration was created.
        public let createdTimeStamp: Date?
        /// The encryption configuration associated with this security configuration.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The name of the security configuration.
        public let name: String?

        public init(createdTimeStamp: Date? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, name: String? = nil) {
            self.createdTimeStamp = createdTimeStamp
            self.encryptionConfiguration = encryptionConfiguration
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimeStamp = "CreatedTimeStamp"
            case encryptionConfiguration = "EncryptionConfiguration"
            case name = "Name"
        }
    }

    public struct Segment: AWSEncodableShape {
        /// The zero-based index number of the segment. For example, if the total number of segments is 4, SegmentNumber values range from 0 through 3.
        public let segmentNumber: Int
        /// The total number of segments.
        public let totalSegments: Int

        public init(segmentNumber: Int, totalSegments: Int) {
            self.segmentNumber = segmentNumber
            self.totalSegments = totalSegments
        }

        public func validate(name: String) throws {
            try self.validate(self.segmentNumber, name: "segmentNumber", parent: name, min: 0)
            try self.validate(self.totalSegments, name: "totalSegments", parent: name, max: 10)
            try self.validate(self.totalSegments, name: "totalSegments", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case segmentNumber = "SegmentNumber"
            case totalSegments = "TotalSegments"
        }
    }

    public struct SerDeInfo: AWSEncodableShape & AWSDecodableShape {
        /// Name of the SerDe.
        public let name: String?
        /// These key-value pairs define initialization parameters for the SerDe.
        public let parameters: [String: String]?
        /// Usually the class that implements the SerDe. An example is org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe.
        public let serializationLibrary: String?

        public init(name: String? = nil, parameters: [String: String]? = nil, serializationLibrary: String? = nil) {
            self.name = name
            self.parameters = parameters
            self.serializationLibrary = serializationLibrary
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512_000)
            }
            try self.validate(self.serializationLibrary, name: "serializationLibrary", parent: name, max: 255)
            try self.validate(self.serializationLibrary, name: "serializationLibrary", parent: name, min: 1)
            try self.validate(self.serializationLibrary, name: "serializationLibrary", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case parameters = "Parameters"
            case serializationLibrary = "SerializationLibrary"
        }
    }

    public struct SkewedInfo: AWSEncodableShape & AWSDecodableShape {
        /// A list of names of columns that contain skewed values.
        public let skewedColumnNames: [String]?
        /// A mapping of skewed values to the columns that contain them.
        public let skewedColumnValueLocationMaps: [String: String]?
        /// A list of values that appear so frequently as to be considered skewed.
        public let skewedColumnValues: [String]?

        public init(skewedColumnNames: [String]? = nil, skewedColumnValueLocationMaps: [String: String]? = nil, skewedColumnValues: [String]? = nil) {
            self.skewedColumnNames = skewedColumnNames
            self.skewedColumnValueLocationMaps = skewedColumnValueLocationMaps
            self.skewedColumnValues = skewedColumnValues
        }

        public func validate(name: String) throws {
            try self.skewedColumnNames?.forEach {
                try validate($0, name: "skewedColumnNames[]", parent: name, max: 255)
                try validate($0, name: "skewedColumnNames[]", parent: name, min: 1)
                try validate($0, name: "skewedColumnNames[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case skewedColumnNames = "SkewedColumnNames"
            case skewedColumnValueLocationMaps = "SkewedColumnValueLocationMaps"
            case skewedColumnValues = "SkewedColumnValues"
        }
    }

    public struct SortCriterion: AWSEncodableShape {
        /// The name of the field on which to sort.
        public let fieldName: String?
        /// An ascending or descending sort.
        public let sort: Sort?

        public init(fieldName: String? = nil, sort: Sort? = nil) {
            self.fieldName = fieldName
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "FieldName"
            case sort = "Sort"
        }
    }

    public struct StartCrawlerRequest: AWSEncodableShape {
        /// Name of the crawler to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartCrawlerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartCrawlerScheduleRequest: AWSEncodableShape {
        /// Name of the crawler to schedule.
        public let crawlerName: String

        public init(crawlerName: String) {
            self.crawlerName = crawlerName
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
        }
    }

    public struct StartCrawlerScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartExportLabelsTaskRunRequest: AWSEncodableShape {
        /// The Amazon S3 path where you export the labels.
        public let outputS3Path: String
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        public init(outputS3Path: String, transformId: String) {
            self.outputS3Path = outputS3Path
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case outputS3Path = "OutputS3Path"
            case transformId = "TransformId"
        }
    }

    public struct StartExportLabelsTaskRunResponse: AWSDecodableShape {
        /// The unique identifier for the task run.
        public let taskRunId: String?

        public init(taskRunId: String? = nil) {
            self.taskRunId = taskRunId
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
        }
    }

    public struct StartImportLabelsTaskRunRequest: AWSEncodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path from where you import the labels.
        public let inputS3Path: String
        /// Indicates whether to overwrite your existing labels.
        public let replaceAllLabels: Bool?
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        public init(inputS3Path: String, replaceAllLabels: Bool? = nil, transformId: String) {
            self.inputS3Path = inputS3Path
            self.replaceAllLabels = replaceAllLabels
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case inputS3Path = "InputS3Path"
            case replaceAllLabels = "ReplaceAllLabels"
            case transformId = "TransformId"
        }
    }

    public struct StartImportLabelsTaskRunResponse: AWSDecodableShape {
        /// The unique identifier for the task run.
        public let taskRunId: String?

        public init(taskRunId: String? = nil) {
            self.taskRunId = taskRunId
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
        }
    }

    public struct StartJobRunRequest: AWSEncodableShape {
        /// The job arguments specifically for this run. For this job run, they replace the default arguments set in the job definition itself. You can specify arguments here that your own job-execution script consumes, as well as arguments that Glue itself consumes. For information about how to specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide. For information about the key-value pairs that Glue consumes to set up your job, see the Special Parameters Used by Glue topic in the developer guide.
        public let arguments: [String: String]?
        /// The name of the job definition to use.
        public let jobName: String
        /// The ID of a previous JobRun to retry.
        public let jobRunId: String?
        /// The number of Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job, or an Apache Spark ETL job:   When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.   When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
        public let maxCapacity: Double?
        /// Specifies configuration properties of a job run notification.
        public let notificationProperty: NotificationProperty?
        /// The number of workers of a defined workerType that are allocated when a job runs. The maximum number of workers you can define are 299 for G.1X, and 149 for G.2X.
        public let numberOfWorkers: Int?
        /// The name of the SecurityConfiguration structure to be used with this job run.
        public let securityConfiguration: String?
        /// The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.
        public let timeout: Int?
        /// The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
        public let workerType: WorkerType?

        public init(arguments: [String: String]? = nil, jobName: String, jobRunId: String? = nil, maxCapacity: Double? = nil, notificationProperty: NotificationProperty? = nil, numberOfWorkers: Int? = nil, securityConfiguration: String? = nil, timeout: Int? = nil, workerType: WorkerType? = nil) {
            self.arguments = arguments
            self.jobName = jobName
            self.jobRunId = jobRunId
            self.maxCapacity = maxCapacity
            self.notificationProperty = notificationProperty
            self.numberOfWorkers = numberOfWorkers
            self.securityConfiguration = securityConfiguration
            self.timeout = timeout
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.jobRunId, name: "jobRunId", parent: name, max: 255)
            try self.validate(self.jobRunId, name: "jobRunId", parent: name, min: 1)
            try self.validate(self.jobRunId, name: "jobRunId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.notificationProperty?.validate(name: "\(name).notificationProperty")
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, max: 255)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, min: 1)
            try self.validate(self.securityConfiguration, name: "securityConfiguration", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "Arguments"
            case jobName = "JobName"
            case jobRunId = "JobRunId"
            case maxCapacity = "MaxCapacity"
            case notificationProperty = "NotificationProperty"
            case numberOfWorkers = "NumberOfWorkers"
            case securityConfiguration = "SecurityConfiguration"
            case timeout = "Timeout"
            case workerType = "WorkerType"
        }
    }

    public struct StartJobRunResponse: AWSDecodableShape {
        /// The ID assigned to this job run.
        public let jobRunId: String?

        public init(jobRunId: String? = nil) {
            self.jobRunId = jobRunId
        }

        private enum CodingKeys: String, CodingKey {
            case jobRunId = "JobRunId"
        }
    }

    public struct StartMLEvaluationTaskRunRequest: AWSEncodableShape {
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        public init(transformId: String) {
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct StartMLEvaluationTaskRunResponse: AWSDecodableShape {
        /// The unique identifier associated with this run.
        public let taskRunId: String?

        public init(taskRunId: String? = nil) {
            self.taskRunId = taskRunId
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
        }
    }

    public struct StartMLLabelingSetGenerationTaskRunRequest: AWSEncodableShape {
        /// The Amazon Simple Storage Service (Amazon S3) path where you generate the labeling set.
        public let outputS3Path: String
        /// The unique identifier of the machine learning transform.
        public let transformId: String

        public init(outputS3Path: String, transformId: String) {
            self.outputS3Path = outputS3Path
            self.transformId = transformId
        }

        public func validate(name: String) throws {
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case outputS3Path = "OutputS3Path"
            case transformId = "TransformId"
        }
    }

    public struct StartMLLabelingSetGenerationTaskRunResponse: AWSDecodableShape {
        /// The unique run identifier that is associated with this task run.
        public let taskRunId: String?

        public init(taskRunId: String? = nil) {
            self.taskRunId = taskRunId
        }

        private enum CodingKeys: String, CodingKey {
            case taskRunId = "TaskRunId"
        }
    }

    public struct StartTriggerRequest: AWSEncodableShape {
        /// The name of the trigger to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartTriggerResponse: AWSDecodableShape {
        /// The name of the trigger that was started.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartWorkflowRunRequest: AWSEncodableShape {
        /// The name of the workflow to start.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StartWorkflowRunResponse: AWSDecodableShape {
        /// An Id for the new run.
        public let runId: String?

        public init(runId: String? = nil) {
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case runId = "RunId"
        }
    }

    public struct StartingEventBatchCondition: AWSDecodableShape {
        /// Number of events in the batch.
        public let batchSize: Int?
        /// Duration of the batch window in seconds.
        public let batchWindow: Int?

        public init(batchSize: Int? = nil, batchWindow: Int? = nil) {
            self.batchSize = batchSize
            self.batchWindow = batchWindow
        }

        private enum CodingKeys: String, CodingKey {
            case batchSize = "BatchSize"
            case batchWindow = "BatchWindow"
        }
    }

    public struct StopCrawlerRequest: AWSEncodableShape {
        /// Name of the crawler to stop.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StopCrawlerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopCrawlerScheduleRequest: AWSEncodableShape {
        /// Name of the crawler whose schedule state to set.
        public let crawlerName: String

        public init(crawlerName: String) {
            self.crawlerName = crawlerName
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
        }
    }

    public struct StopCrawlerScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopTriggerRequest: AWSEncodableShape {
        /// The name of the trigger to stop.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StopTriggerResponse: AWSDecodableShape {
        /// The name of the trigger that was stopped.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct StopWorkflowRunRequest: AWSEncodableShape {
        /// The name of the workflow to stop.
        public let name: String
        /// The ID of the workflow run to stop.
        public let runId: String

        public init(name: String, runId: String) {
            self.name = name
            self.runId = runId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.runId, name: "runId", parent: name, max: 255)
            try self.validate(self.runId, name: "runId", parent: name, min: 1)
            try self.validate(self.runId, name: "runId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case runId = "RunId"
        }
    }

    public struct StopWorkflowRunResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StorageDescriptor: AWSEncodableShape & AWSDecodableShape {
        /// A list of reducer grouping columns, clustering columns, and bucketing columns in the table.
        public let bucketColumns: [String]?
        /// A list of the Columns in the table.
        public let columns: [Column]?
        ///  True if the data in the table is compressed, or False if not.
        public let compressed: Bool?
        /// The input format: SequenceFileInputFormat (binary), or TextInputFormat, or a custom format.
        public let inputFormat: String?
        /// The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
        public let location: String?
        /// Must be specified if the table contains any dimension columns.
        public let numberOfBuckets: Int?
        /// The output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat, or a custom format.
        public let outputFormat: String?
        /// The user-supplied properties in key-value form.
        public let parameters: [String: String]?
        /// An object that references a schema stored in the Glue Schema Registry. When creating a table, you can pass an empty list of columns for the schema, and instead use a schema reference.
        public let schemaReference: SchemaReference?
        /// The serialization/deserialization (SerDe) information.
        public let serdeInfo: SerDeInfo?
        /// The information about values that appear frequently in a column (skewed values).
        public let skewedInfo: SkewedInfo?
        /// A list specifying the sort order of each bucket in the table.
        public let sortColumns: [Order]?
        ///  True if the table data is stored in subdirectories, or False if not.
        public let storedAsSubDirectories: Bool?

        public init(bucketColumns: [String]? = nil, columns: [Column]? = nil, compressed: Bool? = nil, inputFormat: String? = nil, location: String? = nil, numberOfBuckets: Int? = nil, outputFormat: String? = nil, parameters: [String: String]? = nil, schemaReference: SchemaReference? = nil, serdeInfo: SerDeInfo? = nil, skewedInfo: SkewedInfo? = nil, sortColumns: [Order]? = nil, storedAsSubDirectories: Bool? = nil) {
            self.bucketColumns = bucketColumns
            self.columns = columns
            self.compressed = compressed
            self.inputFormat = inputFormat
            self.location = location
            self.numberOfBuckets = numberOfBuckets
            self.outputFormat = outputFormat
            self.parameters = parameters
            self.schemaReference = schemaReference
            self.serdeInfo = serdeInfo
            self.skewedInfo = skewedInfo
            self.sortColumns = sortColumns
            self.storedAsSubDirectories = storedAsSubDirectories
        }

        public func validate(name: String) throws {
            try self.bucketColumns?.forEach {
                try validate($0, name: "bucketColumns[]", parent: name, max: 255)
                try validate($0, name: "bucketColumns[]", parent: name, min: 1)
                try validate($0, name: "bucketColumns[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.validate(self.inputFormat, name: "inputFormat", parent: name, max: 128)
            try self.validate(self.inputFormat, name: "inputFormat", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.location, name: "location", parent: name, max: 2056)
            try self.validate(self.location, name: "location", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.outputFormat, name: "outputFormat", parent: name, max: 128)
            try self.validate(self.outputFormat, name: "outputFormat", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512_000)
            }
            try self.schemaReference?.validate(name: "\(name).schemaReference")
            try self.serdeInfo?.validate(name: "\(name).serdeInfo")
            try self.skewedInfo?.validate(name: "\(name).skewedInfo")
            try self.sortColumns?.forEach {
                try $0.validate(name: "\(name).sortColumns[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bucketColumns = "BucketColumns"
            case columns = "Columns"
            case compressed = "Compressed"
            case inputFormat = "InputFormat"
            case location = "Location"
            case numberOfBuckets = "NumberOfBuckets"
            case outputFormat = "OutputFormat"
            case parameters = "Parameters"
            case schemaReference = "SchemaReference"
            case serdeInfo = "SerdeInfo"
            case skewedInfo = "SkewedInfo"
            case sortColumns = "SortColumns"
            case storedAsSubDirectories = "StoredAsSubDirectories"
        }
    }

    public struct StringColumnStatisticsData: AWSEncodableShape & AWSDecodableShape {
        /// The average string length in the column.
        public let averageLength: Double
        /// The size of the longest string in the column.
        public let maximumLength: Int64
        /// The number of distinct values in a column.
        public let numberOfDistinctValues: Int64
        /// The number of null values in the column.
        public let numberOfNulls: Int64

        public init(averageLength: Double, maximumLength: Int64, numberOfDistinctValues: Int64, numberOfNulls: Int64) {
            self.averageLength = averageLength
            self.maximumLength = maximumLength
            self.numberOfDistinctValues = numberOfDistinctValues
            self.numberOfNulls = numberOfNulls
        }

        public func validate(name: String) throws {
            try self.validate(self.averageLength, name: "averageLength", parent: name, min: 0)
            try self.validate(self.maximumLength, name: "maximumLength", parent: name, min: 0)
            try self.validate(self.numberOfDistinctValues, name: "numberOfDistinctValues", parent: name, min: 0)
            try self.validate(self.numberOfNulls, name: "numberOfNulls", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case averageLength = "AverageLength"
            case maximumLength = "MaximumLength"
            case numberOfDistinctValues = "NumberOfDistinctValues"
            case numberOfNulls = "NumberOfNulls"
        }
    }

    public struct Table: AWSDecodableShape {
        /// The ID of the Data Catalog in which the table resides.
        public let catalogId: String?
        /// The person or entity who created the table.
        public let createdBy: String?
        /// The time when the table definition was created in the Data Catalog.
        public let createTime: Date?
        /// The name of the database where the table metadata resides. For Hive compatibility, this must be all lowercase.
        public let databaseName: String?
        /// A description of the table.
        public let description: String?
        /// Indicates whether the table has been registered with Lake Formation.
        public let isRegisteredWithLakeFormation: Bool?
        /// The last time that the table was accessed. This is usually taken from HDFS, and might not be reliable.
        public let lastAccessTime: Date?
        /// The last time that column statistics were computed for this table.
        public let lastAnalyzedTime: Date?
        /// The table name. For Hive compatibility, this must be entirely lowercase.
        public let name: String
        /// The owner of the table.
        public let owner: String?
        /// These key-value pairs define properties associated with the table.
        public let parameters: [String: String]?
        /// A list of columns by which the table is partitioned. Only primitive types are supported as partition keys. When you create a table used by Amazon Athena, and you do not specify any partitionKeys, you must at least set the value of partitionKeys to an empty list. For example:  "PartitionKeys": []
        public let partitionKeys: [Column]?
        /// The retention time for this table.
        public let retention: Int?
        /// A storage descriptor containing information about the physical storage of this table.
        public let storageDescriptor: StorageDescriptor?
        /// The type of this table (EXTERNAL_TABLE, VIRTUAL_VIEW, etc.).
        public let tableType: String?
        /// A TableIdentifier structure that describes a target table for resource linking.
        public let targetTable: TableIdentifier?
        /// The last time that the table was updated.
        public let updateTime: Date?
        /// If the table is a view, the expanded text of the view; otherwise null.
        public let viewExpandedText: String?
        /// If the table is a view, the original text of the view; otherwise null.
        public let viewOriginalText: String?

        public init(catalogId: String? = nil, createdBy: String? = nil, createTime: Date? = nil, databaseName: String? = nil, description: String? = nil, isRegisteredWithLakeFormation: Bool? = nil, lastAccessTime: Date? = nil, lastAnalyzedTime: Date? = nil, name: String, owner: String? = nil, parameters: [String: String]? = nil, partitionKeys: [Column]? = nil, retention: Int? = nil, storageDescriptor: StorageDescriptor? = nil, tableType: String? = nil, targetTable: TableIdentifier? = nil, updateTime: Date? = nil, viewExpandedText: String? = nil, viewOriginalText: String? = nil) {
            self.catalogId = catalogId
            self.createdBy = createdBy
            self.createTime = createTime
            self.databaseName = databaseName
            self.description = description
            self.isRegisteredWithLakeFormation = isRegisteredWithLakeFormation
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.retention = retention
            self.storageDescriptor = storageDescriptor
            self.tableType = tableType
            self.targetTable = targetTable
            self.updateTime = updateTime
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case createdBy = "CreatedBy"
            case createTime = "CreateTime"
            case databaseName = "DatabaseName"
            case description = "Description"
            case isRegisteredWithLakeFormation = "IsRegisteredWithLakeFormation"
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case name = "Name"
            case owner = "Owner"
            case parameters = "Parameters"
            case partitionKeys = "PartitionKeys"
            case retention = "Retention"
            case storageDescriptor = "StorageDescriptor"
            case tableType = "TableType"
            case targetTable = "TargetTable"
            case updateTime = "UpdateTime"
            case viewExpandedText = "ViewExpandedText"
            case viewOriginalText = "ViewOriginalText"
        }
    }

    public struct TableError: AWSDecodableShape {
        /// The details about the error.
        public let errorDetail: ErrorDetail?
        /// The name of the table. For Hive compatibility, this must be entirely lowercase.
        public let tableName: String?

        public init(errorDetail: ErrorDetail? = nil, tableName: String? = nil) {
            self.errorDetail = errorDetail
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case tableName = "TableName"
        }
    }

    public struct TableIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the Data Catalog in which the table resides.
        public let catalogId: String?
        /// The name of the catalog database that contains the target table.
        public let databaseName: String?
        /// The name of the target table.
        public let name: String?

        public init(catalogId: String? = nil, databaseName: String? = nil, name: String? = nil) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case name = "Name"
        }
    }

    public struct TableInput: AWSEncodableShape {
        /// A description of the table.
        public let description: String?
        /// The last time that the table was accessed.
        public let lastAccessTime: Date?
        /// The last time that column statistics were computed for this table.
        public let lastAnalyzedTime: Date?
        /// The table name. For Hive compatibility, this is folded to lowercase when it is stored.
        public let name: String
        /// The table owner.
        public let owner: String?
        /// These key-value pairs define properties associated with the table.
        public let parameters: [String: String]?
        /// A list of columns by which the table is partitioned. Only primitive types are supported as partition keys. When you create a table used by Amazon Athena, and you do not specify any partitionKeys, you must at least set the value of partitionKeys to an empty list. For example:  "PartitionKeys": []
        public let partitionKeys: [Column]?
        /// The retention time for this table.
        public let retention: Int?
        /// A storage descriptor containing information about the physical storage of this table.
        public let storageDescriptor: StorageDescriptor?
        /// The type of this table (EXTERNAL_TABLE, VIRTUAL_VIEW, etc.).
        public let tableType: String?
        /// A TableIdentifier structure that describes a target table for resource linking.
        public let targetTable: TableIdentifier?
        /// If the table is a view, the expanded text of the view; otherwise null.
        public let viewExpandedText: String?
        /// If the table is a view, the original text of the view; otherwise null.
        public let viewOriginalText: String?

        public init(description: String? = nil, lastAccessTime: Date? = nil, lastAnalyzedTime: Date? = nil, name: String, owner: String? = nil, parameters: [String: String]? = nil, partitionKeys: [Column]? = nil, retention: Int? = nil, storageDescriptor: StorageDescriptor? = nil, tableType: String? = nil, targetTable: TableIdentifier? = nil, viewExpandedText: String? = nil, viewOriginalText: String? = nil) {
            self.description = description
            self.lastAccessTime = lastAccessTime
            self.lastAnalyzedTime = lastAnalyzedTime
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.retention = retention
            self.storageDescriptor = storageDescriptor
            self.tableType = tableType
            self.targetTable = targetTable
            self.viewExpandedText = viewExpandedText
            self.viewOriginalText = viewOriginalText
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.owner, name: "owner", parent: name, max: 255)
            try self.validate(self.owner, name: "owner", parent: name, min: 1)
            try self.validate(self.owner, name: "owner", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 255)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 512_000)
            }
            try self.partitionKeys?.forEach {
                try $0.validate(name: "\(name).partitionKeys[]")
            }
            try self.validate(self.retention, name: "retention", parent: name, min: 0)
            try self.storageDescriptor?.validate(name: "\(name).storageDescriptor")
            try self.validate(self.tableType, name: "tableType", parent: name, max: 255)
            try self.targetTable?.validate(name: "\(name).targetTable")
            try self.validate(self.viewExpandedText, name: "viewExpandedText", parent: name, max: 409_600)
            try self.validate(self.viewOriginalText, name: "viewOriginalText", parent: name, max: 409_600)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastAccessTime = "LastAccessTime"
            case lastAnalyzedTime = "LastAnalyzedTime"
            case name = "Name"
            case owner = "Owner"
            case parameters = "Parameters"
            case partitionKeys = "PartitionKeys"
            case retention = "Retention"
            case storageDescriptor = "StorageDescriptor"
            case tableType = "TableType"
            case targetTable = "TargetTable"
            case viewExpandedText = "ViewExpandedText"
            case viewOriginalText = "ViewOriginalText"
        }
    }

    public struct TableVersion: AWSDecodableShape {
        /// The table in question.
        public let table: Table?
        /// The ID value that identifies this table version. A VersionId is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String?

        public init(table: Table? = nil, versionId: String? = nil) {
            self.table = table
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case table = "Table"
            case versionId = "VersionId"
        }
    }

    public struct TableVersionError: AWSDecodableShape {
        /// The details about the error.
        public let errorDetail: ErrorDetail?
        /// The name of the table in question.
        public let tableName: String?
        /// The ID value of the version in question. A VersionID is a string representation of an integer. Each version is incremented by 1.
        public let versionId: String?

        public init(errorDetail: ErrorDetail? = nil, tableName: String? = nil, versionId: String? = nil) {
            self.errorDetail = errorDetail
            self.tableName = tableName
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "ErrorDetail"
            case tableName = "TableName"
            case versionId = "VersionId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the Glue resource to which to add the tags. For more information about Glue resource ARNs, see the Glue ARN string pattern.
        public let resourceArn: String
        /// Tags to add to this resource.
        public let tagsToAdd: [String: String]

        public init(resourceArn: String, tagsToAdd: [String: String]) {
            self.resourceArn = resourceArn
            self.tagsToAdd = tagsToAdd
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws:glue:.*")
            try self.tagsToAdd.forEach {
                try validate($0.key, name: "tagsToAdd.key", parent: name, max: 128)
                try validate($0.key, name: "tagsToAdd.key", parent: name, min: 1)
                try validate($0.value, name: "tagsToAdd[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tagsToAdd[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagsToAdd = "TagsToAdd"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TaskRun: AWSDecodableShape {
        /// The last point in time that the requested task run was completed.
        public let completedOn: Date?
        /// The list of error strings associated with this task run.
        public let errorString: String?
        /// The amount of time (in seconds) that the task run consumed resources.
        public let executionTime: Int?
        /// The last point in time that the requested task run was updated.
        public let lastModifiedOn: Date?
        /// The names of the log group for secure logging, associated with this task run.
        public let logGroupName: String?
        /// Specifies configuration properties associated with this task run.
        public let properties: TaskRunProperties?
        /// The date and time that this task run started.
        public let startedOn: Date?
        /// The current status of the requested task run.
        public let status: TaskStatusType?
        /// The unique identifier for this task run.
        public let taskRunId: String?
        /// The unique identifier for the transform.
        public let transformId: String?

        public init(completedOn: Date? = nil, errorString: String? = nil, executionTime: Int? = nil, lastModifiedOn: Date? = nil, logGroupName: String? = nil, properties: TaskRunProperties? = nil, startedOn: Date? = nil, status: TaskStatusType? = nil, taskRunId: String? = nil, transformId: String? = nil) {
            self.completedOn = completedOn
            self.errorString = errorString
            self.executionTime = executionTime
            self.lastModifiedOn = lastModifiedOn
            self.logGroupName = logGroupName
            self.properties = properties
            self.startedOn = startedOn
            self.status = status
            self.taskRunId = taskRunId
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case errorString = "ErrorString"
            case executionTime = "ExecutionTime"
            case lastModifiedOn = "LastModifiedOn"
            case logGroupName = "LogGroupName"
            case properties = "Properties"
            case startedOn = "StartedOn"
            case status = "Status"
            case taskRunId = "TaskRunId"
            case transformId = "TransformId"
        }
    }

    public struct TaskRunFilterCriteria: AWSEncodableShape {
        /// Filter on task runs started after this date.
        public let startedAfter: Date?
        /// Filter on task runs started before this date.
        public let startedBefore: Date?
        /// The current status of the task run.
        public let status: TaskStatusType?
        /// The type of task run.
        public let taskRunType: TaskType?

        public init(startedAfter: Date? = nil, startedBefore: Date? = nil, status: TaskStatusType? = nil, taskRunType: TaskType? = nil) {
            self.startedAfter = startedAfter
            self.startedBefore = startedBefore
            self.status = status
            self.taskRunType = taskRunType
        }

        private enum CodingKeys: String, CodingKey {
            case startedAfter = "StartedAfter"
            case startedBefore = "StartedBefore"
            case status = "Status"
            case taskRunType = "TaskRunType"
        }
    }

    public struct TaskRunProperties: AWSDecodableShape {
        /// The configuration properties for an exporting labels task run.
        public let exportLabelsTaskRunProperties: ExportLabelsTaskRunProperties?
        /// The configuration properties for a find matches task run.
        public let findMatchesTaskRunProperties: FindMatchesTaskRunProperties?
        /// The configuration properties for an importing labels task run.
        public let importLabelsTaskRunProperties: ImportLabelsTaskRunProperties?
        /// The configuration properties for a labeling set generation task run.
        public let labelingSetGenerationTaskRunProperties: LabelingSetGenerationTaskRunProperties?
        /// The type of task run.
        public let taskType: TaskType?

        public init(exportLabelsTaskRunProperties: ExportLabelsTaskRunProperties? = nil, findMatchesTaskRunProperties: FindMatchesTaskRunProperties? = nil, importLabelsTaskRunProperties: ImportLabelsTaskRunProperties? = nil, labelingSetGenerationTaskRunProperties: LabelingSetGenerationTaskRunProperties? = nil, taskType: TaskType? = nil) {
            self.exportLabelsTaskRunProperties = exportLabelsTaskRunProperties
            self.findMatchesTaskRunProperties = findMatchesTaskRunProperties
            self.importLabelsTaskRunProperties = importLabelsTaskRunProperties
            self.labelingSetGenerationTaskRunProperties = labelingSetGenerationTaskRunProperties
            self.taskType = taskType
        }

        private enum CodingKeys: String, CodingKey {
            case exportLabelsTaskRunProperties = "ExportLabelsTaskRunProperties"
            case findMatchesTaskRunProperties = "FindMatchesTaskRunProperties"
            case importLabelsTaskRunProperties = "ImportLabelsTaskRunProperties"
            case labelingSetGenerationTaskRunProperties = "LabelingSetGenerationTaskRunProperties"
            case taskType = "TaskType"
        }
    }

    public struct TaskRunSortCriteria: AWSEncodableShape {
        /// The column to be used to sort the list of task runs for the machine learning transform.
        public let column: TaskRunSortColumnType
        /// The sort direction to be used to sort the list of task runs for the machine learning transform.
        public let sortDirection: SortDirectionType

        public init(column: TaskRunSortColumnType, sortDirection: SortDirectionType) {
            self.column = column
            self.sortDirection = sortDirection
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case sortDirection = "SortDirection"
        }
    }

    public struct TransformEncryption: AWSEncodableShape & AWSDecodableShape {
        /// An MLUserDataEncryption object containing the encryption mode and customer-provided KMS key ID.
        public let mlUserDataEncryption: MLUserDataEncryption?
        /// The name of the security configuration.
        public let taskRunSecurityConfigurationName: String?

        public init(mlUserDataEncryption: MLUserDataEncryption? = nil, taskRunSecurityConfigurationName: String? = nil) {
            self.mlUserDataEncryption = mlUserDataEncryption
            self.taskRunSecurityConfigurationName = taskRunSecurityConfigurationName
        }

        public func validate(name: String) throws {
            try self.mlUserDataEncryption?.validate(name: "\(name).mlUserDataEncryption")
            try self.validate(self.taskRunSecurityConfigurationName, name: "taskRunSecurityConfigurationName", parent: name, max: 255)
            try self.validate(self.taskRunSecurityConfigurationName, name: "taskRunSecurityConfigurationName", parent: name, min: 1)
            try self.validate(self.taskRunSecurityConfigurationName, name: "taskRunSecurityConfigurationName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case mlUserDataEncryption = "MlUserDataEncryption"
            case taskRunSecurityConfigurationName = "TaskRunSecurityConfigurationName"
        }
    }

    public struct TransformFilterCriteria: AWSEncodableShape {
        /// The time and date after which the transforms were created.
        public let createdAfter: Date?
        /// The time and date before which the transforms were created.
        public let createdBefore: Date?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see Glue Versions in the developer guide.
        public let glueVersion: String?
        /// Filter on transforms last modified after this date.
        public let lastModifiedAfter: Date?
        /// Filter on transforms last modified before this date.
        public let lastModifiedBefore: Date?
        /// A unique transform name that is used to filter the machine learning transforms.
        public let name: String?
        /// Filters on datasets with a specific schema. The Map&lt;Column, Type&gt; object is an array of key-value pairs representing the schema this transform accepts, where Column is the name of a column, and Type is the type of the data such as an integer or string. Has an upper bound of 100 columns.
        public let schema: [SchemaColumn]?
        /// Filters the list of machine learning transforms by the last known status of the transforms (to indicate whether a transform can be used or not). One of "NOT_READY", "READY", or "DELETING".
        public let status: TransformStatusType?
        /// The type of machine learning transform that is used to filter the machine learning transforms.
        public let transformType: TransformType?

        public init(createdAfter: Date? = nil, createdBefore: Date? = nil, glueVersion: String? = nil, lastModifiedAfter: Date? = nil, lastModifiedBefore: Date? = nil, name: String? = nil, schema: [SchemaColumn]? = nil, status: TransformStatusType? = nil, transformType: TransformType? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.glueVersion = glueVersion
            self.lastModifiedAfter = lastModifiedAfter
            self.lastModifiedBefore = lastModifiedBefore
            self.name = name
            self.schema = schema
            self.status = status
            self.transformType = transformType
        }

        public func validate(name: String) throws {
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^\\w+\\.\\w+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.schema?.forEach {
                try $0.validate(name: "\(name).schema[]")
            }
            try self.validate(self.schema, name: "schema", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
            case glueVersion = "GlueVersion"
            case lastModifiedAfter = "LastModifiedAfter"
            case lastModifiedBefore = "LastModifiedBefore"
            case name = "Name"
            case schema = "Schema"
            case status = "Status"
            case transformType = "TransformType"
        }
    }

    public struct TransformParameters: AWSEncodableShape & AWSDecodableShape {
        /// The parameters for the find matches algorithm.
        public let findMatchesParameters: FindMatchesParameters?
        /// The type of machine learning transform. For information about the types of machine learning transforms, see Creating Machine Learning Transforms.
        public let transformType: TransformType

        public init(findMatchesParameters: FindMatchesParameters? = nil, transformType: TransformType) {
            self.findMatchesParameters = findMatchesParameters
            self.transformType = transformType
        }

        public func validate(name: String) throws {
            try self.findMatchesParameters?.validate(name: "\(name).findMatchesParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case findMatchesParameters = "FindMatchesParameters"
            case transformType = "TransformType"
        }
    }

    public struct TransformSortCriteria: AWSEncodableShape {
        /// The column to be used in the sorting criteria that are associated with the machine learning transform.
        public let column: TransformSortColumnType
        /// The sort direction to be used in the sorting criteria that are associated with the machine learning transform.
        public let sortDirection: SortDirectionType

        public init(column: TransformSortColumnType, sortDirection: SortDirectionType) {
            self.column = column
            self.sortDirection = sortDirection
        }

        private enum CodingKeys: String, CodingKey {
            case column = "Column"
            case sortDirection = "SortDirection"
        }
    }

    public struct Trigger: AWSDecodableShape {
        /// The actions initiated by this trigger.
        public let actions: [Action]?
        /// A description of this trigger.
        public let description: String?
        /// Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.
        public let eventBatchingCondition: EventBatchingCondition?
        /// Reserved for future use.
        public let id: String?
        /// The name of the trigger.
        public let name: String?
        /// The predicate of this trigger, which defines when it will fire.
        public let predicate: Predicate?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// The current state of the trigger.
        public let state: TriggerState?
        /// The type of trigger that this is.
        public let type: TriggerType?
        /// The name of the workflow associated with the trigger.
        public let workflowName: String?

        public init(actions: [Action]? = nil, description: String? = nil, eventBatchingCondition: EventBatchingCondition? = nil, id: String? = nil, name: String? = nil, predicate: Predicate? = nil, schedule: String? = nil, state: TriggerState? = nil, type: TriggerType? = nil, workflowName: String? = nil) {
            self.actions = actions
            self.description = description
            self.eventBatchingCondition = eventBatchingCondition
            self.id = id
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
            self.state = state
            self.type = type
            self.workflowName = workflowName
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case eventBatchingCondition = "EventBatchingCondition"
            case id = "Id"
            case name = "Name"
            case predicate = "Predicate"
            case schedule = "Schedule"
            case state = "State"
            case type = "Type"
            case workflowName = "WorkflowName"
        }
    }

    public struct TriggerNodeDetails: AWSDecodableShape {
        /// The information of the trigger represented by the trigger node.
        public let trigger: Trigger?

        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public struct TriggerUpdate: AWSEncodableShape {
        /// The actions initiated by this trigger.
        public let actions: [Action]?
        /// A description of this trigger.
        public let description: String?
        /// Batch condition that must be met (specified number of events received or batch time window expired) before EventBridge event trigger fires.
        public let eventBatchingCondition: EventBatchingCondition?
        /// Reserved for future use.
        public let name: String?
        /// The predicate of this trigger, which defines when it will fire.
        public let predicate: Predicate?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?

        public init(actions: [Action]? = nil, description: String? = nil, eventBatchingCondition: EventBatchingCondition? = nil, name: String? = nil, predicate: Predicate? = nil, schedule: String? = nil) {
            self.actions = actions
            self.description = description
            self.eventBatchingCondition = eventBatchingCondition
            self.name = name
            self.predicate = predicate
            self.schedule = schedule
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.eventBatchingCondition?.validate(name: "\(name).eventBatchingCondition")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.predicate?.validate(name: "\(name).predicate")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case description = "Description"
            case eventBatchingCondition = "EventBatchingCondition"
            case name = "Name"
            case predicate = "Predicate"
            case schedule = "Schedule"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource from which to remove the tags.
        public let resourceArn: String
        /// Tags to remove from this resource.
        public let tagsToRemove: [String]

        public init(resourceArn: String, tagsToRemove: [String]) {
            self.resourceArn = resourceArn
            self.tagsToRemove = tagsToRemove
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 10240)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws:glue:.*")
            try self.tagsToRemove.forEach {
                try validate($0, name: "tagsToRemove[]", parent: name, max: 128)
                try validate($0, name: "tagsToRemove[]", parent: name, min: 1)
            }
            try self.validate(self.tagsToRemove, name: "tagsToRemove", parent: name, max: 50)
            try self.validate(self.tagsToRemove, name: "tagsToRemove", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagsToRemove = "TagsToRemove"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateClassifierRequest: AWSEncodableShape {
        /// A CsvClassifier object with updated fields.
        public let csvClassifier: UpdateCsvClassifierRequest?
        /// A GrokClassifier object with updated fields.
        public let grokClassifier: UpdateGrokClassifierRequest?
        /// A JsonClassifier object with updated fields.
        public let jsonClassifier: UpdateJsonClassifierRequest?
        /// An XMLClassifier object with updated fields.
        public let xMLClassifier: UpdateXMLClassifierRequest?

        public init(csvClassifier: UpdateCsvClassifierRequest? = nil, grokClassifier: UpdateGrokClassifierRequest? = nil, jsonClassifier: UpdateJsonClassifierRequest? = nil, xMLClassifier: UpdateXMLClassifierRequest? = nil) {
            self.csvClassifier = csvClassifier
            self.grokClassifier = grokClassifier
            self.jsonClassifier = jsonClassifier
            self.xMLClassifier = xMLClassifier
        }

        public func validate(name: String) throws {
            try self.csvClassifier?.validate(name: "\(name).csvClassifier")
            try self.grokClassifier?.validate(name: "\(name).grokClassifier")
            try self.jsonClassifier?.validate(name: "\(name).jsonClassifier")
            try self.xMLClassifier?.validate(name: "\(name).xMLClassifier")
        }

        private enum CodingKeys: String, CodingKey {
            case csvClassifier = "CsvClassifier"
            case grokClassifier = "GrokClassifier"
            case jsonClassifier = "JsonClassifier"
            case xMLClassifier = "XMLClassifier"
        }
    }

    public struct UpdateClassifierResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateColumnStatisticsForPartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A list of the column statistics.
        public let columnStatisticsList: [ColumnStatistics]
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// A list of partition values identifying the partition.
        public let partitionValues: [String]
        /// The name of the partitions' table.
        public let tableName: String

        public init(catalogId: String? = nil, columnStatisticsList: [ColumnStatistics], databaseName: String, partitionValues: [String], tableName: String) {
            self.catalogId = catalogId
            self.columnStatisticsList = columnStatisticsList
            self.databaseName = databaseName
            self.partitionValues = partitionValues
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.columnStatisticsList.forEach {
                try $0.validate(name: "\(name).columnStatisticsList[]")
            }
            try self.validate(self.columnStatisticsList, name: "columnStatisticsList", parent: name, max: 25)
            try self.validate(self.columnStatisticsList, name: "columnStatisticsList", parent: name, min: 0)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionValues.forEach {
                try validate($0, name: "partitionValues[]", parent: name, max: 1024)
            }
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnStatisticsList = "ColumnStatisticsList"
            case databaseName = "DatabaseName"
            case partitionValues = "PartitionValues"
            case tableName = "TableName"
        }
    }

    public struct UpdateColumnStatisticsForPartitionResponse: AWSDecodableShape {
        /// Error occurred during updating column statistics data.
        public let errors: [ColumnStatisticsError]?

        public init(errors: [ColumnStatisticsError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct UpdateColumnStatisticsForTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A list of the column statistics.
        public let columnStatisticsList: [ColumnStatistics]
        /// The name of the catalog database where the partitions reside.
        public let databaseName: String
        /// The name of the partitions' table.
        public let tableName: String

        public init(catalogId: String? = nil, columnStatisticsList: [ColumnStatistics], databaseName: String, tableName: String) {
            self.catalogId = catalogId
            self.columnStatisticsList = columnStatisticsList
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.columnStatisticsList.forEach {
                try $0.validate(name: "\(name).columnStatisticsList[]")
            }
            try self.validate(self.columnStatisticsList, name: "columnStatisticsList", parent: name, max: 25)
            try self.validate(self.columnStatisticsList, name: "columnStatisticsList", parent: name, min: 0)
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case columnStatisticsList = "ColumnStatisticsList"
            case databaseName = "DatabaseName"
            case tableName = "TableName"
        }
    }

    public struct UpdateColumnStatisticsForTableResponse: AWSDecodableShape {
        /// List of ColumnStatisticsErrors.
        public let errors: [ColumnStatisticsError]?

        public init(errors: [ColumnStatisticsError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
        }
    }

    public struct UpdateConnectionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A ConnectionInput object that redefines the connection in question.
        public let connectionInput: ConnectionInput
        /// The name of the connection definition to update.
        public let name: String

        public init(catalogId: String? = nil, connectionInput: ConnectionInput, name: String) {
            self.catalogId = catalogId
            self.connectionInput = connectionInput
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.connectionInput.validate(name: "\(name).connectionInput")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case connectionInput = "ConnectionInput"
            case name = "Name"
        }
    }

    public struct UpdateConnectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCrawlerRequest: AWSEncodableShape {
        /// A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
        public let classifiers: [String]?
        /// Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
        public let configuration: String?
        /// The name of the SecurityConfiguration structure to be used by this crawler.
        public let crawlerSecurityConfiguration: String?
        /// The Glue database where results are stored, such as: arn:aws:daylight:us-east-1::database/sometable/*.
        public let databaseName: String?
        /// A description of the new crawler.
        public let description: String?
        /// Specifies data lineage configuration settings for the crawler.
        public let lineageConfiguration: LineageConfiguration?
        /// Name of the new crawler.
        public let name: String
        /// A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that were added since the last crawler run.
        public let recrawlPolicy: RecrawlPolicy?
        /// The IAM role or Amazon Resource Name (ARN) of an IAM role that is used by the new crawler to access customer resources.
        public let role: String?
        /// A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?
        /// The policy for the crawler's update and deletion behavior.
        public let schemaChangePolicy: SchemaChangePolicy?
        /// The table prefix used for catalog tables that are created.
        public let tablePrefix: String?
        /// A list of targets to crawl.
        public let targets: CrawlerTargets?

        public init(classifiers: [String]? = nil, configuration: String? = nil, crawlerSecurityConfiguration: String? = nil, databaseName: String? = nil, description: String? = nil, lineageConfiguration: LineageConfiguration? = nil, name: String, recrawlPolicy: RecrawlPolicy? = nil, role: String? = nil, schedule: String? = nil, schemaChangePolicy: SchemaChangePolicy? = nil, tablePrefix: String? = nil, targets: CrawlerTargets? = nil) {
            self.classifiers = classifiers
            self.configuration = configuration
            self.crawlerSecurityConfiguration = crawlerSecurityConfiguration
            self.databaseName = databaseName
            self.description = description
            self.lineageConfiguration = lineageConfiguration
            self.name = name
            self.recrawlPolicy = recrawlPolicy
            self.role = role
            self.schedule = schedule
            self.schemaChangePolicy = schemaChangePolicy
            self.tablePrefix = tablePrefix
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.classifiers?.forEach {
                try validate($0, name: "classifiers[]", parent: name, max: 255)
                try validate($0, name: "classifiers[]", parent: name, min: 1)
                try validate($0, name: "classifiers[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.crawlerSecurityConfiguration, name: "crawlerSecurityConfiguration", parent: name, max: 128)
            try self.validate(self.crawlerSecurityConfiguration, name: "crawlerSecurityConfiguration", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.tablePrefix, name: "tablePrefix", parent: name, max: 128)
            try self.validate(self.tablePrefix, name: "tablePrefix", parent: name, min: 0)
            try self.targets?.validate(name: "\(name).targets")
        }

        private enum CodingKeys: String, CodingKey {
            case classifiers = "Classifiers"
            case configuration = "Configuration"
            case crawlerSecurityConfiguration = "CrawlerSecurityConfiguration"
            case databaseName = "DatabaseName"
            case description = "Description"
            case lineageConfiguration = "LineageConfiguration"
            case name = "Name"
            case recrawlPolicy = "RecrawlPolicy"
            case role = "Role"
            case schedule = "Schedule"
            case schemaChangePolicy = "SchemaChangePolicy"
            case tablePrefix = "TablePrefix"
            case targets = "Targets"
        }
    }

    public struct UpdateCrawlerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCrawlerScheduleRequest: AWSEncodableShape {
        /// The name of the crawler whose schedule to update.
        public let crawlerName: String
        /// The updated cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers. For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *).
        public let schedule: String?

        public init(crawlerName: String, schedule: String? = nil) {
            self.crawlerName = crawlerName
            self.schedule = schedule
        }

        public func validate(name: String) throws {
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, max: 255)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, min: 1)
            try self.validate(self.crawlerName, name: "crawlerName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case crawlerName = "CrawlerName"
            case schedule = "Schedule"
        }
    }

    public struct UpdateCrawlerScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCsvClassifierRequest: AWSEncodableShape {
        /// Enables the processing of files that contain only one column.
        public let allowSingleColumn: Bool?
        /// Indicates whether the CSV file contains a header.
        public let containsHeader: CsvHeaderOption?
        /// A custom symbol to denote what separates each column entry in the row.
        public let delimiter: String?
        /// Specifies not to trim values before identifying the type of column values. The default value is true.
        public let disableValueTrimming: Bool?
        /// A list of strings representing column names.
        public let header: [String]?
        /// The name of the classifier.
        public let name: String
        /// A custom symbol to denote what combines content into a single column value. It must be different from the column delimiter.
        public let quoteSymbol: String?

        public init(allowSingleColumn: Bool? = nil, containsHeader: CsvHeaderOption? = nil, delimiter: String? = nil, disableValueTrimming: Bool? = nil, header: [String]? = nil, name: String, quoteSymbol: String? = nil) {
            self.allowSingleColumn = allowSingleColumn
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.disableValueTrimming = disableValueTrimming
            self.header = header
            self.name = name
            self.quoteSymbol = quoteSymbol
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, min: 1)
            try self.validate(self.delimiter, name: "delimiter", parent: name, pattern: "[^\\r\\n]")
            try self.header?.forEach {
                try validate($0, name: "header[]", parent: name, max: 255)
                try validate($0, name: "header[]", parent: name, min: 1)
                try validate($0, name: "header[]", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, max: 1)
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, min: 1)
            try self.validate(self.quoteSymbol, name: "quoteSymbol", parent: name, pattern: "[^\\r\\n]")
        }

        private enum CodingKeys: String, CodingKey {
            case allowSingleColumn = "AllowSingleColumn"
            case containsHeader = "ContainsHeader"
            case delimiter = "Delimiter"
            case disableValueTrimming = "DisableValueTrimming"
            case header = "Header"
            case name = "Name"
            case quoteSymbol = "QuoteSymbol"
        }
    }

    public struct UpdateDatabaseRequest: AWSEncodableShape {
        /// The ID of the Data Catalog in which the metadata database resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// A DatabaseInput object specifying the new definition of the metadata database in the catalog.
        public let databaseInput: DatabaseInput
        /// The name of the database to update in the catalog. For Hive compatibility, this is folded to lowercase.
        public let name: String

        public init(catalogId: String? = nil, databaseInput: DatabaseInput, name: String) {
            self.catalogId = catalogId
            self.databaseInput = databaseInput
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.databaseInput.validate(name: "\(name).databaseInput")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseInput = "DatabaseInput"
            case name = "Name"
        }
    }

    public struct UpdateDatabaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDevEndpointRequest: AWSEncodableShape {
        /// The map of arguments to add the map of arguments used to configure the DevEndpoint. Valid arguments are:    "--enable-glue-datacatalog": ""    You can specify a version of Python support for development endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no arguments are provided, the version defaults to Python 2.
        public let addArguments: [String: String]?
        /// The list of public keys for the DevEndpoint to use.
        public let addPublicKeys: [String]?
        /// Custom Python or Java libraries to be loaded in the DevEndpoint.
        public let customLibraries: DevEndpointCustomLibraries?
        /// The list of argument keys to be deleted from the map of arguments used to configure the DevEndpoint.
        public let deleteArguments: [String]?
        /// The list of public keys to be deleted from the DevEndpoint.
        public let deletePublicKeys: [String]?
        /// The name of the DevEndpoint to be updated.
        public let endpointName: String
        /// The public key for the DevEndpoint to use.
        public let publicKey: String?
        ///  True if the list of custom libraries to be loaded in the development endpoint needs to be updated, or False if otherwise.
        public let updateEtlLibraries: Bool?

        public init(addArguments: [String: String]? = nil, addPublicKeys: [String]? = nil, customLibraries: DevEndpointCustomLibraries? = nil, deleteArguments: [String]? = nil, deletePublicKeys: [String]? = nil, endpointName: String, publicKey: String? = nil, updateEtlLibraries: Bool? = nil) {
            self.addArguments = addArguments
            self.addPublicKeys = addPublicKeys
            self.customLibraries = customLibraries
            self.deleteArguments = deleteArguments
            self.deletePublicKeys = deletePublicKeys
            self.endpointName = endpointName
            self.publicKey = publicKey
            self.updateEtlLibraries = updateEtlLibraries
        }

        public func validate(name: String) throws {
            try self.validate(self.addPublicKeys, name: "addPublicKeys", parent: name, max: 5)
            try self.validate(self.deletePublicKeys, name: "deletePublicKeys", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case addArguments = "AddArguments"
            case addPublicKeys = "AddPublicKeys"
            case customLibraries = "CustomLibraries"
            case deleteArguments = "DeleteArguments"
            case deletePublicKeys = "DeletePublicKeys"
            case endpointName = "EndpointName"
            case publicKey = "PublicKey"
            case updateEtlLibraries = "UpdateEtlLibraries"
        }
    }

    public struct UpdateDevEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGrokClassifierRequest: AWSEncodableShape {
        /// An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs, Amazon CloudWatch Logs, and so on.
        public let classification: String?
        /// Optional custom grok patterns used by this classifier.
        public let customPatterns: String?
        /// The grok pattern used by this classifier.
        public let grokPattern: String?
        /// The name of the GrokClassifier.
        public let name: String

        public init(classification: String? = nil, customPatterns: String? = nil, grokPattern: String? = nil, name: String) {
            self.classification = classification
            self.customPatterns = customPatterns
            self.grokPattern = grokPattern
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.customPatterns, name: "customPatterns", parent: name, max: 16000)
            try self.validate(self.customPatterns, name: "customPatterns", parent: name, min: 0)
            try self.validate(self.customPatterns, name: "customPatterns", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, max: 2048)
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, min: 1)
            try self.validate(self.grokPattern, name: "grokPattern", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\t]*")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case customPatterns = "CustomPatterns"
            case grokPattern = "GrokPattern"
            case name = "Name"
        }
    }

    public struct UpdateJobRequest: AWSEncodableShape {
        /// The name of the job definition to update.
        public let jobName: String
        /// Specifies the values with which to update the job definition.
        public let jobUpdate: JobUpdate

        public init(jobName: String, jobUpdate: JobUpdate) {
            self.jobName = jobName
            self.jobUpdate = jobUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.jobName, name: "jobName", parent: name, max: 255)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.jobUpdate.validate(name: "\(name).jobUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
            case jobUpdate = "JobUpdate"
        }
    }

    public struct UpdateJobResponse: AWSDecodableShape {
        /// Returns the name of the updated job definition.
        public let jobName: String?

        public init(jobName: String? = nil) {
            self.jobName = jobName
        }

        private enum CodingKeys: String, CodingKey {
            case jobName = "JobName"
        }
    }

    public struct UpdateJsonClassifierRequest: AWSEncodableShape {
        /// A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of JsonPath, as described in Writing JsonPath Custom Classifiers.
        public let jsonPath: String?
        /// The name of the classifier.
        public let name: String

        public init(jsonPath: String? = nil, name: String) {
            self.jsonPath = jsonPath
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case jsonPath = "JsonPath"
            case name = "Name"
        }
    }

    public struct UpdateMLTransformRequest: AWSEncodableShape {
        /// A description of the transform. The default is an empty string.
        public let description: String?
        /// This value determines which version of Glue this machine learning transform is compatible with. Glue 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to Glue 0.9. For more information, see Glue Versions in the developer guide.
        public let glueVersion: String?
        /// The number of Glue data processing units (DPUs) that are allocated to task runs for this transform. You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the Glue pricing page.  When the WorkerType field is set to a value other than Standard, the MaxCapacity field is set automatically and becomes read-only.
        public let maxCapacity: Double?
        /// The maximum number of times to retry a task for this transform after a task run fails.
        public let maxRetries: Int?
        /// The unique name that you gave the transform when you created it.
        public let name: String?
        /// The number of workers of a defined workerType that are allocated when this task runs.
        public let numberOfWorkers: Int?
        /// The configuration parameters that are specific to the transform type (algorithm) used. Conditionally dependent on the transform type.
        public let parameters: TransformParameters?
        /// The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.
        public let role: String?
        /// The timeout for a task run for this transform in minutes. This is the maximum time that a task run for this transform can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
        public let timeout: Int?
        /// A unique identifier that was generated when the transform was created.
        public let transformId: String
        /// The type of predefined worker that is allocated when this task runs. Accepts a value of Standard, G.1X, or G.2X.   For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.   For the G.1X worker type, each worker provides 4 vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker.   For the G.2X worker type, each worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.
        public let workerType: WorkerType?

        public init(description: String? = nil, glueVersion: String? = nil, maxCapacity: Double? = nil, maxRetries: Int? = nil, name: String? = nil, numberOfWorkers: Int? = nil, parameters: TransformParameters? = nil, role: String? = nil, timeout: Int? = nil, transformId: String, workerType: WorkerType? = nil) {
            self.description = description
            self.glueVersion = glueVersion
            self.maxCapacity = maxCapacity
            self.maxRetries = maxRetries
            self.name = name
            self.numberOfWorkers = numberOfWorkers
            self.parameters = parameters
            self.role = role
            self.timeout = timeout
            self.transformId = transformId
            self.workerType = workerType
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, max: 255)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, min: 1)
            try self.validate(self.glueVersion, name: "glueVersion", parent: name, pattern: "^\\w+\\.\\w+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.parameters?.validate(name: "\(name).parameters")
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, max: 255)
            try self.validate(self.transformId, name: "transformId", parent: name, min: 1)
            try self.validate(self.transformId, name: "transformId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case glueVersion = "GlueVersion"
            case maxCapacity = "MaxCapacity"
            case maxRetries = "MaxRetries"
            case name = "Name"
            case numberOfWorkers = "NumberOfWorkers"
            case parameters = "Parameters"
            case role = "Role"
            case timeout = "Timeout"
            case transformId = "TransformId"
            case workerType = "WorkerType"
        }
    }

    public struct UpdateMLTransformResponse: AWSDecodableShape {
        /// The unique identifier for the transform that was updated.
        public let transformId: String?

        public init(transformId: String? = nil) {
            self.transformId = transformId
        }

        private enum CodingKeys: String, CodingKey {
            case transformId = "TransformId"
        }
    }

    public struct UpdatePartitionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the partition to be updated resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table in question resides.
        public let databaseName: String
        /// The new partition object to update the partition to. The Values property can't be changed. If you want to change the partition key values for a partition, delete and recreate the partition.
        public let partitionInput: PartitionInput
        /// List of partition key values that define the partition to update.
        public let partitionValueList: [String]
        /// The name of the table in which the partition to be updated is located.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, partitionInput: PartitionInput, partitionValueList: [String], tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.partitionInput = partitionInput
            self.partitionValueList = partitionValueList
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.partitionInput.validate(name: "\(name).partitionInput")
            try self.partitionValueList.forEach {
                try validate($0, name: "partitionValueList[]", parent: name, max: 1024)
            }
            try self.validate(self.partitionValueList, name: "partitionValueList", parent: name, max: 100)
            try self.validate(self.partitionValueList, name: "partitionValueList", parent: name, min: 0)
            try self.validate(self.tableName, name: "tableName", parent: name, max: 255)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case partitionInput = "PartitionInput"
            case partitionValueList = "PartitionValueList"
            case tableName = "TableName"
        }
    }

    public struct UpdatePartitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRegistryInput: AWSEncodableShape {
        /// A description of the registry. If description is not provided, this field will not be updated.
        public let description: String
        /// This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).
        public let registryId: RegistryId

        public init(description: String, registryId: RegistryId) {
            self.description = description
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.registryId.validate(name: "\(name).registryId")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryId = "RegistryId"
        }
    }

    public struct UpdateRegistryResponse: AWSDecodableShape {
        /// The Amazon Resource name (ARN) of the updated registry.
        public let registryArn: String?
        /// The name of the updated registry.
        public let registryName: String?

        public init(registryArn: String? = nil, registryName: String? = nil) {
            self.registryArn = registryArn
            self.registryName = registryName
        }

        private enum CodingKeys: String, CodingKey {
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
        }
    }

    public struct UpdateSchemaInput: AWSEncodableShape {
        /// The new compatibility setting for the schema.
        public let compatibility: Compatibility?
        /// The new description for the schema.
        public let description: String?
        /// This is a wrapper structure to contain schema identity fields. The structure contains:   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.   SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to be provided.
        public let schemaId: SchemaId
        /// Version number required for check pointing. One of VersionNumber or Compatibility has to be provided.
        public let schemaVersionNumber: SchemaVersionNumber?

        public init(compatibility: Compatibility? = nil, description: String? = nil, schemaId: SchemaId, schemaVersionNumber: SchemaVersionNumber? = nil) {
            self.compatibility = compatibility
            self.description = description
            self.schemaId = schemaId
            self.schemaVersionNumber = schemaVersionNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\r\\n\\t]*")
            try self.schemaId.validate(name: "\(name).schemaId")
            try self.schemaVersionNumber?.validate(name: "\(name).schemaVersionNumber")
        }

        private enum CodingKeys: String, CodingKey {
            case compatibility = "Compatibility"
            case description = "Description"
            case schemaId = "SchemaId"
            case schemaVersionNumber = "SchemaVersionNumber"
        }
    }

    public struct UpdateSchemaResponse: AWSDecodableShape {
        /// The name of the registry that contains the schema.
        public let registryName: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?
        /// The name of the schema.
        public let schemaName: String?

        public init(registryName: String? = nil, schemaArn: String? = nil, schemaName: String? = nil) {
            self.registryName = registryName
            self.schemaArn = schemaArn
            self.schemaName = schemaName
        }

        private enum CodingKeys: String, CodingKey {
            case registryName = "RegistryName"
            case schemaArn = "SchemaArn"
            case schemaName = "SchemaName"
        }
    }

    public struct UpdateTableRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
        public let databaseName: String
        /// By default, UpdateTable always creates an archived version of the table before updating it. However, if skipArchive is set to true, UpdateTable does not create the archived version.
        public let skipArchive: Bool?
        /// An updated TableInput object to define the metadata table in the catalog.
        public let tableInput: TableInput

        public init(catalogId: String? = nil, databaseName: String, skipArchive: Bool? = nil, tableInput: TableInput) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.skipArchive = skipArchive
            self.tableInput = tableInput
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.tableInput.validate(name: "\(name).tableInput")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case skipArchive = "SkipArchive"
            case tableInput = "TableInput"
        }
    }

    public struct UpdateTableResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTriggerRequest: AWSEncodableShape {
        /// The name of the trigger to update.
        public let name: String
        /// The new values with which to update the trigger.
        public let triggerUpdate: TriggerUpdate

        public init(name: String, triggerUpdate: TriggerUpdate) {
            self.name = name
            self.triggerUpdate = triggerUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.triggerUpdate.validate(name: "\(name).triggerUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case triggerUpdate = "TriggerUpdate"
        }
    }

    public struct UpdateTriggerResponse: AWSDecodableShape {
        /// The resulting trigger definition.
        public let trigger: Trigger?

        public init(trigger: Trigger? = nil) {
            self.trigger = trigger
        }

        private enum CodingKeys: String, CodingKey {
            case trigger = "Trigger"
        }
    }

    public struct UpdateUserDefinedFunctionRequest: AWSEncodableShape {
        /// The ID of the Data Catalog where the function to be updated is located. If none is provided, the Amazon Web Services account ID is used by default.
        public let catalogId: String?
        /// The name of the catalog database where the function to be updated is located.
        public let databaseName: String
        /// A FunctionInput object that redefines the function in the Data Catalog.
        public let functionInput: UserDefinedFunctionInput
        /// The name of the function.
        public let functionName: String

        public init(catalogId: String? = nil, databaseName: String, functionInput: UserDefinedFunctionInput, functionName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.functionInput = functionInput
            self.functionName = functionName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 255)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 1)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 255)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.functionInput.validate(name: "\(name).functionInput")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 255)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case databaseName = "DatabaseName"
            case functionInput = "FunctionInput"
            case functionName = "FunctionName"
        }
    }

    public struct UpdateUserDefinedFunctionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateWorkflowRequest: AWSEncodableShape {
        /// A collection of properties to be used as part of each execution of the workflow.
        public let defaultRunProperties: [String: String]?
        /// The description of the workflow.
        public let description: String?
        /// You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
        public let maxConcurrentRuns: Int?
        /// Name of the workflow to be updated.
        public let name: String

        public init(defaultRunProperties: [String: String]? = nil, description: String? = nil, maxConcurrentRuns: Int? = nil, name: String) {
            self.defaultRunProperties = defaultRunProperties
            self.description = description
            self.maxConcurrentRuns = maxConcurrentRuns
            self.name = name
        }

        public func validate(name: String) throws {
            try self.defaultRunProperties?.forEach {
                try validate($0.key, name: "defaultRunProperties.key", parent: name, max: 255)
                try validate($0.key, name: "defaultRunProperties.key", parent: name, min: 1)
                try validate($0.key, name: "defaultRunProperties.key", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            }
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultRunProperties = "DefaultRunProperties"
            case description = "Description"
            case maxConcurrentRuns = "MaxConcurrentRuns"
            case name = "Name"
        }
    }

    public struct UpdateWorkflowResponse: AWSDecodableShape {
        /// The name of the workflow which was specified in input.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateXMLClassifierRequest: AWSEncodableShape {
        /// An identifier of the data format that the classifier matches.
        public let classification: String?
        /// The name of the classifier.
        public let name: String
        /// The XML tag designating the element that contains each record in an XML document being parsed. This cannot identify a self-closing element (closed by /&gt;). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, &lt;row item_a="A" item_b="B"&gt;&lt;/row&gt; is okay, but &lt;row item_a="A" item_b="B" /&gt; is not).
        public let rowTag: String?

        public init(classification: String? = nil, name: String, rowTag: String? = nil) {
            self.classification = classification
            self.name = name
            self.rowTag = rowTag
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case name = "Name"
            case rowTag = "RowTag"
        }
    }

    public struct UserDefinedFunction: AWSDecodableShape {
        /// The ID of the Data Catalog in which the function resides.
        public let catalogId: String?
        /// The Java class that contains the function code.
        public let className: String?
        /// The time at which the function was created.
        public let createTime: Date?
        /// The name of the catalog database that contains the function.
        public let databaseName: String?
        /// The name of the function.
        public let functionName: String?
        /// The owner of the function.
        public let ownerName: String?
        /// The owner type.
        public let ownerType: PrincipalType?
        /// The resource URIs for the function.
        public let resourceUris: [ResourceUri]?

        public init(catalogId: String? = nil, className: String? = nil, createTime: Date? = nil, databaseName: String? = nil, functionName: String? = nil, ownerName: String? = nil, ownerType: PrincipalType? = nil, resourceUris: [ResourceUri]? = nil) {
            self.catalogId = catalogId
            self.className = className
            self.createTime = createTime
            self.databaseName = databaseName
            self.functionName = functionName
            self.ownerName = ownerName
            self.ownerType = ownerType
            self.resourceUris = resourceUris
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "CatalogId"
            case className = "ClassName"
            case createTime = "CreateTime"
            case databaseName = "DatabaseName"
            case functionName = "FunctionName"
            case ownerName = "OwnerName"
            case ownerType = "OwnerType"
            case resourceUris = "ResourceUris"
        }
    }

    public struct UserDefinedFunctionInput: AWSEncodableShape {
        /// The Java class that contains the function code.
        public let className: String?
        /// The name of the function.
        public let functionName: String?
        /// The owner of the function.
        public let ownerName: String?
        /// The owner type.
        public let ownerType: PrincipalType?
        /// The resource URIs for the function.
        public let resourceUris: [ResourceUri]?

        public init(className: String? = nil, functionName: String? = nil, ownerName: String? = nil, ownerType: PrincipalType? = nil, resourceUris: [ResourceUri]? = nil) {
            self.className = className
            self.functionName = functionName
            self.ownerName = ownerName
            self.ownerType = ownerType
            self.resourceUris = resourceUris
        }

        public func validate(name: String) throws {
            try self.validate(self.className, name: "className", parent: name, max: 255)
            try self.validate(self.className, name: "className", parent: name, min: 1)
            try self.validate(self.className, name: "className", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.functionName, name: "functionName", parent: name, max: 255)
            try self.validate(self.functionName, name: "functionName", parent: name, min: 1)
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.validate(self.ownerName, name: "ownerName", parent: name, max: 255)
            try self.validate(self.ownerName, name: "ownerName", parent: name, min: 1)
            try self.validate(self.ownerName, name: "ownerName", parent: name, pattern: "[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDC00-\\uDBFF\\uDFFF\\t]*")
            try self.resourceUris?.forEach {
                try $0.validate(name: "\(name).resourceUris[]")
            }
            try self.validate(self.resourceUris, name: "resourceUris", parent: name, max: 1000)
            try self.validate(self.resourceUris, name: "resourceUris", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case className = "ClassName"
            case functionName = "FunctionName"
            case ownerName = "OwnerName"
            case ownerType = "OwnerType"
            case resourceUris = "ResourceUris"
        }
    }

    public struct Workflow: AWSDecodableShape {
        /// The date and time when the workflow was created.
        public let createdOn: Date?
        /// A collection of properties to be used as part of each execution of the workflow. The run properties are made available to each job in the workflow. A job can modify the properties for the next jobs in the flow.
        public let defaultRunProperties: [String: String]?
        /// A description of the workflow.
        public let description: String?
        /// The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.
        public let graph: WorkflowGraph?
        /// The date and time when the workflow was last modified.
        public let lastModifiedOn: Date?
        /// The information about the last execution of the workflow.
        public let lastRun: WorkflowRun?
        /// You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs. If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.
        public let maxConcurrentRuns: Int?
        /// The name of the workflow.
        public let name: String?

        public init(createdOn: Date? = nil, defaultRunProperties: [String: String]? = nil, description: String? = nil, graph: WorkflowGraph? = nil, lastModifiedOn: Date? = nil, lastRun: WorkflowRun? = nil, maxConcurrentRuns: Int? = nil, name: String? = nil) {
            self.createdOn = createdOn
            self.defaultRunProperties = defaultRunProperties
            self.description = description
            self.graph = graph
            self.lastModifiedOn = lastModifiedOn
            self.lastRun = lastRun
            self.maxConcurrentRuns = maxConcurrentRuns
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdOn = "CreatedOn"
            case defaultRunProperties = "DefaultRunProperties"
            case description = "Description"
            case graph = "Graph"
            case lastModifiedOn = "LastModifiedOn"
            case lastRun = "LastRun"
            case maxConcurrentRuns = "MaxConcurrentRuns"
            case name = "Name"
        }
    }

    public struct WorkflowGraph: AWSDecodableShape {
        /// A list of all the directed connections between the nodes belonging to the workflow.
        public let edges: [Edge]?
        /// A list of the the Glue components belong to the workflow represented as nodes.
        public let nodes: [Node]?

        public init(edges: [Edge]? = nil, nodes: [Node]? = nil) {
            self.edges = edges
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case edges = "Edges"
            case nodes = "Nodes"
        }
    }

    public struct WorkflowRun: AWSDecodableShape {
        /// The date and time when the workflow run completed.
        public let completedOn: Date?
        /// This error message describes any error that may have occurred in starting the workflow run. Currently the only error message is "Concurrent runs exceeded for workflow: foo."
        public let errorMessage: String?
        /// The graph representing all the Glue components that belong to the workflow as nodes and directed connections between them as edges.
        public let graph: WorkflowGraph?
        /// Name of the workflow that was run.
        public let name: String?
        /// The ID of the previous workflow run.
        public let previousRunId: String?
        /// The date and time when the workflow run was started.
        public let startedOn: Date?
        /// The batch condition that started the workflow run.
        public let startingEventBatchCondition: StartingEventBatchCondition?
        /// The statistics of the run.
        public let statistics: WorkflowRunStatistics?
        /// The status of the workflow run.
        public let status: WorkflowRunStatus?
        /// The ID of this workflow run.
        public let workflowRunId: String?
        /// The workflow run properties which were set during the run.
        public let workflowRunProperties: [String: String]?

        public init(completedOn: Date? = nil, errorMessage: String? = nil, graph: WorkflowGraph? = nil, name: String? = nil, previousRunId: String? = nil, startedOn: Date? = nil, startingEventBatchCondition: StartingEventBatchCondition? = nil, statistics: WorkflowRunStatistics? = nil, status: WorkflowRunStatus? = nil, workflowRunId: String? = nil, workflowRunProperties: [String: String]? = nil) {
            self.completedOn = completedOn
            self.errorMessage = errorMessage
            self.graph = graph
            self.name = name
            self.previousRunId = previousRunId
            self.startedOn = startedOn
            self.startingEventBatchCondition = startingEventBatchCondition
            self.statistics = statistics
            self.status = status
            self.workflowRunId = workflowRunId
            self.workflowRunProperties = workflowRunProperties
        }

        private enum CodingKeys: String, CodingKey {
            case completedOn = "CompletedOn"
            case errorMessage = "ErrorMessage"
            case graph = "Graph"
            case name = "Name"
            case previousRunId = "PreviousRunId"
            case startedOn = "StartedOn"
            case startingEventBatchCondition = "StartingEventBatchCondition"
            case statistics = "Statistics"
            case status = "Status"
            case workflowRunId = "WorkflowRunId"
            case workflowRunProperties = "WorkflowRunProperties"
        }
    }

    public struct WorkflowRunStatistics: AWSDecodableShape {
        /// Total number of Actions that have failed.
        public let failedActions: Int?
        /// Total number Actions in running state.
        public let runningActions: Int?
        /// Total number of Actions that have stopped.
        public let stoppedActions: Int?
        /// Total number of Actions that have succeeded.
        public let succeededActions: Int?
        /// Total number of Actions that timed out.
        public let timeoutActions: Int?
        /// Total number of Actions in the workflow run.
        public let totalActions: Int?

        public init(failedActions: Int? = nil, runningActions: Int? = nil, stoppedActions: Int? = nil, succeededActions: Int? = nil, timeoutActions: Int? = nil, totalActions: Int? = nil) {
            self.failedActions = failedActions
            self.runningActions = runningActions
            self.stoppedActions = stoppedActions
            self.succeededActions = succeededActions
            self.timeoutActions = timeoutActions
            self.totalActions = totalActions
        }

        private enum CodingKeys: String, CodingKey {
            case failedActions = "FailedActions"
            case runningActions = "RunningActions"
            case stoppedActions = "StoppedActions"
            case succeededActions = "SucceededActions"
            case timeoutActions = "TimeoutActions"
            case totalActions = "TotalActions"
        }
    }

    public struct XMLClassifier: AWSDecodableShape {
        /// An identifier of the data format that the classifier matches.
        public let classification: String
        /// The time that this classifier was registered.
        public let creationTime: Date?
        /// The time that this classifier was last updated.
        public let lastUpdated: Date?
        /// The name of the classifier.
        public let name: String
        /// The XML tag designating the element that contains each record in an XML document being parsed. This can't identify a self-closing element (closed by /&gt;). An empty row element that contains only attributes can be parsed as long as it ends with a closing tag (for example, &lt;row item_a="A" item_b="B"&gt;&lt;/row&gt; is okay, but &lt;row item_a="A" item_b="B" /&gt; is not).
        public let rowTag: String?
        /// The version of this classifier.
        public let version: Int64?

        public init(classification: String, creationTime: Date? = nil, lastUpdated: Date? = nil, name: String, rowTag: String? = nil, version: Int64? = nil) {
            self.classification = classification
            self.creationTime = creationTime
            self.lastUpdated = lastUpdated
            self.name = name
            self.rowTag = rowTag
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case classification = "Classification"
            case creationTime = "CreationTime"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case rowTag = "RowTag"
            case version = "Version"
        }
    }
}
