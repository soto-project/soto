//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension NimbleStudio {
    ///  List Eula Acceptances.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listEulaAcceptancesPaginator<Result>(
        _ input: ListEulaAcceptancesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListEulaAcceptancesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listEulaAcceptances,
            inputKey: \ListEulaAcceptancesRequest.nextToken,
            outputKey: \ListEulaAcceptancesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listEulaAcceptancesPaginator(
        _ input: ListEulaAcceptancesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListEulaAcceptancesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listEulaAcceptances,
            inputKey: \ListEulaAcceptancesRequest.nextToken,
            outputKey: \ListEulaAcceptancesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List Eulas.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listEulasPaginator<Result>(
        _ input: ListEulasRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListEulasResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listEulas,
            inputKey: \ListEulasRequest.nextToken,
            outputKey: \ListEulasResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listEulasPaginator(
        _ input: ListEulasRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListEulasResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listEulas,
            inputKey: \ListEulasRequest.nextToken,
            outputKey: \ListEulasResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Get all users in a given launch profile membership.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listLaunchProfileMembersPaginator<Result>(
        _ input: ListLaunchProfileMembersRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListLaunchProfileMembersResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listLaunchProfileMembers,
            inputKey: \ListLaunchProfileMembersRequest.nextToken,
            outputKey: \ListLaunchProfileMembersResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listLaunchProfileMembersPaginator(
        _ input: ListLaunchProfileMembersRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListLaunchProfileMembersResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listLaunchProfileMembers,
            inputKey: \ListLaunchProfileMembersRequest.nextToken,
            outputKey: \ListLaunchProfileMembersResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List all the launch profiles a studio.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listLaunchProfilesPaginator<Result>(
        _ input: ListLaunchProfilesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListLaunchProfilesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listLaunchProfiles,
            inputKey: \ListLaunchProfilesRequest.nextToken,
            outputKey: \ListLaunchProfilesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listLaunchProfilesPaginator(
        _ input: ListLaunchProfilesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListLaunchProfilesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listLaunchProfiles,
            inputKey: \ListLaunchProfilesRequest.nextToken,
            outputKey: \ListLaunchProfilesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List the streaming image resources available to this studio. This list will contain both images provided by AWS, as well as streaming images that you have created in your studio.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listStreamingImagesPaginator<Result>(
        _ input: ListStreamingImagesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListStreamingImagesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listStreamingImages,
            inputKey: \ListStreamingImagesRequest.nextToken,
            outputKey: \ListStreamingImagesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listStreamingImagesPaginator(
        _ input: ListStreamingImagesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListStreamingImagesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listStreamingImages,
            inputKey: \ListStreamingImagesRequest.nextToken,
            outputKey: \ListStreamingImagesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the streaming image resources in a studio.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listStreamingSessionsPaginator<Result>(
        _ input: ListStreamingSessionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListStreamingSessionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listStreamingSessions,
            inputKey: \ListStreamingSessionsRequest.nextToken,
            outputKey: \ListStreamingSessionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listStreamingSessionsPaginator(
        _ input: ListStreamingSessionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListStreamingSessionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listStreamingSessions,
            inputKey: \ListStreamingSessionsRequest.nextToken,
            outputKey: \ListStreamingSessionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the StudioComponents in a studio.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listStudioComponentsPaginator<Result>(
        _ input: ListStudioComponentsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListStudioComponentsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listStudioComponents,
            inputKey: \ListStudioComponentsRequest.nextToken,
            outputKey: \ListStudioComponentsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listStudioComponentsPaginator(
        _ input: ListStudioComponentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListStudioComponentsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listStudioComponents,
            inputKey: \ListStudioComponentsRequest.nextToken,
            outputKey: \ListStudioComponentsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Get all users in a given studio membership.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listStudioMembersPaginator<Result>(
        _ input: ListStudioMembersRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListStudioMembersResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listStudioMembers,
            inputKey: \ListStudioMembersRequest.nextToken,
            outputKey: \ListStudioMembersResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listStudioMembersPaginator(
        _ input: ListStudioMembersRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListStudioMembersResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listStudioMembers,
            inputKey: \ListStudioMembersRequest.nextToken,
            outputKey: \ListStudioMembersResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  List studios in your AWS account in the requested AWS Region.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listStudiosPaginator<Result>(
        _ input: ListStudiosRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListStudiosResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listStudios,
            inputKey: \ListStudiosRequest.nextToken,
            outputKey: \ListStudiosResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listStudiosPaginator(
        _ input: ListStudiosRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListStudiosResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listStudios,
            inputKey: \ListStudiosRequest.nextToken,
            outputKey: \ListStudiosResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension NimbleStudio.ListEulaAcceptancesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> NimbleStudio.ListEulaAcceptancesRequest {
        return .init(
            eulaIds: self.eulaIds,
            nextToken: token,
            studioId: self.studioId
        )
    }
}

extension NimbleStudio.ListEulasRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> NimbleStudio.ListEulasRequest {
        return .init(
            eulaIds: self.eulaIds,
            nextToken: token
        )
    }
}

extension NimbleStudio.ListLaunchProfileMembersRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> NimbleStudio.ListLaunchProfileMembersRequest {
        return .init(
            launchProfileId: self.launchProfileId,
            maxResults: self.maxResults,
            nextToken: token,
            studioId: self.studioId
        )
    }
}

extension NimbleStudio.ListLaunchProfilesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> NimbleStudio.ListLaunchProfilesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            principalId: self.principalId,
            states: self.states,
            studioId: self.studioId
        )
    }
}

extension NimbleStudio.ListStreamingImagesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> NimbleStudio.ListStreamingImagesRequest {
        return .init(
            nextToken: token,
            owner: self.owner,
            studioId: self.studioId
        )
    }
}

extension NimbleStudio.ListStreamingSessionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> NimbleStudio.ListStreamingSessionsRequest {
        return .init(
            createdBy: self.createdBy,
            nextToken: token,
            sessionIds: self.sessionIds,
            studioId: self.studioId
        )
    }
}

extension NimbleStudio.ListStudioComponentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> NimbleStudio.ListStudioComponentsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            states: self.states,
            studioId: self.studioId,
            types: self.types
        )
    }
}

extension NimbleStudio.ListStudioMembersRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> NimbleStudio.ListStudioMembersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            studioId: self.studioId
        )
    }
}

extension NimbleStudio.ListStudiosRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> NimbleStudio.ListStudiosRequest {
        return .init(
            nextToken: token
        )
    }
}
