//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension PaymentCryptographyData {
    // MARK: Enums

    public enum DukptDerivationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aes128 = "AES_128"
        case aes192 = "AES_192"
        case aes256 = "AES_256"
        case tdes2Key = "TDES_2KEY"
        case tdes3Key = "TDES_3KEY"
        public var description: String { return self.rawValue }
    }

    public enum DukptEncryptionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cbc = "CBC"
        case ecb = "ECB"
        public var description: String { return self.rawValue }
    }

    public enum DukptKeyVariant: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bidirectional = "BIDIRECTIONAL"
        case request = "REQUEST"
        case response = "RESPONSE"
        public var description: String { return self.rawValue }
    }

    public enum EmvEncryptionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cbc = "CBC"
        case ecb = "ECB"
        public var description: String { return self.rawValue }
    }

    public enum EmvMajorKeyDerivationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case emvOptionA = "EMV_OPTION_A"
        case emvOptionB = "EMV_OPTION_B"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cbc = "CBC"
        case cfb = "CFB"
        case cfb1 = "CFB1"
        case cfb128 = "CFB128"
        case cfb64 = "CFB64"
        case cfb8 = "CFB8"
        case ecb = "ECB"
        case ofb = "OFB"
        public var description: String { return self.rawValue }
    }

    public enum MacAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cmac = "CMAC"
        case hmacSha224 = "HMAC_SHA224"
        case hmacSha256 = "HMAC_SHA256"
        case hmacSha384 = "HMAC_SHA384"
        case hmacSha512 = "HMAC_SHA512"
        case iso9797Algorithm1 = "ISO9797_ALGORITHM1"
        case iso9797Algorithm3 = "ISO9797_ALGORITHM3"
        public var description: String { return self.rawValue }
    }

    public enum MajorKeyDerivationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case emvOptionA = "EMV_OPTION_A"
        case emvOptionB = "EMV_OPTION_B"
        public var description: String { return self.rawValue }
    }

    public enum PaddingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oaepSha1 = "OAEP_SHA1"
        case oaepSha256 = "OAEP_SHA256"
        case oaepSha512 = "OAEP_SHA512"
        case pkcs1 = "PKCS1"
        public var description: String { return self.rawValue }
    }

    public enum PinBlockFormatForPinData: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case isoFormat0 = "ISO_FORMAT_0"
        case isoFormat3 = "ISO_FORMAT_3"
        public var description: String { return self.rawValue }
    }

    public enum SessionKeyDerivationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amex = "AMEX"
        case emv2000 = "EMV2000"
        case emvCommonSessionKey = "EMV_COMMON_SESSION_KEY"
        case mastercardSessionKey = "MASTERCARD_SESSION_KEY"
        case visa = "VISA"
        public var description: String { return self.rawValue }
    }

    public enum CardGenerationAttributes: AWSEncodableShape, Sendable {
        case amexCardSecurityCodeVersion1(AmexCardSecurityCodeVersion1)
        /// Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.
        case amexCardSecurityCodeVersion2(AmexCardSecurityCodeVersion2)
        /// Card data parameters that are required to generate a cardholder verification value for the payment card.
        case cardHolderVerificationValue(CardHolderVerificationValue)
        /// Card data parameters that are required to generate Card Verification Value (CVV) for the payment card.
        case cardVerificationValue1(CardVerificationValue1)
        /// Card data parameters that are required to generate Card Verification Value (CVV2) for the payment card.
        case cardVerificationValue2(CardVerificationValue2)
        /// Card data parameters that are required to generate CDynamic Card Verification Code (dCVC) for the payment card.
        case dynamicCardVerificationCode(DynamicCardVerificationCode)
        /// Card data parameters that are required to generate CDynamic Card Verification Value (dCVV) for the payment card.
        case dynamicCardVerificationValue(DynamicCardVerificationValue)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .amexCardSecurityCodeVersion1(let value):
                try container.encode(value, forKey: .amexCardSecurityCodeVersion1)
            case .amexCardSecurityCodeVersion2(let value):
                try container.encode(value, forKey: .amexCardSecurityCodeVersion2)
            case .cardHolderVerificationValue(let value):
                try container.encode(value, forKey: .cardHolderVerificationValue)
            case .cardVerificationValue1(let value):
                try container.encode(value, forKey: .cardVerificationValue1)
            case .cardVerificationValue2(let value):
                try container.encode(value, forKey: .cardVerificationValue2)
            case .dynamicCardVerificationCode(let value):
                try container.encode(value, forKey: .dynamicCardVerificationCode)
            case .dynamicCardVerificationValue(let value):
                try container.encode(value, forKey: .dynamicCardVerificationValue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .amexCardSecurityCodeVersion1(let value):
                try value.validate(name: "\(name).amexCardSecurityCodeVersion1")
            case .amexCardSecurityCodeVersion2(let value):
                try value.validate(name: "\(name).amexCardSecurityCodeVersion2")
            case .cardHolderVerificationValue(let value):
                try value.validate(name: "\(name).cardHolderVerificationValue")
            case .cardVerificationValue1(let value):
                try value.validate(name: "\(name).cardVerificationValue1")
            case .cardVerificationValue2(let value):
                try value.validate(name: "\(name).cardVerificationValue2")
            case .dynamicCardVerificationCode(let value):
                try value.validate(name: "\(name).dynamicCardVerificationCode")
            case .dynamicCardVerificationValue(let value):
                try value.validate(name: "\(name).dynamicCardVerificationValue")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case amexCardSecurityCodeVersion1 = "AmexCardSecurityCodeVersion1"
            case amexCardSecurityCodeVersion2 = "AmexCardSecurityCodeVersion2"
            case cardHolderVerificationValue = "CardHolderVerificationValue"
            case cardVerificationValue1 = "CardVerificationValue1"
            case cardVerificationValue2 = "CardVerificationValue2"
            case dynamicCardVerificationCode = "DynamicCardVerificationCode"
            case dynamicCardVerificationValue = "DynamicCardVerificationValue"
        }
    }

    public enum CardVerificationAttributes: AWSEncodableShape, Sendable {
        case amexCardSecurityCodeVersion1(AmexCardSecurityCodeVersion1)
        /// Card data parameters that are required to verify a Card Security Code (CSC2) for an AMEX payment card.
        case amexCardSecurityCodeVersion2(AmexCardSecurityCodeVersion2)
        /// Card data parameters that are required to verify a cardholder verification value for the payment card.
        case cardHolderVerificationValue(CardHolderVerificationValue)
        /// Card data parameters that are required to verify Card Verification Value (CVV) for the payment card.
        case cardVerificationValue1(CardVerificationValue1)
        /// Card data parameters that are required to verify Card Verification Value (CVV2) for the payment card.
        case cardVerificationValue2(CardVerificationValue2)
        /// Card data parameters that are required to verify CDynamic Card Verification Code (dCVC) for the payment card.
        case discoverDynamicCardVerificationCode(DiscoverDynamicCardVerificationCode)
        /// Card data parameters that are required to verify CDynamic Card Verification Code (dCVC) for the payment card.
        case dynamicCardVerificationCode(DynamicCardVerificationCode)
        /// Card data parameters that are required to verify CDynamic Card Verification Value (dCVV) for the payment card.
        case dynamicCardVerificationValue(DynamicCardVerificationValue)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .amexCardSecurityCodeVersion1(let value):
                try container.encode(value, forKey: .amexCardSecurityCodeVersion1)
            case .amexCardSecurityCodeVersion2(let value):
                try container.encode(value, forKey: .amexCardSecurityCodeVersion2)
            case .cardHolderVerificationValue(let value):
                try container.encode(value, forKey: .cardHolderVerificationValue)
            case .cardVerificationValue1(let value):
                try container.encode(value, forKey: .cardVerificationValue1)
            case .cardVerificationValue2(let value):
                try container.encode(value, forKey: .cardVerificationValue2)
            case .discoverDynamicCardVerificationCode(let value):
                try container.encode(value, forKey: .discoverDynamicCardVerificationCode)
            case .dynamicCardVerificationCode(let value):
                try container.encode(value, forKey: .dynamicCardVerificationCode)
            case .dynamicCardVerificationValue(let value):
                try container.encode(value, forKey: .dynamicCardVerificationValue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .amexCardSecurityCodeVersion1(let value):
                try value.validate(name: "\(name).amexCardSecurityCodeVersion1")
            case .amexCardSecurityCodeVersion2(let value):
                try value.validate(name: "\(name).amexCardSecurityCodeVersion2")
            case .cardHolderVerificationValue(let value):
                try value.validate(name: "\(name).cardHolderVerificationValue")
            case .cardVerificationValue1(let value):
                try value.validate(name: "\(name).cardVerificationValue1")
            case .cardVerificationValue2(let value):
                try value.validate(name: "\(name).cardVerificationValue2")
            case .discoverDynamicCardVerificationCode(let value):
                try value.validate(name: "\(name).discoverDynamicCardVerificationCode")
            case .dynamicCardVerificationCode(let value):
                try value.validate(name: "\(name).dynamicCardVerificationCode")
            case .dynamicCardVerificationValue(let value):
                try value.validate(name: "\(name).dynamicCardVerificationValue")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case amexCardSecurityCodeVersion1 = "AmexCardSecurityCodeVersion1"
            case amexCardSecurityCodeVersion2 = "AmexCardSecurityCodeVersion2"
            case cardHolderVerificationValue = "CardHolderVerificationValue"
            case cardVerificationValue1 = "CardVerificationValue1"
            case cardVerificationValue2 = "CardVerificationValue2"
            case discoverDynamicCardVerificationCode = "DiscoverDynamicCardVerificationCode"
            case dynamicCardVerificationCode = "DynamicCardVerificationCode"
            case dynamicCardVerificationValue = "DynamicCardVerificationValue"
        }
    }

    public enum CryptogramAuthResponse: AWSEncodableShape, Sendable {
        /// Parameters that are required for ARPC response generation using method1 after ARQC verification is successful.
        case arpcMethod1(CryptogramVerificationArpcMethod1)
        /// Parameters that are required for ARPC response generation using method2 after ARQC verification is successful.
        case arpcMethod2(CryptogramVerificationArpcMethod2)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .arpcMethod1(let value):
                try container.encode(value, forKey: .arpcMethod1)
            case .arpcMethod2(let value):
                try container.encode(value, forKey: .arpcMethod2)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .arpcMethod1(let value):
                try value.validate(name: "\(name).arpcMethod1")
            case .arpcMethod2(let value):
                try value.validate(name: "\(name).arpcMethod2")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arpcMethod1 = "ArpcMethod1"
            case arpcMethod2 = "ArpcMethod2"
        }
    }

    public enum EncryptionDecryptionAttributes: AWSEncodableShape, Sendable {
        case asymmetric(AsymmetricEncryptionAttributes)
        case dukpt(DukptEncryptionAttributes)
        /// Parameters for plaintext encryption using EMV keys.
        case emv(EmvEncryptionAttributes)
        /// Parameters that are required to perform encryption and decryption using symmetric keys.
        case symmetric(SymmetricEncryptionAttributes)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .asymmetric(let value):
                try container.encode(value, forKey: .asymmetric)
            case .dukpt(let value):
                try container.encode(value, forKey: .dukpt)
            case .emv(let value):
                try container.encode(value, forKey: .emv)
            case .symmetric(let value):
                try container.encode(value, forKey: .symmetric)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dukpt(let value):
                try value.validate(name: "\(name).dukpt")
            case .emv(let value):
                try value.validate(name: "\(name).emv")
            case .symmetric(let value):
                try value.validate(name: "\(name).symmetric")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case asymmetric = "Asymmetric"
            case dukpt = "Dukpt"
            case emv = "Emv"
            case symmetric = "Symmetric"
        }
    }

    public enum MacAttributes: AWSEncodableShape, Sendable {
        /// The encryption algorithm for MAC generation or verification.
        case algorithm(MacAlgorithm)
        /// Parameters that are required for MAC generation or verification using DUKPT CMAC algorithm.
        case dukptCmac(MacAlgorithmDukpt)
        /// Parameters that are required for MAC generation or verification using DUKPT ISO 9797 algorithm1.
        case dukptIso9797Algorithm1(MacAlgorithmDukpt)
        /// Parameters that are required for MAC generation or verification using DUKPT ISO 9797 algorithm3.
        case dukptIso9797Algorithm3(MacAlgorithmDukpt)
        /// Parameters that are required for MAC generation or verification using EMV MAC algorithm.
        case emvMac(MacAlgorithmEmv)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .algorithm(let value):
                try container.encode(value, forKey: .algorithm)
            case .dukptCmac(let value):
                try container.encode(value, forKey: .dukptCmac)
            case .dukptIso9797Algorithm1(let value):
                try container.encode(value, forKey: .dukptIso9797Algorithm1)
            case .dukptIso9797Algorithm3(let value):
                try container.encode(value, forKey: .dukptIso9797Algorithm3)
            case .emvMac(let value):
                try container.encode(value, forKey: .emvMac)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dukptCmac(let value):
                try value.validate(name: "\(name).dukptCmac")
            case .dukptIso9797Algorithm1(let value):
                try value.validate(name: "\(name).dukptIso9797Algorithm1")
            case .dukptIso9797Algorithm3(let value):
                try value.validate(name: "\(name).dukptIso9797Algorithm3")
            case .emvMac(let value):
                try value.validate(name: "\(name).emvMac")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "Algorithm"
            case dukptCmac = "DukptCmac"
            case dukptIso9797Algorithm1 = "DukptIso9797Algorithm1"
            case dukptIso9797Algorithm3 = "DukptIso9797Algorithm3"
            case emvMac = "EmvMac"
        }
    }

    public enum PinData: AWSDecodableShape, Sendable {
        /// The PIN offset value.
        case pinOffset(String)
        /// The unique data to identify a cardholder. In most cases, this is the same as cardholder's Primary Account Number (PAN). If a value is not provided, it defaults to PAN.
        case verificationValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .pinOffset:
                let value = try container.decode(String.self, forKey: .pinOffset)
                self = .pinOffset(value)
            case .verificationValue:
                let value = try container.decode(String.self, forKey: .verificationValue)
                self = .verificationValue(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case pinOffset = "PinOffset"
            case verificationValue = "VerificationValue"
        }
    }

    public enum PinGenerationAttributes: AWSEncodableShape, Sendable {
        /// Parameters that are required to generate or verify Ibm3624 natural PIN.
        case ibm3624NaturalPin(Ibm3624NaturalPin)
        /// Parameters that are required to generate or verify Ibm3624 PIN from offset PIN.
        case ibm3624PinFromOffset(Ibm3624PinFromOffset)
        /// Parameters that are required to generate or verify Ibm3624 PIN offset PIN.
        case ibm3624PinOffset(Ibm3624PinOffset)
        /// Parameters that are required to generate or verify Ibm3624 random PIN.
        case ibm3624RandomPin(Ibm3624RandomPin)
        /// Parameters that are required to generate or verify Visa PIN.
        case visaPin(VisaPin)
        /// Parameters that are required to generate or verify Visa PIN Verification Value (PVV).
        case visaPinVerificationValue(VisaPinVerificationValue)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .ibm3624NaturalPin(let value):
                try container.encode(value, forKey: .ibm3624NaturalPin)
            case .ibm3624PinFromOffset(let value):
                try container.encode(value, forKey: .ibm3624PinFromOffset)
            case .ibm3624PinOffset(let value):
                try container.encode(value, forKey: .ibm3624PinOffset)
            case .ibm3624RandomPin(let value):
                try container.encode(value, forKey: .ibm3624RandomPin)
            case .visaPin(let value):
                try container.encode(value, forKey: .visaPin)
            case .visaPinVerificationValue(let value):
                try container.encode(value, forKey: .visaPinVerificationValue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .ibm3624NaturalPin(let value):
                try value.validate(name: "\(name).ibm3624NaturalPin")
            case .ibm3624PinFromOffset(let value):
                try value.validate(name: "\(name).ibm3624PinFromOffset")
            case .ibm3624PinOffset(let value):
                try value.validate(name: "\(name).ibm3624PinOffset")
            case .ibm3624RandomPin(let value):
                try value.validate(name: "\(name).ibm3624RandomPin")
            case .visaPin(let value):
                try value.validate(name: "\(name).visaPin")
            case .visaPinVerificationValue(let value):
                try value.validate(name: "\(name).visaPinVerificationValue")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case ibm3624NaturalPin = "Ibm3624NaturalPin"
            case ibm3624PinFromOffset = "Ibm3624PinFromOffset"
            case ibm3624PinOffset = "Ibm3624PinOffset"
            case ibm3624RandomPin = "Ibm3624RandomPin"
            case visaPin = "VisaPin"
            case visaPinVerificationValue = "VisaPinVerificationValue"
        }
    }

    public enum PinVerificationAttributes: AWSEncodableShape, Sendable {
        /// Parameters that are required to generate or verify Ibm3624 PIN.
        case ibm3624Pin(Ibm3624PinVerification)
        /// Parameters that are required to generate or verify Visa PIN.
        case visaPin(VisaPinVerification)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .ibm3624Pin(let value):
                try container.encode(value, forKey: .ibm3624Pin)
            case .visaPin(let value):
                try container.encode(value, forKey: .visaPin)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .ibm3624Pin(let value):
                try value.validate(name: "\(name).ibm3624Pin")
            case .visaPin(let value):
                try value.validate(name: "\(name).visaPin")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case ibm3624Pin = "Ibm3624Pin"
            case visaPin = "VisaPin"
        }
    }

    public enum ReEncryptionAttributes: AWSEncodableShape, Sendable {
        case dukpt(DukptEncryptionAttributes)
        /// Parameters that are required to encrypt data using symmetric keys.
        case symmetric(SymmetricEncryptionAttributes)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dukpt(let value):
                try container.encode(value, forKey: .dukpt)
            case .symmetric(let value):
                try container.encode(value, forKey: .symmetric)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dukpt(let value):
                try value.validate(name: "\(name).dukpt")
            case .symmetric(let value):
                try value.validate(name: "\(name).symmetric")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dukpt = "Dukpt"
            case symmetric = "Symmetric"
        }
    }

    public enum SessionKeyDerivation: AWSEncodableShape, Sendable {
        /// Parameters to derive session key for an Amex payment card for ARQC verification.
        case amex(SessionKeyAmex)
        /// Parameters to derive session key for an Emv2000 payment card for ARQC verification.
        case emv2000(SessionKeyEmv2000)
        /// Parameters to derive session key for an Emv common payment card for ARQC verification.
        case emvCommon(SessionKeyEmvCommon)
        /// Parameters to derive session key for a Mastercard payment card for ARQC verification.
        case mastercard(SessionKeyMastercard)
        /// Parameters to derive session key for a Visa payment cardfor ARQC verification.
        case visa(SessionKeyVisa)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .amex(let value):
                try container.encode(value, forKey: .amex)
            case .emv2000(let value):
                try container.encode(value, forKey: .emv2000)
            case .emvCommon(let value):
                try container.encode(value, forKey: .emvCommon)
            case .mastercard(let value):
                try container.encode(value, forKey: .mastercard)
            case .visa(let value):
                try container.encode(value, forKey: .visa)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .amex(let value):
                try value.validate(name: "\(name).amex")
            case .emv2000(let value):
                try value.validate(name: "\(name).emv2000")
            case .emvCommon(let value):
                try value.validate(name: "\(name).emvCommon")
            case .mastercard(let value):
                try value.validate(name: "\(name).mastercard")
            case .visa(let value):
                try value.validate(name: "\(name).visa")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case amex = "Amex"
            case emv2000 = "Emv2000"
            case emvCommon = "EmvCommon"
            case mastercard = "Mastercard"
            case visa = "Visa"
        }
    }

    public enum SessionKeyDerivationValue: AWSEncodableShape, Sendable {
        /// The cryptogram provided by the terminal during transaction processing.
        case applicationCryptogram(String)
        /// The transaction counter that is provided by the terminal during transaction processing.
        case applicationTransactionCounter(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .applicationCryptogram(let value):
                try container.encode(value, forKey: .applicationCryptogram)
            case .applicationTransactionCounter(let value):
                try container.encode(value, forKey: .applicationTransactionCounter)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .applicationCryptogram(let value):
                try self.validate(value, name: "applicationCryptogram", parent: name, max: 16)
                try self.validate(value, name: "applicationCryptogram", parent: name, min: 16)
                try self.validate(value, name: "applicationCryptogram", parent: name, pattern: "^[0-9a-fA-F]+$")
            case .applicationTransactionCounter(let value):
                try self.validate(value, name: "applicationTransactionCounter", parent: name, max: 4)
                try self.validate(value, name: "applicationTransactionCounter", parent: name, min: 2)
                try self.validate(value, name: "applicationTransactionCounter", parent: name, pattern: "^[0-9a-fA-F]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicationCryptogram = "ApplicationCryptogram"
            case applicationTransactionCounter = "ApplicationTransactionCounter"
        }
    }

    public enum TranslationIsoFormats: AWSEncodableShape, Sendable {
        /// Parameters that are required for ISO9564 PIN format 0 tranlation.
        case isoFormat0(TranslationPinDataIsoFormat034)
        /// Parameters that are required for ISO9564 PIN format 1 tranlation.
        case isoFormat1(TranslationPinDataIsoFormat1)
        /// Parameters that are required for ISO9564 PIN format 3 tranlation.
        case isoFormat3(TranslationPinDataIsoFormat034)
        /// Parameters that are required for ISO9564 PIN format 4 tranlation.
        case isoFormat4(TranslationPinDataIsoFormat034)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .isoFormat0(let value):
                try container.encode(value, forKey: .isoFormat0)
            case .isoFormat1(let value):
                try container.encode(value, forKey: .isoFormat1)
            case .isoFormat3(let value):
                try container.encode(value, forKey: .isoFormat3)
            case .isoFormat4(let value):
                try container.encode(value, forKey: .isoFormat4)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .isoFormat0(let value):
                try value.validate(name: "\(name).isoFormat0")
            case .isoFormat3(let value):
                try value.validate(name: "\(name).isoFormat3")
            case .isoFormat4(let value):
                try value.validate(name: "\(name).isoFormat4")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case isoFormat0 = "IsoFormat0"
            case isoFormat1 = "IsoFormat1"
            case isoFormat3 = "IsoFormat3"
            case isoFormat4 = "IsoFormat4"
        }
    }

    // MARK: Shapes

    public struct AmexCardSecurityCodeVersion1: AWSEncodableShape {
        /// The expiry date of a payment card.
        public let cardExpiryDate: String

        public init(cardExpiryDate: String) {
            self.cardExpiryDate = cardExpiryDate
        }

        public func validate(name: String) throws {
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, max: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, min: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case cardExpiryDate = "CardExpiryDate"
        }
    }

    public struct AmexCardSecurityCodeVersion2: AWSEncodableShape {
        /// The expiry date of a payment card.
        public let cardExpiryDate: String
        /// The service code of the AMEX payment card. This is different from the Card Security Code (CSC).
        public let serviceCode: String

        public init(cardExpiryDate: String, serviceCode: String) {
            self.cardExpiryDate = cardExpiryDate
            self.serviceCode = serviceCode
        }

        public func validate(name: String) throws {
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, max: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, min: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, max: 3)
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, min: 3)
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case cardExpiryDate = "CardExpiryDate"
            case serviceCode = "ServiceCode"
        }
    }

    public struct AsymmetricEncryptionAttributes: AWSEncodableShape {
        /// The padding to be included with the data.
        public let paddingType: PaddingType?

        public init(paddingType: PaddingType? = nil) {
            self.paddingType = paddingType
        }

        private enum CodingKeys: String, CodingKey {
            case paddingType = "PaddingType"
        }
    }

    public struct CardHolderVerificationValue: AWSEncodableShape {
        /// The transaction counter value that comes from a point of sale terminal.
        public let applicationTransactionCounter: String
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        public let panSequenceNumber: String
        /// A random number generated by the issuer.
        public let unpredictableNumber: String

        public init(applicationTransactionCounter: String, panSequenceNumber: String, unpredictableNumber: String) {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.unpredictableNumber = unpredictableNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, max: 4)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, min: 2)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, max: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, min: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, max: 8)
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, min: 2)
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationTransactionCounter = "ApplicationTransactionCounter"
            case panSequenceNumber = "PanSequenceNumber"
            case unpredictableNumber = "UnpredictableNumber"
        }
    }

    public struct CardVerificationValue1: AWSEncodableShape {
        /// The expiry date of a payment card.
        public let cardExpiryDate: String
        /// The service code of the payment card. This is different from Card Security Code (CSC).
        public let serviceCode: String

        public init(cardExpiryDate: String, serviceCode: String) {
            self.cardExpiryDate = cardExpiryDate
            self.serviceCode = serviceCode
        }

        public func validate(name: String) throws {
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, max: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, min: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, max: 3)
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, min: 3)
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case cardExpiryDate = "CardExpiryDate"
            case serviceCode = "ServiceCode"
        }
    }

    public struct CardVerificationValue2: AWSEncodableShape {
        /// The expiry date of a payment card.
        public let cardExpiryDate: String

        public init(cardExpiryDate: String) {
            self.cardExpiryDate = cardExpiryDate
        }

        public func validate(name: String) throws {
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, max: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, min: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case cardExpiryDate = "CardExpiryDate"
        }
    }

    public struct CryptogramVerificationArpcMethod1: AWSEncodableShape {
        /// The auth code used to calculate APRC after ARQC verification is successful. This is the same auth code used for ARQC generation outside of Amazon Web Services Payment Cryptography.
        public let authResponseCode: String

        public init(authResponseCode: String) {
            self.authResponseCode = authResponseCode
        }

        public func validate(name: String) throws {
            try self.validate(self.authResponseCode, name: "authResponseCode", parent: name, max: 4)
            try self.validate(self.authResponseCode, name: "authResponseCode", parent: name, min: 4)
            try self.validate(self.authResponseCode, name: "authResponseCode", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authResponseCode = "AuthResponseCode"
        }
    }

    public struct CryptogramVerificationArpcMethod2: AWSEncodableShape {
        /// The data indicating whether the issuer approves or declines an online transaction using an EMV chip card.
        public let cardStatusUpdate: String
        /// The proprietary authentication data used by issuer for communication during online transaction using an EMV chip card.
        public let proprietaryAuthenticationData: String?

        public init(cardStatusUpdate: String, proprietaryAuthenticationData: String? = nil) {
            self.cardStatusUpdate = cardStatusUpdate
            self.proprietaryAuthenticationData = proprietaryAuthenticationData
        }

        public func validate(name: String) throws {
            try self.validate(self.cardStatusUpdate, name: "cardStatusUpdate", parent: name, max: 8)
            try self.validate(self.cardStatusUpdate, name: "cardStatusUpdate", parent: name, min: 8)
            try self.validate(self.cardStatusUpdate, name: "cardStatusUpdate", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.proprietaryAuthenticationData, name: "proprietaryAuthenticationData", parent: name, max: 16)
            try self.validate(self.proprietaryAuthenticationData, name: "proprietaryAuthenticationData", parent: name, min: 1)
            try self.validate(self.proprietaryAuthenticationData, name: "proprietaryAuthenticationData", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case cardStatusUpdate = "CardStatusUpdate"
            case proprietaryAuthenticationData = "ProprietaryAuthenticationData"
        }
    }

    public struct DecryptDataInput: AWSEncodableShape {
        /// The ciphertext to decrypt.
        public let cipherText: String
        /// The encryption key type and attributes for ciphertext decryption.
        public let decryptionAttributes: EncryptionDecryptionAttributes
        /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for ciphertext decryption.
        public let keyIdentifier: String

        public init(cipherText: String, decryptionAttributes: EncryptionDecryptionAttributes, keyIdentifier: String) {
            self.cipherText = cipherText
            self.decryptionAttributes = decryptionAttributes
            self.keyIdentifier = keyIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.cipherText, forKey: .cipherText)
            try container.encode(self.decryptionAttributes, forKey: .decryptionAttributes)
            request.encodePath(self.keyIdentifier, key: "KeyIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.cipherText, name: "cipherText", parent: name, max: 4096)
            try self.validate(self.cipherText, name: "cipherText", parent: name, min: 16)
            try self.validate(self.cipherText, name: "cipherText", parent: name, pattern: "^(?:[0-9a-fA-F][0-9a-fA-F])+$")
            try self.decryptionAttributes.validate(name: "\(name).decryptionAttributes")
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, max: 322)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, min: 7)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case cipherText = "CipherText"
            case decryptionAttributes = "DecryptionAttributes"
        }
    }

    public struct DecryptDataOutput: AWSDecodableShape {
        /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for ciphertext decryption.
        public let keyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let keyCheckValue: String
        /// The decrypted plaintext data in hexBinary format.
        public let plainText: String

        public init(keyArn: String, keyCheckValue: String, plainText: String) {
            self.keyArn = keyArn
            self.keyCheckValue = keyCheckValue
            self.plainText = plainText
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "KeyArn"
            case keyCheckValue = "KeyCheckValue"
            case plainText = "PlainText"
        }
    }

    public struct DiscoverDynamicCardVerificationCode: AWSEncodableShape {
        /// The transaction counter value that comes from the terminal.
        public let applicationTransactionCounter: String
        /// The expiry date of a payment card.
        public let cardExpiryDate: String
        /// A random number that is generated by the issuer.
        public let unpredictableNumber: String

        public init(applicationTransactionCounter: String, cardExpiryDate: String, unpredictableNumber: String) {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.cardExpiryDate = cardExpiryDate
            self.unpredictableNumber = unpredictableNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, max: 4)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, min: 2)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, max: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, min: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, max: 8)
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, min: 2)
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationTransactionCounter = "ApplicationTransactionCounter"
            case cardExpiryDate = "CardExpiryDate"
            case unpredictableNumber = "UnpredictableNumber"
        }
    }

    public struct DukptAttributes: AWSEncodableShape {
        /// The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY.
        public let dukptDerivationType: DukptDerivationType
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        public let keySerialNumber: String

        public init(dukptDerivationType: DukptDerivationType, keySerialNumber: String) {
            self.dukptDerivationType = dukptDerivationType
            self.keySerialNumber = keySerialNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, max: 24)
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, min: 10)
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dukptDerivationType = "DukptDerivationType"
            case keySerialNumber = "KeySerialNumber"
        }
    }

    public struct DukptDerivationAttributes: AWSEncodableShape {
        /// The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY
        public let dukptKeyDerivationType: DukptDerivationType?
        /// The type of use of DUKPT, which can be for incoming data decryption, outgoing data encryption, or both.
        public let dukptKeyVariant: DukptKeyVariant?
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        public let keySerialNumber: String

        public init(dukptKeyDerivationType: DukptDerivationType? = nil, dukptKeyVariant: DukptKeyVariant? = nil, keySerialNumber: String) {
            self.dukptKeyDerivationType = dukptKeyDerivationType
            self.dukptKeyVariant = dukptKeyVariant
            self.keySerialNumber = keySerialNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, max: 24)
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, min: 10)
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dukptKeyDerivationType = "DukptKeyDerivationType"
            case dukptKeyVariant = "DukptKeyVariant"
            case keySerialNumber = "KeySerialNumber"
        }
    }

    public struct DukptEncryptionAttributes: AWSEncodableShape {
        /// The key type encrypted using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY
        public let dukptKeyDerivationType: DukptDerivationType?
        /// The type of use of DUKPT, which can be incoming data decryption, outgoing data encryption, or both.
        public let dukptKeyVariant: DukptKeyVariant?
        /// An input used to provide the intial state. If no value is provided, Amazon Web Services Payment Cryptography defaults it to zero.
        public let initializationVector: String?
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        public let keySerialNumber: String
        /// The block cipher method to use for encryption. The default is CBC.
        public let mode: DukptEncryptionMode?

        public init(dukptKeyDerivationType: DukptDerivationType? = nil, dukptKeyVariant: DukptKeyVariant? = nil, initializationVector: String? = nil, keySerialNumber: String, mode: DukptEncryptionMode? = nil) {
            self.dukptKeyDerivationType = dukptKeyDerivationType
            self.dukptKeyVariant = dukptKeyVariant
            self.initializationVector = initializationVector
            self.keySerialNumber = keySerialNumber
            self.mode = mode
        }

        public func validate(name: String) throws {
            try self.validate(self.initializationVector, name: "initializationVector", parent: name, max: 32)
            try self.validate(self.initializationVector, name: "initializationVector", parent: name, min: 16)
            try self.validate(self.initializationVector, name: "initializationVector", parent: name, pattern: "^(?:[0-9a-fA-F]{16}|[0-9a-fA-F]{32})$")
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, max: 24)
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, min: 10)
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dukptKeyDerivationType = "DukptKeyDerivationType"
            case dukptKeyVariant = "DukptKeyVariant"
            case initializationVector = "InitializationVector"
            case keySerialNumber = "KeySerialNumber"
            case mode = "Mode"
        }
    }

    public struct DynamicCardVerificationCode: AWSEncodableShape {
        /// The transaction counter value that comes from the terminal.
        public let applicationTransactionCounter: String
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        public let panSequenceNumber: String
        /// The data on the two tracks of magnetic cards used for financial transactions. This includes the cardholder name, PAN, expiration date, bank ID (BIN) and several other numbers the issuing bank uses to validate the data received.
        public let trackData: String
        /// A random number generated by the issuer.
        public let unpredictableNumber: String

        public init(applicationTransactionCounter: String, panSequenceNumber: String, trackData: String, unpredictableNumber: String) {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.trackData = trackData
            self.unpredictableNumber = unpredictableNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, max: 4)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, min: 2)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, max: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, min: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.trackData, name: "trackData", parent: name, max: 160)
            try self.validate(self.trackData, name: "trackData", parent: name, min: 2)
            try self.validate(self.trackData, name: "trackData", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, max: 8)
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, min: 2)
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationTransactionCounter = "ApplicationTransactionCounter"
            case panSequenceNumber = "PanSequenceNumber"
            case trackData = "TrackData"
            case unpredictableNumber = "UnpredictableNumber"
        }
    }

    public struct DynamicCardVerificationValue: AWSEncodableShape {
        /// The transaction counter value that comes from the terminal.
        public let applicationTransactionCounter: String
        /// The expiry date of a payment card.
        public let cardExpiryDate: String
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        public let panSequenceNumber: String
        /// The service code of the payment card. This is different from Card Security Code (CSC).
        public let serviceCode: String

        public init(applicationTransactionCounter: String, cardExpiryDate: String, panSequenceNumber: String, serviceCode: String) {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.cardExpiryDate = cardExpiryDate
            self.panSequenceNumber = panSequenceNumber
            self.serviceCode = serviceCode
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, max: 4)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, min: 2)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, max: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, min: 4)
            try self.validate(self.cardExpiryDate, name: "cardExpiryDate", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, max: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, min: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, max: 3)
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, min: 3)
            try self.validate(self.serviceCode, name: "serviceCode", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationTransactionCounter = "ApplicationTransactionCounter"
            case cardExpiryDate = "CardExpiryDate"
            case panSequenceNumber = "PanSequenceNumber"
            case serviceCode = "ServiceCode"
        }
    }

    public struct EmvEncryptionAttributes: AWSEncodableShape {
        /// An input used to provide the intial state. If no value is provided, Amazon Web Services Payment Cryptography defaults it to zero.
        public let initializationVector: String?
        /// The EMV derivation mode to use for ICC master key derivation as per EMV version 4.3 book 2.
        public let majorKeyDerivationMode: EmvMajorKeyDerivationMode
        /// The block cipher method to use for encryption.
        public let mode: EmvEncryptionMode?
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        public let panSequenceNumber: String
        /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        public let primaryAccountNumber: String
        /// The derivation value used to derive the ICC session key. It is typically the application transaction counter value padded with zeros or previous ARQC value padded with zeros as per EMV version 4.3 book 2.
        public let sessionDerivationData: String

        public init(initializationVector: String? = nil, majorKeyDerivationMode: EmvMajorKeyDerivationMode, mode: EmvEncryptionMode? = nil, panSequenceNumber: String, primaryAccountNumber: String, sessionDerivationData: String) {
            self.initializationVector = initializationVector
            self.majorKeyDerivationMode = majorKeyDerivationMode
            self.mode = mode
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
            self.sessionDerivationData = sessionDerivationData
        }

        public func validate(name: String) throws {
            try self.validate(self.initializationVector, name: "initializationVector", parent: name, max: 32)
            try self.validate(self.initializationVector, name: "initializationVector", parent: name, min: 16)
            try self.validate(self.initializationVector, name: "initializationVector", parent: name, pattern: "^(?:[0-9a-fA-F]{16}|[0-9a-fA-F]{32})$")
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, max: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, min: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sessionDerivationData, name: "sessionDerivationData", parent: name, max: 16)
            try self.validate(self.sessionDerivationData, name: "sessionDerivationData", parent: name, min: 16)
            try self.validate(self.sessionDerivationData, name: "sessionDerivationData", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case initializationVector = "InitializationVector"
            case majorKeyDerivationMode = "MajorKeyDerivationMode"
            case mode = "Mode"
            case panSequenceNumber = "PanSequenceNumber"
            case primaryAccountNumber = "PrimaryAccountNumber"
            case sessionDerivationData = "SessionDerivationData"
        }
    }

    public struct EncryptDataInput: AWSEncodableShape {
        /// The encryption key type and attributes for plaintext encryption.
        public let encryptionAttributes: EncryptionDecryptionAttributes
        /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.
        public let keyIdentifier: String
        /// The plaintext to be encrypted.  For encryption using asymmetric keys, plaintext data length is constrained by encryption key strength that you define in KeyAlgorithm and padding type that you define in AsymmetricEncryptionAttributes. For more information, see Encrypt data in the Amazon Web Services Payment Cryptography User Guide.
        public let plainText: String

        public init(encryptionAttributes: EncryptionDecryptionAttributes, keyIdentifier: String, plainText: String) {
            self.encryptionAttributes = encryptionAttributes
            self.keyIdentifier = keyIdentifier
            self.plainText = plainText
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.encryptionAttributes, forKey: .encryptionAttributes)
            request.encodePath(self.keyIdentifier, key: "KeyIdentifier")
            try container.encode(self.plainText, forKey: .plainText)
        }

        public func validate(name: String) throws {
            try self.encryptionAttributes.validate(name: "\(name).encryptionAttributes")
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, max: 322)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, min: 7)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.validate(self.plainText, name: "plainText", parent: name, max: 4064)
            try self.validate(self.plainText, name: "plainText", parent: name, min: 16)
            try self.validate(self.plainText, name: "plainText", parent: name, pattern: "^(?:[0-9a-fA-F][0-9a-fA-F])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAttributes = "EncryptionAttributes"
            case plainText = "PlainText"
        }
    }

    public struct EncryptDataOutput: AWSDecodableShape {
        /// The encrypted ciphertext.
        public let cipherText: String
        /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.
        public let keyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let keyCheckValue: String?

        public init(cipherText: String, keyArn: String, keyCheckValue: String? = nil) {
            self.cipherText = cipherText
            self.keyArn = keyArn
            self.keyCheckValue = keyCheckValue
        }

        private enum CodingKeys: String, CodingKey {
            case cipherText = "CipherText"
            case keyArn = "KeyArn"
            case keyCheckValue = "KeyCheckValue"
        }
    }

    public struct GenerateCardValidationDataInput: AWSEncodableShape {
        /// The algorithm for generating CVV or CSC values for the card within Amazon Web Services Payment Cryptography.
        public let generationAttributes: CardGenerationAttributes
        /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to generate card data.
        public let keyIdentifier: String
        /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
        public let primaryAccountNumber: String
        /// The length of the CVV or CSC to be generated. The default value is 3.
        public let validationDataLength: Int?

        public init(generationAttributes: CardGenerationAttributes, keyIdentifier: String, primaryAccountNumber: String, validationDataLength: Int? = nil) {
            self.generationAttributes = generationAttributes
            self.keyIdentifier = keyIdentifier
            self.primaryAccountNumber = primaryAccountNumber
            self.validationDataLength = validationDataLength
        }

        public func validate(name: String) throws {
            try self.generationAttributes.validate(name: "\(name).generationAttributes")
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, max: 322)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, min: 7)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.validationDataLength, name: "validationDataLength", parent: name, max: 5)
            try self.validate(self.validationDataLength, name: "validationDataLength", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case generationAttributes = "GenerationAttributes"
            case keyIdentifier = "KeyIdentifier"
            case primaryAccountNumber = "PrimaryAccountNumber"
            case validationDataLength = "ValidationDataLength"
        }
    }

    public struct GenerateCardValidationDataOutput: AWSDecodableShape {
        /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to generate CVV or CSC.
        public let keyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let keyCheckValue: String
        /// The CVV or CSC value that Amazon Web Services Payment Cryptography generates for the card.
        public let validationData: String

        public init(keyArn: String, keyCheckValue: String, validationData: String) {
            self.keyArn = keyArn
            self.keyCheckValue = keyCheckValue
            self.validationData = validationData
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "KeyArn"
            case keyCheckValue = "KeyCheckValue"
            case validationData = "ValidationData"
        }
    }

    public struct GenerateMacInput: AWSEncodableShape {
        /// The attributes and data values to use for MAC generation within Amazon Web Services Payment Cryptography.
        public let generationAttributes: MacAttributes
        /// The keyARN of the MAC generation encryption key.
        public let keyIdentifier: String
        /// The length of a MAC under generation.
        public let macLength: Int?
        /// The data for which a MAC is under generation. This value must be hexBinary.
        public let messageData: String

        public init(generationAttributes: MacAttributes, keyIdentifier: String, macLength: Int? = nil, messageData: String) {
            self.generationAttributes = generationAttributes
            self.keyIdentifier = keyIdentifier
            self.macLength = macLength
            self.messageData = messageData
        }

        public func validate(name: String) throws {
            try self.generationAttributes.validate(name: "\(name).generationAttributes")
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, max: 322)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, min: 7)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.validate(self.macLength, name: "macLength", parent: name, max: 16)
            try self.validate(self.macLength, name: "macLength", parent: name, min: 4)
            try self.validate(self.messageData, name: "messageData", parent: name, max: 4096)
            try self.validate(self.messageData, name: "messageData", parent: name, min: 2)
            try self.validate(self.messageData, name: "messageData", parent: name, pattern: "^(?:[0-9a-fA-F][0-9a-fA-F])+$")
        }

        private enum CodingKeys: String, CodingKey {
            case generationAttributes = "GenerationAttributes"
            case keyIdentifier = "KeyIdentifier"
            case macLength = "MacLength"
            case messageData = "MessageData"
        }
    }

    public struct GenerateMacOutput: AWSDecodableShape {
        /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for MAC generation.
        public let keyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let keyCheckValue: String
        /// The MAC cryptogram generated within Amazon Web Services Payment Cryptography.
        public let mac: String

        public init(keyArn: String, keyCheckValue: String, mac: String) {
            self.keyArn = keyArn
            self.keyCheckValue = keyCheckValue
            self.mac = mac
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "KeyArn"
            case keyCheckValue = "KeyCheckValue"
            case mac = "Mac"
        }
    }

    public struct GeneratePinDataInput: AWSEncodableShape {
        /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses to encrypt the PIN Block.
        public let encryptionKeyIdentifier: String
        /// The attributes and values to use for PIN, PVV, or PIN Offset generation.
        public let generationAttributes: PinGenerationAttributes
        /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses for pin data generation.
        public let generationKeyIdentifier: String
        /// The PIN encoding format for pin data generation as specified in ISO 9564. Amazon Web Services Payment Cryptography supports ISO_Format_0 and ISO_Format_3. The ISO_Format_0 PIN block format is equivalent to the ANSI X9.8, VISA-1, and ECI-1 PIN block formats. It is similar to a VISA-4 PIN block format. It supports a PIN from 4 to 12 digits in length. The ISO_Format_3 PIN block format is the same as ISO_Format_0 except that the fill digits are random values from 10 to 15.
        public let pinBlockFormat: PinBlockFormatForPinData
        /// The length of PIN under generation.
        public let pinDataLength: Int?
        /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
        public let primaryAccountNumber: String

        public init(encryptionKeyIdentifier: String, generationAttributes: PinGenerationAttributes, generationKeyIdentifier: String, pinBlockFormat: PinBlockFormatForPinData, pinDataLength: Int? = nil, primaryAccountNumber: String) {
            self.encryptionKeyIdentifier = encryptionKeyIdentifier
            self.generationAttributes = generationAttributes
            self.generationKeyIdentifier = generationKeyIdentifier
            self.pinBlockFormat = pinBlockFormat
            self.pinDataLength = pinDataLength
            self.primaryAccountNumber = primaryAccountNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.encryptionKeyIdentifier, name: "encryptionKeyIdentifier", parent: name, max: 322)
            try self.validate(self.encryptionKeyIdentifier, name: "encryptionKeyIdentifier", parent: name, min: 7)
            try self.validate(self.encryptionKeyIdentifier, name: "encryptionKeyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.generationAttributes.validate(name: "\(name).generationAttributes")
            try self.validate(self.generationKeyIdentifier, name: "generationKeyIdentifier", parent: name, max: 322)
            try self.validate(self.generationKeyIdentifier, name: "generationKeyIdentifier", parent: name, min: 7)
            try self.validate(self.generationKeyIdentifier, name: "generationKeyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.validate(self.pinDataLength, name: "pinDataLength", parent: name, max: 12)
            try self.validate(self.pinDataLength, name: "pinDataLength", parent: name, min: 4)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionKeyIdentifier = "EncryptionKeyIdentifier"
            case generationAttributes = "GenerationAttributes"
            case generationKeyIdentifier = "GenerationKeyIdentifier"
            case pinBlockFormat = "PinBlockFormat"
            case pinDataLength = "PinDataLength"
            case primaryAccountNumber = "PrimaryAccountNumber"
        }
    }

    public struct GeneratePinDataOutput: AWSDecodableShape {
        /// The PIN block encrypted under PEK from Amazon Web Services Payment Cryptography. The encrypted PIN block is a composite of PAN (Primary Account Number) and PIN (Personal Identification Number), generated in accordance with ISO 9564 standard.
        public let encryptedPinBlock: String
        /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses for encrypted pin block generation.
        public let encryptionKeyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let encryptionKeyCheckValue: String
        /// The keyARN of the pin data generation key that Amazon Web Services Payment Cryptography uses for PIN, PVV or PIN Offset generation.
        public let generationKeyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let generationKeyCheckValue: String
        /// The attributes and values Amazon Web Services Payment Cryptography uses for pin data generation.
        public let pinData: PinData

        public init(encryptedPinBlock: String, encryptionKeyArn: String, encryptionKeyCheckValue: String, generationKeyArn: String, generationKeyCheckValue: String, pinData: PinData) {
            self.encryptedPinBlock = encryptedPinBlock
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionKeyCheckValue = encryptionKeyCheckValue
            self.generationKeyArn = generationKeyArn
            self.generationKeyCheckValue = generationKeyCheckValue
            self.pinData = pinData
        }

        private enum CodingKeys: String, CodingKey {
            case encryptedPinBlock = "EncryptedPinBlock"
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionKeyCheckValue = "EncryptionKeyCheckValue"
            case generationKeyArn = "GenerationKeyArn"
            case generationKeyCheckValue = "GenerationKeyCheckValue"
            case pinData = "PinData"
        }
    }

    public struct Ibm3624NaturalPin: AWSEncodableShape {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        public let decimalizationTable: String
        /// The unique data for cardholder identification.
        public let pinValidationData: String
        /// The padding character for validation data.
        public let pinValidationDataPadCharacter: String

        public init(decimalizationTable: String, pinValidationData: String, pinValidationDataPadCharacter: String) {
            self.decimalizationTable = decimalizationTable
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }

        public func validate(name: String) throws {
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, max: 16)
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, min: 16)
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, max: 16)
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, min: 4)
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, max: 1)
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, min: 1)
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, pattern: "^[0-9A-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case decimalizationTable = "DecimalizationTable"
            case pinValidationData = "PinValidationData"
            case pinValidationDataPadCharacter = "PinValidationDataPadCharacter"
        }
    }

    public struct Ibm3624PinFromOffset: AWSEncodableShape {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        public let decimalizationTable: String
        /// The PIN offset value.
        public let pinOffset: String
        /// The unique data for cardholder identification.
        public let pinValidationData: String
        /// The padding character for validation data.
        public let pinValidationDataPadCharacter: String

        public init(decimalizationTable: String, pinOffset: String, pinValidationData: String, pinValidationDataPadCharacter: String) {
            self.decimalizationTable = decimalizationTable
            self.pinOffset = pinOffset
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }

        public func validate(name: String) throws {
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, max: 16)
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, min: 16)
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinOffset, name: "pinOffset", parent: name, max: 12)
            try self.validate(self.pinOffset, name: "pinOffset", parent: name, min: 4)
            try self.validate(self.pinOffset, name: "pinOffset", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, max: 16)
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, min: 4)
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, max: 1)
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, min: 1)
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, pattern: "^[0-9A-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case decimalizationTable = "DecimalizationTable"
            case pinOffset = "PinOffset"
            case pinValidationData = "PinValidationData"
            case pinValidationDataPadCharacter = "PinValidationDataPadCharacter"
        }
    }

    public struct Ibm3624PinOffset: AWSEncodableShape {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        public let decimalizationTable: String
        /// The encrypted PIN block data. According to ISO 9564 standard, a PIN Block is an encoded representation of a payment card Personal Account Number (PAN) and the cardholder Personal Identification Number (PIN).
        public let encryptedPinBlock: String
        /// The unique data for cardholder identification.
        public let pinValidationData: String
        /// The padding character for validation data.
        public let pinValidationDataPadCharacter: String

        public init(decimalizationTable: String, encryptedPinBlock: String, pinValidationData: String, pinValidationDataPadCharacter: String) {
            self.decimalizationTable = decimalizationTable
            self.encryptedPinBlock = encryptedPinBlock
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }

        public func validate(name: String) throws {
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, max: 16)
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, min: 16)
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, max: 32)
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, min: 16)
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, max: 16)
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, min: 4)
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, max: 1)
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, min: 1)
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, pattern: "^[0-9A-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case decimalizationTable = "DecimalizationTable"
            case encryptedPinBlock = "EncryptedPinBlock"
            case pinValidationData = "PinValidationData"
            case pinValidationDataPadCharacter = "PinValidationDataPadCharacter"
        }
    }

    public struct Ibm3624PinVerification: AWSEncodableShape {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        public let decimalizationTable: String
        /// The PIN offset value.
        public let pinOffset: String
        /// The unique data for cardholder identification.
        public let pinValidationData: String
        /// The padding character for validation data.
        public let pinValidationDataPadCharacter: String

        public init(decimalizationTable: String, pinOffset: String, pinValidationData: String, pinValidationDataPadCharacter: String) {
            self.decimalizationTable = decimalizationTable
            self.pinOffset = pinOffset
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }

        public func validate(name: String) throws {
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, max: 16)
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, min: 16)
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinOffset, name: "pinOffset", parent: name, max: 12)
            try self.validate(self.pinOffset, name: "pinOffset", parent: name, min: 4)
            try self.validate(self.pinOffset, name: "pinOffset", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, max: 16)
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, min: 4)
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, max: 1)
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, min: 1)
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, pattern: "^[0-9A-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case decimalizationTable = "DecimalizationTable"
            case pinOffset = "PinOffset"
            case pinValidationData = "PinValidationData"
            case pinValidationDataPadCharacter = "PinValidationDataPadCharacter"
        }
    }

    public struct Ibm3624RandomPin: AWSEncodableShape {
        /// The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.
        public let decimalizationTable: String
        /// The unique data for cardholder identification.
        public let pinValidationData: String
        /// The padding character for validation data.
        public let pinValidationDataPadCharacter: String

        public init(decimalizationTable: String, pinValidationData: String, pinValidationDataPadCharacter: String) {
            self.decimalizationTable = decimalizationTable
            self.pinValidationData = pinValidationData
            self.pinValidationDataPadCharacter = pinValidationDataPadCharacter
        }

        public func validate(name: String) throws {
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, max: 16)
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, min: 16)
            try self.validate(self.decimalizationTable, name: "decimalizationTable", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, max: 16)
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, min: 4)
            try self.validate(self.pinValidationData, name: "pinValidationData", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, max: 1)
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, min: 1)
            try self.validate(self.pinValidationDataPadCharacter, name: "pinValidationDataPadCharacter", parent: name, pattern: "^[0-9A-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case decimalizationTable = "DecimalizationTable"
            case pinValidationData = "PinValidationData"
            case pinValidationDataPadCharacter = "PinValidationDataPadCharacter"
        }
    }

    public struct MacAlgorithmDukpt: AWSEncodableShape {
        /// The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use AES_128 as a derivation type for a BDK of AES_128 or TDES_2KEY.
        public let dukptDerivationType: DukptDerivationType?
        /// The type of use of DUKPT, which can be MAC generation, MAC verification, or both.
        public let dukptKeyVariant: DukptKeyVariant
        /// The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.
        public let keySerialNumber: String

        public init(dukptDerivationType: DukptDerivationType? = nil, dukptKeyVariant: DukptKeyVariant, keySerialNumber: String) {
            self.dukptDerivationType = dukptDerivationType
            self.dukptKeyVariant = dukptKeyVariant
            self.keySerialNumber = keySerialNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, max: 24)
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, min: 10)
            try self.validate(self.keySerialNumber, name: "keySerialNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dukptDerivationType = "DukptDerivationType"
            case dukptKeyVariant = "DukptKeyVariant"
            case keySerialNumber = "KeySerialNumber"
        }
    }

    public struct MacAlgorithmEmv: AWSEncodableShape {
        /// The method to use when deriving the master key for EMV MAC generation or verification.
        public let majorKeyDerivationMode: MajorKeyDerivationMode
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        public let panSequenceNumber: String
        /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        public let primaryAccountNumber: String
        /// The method of deriving a session key for EMV MAC generation or verification.
        public let sessionKeyDerivationMode: SessionKeyDerivationMode
        /// Parameters that are required to generate session key for EMV generation and verification.
        public let sessionKeyDerivationValue: SessionKeyDerivationValue

        public init(majorKeyDerivationMode: MajorKeyDerivationMode, panSequenceNumber: String, primaryAccountNumber: String, sessionKeyDerivationMode: SessionKeyDerivationMode, sessionKeyDerivationValue: SessionKeyDerivationValue) {
            self.majorKeyDerivationMode = majorKeyDerivationMode
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
            self.sessionKeyDerivationMode = sessionKeyDerivationMode
            self.sessionKeyDerivationValue = sessionKeyDerivationValue
        }

        public func validate(name: String) throws {
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, max: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, min: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
            try self.sessionKeyDerivationValue.validate(name: "\(name).sessionKeyDerivationValue")
        }

        private enum CodingKeys: String, CodingKey {
            case majorKeyDerivationMode = "MajorKeyDerivationMode"
            case panSequenceNumber = "PanSequenceNumber"
            case primaryAccountNumber = "PrimaryAccountNumber"
            case sessionKeyDerivationMode = "SessionKeyDerivationMode"
            case sessionKeyDerivationValue = "SessionKeyDerivationValue"
        }
    }

    public struct ReEncryptDataInput: AWSEncodableShape {
        /// Ciphertext to be encrypted. The minimum allowed length is 16 bytes and maximum allowed length is 4096 bytes.
        public let cipherText: String
        /// The attributes and values for incoming ciphertext.
        public let incomingEncryptionAttributes: ReEncryptionAttributes
        /// The keyARN of the encryption key of incoming ciphertext data.
        public let incomingKeyIdentifier: String
        /// The attributes and values for outgoing ciphertext data after encryption by Amazon Web Services Payment Cryptography.
        public let outgoingEncryptionAttributes: ReEncryptionAttributes
        /// The keyARN of the encryption key of outgoing ciphertext data after encryption by Amazon Web Services Payment Cryptography.
        public let outgoingKeyIdentifier: String

        public init(cipherText: String, incomingEncryptionAttributes: ReEncryptionAttributes, incomingKeyIdentifier: String, outgoingEncryptionAttributes: ReEncryptionAttributes, outgoingKeyIdentifier: String) {
            self.cipherText = cipherText
            self.incomingEncryptionAttributes = incomingEncryptionAttributes
            self.incomingKeyIdentifier = incomingKeyIdentifier
            self.outgoingEncryptionAttributes = outgoingEncryptionAttributes
            self.outgoingKeyIdentifier = outgoingKeyIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.cipherText, forKey: .cipherText)
            try container.encode(self.incomingEncryptionAttributes, forKey: .incomingEncryptionAttributes)
            request.encodePath(self.incomingKeyIdentifier, key: "IncomingKeyIdentifier")
            try container.encode(self.outgoingEncryptionAttributes, forKey: .outgoingEncryptionAttributes)
            try container.encode(self.outgoingKeyIdentifier, forKey: .outgoingKeyIdentifier)
        }

        public func validate(name: String) throws {
            try self.validate(self.cipherText, name: "cipherText", parent: name, max: 4096)
            try self.validate(self.cipherText, name: "cipherText", parent: name, min: 16)
            try self.validate(self.cipherText, name: "cipherText", parent: name, pattern: "^(?:[0-9a-fA-F][0-9a-fA-F])+$")
            try self.incomingEncryptionAttributes.validate(name: "\(name).incomingEncryptionAttributes")
            try self.validate(self.incomingKeyIdentifier, name: "incomingKeyIdentifier", parent: name, max: 322)
            try self.validate(self.incomingKeyIdentifier, name: "incomingKeyIdentifier", parent: name, min: 7)
            try self.validate(self.incomingKeyIdentifier, name: "incomingKeyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.outgoingEncryptionAttributes.validate(name: "\(name).outgoingEncryptionAttributes")
            try self.validate(self.outgoingKeyIdentifier, name: "outgoingKeyIdentifier", parent: name, max: 322)
            try self.validate(self.outgoingKeyIdentifier, name: "outgoingKeyIdentifier", parent: name, min: 7)
            try self.validate(self.outgoingKeyIdentifier, name: "outgoingKeyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case cipherText = "CipherText"
            case incomingEncryptionAttributes = "IncomingEncryptionAttributes"
            case outgoingEncryptionAttributes = "OutgoingEncryptionAttributes"
            case outgoingKeyIdentifier = "OutgoingKeyIdentifier"
        }
    }

    public struct ReEncryptDataOutput: AWSDecodableShape {
        /// The encrypted ciphertext.
        public let cipherText: String
        /// The keyARN (Amazon Resource Name) of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.
        public let keyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let keyCheckValue: String

        public init(cipherText: String, keyArn: String, keyCheckValue: String) {
            self.cipherText = cipherText
            self.keyArn = keyArn
            self.keyCheckValue = keyCheckValue
        }

        private enum CodingKeys: String, CodingKey {
            case cipherText = "CipherText"
            case keyArn = "KeyArn"
            case keyCheckValue = "KeyCheckValue"
        }
    }

    public struct SessionKeyAmex: AWSEncodableShape {
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        public let panSequenceNumber: String
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        public let primaryAccountNumber: String

        public init(panSequenceNumber: String, primaryAccountNumber: String) {
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, max: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, min: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case panSequenceNumber = "PanSequenceNumber"
            case primaryAccountNumber = "PrimaryAccountNumber"
        }
    }

    public struct SessionKeyEmv2000: AWSEncodableShape {
        /// The transaction counter that is provided by the terminal during transaction processing.
        public let applicationTransactionCounter: String
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        public let panSequenceNumber: String
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        public let primaryAccountNumber: String

        public init(applicationTransactionCounter: String, panSequenceNumber: String, primaryAccountNumber: String) {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, max: 4)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, min: 2)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, max: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, min: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationTransactionCounter = "ApplicationTransactionCounter"
            case panSequenceNumber = "PanSequenceNumber"
            case primaryAccountNumber = "PrimaryAccountNumber"
        }
    }

    public struct SessionKeyEmvCommon: AWSEncodableShape {
        /// The transaction counter that is provided by the terminal during transaction processing.
        public let applicationTransactionCounter: String
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        public let panSequenceNumber: String
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        public let primaryAccountNumber: String

        public init(applicationTransactionCounter: String, panSequenceNumber: String, primaryAccountNumber: String) {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, max: 4)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, min: 2)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, max: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, min: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationTransactionCounter = "ApplicationTransactionCounter"
            case panSequenceNumber = "PanSequenceNumber"
            case primaryAccountNumber = "PrimaryAccountNumber"
        }
    }

    public struct SessionKeyMastercard: AWSEncodableShape {
        /// The transaction counter that is provided by the terminal during transaction processing.
        public let applicationTransactionCounter: String
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        public let panSequenceNumber: String
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        public let primaryAccountNumber: String
        /// A random number generated by the issuer.
        public let unpredictableNumber: String

        public init(applicationTransactionCounter: String, panSequenceNumber: String, primaryAccountNumber: String, unpredictableNumber: String) {
            self.applicationTransactionCounter = applicationTransactionCounter
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
            self.unpredictableNumber = unpredictableNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, max: 4)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, min: 2)
            try self.validate(self.applicationTransactionCounter, name: "applicationTransactionCounter", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, max: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, min: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, max: 8)
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, min: 2)
            try self.validate(self.unpredictableNumber, name: "unpredictableNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationTransactionCounter = "ApplicationTransactionCounter"
            case panSequenceNumber = "PanSequenceNumber"
            case primaryAccountNumber = "PrimaryAccountNumber"
            case unpredictableNumber = "UnpredictableNumber"
        }
    }

    public struct SessionKeyVisa: AWSEncodableShape {
        /// A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).
        public let panSequenceNumber: String
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        public let primaryAccountNumber: String

        public init(panSequenceNumber: String, primaryAccountNumber: String) {
            self.panSequenceNumber = panSequenceNumber
            self.primaryAccountNumber = primaryAccountNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, max: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, min: 2)
            try self.validate(self.panSequenceNumber, name: "panSequenceNumber", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case panSequenceNumber = "PanSequenceNumber"
            case primaryAccountNumber = "PrimaryAccountNumber"
        }
    }

    public struct SymmetricEncryptionAttributes: AWSEncodableShape {
        /// An input used to provide the intial state. If no value is provided, Amazon Web Services Payment Cryptography defaults it to zero.
        public let initializationVector: String?
        /// The block cipher method to use for encryption.
        public let mode: EncryptionMode
        /// The padding to be included with the data.
        public let paddingType: PaddingType?

        public init(initializationVector: String? = nil, mode: EncryptionMode, paddingType: PaddingType? = nil) {
            self.initializationVector = initializationVector
            self.mode = mode
            self.paddingType = paddingType
        }

        public func validate(name: String) throws {
            try self.validate(self.initializationVector, name: "initializationVector", parent: name, max: 32)
            try self.validate(self.initializationVector, name: "initializationVector", parent: name, min: 16)
            try self.validate(self.initializationVector, name: "initializationVector", parent: name, pattern: "^(?:[0-9a-fA-F]{16}|[0-9a-fA-F]{32})$")
        }

        private enum CodingKeys: String, CodingKey {
            case initializationVector = "InitializationVector"
            case mode = "Mode"
            case paddingType = "PaddingType"
        }
    }

    public struct TranslatePinDataInput: AWSEncodableShape {
        /// The encrypted PIN block data that Amazon Web Services Payment Cryptography translates.
        public let encryptedPinBlock: String
        /// The attributes and values to use for incoming DUKPT encryption key for PIN block translation.
        public let incomingDukptAttributes: DukptDerivationAttributes?
        /// The keyARN of the encryption key under which incoming PIN block data is encrypted. This key type can be PEK or BDK.
        public let incomingKeyIdentifier: String
        /// The format of the incoming PIN block data for translation within Amazon Web Services Payment Cryptography.
        public let incomingTranslationAttributes: TranslationIsoFormats
        /// The attributes and values to use for outgoing DUKPT encryption key after PIN block translation.
        public let outgoingDukptAttributes: DukptDerivationAttributes?
        /// The keyARN of the encryption key for encrypting outgoing PIN block data. This key type can be PEK or BDK.
        public let outgoingKeyIdentifier: String
        /// The format of the outgoing PIN block data after translation by Amazon Web Services Payment Cryptography.
        public let outgoingTranslationAttributes: TranslationIsoFormats

        public init(encryptedPinBlock: String, incomingDukptAttributes: DukptDerivationAttributes? = nil, incomingKeyIdentifier: String, incomingTranslationAttributes: TranslationIsoFormats, outgoingDukptAttributes: DukptDerivationAttributes? = nil, outgoingKeyIdentifier: String, outgoingTranslationAttributes: TranslationIsoFormats) {
            self.encryptedPinBlock = encryptedPinBlock
            self.incomingDukptAttributes = incomingDukptAttributes
            self.incomingKeyIdentifier = incomingKeyIdentifier
            self.incomingTranslationAttributes = incomingTranslationAttributes
            self.outgoingDukptAttributes = outgoingDukptAttributes
            self.outgoingKeyIdentifier = outgoingKeyIdentifier
            self.outgoingTranslationAttributes = outgoingTranslationAttributes
        }

        public func validate(name: String) throws {
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, max: 32)
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, min: 16)
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, pattern: "^(?:[0-9a-fA-F][0-9a-fA-F])+$")
            try self.incomingDukptAttributes?.validate(name: "\(name).incomingDukptAttributes")
            try self.validate(self.incomingKeyIdentifier, name: "incomingKeyIdentifier", parent: name, max: 322)
            try self.validate(self.incomingKeyIdentifier, name: "incomingKeyIdentifier", parent: name, min: 7)
            try self.validate(self.incomingKeyIdentifier, name: "incomingKeyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.incomingTranslationAttributes.validate(name: "\(name).incomingTranslationAttributes")
            try self.outgoingDukptAttributes?.validate(name: "\(name).outgoingDukptAttributes")
            try self.validate(self.outgoingKeyIdentifier, name: "outgoingKeyIdentifier", parent: name, max: 322)
            try self.validate(self.outgoingKeyIdentifier, name: "outgoingKeyIdentifier", parent: name, min: 7)
            try self.validate(self.outgoingKeyIdentifier, name: "outgoingKeyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.outgoingTranslationAttributes.validate(name: "\(name).outgoingTranslationAttributes")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptedPinBlock = "EncryptedPinBlock"
            case incomingDukptAttributes = "IncomingDukptAttributes"
            case incomingKeyIdentifier = "IncomingKeyIdentifier"
            case incomingTranslationAttributes = "IncomingTranslationAttributes"
            case outgoingDukptAttributes = "OutgoingDukptAttributes"
            case outgoingKeyIdentifier = "OutgoingKeyIdentifier"
            case outgoingTranslationAttributes = "OutgoingTranslationAttributes"
        }
    }

    public struct TranslatePinDataOutput: AWSDecodableShape {
        /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses to encrypt outgoing PIN block data after translation.
        public let keyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let keyCheckValue: String
        /// The outgoing encrypted PIN block data after translation.
        public let pinBlock: String

        public init(keyArn: String, keyCheckValue: String, pinBlock: String) {
            self.keyArn = keyArn
            self.keyCheckValue = keyCheckValue
            self.pinBlock = pinBlock
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "KeyArn"
            case keyCheckValue = "KeyCheckValue"
            case pinBlock = "PinBlock"
        }
    }

    public struct TranslationPinDataIsoFormat034: AWSEncodableShape {
        /// The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.
        public let primaryAccountNumber: String

        public init(primaryAccountNumber: String) {
            self.primaryAccountNumber = primaryAccountNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case primaryAccountNumber = "PrimaryAccountNumber"
        }
    }

    public struct TranslationPinDataIsoFormat1: AWSEncodableShape {
        public init() {}
    }

    public struct VerifyAuthRequestCryptogramInput: AWSEncodableShape {
        /// The auth request cryptogram imported into Amazon Web Services Payment Cryptography for ARQC verification using a major encryption key and transaction data.
        public let authRequestCryptogram: String
        /// The attributes and values for auth request cryptogram verification. These parameters are required in case using ARPC Method 1 or Method 2 for ARQC verification.
        public let authResponseAttributes: CryptogramAuthResponse?
        /// The keyARN of the major encryption key that Amazon Web Services Payment Cryptography uses for ARQC verification.
        public let keyIdentifier: String
        /// The method to use when deriving the major encryption key for ARQC verification within Amazon Web Services Payment Cryptography. The same key derivation mode was used for ARQC generation outside of Amazon Web Services Payment Cryptography.
        public let majorKeyDerivationMode: MajorKeyDerivationMode
        /// The attributes and values to use for deriving a session key for ARQC verification within Amazon Web Services Payment Cryptography. The same attributes were used for ARQC generation outside of Amazon Web Services Payment Cryptography.
        public let sessionKeyDerivationAttributes: SessionKeyDerivation
        /// The transaction data that Amazon Web Services Payment Cryptography uses for ARQC verification. The same transaction is used for ARQC generation outside of Amazon Web Services Payment Cryptography.
        public let transactionData: String

        public init(authRequestCryptogram: String, authResponseAttributes: CryptogramAuthResponse? = nil, keyIdentifier: String, majorKeyDerivationMode: MajorKeyDerivationMode, sessionKeyDerivationAttributes: SessionKeyDerivation, transactionData: String) {
            self.authRequestCryptogram = authRequestCryptogram
            self.authResponseAttributes = authResponseAttributes
            self.keyIdentifier = keyIdentifier
            self.majorKeyDerivationMode = majorKeyDerivationMode
            self.sessionKeyDerivationAttributes = sessionKeyDerivationAttributes
            self.transactionData = transactionData
        }

        public func validate(name: String) throws {
            try self.validate(self.authRequestCryptogram, name: "authRequestCryptogram", parent: name, max: 16)
            try self.validate(self.authRequestCryptogram, name: "authRequestCryptogram", parent: name, min: 16)
            try self.validate(self.authRequestCryptogram, name: "authRequestCryptogram", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.authResponseAttributes?.validate(name: "\(name).authResponseAttributes")
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, max: 322)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, min: 7)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.sessionKeyDerivationAttributes.validate(name: "\(name).sessionKeyDerivationAttributes")
            try self.validate(self.transactionData, name: "transactionData", parent: name, max: 1024)
            try self.validate(self.transactionData, name: "transactionData", parent: name, min: 2)
            try self.validate(self.transactionData, name: "transactionData", parent: name, pattern: "^[0-9a-fA-F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authRequestCryptogram = "AuthRequestCryptogram"
            case authResponseAttributes = "AuthResponseAttributes"
            case keyIdentifier = "KeyIdentifier"
            case majorKeyDerivationMode = "MajorKeyDerivationMode"
            case sessionKeyDerivationAttributes = "SessionKeyDerivationAttributes"
            case transactionData = "TransactionData"
        }
    }

    public struct VerifyAuthRequestCryptogramOutput: AWSDecodableShape {
        /// The result for ARQC verification or ARPC generation within Amazon Web Services Payment Cryptography.
        public let authResponseValue: String?
        /// The keyARN of the major encryption key that Amazon Web Services Payment Cryptography uses for ARQC verification.
        public let keyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let keyCheckValue: String

        public init(authResponseValue: String? = nil, keyArn: String, keyCheckValue: String) {
            self.authResponseValue = authResponseValue
            self.keyArn = keyArn
            self.keyCheckValue = keyCheckValue
        }

        private enum CodingKeys: String, CodingKey {
            case authResponseValue = "AuthResponseValue"
            case keyArn = "KeyArn"
            case keyCheckValue = "KeyCheckValue"
        }
    }

    public struct VerifyCardValidationDataInput: AWSEncodableShape {
        /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to verify card data.
        public let keyIdentifier: String
        /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
        public let primaryAccountNumber: String
        /// The CVV or CSC value for use for card data verification within Amazon Web Services Payment Cryptography.
        public let validationData: String
        /// The algorithm to use for verification of card data within Amazon Web Services Payment Cryptography.
        public let verificationAttributes: CardVerificationAttributes

        public init(keyIdentifier: String, primaryAccountNumber: String, validationData: String, verificationAttributes: CardVerificationAttributes) {
            self.keyIdentifier = keyIdentifier
            self.primaryAccountNumber = primaryAccountNumber
            self.validationData = validationData
            self.verificationAttributes = verificationAttributes
        }

        public func validate(name: String) throws {
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, max: 322)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, min: 7)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.validationData, name: "validationData", parent: name, max: 5)
            try self.validate(self.validationData, name: "validationData", parent: name, min: 3)
            try self.validate(self.validationData, name: "validationData", parent: name, pattern: "^[0-9]+$")
            try self.verificationAttributes.validate(name: "\(name).verificationAttributes")
        }

        private enum CodingKeys: String, CodingKey {
            case keyIdentifier = "KeyIdentifier"
            case primaryAccountNumber = "PrimaryAccountNumber"
            case validationData = "ValidationData"
            case verificationAttributes = "VerificationAttributes"
        }
    }

    public struct VerifyCardValidationDataOutput: AWSDecodableShape {
        /// The keyARN of the CVK encryption key that Amazon Web Services Payment Cryptography uses to verify CVV or CSC.
        public let keyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let keyCheckValue: String

        public init(keyArn: String, keyCheckValue: String) {
            self.keyArn = keyArn
            self.keyCheckValue = keyCheckValue
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "KeyArn"
            case keyCheckValue = "KeyCheckValue"
        }
    }

    public struct VerifyMacInput: AWSEncodableShape {
        /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses to verify MAC data.
        public let keyIdentifier: String
        /// The MAC being verified.
        public let mac: String
        /// The length of the MAC.
        public let macLength: Int?
        /// The data on for which MAC is under verification. This value must be hexBinary.
        public let messageData: String
        /// The attributes and data values to use for MAC verification within Amazon Web Services Payment Cryptography.
        public let verificationAttributes: MacAttributes

        public init(keyIdentifier: String, mac: String, macLength: Int? = nil, messageData: String, verificationAttributes: MacAttributes) {
            self.keyIdentifier = keyIdentifier
            self.mac = mac
            self.macLength = macLength
            self.messageData = messageData
            self.verificationAttributes = verificationAttributes
        }

        public func validate(name: String) throws {
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, max: 322)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, min: 7)
            try self.validate(self.keyIdentifier, name: "keyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.validate(self.mac, name: "mac", parent: name, max: 128)
            try self.validate(self.mac, name: "mac", parent: name, min: 4)
            try self.validate(self.mac, name: "mac", parent: name, pattern: "^(?:[0-9a-fA-F][0-9a-fA-F])+$")
            try self.validate(self.macLength, name: "macLength", parent: name, max: 16)
            try self.validate(self.macLength, name: "macLength", parent: name, min: 4)
            try self.validate(self.messageData, name: "messageData", parent: name, max: 4096)
            try self.validate(self.messageData, name: "messageData", parent: name, min: 2)
            try self.validate(self.messageData, name: "messageData", parent: name, pattern: "^(?:[0-9a-fA-F][0-9a-fA-F])+$")
            try self.verificationAttributes.validate(name: "\(name).verificationAttributes")
        }

        private enum CodingKeys: String, CodingKey {
            case keyIdentifier = "KeyIdentifier"
            case mac = "Mac"
            case macLength = "MacLength"
            case messageData = "MessageData"
            case verificationAttributes = "VerificationAttributes"
        }
    }

    public struct VerifyMacOutput: AWSDecodableShape {
        /// The keyARN of the encryption key that Amazon Web Services Payment Cryptography uses for MAC verification.
        public let keyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let keyCheckValue: String

        public init(keyArn: String, keyCheckValue: String) {
            self.keyArn = keyArn
            self.keyCheckValue = keyCheckValue
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "KeyArn"
            case keyCheckValue = "KeyCheckValue"
        }
    }

    public struct VerifyPinDataInput: AWSEncodableShape {
        /// The attributes and values for the DUKPT encrypted PIN block data.
        public let dukptAttributes: DukptAttributes?
        /// The encrypted PIN block data that Amazon Web Services Payment Cryptography verifies.
        public let encryptedPinBlock: String
        /// The keyARN of the encryption key under which the PIN block data is encrypted. This key type can be PEK or BDK.
        public let encryptionKeyIdentifier: String
        /// The PIN encoding format for pin data generation as specified in ISO 9564. Amazon Web Services Payment Cryptography supports ISO_Format_0 and ISO_Format_3. The ISO_Format_0 PIN block format is equivalent to the ANSI X9.8, VISA-1, and ECI-1 PIN block formats. It is similar to a VISA-4 PIN block format. It supports a PIN from 4 to 12 digits in length. The ISO_Format_3 PIN block format is the same as ISO_Format_0 except that the fill digits are random values from 10 to 15.
        public let pinBlockFormat: PinBlockFormatForPinData
        /// The length of PIN being verified.
        public let pinDataLength: Int?
        /// The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.
        public let primaryAccountNumber: String
        /// The attributes and values for PIN data verification.
        public let verificationAttributes: PinVerificationAttributes
        /// The keyARN of the PIN verification key.
        public let verificationKeyIdentifier: String

        public init(dukptAttributes: DukptAttributes? = nil, encryptedPinBlock: String, encryptionKeyIdentifier: String, pinBlockFormat: PinBlockFormatForPinData, pinDataLength: Int? = nil, primaryAccountNumber: String, verificationAttributes: PinVerificationAttributes, verificationKeyIdentifier: String) {
            self.dukptAttributes = dukptAttributes
            self.encryptedPinBlock = encryptedPinBlock
            self.encryptionKeyIdentifier = encryptionKeyIdentifier
            self.pinBlockFormat = pinBlockFormat
            self.pinDataLength = pinDataLength
            self.primaryAccountNumber = primaryAccountNumber
            self.verificationAttributes = verificationAttributes
            self.verificationKeyIdentifier = verificationKeyIdentifier
        }

        public func validate(name: String) throws {
            try self.dukptAttributes?.validate(name: "\(name).dukptAttributes")
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, max: 32)
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, min: 16)
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.encryptionKeyIdentifier, name: "encryptionKeyIdentifier", parent: name, max: 322)
            try self.validate(self.encryptionKeyIdentifier, name: "encryptionKeyIdentifier", parent: name, min: 7)
            try self.validate(self.encryptionKeyIdentifier, name: "encryptionKeyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
            try self.validate(self.pinDataLength, name: "pinDataLength", parent: name, max: 12)
            try self.validate(self.pinDataLength, name: "pinDataLength", parent: name, min: 4)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, max: 19)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, min: 12)
            try self.validate(self.primaryAccountNumber, name: "primaryAccountNumber", parent: name, pattern: "^[0-9]+$")
            try self.verificationAttributes.validate(name: "\(name).verificationAttributes")
            try self.validate(self.verificationKeyIdentifier, name: "verificationKeyIdentifier", parent: name, max: 322)
            try self.validate(self.verificationKeyIdentifier, name: "verificationKeyIdentifier", parent: name, min: 7)
            try self.validate(self.verificationKeyIdentifier, name: "verificationKeyIdentifier", parent: name, pattern: "^arn:aws:payment-cryptography:[a-z]{2}-[a-z]{1,16}-[0-9]+:[0-9]{12}:(key/[0-9a-zA-Z]{16,64}|alias/[a-zA-Z0-9/_-]+)$|^alias/[a-zA-Z0-9/_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dukptAttributes = "DukptAttributes"
            case encryptedPinBlock = "EncryptedPinBlock"
            case encryptionKeyIdentifier = "EncryptionKeyIdentifier"
            case pinBlockFormat = "PinBlockFormat"
            case pinDataLength = "PinDataLength"
            case primaryAccountNumber = "PrimaryAccountNumber"
            case verificationAttributes = "VerificationAttributes"
            case verificationKeyIdentifier = "VerificationKeyIdentifier"
        }
    }

    public struct VerifyPinDataOutput: AWSDecodableShape {
        /// The keyARN of the PEK that Amazon Web Services Payment Cryptography uses for encrypted pin block generation.
        public let encryptionKeyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let encryptionKeyCheckValue: String
        /// The keyARN of the PIN encryption key that Amazon Web Services Payment Cryptography uses for PIN or PIN Offset verification.
        public let verificationKeyArn: String
        /// The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed. Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.
        public let verificationKeyCheckValue: String

        public init(encryptionKeyArn: String, encryptionKeyCheckValue: String, verificationKeyArn: String, verificationKeyCheckValue: String) {
            self.encryptionKeyArn = encryptionKeyArn
            self.encryptionKeyCheckValue = encryptionKeyCheckValue
            self.verificationKeyArn = verificationKeyArn
            self.verificationKeyCheckValue = verificationKeyCheckValue
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionKeyArn = "EncryptionKeyArn"
            case encryptionKeyCheckValue = "EncryptionKeyCheckValue"
            case verificationKeyArn = "VerificationKeyArn"
            case verificationKeyCheckValue = "VerificationKeyCheckValue"
        }
    }

    public struct VisaPin: AWSEncodableShape {
        /// The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).
        public let pinVerificationKeyIndex: Int

        public init(pinVerificationKeyIndex: Int) {
            self.pinVerificationKeyIndex = pinVerificationKeyIndex
        }

        public func validate(name: String) throws {
            try self.validate(self.pinVerificationKeyIndex, name: "pinVerificationKeyIndex", parent: name, max: 9)
            try self.validate(self.pinVerificationKeyIndex, name: "pinVerificationKeyIndex", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case pinVerificationKeyIndex = "PinVerificationKeyIndex"
        }
    }

    public struct VisaPinVerification: AWSEncodableShape {
        /// The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).
        public let pinVerificationKeyIndex: Int
        /// Parameters that are required to generate or verify Visa PVV (PIN Verification Value).
        public let verificationValue: String

        public init(pinVerificationKeyIndex: Int, verificationValue: String) {
            self.pinVerificationKeyIndex = pinVerificationKeyIndex
            self.verificationValue = verificationValue
        }

        public func validate(name: String) throws {
            try self.validate(self.pinVerificationKeyIndex, name: "pinVerificationKeyIndex", parent: name, max: 9)
            try self.validate(self.pinVerificationKeyIndex, name: "pinVerificationKeyIndex", parent: name, min: 0)
            try self.validate(self.verificationValue, name: "verificationValue", parent: name, max: 12)
            try self.validate(self.verificationValue, name: "verificationValue", parent: name, min: 4)
            try self.validate(self.verificationValue, name: "verificationValue", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case pinVerificationKeyIndex = "PinVerificationKeyIndex"
            case verificationValue = "VerificationValue"
        }
    }

    public struct VisaPinVerificationValue: AWSEncodableShape {
        /// The encrypted PIN block data to verify.
        public let encryptedPinBlock: String
        /// The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).
        public let pinVerificationKeyIndex: Int

        public init(encryptedPinBlock: String, pinVerificationKeyIndex: Int) {
            self.encryptedPinBlock = encryptedPinBlock
            self.pinVerificationKeyIndex = pinVerificationKeyIndex
        }

        public func validate(name: String) throws {
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, max: 32)
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, min: 16)
            try self.validate(self.encryptedPinBlock, name: "encryptedPinBlock", parent: name, pattern: "^[0-9a-fA-F]+$")
            try self.validate(self.pinVerificationKeyIndex, name: "pinVerificationKeyIndex", parent: name, max: 9)
            try self.validate(self.pinVerificationKeyIndex, name: "pinVerificationKeyIndex", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptedPinBlock = "EncryptedPinBlock"
            case pinVerificationKeyIndex = "PinVerificationKeyIndex"
        }
    }
}

// MARK: - Errors

/// Error enum for PaymentCryptographyData
public struct PaymentCryptographyDataErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
        case verificationFailedException = "VerificationFailedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize PaymentCryptographyData
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request processing has failed because of an unknown error, exception, or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request was denied due to an invalid resource error.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request was denied due to an invalid request error.
    public static var validationException: Self { .init(.validationException) }
    /// This request failed verification.
    public static var verificationFailedException: Self { .init(.verificationFailedException) }
}

extension PaymentCryptographyDataErrorType: Equatable {
    public static func == (lhs: PaymentCryptographyDataErrorType, rhs: PaymentCryptographyDataErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PaymentCryptographyDataErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
