//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ConnectCases {
    // MARK: Enums

    public enum AuditEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case caseCreated = "Case.Created"
        case caseUpdated = "Case.Updated"
        case relatedItemCreated = "RelatedItem.Created"
        public var description: String { return self.rawValue }
    }

    public enum CommentBodyTextType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case textPlain = "Text/Plain"
        public var description: String { return self.rawValue }
    }

    public enum DomainStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case creationFailed = "CreationFailed"
        case creationInProgress = "CreationInProgress"
        public var description: String { return self.rawValue }
    }

    public enum FieldNamespace: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "Custom"
        case system = "System"
        public var description: String { return self.rawValue }
    }

    public enum FieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "Boolean"
        case dateTime = "DateTime"
        case number = "Number"
        case singleSelect = "SingleSelect"
        case text = "Text"
        case url = "Url"
        case user = "User"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "Asc"
        case desc = "Desc"
        public var description: String { return self.rawValue }
    }

    public enum RelatedItemType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case comment = "Comment"
        case contact = "Contact"
        public var description: String { return self.rawValue }
    }

    public enum TemplateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum AuditEventFieldValueUnion: AWSDecodableShape, Sendable {
        /// Can be either null, or have a Boolean value type. Only one value can be provided.
        case booleanValue(Bool)
        /// Can be either null, or have a Double value type. Only one value can be provided.
        case doubleValue(Double)
        case emptyValue(EmptyFieldValue)
        /// Can be either null, or have a String value type. Only one value can be provided.
        case stringValue(String)
        /// Can be either null, or have a String value type formatted as an ARN. Only one value can be provided.
        case userArnValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanValue:
                let value = try container.decode(Bool.self, forKey: .booleanValue)
                self = .booleanValue(value)
            case .doubleValue:
                let value = try container.decode(Double.self, forKey: .doubleValue)
                self = .doubleValue(value)
            case .emptyValue:
                let value = try container.decode(EmptyFieldValue.self, forKey: .emptyValue)
                self = .emptyValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            case .userArnValue:
                let value = try container.decode(String.self, forKey: .userArnValue)
                self = .userArnValue(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case doubleValue = "doubleValue"
            case emptyValue = "emptyValue"
            case stringValue = "stringValue"
            case userArnValue = "userArnValue"
        }
    }

    public indirect enum CaseFilter: AWSEncodableShape, Sendable {
        /// Provides "and all" filtering.
        case andAll([CaseFilter])
        /// A list of fields to filter on.
        case field(FieldFilter)
        case not(CaseFilter)
        /// Provides "or all" filtering.
        case orAll([CaseFilter])

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andAll(let value):
                try container.encode(value, forKey: .andAll)
            case .field(let value):
                try container.encode(value, forKey: .field)
            case .not(let value):
                try container.encode(value, forKey: .not)
            case .orAll(let value):
                try container.encode(value, forKey: .orAll)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andAll[]")
                }
            case .field(let value):
                try value.validate(name: "\(name).field")
            case .not(let value):
                try value.validate(name: "\(name).not")
            case .orAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).orAll[]")
                }
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAll = "andAll"
            case field = "field"
            case not = "not"
            case orAll = "orAll"
        }
    }

    public enum FieldFilter: AWSEncodableShape, Sendable {
        /// Object containing field identifier and value information.
        case contains(FieldValue)
        /// Object containing field identifier and value information.
        case equalTo(FieldValue)
        /// Object containing field identifier and value information.
        case greaterThan(FieldValue)
        /// Object containing field identifier and value information.
        case greaterThanOrEqualTo(FieldValue)
        /// Object containing field identifier and value information.
        case lessThan(FieldValue)
        /// Object containing field identifier and value information.
        case lessThanOrEqualTo(FieldValue)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .contains(let value):
                try container.encode(value, forKey: .contains)
            case .equalTo(let value):
                try container.encode(value, forKey: .equalTo)
            case .greaterThan(let value):
                try container.encode(value, forKey: .greaterThan)
            case .greaterThanOrEqualTo(let value):
                try container.encode(value, forKey: .greaterThanOrEqualTo)
            case .lessThan(let value):
                try container.encode(value, forKey: .lessThan)
            case .lessThanOrEqualTo(let value):
                try container.encode(value, forKey: .lessThanOrEqualTo)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .contains(let value):
                try value.validate(name: "\(name).contains")
            case .equalTo(let value):
                try value.validate(name: "\(name).equalTo")
            case .greaterThan(let value):
                try value.validate(name: "\(name).greaterThan")
            case .greaterThanOrEqualTo(let value):
                try value.validate(name: "\(name).greaterThanOrEqualTo")
            case .lessThan(let value):
                try value.validate(name: "\(name).lessThan")
            case .lessThanOrEqualTo(let value):
                try value.validate(name: "\(name).lessThanOrEqualTo")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contains = "contains"
            case equalTo = "equalTo"
            case greaterThan = "greaterThan"
            case greaterThanOrEqualTo = "greaterThanOrEqualTo"
            case lessThan = "lessThan"
            case lessThanOrEqualTo = "lessThanOrEqualTo"
        }
    }

    public enum FieldValueUnion: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Can be either null, or have a Boolean value type. Only one value can be provided.
        case booleanValue(Bool)
        /// Can be either null, or have a Double number value type. Only one value can be provided.
        case doubleValue(Double)
        /// An empty value.
        case emptyValue(EmptyFieldValue)
        /// String value type.
        case stringValue(String)
        /// Represents the user that performed the audit.
        case userArnValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanValue:
                let value = try container.decode(Bool.self, forKey: .booleanValue)
                self = .booleanValue(value)
            case .doubleValue:
                let value = try container.decode(Double.self, forKey: .doubleValue)
                self = .doubleValue(value)
            case .emptyValue:
                let value = try container.decode(EmptyFieldValue.self, forKey: .emptyValue)
                self = .emptyValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            case .userArnValue:
                let value = try container.decode(String.self, forKey: .userArnValue)
                self = .userArnValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .booleanValue(let value):
                try container.encode(value, forKey: .booleanValue)
            case .doubleValue(let value):
                try container.encode(value, forKey: .doubleValue)
            case .emptyValue(let value):
                try container.encode(value, forKey: .emptyValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            case .userArnValue(let value):
                try container.encode(value, forKey: .userArnValue)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case doubleValue = "doubleValue"
            case emptyValue = "emptyValue"
            case stringValue = "stringValue"
            case userArnValue = "userArnValue"
        }
    }

    public enum RelatedItemContent: AWSDecodableShape, Sendable {
        /// Represents the content of a comment to be returned to agents.
        case comment(CommentContent)
        /// Represents the content of a contact to be returned to agents.
        case contact(ContactContent)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .comment:
                let value = try container.decode(CommentContent.self, forKey: .comment)
                self = .comment(value)
            case .contact:
                let value = try container.decode(ContactContent.self, forKey: .contact)
                self = .contact(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case contact = "contact"
        }
    }

    public enum RelatedItemInputContent: AWSEncodableShape, Sendable {
        /// Represents the content of a comment to be returned to agents.
        case comment(CommentContent)
        /// Object representing a contact in Amazon Connect as an API request field.
        case contact(Contact)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .comment(let value):
                try container.encode(value, forKey: .comment)
            case .contact(let value):
                try container.encode(value, forKey: .contact)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .comment(let value):
                try value.validate(name: "\(name).comment")
            case .contact(let value):
                try value.validate(name: "\(name).contact")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case contact = "contact"
        }
    }

    public enum RelatedItemTypeFilter: AWSEncodableShape, Sendable {
        /// A filter for related items of type Comment.
        case comment(CommentFilter)
        /// A filter for related items of type Contact.
        case contact(ContactFilter)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .comment(let value):
                try container.encode(value, forKey: .comment)
            case .contact(let value):
                try container.encode(value, forKey: .contact)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .contact(let value):
                try value.validate(name: "\(name).contact")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case contact = "contact"
        }
    }

    // MARK: Shapes

    public struct AuditEvent: AWSDecodableShape {
        /// Unique identifier of a case audit history event.
        public let eventId: String
        /// A list of Case Audit History event fields.
        public let fields: [AuditEventField]
        /// Information of the user which performed the audit.
        public let performedBy: AuditEventPerformedBy?
        /// Time at which an Audit History event took place.
        @CustomCoding<ISO8601DateCoder>
        public var performedTime: Date
        /// The Type of the related item.
        public let relatedItemType: RelatedItemType?
        /// The Type of an audit history event.
        public let type: AuditEventType

        public init(eventId: String, fields: [AuditEventField], performedBy: AuditEventPerformedBy? = nil, performedTime: Date, relatedItemType: RelatedItemType? = nil, type: AuditEventType) {
            self.eventId = eventId
            self.fields = fields
            self.performedBy = performedBy
            self.performedTime = performedTime
            self.relatedItemType = relatedItemType
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case fields = "fields"
            case performedBy = "performedBy"
            case performedTime = "performedTime"
            case relatedItemType = "relatedItemType"
            case type = "type"
        }
    }

    public struct AuditEventField: AWSDecodableShape {
        /// Unique identifier of field in an Audit History entry.
        public let eventFieldId: String
        /// Union of potential field value types.
        public let newValue: AuditEventFieldValueUnion
        /// Union of potential field value types.
        public let oldValue: AuditEventFieldValueUnion?

        public init(eventFieldId: String, newValue: AuditEventFieldValueUnion, oldValue: AuditEventFieldValueUnion? = nil) {
            self.eventFieldId = eventFieldId
            self.newValue = newValue
            self.oldValue = oldValue
        }

        private enum CodingKeys: String, CodingKey {
            case eventFieldId = "eventFieldId"
            case newValue = "newValue"
            case oldValue = "oldValue"
        }
    }

    public struct AuditEventPerformedBy: AWSDecodableShape {
        /// Unique identifier of an IAM role.
        public let iamPrincipalArn: String
        public let user: UserUnion?

        public init(iamPrincipalArn: String, user: UserUnion? = nil) {
            self.iamPrincipalArn = iamPrincipalArn
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case iamPrincipalArn = "iamPrincipalArn"
            case user = "user"
        }
    }

    public struct BasicLayout: AWSEncodableShape & AWSDecodableShape {
        /// This represents sections in a tab of the page layout.
        public let moreInfo: LayoutSections?
        /// This represents sections in a panel of the page layout.
        public let topPanel: LayoutSections?

        public init(moreInfo: LayoutSections? = nil, topPanel: LayoutSections? = nil) {
            self.moreInfo = moreInfo
            self.topPanel = topPanel
        }

        public func validate(name: String) throws {
            try self.moreInfo?.validate(name: "\(name).moreInfo")
            try self.topPanel?.validate(name: "\(name).topPanel")
        }

        private enum CodingKeys: String, CodingKey {
            case moreInfo = "moreInfo"
            case topPanel = "topPanel"
        }
    }

    public struct BatchGetFieldRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// A list of unique field identifiers.
        public let fields: [FieldIdentifier]

        public init(domainId: String, fields: [FieldIdentifier]) {
            self.domainId = domainId
            self.fields = fields
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.fields, forKey: .fields)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.fields, name: "fields", parent: name, max: 50)
            try self.validate(self.fields, name: "fields", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
        }
    }

    public struct BatchGetFieldResponse: AWSDecodableShape {
        /// A list of field errors.
        public let errors: [FieldError]
        /// A list of detailed field information.
        public let fields: [GetFieldResponse]

        public init(errors: [FieldError], fields: [GetFieldResponse]) {
            self.errors = errors
            self.fields = fields
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case fields = "fields"
        }
    }

    public struct BatchPutFieldOptionsRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// A list of FieldOption objects.
        public let options: [FieldOption]

        public init(domainId: String, fieldId: String, options: [FieldOption]) {
            self.domainId = domainId
            self.fieldId = fieldId
            self.options = options
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.fieldId, key: "fieldId")
            try container.encode(self.options, forKey: .options)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.options.forEach {
                try $0.validate(name: "\(name).options[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case options = "options"
        }
    }

    public struct BatchPutFieldOptionsResponse: AWSDecodableShape {
        /// A list of field errors.
        public let errors: [FieldOptionError]?

        public init(errors: [FieldOptionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct CaseEventIncludedData: AWSEncodableShape & AWSDecodableShape {
        /// List of field identifiers.
        public let fields: [FieldIdentifier]

        public init(fields: [FieldIdentifier]) {
            self.fields = fields
        }

        public func validate(name: String) throws {
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
        }
    }

    public struct CaseSummary: AWSDecodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// A unique identifier of a template.
        public let templateId: String

        public init(caseId: String, templateId: String) {
            self.caseId = caseId
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case caseId = "caseId"
            case templateId = "templateId"
        }
    }

    public struct CommentContent: AWSEncodableShape & AWSDecodableShape {
        /// Text in the body of a Comment on a case.
        public let body: String
        /// Type of the text in the box of a Comment on a case.
        public let contentType: CommentBodyTextType

        public init(body: String, contentType: CommentBodyTextType) {
            self.body = body
            self.contentType = contentType
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 3000)
            try self.validate(self.body, name: "body", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
            case contentType = "contentType"
        }
    }

    public struct CommentFilter: AWSEncodableShape {
        public init() {}
    }

    public struct Contact: AWSEncodableShape {
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String

        public init(contactArn: String) {
            self.contactArn = contactArn
        }

        public func validate(name: String) throws {
            try self.validate(self.contactArn, name: "contactArn", parent: name, max: 500)
            try self.validate(self.contactArn, name: "contactArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "contactArn"
        }
    }

    public struct ContactContent: AWSDecodableShape {
        /// A list of channels to filter on for related items of type Contact.
        public let channel: String
        /// The difference between the InitiationTimestamp and the DisconnectTimestamp of the contact.
        @CustomCoding<ISO8601DateCoder>
        public var connectedToSystemTime: Date
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String

        public init(channel: String, connectedToSystemTime: Date, contactArn: String) {
            self.channel = channel
            self.connectedToSystemTime = connectedToSystemTime
            self.contactArn = contactArn
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "channel"
            case connectedToSystemTime = "connectedToSystemTime"
            case contactArn = "contactArn"
        }
    }

    public struct ContactFilter: AWSEncodableShape {
        /// A list of channels to filter on for related items of type Contact.
        public let channel: [String]?
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String?

        public init(channel: [String]? = nil, contactArn: String? = nil) {
            self.channel = channel
            self.contactArn = contactArn
        }

        public func validate(name: String) throws {
            try self.channel?.forEach {
                try validate($0, name: "channel[]", parent: name, max: 100)
                try validate($0, name: "channel[]", parent: name, min: 1)
            }
            try self.validate(self.contactArn, name: "contactArn", parent: name, max: 500)
            try self.validate(self.contactArn, name: "contactArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "channel"
            case contactArn = "contactArn"
        }
    }

    public struct CreateCaseRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// An array of objects with field ID (matching ListFields/DescribeField) and value union data.
        public let fields: [FieldValue]
        public let performedBy: UserUnion?
        /// A unique identifier of a template.
        public let templateId: String

        public init(clientToken: String? = CreateCaseRequest.idempotencyToken(), domainId: String, fields: [FieldValue], performedBy: UserUnion? = nil, templateId: String) {
            self.clientToken = clientToken
            self.domainId = domainId
            self.fields = fields
            self.performedBy = performedBy
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.fields, forKey: .fields)
            try container.encodeIfPresent(self.performedBy, forKey: .performedBy)
            try container.encode(self.templateId, forKey: .templateId)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.performedBy?.validate(name: "\(name).performedBy")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case fields = "fields"
            case performedBy = "performedBy"
            case templateId = "templateId"
        }
    }

    public struct CreateCaseResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the case.
        public let caseArn: String
        /// A unique identifier of the case.
        public let caseId: String

        public init(caseArn: String, caseId: String) {
            self.caseArn = caseArn
            self.caseId = caseId
        }

        private enum CodingKeys: String, CodingKey {
            case caseArn = "caseArn"
            case caseId = "caseId"
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        /// The name for your Cases domain. It must be unique for your Amazon Web Services account.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct CreateDomainResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the Cases domain.
        public let domainArn: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The status of the domain.
        public let domainStatus: DomainStatus

        public init(domainArn: String, domainId: String, domainStatus: DomainStatus) {
            self.domainArn = domainArn
            self.domainId = domainId
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "domainArn"
            case domainId = "domainId"
            case domainStatus = "domainStatus"
        }
    }

    public struct CreateFieldRequest: AWSEncodableShape {
        /// The description of the field.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The name of the field.
        public let name: String
        /// Defines the data type, some system constraints, and default display of the field.
        public let type: FieldType

        public init(description: String? = nil, domainId: String, name: String, type: FieldType) {
            self.description = description
            self.domainId = domainId
            self.name = name
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case type = "type"
        }
    }

    public struct CreateFieldResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the field.
        public let fieldArn: String
        /// The unique identifier of a field.
        public let fieldId: String

        public init(fieldArn: String, fieldId: String) {
            self.fieldArn = fieldArn
            self.fieldId = fieldId
        }

        private enum CodingKeys: String, CodingKey {
            case fieldArn = "fieldArn"
            case fieldId = "fieldId"
        }
    }

    public struct CreateLayoutRequest: AWSEncodableShape {
        /// Information about which fields will be present in the layout, and information about the order of the fields.
        public let content: LayoutContent
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The name of the layout. It must be unique for the Cases domain.
        public let name: String

        public init(content: LayoutContent, domainId: String, name: String) {
            self.content = content
            self.domainId = domainId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.content, forKey: .content)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.content.validate(name: "\(name).content")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case name = "name"
        }
    }

    public struct CreateLayoutResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created layout.
        public let layoutArn: String
        /// The unique identifier of the layout.
        public let layoutId: String

        public init(layoutArn: String, layoutId: String) {
            self.layoutArn = layoutArn
            self.layoutId = layoutId
        }

        private enum CodingKeys: String, CodingKey {
            case layoutArn = "layoutArn"
            case layoutId = "layoutId"
        }
    }

    public struct CreateRelatedItemRequest: AWSEncodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// The content of a related item to be created.
        public let content: RelatedItemInputContent
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Represents the creator of the related item.
        public let performedBy: UserUnion?
        /// The type of a related item.
        public let type: RelatedItemType

        public init(caseId: String, content: RelatedItemInputContent, domainId: String, performedBy: UserUnion? = nil, type: RelatedItemType) {
            self.caseId = caseId
            self.content = content
            self.domainId = domainId
            self.performedBy = performedBy
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseId, key: "caseId")
            try container.encode(self.content, forKey: .content)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.performedBy, forKey: .performedBy)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.content.validate(name: "\(name).content")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.performedBy?.validate(name: "\(name).performedBy")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case performedBy = "performedBy"
            case type = "type"
        }
    }

    public struct CreateRelatedItemResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the related item.
        public let relatedItemArn: String
        /// The unique identifier of the related item.
        public let relatedItemId: String

        public init(relatedItemArn: String, relatedItemId: String) {
            self.relatedItemArn = relatedItemArn
            self.relatedItemId = relatedItemId
        }

        private enum CodingKeys: String, CodingKey {
            case relatedItemArn = "relatedItemArn"
            case relatedItemId = "relatedItemId"
        }
    }

    public struct CreateTemplateRequest: AWSEncodableShape {
        /// A brief description of the template.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Configuration of layouts associated to the template.
        public let layoutConfiguration: LayoutConfiguration?
        /// A name for the template. It must be unique per domain.
        public let name: String
        /// A list of fields that must contain a value for a case to be successfully created with this template.
        public let requiredFields: [RequiredField]?
        /// The status of the template.
        public let status: TemplateStatus?

        public init(description: String? = nil, domainId: String, layoutConfiguration: LayoutConfiguration? = nil, name: String, requiredFields: [RequiredField]? = nil, status: TemplateStatus? = nil) {
            self.description = description
            self.domainId = domainId
            self.layoutConfiguration = layoutConfiguration
            self.name = name
            self.requiredFields = requiredFields
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.layoutConfiguration, forKey: .layoutConfiguration)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.requiredFields, forKey: .requiredFields)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.layoutConfiguration?.validate(name: "\(name).layoutConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.requiredFields?.forEach {
                try $0.validate(name: "\(name).requiredFields[]")
            }
            try self.validate(self.requiredFields, name: "requiredFields", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case layoutConfiguration = "layoutConfiguration"
            case name = "name"
            case requiredFields = "requiredFields"
            case status = "status"
        }
    }

    public struct CreateTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created template.
        public let templateArn: String
        /// A unique identifier of a template.
        public let templateId: String

        public init(templateArn: String, templateId: String) {
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case templateArn = "templateArn"
            case templateId = "templateId"
        }
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String

        public init(domainId: String) {
            self.domainId = domainId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DomainSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the domain.
        public let domainArn: String
        /// The unique identifier of the domain.
        public let domainId: String
        /// The name of the domain.
        public let name: String

        public init(domainArn: String, domainId: String, name: String) {
            self.domainArn = domainArn
            self.domainId = domainId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "domainArn"
            case domainId = "domainId"
            case name = "name"
        }
    }

    public struct EmptyFieldValue: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct EventBridgeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the to broadcast case event data to the customer.
        public let enabled: Bool
        /// Details of what case and related item data is published through the case event stream.
        public let includedData: EventIncludedData?

        public init(enabled: Bool, includedData: EventIncludedData? = nil) {
            self.enabled = enabled
            self.includedData = includedData
        }

        public func validate(name: String) throws {
            try self.includedData?.validate(name: "\(name).includedData")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case includedData = "includedData"
        }
    }

    public struct EventIncludedData: AWSEncodableShape & AWSDecodableShape {
        /// Details of what case data is published through the case event stream.
        public let caseData: CaseEventIncludedData?
        /// Details of what related item data is published through the case event stream.
        public let relatedItemData: RelatedItemEventIncludedData?

        public init(caseData: CaseEventIncludedData? = nil, relatedItemData: RelatedItemEventIncludedData? = nil) {
            self.caseData = caseData
            self.relatedItemData = relatedItemData
        }

        public func validate(name: String) throws {
            try self.caseData?.validate(name: "\(name).caseData")
        }

        private enum CodingKeys: String, CodingKey {
            case caseData = "caseData"
            case relatedItemData = "relatedItemData"
        }
    }

    public struct FieldError: AWSDecodableShape {
        /// The error code from getting a field.
        public let errorCode: String
        /// The field identifier that caused the error.
        public let id: String
        /// The error message from getting a field.
        public let message: String?

        public init(errorCode: String, id: String, message: String? = nil) {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case id = "id"
            case message = "message"
        }
    }

    public struct FieldGroup: AWSEncodableShape & AWSDecodableShape {
        /// Represents an ordered list containing field related information.
        public let fields: [FieldItem]
        /// Name of the field group.
        public let name: String?

        public init(fields: [FieldItem], name: String? = nil) {
            self.fields = fields
            self.name = name
        }

        public func validate(name: String) throws {
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case name = "name"
        }
    }

    public struct FieldIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct FieldItem: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct FieldOption: AWSEncodableShape & AWSDecodableShape {
        /// Describes whether the FieldOption is active (displayed) or inactive.
        public let active: Bool
        ///  FieldOptionName has max length 100 and disallows trailing spaces.
        public let name: String
        ///  FieldOptionValue has max length 100 and must be alphanumeric with hyphens and underscores.
        public let value: String

        public init(active: Bool, name: String, value: String) {
            self.active = active
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.validate(self.value, name: "value", parent: name, max: 100)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case name = "name"
            case value = "value"
        }
    }

    public struct FieldOptionError: AWSDecodableShape {
        /// Error code from creating or updating field option.
        public let errorCode: String
        /// Error message from creating or updating field option.
        public let message: String
        /// The field option value that caused the error.
        public let value: String

        public init(errorCode: String, message: String, value: String) {
            self.errorCode = errorCode
            self.message = message
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
            case value = "value"
        }
    }

    public struct FieldSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the field.
        public let fieldArn: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// Name of the field.
        public let name: String
        /// The namespace of a field.
        public let namespace: FieldNamespace
        /// The type of a field.
        public let type: FieldType

        public init(fieldArn: String, fieldId: String, name: String, namespace: FieldNamespace, type: FieldType) {
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.name = name
            self.namespace = namespace
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case fieldArn = "fieldArn"
            case fieldId = "fieldId"
            case name = "name"
            case namespace = "namespace"
            case type = "type"
        }
    }

    public struct FieldValue: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let id: String
        /// Union of potential field value types.
        public let value: FieldValueUnion

        public init(id: String, value: FieldValueUnion) {
            self.id = id
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case value = "value"
        }
    }

    public struct GetCaseAuditEventsRequest: AWSEncodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of audit events to return. The current maximum supported value is 25. This is also the default when no other value is provided.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(caseId: String, domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.caseId = caseId
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseId, key: "caseId")
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetCaseAuditEventsResponse: AWSDecodableShape {
        /// A list of case audits where each represents a particular edit of the case.
        public let auditEvents: [AuditEvent]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(auditEvents: [AuditEvent], nextToken: String? = nil) {
            self.auditEvents = auditEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case auditEvents = "auditEvents"
            case nextToken = "nextToken"
        }
    }

    public struct GetCaseEventConfigurationRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String

        public init(domainId: String) {
            self.domainId = domainId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCaseEventConfigurationResponse: AWSDecodableShape {
        /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
        public let eventBridge: EventBridgeConfiguration

        public init(eventBridge: EventBridgeConfiguration) {
            self.eventBridge = eventBridge
        }

        private enum CodingKeys: String, CodingKey {
            case eventBridge = "eventBridge"
        }
    }

    public struct GetCaseRequest: AWSEncodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// A list of unique field identifiers.
        public let fields: [FieldIdentifier]
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(caseId: String, domainId: String, fields: [FieldIdentifier], nextToken: String? = nil) {
            self.caseId = caseId
            self.domainId = domainId
            self.fields = fields
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseId, key: "caseId")
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.fields, forKey: .fields)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case nextToken = "nextToken"
        }
    }

    public struct GetCaseResponse: AWSDecodableShape {
        /// A list of detailed field information.
        public let fields: [FieldValue]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier of a template.
        public let templateId: String

        public init(fields: [FieldValue], nextToken: String? = nil, tags: [String: String]? = nil, templateId: String) {
            self.fields = fields
            self.nextToken = nextToken
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case nextToken = "nextToken"
            case tags = "tags"
            case templateId = "templateId"
        }
    }

    public struct GetDomainRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String

        public init(domainId: String) {
            self.domainId = domainId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainResponse: AWSDecodableShape {
        /// The timestamp when the Cases domain was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdTime: Date
        /// The Amazon Resource Name (ARN) for the Cases domain.
        public let domainArn: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The status of the Cases domain.
        public let domainStatus: DomainStatus
        /// The name of the Cases domain.
        public let name: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(createdTime: Date, domainArn: String, domainId: String, domainStatus: DomainStatus, name: String, tags: [String: String]? = nil) {
            self.createdTime = createdTime
            self.domainArn = domainArn
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case domainArn = "domainArn"
            case domainId = "domainId"
            case domainStatus = "domainStatus"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct GetFieldResponse: AWSDecodableShape {
        /// Description of the field.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the field.
        public let fieldArn: String
        /// Unique identifier of the field.
        public let fieldId: String
        /// Name of the field.
        public let name: String
        /// Namespace of the field.
        public let namespace: FieldNamespace
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Type of the field.
        public let type: FieldType

        public init(description: String? = nil, fieldArn: String, fieldId: String, name: String, namespace: FieldNamespace, tags: [String: String]? = nil, type: FieldType) {
            self.description = description
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.name = name
            self.namespace = namespace
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case fieldArn = "fieldArn"
            case fieldId = "fieldId"
            case name = "name"
            case namespace = "namespace"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct GetLayoutRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of the layout.
        public let layoutId: String

        public init(domainId: String, layoutId: String) {
            self.domainId = domainId
            self.layoutId = layoutId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.layoutId, key: "layoutId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.layoutId, name: "layoutId", parent: name, max: 500)
            try self.validate(self.layoutId, name: "layoutId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLayoutResponse: AWSDecodableShape {
        /// Information about which fields will be present in the layout, the order of the fields, and read-only attribute of the field.
        public let content: LayoutContent
        /// The Amazon Resource Name (ARN) of the newly created layout.
        public let layoutArn: String
        /// The unique identifier of the layout.
        public let layoutId: String
        /// The name of the layout. It must be unique.
        public let name: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(content: LayoutContent, layoutArn: String, layoutId: String, name: String, tags: [String: String]? = nil) {
            self.content = content
            self.layoutArn = layoutArn
            self.layoutId = layoutId
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case layoutArn = "layoutArn"
            case layoutId = "layoutId"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct GetTemplateRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// A unique identifier of a template.
        public let templateId: String

        public init(domainId: String, templateId: String) {
            self.domainId = domainId
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.templateId, key: "templateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTemplateResponse: AWSDecodableShape {
        /// A brief description of the template.
        public let description: String?
        /// Configuration of layouts associated to the template.
        public let layoutConfiguration: LayoutConfiguration?
        /// The name of the template.
        public let name: String
        /// A list of fields that must contain a value for a case to be successfully created with this template.
        public let requiredFields: [RequiredField]?
        /// The status of the template.
        public let status: TemplateStatus
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String
        /// A unique identifier of a template.
        public let templateId: String

        public init(description: String? = nil, layoutConfiguration: LayoutConfiguration? = nil, name: String, requiredFields: [RequiredField]? = nil, status: TemplateStatus, tags: [String: String]? = nil, templateArn: String, templateId: String) {
            self.description = description
            self.layoutConfiguration = layoutConfiguration
            self.name = name
            self.requiredFields = requiredFields
            self.status = status
            self.tags = tags
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case layoutConfiguration = "layoutConfiguration"
            case name = "name"
            case requiredFields = "requiredFields"
            case status = "status"
            case tags = "tags"
            case templateArn = "templateArn"
            case templateId = "templateId"
        }
    }

    public struct LayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  Unique identifier of a layout.
        public let defaultLayout: String?

        public init(defaultLayout: String? = nil) {
            self.defaultLayout = defaultLayout
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultLayout, name: "defaultLayout", parent: name, max: 500)
            try self.validate(self.defaultLayout, name: "defaultLayout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultLayout = "defaultLayout"
        }
    }

    public struct LayoutSections: AWSEncodableShape & AWSDecodableShape {
        public let sections: [Section]?

        public init(sections: [Section]? = nil) {
            self.sections = sections
        }

        public func validate(name: String) throws {
            try self.sections?.forEach {
                try $0.validate(name: "\(name).sections[]")
            }
            try self.validate(self.sections, name: "sections", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case sections = "sections"
        }
    }

    public struct LayoutSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the layout.
        public let layoutArn: String
        /// The unique identifier for of the layout.
        public let layoutId: String
        /// The name of the layout.
        public let name: String

        public init(layoutArn: String, layoutId: String, name: String) {
            self.layoutArn = layoutArn
            self.layoutId = layoutId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case layoutArn = "layoutArn"
            case layoutId = "layoutId"
            case name = "name"
        }
    }

    public struct ListCasesForContactRequest: AWSEncodableShape {
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(contactArn: String, domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contactArn = contactArn
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.contactArn, forKey: .contactArn)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactArn, name: "contactArn", parent: name, max: 500)
            try self.validate(self.contactArn, name: "contactArn", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "contactArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListCasesForContactResponse: AWSDecodableShape {
        /// A list of Case summary information.
        public let cases: [CaseSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(cases: [CaseSummary], nextToken: String? = nil) {
            self.cases = cases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cases = "cases"
            case nextToken = "nextToken"
        }
    }

    public struct ListDomainsRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainsResponse: AWSDecodableShape {
        /// The Cases domain.
        public let domains: [DomainSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(domains: [DomainSummary], nextToken: String? = nil) {
            self.domains = domains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domains = "domains"
            case nextToken = "nextToken"
        }
    }

    public struct ListFieldOptionsRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A list of FieldOption values to filter on for ListFieldOptions.
        public let values: [String]?

        public init(domainId: String, fieldId: String, maxResults: Int? = nil, nextToken: String? = nil, values: [String]? = nil) {
            self.domainId = domainId
            self.fieldId = fieldId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.values = values
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.fieldId, key: "fieldId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.values, key: "values")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFieldOptionsResponse: AWSDecodableShape {
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// A list of FieldOption objects.
        public let options: [FieldOption]

        public init(nextToken: String? = nil, options: [FieldOption]) {
            self.nextToken = nextToken
            self.options = options
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case options = "options"
        }
    }

    public struct ListFieldsRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFieldsResponse: AWSDecodableShape {
        /// List of detailed field information.
        public let fields: [FieldSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(fields: [FieldSummary], nextToken: String? = nil) {
            self.fields = fields
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case nextToken = "nextToken"
        }
    }

    public struct ListLayoutsRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLayoutsResponse: AWSDecodableShape {
        /// The layouts for the domain.
        public let layouts: [LayoutSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(layouts: [LayoutSummary], nextToken: String? = nil) {
            self.layouts = layouts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case layouts = "layouts"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN)
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTemplatesRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A list of status values to filter on.
        public let status: [TemplateStatus]?

        public init(domainId: String, maxResults: Int? = nil, nextToken: String? = nil, status: [TemplateStatus]? = nil) {
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
            try self.validate(self.status, name: "status", parent: name, max: 2)
            try self.validate(self.status, name: "status", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplatesResponse: AWSDecodableShape {
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// List of template summary objects.
        public let templates: [TemplateSummary]

        public init(nextToken: String? = nil, templates: [TemplateSummary]) {
            self.nextToken = nextToken
            self.templates = templates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case templates = "templates"
        }
    }

    public struct PutCaseEventConfigurationRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
        public let eventBridge: EventBridgeConfiguration

        public init(domainId: String, eventBridge: EventBridgeConfiguration) {
            self.domainId = domainId
            self.eventBridge = eventBridge
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.eventBridge, forKey: .eventBridge)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.eventBridge.validate(name: "\(name).eventBridge")
        }

        private enum CodingKeys: String, CodingKey {
            case eventBridge = "eventBridge"
        }
    }

    public struct PutCaseEventConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RelatedItemEventIncludedData: AWSEncodableShape & AWSDecodableShape {
        /// Details of what related item data is published through the case event stream.
        public let includeContent: Bool

        public init(includeContent: Bool) {
            self.includeContent = includeContent
        }

        private enum CodingKeys: String, CodingKey {
            case includeContent = "includeContent"
        }
    }

    public struct RequiredField: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let fieldId: String

        public init(fieldId: String) {
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "fieldId"
        }
    }

    public struct SearchCasesRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The list of field identifiers to be returned as part of the response.
        public let fields: [FieldIdentifier]?
        /// A list of filter objects.
        public let filter: CaseFilter?
        /// The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A word or phrase used to perform a quick search.
        public let searchTerm: String?
        /// A list of sorts where each sort specifies a field and their sort order to be applied to the results.
        public let sorts: [Sort]?

        public init(domainId: String, fields: [FieldIdentifier]? = nil, filter: CaseFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, searchTerm: String? = nil, sorts: [Sort]? = nil) {
            self.domainId = domainId
            self.fields = fields
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchTerm = searchTerm
            self.sorts = sorts
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.fields, forKey: .fields)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.searchTerm, forKey: .searchTerm)
            try container.encodeIfPresent(self.sorts, forKey: .sorts)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields?.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
            try self.sorts?.forEach {
                try $0.validate(name: "\(name).sorts[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case filter = "filter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case searchTerm = "searchTerm"
            case sorts = "sorts"
        }
    }

    public struct SearchCasesResponse: AWSDecodableShape {
        /// A list of case documents where each case contains the properties CaseId and Fields where each field is a complex union structure.
        public let cases: [SearchCasesResponseItem]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(cases: [SearchCasesResponseItem], nextToken: String? = nil) {
            self.cases = cases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cases = "cases"
            case nextToken = "nextToken"
        }
    }

    public struct SearchCasesResponseItem: AWSDecodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// List of case field values.
        public let fields: [FieldValue]
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier of a template.
        public let templateId: String

        public init(caseId: String, fields: [FieldValue], tags: [String: String]? = nil, templateId: String) {
            self.caseId = caseId
            self.fields = fields
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case caseId = "caseId"
            case fields = "fields"
            case tags = "tags"
            case templateId = "templateId"
        }
    }

    public struct SearchRelatedItemsRequest: AWSEncodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The list of types of related items and their parameters to use for filtering.
        public let filters: [RelatedItemTypeFilter]?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(caseId: String, domainId: String, filters: [RelatedItemTypeFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.caseId = caseId
            self.domainId = domainId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseId, key: "caseId")
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct SearchRelatedItemsResponse: AWSDecodableShape {
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// A list of items related to a case.
        public let relatedItems: [SearchRelatedItemsResponseItem]

        public init(nextToken: String? = nil, relatedItems: [SearchRelatedItemsResponseItem]) {
            self.nextToken = nextToken
            self.relatedItems = relatedItems
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case relatedItems = "relatedItems"
        }
    }

    public struct SearchRelatedItemsResponseItem: AWSDecodableShape {
        /// Time at which a related item was associated with a case.
        @CustomCoding<ISO8601DateCoder>
        public var associationTime: Date
        /// Represents the content of a particular type of related item.
        public let content: RelatedItemContent
        /// Represents the creator of the related item.
        public let performedBy: UserUnion?
        /// Unique identifier of a related item.
        public let relatedItemId: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Type of a related item.
        public let type: RelatedItemType

        public init(associationTime: Date, content: RelatedItemContent, performedBy: UserUnion? = nil, relatedItemId: String, tags: [String: String]? = nil, type: RelatedItemType) {
            self.associationTime = associationTime
            self.content = content
            self.performedBy = performedBy
            self.relatedItemId = relatedItemId
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case associationTime = "associationTime"
            case content = "content"
            case performedBy = "performedBy"
            case relatedItemId = "relatedItemId"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct Sort: AWSEncodableShape {
        /// Unique identifier of a field.
        public let fieldId: String
        /// A structured set of sort terms
        public let sortOrder: Order

        public init(fieldId: String, sortOrder: Order) {
            self.fieldId = fieldId
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "fieldId"
            case sortOrder = "sortOrder"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN)
        public let arn: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(arn: String, tags: [String: String]) {
            self.arn = arn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TemplateSummary: AWSDecodableShape {
        /// The template name.
        public let name: String
        /// The status of the template.
        public let status: TemplateStatus
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String
        /// The unique identifier for the template.
        public let templateId: String

        public init(name: String, status: TemplateStatus, templateArn: String, templateId: String) {
            self.name = name
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
            case templateArn = "templateArn"
            case templateId = "templateId"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN)
        public let arn: String
        /// List of tag keys.
        public let tagKeys: [String]

        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateCaseRequest: AWSEncodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// An array of objects with fieldId (matching ListFields/DescribeField) and value union data, structured identical to CreateCase.
        public let fields: [FieldValue]
        public let performedBy: UserUnion?

        public init(caseId: String, domainId: String, fields: [FieldValue], performedBy: UserUnion? = nil) {
            self.caseId = caseId
            self.domainId = domainId
            self.fields = fields
            self.performedBy = performedBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseId, key: "caseId")
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.fields, forKey: .fields)
            try container.encodeIfPresent(self.performedBy, forKey: .performedBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.performedBy?.validate(name: "\(name).performedBy")
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case performedBy = "performedBy"
        }
    }

    public struct UpdateCaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFieldRequest: AWSEncodableShape {
        /// The description of a field.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// The name of the field.
        public let name: String?

        public init(description: String? = nil, domainId: String, fieldId: String, name: String? = nil) {
            self.description = description
            self.domainId = domainId
            self.fieldId = fieldId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.fieldId, key: "fieldId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateFieldResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLayoutRequest: AWSEncodableShape {
        /// Information about which fields will be present in the layout, the order of the fields.
        public let content: LayoutContent?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of the layout.
        public let layoutId: String
        /// The name of the layout. It must be unique per domain.
        public let name: String?

        public init(content: LayoutContent? = nil, domainId: String, layoutId: String, name: String? = nil) {
            self.content = content
            self.domainId = domainId
            self.layoutId = layoutId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.content, forKey: .content)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.layoutId, key: "layoutId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.content?.validate(name: "\(name).content")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.layoutId, name: "layoutId", parent: name, max: 500)
            try self.validate(self.layoutId, name: "layoutId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case name = "name"
        }
    }

    public struct UpdateLayoutResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTemplateRequest: AWSEncodableShape {
        /// A brief description of the template.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Configuration of layouts associated to the template.
        public let layoutConfiguration: LayoutConfiguration?
        /// The name of the template. It must be unique per domain.
        public let name: String?
        /// A list of fields that must contain a value for a case to be successfully created with this template.
        public let requiredFields: [RequiredField]?
        /// The status of the template.
        public let status: TemplateStatus?
        /// A unique identifier for the template.
        public let templateId: String

        public init(description: String? = nil, domainId: String, layoutConfiguration: LayoutConfiguration? = nil, name: String? = nil, requiredFields: [RequiredField]? = nil, status: TemplateStatus? = nil, templateId: String) {
            self.description = description
            self.domainId = domainId
            self.layoutConfiguration = layoutConfiguration
            self.name = name
            self.requiredFields = requiredFields
            self.status = status
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.layoutConfiguration, forKey: .layoutConfiguration)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.requiredFields, forKey: .requiredFields)
            try container.encodeIfPresent(self.status, forKey: .status)
            request.encodePath(self.templateId, key: "templateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.layoutConfiguration?.validate(name: "\(name).layoutConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.requiredFields?.forEach {
                try $0.validate(name: "\(name).requiredFields[]")
            }
            try self.validate(self.requiredFields, name: "requiredFields", parent: name, max: 100)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case layoutConfiguration = "layoutConfiguration"
            case name = "name"
            case requiredFields = "requiredFields"
            case status = "status"
        }
    }

    public struct UpdateTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct LayoutContent: AWSEncodableShape & AWSDecodableShape {
        /// Content specific to BasicLayout type. It configures fields in the top panel and More Info tab of Cases user interface.
        public let basic: BasicLayout?

        public init(basic: BasicLayout? = nil) {
            self.basic = basic
        }

        public func validate(name: String) throws {
            try self.basic?.validate(name: "\(name).basic")
        }

        private enum CodingKeys: String, CodingKey {
            case basic = "basic"
        }
    }

    public struct Section: AWSEncodableShape & AWSDecodableShape {
        /// Consists of a group of fields and associated properties.
        public let fieldGroup: FieldGroup?

        public init(fieldGroup: FieldGroup? = nil) {
            self.fieldGroup = fieldGroup
        }

        public func validate(name: String) throws {
            try self.fieldGroup?.validate(name: "\(name).fieldGroup")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldGroup = "fieldGroup"
        }
    }

    public struct UserUnion: AWSEncodableShape & AWSDecodableShape {
        /// Represents the Amazon Connect ARN of the user.
        public let userArn: String?

        public init(userArn: String? = nil) {
            self.userArn = userArn
        }

        public func validate(name: String) throws {
            try self.validate(self.userArn, name: "userArn", parent: name, max: 500)
            try self.validate(self.userArn, name: "userArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case userArn = "userArn"
        }
    }
}

// MARK: - Errors

/// Error enum for ConnectCases
public struct ConnectCasesErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ConnectCases
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
    public static var conflictException: Self { .init(.conflictException) }
    /// We couldn't process your request because of an issue with the server. Try again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota has been exceeded. For a list of service quotas, see Amazon Connect Service Quotas in the Amazon Connect Administrator Guide.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The rate has been exceeded for this API. Please try again after a few minutes.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request isn't valid. Check the syntax and try again.
    public static var validationException: Self { .init(.validationException) }
}

extension ConnectCasesErrorType: Equatable {
    public static func == (lhs: ConnectCasesErrorType, rhs: ConnectCasesErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ConnectCasesErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
