//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ConnectCases {
    // MARK: Enums

    public enum AuditEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case caseCreated = "Case.Created"
        case caseUpdated = "Case.Updated"
        case relatedItemCreated = "RelatedItem.Created"
        public var description: String { return self.rawValue }
    }

    public enum CommentBodyTextType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case textPlain = "Text/Plain"
        public var description: String { return self.rawValue }
    }

    public enum DomainStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case creationFailed = "CreationFailed"
        case creationInProgress = "CreationInProgress"
        public var description: String { return self.rawValue }
    }

    public enum FieldNamespace: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "Custom"
        case system = "System"
        public var description: String { return self.rawValue }
    }

    public enum FieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "Boolean"
        case dateTime = "DateTime"
        case number = "Number"
        case singleSelect = "SingleSelect"
        case text = "Text"
        case url = "Url"
        case user = "User"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "Asc"
        case desc = "Desc"
        public var description: String { return self.rawValue }
    }

    public enum RelatedItemType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case comment = "Comment"
        case contact = "Contact"
        case file = "File"
        public var description: String { return self.rawValue }
    }

    public enum RuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case required = "Required"
        public var description: String { return self.rawValue }
    }

    public enum TemplateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum AuditEventFieldValueUnion: AWSDecodableShape, Sendable {
        /// Can be either null, or have a Boolean value type. Only one value can be provided.
        case booleanValue(Bool)
        /// Can be either null, or have a Double value type. Only one value can be provided.
        case doubleValue(Double)
        case emptyValue(EmptyFieldValue)
        /// Can be either null, or have a String value type. Only one value can be provided.
        case stringValue(String)
        /// Can be either null, or have a String value type formatted as an ARN. Only one value can be provided.
        case userArnValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanValue:
                let value = try container.decode(Bool.self, forKey: .booleanValue)
                self = .booleanValue(value)
            case .doubleValue:
                let value = try container.decode(Double.self, forKey: .doubleValue)
                self = .doubleValue(value)
            case .emptyValue:
                let value = try container.decode(EmptyFieldValue.self, forKey: .emptyValue)
                self = .emptyValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            case .userArnValue:
                let value = try container.decode(String.self, forKey: .userArnValue)
                self = .userArnValue(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case doubleValue = "doubleValue"
            case emptyValue = "emptyValue"
            case stringValue = "stringValue"
            case userArnValue = "userArnValue"
        }
    }

    public enum BooleanCondition: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Tests that operandOne is equal to operandTwo.
        case equalTo(BooleanOperands)
        /// Tests that operandOne is not equal to operandTwo.
        case notEqualTo(BooleanOperands)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .equalTo:
                let value = try container.decode(BooleanOperands.self, forKey: .equalTo)
                self = .equalTo(value)
            case .notEqualTo:
                let value = try container.decode(BooleanOperands.self, forKey: .notEqualTo)
                self = .notEqualTo(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .equalTo(let value):
                try container.encode(value, forKey: .equalTo)
            case .notEqualTo(let value):
                try container.encode(value, forKey: .notEqualTo)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .equalTo(let value):
                try value.validate(name: "\(name).equalTo")
            case .notEqualTo(let value):
                try value.validate(name: "\(name).notEqualTo")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case equalTo = "equalTo"
            case notEqualTo = "notEqualTo"
        }
    }

    public indirect enum CaseFilter: AWSEncodableShape, Sendable {
        /// Provides "and all" filtering.
        case andAll([CaseFilter])
        /// A list of fields to filter on.
        case field(FieldFilter)
        case not(CaseFilter)
        /// Provides "or all" filtering.
        case orAll([CaseFilter])

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andAll(let value):
                try container.encode(value, forKey: .andAll)
            case .field(let value):
                try container.encode(value, forKey: .field)
            case .not(let value):
                try container.encode(value, forKey: .not)
            case .orAll(let value):
                try container.encode(value, forKey: .orAll)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andAll[]")
                }
            case .field(let value):
                try value.validate(name: "\(name).field")
            case .not(let value):
                try value.validate(name: "\(name).not")
            case .orAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).orAll[]")
                }
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAll = "andAll"
            case field = "field"
            case not = "not"
            case orAll = "orAll"
        }
    }

    public enum FieldFilter: AWSEncodableShape, Sendable {
        /// Object containing field identifier and value information.
        case contains(FieldValue)
        /// Object containing field identifier and value information.
        case equalTo(FieldValue)
        /// Object containing field identifier and value information.
        case greaterThan(FieldValue)
        /// Object containing field identifier and value information.
        case greaterThanOrEqualTo(FieldValue)
        /// Object containing field identifier and value information.
        case lessThan(FieldValue)
        /// Object containing field identifier and value information.
        case lessThanOrEqualTo(FieldValue)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .contains(let value):
                try container.encode(value, forKey: .contains)
            case .equalTo(let value):
                try container.encode(value, forKey: .equalTo)
            case .greaterThan(let value):
                try container.encode(value, forKey: .greaterThan)
            case .greaterThanOrEqualTo(let value):
                try container.encode(value, forKey: .greaterThanOrEqualTo)
            case .lessThan(let value):
                try container.encode(value, forKey: .lessThan)
            case .lessThanOrEqualTo(let value):
                try container.encode(value, forKey: .lessThanOrEqualTo)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .contains(let value):
                try value.validate(name: "\(name).contains")
            case .equalTo(let value):
                try value.validate(name: "\(name).equalTo")
            case .greaterThan(let value):
                try value.validate(name: "\(name).greaterThan")
            case .greaterThanOrEqualTo(let value):
                try value.validate(name: "\(name).greaterThanOrEqualTo")
            case .lessThan(let value):
                try value.validate(name: "\(name).lessThan")
            case .lessThanOrEqualTo(let value):
                try value.validate(name: "\(name).lessThanOrEqualTo")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contains = "contains"
            case equalTo = "equalTo"
            case greaterThan = "greaterThan"
            case greaterThanOrEqualTo = "greaterThanOrEqualTo"
            case lessThan = "lessThan"
            case lessThanOrEqualTo = "lessThanOrEqualTo"
        }
    }

    public enum FieldValueUnion: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Can be either null, or have a Boolean value type. Only one value can be provided.
        case booleanValue(Bool)
        /// Can be either null, or have a Double number value type. Only one value can be provided.
        case doubleValue(Double)
        /// An empty value.
        case emptyValue(EmptyFieldValue)
        /// String value type.
        case stringValue(String)
        /// Represents the user that performed the audit.
        case userArnValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanValue:
                let value = try container.decode(Bool.self, forKey: .booleanValue)
                self = .booleanValue(value)
            case .doubleValue:
                let value = try container.decode(Double.self, forKey: .doubleValue)
                self = .doubleValue(value)
            case .emptyValue:
                let value = try container.decode(EmptyFieldValue.self, forKey: .emptyValue)
                self = .emptyValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            case .userArnValue:
                let value = try container.decode(String.self, forKey: .userArnValue)
                self = .userArnValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .booleanValue(let value):
                try container.encode(value, forKey: .booleanValue)
            case .doubleValue(let value):
                try container.encode(value, forKey: .doubleValue)
            case .emptyValue(let value):
                try container.encode(value, forKey: .emptyValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            case .userArnValue(let value):
                try container.encode(value, forKey: .userArnValue)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case doubleValue = "doubleValue"
            case emptyValue = "emptyValue"
            case stringValue = "stringValue"
            case userArnValue = "userArnValue"
        }
    }

    public enum OperandTwo: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Boolean value type.
        case booleanValue(Bool)
        /// Double value type.
        case doubleValue(Double)
        /// Empty value type.
        case emptyValue(EmptyOperandValue)
        /// String value type.
        case stringValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanValue:
                let value = try container.decode(Bool.self, forKey: .booleanValue)
                self = .booleanValue(value)
            case .doubleValue:
                let value = try container.decode(Double.self, forKey: .doubleValue)
                self = .doubleValue(value)
            case .emptyValue:
                let value = try container.decode(EmptyOperandValue.self, forKey: .emptyValue)
                self = .emptyValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .booleanValue(let value):
                try container.encode(value, forKey: .booleanValue)
            case .doubleValue(let value):
                try container.encode(value, forKey: .doubleValue)
            case .emptyValue(let value):
                try container.encode(value, forKey: .emptyValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case doubleValue = "doubleValue"
            case emptyValue = "emptyValue"
            case stringValue = "stringValue"
        }
    }

    public enum RelatedItemContent: AWSDecodableShape, Sendable {
        /// Represents the content of a comment to be returned to agents.
        case comment(CommentContent)
        /// Represents the content of a contact to be returned to agents.
        case contact(ContactContent)
        /// Represents the content of a File to be returned to agents.
        case file(FileContent)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .comment:
                let value = try container.decode(CommentContent.self, forKey: .comment)
                self = .comment(value)
            case .contact:
                let value = try container.decode(ContactContent.self, forKey: .contact)
                self = .contact(value)
            case .file:
                let value = try container.decode(FileContent.self, forKey: .file)
                self = .file(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case contact = "contact"
            case file = "file"
        }
    }

    public enum RelatedItemInputContent: AWSEncodableShape, Sendable {
        /// Represents the content of a comment to be returned to agents.
        case comment(CommentContent)
        /// Object representing a contact in Amazon Connect as an API request field.
        case contact(Contact)
        /// A file of related items.
        case file(FileContent)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .comment(let value):
                try container.encode(value, forKey: .comment)
            case .contact(let value):
                try container.encode(value, forKey: .contact)
            case .file(let value):
                try container.encode(value, forKey: .file)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .comment(let value):
                try value.validate(name: "\(name).comment")
            case .contact(let value):
                try value.validate(name: "\(name).contact")
            case .file(let value):
                try value.validate(name: "\(name).file")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case contact = "contact"
            case file = "file"
        }
    }

    public enum RelatedItemTypeFilter: AWSEncodableShape, Sendable {
        /// A filter for related items of type Comment.
        case comment(CommentFilter)
        /// A filter for related items of type Contact.
        case contact(ContactFilter)
        /// A filter for related items of this type of File.
        case file(FileFilter)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .comment(let value):
                try container.encode(value, forKey: .comment)
            case .contact(let value):
                try container.encode(value, forKey: .contact)
            case .file(let value):
                try container.encode(value, forKey: .file)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .contact(let value):
                try value.validate(name: "\(name).contact")
            case .file(let value):
                try value.validate(name: "\(name).file")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case contact = "contact"
            case file = "file"
        }
    }

    // MARK: Shapes

    public struct AuditEvent: AWSDecodableShape {
        /// Unique identifier of a case audit history event.
        public let eventId: String
        /// A list of Case Audit History event fields.
        public let fields: [AuditEventField]
        /// Information of the user which performed the audit.
        public let performedBy: AuditEventPerformedBy?
        /// Time at which an Audit History event took place.
        @CustomCoding<ISO8601DateCoder>
        public var performedTime: Date
        /// The Type of the related item.
        public let relatedItemType: RelatedItemType?
        /// The Type of an audit history event.
        public let type: AuditEventType

        @inlinable
        public init(eventId: String, fields: [AuditEventField], performedBy: AuditEventPerformedBy? = nil, performedTime: Date, relatedItemType: RelatedItemType? = nil, type: AuditEventType) {
            self.eventId = eventId
            self.fields = fields
            self.performedBy = performedBy
            self.performedTime = performedTime
            self.relatedItemType = relatedItemType
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case fields = "fields"
            case performedBy = "performedBy"
            case performedTime = "performedTime"
            case relatedItemType = "relatedItemType"
            case type = "type"
        }
    }

    public struct AuditEventField: AWSDecodableShape {
        /// Unique identifier of field in an Audit History entry.
        public let eventFieldId: String
        /// Union of potential field value types.
        public let newValue: AuditEventFieldValueUnion
        /// Union of potential field value types.
        public let oldValue: AuditEventFieldValueUnion?

        @inlinable
        public init(eventFieldId: String, newValue: AuditEventFieldValueUnion, oldValue: AuditEventFieldValueUnion? = nil) {
            self.eventFieldId = eventFieldId
            self.newValue = newValue
            self.oldValue = oldValue
        }

        private enum CodingKeys: String, CodingKey {
            case eventFieldId = "eventFieldId"
            case newValue = "newValue"
            case oldValue = "oldValue"
        }
    }

    public struct AuditEventPerformedBy: AWSDecodableShape {
        /// Unique identifier of an IAM role.
        public let iamPrincipalArn: String
        public let user: UserUnion?

        @inlinable
        public init(iamPrincipalArn: String, user: UserUnion? = nil) {
            self.iamPrincipalArn = iamPrincipalArn
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case iamPrincipalArn = "iamPrincipalArn"
            case user = "user"
        }
    }

    public struct BasicLayout: AWSEncodableShape & AWSDecodableShape {
        /// This represents sections in a tab of the page layout.
        public let moreInfo: LayoutSections?
        /// This represents sections in a panel of the page layout.
        public let topPanel: LayoutSections?

        @inlinable
        public init(moreInfo: LayoutSections? = nil, topPanel: LayoutSections? = nil) {
            self.moreInfo = moreInfo
            self.topPanel = topPanel
        }

        public func validate(name: String) throws {
            try self.moreInfo?.validate(name: "\(name).moreInfo")
            try self.topPanel?.validate(name: "\(name).topPanel")
        }

        private enum CodingKeys: String, CodingKey {
            case moreInfo = "moreInfo"
            case topPanel = "topPanel"
        }
    }

    public struct BatchGetCaseRuleRequest: AWSEncodableShape {
        /// List of case rule identifiers.
        public let caseRules: [CaseRuleIdentifier]
        /// Unique identifier of a Cases domain.
        public let domainId: String

        @inlinable
        public init(caseRules: [CaseRuleIdentifier], domainId: String) {
            self.caseRules = caseRules
            self.domainId = domainId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.caseRules, forKey: .caseRules)
            request.encodePath(self.domainId, key: "domainId")
        }

        public func validate(name: String) throws {
            try self.caseRules.forEach {
                try $0.validate(name: "\(name).caseRules[]")
            }
            try self.validate(self.caseRules, name: "caseRules", parent: name, max: 50)
            try self.validate(self.caseRules, name: "caseRules", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case caseRules = "caseRules"
        }
    }

    public struct BatchGetCaseRuleResponse: AWSDecodableShape {
        /// List of detailed case rule information.
        public let caseRules: [GetCaseRuleResponse]
        /// List of case rule errors.
        public let errors: [CaseRuleError]

        @inlinable
        public init(caseRules: [GetCaseRuleResponse], errors: [CaseRuleError]) {
            self.caseRules = caseRules
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case caseRules = "caseRules"
            case errors = "errors"
        }
    }

    public struct BatchGetFieldRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// A list of unique field identifiers.
        public let fields: [FieldIdentifier]

        @inlinable
        public init(domainId: String, fields: [FieldIdentifier]) {
            self.domainId = domainId
            self.fields = fields
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.fields, forKey: .fields)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.fields, name: "fields", parent: name, max: 50)
            try self.validate(self.fields, name: "fields", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
        }
    }

    public struct BatchGetFieldResponse: AWSDecodableShape {
        /// A list of field errors.
        public let errors: [FieldError]
        /// A list of detailed field information.
        public let fields: [GetFieldResponse]

        @inlinable
        public init(errors: [FieldError], fields: [GetFieldResponse]) {
            self.errors = errors
            self.fields = fields
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case fields = "fields"
        }
    }

    public struct BatchPutFieldOptionsRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// A list of FieldOption objects.
        public let options: [FieldOption]

        @inlinable
        public init(domainId: String, fieldId: String, options: [FieldOption]) {
            self.domainId = domainId
            self.fieldId = fieldId
            self.options = options
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.fieldId, key: "fieldId")
            try container.encode(self.options, forKey: .options)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.options.forEach {
                try $0.validate(name: "\(name).options[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case options = "options"
        }
    }

    public struct BatchPutFieldOptionsResponse: AWSDecodableShape {
        /// A list of field errors.
        public let errors: [FieldOptionError]?

        @inlinable
        public init(errors: [FieldOptionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BooleanOperands: AWSEncodableShape & AWSDecodableShape {
        /// Represents the left hand operand in the condition.
        public let operandOne: OperandOne
        /// Represents the right hand operand in the condition.
        public let operandTwo: OperandTwo
        /// The value of the outer rule if the condition evaluates to true.
        public let result: Bool

        @inlinable
        public init(operandOne: OperandOne, operandTwo: OperandTwo, result: Bool) {
            self.operandOne = operandOne
            self.operandTwo = operandTwo
            self.result = result
        }

        public func validate(name: String) throws {
            try self.operandOne.validate(name: "\(name).operandOne")
        }

        private enum CodingKeys: String, CodingKey {
            case operandOne = "operandOne"
            case operandTwo = "operandTwo"
            case result = "result"
        }
    }

    public struct CaseEventIncludedData: AWSEncodableShape & AWSDecodableShape {
        /// List of field identifiers.
        public let fields: [FieldIdentifier]

        @inlinable
        public init(fields: [FieldIdentifier]) {
            self.fields = fields
        }

        public func validate(name: String) throws {
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
        }
    }

    public struct CaseRuleError: AWSDecodableShape {
        /// Error code from getting a case rule.
        public let errorCode: String
        /// The case rule identifier that caused the error.
        public let id: String
        /// Error message from getting a case rule.
        public let message: String?

        @inlinable
        public init(errorCode: String, id: String, message: String? = nil) {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case id = "id"
            case message = "message"
        }
    }

    public struct CaseRuleIdentifier: AWSEncodableShape {
        /// Unique identifier of a case rule.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct CaseRuleSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the case rule.
        public let caseRuleArn: String
        /// Unique identifier of a case rule.
        public let caseRuleId: String
        /// Description of a case rule.
        public let description: String?
        /// Name of the case rule.
        public let name: String
        /// Possible types for a rule.
        public let ruleType: RuleType

        @inlinable
        public init(caseRuleArn: String, caseRuleId: String, description: String? = nil, name: String, ruleType: RuleType) {
            self.caseRuleArn = caseRuleArn
            self.caseRuleId = caseRuleId
            self.description = description
            self.name = name
            self.ruleType = ruleType
        }

        private enum CodingKeys: String, CodingKey {
            case caseRuleArn = "caseRuleArn"
            case caseRuleId = "caseRuleId"
            case description = "description"
            case name = "name"
            case ruleType = "ruleType"
        }
    }

    public struct CaseSummary: AWSDecodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// A unique identifier of a template.
        public let templateId: String

        @inlinable
        public init(caseId: String, templateId: String) {
            self.caseId = caseId
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case caseId = "caseId"
            case templateId = "templateId"
        }
    }

    public struct CommentContent: AWSEncodableShape & AWSDecodableShape {
        /// Text in the body of a Comment on a case.
        public let body: String
        /// Type of the text in the box of a Comment on a case.
        public let contentType: CommentBodyTextType

        @inlinable
        public init(body: String, contentType: CommentBodyTextType) {
            self.body = body
            self.contentType = contentType
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 15000)
            try self.validate(self.body, name: "body", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
            case contentType = "contentType"
        }
    }

    public struct CommentFilter: AWSEncodableShape {
        public init() {}
    }

    public struct Contact: AWSEncodableShape {
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String

        @inlinable
        public init(contactArn: String) {
            self.contactArn = contactArn
        }

        public func validate(name: String) throws {
            try self.validate(self.contactArn, name: "contactArn", parent: name, max: 500)
            try self.validate(self.contactArn, name: "contactArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "contactArn"
        }
    }

    public struct ContactContent: AWSDecodableShape {
        /// A list of channels to filter on for related items of type Contact.
        public let channel: String
        /// The difference between the InitiationTimestamp and the DisconnectTimestamp of the contact.
        @CustomCoding<ISO8601DateCoder>
        public var connectedToSystemTime: Date
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String

        @inlinable
        public init(channel: String, connectedToSystemTime: Date, contactArn: String) {
            self.channel = channel
            self.connectedToSystemTime = connectedToSystemTime
            self.contactArn = contactArn
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "channel"
            case connectedToSystemTime = "connectedToSystemTime"
            case contactArn = "contactArn"
        }
    }

    public struct ContactFilter: AWSEncodableShape {
        /// A list of channels to filter on for related items of type Contact.
        public let channel: [String]?
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String?

        @inlinable
        public init(channel: [String]? = nil, contactArn: String? = nil) {
            self.channel = channel
            self.contactArn = contactArn
        }

        public func validate(name: String) throws {
            try self.channel?.forEach {
                try validate($0, name: "channel[]", parent: name, max: 100)
                try validate($0, name: "channel[]", parent: name, min: 1)
            }
            try self.validate(self.contactArn, name: "contactArn", parent: name, max: 500)
            try self.validate(self.contactArn, name: "contactArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "channel"
            case contactArn = "contactArn"
        }
    }

    public struct CreateCaseRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// An array of objects with field ID (matching ListFields/DescribeField) and value union data.
        public let fields: [FieldValue]
        public let performedBy: UserUnion?
        /// A unique identifier of a template.
        public let templateId: String

        @inlinable
        public init(clientToken: String? = CreateCaseRequest.idempotencyToken(), domainId: String, fields: [FieldValue], performedBy: UserUnion? = nil, templateId: String) {
            self.clientToken = clientToken
            self.domainId = domainId
            self.fields = fields
            self.performedBy = performedBy
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.fields, forKey: .fields)
            try container.encodeIfPresent(self.performedBy, forKey: .performedBy)
            try container.encode(self.templateId, forKey: .templateId)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.performedBy?.validate(name: "\(name).performedBy")
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case fields = "fields"
            case performedBy = "performedBy"
            case templateId = "templateId"
        }
    }

    public struct CreateCaseResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the case.
        public let caseArn: String
        /// A unique identifier of the case.
        public let caseId: String

        @inlinable
        public init(caseArn: String, caseId: String) {
            self.caseArn = caseArn
            self.caseId = caseId
        }

        private enum CodingKeys: String, CodingKey {
            case caseArn = "caseArn"
            case caseId = "caseId"
        }
    }

    public struct CreateCaseRuleRequest: AWSEncodableShape {
        /// The description of a case rule.
        public let description: String?
        /// Unique identifier of a Cases domain.
        public let domainId: String
        /// Name of the case rule.
        public let name: String
        /// Represents what rule type should take place, under what conditions.
        public let rule: CaseRuleDetails

        @inlinable
        public init(description: String? = nil, domainId: String, name: String, rule: CaseRuleDetails) {
            self.description = description
            self.domainId = domainId
            self.name = name
            self.rule = rule
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.rule, forKey: .rule)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.rule.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case rule = "rule"
        }
    }

    public struct CreateCaseRuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a case rule.
        public let caseRuleArn: String
        /// Unique identifier of a case rule.
        public let caseRuleId: String

        @inlinable
        public init(caseRuleArn: String, caseRuleId: String) {
            self.caseRuleArn = caseRuleArn
            self.caseRuleId = caseRuleId
        }

        private enum CodingKeys: String, CodingKey {
            case caseRuleArn = "caseRuleArn"
            case caseRuleId = "caseRuleId"
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        /// The name for your Cases domain. It must be unique for your Amazon Web Services account.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct CreateDomainResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the Cases domain.
        public let domainArn: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The status of the domain.
        public let domainStatus: DomainStatus

        @inlinable
        public init(domainArn: String, domainId: String, domainStatus: DomainStatus) {
            self.domainArn = domainArn
            self.domainId = domainId
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "domainArn"
            case domainId = "domainId"
            case domainStatus = "domainStatus"
        }
    }

    public struct CreateFieldRequest: AWSEncodableShape {
        /// The description of the field.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The name of the field.
        public let name: String
        /// Defines the data type, some system constraints, and default display of the field.
        public let type: FieldType

        @inlinable
        public init(description: String? = nil, domainId: String, name: String, type: FieldType) {
            self.description = description
            self.domainId = domainId
            self.name = name
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case type = "type"
        }
    }

    public struct CreateFieldResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the field.
        public let fieldArn: String
        /// The unique identifier of a field.
        public let fieldId: String

        @inlinable
        public init(fieldArn: String, fieldId: String) {
            self.fieldArn = fieldArn
            self.fieldId = fieldId
        }

        private enum CodingKeys: String, CodingKey {
            case fieldArn = "fieldArn"
            case fieldId = "fieldId"
        }
    }

    public struct CreateLayoutRequest: AWSEncodableShape {
        /// Information about which fields will be present in the layout, and information about the order of the fields.
        public let content: LayoutContent
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The name of the layout. It must be unique for the Cases domain.
        public let name: String

        @inlinable
        public init(content: LayoutContent, domainId: String, name: String) {
            self.content = content
            self.domainId = domainId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.content, forKey: .content)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.content.validate(name: "\(name).content")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case name = "name"
        }
    }

    public struct CreateLayoutResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created layout.
        public let layoutArn: String
        /// The unique identifier of the layout.
        public let layoutId: String

        @inlinable
        public init(layoutArn: String, layoutId: String) {
            self.layoutArn = layoutArn
            self.layoutId = layoutId
        }

        private enum CodingKeys: String, CodingKey {
            case layoutArn = "layoutArn"
            case layoutId = "layoutId"
        }
    }

    public struct CreateRelatedItemRequest: AWSEncodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// The content of a related item to be created.
        public let content: RelatedItemInputContent
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Represents the creator of the related item.
        public let performedBy: UserUnion?
        /// The type of a related item.
        public let type: RelatedItemType

        @inlinable
        public init(caseId: String, content: RelatedItemInputContent, domainId: String, performedBy: UserUnion? = nil, type: RelatedItemType) {
            self.caseId = caseId
            self.content = content
            self.domainId = domainId
            self.performedBy = performedBy
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseId, key: "caseId")
            try container.encode(self.content, forKey: .content)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.performedBy, forKey: .performedBy)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.content.validate(name: "\(name).content")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.performedBy?.validate(name: "\(name).performedBy")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case performedBy = "performedBy"
            case type = "type"
        }
    }

    public struct CreateRelatedItemResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the related item.
        public let relatedItemArn: String
        /// The unique identifier of the related item.
        public let relatedItemId: String

        @inlinable
        public init(relatedItemArn: String, relatedItemId: String) {
            self.relatedItemArn = relatedItemArn
            self.relatedItemId = relatedItemId
        }

        private enum CodingKeys: String, CodingKey {
            case relatedItemArn = "relatedItemArn"
            case relatedItemId = "relatedItemId"
        }
    }

    public struct CreateTemplateRequest: AWSEncodableShape {
        /// A brief description of the template.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Configuration of layouts associated to the template.
        public let layoutConfiguration: LayoutConfiguration?
        /// A name for the template. It must be unique per domain.
        public let name: String
        /// A list of fields that must contain a value for a case to be successfully created with this template.
        public let requiredFields: [RequiredField]?
        /// A list of case rules (also known as case field conditions) on a template.
        public let rules: [TemplateRule]?
        /// The status of the template.
        public let status: TemplateStatus?

        @inlinable
        public init(description: String? = nil, domainId: String, layoutConfiguration: LayoutConfiguration? = nil, name: String, requiredFields: [RequiredField]? = nil, rules: [TemplateRule]? = nil, status: TemplateStatus? = nil) {
            self.description = description
            self.domainId = domainId
            self.layoutConfiguration = layoutConfiguration
            self.name = name
            self.requiredFields = requiredFields
            self.rules = rules
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.layoutConfiguration, forKey: .layoutConfiguration)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.requiredFields, forKey: .requiredFields)
            try container.encodeIfPresent(self.rules, forKey: .rules)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.layoutConfiguration?.validate(name: "\(name).layoutConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.requiredFields?.forEach {
                try $0.validate(name: "\(name).requiredFields[]")
            }
            try self.validate(self.requiredFields, name: "requiredFields", parent: name, max: 100)
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case layoutConfiguration = "layoutConfiguration"
            case name = "name"
            case requiredFields = "requiredFields"
            case rules = "rules"
            case status = "status"
        }
    }

    public struct CreateTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created template.
        public let templateArn: String
        /// A unique identifier of a template.
        public let templateId: String

        @inlinable
        public init(templateArn: String, templateId: String) {
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case templateArn = "templateArn"
            case templateId = "templateId"
        }
    }

    public struct DeleteCaseRuleRequest: AWSEncodableShape {
        /// Unique identifier of a case rule.
        public let caseRuleId: String
        /// Unique identifier of a Cases domain.
        public let domainId: String

        @inlinable
        public init(caseRuleId: String, domainId: String) {
            self.caseRuleId = caseRuleId
            self.domainId = domainId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseRuleId, key: "caseRuleId")
            request.encodePath(self.domainId, key: "domainId")
        }

        public func validate(name: String) throws {
            try self.validate(self.caseRuleId, name: "caseRuleId", parent: name, max: 500)
            try self.validate(self.caseRuleId, name: "caseRuleId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCaseRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String

        @inlinable
        public init(domainId: String) {
            self.domainId = domainId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFieldRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Unique identifier of the field.
        public let fieldId: String

        @inlinable
        public init(domainId: String, fieldId: String) {
            self.domainId = domainId
            self.fieldId = fieldId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.fieldId, key: "fieldId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFieldResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLayoutRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of the layout.
        public let layoutId: String

        @inlinable
        public init(domainId: String, layoutId: String) {
            self.domainId = domainId
            self.layoutId = layoutId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.layoutId, key: "layoutId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.layoutId, name: "layoutId", parent: name, max: 500)
            try self.validate(self.layoutId, name: "layoutId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLayoutResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTemplateRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// A unique identifier of a template.
        public let templateId: String

        @inlinable
        public init(domainId: String, templateId: String) {
            self.domainId = domainId
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.templateId, key: "templateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DomainSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the domain.
        public let domainArn: String
        /// The unique identifier of the domain.
        public let domainId: String
        /// The name of the domain.
        public let name: String

        @inlinable
        public init(domainArn: String, domainId: String, name: String) {
            self.domainArn = domainArn
            self.domainId = domainId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "domainArn"
            case domainId = "domainId"
            case name = "name"
        }
    }

    public struct EmptyFieldValue: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct EmptyOperandValue: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct EventBridgeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the to broadcast case event data to the customer.
        public let enabled: Bool
        /// Details of what case and related item data is published through the case event stream.
        public let includedData: EventIncludedData?

        @inlinable
        public init(enabled: Bool, includedData: EventIncludedData? = nil) {
            self.enabled = enabled
            self.includedData = includedData
        }

        public func validate(name: String) throws {
            try self.includedData?.validate(name: "\(name).includedData")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case includedData = "includedData"
        }
    }

    public struct EventIncludedData: AWSEncodableShape & AWSDecodableShape {
        /// Details of what case data is published through the case event stream.
        public let caseData: CaseEventIncludedData?
        /// Details of what related item data is published through the case event stream.
        public let relatedItemData: RelatedItemEventIncludedData?

        @inlinable
        public init(caseData: CaseEventIncludedData? = nil, relatedItemData: RelatedItemEventIncludedData? = nil) {
            self.caseData = caseData
            self.relatedItemData = relatedItemData
        }

        public func validate(name: String) throws {
            try self.caseData?.validate(name: "\(name).caseData")
        }

        private enum CodingKeys: String, CodingKey {
            case caseData = "caseData"
            case relatedItemData = "relatedItemData"
        }
    }

    public struct FieldError: AWSDecodableShape {
        /// The error code from getting a field.
        public let errorCode: String
        /// The field identifier that caused the error.
        public let id: String
        /// The error message from getting a field.
        public let message: String?

        @inlinable
        public init(errorCode: String, id: String, message: String? = nil) {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case id = "id"
            case message = "message"
        }
    }

    public struct FieldGroup: AWSEncodableShape & AWSDecodableShape {
        /// Represents an ordered list containing field related information.
        public let fields: [FieldItem]
        /// Name of the field group.
        public let name: String?

        @inlinable
        public init(fields: [FieldItem], name: String? = nil) {
            self.fields = fields
            self.name = name
        }

        public func validate(name: String) throws {
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case name = "name"
        }
    }

    public struct FieldIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct FieldItem: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct FieldOption: AWSEncodableShape & AWSDecodableShape {
        /// Describes whether the FieldOption is active (displayed) or inactive.
        public let active: Bool
        ///  FieldOptionName has max length 100 and disallows trailing spaces.
        public let name: String
        ///  FieldOptionValue has max length 100 and must be alphanumeric with hyphens and underscores.
        public let value: String

        @inlinable
        public init(active: Bool, name: String, value: String) {
            self.active = active
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.validate(self.value, name: "value", parent: name, max: 100)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "active"
            case name = "name"
            case value = "value"
        }
    }

    public struct FieldOptionError: AWSDecodableShape {
        /// Error code from creating or updating field option.
        public let errorCode: String
        /// Error message from creating or updating field option.
        public let message: String
        /// The field option value that caused the error.
        public let value: String

        @inlinable
        public init(errorCode: String, message: String, value: String) {
            self.errorCode = errorCode
            self.message = message
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case message = "message"
            case value = "value"
        }
    }

    public struct FieldSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the field.
        public let fieldArn: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// Name of the field.
        public let name: String
        /// The namespace of a field.
        public let namespace: FieldNamespace
        /// The type of a field.
        public let type: FieldType

        @inlinable
        public init(fieldArn: String, fieldId: String, name: String, namespace: FieldNamespace, type: FieldType) {
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.name = name
            self.namespace = namespace
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case fieldArn = "fieldArn"
            case fieldId = "fieldId"
            case name = "name"
            case namespace = "namespace"
            case type = "type"
        }
    }

    public struct FieldValue: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let id: String
        /// Union of potential field value types.
        public let value: FieldValueUnion

        @inlinable
        public init(id: String, value: FieldValueUnion) {
            self.id = id
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case value = "value"
        }
    }

    public struct FileContent: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a File in Amazon Connect.
        public let fileArn: String

        @inlinable
        public init(fileArn: String) {
            self.fileArn = fileArn
        }

        public func validate(name: String) throws {
            try self.validate(self.fileArn, name: "fileArn", parent: name, max: 500)
            try self.validate(self.fileArn, name: "fileArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileArn = "fileArn"
        }
    }

    public struct FileFilter: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the file.
        public let fileArn: String?

        @inlinable
        public init(fileArn: String? = nil) {
            self.fileArn = fileArn
        }

        public func validate(name: String) throws {
            try self.validate(self.fileArn, name: "fileArn", parent: name, max: 500)
            try self.validate(self.fileArn, name: "fileArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileArn = "fileArn"
        }
    }

    public struct GetCaseAuditEventsRequest: AWSEncodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of audit events to return. The current maximum supported value is 25. This is also the default when no other value is provided.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(caseId: String, domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.caseId = caseId
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseId, key: "caseId")
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetCaseAuditEventsResponse: AWSDecodableShape {
        /// A list of case audits where each represents a particular edit of the case.
        public let auditEvents: [AuditEvent]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(auditEvents: [AuditEvent], nextToken: String? = nil) {
            self.auditEvents = auditEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case auditEvents = "auditEvents"
            case nextToken = "nextToken"
        }
    }

    public struct GetCaseEventConfigurationRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String

        @inlinable
        public init(domainId: String) {
            self.domainId = domainId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCaseEventConfigurationResponse: AWSDecodableShape {
        /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
        public let eventBridge: EventBridgeConfiguration

        @inlinable
        public init(eventBridge: EventBridgeConfiguration) {
            self.eventBridge = eventBridge
        }

        private enum CodingKeys: String, CodingKey {
            case eventBridge = "eventBridge"
        }
    }

    public struct GetCaseRequest: AWSEncodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// A list of unique field identifiers.
        public let fields: [FieldIdentifier]
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(caseId: String, domainId: String, fields: [FieldIdentifier], nextToken: String? = nil) {
            self.caseId = caseId
            self.domainId = domainId
            self.fields = fields
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseId, key: "caseId")
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.fields, forKey: .fields)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case nextToken = "nextToken"
        }
    }

    public struct GetCaseResponse: AWSDecodableShape {
        /// A list of detailed field information.
        public let fields: [FieldValue]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier of a template.
        public let templateId: String

        @inlinable
        public init(fields: [FieldValue], nextToken: String? = nil, tags: [String: String]? = nil, templateId: String) {
            self.fields = fields
            self.nextToken = nextToken
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case nextToken = "nextToken"
            case tags = "tags"
            case templateId = "templateId"
        }
    }

    public struct GetCaseRuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the case rule.
        public let caseRuleArn: String
        /// Unique identifier of a case rule.
        public let caseRuleId: String
        /// Timestamp when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTime: Date?
        /// Indicates whether the resource has been deleted.
        public let deleted: Bool?
        /// Description of a case rule.
        public let description: String?
        /// Timestamp when the resource was created or last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// Name of the case rule.
        public let name: String
        /// Represents what rule type should take place, under what conditions.
        public let rule: CaseRuleDetails
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(caseRuleArn: String, caseRuleId: String, createdTime: Date? = nil, deleted: Bool? = nil, description: String? = nil, lastModifiedTime: Date? = nil, name: String, rule: CaseRuleDetails, tags: [String: String]? = nil) {
            self.caseRuleArn = caseRuleArn
            self.caseRuleId = caseRuleId
            self.createdTime = createdTime
            self.deleted = deleted
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.rule = rule
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case caseRuleArn = "caseRuleArn"
            case caseRuleId = "caseRuleId"
            case createdTime = "createdTime"
            case deleted = "deleted"
            case description = "description"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case rule = "rule"
            case tags = "tags"
        }
    }

    public struct GetDomainRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String

        @inlinable
        public init(domainId: String) {
            self.domainId = domainId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainResponse: AWSDecodableShape {
        /// The timestamp when the Cases domain was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdTime: Date
        /// The Amazon Resource Name (ARN) for the Cases domain.
        public let domainArn: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The status of the Cases domain.
        public let domainStatus: DomainStatus
        /// The name of the Cases domain.
        public let name: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(createdTime: Date, domainArn: String, domainId: String, domainStatus: DomainStatus, name: String, tags: [String: String]? = nil) {
            self.createdTime = createdTime
            self.domainArn = domainArn
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case domainArn = "domainArn"
            case domainId = "domainId"
            case domainStatus = "domainStatus"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct GetFieldResponse: AWSDecodableShape {
        /// Timestamp at which the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTime: Date?
        /// Denotes whether or not the resource has been deleted.
        public let deleted: Bool?
        /// Description of the field.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the field.
        public let fieldArn: String
        /// Unique identifier of the field.
        public let fieldId: String
        /// Timestamp at which the resource was created or last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// Name of the field.
        public let name: String
        /// Namespace of the field.
        public let namespace: FieldNamespace
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Type of the field.
        public let type: FieldType

        @inlinable
        public init(createdTime: Date? = nil, deleted: Bool? = nil, description: String? = nil, fieldArn: String, fieldId: String, lastModifiedTime: Date? = nil, name: String, namespace: FieldNamespace, tags: [String: String]? = nil, type: FieldType) {
            self.createdTime = createdTime
            self.deleted = deleted
            self.description = description
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.namespace = namespace
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case deleted = "deleted"
            case description = "description"
            case fieldArn = "fieldArn"
            case fieldId = "fieldId"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case namespace = "namespace"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct GetLayoutRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of the layout.
        public let layoutId: String

        @inlinable
        public init(domainId: String, layoutId: String) {
            self.domainId = domainId
            self.layoutId = layoutId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.layoutId, key: "layoutId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.layoutId, name: "layoutId", parent: name, max: 500)
            try self.validate(self.layoutId, name: "layoutId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLayoutResponse: AWSDecodableShape {
        /// Information about which fields will be present in the layout, the order of the fields, and read-only attribute of the field.
        public let content: LayoutContent
        /// Timestamp at which the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTime: Date?
        /// Denotes whether or not the resource has been deleted.
        public let deleted: Bool?
        /// Timestamp at which the resource was created or last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// The Amazon Resource Name (ARN) of the newly created layout.
        public let layoutArn: String
        /// The unique identifier of the layout.
        public let layoutId: String
        /// The name of the layout. It must be unique.
        public let name: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(content: LayoutContent, createdTime: Date? = nil, deleted: Bool? = nil, lastModifiedTime: Date? = nil, layoutArn: String, layoutId: String, name: String, tags: [String: String]? = nil) {
            self.content = content
            self.createdTime = createdTime
            self.deleted = deleted
            self.lastModifiedTime = lastModifiedTime
            self.layoutArn = layoutArn
            self.layoutId = layoutId
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case createdTime = "createdTime"
            case deleted = "deleted"
            case lastModifiedTime = "lastModifiedTime"
            case layoutArn = "layoutArn"
            case layoutId = "layoutId"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct GetTemplateRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// A unique identifier of a template.
        public let templateId: String

        @inlinable
        public init(domainId: String, templateId: String) {
            self.domainId = domainId
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.templateId, key: "templateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTemplateResponse: AWSDecodableShape {
        /// Timestamp at which the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTime: Date?
        /// Denotes whether or not the resource has been deleted.
        public let deleted: Bool?
        /// A brief description of the template.
        public let description: String?
        /// Timestamp at which the resource was created or last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// Configuration of layouts associated to the template.
        public let layoutConfiguration: LayoutConfiguration?
        /// The name of the template.
        public let name: String
        /// A list of fields that must contain a value for a case to be successfully created with this template.
        public let requiredFields: [RequiredField]?
        /// A list of case rules (also known as case field conditions) on a template.
        public let rules: [TemplateRule]?
        /// The status of the template.
        public let status: TemplateStatus
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String
        /// A unique identifier of a template.
        public let templateId: String

        @inlinable
        public init(createdTime: Date? = nil, deleted: Bool? = nil, description: String? = nil, lastModifiedTime: Date? = nil, layoutConfiguration: LayoutConfiguration? = nil, name: String, requiredFields: [RequiredField]? = nil, rules: [TemplateRule]? = nil, status: TemplateStatus, tags: [String: String]? = nil, templateArn: String, templateId: String) {
            self.createdTime = createdTime
            self.deleted = deleted
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.layoutConfiguration = layoutConfiguration
            self.name = name
            self.requiredFields = requiredFields
            self.rules = rules
            self.status = status
            self.tags = tags
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case deleted = "deleted"
            case description = "description"
            case lastModifiedTime = "lastModifiedTime"
            case layoutConfiguration = "layoutConfiguration"
            case name = "name"
            case requiredFields = "requiredFields"
            case rules = "rules"
            case status = "status"
            case tags = "tags"
            case templateArn = "templateArn"
            case templateId = "templateId"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// Advice to clients on when the call can be safely retried.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct LayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  Unique identifier of a layout.
        public let defaultLayout: String?

        @inlinable
        public init(defaultLayout: String? = nil) {
            self.defaultLayout = defaultLayout
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultLayout, name: "defaultLayout", parent: name, max: 500)
            try self.validate(self.defaultLayout, name: "defaultLayout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultLayout = "defaultLayout"
        }
    }

    public struct LayoutSections: AWSEncodableShape & AWSDecodableShape {
        public let sections: [Section]?

        @inlinable
        public init(sections: [Section]? = nil) {
            self.sections = sections
        }

        public func validate(name: String) throws {
            try self.sections?.forEach {
                try $0.validate(name: "\(name).sections[]")
            }
            try self.validate(self.sections, name: "sections", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case sections = "sections"
        }
    }

    public struct LayoutSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the layout.
        public let layoutArn: String
        /// The unique identifier for of the layout.
        public let layoutId: String
        /// The name of the layout.
        public let name: String

        @inlinable
        public init(layoutArn: String, layoutId: String, name: String) {
            self.layoutArn = layoutArn
            self.layoutId = layoutId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case layoutArn = "layoutArn"
            case layoutId = "layoutId"
            case name = "name"
        }
    }

    public struct ListCaseRulesRequest: AWSEncodableShape {
        /// Unique identifier of a Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCaseRulesResponse: AWSDecodableShape {
        /// A list of field summary objects.
        public let caseRules: [CaseRuleSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(caseRules: [CaseRuleSummary], nextToken: String? = nil) {
            self.caseRules = caseRules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case caseRules = "caseRules"
            case nextToken = "nextToken"
        }
    }

    public struct ListCasesForContactRequest: AWSEncodableShape {
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contactArn: String, domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contactArn = contactArn
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.contactArn, forKey: .contactArn)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactArn, name: "contactArn", parent: name, max: 500)
            try self.validate(self.contactArn, name: "contactArn", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "contactArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListCasesForContactResponse: AWSDecodableShape {
        /// A list of Case summary information.
        public let cases: [CaseSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(cases: [CaseSummary], nextToken: String? = nil) {
            self.cases = cases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cases = "cases"
            case nextToken = "nextToken"
        }
    }

    public struct ListDomainsRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainsResponse: AWSDecodableShape {
        /// The Cases domain.
        public let domains: [DomainSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(domains: [DomainSummary], nextToken: String? = nil) {
            self.domains = domains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domains = "domains"
            case nextToken = "nextToken"
        }
    }

    public struct ListFieldOptionsRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A list of FieldOption values to filter on for ListFieldOptions.
        public let values: [String]?

        @inlinable
        public init(domainId: String, fieldId: String, maxResults: Int? = nil, nextToken: String? = nil, values: [String]? = nil) {
            self.domainId = domainId
            self.fieldId = fieldId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.values = values
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.fieldId, key: "fieldId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.values, key: "values")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFieldOptionsResponse: AWSDecodableShape {
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// A list of FieldOption objects.
        public let options: [FieldOption]

        @inlinable
        public init(nextToken: String? = nil, options: [FieldOption]) {
            self.nextToken = nextToken
            self.options = options
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case options = "options"
        }
    }

    public struct ListFieldsRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFieldsResponse: AWSDecodableShape {
        /// List of detailed field information.
        public let fields: [FieldSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(fields: [FieldSummary], nextToken: String? = nil) {
            self.fields = fields
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case nextToken = "nextToken"
        }
    }

    public struct ListLayoutsRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLayoutsResponse: AWSDecodableShape {
        /// The layouts for the domain.
        public let layouts: [LayoutSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(layouts: [LayoutSummary], nextToken: String? = nil) {
            self.layouts = layouts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case layouts = "layouts"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN)
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTemplatesRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A list of status values to filter on.
        public let status: [TemplateStatus]?

        @inlinable
        public init(domainId: String, maxResults: Int? = nil, nextToken: String? = nil, status: [TemplateStatus]? = nil) {
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
            try self.validate(self.status, name: "status", parent: name, max: 2)
            try self.validate(self.status, name: "status", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplatesResponse: AWSDecodableShape {
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// List of template summary objects.
        public let templates: [TemplateSummary]

        @inlinable
        public init(nextToken: String? = nil, templates: [TemplateSummary]) {
            self.nextToken = nextToken
            self.templates = templates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case templates = "templates"
        }
    }

    public struct PutCaseEventConfigurationRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
        public let eventBridge: EventBridgeConfiguration

        @inlinable
        public init(domainId: String, eventBridge: EventBridgeConfiguration) {
            self.domainId = domainId
            self.eventBridge = eventBridge
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.eventBridge, forKey: .eventBridge)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.eventBridge.validate(name: "\(name).eventBridge")
        }

        private enum CodingKeys: String, CodingKey {
            case eventBridge = "eventBridge"
        }
    }

    public struct PutCaseEventConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RelatedItemEventIncludedData: AWSEncodableShape & AWSDecodableShape {
        /// Details of what related item data is published through the case event stream.
        public let includeContent: Bool

        @inlinable
        public init(includeContent: Bool) {
            self.includeContent = includeContent
        }

        private enum CodingKeys: String, CodingKey {
            case includeContent = "includeContent"
        }
    }

    public struct RequiredCaseRule: AWSEncodableShape & AWSDecodableShape {
        /// List of conditions for the required rule; the first condition to evaluate to true dictates the value of the rule.
        public let conditions: [BooleanCondition]
        /// The value of the rule (that is, whether the field is required) should none of the conditions evaluate to true.
        public let defaultValue: Bool

        @inlinable
        public init(conditions: [BooleanCondition], defaultValue: Bool) {
            self.conditions = conditions
            self.defaultValue = defaultValue
        }

        public func validate(name: String) throws {
            try self.conditions.forEach {
                try $0.validate(name: "\(name).conditions[]")
            }
            try self.validate(self.conditions, name: "conditions", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case conditions = "conditions"
            case defaultValue = "defaultValue"
        }
    }

    public struct RequiredField: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let fieldId: String

        @inlinable
        public init(fieldId: String) {
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "fieldId"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// Unique identifier of the resource affected.
        public let resourceId: String
        /// Type of the resource affected.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct SearchCasesRequest: AWSEncodableShape {
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The list of field identifiers to be returned as part of the response.
        public let fields: [FieldIdentifier]?
        /// A list of filter objects.
        public let filter: CaseFilter?
        /// The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A word or phrase used to perform a quick search.
        public let searchTerm: String?
        /// A list of sorts where each sort specifies a field and their sort order to be applied to the results.
        public let sorts: [Sort]?

        @inlinable
        public init(domainId: String, fields: [FieldIdentifier]? = nil, filter: CaseFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, searchTerm: String? = nil, sorts: [Sort]? = nil) {
            self.domainId = domainId
            self.fields = fields
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchTerm = searchTerm
            self.sorts = sorts
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.fields, forKey: .fields)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.searchTerm, forKey: .searchTerm)
            try container.encodeIfPresent(self.sorts, forKey: .sorts)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields?.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
            try self.sorts?.forEach {
                try $0.validate(name: "\(name).sorts[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case filter = "filter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case searchTerm = "searchTerm"
            case sorts = "sorts"
        }
    }

    public struct SearchCasesResponse: AWSDecodableShape {
        /// A list of case documents where each case contains the properties CaseId and Fields where each field is a complex union structure.
        public let cases: [SearchCasesResponseItem]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(cases: [SearchCasesResponseItem], nextToken: String? = nil) {
            self.cases = cases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cases = "cases"
            case nextToken = "nextToken"
        }
    }

    public struct SearchCasesResponseItem: AWSDecodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// List of case field values.
        public let fields: [FieldValue]
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier of a template.
        public let templateId: String

        @inlinable
        public init(caseId: String, fields: [FieldValue], tags: [String: String]? = nil, templateId: String) {
            self.caseId = caseId
            self.fields = fields
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case caseId = "caseId"
            case fields = "fields"
            case tags = "tags"
            case templateId = "templateId"
        }
    }

    public struct SearchRelatedItemsRequest: AWSEncodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The list of types of related items and their parameters to use for filtering.
        public let filters: [RelatedItemTypeFilter]?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(caseId: String, domainId: String, filters: [RelatedItemTypeFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.caseId = caseId
            self.domainId = domainId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseId, key: "caseId")
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct SearchRelatedItemsResponse: AWSDecodableShape {
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// A list of items related to a case.
        public let relatedItems: [SearchRelatedItemsResponseItem]

        @inlinable
        public init(nextToken: String? = nil, relatedItems: [SearchRelatedItemsResponseItem]) {
            self.nextToken = nextToken
            self.relatedItems = relatedItems
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case relatedItems = "relatedItems"
        }
    }

    public struct SearchRelatedItemsResponseItem: AWSDecodableShape {
        /// Time at which a related item was associated with a case.
        @CustomCoding<ISO8601DateCoder>
        public var associationTime: Date
        /// Represents the content of a particular type of related item.
        public let content: RelatedItemContent
        /// Represents the creator of the related item.
        public let performedBy: UserUnion?
        /// Unique identifier of a related item.
        public let relatedItemId: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Type of a related item.
        public let type: RelatedItemType

        @inlinable
        public init(associationTime: Date, content: RelatedItemContent, performedBy: UserUnion? = nil, relatedItemId: String, tags: [String: String]? = nil, type: RelatedItemType) {
            self.associationTime = associationTime
            self.content = content
            self.performedBy = performedBy
            self.relatedItemId = relatedItemId
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case associationTime = "associationTime"
            case content = "content"
            case performedBy = "performedBy"
            case relatedItemId = "relatedItemId"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct Sort: AWSEncodableShape {
        /// Unique identifier of a field.
        public let fieldId: String
        /// A structured set of sort terms
        public let sortOrder: Order

        @inlinable
        public init(fieldId: String, sortOrder: Order) {
            self.fieldId = fieldId
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "fieldId"
            case sortOrder = "sortOrder"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN)
        public let arn: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]

        @inlinable
        public init(arn: String, tags: [String: String]) {
            self.arn = arn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TemplateRule: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a case rule.
        public let caseRuleId: String
        /// Unique identifier of a field.
        public let fieldId: String

        @inlinable
        public init(caseRuleId: String, fieldId: String) {
            self.caseRuleId = caseRuleId
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.caseRuleId, name: "caseRuleId", parent: name, max: 500)
            try self.validate(self.caseRuleId, name: "caseRuleId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case caseRuleId = "caseRuleId"
            case fieldId = "fieldId"
        }
    }

    public struct TemplateSummary: AWSDecodableShape {
        /// The template name.
        public let name: String
        /// The status of the template.
        public let status: TemplateStatus
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String
        /// The unique identifier for the template.
        public let templateId: String

        @inlinable
        public init(name: String, status: TemplateStatus, templateArn: String, templateId: String) {
            self.name = name
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
            case templateArn = "templateArn"
            case templateId = "templateId"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN)
        public let arn: String
        /// List of tag keys.
        public let tagKeys: [String]

        @inlinable
        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "arn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateCaseRequest: AWSEncodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// An array of objects with fieldId (matching ListFields/DescribeField) and value union data, structured identical to CreateCase.
        public let fields: [FieldValue]
        public let performedBy: UserUnion?

        @inlinable
        public init(caseId: String, domainId: String, fields: [FieldValue], performedBy: UserUnion? = nil) {
            self.caseId = caseId
            self.domainId = domainId
            self.fields = fields
            self.performedBy = performedBy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseId, key: "caseId")
            request.encodePath(self.domainId, key: "domainId")
            try container.encode(self.fields, forKey: .fields)
            try container.encodeIfPresent(self.performedBy, forKey: .performedBy)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.performedBy?.validate(name: "\(name).performedBy")
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
            case performedBy = "performedBy"
        }
    }

    public struct UpdateCaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCaseRuleRequest: AWSEncodableShape {
        /// Unique identifier of a case rule.
        public let caseRuleId: String
        /// Description of a case rule.
        public let description: String?
        /// Unique identifier of a Cases domain.
        public let domainId: String
        /// Name of the case rule.
        public let name: String?
        /// Represents what rule type should take place, under what conditions.
        public let rule: CaseRuleDetails?

        @inlinable
        public init(caseRuleId: String, description: String? = nil, domainId: String, name: String? = nil, rule: CaseRuleDetails? = nil) {
            self.caseRuleId = caseRuleId
            self.description = description
            self.domainId = domainId
            self.name = name
            self.rule = rule
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.caseRuleId, key: "caseRuleId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.rule, forKey: .rule)
        }

        public func validate(name: String) throws {
            try self.validate(self.caseRuleId, name: "caseRuleId", parent: name, max: 500)
            try self.validate(self.caseRuleId, name: "caseRuleId", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.rule?.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case rule = "rule"
        }
    }

    public struct UpdateCaseRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFieldRequest: AWSEncodableShape {
        /// The description of a field.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// The name of the field.
        public let name: String?

        @inlinable
        public init(description: String? = nil, domainId: String, fieldId: String, name: String? = nil) {
            self.description = description
            self.domainId = domainId
            self.fieldId = fieldId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.fieldId, key: "fieldId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateFieldResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLayoutRequest: AWSEncodableShape {
        /// Information about which fields will be present in the layout, the order of the fields.
        public let content: LayoutContent?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of the layout.
        public let layoutId: String
        /// The name of the layout. It must be unique per domain.
        public let name: String?

        @inlinable
        public init(content: LayoutContent? = nil, domainId: String, layoutId: String, name: String? = nil) {
            self.content = content
            self.domainId = domainId
            self.layoutId = layoutId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.content, forKey: .content)
            request.encodePath(self.domainId, key: "domainId")
            request.encodePath(self.layoutId, key: "layoutId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.content?.validate(name: "\(name).content")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.layoutId, name: "layoutId", parent: name, max: 500)
            try self.validate(self.layoutId, name: "layoutId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case name = "name"
        }
    }

    public struct UpdateLayoutResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTemplateRequest: AWSEncodableShape {
        /// A brief description of the template.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Configuration of layouts associated to the template.
        public let layoutConfiguration: LayoutConfiguration?
        /// The name of the template. It must be unique per domain.
        public let name: String?
        /// A list of fields that must contain a value for a case to be successfully created with this template.
        public let requiredFields: [RequiredField]?
        /// A list of case rules (also known as case field conditions) on a template.
        public let rules: [TemplateRule]?
        /// The status of the template.
        public let status: TemplateStatus?
        /// A unique identifier for the template.
        public let templateId: String

        @inlinable
        public init(description: String? = nil, domainId: String, layoutConfiguration: LayoutConfiguration? = nil, name: String? = nil, requiredFields: [RequiredField]? = nil, rules: [TemplateRule]? = nil, status: TemplateStatus? = nil, templateId: String) {
            self.description = description
            self.domainId = domainId
            self.layoutConfiguration = layoutConfiguration
            self.name = name
            self.requiredFields = requiredFields
            self.rules = rules
            self.status = status
            self.templateId = templateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainId, key: "domainId")
            try container.encodeIfPresent(self.layoutConfiguration, forKey: .layoutConfiguration)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.requiredFields, forKey: .requiredFields)
            try container.encodeIfPresent(self.rules, forKey: .rules)
            try container.encodeIfPresent(self.status, forKey: .status)
            request.encodePath(self.templateId, key: "templateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.layoutConfiguration?.validate(name: "\(name).layoutConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.requiredFields?.forEach {
                try $0.validate(name: "\(name).requiredFields[]")
            }
            try self.validate(self.requiredFields, name: "requiredFields", parent: name, max: 100)
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 50)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case layoutConfiguration = "layoutConfiguration"
            case name = "name"
            case requiredFields = "requiredFields"
            case rules = "rules"
            case status = "status"
        }
    }

    public struct UpdateTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CaseRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// Required rule type, used to indicate whether a field is required.
        public let required: RequiredCaseRule?

        @inlinable
        public init(required: RequiredCaseRule? = nil) {
            self.required = required
        }

        public func validate(name: String) throws {
            try self.required?.validate(name: "\(name).required")
        }

        private enum CodingKeys: String, CodingKey {
            case required = "required"
        }
    }

    public struct LayoutContent: AWSEncodableShape & AWSDecodableShape {
        /// Content specific to BasicLayout type. It configures fields in the top panel and More Info tab of Cases user interface.
        public let basic: BasicLayout?

        @inlinable
        public init(basic: BasicLayout? = nil) {
            self.basic = basic
        }

        public func validate(name: String) throws {
            try self.basic?.validate(name: "\(name).basic")
        }

        private enum CodingKeys: String, CodingKey {
            case basic = "basic"
        }
    }

    public struct OperandOne: AWSEncodableShape & AWSDecodableShape {
        /// The field ID that this operand should take the value of.
        public let fieldId: String?

        @inlinable
        public init(fieldId: String? = nil) {
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId = "fieldId"
        }
    }

    public struct Section: AWSEncodableShape & AWSDecodableShape {
        /// Consists of a group of fields and associated properties.
        public let fieldGroup: FieldGroup?

        @inlinable
        public init(fieldGroup: FieldGroup? = nil) {
            self.fieldGroup = fieldGroup
        }

        public func validate(name: String) throws {
            try self.fieldGroup?.validate(name: "\(name).fieldGroup")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldGroup = "fieldGroup"
        }
    }

    public struct UserUnion: AWSEncodableShape & AWSDecodableShape {
        /// Represents the Amazon Connect ARN of the user.
        public let userArn: String?

        @inlinable
        public init(userArn: String? = nil) {
            self.userArn = userArn
        }

        public func validate(name: String) throws {
            try self.validate(self.userArn, name: "userArn", parent: name, max: 500)
            try self.validate(self.userArn, name: "userArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case userArn = "userArn"
        }
    }
}

// MARK: - Errors

/// Error enum for ConnectCases
public struct ConnectCasesErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ConnectCases
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
    public static var conflictException: Self { .init(.conflictException) }
    /// We couldn't process your request because of an issue with the server. Try again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota has been exceeded. For a list of service quotas, see Amazon Connect Service Quotas in the Amazon Connect Administrator Guide.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The rate has been exceeded for this API. Please try again after a few minutes.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request isn't valid. Check the syntax and try again.
    public static var validationException: Self { .init(.validationException) }
}

extension ConnectCasesErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "InternalServerException": ConnectCases.InternalServerException.self,
        "ResourceNotFoundException": ConnectCases.ResourceNotFoundException.self
    ]
}

extension ConnectCasesErrorType: Equatable {
    public static func == (lhs: ConnectCasesErrorType, rhs: ConnectCasesErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ConnectCasesErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
