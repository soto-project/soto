//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension ConnectCases {
    // MARK: Enums

    public enum CommentBodyTextType: String, CustomStringConvertible, Codable, _SotoSendable {
        case textPlain = "Text/Plain"
        public var description: String { return self.rawValue }
    }

    public enum DomainStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "Active"
        case creationFailed = "CreationFailed"
        case creationInProgress = "CreationInProgress"
        public var description: String { return self.rawValue }
    }

    public enum FieldNamespace: String, CustomStringConvertible, Codable, _SotoSendable {
        case custom = "Custom"
        case system = "System"
        public var description: String { return self.rawValue }
    }

    public enum FieldType: String, CustomStringConvertible, Codable, _SotoSendable {
        case boolean = "Boolean"
        case dateTime = "DateTime"
        case number = "Number"
        case singleSelect = "SingleSelect"
        case text = "Text"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable, _SotoSendable {
        case asc = "Asc"
        case desc = "Desc"
        public var description: String { return self.rawValue }
    }

    public enum RelatedItemType: String, CustomStringConvertible, Codable, _SotoSendable {
        case comment = "Comment"
        case contact = "Contact"
        public var description: String { return self.rawValue }
    }

    public enum TemplateStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public indirect enum CaseFilter: AWSEncodableShape, _SotoSendable {
        /// Provides "and all" filtering.
        case andAll([CaseFilter])
        /// A list of fields to filter on.
        case field(FieldFilter)
        case not(CaseFilter)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andAll(let value):
                try container.encode(value, forKey: .andAll)
            case .field(let value):
                try container.encode(value, forKey: .field)
            case .not(let value):
                try container.encode(value, forKey: .not)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andAll[]")
                }
            case .field(let value):
                try value.validate(name: "\(name).field")
            case .not(let value):
                try value.validate(name: "\(name).not")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAll
            case field
            case not
        }
    }

    public enum FieldFilter: AWSEncodableShape, _SotoSendable {
        /// Object containing field identifier and value information.
        case contains(FieldValue)
        /// Object containing field identifier and value information.
        case equalTo(FieldValue)
        /// Object containing field identifier and value information.
        case greaterThan(FieldValue)
        /// Object containing field identifier and value information.
        case greaterThanOrEqualTo(FieldValue)
        /// Object containing field identifier and value information.
        case lessThan(FieldValue)
        /// Object containing field identifier and value information.
        case lessThanOrEqualTo(FieldValue)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .contains(let value):
                try container.encode(value, forKey: .contains)
            case .equalTo(let value):
                try container.encode(value, forKey: .equalTo)
            case .greaterThan(let value):
                try container.encode(value, forKey: .greaterThan)
            case .greaterThanOrEqualTo(let value):
                try container.encode(value, forKey: .greaterThanOrEqualTo)
            case .lessThan(let value):
                try container.encode(value, forKey: .lessThan)
            case .lessThanOrEqualTo(let value):
                try container.encode(value, forKey: .lessThanOrEqualTo)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .contains(let value):
                try value.validate(name: "\(name).contains")
            case .equalTo(let value):
                try value.validate(name: "\(name).equalTo")
            case .greaterThan(let value):
                try value.validate(name: "\(name).greaterThan")
            case .greaterThanOrEqualTo(let value):
                try value.validate(name: "\(name).greaterThanOrEqualTo")
            case .lessThan(let value):
                try value.validate(name: "\(name).lessThan")
            case .lessThanOrEqualTo(let value):
                try value.validate(name: "\(name).lessThanOrEqualTo")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contains
            case equalTo
            case greaterThan
            case greaterThanOrEqualTo
            case lessThan
            case lessThanOrEqualTo
        }
    }

    public enum FieldValueUnion: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        /// Can be either null, or have a Boolean value type. Only one value can be provided.
        case booleanValue(Bool)
        /// Can be either null, or have a Double number value type. Only one value can be provided.
        case doubleValue(Double)
        /// String value type.
        case stringValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .booleanValue:
                let value = try container.decode(Bool.self, forKey: .booleanValue)
                self = .booleanValue(value)
            case .doubleValue:
                let value = try container.decode(Double.self, forKey: .doubleValue)
                self = .doubleValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .booleanValue(let value):
                try container.encode(value, forKey: .booleanValue)
            case .doubleValue(let value):
                try container.encode(value, forKey: .doubleValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue
            case doubleValue
            case stringValue
        }
    }

    public enum RelatedItemContent: AWSDecodableShape, _SotoSendable {
        /// Represents the content of a comment to be returned to agents.
        case comment(CommentContent)
        /// Represents the content of a contact to be returned to agents.
        case contact(ContactContent)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .comment:
                let value = try container.decode(CommentContent.self, forKey: .comment)
                self = .comment(value)
            case .contact:
                let value = try container.decode(ContactContent.self, forKey: .contact)
                self = .contact(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comment
            case contact
        }
    }

    public enum RelatedItemInputContent: AWSEncodableShape, _SotoSendable {
        /// Represents the content of a comment to be returned to agents.
        case comment(CommentContent)
        /// Object representing a contact in Amazon Connect as an API request field.
        case contact(Contact)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .comment(let value):
                try container.encode(value, forKey: .comment)
            case .contact(let value):
                try container.encode(value, forKey: .contact)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .comment(let value):
                try value.validate(name: "\(name).comment")
            case .contact(let value):
                try value.validate(name: "\(name).contact")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comment
            case contact
        }
    }

    public enum RelatedItemTypeFilter: AWSEncodableShape, _SotoSendable {
        /// A filter for related items of type Comment.
        case comment(CommentFilter)
        /// A filter for related items of type Contact.
        case contact(ContactFilter)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .comment(let value):
                try container.encode(value, forKey: .comment)
            case .contact(let value):
                try container.encode(value, forKey: .contact)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .contact(let value):
                try value.validate(name: "\(name).contact")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case comment
            case contact
        }
    }

    // MARK: Shapes

    public struct BasicLayout: AWSEncodableShape & AWSDecodableShape {
        /// This represents sections in a tab of the page layout.
        public let moreInfo: LayoutSections?
        /// This represents sections in a panel of the page layout.
        public let topPanel: LayoutSections?

        public init(moreInfo: LayoutSections? = nil, topPanel: LayoutSections? = nil) {
            self.moreInfo = moreInfo
            self.topPanel = topPanel
        }

        public func validate(name: String) throws {
            try self.moreInfo?.validate(name: "\(name).moreInfo")
            try self.topPanel?.validate(name: "\(name).topPanel")
        }

        private enum CodingKeys: String, CodingKey {
            case moreInfo
            case topPanel
        }
    }

    public struct BatchGetFieldRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// A list of unique field identifiers.
        public let fields: [FieldIdentifier]

        public init(domainId: String, fields: [FieldIdentifier]) {
            self.domainId = domainId
            self.fields = fields
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.fields, name: "fields", parent: name, max: 50)
            try self.validate(self.fields, name: "fields", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fields
        }
    }

    public struct BatchGetFieldResponse: AWSDecodableShape {
        /// A list of field errors.
        public let errors: [FieldError]
        /// A list of detailed field information.
        public let fields: [GetFieldResponse]

        public init(errors: [FieldError], fields: [GetFieldResponse]) {
            self.errors = errors
            self.fields = fields
        }

        private enum CodingKeys: String, CodingKey {
            case errors
            case fields
        }
    }

    public struct BatchPutFieldOptionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId")),
            AWSMemberEncoding(label: "fieldId", location: .uri("fieldId"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// A list of FieldOption objects.
        public let options: [FieldOption]

        public init(domainId: String, fieldId: String, options: [FieldOption]) {
            self.domainId = domainId
            self.fieldId = fieldId
            self.options = options
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.options.forEach {
                try $0.validate(name: "\(name).options[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case options
        }
    }

    public struct BatchPutFieldOptionsResponse: AWSDecodableShape {
        /// A list of field errors.
        public let errors: [FieldOptionError]?

        public init(errors: [FieldOptionError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors
        }
    }

    public struct CaseEventIncludedData: AWSEncodableShape & AWSDecodableShape {
        /// List of field identifiers.
        public let fields: [FieldIdentifier]

        public init(fields: [FieldIdentifier]) {
            self.fields = fields
        }

        public func validate(name: String) throws {
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields
        }
    }

    public struct CaseSummary: AWSDecodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// A unique identifier of a template.
        public let templateId: String

        public init(caseId: String, templateId: String) {
            self.caseId = caseId
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case caseId
            case templateId
        }
    }

    public struct CommentContent: AWSEncodableShape & AWSDecodableShape {
        /// Text in the body of a Comment on a case.
        public let body: String
        /// Type of the text in the box of a Comment on a case.
        public let contentType: CommentBodyTextType

        public init(body: String, contentType: CommentBodyTextType) {
            self.body = body
            self.contentType = contentType
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 1000)
            try self.validate(self.body, name: "body", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case body
            case contentType
        }
    }

    public struct CommentFilter: AWSEncodableShape {
        public init() {}
    }

    public struct Contact: AWSEncodableShape {
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String

        public init(contactArn: String) {
            self.contactArn = contactArn
        }

        public func validate(name: String) throws {
            try self.validate(self.contactArn, name: "contactArn", parent: name, max: 500)
            try self.validate(self.contactArn, name: "contactArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn
        }
    }

    public struct ContactContent: AWSDecodableShape {
        /// A list of channels to filter on for related items of type Contact.
        public let channel: String
        /// The difference between the InitiationTimestamp and the DisconnectTimestamp of the contact.
        @CustomCoding<ISO8601DateCoder>
        public var connectedToSystemTime: Date
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String

        public init(channel: String, connectedToSystemTime: Date, contactArn: String) {
            self.channel = channel
            self.connectedToSystemTime = connectedToSystemTime
            self.contactArn = contactArn
        }

        private enum CodingKeys: String, CodingKey {
            case channel
            case connectedToSystemTime
            case contactArn
        }
    }

    public struct ContactFilter: AWSEncodableShape {
        /// A list of channels to filter on for related items of type Contact.
        public let channel: [String]?
        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String?

        public init(channel: [String]? = nil, contactArn: String? = nil) {
            self.channel = channel
            self.contactArn = contactArn
        }

        public func validate(name: String) throws {
            try self.channel?.forEach {
                try validate($0, name: "channel[]", parent: name, max: 100)
                try validate($0, name: "channel[]", parent: name, min: 1)
            }
            try self.validate(self.contactArn, name: "contactArn", parent: name, max: 500)
            try self.validate(self.contactArn, name: "contactArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channel
            case contactArn
        }
    }

    public struct CreateCaseRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// An array of objects with field ID (matching ListFields/DescribeField) and value union data.
        public let fields: [FieldValue]
        /// A unique identifier of a template.
        public let templateId: String

        public init(clientToken: String? = CreateCaseRequest.idempotencyToken(), domainId: String, fields: [FieldValue], templateId: String) {
            self.clientToken = clientToken
            self.domainId = domainId
            self.fields = fields
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case fields
            case templateId
        }
    }

    public struct CreateCaseResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the case.
        public let caseArn: String
        /// A unique identifier of the case.
        public let caseId: String

        public init(caseArn: String, caseId: String) {
            self.caseArn = caseArn
            self.caseId = caseId
        }

        private enum CodingKeys: String, CodingKey {
            case caseArn
            case caseId
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        /// The name for your Cases domain. It must be unique for your Amazon Web Services account.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct CreateDomainResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the Cases domain.
        public let domainArn: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The status of the domain.
        public let domainStatus: DomainStatus

        public init(domainArn: String, domainId: String, domainStatus: DomainStatus) {
            self.domainArn = domainArn
            self.domainId = domainId
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn
            case domainId
            case domainStatus
        }
    }

    public struct CreateFieldRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// The description of the field.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The name of the field.
        public let name: String
        /// Defines the data type, some system constraints, and default display of the field.
        public let type: FieldType

        public init(description: String? = nil, domainId: String, name: String, type: FieldType) {
            self.description = description
            self.domainId = domainId
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case type
        }
    }

    public struct CreateFieldResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the field.
        public let fieldArn: String
        /// The unique identifier of a field.
        public let fieldId: String

        public init(fieldArn: String, fieldId: String) {
            self.fieldArn = fieldArn
            self.fieldId = fieldId
        }

        private enum CodingKeys: String, CodingKey {
            case fieldArn
            case fieldId
        }
    }

    public struct CreateLayoutRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// Information about which fields will be present in the layout, and information about the order of the fields.
        public let content: LayoutContent
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The name of the layout. It must be unique for the Cases domain.
        public let name: String

        public init(content: LayoutContent, domainId: String, name: String) {
            self.content = content
            self.domainId = domainId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.content.validate(name: "\(name).content")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case name
        }
    }

    public struct CreateLayoutResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created layout.
        public let layoutArn: String
        /// The unique identifier of the layout.
        public let layoutId: String

        public init(layoutArn: String, layoutId: String) {
            self.layoutArn = layoutArn
            self.layoutId = layoutId
        }

        private enum CodingKeys: String, CodingKey {
            case layoutArn
            case layoutId
        }
    }

    public struct CreateRelatedItemRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "caseId", location: .uri("caseId")),
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// A unique identifier of the case.
        public let caseId: String
        /// The content of a related item to be created.
        public let content: RelatedItemInputContent
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The type of a related item.
        public let type: RelatedItemType

        public init(caseId: String, content: RelatedItemInputContent, domainId: String, type: RelatedItemType) {
            self.caseId = caseId
            self.content = content
            self.domainId = domainId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.content.validate(name: "\(name).content")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case type
        }
    }

    public struct CreateRelatedItemResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the related item.
        public let relatedItemArn: String
        /// The unique identifier of the related item.
        public let relatedItemId: String

        public init(relatedItemArn: String, relatedItemId: String) {
            self.relatedItemArn = relatedItemArn
            self.relatedItemId = relatedItemId
        }

        private enum CodingKeys: String, CodingKey {
            case relatedItemArn
            case relatedItemId
        }
    }

    public struct CreateTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// A brief description of the template.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Configuration of layouts associated to the template.
        public let layoutConfiguration: LayoutConfiguration?
        /// A name for the template. It must be unique per domain.
        public let name: String
        /// A list of fields that must contain a value for a case to be successfully created with this template.
        public let requiredFields: [RequiredField]?
        /// The status of the template.
        public let status: TemplateStatus?

        public init(description: String? = nil, domainId: String, layoutConfiguration: LayoutConfiguration? = nil, name: String, requiredFields: [RequiredField]? = nil, status: TemplateStatus? = nil) {
            self.description = description
            self.domainId = domainId
            self.layoutConfiguration = layoutConfiguration
            self.name = name
            self.requiredFields = requiredFields
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.layoutConfiguration?.validate(name: "\(name).layoutConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.requiredFields?.forEach {
                try $0.validate(name: "\(name).requiredFields[]")
            }
            try self.validate(self.requiredFields, name: "requiredFields", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case layoutConfiguration
            case name
            case requiredFields
            case status
        }
    }

    public struct CreateTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the newly created template.
        public let templateArn: String
        /// A unique identifier of a template.
        public let templateId: String

        public init(templateArn: String, templateId: String) {
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case templateArn
            case templateId
        }
    }

    public struct DomainSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the domain.
        public let domainArn: String
        /// The unique identifier of the domain.
        public let domainId: String
        /// The name of the domain.
        public let name: String

        public init(domainArn: String, domainId: String, name: String) {
            self.domainArn = domainArn
            self.domainId = domainId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn
            case domainId
            case name
        }
    }

    public struct EventBridgeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the to broadcast case event data to the customer.
        public let enabled: Bool
        /// Details of what case and related item data is published through the case event stream.
        public let includedData: EventIncludedData?

        public init(enabled: Bool, includedData: EventIncludedData? = nil) {
            self.enabled = enabled
            self.includedData = includedData
        }

        public func validate(name: String) throws {
            try self.includedData?.validate(name: "\(name).includedData")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
            case includedData
        }
    }

    public struct EventIncludedData: AWSEncodableShape & AWSDecodableShape {
        /// Details of what case data is published through the case event stream.
        public let caseData: CaseEventIncludedData?
        /// Details of what related item data is published through the case event stream.
        public let relatedItemData: RelatedItemEventIncludedData?

        public init(caseData: CaseEventIncludedData? = nil, relatedItemData: RelatedItemEventIncludedData? = nil) {
            self.caseData = caseData
            self.relatedItemData = relatedItemData
        }

        public func validate(name: String) throws {
            try self.caseData?.validate(name: "\(name).caseData")
        }

        private enum CodingKeys: String, CodingKey {
            case caseData
            case relatedItemData
        }
    }

    public struct FieldError: AWSDecodableShape {
        /// The error code from getting a field.
        public let errorCode: String
        /// The field identifier that caused the error.
        public let id: String
        /// The error message from getting a field.
        public let message: String?

        public init(errorCode: String, id: String, message: String? = nil) {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case id
            case message
        }
    }

    public struct FieldGroup: AWSEncodableShape & AWSDecodableShape {
        /// Represents an ordered list containing field related information.
        public let fields: [FieldItem]
        /// Name of the field group.
        public let name: String?

        public init(fields: [FieldItem], name: String? = nil) {
            self.fields = fields
            self.name = name
        }

        public func validate(name: String) throws {
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields
            case name
        }
    }

    public struct FieldIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct FieldItem: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct FieldOption: AWSEncodableShape & AWSDecodableShape {
        /// Describes whether the FieldOption is active (displayed) or inactive.
        public let active: Bool
        ///  FieldOptionName has max length 100 and disallows trailing spaces.
        public let name: String
        ///  FieldOptionValue has max length 100 and must be alphanumeric with hyphens and underscores.
        public let value: String

        public init(active: Bool, name: String, value: String) {
            self.active = active
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.validate(self.value, name: "value", parent: name, max: 100)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case active
            case name
            case value
        }
    }

    public struct FieldOptionError: AWSDecodableShape {
        /// Error code from creating or updating field option.
        public let errorCode: String
        /// Error message from creating or updating field option.
        public let message: String
        /// The field option value that caused the error.
        public let value: String

        public init(errorCode: String, message: String, value: String) {
            self.errorCode = errorCode
            self.message = message
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case message
            case value
        }
    }

    public struct FieldSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the field.
        public let fieldArn: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// Name of the field.
        public let name: String
        /// The namespace of a field.
        public let namespace: FieldNamespace
        /// The type of a field.
        public let type: FieldType

        public init(fieldArn: String, fieldId: String, name: String, namespace: FieldNamespace, type: FieldType) {
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.name = name
            self.namespace = namespace
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case fieldArn
            case fieldId
            case name
            case namespace
            case type
        }
    }

    public struct FieldValue: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let id: String
        /// Union of potential field value types.
        public let value: FieldValueUnion

        public init(id: String, value: FieldValueUnion) {
            self.id = id
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case value
        }
    }

    public struct GetCaseEventConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String

        public init(domainId: String) {
            self.domainId = domainId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCaseEventConfigurationResponse: AWSDecodableShape {
        /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
        public let eventBridge: EventBridgeConfiguration

        public init(eventBridge: EventBridgeConfiguration) {
            self.eventBridge = eventBridge
        }

        private enum CodingKeys: String, CodingKey {
            case eventBridge
        }
    }

    public struct GetCaseRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "caseId", location: .uri("caseId")),
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// A list of unique field identifiers.
        public let fields: [FieldIdentifier]
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(caseId: String, domainId: String, fields: [FieldIdentifier], nextToken: String? = nil) {
            self.caseId = caseId
            self.domainId = domainId
            self.fields = fields
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case fields
            case nextToken
        }
    }

    public struct GetCaseResponse: AWSDecodableShape {
        /// A list of detailed field information.
        public let fields: [FieldValue]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier of a template.
        public let templateId: String

        public init(fields: [FieldValue], nextToken: String? = nil, tags: [String: String]? = nil, templateId: String) {
            self.fields = fields
            self.nextToken = nextToken
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case fields
            case nextToken
            case tags
            case templateId
        }
    }

    public struct GetDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String

        public init(domainId: String) {
            self.domainId = domainId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainResponse: AWSDecodableShape {
        /// The timestamp when the Cases domain was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdTime: Date
        /// The Amazon Resource Name (ARN) for the Cases domain.
        public let domainArn: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The status of the Cases domain.
        public let domainStatus: DomainStatus
        /// The name of the Cases domain.
        public let name: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(createdTime: Date, domainArn: String, domainId: String, domainStatus: DomainStatus, name: String, tags: [String: String]? = nil) {
            self.createdTime = createdTime
            self.domainArn = domainArn
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime
            case domainArn
            case domainId
            case domainStatus
            case name
            case tags
        }
    }

    public struct GetFieldResponse: AWSDecodableShape {
        /// Description of the field.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the field.
        public let fieldArn: String
        /// Unique identifier of the field.
        public let fieldId: String
        /// Name of the field.
        public let name: String
        /// Namespace of the field.
        public let namespace: FieldNamespace
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Type of the field.
        public let type: FieldType

        public init(description: String? = nil, fieldArn: String, fieldId: String, name: String, namespace: FieldNamespace, tags: [String: String]? = nil, type: FieldType) {
            self.description = description
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.name = name
            self.namespace = namespace
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case fieldArn
            case fieldId
            case name
            case namespace
            case tags
            case type
        }
    }

    public struct GetLayoutRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId")),
            AWSMemberEncoding(label: "layoutId", location: .uri("layoutId"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of the layout.
        public let layoutId: String

        public init(domainId: String, layoutId: String) {
            self.domainId = domainId
            self.layoutId = layoutId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.layoutId, name: "layoutId", parent: name, max: 500)
            try self.validate(self.layoutId, name: "layoutId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLayoutResponse: AWSDecodableShape {
        /// Information about which fields will be present in the layout, the order of the fields, and read-only attribute of the field.
        public let content: LayoutContent
        /// The Amazon Resource Name (ARN) of the newly created layout.
        public let layoutArn: String
        /// The unique identifier of the layout.
        public let layoutId: String
        /// The name of the layout. It must be unique.
        public let name: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(content: LayoutContent, layoutArn: String, layoutId: String, name: String, tags: [String: String]? = nil) {
            self.content = content
            self.layoutArn = layoutArn
            self.layoutId = layoutId
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case layoutArn
            case layoutId
            case name
            case tags
        }
    }

    public struct GetTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId")),
            AWSMemberEncoding(label: "templateId", location: .uri("templateId"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// A unique identifier of a template.
        public let templateId: String

        public init(domainId: String, templateId: String) {
            self.domainId = domainId
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTemplateResponse: AWSDecodableShape {
        /// A brief description of the template.
        public let description: String?
        /// Configuration of layouts associated to the template.
        public let layoutConfiguration: LayoutConfiguration?
        /// The name of the template.
        public let name: String
        /// A list of fields that must contain a value for a case to be successfully created with this template.
        public let requiredFields: [RequiredField]?
        /// The status of the template.
        public let status: TemplateStatus
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String
        /// A unique identifier of a template.
        public let templateId: String

        public init(description: String? = nil, layoutConfiguration: LayoutConfiguration? = nil, name: String, requiredFields: [RequiredField]? = nil, status: TemplateStatus, tags: [String: String]? = nil, templateArn: String, templateId: String) {
            self.description = description
            self.layoutConfiguration = layoutConfiguration
            self.name = name
            self.requiredFields = requiredFields
            self.status = status
            self.tags = tags
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case layoutConfiguration
            case name
            case requiredFields
            case status
            case tags
            case templateArn
            case templateId
        }
    }

    public struct LayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  Unique identifier of a layout.
        public let defaultLayout: String?

        public init(defaultLayout: String? = nil) {
            self.defaultLayout = defaultLayout
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultLayout, name: "defaultLayout", parent: name, max: 500)
            try self.validate(self.defaultLayout, name: "defaultLayout", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultLayout
        }
    }

    public struct LayoutSections: AWSEncodableShape & AWSDecodableShape {
        public let sections: [Section]?

        public init(sections: [Section]? = nil) {
            self.sections = sections
        }

        public func validate(name: String) throws {
            try self.sections?.forEach {
                try $0.validate(name: "\(name).sections[]")
            }
            try self.validate(self.sections, name: "sections", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case sections
        }
    }

    public struct LayoutSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the layout.
        public let layoutArn: String
        /// The unique identifier for of the layout.
        public let layoutId: String
        /// The name of the layout.
        public let name: String

        public init(layoutArn: String, layoutId: String, name: String) {
            self.layoutArn = layoutArn
            self.layoutId = layoutId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case layoutArn
            case layoutId
            case name
        }
    }

    public struct ListCasesForContactRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// A unique identifier of a contact in Amazon Connect.
        public let contactArn: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(contactArn: String, domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contactArn = contactArn
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.contactArn, name: "contactArn", parent: name, max: 500)
            try self.validate(self.contactArn, name: "contactArn", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn
            case maxResults
            case nextToken
        }
    }

    public struct ListCasesForContactResponse: AWSDecodableShape {
        /// A list of Case summary information.
        public let cases: [CaseSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(cases: [CaseSummary], nextToken: String? = nil) {
            self.cases = cases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cases
            case nextToken
        }
    }

    public struct ListDomainsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainsResponse: AWSDecodableShape {
        /// The Cases domain.
        public let domains: [DomainSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(domains: [DomainSummary], nextToken: String? = nil) {
            self.domains = domains
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domains
            case nextToken
        }
    }

    public struct ListFieldOptionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId")),
            AWSMemberEncoding(label: "fieldId", location: .uri("fieldId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "values", location: .querystring("values"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A list of FieldOption values to filter on for ListFieldOptions.
        public let values: [String]?

        public init(domainId: String, fieldId: String, maxResults: Int? = nil, nextToken: String? = nil, values: [String]? = nil) {
            self.domainId = domainId
            self.fieldId = fieldId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
            }
            try self.validate(self.values, name: "values", parent: name, max: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFieldOptionsResponse: AWSDecodableShape {
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// A list of FieldOption objects.
        public let options: [FieldOption]

        public init(nextToken: String? = nil, options: [FieldOption]) {
            self.nextToken = nextToken
            self.options = options
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case options
        }
    }

    public struct ListFieldsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFieldsResponse: AWSDecodableShape {
        /// List of detailed field information.
        public let fields: [FieldSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(fields: [FieldSummary], nextToken: String? = nil) {
            self.fields = fields
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fields
            case nextToken
        }
    }

    public struct ListLayoutsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(domainId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLayoutsResponse: AWSDecodableShape {
        /// The layouts for the domain.
        public let layouts: [LayoutSummary]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(layouts: [LayoutSummary], nextToken: String? = nil) {
            self.layouts = layouts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case layouts
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("arn"))
        ]

        /// The Amazon Resource Name (ARN)
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListTemplatesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "status", location: .querystring("status"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A list of status values to filter on.
        public let status: [TemplateStatus]?

        public init(domainId: String, maxResults: Int? = nil, nextToken: String? = nil, status: [TemplateStatus]? = nil) {
            self.domainId = domainId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
            try self.validate(self.status, name: "status", parent: name, max: 2)
            try self.validate(self.status, name: "status", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTemplatesResponse: AWSDecodableShape {
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// List of template summary objects.
        public let templates: [TemplateSummary]

        public init(nextToken: String? = nil, templates: [TemplateSummary]) {
            self.nextToken = nextToken
            self.templates = templates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case templates
        }
    }

    public struct PutCaseEventConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
        public let eventBridge: EventBridgeConfiguration

        public init(domainId: String, eventBridge: EventBridgeConfiguration) {
            self.domainId = domainId
            self.eventBridge = eventBridge
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.eventBridge.validate(name: "\(name).eventBridge")
        }

        private enum CodingKeys: String, CodingKey {
            case eventBridge
        }
    }

    public struct PutCaseEventConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RelatedItemEventIncludedData: AWSEncodableShape & AWSDecodableShape {
        /// Details of what related item data is published through the case event stream.
        public let includeContent: Bool

        public init(includeContent: Bool) {
            self.includeContent = includeContent
        }

        private enum CodingKeys: String, CodingKey {
            case includeContent
        }
    }

    public struct RequiredField: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let fieldId: String

        public init(fieldId: String) {
            self.fieldId = fieldId
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId
        }
    }

    public struct SearchCasesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The list of field identifiers to be returned as part of the response.
        public let fields: [FieldIdentifier]?
        /// A list of filter objects.
        public let filter: CaseFilter?
        /// The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A word or phrase used to perform a quick search.
        public let searchTerm: String?
        /// A list of sorts where each sort specifies a field and their sort order to be applied to the results.
        public let sorts: [Sort]?

        public init(domainId: String, fields: [FieldIdentifier]? = nil, filter: CaseFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, searchTerm: String? = nil, sorts: [Sort]? = nil) {
            self.domainId = domainId
            self.fields = fields
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchTerm = searchTerm
            self.sorts = sorts
        }

        public func validate(name: String) throws {
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields?.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
            try self.sorts?.forEach {
                try $0.validate(name: "\(name).sorts[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields
            case filter
            case maxResults
            case nextToken
            case searchTerm
            case sorts
        }
    }

    public struct SearchCasesResponse: AWSDecodableShape {
        /// A list of case documents where each case contains the properties CaseId and Fields where each field is a complex union structure.
        public let cases: [SearchCasesResponseItem]
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?

        public init(cases: [SearchCasesResponseItem], nextToken: String? = nil) {
            self.cases = cases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cases
            case nextToken
        }
    }

    public struct SearchCasesResponseItem: AWSDecodableShape {
        /// A unique identifier of the case.
        public let caseId: String
        /// List of case field values.
        public let fields: [FieldValue]
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier of a template.
        public let templateId: String

        public init(caseId: String, fields: [FieldValue], tags: [String: String]? = nil, templateId: String) {
            self.caseId = caseId
            self.fields = fields
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case caseId
            case fields
            case tags
            case templateId
        }
    }

    public struct SearchRelatedItemsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "caseId", location: .uri("caseId")),
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The list of types of related items and their parameters to use for filtering.
        public let filters: [RelatedItemTypeFilter]?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(caseId: String, domainId: String, filters: [RelatedItemTypeFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.caseId = caseId
            self.domainId = domainId
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 9000)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct SearchRelatedItemsResponse: AWSDecodableShape {
        /// The token for the next set of results. This is null if there are no more results to return.
        public let nextToken: String?
        /// A list of items related to a case.
        public let relatedItems: [SearchRelatedItemsResponseItem]

        public init(nextToken: String? = nil, relatedItems: [SearchRelatedItemsResponseItem]) {
            self.nextToken = nextToken
            self.relatedItems = relatedItems
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case relatedItems
        }
    }

    public struct SearchRelatedItemsResponseItem: AWSDecodableShape {
        /// Time at which a related item was associated with a case.
        @CustomCoding<ISO8601DateCoder>
        public var associationTime: Date
        /// Represents the content of a particular type of related item.
        public let content: RelatedItemContent
        /// Unique identifier of a related item.
        public let relatedItemId: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// Type of a related item.
        public let type: RelatedItemType

        public init(associationTime: Date, content: RelatedItemContent, relatedItemId: String, tags: [String: String]? = nil, type: RelatedItemType) {
            self.associationTime = associationTime
            self.content = content
            self.relatedItemId = relatedItemId
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case associationTime
            case content
            case relatedItemId
            case tags
            case type
        }
    }

    public struct Sort: AWSEncodableShape {
        /// Unique identifier of a field.
        public let fieldId: String
        /// A structured set of sort terms
        public let sortOrder: Order

        public init(fieldId: String, sortOrder: Order) {
            self.fieldId = fieldId
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fieldId
            case sortOrder
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("arn"))
        ]

        /// The Amazon Resource Name (ARN)
        public let arn: String
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(arn: String, tags: [String: String]) {
            self.arn = arn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TemplateSummary: AWSDecodableShape {
        /// The template name.
        public let name: String
        /// The status of the template.
        public let status: TemplateStatus
        /// The Amazon Resource Name (ARN) of the template.
        public let templateArn: String
        /// The unique identifier for the template.
        public let templateId: String

        public init(name: String, status: TemplateStatus, templateArn: String, templateId: String) {
            self.name = name
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case status
            case templateArn
            case templateId
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("arn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN)
        public let arn: String
        /// List of tag keys.
        public let tagKeys: [String]

        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 500)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateCaseRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "caseId", location: .uri("caseId")),
            AWSMemberEncoding(label: "domainId", location: .uri("domainId"))
        ]

        /// A unique identifier of the case.
        public let caseId: String
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// An array of objects with fieldId (matching ListFields/DescribeField) and value union data, structured identical to CreateCase.
        public let fields: [FieldValue]

        public init(caseId: String, domainId: String, fields: [FieldValue]) {
            self.caseId = caseId
            self.domainId = domainId
            self.fields = fields
        }

        public func validate(name: String) throws {
            try self.validate(self.caseId, name: "caseId", parent: name, max: 500)
            try self.validate(self.caseId, name: "caseId", parent: name, min: 1)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields
        }
    }

    public struct UpdateCaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFieldRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId")),
            AWSMemberEncoding(label: "fieldId", location: .uri("fieldId"))
        ]

        /// The description of a field.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of a field.
        public let fieldId: String
        /// The name of the field.
        public let name: String?

        public init(description: String? = nil, domainId: String, fieldId: String, name: String? = nil) {
            self.description = description
            self.domainId = domainId
            self.fieldId = fieldId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.fieldId, name: "fieldId", parent: name, max: 500)
            try self.validate(self.fieldId, name: "fieldId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
        }
    }

    public struct UpdateFieldResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLayoutRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId")),
            AWSMemberEncoding(label: "layoutId", location: .uri("layoutId"))
        ]

        /// Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field.
        public let content: LayoutContent?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// The unique identifier of the layout.
        public let layoutId: String
        /// The name of the layout. It must be unique per domain.
        public let name: String?

        public init(content: LayoutContent? = nil, domainId: String, layoutId: String, name: String? = nil) {
            self.content = content
            self.domainId = domainId
            self.layoutId = layoutId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.content?.validate(name: "\(name).content")
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.validate(self.layoutId, name: "layoutId", parent: name, max: 500)
            try self.validate(self.layoutId, name: "layoutId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case name
        }
    }

    public struct UpdateLayoutResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainId", location: .uri("domainId")),
            AWSMemberEncoding(label: "templateId", location: .uri("templateId"))
        ]

        /// A brief description of the template.
        public let description: String?
        /// The unique identifier of the Cases domain.
        public let domainId: String
        /// Configuration of layouts associated to the template.
        public let layoutConfiguration: LayoutConfiguration?
        /// The name of the template. It must be unique per domain.
        public let name: String?
        /// A list of fields that must contain a value for a case to be successfully created with this template.
        public let requiredFields: [RequiredField]?
        /// The status of the template.
        public let status: TemplateStatus?
        /// A unique identifier for the template.
        public let templateId: String

        public init(description: String? = nil, domainId: String, layoutConfiguration: LayoutConfiguration? = nil, name: String? = nil, requiredFields: [RequiredField]? = nil, status: TemplateStatus? = nil, templateId: String) {
            self.description = description
            self.domainId = domainId
            self.layoutConfiguration = layoutConfiguration
            self.name = name
            self.requiredFields = requiredFields
            self.status = status
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.domainId, name: "domainId", parent: name, max: 500)
            try self.validate(self.domainId, name: "domainId", parent: name, min: 1)
            try self.layoutConfiguration?.validate(name: "\(name).layoutConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^.*[\\S]$")
            try self.requiredFields?.forEach {
                try $0.validate(name: "\(name).requiredFields[]")
            }
            try self.validate(self.requiredFields, name: "requiredFields", parent: name, max: 100)
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case layoutConfiguration
            case name
            case requiredFields
            case status
        }
    }

    public struct UpdateTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct LayoutContent: AWSEncodableShape & AWSDecodableShape {
        /// Content specific to BasicLayout type. It configures fields in the top panel and More Info tab of Cases user interface.
        public let basic: BasicLayout?

        public init(basic: BasicLayout? = nil) {
            self.basic = basic
        }

        public func validate(name: String) throws {
            try self.basic?.validate(name: "\(name).basic")
        }

        private enum CodingKeys: String, CodingKey {
            case basic
        }
    }

    public struct Section: AWSEncodableShape & AWSDecodableShape {
        /// Consists of a group of fields and associated properties.
        public let fieldGroup: FieldGroup?

        public init(fieldGroup: FieldGroup? = nil) {
            self.fieldGroup = fieldGroup
        }

        public func validate(name: String) throws {
            try self.fieldGroup?.validate(name: "\(name).fieldGroup")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldGroup
        }
    }
}

// MARK: - Errors

/// Error enum for ConnectCases
public struct ConnectCasesErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ConnectCases
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
    public static var conflictException: Self { .init(.conflictException) }
    /// We couldn&#39;t process your request because of an issue with the server. Try again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// We couldn&#39;t find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota has been exceeded. For a list of service quotas, see Amazon Connect Service Quotas in the Amazon Connect Administrator Guide.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The rate has been exceeded for this API. Please try again after a few minutes.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request isn&#39;t valid. Check the syntax and try again.
    public static var validationException: Self { .init(.validationException) }
}

extension ConnectCasesErrorType: Equatable {
    public static func == (lhs: ConnectCasesErrorType, rhs: ConnectCasesErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ConnectCasesErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
