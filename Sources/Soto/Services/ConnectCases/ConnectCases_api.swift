//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS ConnectCases service.
///
///    Cases actions     Cases data types    With Amazon Connect Cases, your agents can track and manage customer issues that require multiple interactions, follow-up tasks, and teams in your contact center. A case represents a customer issue. It records the issue, the steps and interactions taken to resolve the issue, and the outcome. For more information, see Amazon Connect Cases in the Amazon Connect Administrator Guide.
public struct ConnectCases: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the ConnectCases client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "ConnectCases",
            serviceIdentifier: "cases",
            serviceProtocol: .restjson,
            apiVersion: "2022-10-03",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: ConnectCasesErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-east-1": "cases-fips.us-east-1.amazonaws.com",
            "us-west-2": "cases-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Gets a batch of case rules. In the Amazon Connect admin website, case rules are known as case field conditions.  For more information about case field conditions, see Add case field conditions to a case template.
    @Sendable
    @inlinable
    public func batchGetCaseRule(_ input: BatchGetCaseRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetCaseRuleResponse {
        try await self.client.execute(
            operation: "BatchGetCaseRule", 
            path: "/domains/{domainId}/rules-batch", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a batch of case rules. In the Amazon Connect admin website, case rules are known as case field conditions.  For more information about case field conditions, see Add case field conditions to a case template.
    ///
    /// Parameters:
    ///   - caseRules: List of case rule identifiers.
    ///   - domainId: Unique identifier of a Cases domain.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetCaseRule(
        caseRules: [CaseRuleIdentifier],
        domainId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetCaseRuleResponse {
        let input = BatchGetCaseRuleRequest(
            caseRules: caseRules, 
            domainId: domainId
        )
        return try await self.batchGetCaseRule(input, logger: logger)
    }

    /// Returns the description for the list of fields in the request parameters.
    @Sendable
    @inlinable
    public func batchGetField(_ input: BatchGetFieldRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetFieldResponse {
        try await self.client.execute(
            operation: "BatchGetField", 
            path: "/domains/{domainId}/fields-batch", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the description for the list of fields in the request parameters.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fields: A list of unique field identifiers.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetField(
        domainId: String,
        fields: [FieldIdentifier],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetFieldResponse {
        let input = BatchGetFieldRequest(
            domainId: domainId, 
            fields: fields
        )
        return try await self.batchGetField(input, logger: logger)
    }

    /// Creates and updates a set of field options for a single select field in a Cases domain.
    @Sendable
    @inlinable
    public func batchPutFieldOptions(_ input: BatchPutFieldOptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchPutFieldOptionsResponse {
        try await self.client.execute(
            operation: "BatchPutFieldOptions", 
            path: "/domains/{domainId}/fields/{fieldId}/options", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates and updates a set of field options for a single select field in a Cases domain.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fieldId: The unique identifier of a field.
    ///   - options: A list of FieldOption objects.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchPutFieldOptions(
        domainId: String,
        fieldId: String,
        options: [FieldOption],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchPutFieldOptionsResponse {
        let input = BatchPutFieldOptionsRequest(
            domainId: domainId, 
            fieldId: fieldId, 
            options: options
        )
        return try await self.batchPutFieldOptions(input, logger: logger)
    }

    ///  If you provide a value for PerformedBy.UserArn you must also have connect:DescribeUser permission on the User ARN resource that you provide  Creates a case in the specified Cases domain. Case system and custom fields are taken as an array id/value pairs with a declared data types. The following fields are required when creating a case:     customer_id - You must provide the full customer profile ARN in this format: arn:aws:profile:your_AWS_Region:your_AWS_account ID:domains/your_profiles_domain_name/profiles/profile_ID     title
    @Sendable
    @inlinable
    public func createCase(_ input: CreateCaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCaseResponse {
        try await self.client.execute(
            operation: "CreateCase", 
            path: "/domains/{domainId}/cases", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  If you provide a value for PerformedBy.UserArn you must also have connect:DescribeUser permission on the User ARN resource that you provide  Creates a case in the specified Cases domain. Case system and custom fields are taken as an array id/value pairs with a declared data types. The following fields are required when creating a case:     customer_id - You must provide the full customer profile ARN in this format: arn:aws:profile:your_AWS_Region:your_AWS_account ID:domains/your_profiles_domain_name/profiles/profile_ID     title
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fields: An array of objects with field ID (matching ListFields/DescribeField) and value union data.
    ///   - performedBy: 
    ///   - templateId: A unique identifier of a template.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCase(
        clientToken: String? = CreateCaseRequest.idempotencyToken(),
        domainId: String,
        fields: [FieldValue],
        performedBy: UserUnion? = nil,
        templateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCaseResponse {
        let input = CreateCaseRequest(
            clientToken: clientToken, 
            domainId: domainId, 
            fields: fields, 
            performedBy: performedBy, 
            templateId: templateId
        )
        return try await self.createCase(input, logger: logger)
    }

    /// Creates a new case rule. In the Amazon Connect admin website, case rules are known as case field conditions.  For more information about case field conditions, see Add case field conditions to a case template.
    @Sendable
    @inlinable
    public func createCaseRule(_ input: CreateCaseRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCaseRuleResponse {
        try await self.client.execute(
            operation: "CreateCaseRule", 
            path: "/domains/{domainId}/case-rules", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new case rule. In the Amazon Connect admin website, case rules are known as case field conditions.  For more information about case field conditions, see Add case field conditions to a case template.
    ///
    /// Parameters:
    ///   - description: The description of a case rule.
    ///   - domainId: Unique identifier of a Cases domain.
    ///   - name: Name of the case rule.
    ///   - rule: Represents what rule type should take place, under what conditions.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCaseRule(
        description: String? = nil,
        domainId: String,
        name: String,
        rule: CaseRuleDetails,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCaseRuleResponse {
        let input = CreateCaseRuleRequest(
            description: description, 
            domainId: domainId, 
            name: name, 
            rule: rule
        )
        return try await self.createCaseRule(input, logger: logger)
    }

    /// Creates a domain, which is a container for all case data, such as cases, fields, templates and layouts. Each Amazon Connect instance can be associated with only one Cases domain.  This will not associate your connect instance to Cases domain. Instead, use the Amazon Connect CreateIntegrationAssociation API. You need specific IAM permissions to successfully associate the Cases domain. For more information, see Onboard to Cases.
    @Sendable
    @inlinable
    public func createDomain(_ input: CreateDomainRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDomainResponse {
        try await self.client.execute(
            operation: "CreateDomain", 
            path: "/domains", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a domain, which is a container for all case data, such as cases, fields, templates and layouts. Each Amazon Connect instance can be associated with only one Cases domain.  This will not associate your connect instance to Cases domain. Instead, use the Amazon Connect CreateIntegrationAssociation API. You need specific IAM permissions to successfully associate the Cases domain. For more information, see Onboard to Cases.
    ///
    /// Parameters:
    ///   - name: The name for your Cases domain. It must be unique for your Amazon Web Services account.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDomain(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDomainResponse {
        let input = CreateDomainRequest(
            name: name
        )
        return try await self.createDomain(input, logger: logger)
    }

    /// Creates a field in the Cases domain. This field is used to define the case object model (that is, defines what data can be captured on cases) in a Cases domain.
    @Sendable
    @inlinable
    public func createField(_ input: CreateFieldRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFieldResponse {
        try await self.client.execute(
            operation: "CreateField", 
            path: "/domains/{domainId}/fields", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a field in the Cases domain. This field is used to define the case object model (that is, defines what data can be captured on cases) in a Cases domain.
    ///
    /// Parameters:
    ///   - description: The description of the field.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - name: The name of the field.
    ///   - type: Defines the data type, some system constraints, and default display of the field.
    ///   - logger: Logger use during operation
    @inlinable
    public func createField(
        description: String? = nil,
        domainId: String,
        name: String,
        type: FieldType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFieldResponse {
        let input = CreateFieldRequest(
            description: description, 
            domainId: domainId, 
            name: name, 
            type: type
        )
        return try await self.createField(input, logger: logger)
    }

    /// Creates a layout in the Cases domain. Layouts define the following configuration in the top section and More Info tab of the Cases user interface:   Fields to display to the users   Field ordering    Title and Status fields cannot be part of layouts since they are not configurable.
    @Sendable
    @inlinable
    public func createLayout(_ input: CreateLayoutRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLayoutResponse {
        try await self.client.execute(
            operation: "CreateLayout", 
            path: "/domains/{domainId}/layouts", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a layout in the Cases domain. Layouts define the following configuration in the top section and More Info tab of the Cases user interface:   Fields to display to the users   Field ordering    Title and Status fields cannot be part of layouts since they are not configurable.
    ///
    /// Parameters:
    ///   - content: Information about which fields will be present in the layout, and information about the order of the fields.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - name: The name of the layout. It must be unique for the Cases domain.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLayout(
        content: LayoutContent,
        domainId: String,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLayoutResponse {
        let input = CreateLayoutRequest(
            content: content, 
            domainId: domainId, 
            name: name
        )
        return try await self.createLayout(input, logger: logger)
    }

    /// Creates a related item (comments, tasks, and contacts) and associates it with a case.    A Related Item is a resource that is associated with a case. It may or may not have an external identifier linking it to an external resource (for example, a contactArn). All Related Items have their own internal identifier, the relatedItemArn. Examples of related items include comments and contacts.   If you provide a value for performedBy.userArn you must also have DescribeUser permission on the ARN of the user that you provide.   The type field is reserved for internal use only.
    @Sendable
    @inlinable
    public func createRelatedItem(_ input: CreateRelatedItemRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRelatedItemResponse {
        try await self.client.execute(
            operation: "CreateRelatedItem", 
            path: "/domains/{domainId}/cases/{caseId}/related-items/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a related item (comments, tasks, and contacts) and associates it with a case.    A Related Item is a resource that is associated with a case. It may or may not have an external identifier linking it to an external resource (for example, a contactArn). All Related Items have their own internal identifier, the relatedItemArn. Examples of related items include comments and contacts.   If you provide a value for performedBy.userArn you must also have DescribeUser permission on the ARN of the user that you provide.   The type field is reserved for internal use only.
    ///
    /// Parameters:
    ///   - caseId: A unique identifier of the case.
    ///   - content: The content of a related item to be created.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - performedBy: Represents the creator of the related item.
    ///   - type: The type of a related item.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRelatedItem(
        caseId: String,
        content: RelatedItemInputContent,
        domainId: String,
        performedBy: UserUnion? = nil,
        type: RelatedItemType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRelatedItemResponse {
        let input = CreateRelatedItemRequest(
            caseId: caseId, 
            content: content, 
            domainId: domainId, 
            performedBy: performedBy, 
            type: type
        )
        return try await self.createRelatedItem(input, logger: logger)
    }

    /// Creates a template in the Cases domain. This template is used to define the case object model (that is, to define what data can be captured on cases) in a Cases domain. A template must have a unique name within a domain, and it must reference existing field IDs and layout IDs. Additionally, multiple fields with same IDs are not allowed within the same Template. A template can be either Active or Inactive, as indicated by its status. Inactive templates cannot be used to create cases. Other template APIs are:     DeleteTemplate     GetTemplate     ListTemplates     UpdateTemplate
    @Sendable
    @inlinable
    public func createTemplate(_ input: CreateTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTemplateResponse {
        try await self.client.execute(
            operation: "CreateTemplate", 
            path: "/domains/{domainId}/templates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a template in the Cases domain. This template is used to define the case object model (that is, to define what data can be captured on cases) in a Cases domain. A template must have a unique name within a domain, and it must reference existing field IDs and layout IDs. Additionally, multiple fields with same IDs are not allowed within the same Template. A template can be either Active or Inactive, as indicated by its status. Inactive templates cannot be used to create cases. Other template APIs are:     DeleteTemplate     GetTemplate     ListTemplates     UpdateTemplate
    ///
    /// Parameters:
    ///   - description: A brief description of the template.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - layoutConfiguration: Configuration of layouts associated to the template.
    ///   - name: A name for the template. It must be unique per domain.
    ///   - requiredFields: A list of fields that must contain a value for a case to be successfully created with this template.
    ///   - rules: A list of case rules (also known as case field conditions) on a template.
    ///   - status: The status of the template.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTemplate(
        description: String? = nil,
        domainId: String,
        layoutConfiguration: LayoutConfiguration? = nil,
        name: String,
        requiredFields: [RequiredField]? = nil,
        rules: [TemplateRule]? = nil,
        status: TemplateStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTemplateResponse {
        let input = CreateTemplateRequest(
            description: description, 
            domainId: domainId, 
            layoutConfiguration: layoutConfiguration, 
            name: name, 
            requiredFields: requiredFields, 
            rules: rules, 
            status: status
        )
        return try await self.createTemplate(input, logger: logger)
    }

    /// Deletes a case rule. In the Amazon Connect admin website, case rules are known as case field conditions.  For more information about case field conditions, see Add case field conditions to a case template.
    @Sendable
    @inlinable
    public func deleteCaseRule(_ input: DeleteCaseRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCaseRuleResponse {
        try await self.client.execute(
            operation: "DeleteCaseRule", 
            path: "/domains/{domainId}/case-rules/{caseRuleId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a case rule. In the Amazon Connect admin website, case rules are known as case field conditions.  For more information about case field conditions, see Add case field conditions to a case template.
    ///
    /// Parameters:
    ///   - caseRuleId: Unique identifier of a case rule.
    ///   - domainId: Unique identifier of a Cases domain.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCaseRule(
        caseRuleId: String,
        domainId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCaseRuleResponse {
        let input = DeleteCaseRuleRequest(
            caseRuleId: caseRuleId, 
            domainId: domainId
        )
        return try await self.deleteCaseRule(input, logger: logger)
    }

    /// Deletes a Cases domain.   After deleting your domain you must disassociate the deleted domain from your Amazon Connect instance with another API call before being able to use Cases again with this Amazon Connect instance. See DeleteIntegrationAssociation.
    @Sendable
    @inlinable
    public func deleteDomain(_ input: DeleteDomainRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDomainResponse {
        try await self.client.execute(
            operation: "DeleteDomain", 
            path: "/domains/{domainId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a Cases domain.   After deleting your domain you must disassociate the deleted domain from your Amazon Connect instance with another API call before being able to use Cases again with this Amazon Connect instance. See DeleteIntegrationAssociation.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDomain(
        domainId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDomainResponse {
        let input = DeleteDomainRequest(
            domainId: domainId
        )
        return try await self.deleteDomain(input, logger: logger)
    }

    /// Deletes a field from a cases template. You can delete up to 100 fields per domain. After a field is deleted:   You can still retrieve the field by calling BatchGetField.   You cannot update a deleted field by calling UpdateField; it throws a ValidationException.   Deleted fields are not included in the ListFields response.   Calling CreateCase with a deleted field throws a ValidationException denoting which field IDs in the request have been deleted.   Calling GetCase with a deleted field ID returns the deleted field's value if one exists.   Calling UpdateCase with a deleted field ID throws a ValidationException if the case does not already contain a value for the deleted field. Otherwise it succeeds, allowing you to update or remove (using emptyValue: {}) the field's value from the case.    GetTemplate does not return field IDs for deleted fields.    GetLayout does not return field IDs for deleted fields.   Calling SearchCases with the deleted field ID as a filter returns any cases that have a value for the deleted field that matches the filter criteria.   Calling SearchCases with a searchTerm value that matches a deleted field's value on a case returns the case in the response.   Calling BatchPutFieldOptions with a deleted field ID throw a ValidationException.   Calling GetCaseEventConfiguration does not return field IDs for deleted fields.
    @Sendable
    @inlinable
    public func deleteField(_ input: DeleteFieldRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFieldResponse {
        try await self.client.execute(
            operation: "DeleteField", 
            path: "/domains/{domainId}/fields/{fieldId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a field from a cases template. You can delete up to 100 fields per domain. After a field is deleted:   You can still retrieve the field by calling BatchGetField.   You cannot update a deleted field by calling UpdateField; it throws a ValidationException.   Deleted fields are not included in the ListFields response.   Calling CreateCase with a deleted field throws a ValidationException denoting which field IDs in the request have been deleted.   Calling GetCase with a deleted field ID returns the deleted field's value if one exists.   Calling UpdateCase with a deleted field ID throws a ValidationException if the case does not already contain a value for the deleted field. Otherwise it succeeds, allowing you to update or remove (using emptyValue: {}) the field's value from the case.    GetTemplate does not return field IDs for deleted fields.    GetLayout does not return field IDs for deleted fields.   Calling SearchCases with the deleted field ID as a filter returns any cases that have a value for the deleted field that matches the filter criteria.   Calling SearchCases with a searchTerm value that matches a deleted field's value on a case returns the case in the response.   Calling BatchPutFieldOptions with a deleted field ID throw a ValidationException.   Calling GetCaseEventConfiguration does not return field IDs for deleted fields.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fieldId: Unique identifier of the field.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteField(
        domainId: String,
        fieldId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFieldResponse {
        let input = DeleteFieldRequest(
            domainId: domainId, 
            fieldId: fieldId
        )
        return try await self.deleteField(input, logger: logger)
    }

    /// Deletes a layout from a cases template. You can delete up to 100 layouts per domain.
    ///  After a layout is deleted:   You can still retrieve the layout by calling GetLayout.   You cannot update a deleted layout by calling UpdateLayout; it throws a ValidationException.   Deleted layouts are not included in the ListLayouts response.
    @Sendable
    @inlinable
    public func deleteLayout(_ input: DeleteLayoutRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLayoutResponse {
        try await self.client.execute(
            operation: "DeleteLayout", 
            path: "/domains/{domainId}/layouts/{layoutId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a layout from a cases template. You can delete up to 100 layouts per domain.
    ///  After a layout is deleted:   You can still retrieve the layout by calling GetLayout.   You cannot update a deleted layout by calling UpdateLayout; it throws a ValidationException.   Deleted layouts are not included in the ListLayouts response.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - layoutId: The unique identifier of the layout.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLayout(
        domainId: String,
        layoutId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteLayoutResponse {
        let input = DeleteLayoutRequest(
            domainId: domainId, 
            layoutId: layoutId
        )
        return try await self.deleteLayout(input, logger: logger)
    }

    /// Deletes a cases template. You can delete up to 100 templates per domain.
    ///  After a cases template is deleted:   You can still retrieve the template by calling GetTemplate.   You cannot update the template.    You cannot create a case by using the deleted template.   Deleted templates are not included in the ListTemplates response.
    @Sendable
    @inlinable
    public func deleteTemplate(_ input: DeleteTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteTemplateResponse {
        try await self.client.execute(
            operation: "DeleteTemplate", 
            path: "/domains/{domainId}/templates/{templateId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a cases template. You can delete up to 100 templates per domain.
    ///  After a cases template is deleted:   You can still retrieve the template by calling GetTemplate.   You cannot update the template.    You cannot create a case by using the deleted template.   Deleted templates are not included in the ListTemplates response.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - templateId: A unique identifier of a template.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTemplate(
        domainId: String,
        templateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteTemplateResponse {
        let input = DeleteTemplateRequest(
            domainId: domainId, 
            templateId: templateId
        )
        return try await self.deleteTemplate(input, logger: logger)
    }

    /// Returns information about a specific case if it exists.
    @Sendable
    @inlinable
    public func getCase(_ input: GetCaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCaseResponse {
        try await self.client.execute(
            operation: "GetCase", 
            path: "/domains/{domainId}/cases/{caseId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a specific case if it exists.
    ///
    /// Parameters:
    ///   - caseId: A unique identifier of the case.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fields: A list of unique field identifiers.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous
    ///   - logger: Logger use during operation
    @inlinable
    public func getCase(
        caseId: String,
        domainId: String,
        fields: [FieldIdentifier],
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCaseResponse {
        let input = GetCaseRequest(
            caseId: caseId, 
            domainId: domainId, 
            fields: fields, 
            nextToken: nextToken
        )
        return try await self.getCase(input, logger: logger)
    }

    /// Returns the audit history about a specific case if it exists.
    @Sendable
    @inlinable
    public func getCaseAuditEvents(_ input: GetCaseAuditEventsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCaseAuditEventsResponse {
        try await self.client.execute(
            operation: "GetCaseAuditEvents", 
            path: "/domains/{domainId}/cases/{caseId}/audit-history", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the audit history about a specific case if it exists.
    ///
    /// Parameters:
    ///   - caseId: A unique identifier of the case.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - maxResults: The maximum number of audit events to return. The current maximum supported value is 25. This is also the default when no other value is provided.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCaseAuditEvents(
        caseId: String,
        domainId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCaseAuditEventsResponse {
        let input = GetCaseAuditEventsRequest(
            caseId: caseId, 
            domainId: domainId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getCaseAuditEvents(input, logger: logger)
    }

    /// Returns the case event publishing configuration.
    @Sendable
    @inlinable
    public func getCaseEventConfiguration(_ input: GetCaseEventConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCaseEventConfigurationResponse {
        try await self.client.execute(
            operation: "GetCaseEventConfiguration", 
            path: "/domains/{domainId}/case-event-configuration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the case event publishing configuration.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCaseEventConfiguration(
        domainId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCaseEventConfigurationResponse {
        let input = GetCaseEventConfigurationRequest(
            domainId: domainId
        )
        return try await self.getCaseEventConfiguration(input, logger: logger)
    }

    /// Returns information about a specific domain if it exists.
    @Sendable
    @inlinable
    public func getDomain(_ input: GetDomainRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDomainResponse {
        try await self.client.execute(
            operation: "GetDomain", 
            path: "/domains/{domainId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a specific domain if it exists.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDomain(
        domainId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDomainResponse {
        let input = GetDomainRequest(
            domainId: domainId
        )
        return try await self.getDomain(input, logger: logger)
    }

    /// Returns the details for the requested layout.
    @Sendable
    @inlinable
    public func getLayout(_ input: GetLayoutRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLayoutResponse {
        try await self.client.execute(
            operation: "GetLayout", 
            path: "/domains/{domainId}/layouts/{layoutId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the details for the requested layout.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - layoutId: The unique identifier of the layout.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLayout(
        domainId: String,
        layoutId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLayoutResponse {
        let input = GetLayoutRequest(
            domainId: domainId, 
            layoutId: layoutId
        )
        return try await self.getLayout(input, logger: logger)
    }

    /// Returns the details for the requested template. Other template APIs are:     CreateTemplate     DeleteTemplate     ListTemplates     UpdateTemplate
    @Sendable
    @inlinable
    public func getTemplate(_ input: GetTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTemplateResponse {
        try await self.client.execute(
            operation: "GetTemplate", 
            path: "/domains/{domainId}/templates/{templateId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the details for the requested template. Other template APIs are:     CreateTemplate     DeleteTemplate     ListTemplates     UpdateTemplate
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - templateId: A unique identifier of a template.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTemplate(
        domainId: String,
        templateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTemplateResponse {
        let input = GetTemplateRequest(
            domainId: domainId, 
            templateId: templateId
        )
        return try await self.getTemplate(input, logger: logger)
    }

    /// Lists all case rules in a Cases domain. In the Amazon Connect admin website, case rules are known as case field conditions.  For more information about case field conditions, see Add case field conditions to a case template.
    @Sendable
    @inlinable
    public func listCaseRules(_ input: ListCaseRulesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCaseRulesResponse {
        try await self.client.execute(
            operation: "ListCaseRules", 
            path: "/domains/{domainId}/rules-list/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all case rules in a Cases domain. In the Amazon Connect admin website, case rules are known as case field conditions.  For more information about case field conditions, see Add case field conditions to a case template.
    ///
    /// Parameters:
    ///   - domainId: Unique identifier of a Cases domain.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous
    ///   - logger: Logger use during operation
    @inlinable
    public func listCaseRules(
        domainId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCaseRulesResponse {
        let input = ListCaseRulesRequest(
            domainId: domainId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listCaseRules(input, logger: logger)
    }

    /// Lists cases for a given contact.
    @Sendable
    @inlinable
    public func listCasesForContact(_ input: ListCasesForContactRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCasesForContactResponse {
        try await self.client.execute(
            operation: "ListCasesForContact", 
            path: "/domains/{domainId}/list-cases-for-contact", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists cases for a given contact.
    ///
    /// Parameters:
    ///   - contactArn: A unique identifier of a contact in Amazon Connect.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous
    ///   - logger: Logger use during operation
    @inlinable
    public func listCasesForContact(
        contactArn: String,
        domainId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCasesForContactResponse {
        let input = ListCasesForContactRequest(
            contactArn: contactArn, 
            domainId: domainId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listCasesForContact(input, logger: logger)
    }

    /// Lists all cases domains in the Amazon Web Services account. Each list item is a condensed summary object of the domain.
    @Sendable
    @inlinable
    public func listDomains(_ input: ListDomainsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDomainsResponse {
        try await self.client.execute(
            operation: "ListDomains", 
            path: "/domains-list", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all cases domains in the Amazon Web Services account. Each list item is a condensed summary object of the domain.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return per page.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous
    ///   - logger: Logger use during operation
    @inlinable
    public func listDomains(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDomainsResponse {
        let input = ListDomainsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDomains(input, logger: logger)
    }

    /// Lists all of the field options for a field identifier in the domain.
    @Sendable
    @inlinable
    public func listFieldOptions(_ input: ListFieldOptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFieldOptionsResponse {
        try await self.client.execute(
            operation: "ListFieldOptions", 
            path: "/domains/{domainId}/fields/{fieldId}/options-list", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the field options for a field identifier in the domain.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fieldId: The unique identifier of a field.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous
    ///   - values: A list of FieldOption values to filter on for ListFieldOptions.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFieldOptions(
        domainId: String,
        fieldId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        values: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFieldOptionsResponse {
        let input = ListFieldOptionsRequest(
            domainId: domainId, 
            fieldId: fieldId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            values: values
        )
        return try await self.listFieldOptions(input, logger: logger)
    }

    /// Lists all fields in a Cases domain.
    @Sendable
    @inlinable
    public func listFields(_ input: ListFieldsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFieldsResponse {
        try await self.client.execute(
            operation: "ListFields", 
            path: "/domains/{domainId}/fields-list", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all fields in a Cases domain.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous
    ///   - logger: Logger use during operation
    @inlinable
    public func listFields(
        domainId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFieldsResponse {
        let input = ListFieldsRequest(
            domainId: domainId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFields(input, logger: logger)
    }

    /// Lists all layouts in the given cases domain. Each list item is a condensed summary object of the layout.
    @Sendable
    @inlinable
    public func listLayouts(_ input: ListLayoutsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLayoutsResponse {
        try await self.client.execute(
            operation: "ListLayouts", 
            path: "/domains/{domainId}/layouts-list", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all layouts in the given cases domain. Each list item is a condensed summary object of the layout.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous
    ///   - logger: Logger use during operation
    @inlinable
    public func listLayouts(
        domainId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLayoutsResponse {
        let input = ListLayoutsRequest(
            domainId: domainId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listLayouts(input, logger: logger)
    }

    /// Lists tags for a resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{arn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists tags for a resource.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN)
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            arn: arn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Lists all of the templates in a Cases domain. Each list item is a condensed summary object of the template.  Other template APIs are:     CreateTemplate     DeleteTemplate     GetTemplate     UpdateTemplate
    @Sendable
    @inlinable
    public func listTemplates(_ input: ListTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTemplatesResponse {
        try await self.client.execute(
            operation: "ListTemplates", 
            path: "/domains/{domainId}/templates-list", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the templates in a Cases domain. Each list item is a condensed summary object of the template.  Other template APIs are:     CreateTemplate     DeleteTemplate     GetTemplate     UpdateTemplate
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous
    ///   - status: A list of status values to filter on.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTemplates(
        domainId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: [TemplateStatus]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTemplatesResponse {
        let input = ListTemplatesRequest(
            domainId: domainId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listTemplates(input, logger: logger)
    }

    /// Adds case event publishing configuration. For a complete list of fields you can add to the event message, see Create case fields in the Amazon Connect Administrator Guide
    @Sendable
    @inlinable
    public func putCaseEventConfiguration(_ input: PutCaseEventConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutCaseEventConfigurationResponse {
        try await self.client.execute(
            operation: "PutCaseEventConfiguration", 
            path: "/domains/{domainId}/case-event-configuration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds case event publishing configuration. For a complete list of fields you can add to the event message, see Create case fields in the Amazon Connect Administrator Guide
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - eventBridge: Configuration to enable EventBridge case event delivery and determine what data is delivered.
    ///   - logger: Logger use during operation
    @inlinable
    public func putCaseEventConfiguration(
        domainId: String,
        eventBridge: EventBridgeConfiguration,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutCaseEventConfigurationResponse {
        let input = PutCaseEventConfigurationRequest(
            domainId: domainId, 
            eventBridge: eventBridge
        )
        return try await self.putCaseEventConfiguration(input, logger: logger)
    }

    /// Searches for cases within their associated Cases domain. Search results are returned as a paginated list of abridged case documents.  For customer_id you must provide the full customer profile ARN in this format:  arn:aws:profile:your AWS Region:your AWS account ID:domains/profiles domain name/profiles/profile ID.
    @Sendable
    @inlinable
    public func searchCases(_ input: SearchCasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchCasesResponse {
        try await self.client.execute(
            operation: "SearchCases", 
            path: "/domains/{domainId}/cases-search", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Searches for cases within their associated Cases domain. Search results are returned as a paginated list of abridged case documents.  For customer_id you must provide the full customer profile ARN in this format:  arn:aws:profile:your AWS Region:your AWS account ID:domains/profiles domain name/profiles/profile ID.
    ///
    /// Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fields: The list of field identifiers to be returned as part of the response.
    ///   - filter: A list of filter objects.
    ///   - maxResults: The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous
    ///   - searchTerm: A word or phrase used to perform a quick search.
    ///   - sorts: A list of sorts where each sort specifies a field and their sort order to be applied to the results.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchCases(
        domainId: String,
        fields: [FieldIdentifier]? = nil,
        filter: CaseFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        searchTerm: String? = nil,
        sorts: [Sort]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchCasesResponse {
        let input = SearchCasesRequest(
            domainId: domainId, 
            fields: fields, 
            filter: filter, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            searchTerm: searchTerm, 
            sorts: sorts
        )
        return try await self.searchCases(input, logger: logger)
    }

    /// Searches for related items that are associated with a case.  If no filters are provided, this returns all related items associated with a case.
    @Sendable
    @inlinable
    public func searchRelatedItems(_ input: SearchRelatedItemsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchRelatedItemsResponse {
        try await self.client.execute(
            operation: "SearchRelatedItems", 
            path: "/domains/{domainId}/cases/{caseId}/related-items-search", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Searches for related items that are associated with a case.  If no filters are provided, this returns all related items associated with a case.
    ///
    /// Parameters:
    ///   - caseId: A unique identifier of the case.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - filters: The list of types of related items and their parameters to use for filtering.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous
    ///   - logger: Logger use during operation
    @inlinable
    public func searchRelatedItems(
        caseId: String,
        domainId: String,
        filters: [RelatedItemTypeFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchRelatedItemsResponse {
        let input = SearchRelatedItemsRequest(
            caseId: caseId, 
            domainId: domainId, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.searchRelatedItems(input, logger: logger)
    }

    /// Adds tags to a resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{arn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds tags to a resource.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN)
    ///   - tags: A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        arn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = TagResourceRequest(
            arn: arn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Untags a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{arn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Untags a resource.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN)
    ///   - tagKeys: List of tag keys.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        arn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UntagResourceRequest(
            arn: arn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    ///  If you provide a value for PerformedBy.UserArn you must also have connect:DescribeUser permission on the User ARN resource that you provide  Updates the values of fields on a case. Fields to be updated are received as an array of id/value pairs identical to the CreateCase input . If the action is successful, the service sends back an HTTP 200 response with an empty HTTP body.
    @Sendable
    @inlinable
    public func updateCase(_ input: UpdateCaseRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCaseResponse {
        try await self.client.execute(
            operation: "UpdateCase", 
            path: "/domains/{domainId}/cases/{caseId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  If you provide a value for PerformedBy.UserArn you must also have connect:DescribeUser permission on the User ARN resource that you provide  Updates the values of fields on a case. Fields to be updated are received as an array of id/value pairs identical to the CreateCase input . If the action is successful, the service sends back an HTTP 200 response with an empty HTTP body.
    ///
    /// Parameters:
    ///   - caseId: A unique identifier of the case.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fields: An array of objects with fieldId (matching ListFields/DescribeField) and value union data, structured identical to CreateCase.
    ///   - performedBy: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCase(
        caseId: String,
        domainId: String,
        fields: [FieldValue],
        performedBy: UserUnion? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCaseResponse {
        let input = UpdateCaseRequest(
            caseId: caseId, 
            domainId: domainId, 
            fields: fields, 
            performedBy: performedBy
        )
        return try await self.updateCase(input, logger: logger)
    }

    /// Updates a case rule. In the Amazon Connect admin website, case rules are known as case field conditions.  For more information about case field conditions, see Add case field conditions to a case template.
    @Sendable
    @inlinable
    public func updateCaseRule(_ input: UpdateCaseRuleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCaseRuleResponse {
        try await self.client.execute(
            operation: "UpdateCaseRule", 
            path: "/domains/{domainId}/case-rules/{caseRuleId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a case rule. In the Amazon Connect admin website, case rules are known as case field conditions.  For more information about case field conditions, see Add case field conditions to a case template.
    ///
    /// Parameters:
    ///   - caseRuleId: Unique identifier of a case rule.
    ///   - description: Description of a case rule.
    ///   - domainId: Unique identifier of a Cases domain.
    ///   - name: Name of the case rule.
    ///   - rule: Represents what rule type should take place, under what conditions.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCaseRule(
        caseRuleId: String,
        description: String? = nil,
        domainId: String,
        name: String? = nil,
        rule: CaseRuleDetails? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCaseRuleResponse {
        let input = UpdateCaseRuleRequest(
            caseRuleId: caseRuleId, 
            description: description, 
            domainId: domainId, 
            name: name, 
            rule: rule
        )
        return try await self.updateCaseRule(input, logger: logger)
    }

    /// Updates the properties of an existing field.
    @Sendable
    @inlinable
    public func updateField(_ input: UpdateFieldRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFieldResponse {
        try await self.client.execute(
            operation: "UpdateField", 
            path: "/domains/{domainId}/fields/{fieldId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the properties of an existing field.
    ///
    /// Parameters:
    ///   - description: The description of a field.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fieldId: The unique identifier of a field.
    ///   - name: The name of the field.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateField(
        description: String? = nil,
        domainId: String,
        fieldId: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFieldResponse {
        let input = UpdateFieldRequest(
            description: description, 
            domainId: domainId, 
            fieldId: fieldId, 
            name: name
        )
        return try await self.updateField(input, logger: logger)
    }

    /// Updates the attributes of an existing layout. If the action is successful, the service sends back an HTTP 200 response with an empty HTTP body. A ValidationException is returned when you add non-existent fieldIds to a layout.  Title and Status fields cannot be part of layouts because they are not configurable.
    @Sendable
    @inlinable
    public func updateLayout(_ input: UpdateLayoutRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLayoutResponse {
        try await self.client.execute(
            operation: "UpdateLayout", 
            path: "/domains/{domainId}/layouts/{layoutId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the attributes of an existing layout. If the action is successful, the service sends back an HTTP 200 response with an empty HTTP body. A ValidationException is returned when you add non-existent fieldIds to a layout.  Title and Status fields cannot be part of layouts because they are not configurable.
    ///
    /// Parameters:
    ///   - content: Information about which fields will be present in the layout, the order of the fields.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - layoutId: The unique identifier of the layout.
    ///   - name: The name of the layout. It must be unique per domain.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLayout(
        content: LayoutContent? = nil,
        domainId: String,
        layoutId: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateLayoutResponse {
        let input = UpdateLayoutRequest(
            content: content, 
            domainId: domainId, 
            layoutId: layoutId, 
            name: name
        )
        return try await self.updateLayout(input, logger: logger)
    }

    /// Updates the attributes of an existing template. The template attributes that can be modified include name, description, layoutConfiguration, requiredFields, and status. At least one of these attributes must not be null. If a null value is provided for a given attribute, that attribute is ignored and its current value is preserved. Other template APIs are:    CreateTemplate     DeleteTemplate     GetTemplate     ListTemplates
    @Sendable
    @inlinable
    public func updateTemplate(_ input: UpdateTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTemplateResponse {
        try await self.client.execute(
            operation: "UpdateTemplate", 
            path: "/domains/{domainId}/templates/{templateId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the attributes of an existing template. The template attributes that can be modified include name, description, layoutConfiguration, requiredFields, and status. At least one of these attributes must not be null. If a null value is provided for a given attribute, that attribute is ignored and its current value is preserved. Other template APIs are:    CreateTemplate     DeleteTemplate     GetTemplate     ListTemplates
    ///
    /// Parameters:
    ///   - description: A brief description of the template.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - layoutConfiguration: Configuration of layouts associated to the template.
    ///   - name: The name of the template. It must be unique per domain.
    ///   - requiredFields: A list of fields that must contain a value for a case to be successfully created with this template.
    ///   - rules: A list of case rules (also known as case field conditions) on a template.
    ///   - status: The status of the template.
    ///   - templateId: A unique identifier for the template.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateTemplate(
        description: String? = nil,
        domainId: String,
        layoutConfiguration: LayoutConfiguration? = nil,
        name: String? = nil,
        requiredFields: [RequiredField]? = nil,
        rules: [TemplateRule]? = nil,
        status: TemplateStatus? = nil,
        templateId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateTemplateResponse {
        let input = UpdateTemplateRequest(
            description: description, 
            domainId: domainId, 
            layoutConfiguration: layoutConfiguration, 
            name: name, 
            requiredFields: requiredFields, 
            rules: rules, 
            status: status, 
            templateId: templateId
        )
        return try await self.updateTemplate(input, logger: logger)
    }
}

extension ConnectCases {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: ConnectCases, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension ConnectCases {
    /// Return PaginatorSequence for operation ``getCase(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getCasePaginator(
        _ input: GetCaseRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetCaseRequest, GetCaseResponse> {
        return .init(
            input: input,
            command: self.getCase,
            inputKey: \GetCaseRequest.nextToken,
            outputKey: \GetCaseResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getCase(_:logger:)``.
    ///
    /// - Parameters:
    ///   - caseId: A unique identifier of the case.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fields: A list of unique field identifiers.
    ///   - logger: Logger used for logging
    @inlinable
    public func getCasePaginator(
        caseId: String,
        domainId: String,
        fields: [FieldIdentifier],
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetCaseRequest, GetCaseResponse> {
        let input = GetCaseRequest(
            caseId: caseId, 
            domainId: domainId, 
            fields: fields
        )
        return self.getCasePaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getCaseAuditEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getCaseAuditEventsPaginator(
        _ input: GetCaseAuditEventsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetCaseAuditEventsRequest, GetCaseAuditEventsResponse> {
        return .init(
            input: input,
            command: self.getCaseAuditEvents,
            inputKey: \GetCaseAuditEventsRequest.nextToken,
            outputKey: \GetCaseAuditEventsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getCaseAuditEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - caseId: A unique identifier of the case.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - maxResults: The maximum number of audit events to return. The current maximum supported value is 25. This is also the default when no other value is provided.
    ///   - logger: Logger used for logging
    @inlinable
    public func getCaseAuditEventsPaginator(
        caseId: String,
        domainId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetCaseAuditEventsRequest, GetCaseAuditEventsResponse> {
        let input = GetCaseAuditEventsRequest(
            caseId: caseId, 
            domainId: domainId, 
            maxResults: maxResults
        )
        return self.getCaseAuditEventsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCaseRules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCaseRulesPaginator(
        _ input: ListCaseRulesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCaseRulesRequest, ListCaseRulesResponse> {
        return .init(
            input: input,
            command: self.listCaseRules,
            inputKey: \ListCaseRulesRequest.nextToken,
            outputKey: \ListCaseRulesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCaseRules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - domainId: Unique identifier of a Cases domain.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCaseRulesPaginator(
        domainId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCaseRulesRequest, ListCaseRulesResponse> {
        let input = ListCaseRulesRequest(
            domainId: domainId, 
            maxResults: maxResults
        )
        return self.listCaseRulesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCasesForContact(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCasesForContactPaginator(
        _ input: ListCasesForContactRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCasesForContactRequest, ListCasesForContactResponse> {
        return .init(
            input: input,
            command: self.listCasesForContact,
            inputKey: \ListCasesForContactRequest.nextToken,
            outputKey: \ListCasesForContactResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCasesForContact(_:logger:)``.
    ///
    /// - Parameters:
    ///   - contactArn: A unique identifier of a contact in Amazon Connect.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCasesForContactPaginator(
        contactArn: String,
        domainId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCasesForContactRequest, ListCasesForContactResponse> {
        let input = ListCasesForContactRequest(
            contactArn: contactArn, 
            domainId: domainId, 
            maxResults: maxResults
        )
        return self.listCasesForContactPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDomains(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDomainsPaginator(
        _ input: ListDomainsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDomainsRequest, ListDomainsResponse> {
        return .init(
            input: input,
            command: self.listDomains,
            inputKey: \ListDomainsRequest.nextToken,
            outputKey: \ListDomainsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDomains(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDomainsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDomainsRequest, ListDomainsResponse> {
        let input = ListDomainsRequest(
            maxResults: maxResults
        )
        return self.listDomainsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFieldOptions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFieldOptionsPaginator(
        _ input: ListFieldOptionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFieldOptionsRequest, ListFieldOptionsResponse> {
        return .init(
            input: input,
            command: self.listFieldOptions,
            inputKey: \ListFieldOptionsRequest.nextToken,
            outputKey: \ListFieldOptionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFieldOptions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fieldId: The unique identifier of a field.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - values: A list of FieldOption values to filter on for ListFieldOptions.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFieldOptionsPaginator(
        domainId: String,
        fieldId: String,
        maxResults: Int? = nil,
        values: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFieldOptionsRequest, ListFieldOptionsResponse> {
        let input = ListFieldOptionsRequest(
            domainId: domainId, 
            fieldId: fieldId, 
            maxResults: maxResults, 
            values: values
        )
        return self.listFieldOptionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFields(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFieldsPaginator(
        _ input: ListFieldsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFieldsRequest, ListFieldsResponse> {
        return .init(
            input: input,
            command: self.listFields,
            inputKey: \ListFieldsRequest.nextToken,
            outputKey: \ListFieldsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFields(_:logger:)``.
    ///
    /// - Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFieldsPaginator(
        domainId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFieldsRequest, ListFieldsResponse> {
        let input = ListFieldsRequest(
            domainId: domainId, 
            maxResults: maxResults
        )
        return self.listFieldsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLayouts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLayoutsPaginator(
        _ input: ListLayoutsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLayoutsRequest, ListLayoutsResponse> {
        return .init(
            input: input,
            command: self.listLayouts,
            inputKey: \ListLayoutsRequest.nextToken,
            outputKey: \ListLayoutsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLayouts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listLayoutsPaginator(
        domainId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLayoutsRequest, ListLayoutsResponse> {
        let input = ListLayoutsRequest(
            domainId: domainId, 
            maxResults: maxResults
        )
        return self.listLayoutsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTemplatesPaginator(
        _ input: ListTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTemplatesRequest, ListTemplatesResponse> {
        return .init(
            input: input,
            command: self.listTemplates,
            inputKey: \ListTemplatesRequest.nextToken,
            outputKey: \ListTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - status: A list of status values to filter on.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTemplatesPaginator(
        domainId: String,
        maxResults: Int? = nil,
        status: [TemplateStatus]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTemplatesRequest, ListTemplatesResponse> {
        let input = ListTemplatesRequest(
            domainId: domainId, 
            maxResults: maxResults, 
            status: status
        )
        return self.listTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``searchCases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func searchCasesPaginator(
        _ input: SearchCasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<SearchCasesRequest, SearchCasesResponse> {
        return .init(
            input: input,
            command: self.searchCases,
            inputKey: \SearchCasesRequest.nextToken,
            outputKey: \SearchCasesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``searchCases(_:logger:)``.
    ///
    /// - Parameters:
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - fields: The list of field identifiers to be returned as part of the response.
    ///   - filter: A list of filter objects.
    ///   - maxResults: The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.
    ///   - searchTerm: A word or phrase used to perform a quick search.
    ///   - sorts: A list of sorts where each sort specifies a field and their sort order to be applied to the results.
    ///   - logger: Logger used for logging
    @inlinable
    public func searchCasesPaginator(
        domainId: String,
        fields: [FieldIdentifier]? = nil,
        filter: CaseFilter? = nil,
        maxResults: Int? = nil,
        searchTerm: String? = nil,
        sorts: [Sort]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<SearchCasesRequest, SearchCasesResponse> {
        let input = SearchCasesRequest(
            domainId: domainId, 
            fields: fields, 
            filter: filter, 
            maxResults: maxResults, 
            searchTerm: searchTerm, 
            sorts: sorts
        )
        return self.searchCasesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``searchRelatedItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func searchRelatedItemsPaginator(
        _ input: SearchRelatedItemsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<SearchRelatedItemsRequest, SearchRelatedItemsResponse> {
        return .init(
            input: input,
            command: self.searchRelatedItems,
            inputKey: \SearchRelatedItemsRequest.nextToken,
            outputKey: \SearchRelatedItemsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``searchRelatedItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - caseId: A unique identifier of the case.
    ///   - domainId: The unique identifier of the Cases domain.
    ///   - filters: The list of types of related items and their parameters to use for filtering.
    ///   - maxResults: The maximum number of results to return per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func searchRelatedItemsPaginator(
        caseId: String,
        domainId: String,
        filters: [RelatedItemTypeFilter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<SearchRelatedItemsRequest, SearchRelatedItemsResponse> {
        let input = SearchRelatedItemsRequest(
            caseId: caseId, 
            domainId: domainId, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.searchRelatedItemsPaginator(input, logger: logger)
    }
}

extension ConnectCases.GetCaseAuditEventsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.GetCaseAuditEventsRequest {
        return .init(
            caseId: self.caseId,
            domainId: self.domainId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ConnectCases.GetCaseRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.GetCaseRequest {
        return .init(
            caseId: self.caseId,
            domainId: self.domainId,
            fields: self.fields,
            nextToken: token
        )
    }
}

extension ConnectCases.ListCaseRulesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.ListCaseRulesRequest {
        return .init(
            domainId: self.domainId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ConnectCases.ListCasesForContactRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.ListCasesForContactRequest {
        return .init(
            contactArn: self.contactArn,
            domainId: self.domainId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ConnectCases.ListDomainsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.ListDomainsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ConnectCases.ListFieldOptionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.ListFieldOptionsRequest {
        return .init(
            domainId: self.domainId,
            fieldId: self.fieldId,
            maxResults: self.maxResults,
            nextToken: token,
            values: self.values
        )
    }
}

extension ConnectCases.ListFieldsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.ListFieldsRequest {
        return .init(
            domainId: self.domainId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ConnectCases.ListLayoutsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.ListLayoutsRequest {
        return .init(
            domainId: self.domainId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension ConnectCases.ListTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.ListTemplatesRequest {
        return .init(
            domainId: self.domainId,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension ConnectCases.SearchCasesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.SearchCasesRequest {
        return .init(
            domainId: self.domainId,
            fields: self.fields,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            searchTerm: self.searchTerm,
            sorts: self.sorts
        )
    }
}

extension ConnectCases.SearchRelatedItemsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> ConnectCases.SearchRelatedItemsRequest {
        return .init(
            caseId: self.caseId,
            domainId: self.domainId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
