//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension SFN {
    // MARK: Enums

    public enum ExecutionRedriveFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notRedriven = "NOT_REDRIVEN"
        case redriven = "REDRIVEN"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionRedriveStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notRedrivable = "NOT_REDRIVABLE"
        case redrivable = "REDRIVABLE"
        case redrivableByMapRun = "REDRIVABLE_BY_MAP_RUN"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case failed = "FAILED"
        case pendingRedrive = "PENDING_REDRIVE"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum HistoryEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activityFailed = "ActivityFailed"
        case activityScheduleFailed = "ActivityScheduleFailed"
        case activityScheduled = "ActivityScheduled"
        case activityStarted = "ActivityStarted"
        case activitySucceeded = "ActivitySucceeded"
        case activityTimedOut = "ActivityTimedOut"
        case choiceStateEntered = "ChoiceStateEntered"
        case choiceStateExited = "ChoiceStateExited"
        case executionAborted = "ExecutionAborted"
        case executionFailed = "ExecutionFailed"
        case executionRedriven = "ExecutionRedriven"
        case executionStarted = "ExecutionStarted"
        case executionSucceeded = "ExecutionSucceeded"
        case executionTimedOut = "ExecutionTimedOut"
        case failStateEntered = "FailStateEntered"
        case lambdaFunctionFailed = "LambdaFunctionFailed"
        case lambdaFunctionScheduleFailed = "LambdaFunctionScheduleFailed"
        case lambdaFunctionScheduled = "LambdaFunctionScheduled"
        case lambdaFunctionStartFailed = "LambdaFunctionStartFailed"
        case lambdaFunctionStarted = "LambdaFunctionStarted"
        case lambdaFunctionSucceeded = "LambdaFunctionSucceeded"
        case lambdaFunctionTimedOut = "LambdaFunctionTimedOut"
        case mapIterationAborted = "MapIterationAborted"
        case mapIterationFailed = "MapIterationFailed"
        case mapIterationStarted = "MapIterationStarted"
        case mapIterationSucceeded = "MapIterationSucceeded"
        case mapRunAborted = "MapRunAborted"
        case mapRunFailed = "MapRunFailed"
        case mapRunRedriven = "MapRunRedriven"
        case mapRunStarted = "MapRunStarted"
        case mapRunSucceeded = "MapRunSucceeded"
        case mapStateAborted = "MapStateAborted"
        case mapStateEntered = "MapStateEntered"
        case mapStateExited = "MapStateExited"
        case mapStateFailed = "MapStateFailed"
        case mapStateStarted = "MapStateStarted"
        case mapStateSucceeded = "MapStateSucceeded"
        case parallelStateAborted = "ParallelStateAborted"
        case parallelStateEntered = "ParallelStateEntered"
        case parallelStateExited = "ParallelStateExited"
        case parallelStateFailed = "ParallelStateFailed"
        case parallelStateStarted = "ParallelStateStarted"
        case parallelStateSucceeded = "ParallelStateSucceeded"
        case passStateEntered = "PassStateEntered"
        case passStateExited = "PassStateExited"
        case succeedStateEntered = "SucceedStateEntered"
        case succeedStateExited = "SucceedStateExited"
        case taskFailed = "TaskFailed"
        case taskScheduled = "TaskScheduled"
        case taskStartFailed = "TaskStartFailed"
        case taskStarted = "TaskStarted"
        case taskStateAborted = "TaskStateAborted"
        case taskStateEntered = "TaskStateEntered"
        case taskStateExited = "TaskStateExited"
        case taskSubmitFailed = "TaskSubmitFailed"
        case taskSubmitted = "TaskSubmitted"
        case taskSucceeded = "TaskSucceeded"
        case taskTimedOut = "TaskTimedOut"
        case waitStateAborted = "WaitStateAborted"
        case waitStateEntered = "WaitStateEntered"
        case waitStateExited = "WaitStateExited"
        public var description: String { return self.rawValue }
    }

    public enum InspectionLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        case info = "INFO"
        case trace = "TRACE"
        public var description: String { return self.rawValue }
    }

    public enum LogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case error = "ERROR"
        case fatal = "FATAL"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum MapRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case failed = "FAILED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum StateMachineStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum StateMachineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case express = "EXPRESS"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum SyncExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case succeeded = "SUCCEEDED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum TestExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case caughtError = "CAUGHT_ERROR"
        case failed = "FAILED"
        case retriable = "RETRIABLE"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ActivityFailedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct ActivityListItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the activity.
        public let activityArn: String
        /// The date the activity is created.
        public let creationDate: Date
        /// The name of the activity. A name must not contain:   white space   brackets  { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ & , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.
        public let name: String

        public init(activityArn: String, creationDate: Date, name: String) {
            self.activityArn = activityArn
            self.creationDate = creationDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
            case creationDate = "creationDate"
            case name = "name"
        }
    }

    public struct ActivityScheduleFailedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct ActivityScheduledEventDetails: AWSDecodableShape {
        /// The maximum allowed duration between two heartbeats for the activity task.
        public let heartbeatInSeconds: Int64?
        /// The JSON data input to the activity task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// Contains details about the input for an execution history event.
        public let inputDetails: HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the scheduled activity.
        public let resource: String
        /// The maximum allowed duration of the activity task.
        public let timeoutInSeconds: Int64?

        public init(heartbeatInSeconds: Int64? = nil, input: String? = nil, inputDetails: HistoryEventExecutionDataDetails? = nil, resource: String, timeoutInSeconds: Int64? = nil) {
            self.heartbeatInSeconds = heartbeatInSeconds
            self.input = input
            self.inputDetails = inputDetails
            self.resource = resource
            self.timeoutInSeconds = timeoutInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case heartbeatInSeconds = "heartbeatInSeconds"
            case input = "input"
            case inputDetails = "inputDetails"
            case resource = "resource"
            case timeoutInSeconds = "timeoutInSeconds"
        }
    }

    public struct ActivityStartedEventDetails: AWSDecodableShape {
        /// The name of the worker that the task is assigned to. These names are provided by the workers when calling GetActivityTask.
        public let workerName: String?

        public init(workerName: String? = nil) {
            self.workerName = workerName
        }

        private enum CodingKeys: String, CodingKey {
            case workerName = "workerName"
        }
    }

    public struct ActivitySucceededEventDetails: AWSDecodableShape {
        /// The JSON data output by the activity task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?

        public init(output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil) {
            self.output = output
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case outputDetails = "outputDetails"
        }
    }

    public struct ActivityTimedOutEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the timeout.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct BillingDetails: AWSDecodableShape {
        /// Billed duration of your workflow, in milliseconds.
        public let billedDurationInMilliseconds: Int64?
        /// Billed memory consumption of your workflow, in MB.
        public let billedMemoryUsedInMB: Int64?

        public init(billedDurationInMilliseconds: Int64? = nil, billedMemoryUsedInMB: Int64? = nil) {
            self.billedDurationInMilliseconds = billedDurationInMilliseconds
            self.billedMemoryUsedInMB = billedMemoryUsedInMB
        }

        private enum CodingKeys: String, CodingKey {
            case billedDurationInMilliseconds = "billedDurationInMilliseconds"
            case billedMemoryUsedInMB = "billedMemoryUsedInMB"
        }
    }

    public struct CloudWatchEventsExecutionDataDetails: AWSDecodableShape {
        /// Indicates whether input or output was included in the response. Always true for API calls.
        public let included: Bool?

        public init(included: Bool? = nil) {
            self.included = included
        }

        private enum CodingKeys: String, CodingKey {
            case included = "included"
        }
    }

    public struct CloudWatchLogsLogGroup: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the the CloudWatch log group to which you want your logs emitted to. The ARN must end with :*
        public let logGroupArn: String?

        public init(logGroupArn: String? = nil) {
            self.logGroupArn = logGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, max: 256)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupArn = "logGroupArn"
        }
    }

    public struct CreateActivityInput: AWSEncodableShape {
        /// The name of the activity to create. This name must be unique for your Amazon Web Services account and region for 90 days. For more information, see  Limits Related to State Machine Executions in the Step Functions Developer Guide. A name must not contain:   white space   brackets  { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ & , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.
        public let name: String
        /// The list of tags to add to a resource. An array of key-value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide, and Controlling Access Using IAM Tags. Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
        public let tags: [Tag]?

        public init(name: String, tags: [Tag]? = nil) {
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 80)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateActivityOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the created activity.
        public let activityArn: String
        /// The date the activity is created.
        public let creationDate: Date

        public init(activityArn: String, creationDate: Date) {
            self.activityArn = activityArn
            self.creationDate = creationDate
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
            case creationDate = "creationDate"
        }
    }

    public struct CreateStateMachineAliasInput: AWSEncodableShape {
        /// A description for the state machine alias.
        public let description: String?
        /// The name of the state machine alias. To avoid conflict with version ARNs, don't use an integer in the name of the alias.
        public let name: String
        /// The routing configuration of a state machine alias. The routing configuration shifts execution traffic between two state machine versions. routingConfiguration contains an array of RoutingConfig objects that specify up to two state machine versions. Step Functions then randomly choses which version to run an execution with based on the weight assigned to each RoutingConfig.
        public let routingConfiguration: [RoutingConfigurationListItem]

        public init(description: String? = nil, name: String, routingConfiguration: [RoutingConfigurationListItem]) {
            self.description = description
            self.name = name
            self.routingConfiguration = routingConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 80)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?=.*[a-zA-Z_\\-\\.])[a-zA-Z0-9_\\-\\.]+$")
            try self.routingConfiguration.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 2)
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
        }
    }

    public struct CreateStateMachineAliasOutput: AWSDecodableShape {
        /// The date the state machine alias was created.
        public let creationDate: Date
        /// The Amazon Resource Name (ARN) that identifies the created state machine alias.
        public let stateMachineAliasArn: String

        public init(creationDate: Date, stateMachineAliasArn: String) {
            self.creationDate = creationDate
            self.stateMachineAliasArn = stateMachineAliasArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case stateMachineAliasArn = "stateMachineAliasArn"
        }
    }

    public struct CreateStateMachineInput: AWSEncodableShape {
        /// The Amazon States Language definition of the state machine. See Amazon States Language.
        public let definition: String
        /// Defines what execution history events are logged and where they are logged.  By default, the level is set to OFF. For more information see Log Levels in the Step Functions User Guide.
        public let loggingConfiguration: LoggingConfiguration?
        /// The name of the state machine.  A name must not contain:   white space   brackets  { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ & , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.
        public let name: String
        /// Set to true to publish the first version of the state machine during creation. The default is false.
        public let publish: Bool?
        /// The Amazon Resource Name (ARN) of the IAM role to use for this state machine.
        public let roleArn: String
        /// Tags to be added when creating a state machine. An array of key-value pairs. For more information, see Using Cost Allocation Tags in the Amazon Web Services Billing and Cost Management User Guide, and Controlling Access Using IAM Tags. Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// Selects whether X-Ray tracing is enabled.
        public let tracingConfiguration: TracingConfiguration?
        /// Determines whether a Standard or Express state machine is created. The default is STANDARD. You cannot update the type of a state machine once it has been created.
        public let type: StateMachineType?
        /// Sets description about the state machine version. You can only set the description if the publish parameter is set to true. Otherwise, if you set versionDescription, but publish to false, this API action throws ValidationException.
        public let versionDescription: String?

        public init(definition: String, loggingConfiguration: LoggingConfiguration? = nil, name: String, publish: Bool? = nil, roleArn: String, tags: [Tag]? = nil, tracingConfiguration: TracingConfiguration? = nil, type: StateMachineType? = nil, versionDescription: String? = nil) {
            self.definition = definition
            self.loggingConfiguration = loggingConfiguration
            self.name = name
            self.publish = publish
            self.roleArn = roleArn
            self.tags = tags
            self.tracingConfiguration = tracingConfiguration
            self.type = type
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.definition, name: "definition", parent: name, max: 1048576)
            try self.validate(self.definition, name: "definition", parent: name, min: 1)
            try self.loggingConfiguration?.validate(name: "\(name).loggingConfiguration")
            try self.validate(self.name, name: "name", parent: name, max: 80)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case loggingConfiguration = "loggingConfiguration"
            case name = "name"
            case publish = "publish"
            case roleArn = "roleArn"
            case tags = "tags"
            case tracingConfiguration = "tracingConfiguration"
            case type = "type"
            case versionDescription = "versionDescription"
        }
    }

    public struct CreateStateMachineOutput: AWSDecodableShape {
        /// The date the state machine is created.
        public let creationDate: Date
        /// The Amazon Resource Name (ARN) that identifies the created state machine.
        public let stateMachineArn: String
        /// The Amazon Resource Name (ARN) that identifies the created state machine version. If you do not set the publish parameter to true, this field returns null value.
        public let stateMachineVersionArn: String?

        public init(creationDate: Date, stateMachineArn: String, stateMachineVersionArn: String? = nil) {
            self.creationDate = creationDate
            self.stateMachineArn = stateMachineArn
            self.stateMachineVersionArn = stateMachineVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case stateMachineArn = "stateMachineArn"
            case stateMachineVersionArn = "stateMachineVersionArn"
        }
    }

    public struct DeleteActivityInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the activity to delete.
        public let activityArn: String

        public init(activityArn: String) {
            self.activityArn = activityArn
        }

        public func validate(name: String) throws {
            try self.validate(self.activityArn, name: "activityArn", parent: name, max: 256)
            try self.validate(self.activityArn, name: "activityArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
        }
    }

    public struct DeleteActivityOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStateMachineAliasInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the state machine alias to delete.
        public let stateMachineAliasArn: String

        public init(stateMachineAliasArn: String) {
            self.stateMachineAliasArn = stateMachineAliasArn
        }

        public func validate(name: String) throws {
            try self.validate(self.stateMachineAliasArn, name: "stateMachineAliasArn", parent: name, max: 256)
            try self.validate(self.stateMachineAliasArn, name: "stateMachineAliasArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stateMachineAliasArn = "stateMachineAliasArn"
        }
    }

    public struct DeleteStateMachineAliasOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStateMachineInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the state machine to delete.
        public let stateMachineArn: String

        public init(stateMachineArn: String) {
            self.stateMachineArn = stateMachineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, max: 256)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stateMachineArn = "stateMachineArn"
        }
    }

    public struct DeleteStateMachineOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStateMachineVersionInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the state machine version to delete.
        public let stateMachineVersionArn: String

        public init(stateMachineVersionArn: String) {
            self.stateMachineVersionArn = stateMachineVersionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.stateMachineVersionArn, name: "stateMachineVersionArn", parent: name, max: 2000)
            try self.validate(self.stateMachineVersionArn, name: "stateMachineVersionArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stateMachineVersionArn = "stateMachineVersionArn"
        }
    }

    public struct DeleteStateMachineVersionOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeActivityInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the activity to describe.
        public let activityArn: String

        public init(activityArn: String) {
            self.activityArn = activityArn
        }

        public func validate(name: String) throws {
            try self.validate(self.activityArn, name: "activityArn", parent: name, max: 256)
            try self.validate(self.activityArn, name: "activityArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
        }
    }

    public struct DescribeActivityOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the activity.
        public let activityArn: String
        /// The date the activity is created.
        public let creationDate: Date
        /// The name of the activity. A name must not contain:   white space   brackets  { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ & , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.
        public let name: String

        public init(activityArn: String, creationDate: Date, name: String) {
            self.activityArn = activityArn
            self.creationDate = creationDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
            case creationDate = "creationDate"
            case name = "name"
        }
    }

    public struct DescribeExecutionInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the execution to describe.
        public let executionArn: String

        public init(executionArn: String) {
            self.executionArn = executionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.executionArn, name: "executionArn", parent: name, max: 256)
            try self.validate(self.executionArn, name: "executionArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
        }
    }

    public struct DescribeExecutionOutput: AWSDecodableShape {
        /// The cause string if the state machine execution failed.
        public let cause: String?
        /// The error string if the state machine execution failed.
        public let error: String?
        /// The Amazon Resource Name (ARN) that identifies the execution.
        public let executionArn: String
        /// The string that contains the JSON input data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        public let inputDetails: CloudWatchEventsExecutionDataDetails?
        /// The Amazon Resource Name (ARN) that identifies a Map Run, which dispatched this execution.
        public let mapRunArn: String?
        /// The name of the execution. A name must not contain:   white space   brackets  { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ & , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.
        public let name: String?
        /// The JSON output data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.  This field is set only if the execution succeeds. If the execution fails, this field is null.
        public let output: String?
        public let outputDetails: CloudWatchEventsExecutionDataDetails?
        /// The number of times you've redriven an execution. If you have not yet redriven an execution, the redriveCount is 0. This count is only updated if you successfully redrive an execution.
        public let redriveCount: Int?
        /// The date the execution was last redriven. If you have not yet redriven an execution, the redriveDate is null. The redriveDate is unavailable if you redrive a Map Run that starts child workflow executions of type EXPRESS.
        public let redriveDate: Date?
        /// Indicates whether or not an execution can be redriven at a given point in time.   For executions of type STANDARD, redriveStatus is NOT_REDRIVABLE if calling the RedriveExecution API action would return the ExecutionNotRedrivable error.   For a Distributed Map that includes child workflows of type STANDARD, redriveStatus indicates whether or not the Map Run can redrive child workflow executions.   For a Distributed Map that includes child workflows of type EXPRESS, redriveStatus indicates whether or not the Map Run can redrive child workflow executions. You can redrive failed or timed out EXPRESS workflows only if they're a part of a Map Run. When you redrive the Map Run, these workflows are restarted using the StartExecution API action.
        public let redriveStatus: ExecutionRedriveStatus?
        /// When redriveStatus is NOT_REDRIVABLE, redriveStatusReason specifies the reason why an execution cannot be redriven.   For executions of type STANDARD, or for a Distributed Map that includes child workflows of type STANDARD, redriveStatusReason can include one of the following reasons:    State machine is in DELETING status.    Execution is RUNNING and cannot be redriven.    Execution is SUCCEEDED and cannot be redriven.    Execution was started before the launch of RedriveExecution.    Execution history event limit exceeded.    Execution has exceeded the max execution time.    Execution redrivable period exceeded.     For a Distributed Map that includes child workflows of type EXPRESS, redriveStatusReason is only returned if the child workflows are not redrivable. This happens when the child workflow executions have completed successfully.
        public let redriveStatusReason: String?
        /// The date the execution is started.
        public let startDate: Date
        /// The Amazon Resource Name (ARN) of the state machine alias associated with the execution. The alias ARN is a combination of state machine ARN and the alias name separated by a colon (:). For example, stateMachineARN:PROD. If you start an execution from a StartExecution request with a state machine version ARN, this field will be null.
        public let stateMachineAliasArn: String?
        /// The Amazon Resource Name (ARN) of the executed stated machine.
        public let stateMachineArn: String
        /// The Amazon Resource Name (ARN) of the state machine version associated with the execution. The version ARN is a combination of state machine ARN and the version number separated by a colon (:). For example, stateMachineARN:1. If you start an execution from a StartExecution request without specifying a state machine version or alias ARN, Step Functions returns a null value.
        public let stateMachineVersionArn: String?
        /// The current status of the execution.
        public let status: ExecutionStatus
        /// If the execution ended, the date the execution stopped.
        public let stopDate: Date?
        /// The X-Ray trace header that was passed to the execution.
        public let traceHeader: String?

        public init(cause: String? = nil, error: String? = nil, executionArn: String, input: String? = nil, inputDetails: CloudWatchEventsExecutionDataDetails? = nil, mapRunArn: String? = nil, name: String? = nil, output: String? = nil, outputDetails: CloudWatchEventsExecutionDataDetails? = nil, redriveCount: Int? = nil, redriveDate: Date? = nil, redriveStatus: ExecutionRedriveStatus? = nil, redriveStatusReason: String? = nil, startDate: Date, stateMachineAliasArn: String? = nil, stateMachineArn: String, stateMachineVersionArn: String? = nil, status: ExecutionStatus, stopDate: Date? = nil, traceHeader: String? = nil) {
            self.cause = cause
            self.error = error
            self.executionArn = executionArn
            self.input = input
            self.inputDetails = inputDetails
            self.mapRunArn = mapRunArn
            self.name = name
            self.output = output
            self.outputDetails = outputDetails
            self.redriveCount = redriveCount
            self.redriveDate = redriveDate
            self.redriveStatus = redriveStatus
            self.redriveStatusReason = redriveStatusReason
            self.startDate = startDate
            self.stateMachineAliasArn = stateMachineAliasArn
            self.stateMachineArn = stateMachineArn
            self.stateMachineVersionArn = stateMachineVersionArn
            self.status = status
            self.stopDate = stopDate
            self.traceHeader = traceHeader
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case executionArn = "executionArn"
            case input = "input"
            case inputDetails = "inputDetails"
            case mapRunArn = "mapRunArn"
            case name = "name"
            case output = "output"
            case outputDetails = "outputDetails"
            case redriveCount = "redriveCount"
            case redriveDate = "redriveDate"
            case redriveStatus = "redriveStatus"
            case redriveStatusReason = "redriveStatusReason"
            case startDate = "startDate"
            case stateMachineAliasArn = "stateMachineAliasArn"
            case stateMachineArn = "stateMachineArn"
            case stateMachineVersionArn = "stateMachineVersionArn"
            case status = "status"
            case stopDate = "stopDate"
            case traceHeader = "traceHeader"
        }
    }

    public struct DescribeMapRunInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies a Map Run.
        public let mapRunArn: String

        public init(mapRunArn: String) {
            self.mapRunArn = mapRunArn
        }

        public func validate(name: String) throws {
            try self.validate(self.mapRunArn, name: "mapRunArn", parent: name, max: 2000)
            try self.validate(self.mapRunArn, name: "mapRunArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case mapRunArn = "mapRunArn"
        }
    }

    public struct DescribeMapRunOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the execution in which the Map Run was started.
        public let executionArn: String
        /// A JSON object that contains information about the total number of child workflow executions for the Map Run, and the count of child workflow executions for each status, such as failed and succeeded.
        public let executionCounts: MapRunExecutionCounts
        /// A JSON object that contains information about the total number of items, and the item count for each processing status, such as pending and failed.
        public let itemCounts: MapRunItemCounts
        /// The Amazon Resource Name (ARN) that identifies a Map Run.
        public let mapRunArn: String
        /// The maximum number of child workflow executions configured to run in parallel for the Map Run at the same time.
        public let maxConcurrency: Int
        /// The number of times you've redriven a Map Run. If you have not yet redriven a Map Run, the redriveCount is 0. This count is only updated if you successfully redrive a Map Run.
        public let redriveCount: Int?
        /// The date a Map Run was last redriven. If you have not yet redriven a Map Run, the redriveDate is null.
        public let redriveDate: Date?
        /// The date when the Map Run was started.
        public let startDate: Date
        /// The current status of the Map Run.
        public let status: MapRunStatus
        /// The date when the Map Run was stopped.
        public let stopDate: Date?
        /// The maximum number of failed child workflow executions before the Map Run fails.
        public let toleratedFailureCount: Int64
        /// The maximum percentage of failed child workflow executions before the Map Run fails.
        public let toleratedFailurePercentage: Float

        public init(executionArn: String, executionCounts: MapRunExecutionCounts, itemCounts: MapRunItemCounts, mapRunArn: String, maxConcurrency: Int, redriveCount: Int? = nil, redriveDate: Date? = nil, startDate: Date, status: MapRunStatus, stopDate: Date? = nil, toleratedFailureCount: Int64, toleratedFailurePercentage: Float) {
            self.executionArn = executionArn
            self.executionCounts = executionCounts
            self.itemCounts = itemCounts
            self.mapRunArn = mapRunArn
            self.maxConcurrency = maxConcurrency
            self.redriveCount = redriveCount
            self.redriveDate = redriveDate
            self.startDate = startDate
            self.status = status
            self.stopDate = stopDate
            self.toleratedFailureCount = toleratedFailureCount
            self.toleratedFailurePercentage = toleratedFailurePercentage
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
            case executionCounts = "executionCounts"
            case itemCounts = "itemCounts"
            case mapRunArn = "mapRunArn"
            case maxConcurrency = "maxConcurrency"
            case redriveCount = "redriveCount"
            case redriveDate = "redriveDate"
            case startDate = "startDate"
            case status = "status"
            case stopDate = "stopDate"
            case toleratedFailureCount = "toleratedFailureCount"
            case toleratedFailurePercentage = "toleratedFailurePercentage"
        }
    }

    public struct DescribeStateMachineAliasInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the state machine alias.
        public let stateMachineAliasArn: String

        public init(stateMachineAliasArn: String) {
            self.stateMachineAliasArn = stateMachineAliasArn
        }

        public func validate(name: String) throws {
            try self.validate(self.stateMachineAliasArn, name: "stateMachineAliasArn", parent: name, max: 256)
            try self.validate(self.stateMachineAliasArn, name: "stateMachineAliasArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stateMachineAliasArn = "stateMachineAliasArn"
        }
    }

    public struct DescribeStateMachineAliasOutput: AWSDecodableShape {
        /// The date the state machine alias was created.
        public let creationDate: Date?
        /// A description of the alias.
        public let description: String?
        /// The name of the state machine alias.
        public let name: String?
        /// The routing configuration of the alias.
        public let routingConfiguration: [RoutingConfigurationListItem]?
        /// The Amazon Resource Name (ARN) of the state machine alias.
        public let stateMachineAliasArn: String?
        /// The date the state machine alias was last updated. For a newly created state machine, this is the same as the creation date.
        public let updateDate: Date?

        public init(creationDate: Date? = nil, description: String? = nil, name: String? = nil, routingConfiguration: [RoutingConfigurationListItem]? = nil, stateMachineAliasArn: String? = nil, updateDate: Date? = nil) {
            self.creationDate = creationDate
            self.description = description
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.stateMachineAliasArn = stateMachineAliasArn
            self.updateDate = updateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case name = "name"
            case routingConfiguration = "routingConfiguration"
            case stateMachineAliasArn = "stateMachineAliasArn"
            case updateDate = "updateDate"
        }
    }

    public struct DescribeStateMachineForExecutionInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the execution you want state machine information for.
        public let executionArn: String

        public init(executionArn: String) {
            self.executionArn = executionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.executionArn, name: "executionArn", parent: name, max: 256)
            try self.validate(self.executionArn, name: "executionArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
        }
    }

    public struct DescribeStateMachineForExecutionOutput: AWSDecodableShape {
        /// The Amazon States Language definition of the state machine. See Amazon States Language.
        public let definition: String
        /// A user-defined or an auto-generated string that identifies a Map state. This ﬁeld is returned only if the executionArn is a child workflow execution that was started by a Distributed Map state.
        public let label: String?
        public let loggingConfiguration: LoggingConfiguration?
        /// The Amazon Resource Name (ARN) of the Map Run that started the child workflow execution. This field is returned only if the executionArn is a child workflow execution that was started by a Distributed Map state.
        public let mapRunArn: String?
        /// The name of the state machine associated with the execution.
        public let name: String
        /// The revision identifier for the state machine. The first revision ID when you create the state machine is null. Use the state machine revisionId parameter to compare the revision of a state machine with the configuration of the state machine used for executions without performing a diff of the properties, such as definition and roleArn.
        public let revisionId: String?
        /// The Amazon Resource Name (ARN) of the IAM role of the State Machine for the execution.
        public let roleArn: String
        /// The Amazon Resource Name (ARN) of the state machine associated with the execution.
        public let stateMachineArn: String
        /// Selects whether X-Ray tracing is enabled.
        public let tracingConfiguration: TracingConfiguration?
        /// The date and time the state machine associated with an execution was updated. For a newly created state machine, this is the creation date.
        public let updateDate: Date

        public init(definition: String, label: String? = nil, loggingConfiguration: LoggingConfiguration? = nil, mapRunArn: String? = nil, name: String, revisionId: String? = nil, roleArn: String, stateMachineArn: String, tracingConfiguration: TracingConfiguration? = nil, updateDate: Date) {
            self.definition = definition
            self.label = label
            self.loggingConfiguration = loggingConfiguration
            self.mapRunArn = mapRunArn
            self.name = name
            self.revisionId = revisionId
            self.roleArn = roleArn
            self.stateMachineArn = stateMachineArn
            self.tracingConfiguration = tracingConfiguration
            self.updateDate = updateDate
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case label = "label"
            case loggingConfiguration = "loggingConfiguration"
            case mapRunArn = "mapRunArn"
            case name = "name"
            case revisionId = "revisionId"
            case roleArn = "roleArn"
            case stateMachineArn = "stateMachineArn"
            case tracingConfiguration = "tracingConfiguration"
            case updateDate = "updateDate"
        }
    }

    public struct DescribeStateMachineInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the state machine for which you want the information. If you specify a state machine version ARN, this API returns details about that version. The version ARN is a combination of state machine ARN and the version number separated by a colon (:). For example, stateMachineARN:1.
        public let stateMachineArn: String

        public init(stateMachineArn: String) {
            self.stateMachineArn = stateMachineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, max: 256)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stateMachineArn = "stateMachineArn"
        }
    }

    public struct DescribeStateMachineOutput: AWSDecodableShape {
        /// The date the state machine is created. For a state machine version, creationDate is the date the version was created.
        public let creationDate: Date
        /// The Amazon States Language definition of the state machine. See Amazon States Language.
        public let definition: String
        /// The description of the state machine version.
        public let description: String?
        /// A user-defined or an auto-generated string that identifies a Map state. This parameter is present only if the stateMachineArn specified in input is a qualified state machine ARN.
        public let label: String?
        public let loggingConfiguration: LoggingConfiguration?
        /// The name of the state machine. A name must not contain:   white space   brackets  { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ & , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.
        public let name: String
        /// The revision identifier for the state machine. Use the revisionId parameter to compare between versions of a state machine configuration used for executions without performing a diff of the properties, such as definition and roleArn.
        public let revisionId: String?
        /// The Amazon Resource Name (ARN) of the IAM role used when creating this state machine. (The IAM role maintains security by granting Step Functions access to Amazon Web Services resources.)
        public let roleArn: String
        /// The Amazon Resource Name (ARN) that identifies the state machine. If you specified a state machine version ARN in your request, the API returns the version ARN. The version ARN is a combination of state machine ARN and the version number separated by a colon (:). For example, stateMachineARN:1.
        public let stateMachineArn: String
        /// The current status of the state machine.
        public let status: StateMachineStatus?
        /// Selects whether X-Ray tracing is enabled.
        public let tracingConfiguration: TracingConfiguration?
        /// The type of the state machine (STANDARD or EXPRESS).
        public let type: StateMachineType

        public init(creationDate: Date, definition: String, description: String? = nil, label: String? = nil, loggingConfiguration: LoggingConfiguration? = nil, name: String, revisionId: String? = nil, roleArn: String, stateMachineArn: String, status: StateMachineStatus? = nil, tracingConfiguration: TracingConfiguration? = nil, type: StateMachineType) {
            self.creationDate = creationDate
            self.definition = definition
            self.description = description
            self.label = label
            self.loggingConfiguration = loggingConfiguration
            self.name = name
            self.revisionId = revisionId
            self.roleArn = roleArn
            self.stateMachineArn = stateMachineArn
            self.status = status
            self.tracingConfiguration = tracingConfiguration
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case definition = "definition"
            case description = "description"
            case label = "label"
            case loggingConfiguration = "loggingConfiguration"
            case name = "name"
            case revisionId = "revisionId"
            case roleArn = "roleArn"
            case stateMachineArn = "stateMachineArn"
            case status = "status"
            case tracingConfiguration = "tracingConfiguration"
            case type = "type"
        }
    }

    public struct ExecutionAbortedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct ExecutionFailedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct ExecutionListItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the execution.
        public let executionArn: String
        /// The total number of items processed in a child workflow execution. This field is returned only if mapRunArn was specified in the ListExecutions API action. If stateMachineArn was specified in ListExecutions, the itemCount field isn't returned.
        public let itemCount: Int?
        /// The Amazon Resource Name (ARN) of a Map Run. This field is returned only if mapRunArn was specified in the ListExecutions API action. If stateMachineArn was specified in ListExecutions, the mapRunArn isn't returned.
        public let mapRunArn: String?
        /// The name of the execution. A name must not contain:   white space   brackets  { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ & , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.
        public let name: String
        /// The number of times you've redriven an execution. If you have not yet redriven an execution, the redriveCount is 0. This count is only updated when you successfully redrive an execution.
        public let redriveCount: Int?
        /// The date the execution was last redriven.
        public let redriveDate: Date?
        /// The date the execution started.
        public let startDate: Date
        /// The Amazon Resource Name (ARN) of the state machine alias used to start an execution. If the state machine execution was started with an unqualified ARN or a version ARN, it returns null.
        public let stateMachineAliasArn: String?
        /// The Amazon Resource Name (ARN) of the state machine that ran the execution.
        public let stateMachineArn: String
        /// The Amazon Resource Name (ARN) of the state machine version associated with the execution. If the state machine execution was started with an unqualified ARN, it returns null. If the execution was started using a stateMachineAliasArn, both the stateMachineAliasArn and stateMachineVersionArn parameters contain the respective values.
        public let stateMachineVersionArn: String?
        /// The current status of the execution.
        public let status: ExecutionStatus
        /// If the execution already ended, the date the execution stopped.
        public let stopDate: Date?

        public init(executionArn: String, itemCount: Int? = nil, mapRunArn: String? = nil, name: String, redriveCount: Int? = nil, redriveDate: Date? = nil, startDate: Date, stateMachineAliasArn: String? = nil, stateMachineArn: String, stateMachineVersionArn: String? = nil, status: ExecutionStatus, stopDate: Date? = nil) {
            self.executionArn = executionArn
            self.itemCount = itemCount
            self.mapRunArn = mapRunArn
            self.name = name
            self.redriveCount = redriveCount
            self.redriveDate = redriveDate
            self.startDate = startDate
            self.stateMachineAliasArn = stateMachineAliasArn
            self.stateMachineArn = stateMachineArn
            self.stateMachineVersionArn = stateMachineVersionArn
            self.status = status
            self.stopDate = stopDate
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
            case itemCount = "itemCount"
            case mapRunArn = "mapRunArn"
            case name = "name"
            case redriveCount = "redriveCount"
            case redriveDate = "redriveDate"
            case startDate = "startDate"
            case stateMachineAliasArn = "stateMachineAliasArn"
            case stateMachineArn = "stateMachineArn"
            case stateMachineVersionArn = "stateMachineVersionArn"
            case status = "status"
            case stopDate = "stopDate"
        }
    }

    public struct ExecutionRedrivenEventDetails: AWSDecodableShape {
        /// The number of times you've redriven an execution. If you have not yet redriven an execution, the redriveCount is 0. This count is not updated for redrives that failed to start or are pending to be redriven.
        public let redriveCount: Int?

        public init(redriveCount: Int? = nil) {
            self.redriveCount = redriveCount
        }

        private enum CodingKeys: String, CodingKey {
            case redriveCount = "redriveCount"
        }
    }

    public struct ExecutionStartedEventDetails: AWSDecodableShape {
        /// The JSON data input to the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// Contains details about the input for an execution history event.
        public let inputDetails: HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the IAM role used for executing Lambda tasks.
        public let roleArn: String?
        /// The Amazon Resource Name (ARN) that identifies a state machine alias used for starting the state machine execution.
        public let stateMachineAliasArn: String?
        /// The Amazon Resource Name (ARN) that identifies a state machine version used for starting the state machine execution.
        public let stateMachineVersionArn: String?

        public init(input: String? = nil, inputDetails: HistoryEventExecutionDataDetails? = nil, roleArn: String? = nil, stateMachineAliasArn: String? = nil, stateMachineVersionArn: String? = nil) {
            self.input = input
            self.inputDetails = inputDetails
            self.roleArn = roleArn
            self.stateMachineAliasArn = stateMachineAliasArn
            self.stateMachineVersionArn = stateMachineVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case inputDetails = "inputDetails"
            case roleArn = "roleArn"
            case stateMachineAliasArn = "stateMachineAliasArn"
            case stateMachineVersionArn = "stateMachineVersionArn"
        }
    }

    public struct ExecutionSucceededEventDetails: AWSDecodableShape {
        /// The JSON data output by the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?

        public init(output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil) {
            self.output = output
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case outputDetails = "outputDetails"
        }
    }

    public struct ExecutionTimedOutEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the timeout.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct GetActivityTaskInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the activity to retrieve tasks from (assigned when you create the task using CreateActivity.)
        public let activityArn: String
        /// You can provide an arbitrary name in order to identify the worker that the task is assigned to. This name is used when it is logged in the execution history.
        public let workerName: String?

        public init(activityArn: String, workerName: String? = nil) {
            self.activityArn = activityArn
            self.workerName = workerName
        }

        public func validate(name: String) throws {
            try self.validate(self.activityArn, name: "activityArn", parent: name, max: 256)
            try self.validate(self.activityArn, name: "activityArn", parent: name, min: 1)
            try self.validate(self.workerName, name: "workerName", parent: name, max: 80)
            try self.validate(self.workerName, name: "workerName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
            case workerName = "workerName"
        }
    }

    public struct GetActivityTaskOutput: AWSDecodableShape {
        /// The string that contains the JSON input data for the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// A token that identifies the scheduled task. This token must be copied and included in subsequent calls to SendTaskHeartbeat, SendTaskSuccess or SendTaskFailure in order to report the progress or completion of the task.
        public let taskToken: String?

        public init(input: String? = nil, taskToken: String? = nil) {
            self.input = input
            self.taskToken = taskToken
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case taskToken = "taskToken"
        }
    }

    public struct GetExecutionHistoryInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the execution.
        public let executionArn: String
        /// You can select whether execution data (input or output of a history event) is returned. The default is true.
        public let includeExecutionData: Bool?
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        /// Lists events in descending order of their timeStamp.
        public let reverseOrder: Bool?

        public init(executionArn: String, includeExecutionData: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, reverseOrder: Bool? = nil) {
            self.executionArn = executionArn
            self.includeExecutionData = includeExecutionData
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.reverseOrder = reverseOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.executionArn, name: "executionArn", parent: name, max: 256)
            try self.validate(self.executionArn, name: "executionArn", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
            case includeExecutionData = "includeExecutionData"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case reverseOrder = "reverseOrder"
        }
    }

    public struct GetExecutionHistoryOutput: AWSDecodableShape {
        /// The list of events that occurred in the execution.
        public let events: [HistoryEvent]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(events: [HistoryEvent], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct HistoryEvent: AWSDecodableShape {
        public let activityFailedEventDetails: ActivityFailedEventDetails?
        public let activityScheduledEventDetails: ActivityScheduledEventDetails?
        /// Contains details about an activity schedule event that failed during an execution.
        public let activityScheduleFailedEventDetails: ActivityScheduleFailedEventDetails?
        public let activityStartedEventDetails: ActivityStartedEventDetails?
        public let activitySucceededEventDetails: ActivitySucceededEventDetails?
        public let activityTimedOutEventDetails: ActivityTimedOutEventDetails?
        public let executionAbortedEventDetails: ExecutionAbortedEventDetails?
        public let executionFailedEventDetails: ExecutionFailedEventDetails?
        /// Contains details about the redrive attempt of an execution.
        public let executionRedrivenEventDetails: ExecutionRedrivenEventDetails?
        public let executionStartedEventDetails: ExecutionStartedEventDetails?
        public let executionSucceededEventDetails: ExecutionSucceededEventDetails?
        public let executionTimedOutEventDetails: ExecutionTimedOutEventDetails?
        /// The id of the event. Events are numbered sequentially, starting at one.
        public let id: Int64
        public let lambdaFunctionFailedEventDetails: LambdaFunctionFailedEventDetails?
        public let lambdaFunctionScheduledEventDetails: LambdaFunctionScheduledEventDetails?
        public let lambdaFunctionScheduleFailedEventDetails: LambdaFunctionScheduleFailedEventDetails?
        /// Contains details about a lambda function that failed to start during an execution.
        public let lambdaFunctionStartFailedEventDetails: LambdaFunctionStartFailedEventDetails?
        /// Contains details about a Lambda function that terminated successfully during an execution.
        public let lambdaFunctionSucceededEventDetails: LambdaFunctionSucceededEventDetails?
        public let lambdaFunctionTimedOutEventDetails: LambdaFunctionTimedOutEventDetails?
        /// Contains details about an iteration of a Map state that was aborted.
        public let mapIterationAbortedEventDetails: MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that failed.
        public let mapIterationFailedEventDetails: MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that was started.
        public let mapIterationStartedEventDetails: MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that succeeded.
        public let mapIterationSucceededEventDetails: MapIterationEventDetails?
        /// Contains error and cause details about a Map Run that failed.
        public let mapRunFailedEventDetails: MapRunFailedEventDetails?
        /// Contains details about the redrive attempt of a Map Run.
        public let mapRunRedrivenEventDetails: MapRunRedrivenEventDetails?
        /// Contains details, such as mapRunArn, and the start date and time of a Map Run. mapRunArn is the Amazon Resource Name (ARN) of the Map Run that was started.
        public let mapRunStartedEventDetails: MapRunStartedEventDetails?
        /// Contains details about Map state that was started.
        public let mapStateStartedEventDetails: MapStateStartedEventDetails?
        /// The id of the previous event.
        public let previousEventId: Int64?
        public let stateEnteredEventDetails: StateEnteredEventDetails?
        public let stateExitedEventDetails: StateExitedEventDetails?
        /// Contains details about the failure of a task.
        public let taskFailedEventDetails: TaskFailedEventDetails?
        /// Contains details about a task that was scheduled.
        public let taskScheduledEventDetails: TaskScheduledEventDetails?
        /// Contains details about a task that was started.
        public let taskStartedEventDetails: TaskStartedEventDetails?
        /// Contains details about a task that failed to start.
        public let taskStartFailedEventDetails: TaskStartFailedEventDetails?
        /// Contains details about a task that where the submit failed.
        public let taskSubmitFailedEventDetails: TaskSubmitFailedEventDetails?
        /// Contains details about a submitted task.
        public let taskSubmittedEventDetails: TaskSubmittedEventDetails?
        /// Contains details about a task that succeeded.
        public let taskSucceededEventDetails: TaskSucceededEventDetails?
        /// Contains details about a task that timed out.
        public let taskTimedOutEventDetails: TaskTimedOutEventDetails?
        /// The date and time the event occurred.
        public let timestamp: Date
        /// The type of the event.
        public let type: HistoryEventType

        public init(activityFailedEventDetails: ActivityFailedEventDetails? = nil, activityScheduledEventDetails: ActivityScheduledEventDetails? = nil, activityScheduleFailedEventDetails: ActivityScheduleFailedEventDetails? = nil, activityStartedEventDetails: ActivityStartedEventDetails? = nil, activitySucceededEventDetails: ActivitySucceededEventDetails? = nil, activityTimedOutEventDetails: ActivityTimedOutEventDetails? = nil, executionAbortedEventDetails: ExecutionAbortedEventDetails? = nil, executionFailedEventDetails: ExecutionFailedEventDetails? = nil, executionRedrivenEventDetails: ExecutionRedrivenEventDetails? = nil, executionStartedEventDetails: ExecutionStartedEventDetails? = nil, executionSucceededEventDetails: ExecutionSucceededEventDetails? = nil, executionTimedOutEventDetails: ExecutionTimedOutEventDetails? = nil, id: Int64, lambdaFunctionFailedEventDetails: LambdaFunctionFailedEventDetails? = nil, lambdaFunctionScheduledEventDetails: LambdaFunctionScheduledEventDetails? = nil, lambdaFunctionScheduleFailedEventDetails: LambdaFunctionScheduleFailedEventDetails? = nil, lambdaFunctionStartFailedEventDetails: LambdaFunctionStartFailedEventDetails? = nil, lambdaFunctionSucceededEventDetails: LambdaFunctionSucceededEventDetails? = nil, lambdaFunctionTimedOutEventDetails: LambdaFunctionTimedOutEventDetails? = nil, mapIterationAbortedEventDetails: MapIterationEventDetails? = nil, mapIterationFailedEventDetails: MapIterationEventDetails? = nil, mapIterationStartedEventDetails: MapIterationEventDetails? = nil, mapIterationSucceededEventDetails: MapIterationEventDetails? = nil, mapRunFailedEventDetails: MapRunFailedEventDetails? = nil, mapRunRedrivenEventDetails: MapRunRedrivenEventDetails? = nil, mapRunStartedEventDetails: MapRunStartedEventDetails? = nil, mapStateStartedEventDetails: MapStateStartedEventDetails? = nil, previousEventId: Int64? = nil, stateEnteredEventDetails: StateEnteredEventDetails? = nil, stateExitedEventDetails: StateExitedEventDetails? = nil, taskFailedEventDetails: TaskFailedEventDetails? = nil, taskScheduledEventDetails: TaskScheduledEventDetails? = nil, taskStartedEventDetails: TaskStartedEventDetails? = nil, taskStartFailedEventDetails: TaskStartFailedEventDetails? = nil, taskSubmitFailedEventDetails: TaskSubmitFailedEventDetails? = nil, taskSubmittedEventDetails: TaskSubmittedEventDetails? = nil, taskSucceededEventDetails: TaskSucceededEventDetails? = nil, taskTimedOutEventDetails: TaskTimedOutEventDetails? = nil, timestamp: Date, type: HistoryEventType) {
            self.activityFailedEventDetails = activityFailedEventDetails
            self.activityScheduledEventDetails = activityScheduledEventDetails
            self.activityScheduleFailedEventDetails = activityScheduleFailedEventDetails
            self.activityStartedEventDetails = activityStartedEventDetails
            self.activitySucceededEventDetails = activitySucceededEventDetails
            self.activityTimedOutEventDetails = activityTimedOutEventDetails
            self.executionAbortedEventDetails = executionAbortedEventDetails
            self.executionFailedEventDetails = executionFailedEventDetails
            self.executionRedrivenEventDetails = executionRedrivenEventDetails
            self.executionStartedEventDetails = executionStartedEventDetails
            self.executionSucceededEventDetails = executionSucceededEventDetails
            self.executionTimedOutEventDetails = executionTimedOutEventDetails
            self.id = id
            self.lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetails
            self.lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetails
            self.lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetails
            self.lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetails
            self.lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetails
            self.lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetails
            self.mapIterationAbortedEventDetails = mapIterationAbortedEventDetails
            self.mapIterationFailedEventDetails = mapIterationFailedEventDetails
            self.mapIterationStartedEventDetails = mapIterationStartedEventDetails
            self.mapIterationSucceededEventDetails = mapIterationSucceededEventDetails
            self.mapRunFailedEventDetails = mapRunFailedEventDetails
            self.mapRunRedrivenEventDetails = mapRunRedrivenEventDetails
            self.mapRunStartedEventDetails = mapRunStartedEventDetails
            self.mapStateStartedEventDetails = mapStateStartedEventDetails
            self.previousEventId = previousEventId
            self.stateEnteredEventDetails = stateEnteredEventDetails
            self.stateExitedEventDetails = stateExitedEventDetails
            self.taskFailedEventDetails = taskFailedEventDetails
            self.taskScheduledEventDetails = taskScheduledEventDetails
            self.taskStartedEventDetails = taskStartedEventDetails
            self.taskStartFailedEventDetails = taskStartFailedEventDetails
            self.taskSubmitFailedEventDetails = taskSubmitFailedEventDetails
            self.taskSubmittedEventDetails = taskSubmittedEventDetails
            self.taskSucceededEventDetails = taskSucceededEventDetails
            self.taskTimedOutEventDetails = taskTimedOutEventDetails
            self.timestamp = timestamp
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case activityFailedEventDetails = "activityFailedEventDetails"
            case activityScheduledEventDetails = "activityScheduledEventDetails"
            case activityScheduleFailedEventDetails = "activityScheduleFailedEventDetails"
            case activityStartedEventDetails = "activityStartedEventDetails"
            case activitySucceededEventDetails = "activitySucceededEventDetails"
            case activityTimedOutEventDetails = "activityTimedOutEventDetails"
            case executionAbortedEventDetails = "executionAbortedEventDetails"
            case executionFailedEventDetails = "executionFailedEventDetails"
            case executionRedrivenEventDetails = "executionRedrivenEventDetails"
            case executionStartedEventDetails = "executionStartedEventDetails"
            case executionSucceededEventDetails = "executionSucceededEventDetails"
            case executionTimedOutEventDetails = "executionTimedOutEventDetails"
            case id = "id"
            case lambdaFunctionFailedEventDetails = "lambdaFunctionFailedEventDetails"
            case lambdaFunctionScheduledEventDetails = "lambdaFunctionScheduledEventDetails"
            case lambdaFunctionScheduleFailedEventDetails = "lambdaFunctionScheduleFailedEventDetails"
            case lambdaFunctionStartFailedEventDetails = "lambdaFunctionStartFailedEventDetails"
            case lambdaFunctionSucceededEventDetails = "lambdaFunctionSucceededEventDetails"
            case lambdaFunctionTimedOutEventDetails = "lambdaFunctionTimedOutEventDetails"
            case mapIterationAbortedEventDetails = "mapIterationAbortedEventDetails"
            case mapIterationFailedEventDetails = "mapIterationFailedEventDetails"
            case mapIterationStartedEventDetails = "mapIterationStartedEventDetails"
            case mapIterationSucceededEventDetails = "mapIterationSucceededEventDetails"
            case mapRunFailedEventDetails = "mapRunFailedEventDetails"
            case mapRunRedrivenEventDetails = "mapRunRedrivenEventDetails"
            case mapRunStartedEventDetails = "mapRunStartedEventDetails"
            case mapStateStartedEventDetails = "mapStateStartedEventDetails"
            case previousEventId = "previousEventId"
            case stateEnteredEventDetails = "stateEnteredEventDetails"
            case stateExitedEventDetails = "stateExitedEventDetails"
            case taskFailedEventDetails = "taskFailedEventDetails"
            case taskScheduledEventDetails = "taskScheduledEventDetails"
            case taskStartedEventDetails = "taskStartedEventDetails"
            case taskStartFailedEventDetails = "taskStartFailedEventDetails"
            case taskSubmitFailedEventDetails = "taskSubmitFailedEventDetails"
            case taskSubmittedEventDetails = "taskSubmittedEventDetails"
            case taskSucceededEventDetails = "taskSucceededEventDetails"
            case taskTimedOutEventDetails = "taskTimedOutEventDetails"
            case timestamp = "timestamp"
            case type = "type"
        }
    }

    public struct HistoryEventExecutionDataDetails: AWSDecodableShape {
        /// Indicates whether input or output was truncated in the response. Always false for API calls.
        public let truncated: Bool?

        public init(truncated: Bool? = nil) {
            self.truncated = truncated
        }

        private enum CodingKeys: String, CodingKey {
            case truncated = "truncated"
        }
    }

    public struct InspectionData: AWSDecodableShape {
        /// The input after Step Functions applies the InputPath filter.
        public let afterInputPath: String?
        /// The effective input after Step Functions applies the Parameters filter.
        public let afterParameters: String?
        /// The effective result combined with the raw state input after Step Functions applies the ResultPath filter.
        public let afterResultPath: String?
        /// The effective result after Step Functions applies the ResultSelector filter.
        public let afterResultSelector: String?
        /// The raw state input.
        public let input: String?
        /// The raw HTTP request that is sent when you test an HTTP Task.
        public let request: InspectionDataRequest?
        /// The raw HTTP response that is returned when you test an HTTP Task.
        public let response: InspectionDataResponse?
        /// The state's raw result.
        public let result: String?

        public init(afterInputPath: String? = nil, afterParameters: String? = nil, afterResultPath: String? = nil, afterResultSelector: String? = nil, input: String? = nil, request: InspectionDataRequest? = nil, response: InspectionDataResponse? = nil, result: String? = nil) {
            self.afterInputPath = afterInputPath
            self.afterParameters = afterParameters
            self.afterResultPath = afterResultPath
            self.afterResultSelector = afterResultSelector
            self.input = input
            self.request = request
            self.response = response
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case afterInputPath = "afterInputPath"
            case afterParameters = "afterParameters"
            case afterResultPath = "afterResultPath"
            case afterResultSelector = "afterResultSelector"
            case input = "input"
            case request = "request"
            case response = "response"
            case result = "result"
        }
    }

    public struct InspectionDataRequest: AWSDecodableShape {
        /// The request body for the HTTP request.
        public let body: String?
        /// The request headers associated with the HTTP request.
        public let headers: String?
        /// The HTTP method used for the HTTP request.
        public let method: String?
        /// The protocol used to make the HTTP request.
        public let `protocol`: String?
        /// The API endpoint used for the HTTP request.
        public let url: String?

        public init(body: String? = nil, headers: String? = nil, method: String? = nil, protocol: String? = nil, url: String? = nil) {
            self.body = body
            self.headers = headers
            self.method = method
            self.`protocol` = `protocol`
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
            case headers = "headers"
            case method = "method"
            case `protocol` = "protocol"
            case url = "url"
        }
    }

    public struct InspectionDataResponse: AWSDecodableShape {
        /// The HTTP response returned.
        public let body: String?
        /// The response headers associated with the HTTP response.
        public let headers: String?
        /// The protocol used to return the HTTP response.
        public let `protocol`: String?
        /// The HTTP response status code for the HTTP response.
        public let statusCode: String?
        /// The message associated with the HTTP status code.
        public let statusMessage: String?

        public init(body: String? = nil, headers: String? = nil, protocol: String? = nil, statusCode: String? = nil, statusMessage: String? = nil) {
            self.body = body
            self.headers = headers
            self.`protocol` = `protocol`
            self.statusCode = statusCode
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
            case headers = "headers"
            case `protocol` = "protocol"
            case statusCode = "statusCode"
            case statusMessage = "statusMessage"
        }
    }

    public struct LambdaFunctionFailedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct LambdaFunctionScheduleFailedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct LambdaFunctionScheduledEventDetails: AWSDecodableShape {
        /// The JSON data input to the Lambda function. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// Contains details about input for an execution history event.
        public let inputDetails: HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the scheduled Lambda function.
        public let resource: String
        /// The credentials that Step Functions uses for the task.
        public let taskCredentials: TaskCredentials?
        /// The maximum allowed duration of the Lambda function.
        public let timeoutInSeconds: Int64?

        public init(input: String? = nil, inputDetails: HistoryEventExecutionDataDetails? = nil, resource: String, taskCredentials: TaskCredentials? = nil, timeoutInSeconds: Int64? = nil) {
            self.input = input
            self.inputDetails = inputDetails
            self.resource = resource
            self.taskCredentials = taskCredentials
            self.timeoutInSeconds = timeoutInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case inputDetails = "inputDetails"
            case resource = "resource"
            case taskCredentials = "taskCredentials"
            case timeoutInSeconds = "timeoutInSeconds"
        }
    }

    public struct LambdaFunctionStartFailedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct LambdaFunctionSucceededEventDetails: AWSDecodableShape {
        /// The JSON data output by the Lambda function. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?

        public init(output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil) {
            self.output = output
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case outputDetails = "outputDetails"
        }
    }

    public struct LambdaFunctionTimedOutEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the timeout.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct ListActivitiesInput: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListActivitiesOutput: AWSDecodableShape {
        /// The list of activities.
        public let activities: [ActivityListItem]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(activities: [ActivityListItem], nextToken: String? = nil) {
            self.activities = activities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case activities = "activities"
            case nextToken = "nextToken"
        }
    }

    public struct ListExecutionsInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Map Run that started the child workflow executions. If the mapRunArn field is specified, a list of all of the child workflow executions started by a Map Run is returned. For more information, see Examining Map Run in the Step Functions Developer Guide. You can specify either a mapRunArn or a stateMachineArn, but not both.
        public let mapRunArn: String?
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        /// Sets a filter to list executions based on whether or not they have been redriven. For a Distributed Map, redriveFilter sets a filter to list child workflow executions based on whether or not they have been redriven. If you do not provide a redriveFilter, Step Functions returns a list of both redriven and non-redriven executions. If you provide a state machine ARN in redriveFilter, the API returns a validation exception.
        public let redriveFilter: ExecutionRedriveFilter?
        /// The Amazon Resource Name (ARN) of the state machine whose executions is listed. You can specify either a mapRunArn or a stateMachineArn, but not both. You can also return a list of executions associated with a specific alias or version, by specifying an alias ARN or a version ARN in the stateMachineArn parameter.
        public let stateMachineArn: String?
        /// If specified, only list the executions whose current execution status matches the given filter.
        public let statusFilter: ExecutionStatus?

        public init(mapRunArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, redriveFilter: ExecutionRedriveFilter? = nil, stateMachineArn: String? = nil, statusFilter: ExecutionStatus? = nil) {
            self.mapRunArn = mapRunArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.redriveFilter = redriveFilter
            self.stateMachineArn = stateMachineArn
            self.statusFilter = statusFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.mapRunArn, name: "mapRunArn", parent: name, max: 2000)
            try self.validate(self.mapRunArn, name: "mapRunArn", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, max: 256)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case mapRunArn = "mapRunArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case redriveFilter = "redriveFilter"
            case stateMachineArn = "stateMachineArn"
            case statusFilter = "statusFilter"
        }
    }

    public struct ListExecutionsOutput: AWSDecodableShape {
        /// The list of matching executions.
        public let executions: [ExecutionListItem]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(executions: [ExecutionListItem], nextToken: String? = nil) {
            self.executions = executions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case executions = "executions"
            case nextToken = "nextToken"
        }
    }

    public struct ListMapRunsInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the execution for which the Map Runs must be listed.
        public let executionArn: String
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(executionArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.executionArn = executionArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.executionArn, name: "executionArn", parent: name, max: 256)
            try self.validate(self.executionArn, name: "executionArn", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListMapRunsOutput: AWSDecodableShape {
        /// An array that lists information related to a Map Run, such as the Amazon Resource Name (ARN) of the Map Run and the ARN of the state machine that started the Map Run.
        public let mapRuns: [MapRunListItem]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(mapRuns: [MapRunListItem], nextToken: String? = nil) {
            self.mapRuns = mapRuns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case mapRuns = "mapRuns"
            case nextToken = "nextToken"
        }
    }

    public struct ListStateMachineAliasesInput: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the state machine for which you want to list aliases. If you specify a state machine version ARN, this API returns a list of aliases for that version.
        public let stateMachineArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, stateMachineArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.stateMachineArn = stateMachineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, max: 256)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case stateMachineArn = "stateMachineArn"
        }
    }

    public struct ListStateMachineAliasesOutput: AWSDecodableShape {
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        /// Aliases for the state machine.
        public let stateMachineAliases: [StateMachineAliasListItem]

        public init(nextToken: String? = nil, stateMachineAliases: [StateMachineAliasListItem]) {
            self.nextToken = nextToken
            self.stateMachineAliases = stateMachineAliases
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stateMachineAliases = "stateMachineAliases"
        }
    }

    public struct ListStateMachineVersionsInput: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the state machine.
        public let stateMachineArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, stateMachineArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.stateMachineArn = stateMachineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, max: 256)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case stateMachineArn = "stateMachineArn"
        }
    }

    public struct ListStateMachineVersionsOutput: AWSDecodableShape {
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        /// Versions for the state machine.
        public let stateMachineVersions: [StateMachineVersionListItem]

        public init(nextToken: String? = nil, stateMachineVersions: [StateMachineVersionListItem]) {
            self.nextToken = nextToken
            self.stateMachineVersions = stateMachineVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stateMachineVersions = "stateMachineVersions"
        }
    }

    public struct ListStateMachinesInput: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListStateMachinesOutput: AWSDecodableShape {
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        public let stateMachines: [StateMachineListItem]

        public init(nextToken: String? = nil, stateMachines: [StateMachineListItem]) {
            self.nextToken = nextToken
            self.stateMachines = stateMachines
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stateMachines = "stateMachines"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// An array of tags associated with the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LogDestination: AWSEncodableShape & AWSDecodableShape {
        /// An object describing a CloudWatch log group. For more information, see AWS::Logs::LogGroup in the CloudFormation User Guide.
        public let cloudWatchLogsLogGroup: CloudWatchLogsLogGroup?

        public init(cloudWatchLogsLogGroup: CloudWatchLogsLogGroup? = nil) {
            self.cloudWatchLogsLogGroup = cloudWatchLogsLogGroup
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogsLogGroup?.validate(name: "\(name).cloudWatchLogsLogGroup")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroup = "cloudWatchLogsLogGroup"
        }
    }

    public struct LoggingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An array of objects that describes where your execution history events will be logged. Limited to size 1. Required, if your log level is not set to OFF.
        public let destinations: [LogDestination]?
        /// Determines whether execution data is included in your log. When set to false, data is excluded.
        public let includeExecutionData: Bool?
        /// Defines which category of execution history events are logged.
        public let level: LogLevel?

        public init(destinations: [LogDestination]? = nil, includeExecutionData: Bool? = nil, level: LogLevel? = nil) {
            self.destinations = destinations
            self.includeExecutionData = includeExecutionData
            self.level = level
        }

        public func validate(name: String) throws {
            try self.destinations?.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "destinations"
            case includeExecutionData = "includeExecutionData"
            case level = "level"
        }
    }

    public struct MapIterationEventDetails: AWSDecodableShape {
        /// The index of the array belonging to the Map state iteration.
        public let index: Int?
        /// The name of the iteration’s parent Map state.
        public let name: String?

        public init(index: Int? = nil, name: String? = nil) {
            self.index = index
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case index = "index"
            case name = "name"
        }
    }

    public struct MapRunExecutionCounts: AWSDecodableShape {
        /// The total number of child workflow executions that were started by a Map Run and were running, but were either stopped by the user or by Step Functions because the Map Run failed.
        public let aborted: Int64
        /// The total number of child workflow executions that were started by a Map Run, but have failed.
        public let failed: Int64
        /// The number of FAILED, ABORTED, or TIMED_OUT child workflow executions that cannot be redriven because their execution status is terminal. For example, child workflows with an execution status of FAILED, ABORTED, or TIMED_OUT and a redriveStatus of NOT_REDRIVABLE.
        public let failuresNotRedrivable: Int64?
        /// The total number of child workflow executions that were started by a Map Run, but haven't started executing yet.
        public let pending: Int64
        /// The number of unsuccessful child workflow executions currently waiting to be redriven. The status of these child workflow executions could be FAILED, ABORTED, or TIMED_OUT in the original execution attempt or a previous redrive attempt.
        public let pendingRedrive: Int64?
        /// Returns the count of child workflow executions whose results were written by ResultWriter. For more information, see ResultWriter in the Step Functions Developer Guide.
        public let resultsWritten: Int64
        /// The total number of child workflow executions that were started by a Map Run and are currently in-progress.
        public let running: Int64
        /// The total number of child workflow executions that were started by a Map Run and have completed successfully.
        public let succeeded: Int64
        /// The total number of child workflow executions that were started by a Map Run and have timed out.
        public let timedOut: Int64
        /// The total number of child workflow executions that were started by a Map Run.
        public let total: Int64

        public init(aborted: Int64, failed: Int64, failuresNotRedrivable: Int64? = nil, pending: Int64, pendingRedrive: Int64? = nil, resultsWritten: Int64, running: Int64, succeeded: Int64, timedOut: Int64, total: Int64) {
            self.aborted = aborted
            self.failed = failed
            self.failuresNotRedrivable = failuresNotRedrivable
            self.pending = pending
            self.pendingRedrive = pendingRedrive
            self.resultsWritten = resultsWritten
            self.running = running
            self.succeeded = succeeded
            self.timedOut = timedOut
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case aborted = "aborted"
            case failed = "failed"
            case failuresNotRedrivable = "failuresNotRedrivable"
            case pending = "pending"
            case pendingRedrive = "pendingRedrive"
            case resultsWritten = "resultsWritten"
            case running = "running"
            case succeeded = "succeeded"
            case timedOut = "timedOut"
            case total = "total"
        }
    }

    public struct MapRunFailedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the Map Run failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct MapRunItemCounts: AWSDecodableShape {
        /// The total number of items processed in child workflow executions that were either stopped by the user or by Step Functions, because the Map Run failed.
        public let aborted: Int64
        /// The total number of items processed in child workflow executions that have failed.
        public let failed: Int64
        /// The number of FAILED, ABORTED, or TIMED_OUT items in child workflow executions that cannot be redriven because the execution status of those child workflows is terminal. For example, child workflows with an execution status of FAILED, ABORTED, or TIMED_OUT and a redriveStatus of NOT_REDRIVABLE.
        public let failuresNotRedrivable: Int64?
        /// The total number of items to process in child workflow executions that haven't started running yet.
        public let pending: Int64
        /// The number of unsuccessful items in child workflow executions currently waiting to be redriven.
        public let pendingRedrive: Int64?
        /// Returns the count of items whose results were written by ResultWriter. For more information, see ResultWriter in the Step Functions Developer Guide.
        public let resultsWritten: Int64
        /// The total number of items being processed in child workflow executions that are currently in-progress.
        public let running: Int64
        /// The total number of items processed in child workflow executions that have completed successfully.
        public let succeeded: Int64
        /// The total number of items processed in child workflow executions that have timed out.
        public let timedOut: Int64
        /// The total number of items processed in all the child workflow executions started by a Map Run.
        public let total: Int64

        public init(aborted: Int64, failed: Int64, failuresNotRedrivable: Int64? = nil, pending: Int64, pendingRedrive: Int64? = nil, resultsWritten: Int64, running: Int64, succeeded: Int64, timedOut: Int64, total: Int64) {
            self.aborted = aborted
            self.failed = failed
            self.failuresNotRedrivable = failuresNotRedrivable
            self.pending = pending
            self.pendingRedrive = pendingRedrive
            self.resultsWritten = resultsWritten
            self.running = running
            self.succeeded = succeeded
            self.timedOut = timedOut
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case aborted = "aborted"
            case failed = "failed"
            case failuresNotRedrivable = "failuresNotRedrivable"
            case pending = "pending"
            case pendingRedrive = "pendingRedrive"
            case resultsWritten = "resultsWritten"
            case running = "running"
            case succeeded = "succeeded"
            case timedOut = "timedOut"
            case total = "total"
        }
    }

    public struct MapRunListItem: AWSDecodableShape {
        /// The executionArn of the execution from which the Map Run was started.
        public let executionArn: String
        /// The Amazon Resource Name (ARN) of the Map Run.
        public let mapRunArn: String
        /// The date on which the Map Run started.
        public let startDate: Date
        /// The Amazon Resource Name (ARN) of the executed state machine.
        public let stateMachineArn: String
        /// The date on which the Map Run stopped.
        public let stopDate: Date?

        public init(executionArn: String, mapRunArn: String, startDate: Date, stateMachineArn: String, stopDate: Date? = nil) {
            self.executionArn = executionArn
            self.mapRunArn = mapRunArn
            self.startDate = startDate
            self.stateMachineArn = stateMachineArn
            self.stopDate = stopDate
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
            case mapRunArn = "mapRunArn"
            case startDate = "startDate"
            case stateMachineArn = "stateMachineArn"
            case stopDate = "stopDate"
        }
    }

    public struct MapRunRedrivenEventDetails: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a Map Run that was redriven.
        public let mapRunArn: String?
        /// The number of times the Map Run has been redriven at this point in the execution's history including this event. The redrive count for a redriven Map Run is always greater than 0.
        public let redriveCount: Int?

        public init(mapRunArn: String? = nil, redriveCount: Int? = nil) {
            self.mapRunArn = mapRunArn
            self.redriveCount = redriveCount
        }

        private enum CodingKeys: String, CodingKey {
            case mapRunArn = "mapRunArn"
            case redriveCount = "redriveCount"
        }
    }

    public struct MapRunStartedEventDetails: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a Map Run that was started.
        public let mapRunArn: String?

        public init(mapRunArn: String? = nil) {
            self.mapRunArn = mapRunArn
        }

        private enum CodingKeys: String, CodingKey {
            case mapRunArn = "mapRunArn"
        }
    }

    public struct MapStateStartedEventDetails: AWSDecodableShape {
        /// The size of the array for Map state iterations.
        public let length: Int?

        public init(length: Int? = nil) {
            self.length = length
        }

        private enum CodingKeys: String, CodingKey {
            case length = "length"
        }
    }

    public struct PublishStateMachineVersionInput: AWSEncodableShape {
        /// An optional description of the state machine version.
        public let description: String?
        /// Only publish the state machine version if the current state machine's revision ID matches the specified ID. Use this option to avoid publishing a version if the state machine changed since you last updated it. If the specified revision ID doesn't match the state machine's current revision ID, the API returns ConflictException.  To specify an initial revision ID for a state machine with no revision ID assigned, specify the string INITIAL for the revisionId parameter. For example, you can specify a revisionID of INITIAL when you create a state machine using the CreateStateMachine API action.
        public let revisionId: String?
        /// The Amazon Resource Name (ARN) of the state machine.
        public let stateMachineArn: String

        public init(description: String? = nil, revisionId: String? = nil, stateMachineArn: String) {
            self.description = description
            self.revisionId = revisionId
            self.stateMachineArn = stateMachineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, max: 256)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case revisionId = "revisionId"
            case stateMachineArn = "stateMachineArn"
        }
    }

    public struct PublishStateMachineVersionOutput: AWSDecodableShape {
        /// The date the version was created.
        public let creationDate: Date
        /// The Amazon Resource Name (ARN) (ARN) that identifies the state machine version.
        public let stateMachineVersionArn: String

        public init(creationDate: Date, stateMachineVersionArn: String) {
            self.creationDate = creationDate
            self.stateMachineVersionArn = stateMachineVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case stateMachineVersionArn = "stateMachineVersionArn"
        }
    }

    public struct RedriveExecutionInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The API will return idempotent responses for the last 10 client tokens used to successfully redrive the execution. These client tokens are valid for up to 15 minutes after they are first used.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the execution to be redriven.
        public let executionArn: String

        public init(clientToken: String? = RedriveExecutionInput.idempotencyToken(), executionArn: String) {
            self.clientToken = clientToken
            self.executionArn = executionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.executionArn, name: "executionArn", parent: name, max: 256)
            try self.validate(self.executionArn, name: "executionArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case executionArn = "executionArn"
        }
    }

    public struct RedriveExecutionOutput: AWSDecodableShape {
        /// The date the execution was last redriven.
        public let redriveDate: Date

        public init(redriveDate: Date) {
            self.redriveDate = redriveDate
        }

        private enum CodingKeys: String, CodingKey {
            case redriveDate = "redriveDate"
        }
    }

    public struct RoutingConfigurationListItem: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies one or two state machine versions defined in the routing configuration. If you specify the ARN of a second version, it must belong to the same state machine as the first version.
        public let stateMachineVersionArn: String
        /// The percentage of traffic you want to route to a state machine version. The sum of the weights in the routing configuration must be equal to 100.
        public let weight: Int

        public init(stateMachineVersionArn: String, weight: Int) {
            self.stateMachineVersionArn = stateMachineVersionArn
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.stateMachineVersionArn, name: "stateMachineVersionArn", parent: name, max: 256)
            try self.validate(self.stateMachineVersionArn, name: "stateMachineVersionArn", parent: name, min: 1)
            try self.validate(self.weight, name: "weight", parent: name, max: 100)
            try self.validate(self.weight, name: "weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case stateMachineVersionArn = "stateMachineVersionArn"
            case weight = "weight"
        }
    }

    public struct SendTaskFailureInput: AWSEncodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the context object when a workflow enters a task state. See GetActivityTaskOutput$taskToken.
        public let taskToken: String

        public init(cause: String? = nil, error: String? = nil, taskToken: String) {
            self.cause = cause
            self.error = error
            self.taskToken = taskToken
        }

        public func validate(name: String) throws {
            try self.validate(self.cause, name: "cause", parent: name, max: 32768)
            try self.validate(self.error, name: "error", parent: name, max: 256)
            try self.validate(self.taskToken, name: "taskToken", parent: name, max: 1024)
            try self.validate(self.taskToken, name: "taskToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case taskToken = "taskToken"
        }
    }

    public struct SendTaskFailureOutput: AWSDecodableShape {
        public init() {}
    }

    public struct SendTaskHeartbeatInput: AWSEncodableShape {
        /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the context object when a workflow enters a task state. See GetActivityTaskOutput$taskToken.
        public let taskToken: String

        public init(taskToken: String) {
            self.taskToken = taskToken
        }

        public func validate(name: String) throws {
            try self.validate(self.taskToken, name: "taskToken", parent: name, max: 1024)
            try self.validate(self.taskToken, name: "taskToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case taskToken = "taskToken"
        }
    }

    public struct SendTaskHeartbeatOutput: AWSDecodableShape {
        public init() {}
    }

    public struct SendTaskSuccessInput: AWSEncodableShape {
        /// The JSON output of the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String
        /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the context object when a workflow enters a task state. See GetActivityTaskOutput$taskToken.
        public let taskToken: String

        public init(output: String, taskToken: String) {
            self.output = output
            self.taskToken = taskToken
        }

        public func validate(name: String) throws {
            try self.validate(self.output, name: "output", parent: name, max: 262144)
            try self.validate(self.taskToken, name: "taskToken", parent: name, max: 1024)
            try self.validate(self.taskToken, name: "taskToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case taskToken = "taskToken"
        }
    }

    public struct SendTaskSuccessOutput: AWSDecodableShape {
        public init() {}
    }

    public struct StartExecutionInput: AWSEncodableShape {
        /// The string that contains the JSON input data for the execution, for example:  "input": "{\"first_name\" : \"test\"}"   If you don't include any JSON input data, you still must include the two braces, for example: "input": "{}"   Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// Optional name of the execution. This name must be unique for your Amazon Web Services account, Region, and state machine for 90 days. For more information, see  Limits Related to State Machine Executions in the Step Functions Developer Guide. If you don't provide a name for the execution, Step Functions automatically generates a universally unique identifier (UUID) as the execution name. A name must not contain:   white space   brackets  { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ & , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the state machine to execute. The stateMachineArn parameter accepts one of the following inputs:    An unqualified state machine ARN – Refers to a state machine ARN that isn't qualified with a version or alias ARN. The following is an example of an unqualified state machine ARN.  arn::states:::stateMachine:  Step Functions doesn't associate state machine executions that you start with an unqualified ARN with a version. This is true even if that version uses the same revision that the execution used.    A state machine version ARN – Refers to a version ARN, which is a combination of state machine ARN and the version number separated by a colon (:). The following is an example of the ARN for version 10.   arn::states:::stateMachine::10  Step Functions doesn't associate executions that you start with a version ARN with any aliases that point to that version.    A state machine alias ARN – Refers to an alias ARN, which is a combination of state machine ARN and the alias name separated by a colon (:). The following is an example of the ARN for an alias named PROD.  arn::states:::stateMachine:  Step Functions associates executions that you start with an alias ARN with that alias and the state machine version used for that execution.
        public let stateMachineArn: String
        /// Passes the X-Ray trace header. The trace header can also be passed in the request payload.
        public let traceHeader: String?

        public init(input: String? = nil, name: String? = nil, stateMachineArn: String, traceHeader: String? = nil) {
            self.input = input
            self.name = name
            self.stateMachineArn = stateMachineArn
            self.traceHeader = traceHeader
        }

        public func validate(name: String) throws {
            try self.validate(self.input, name: "input", parent: name, max: 262144)
            try self.validate(self.name, name: "name", parent: name, max: 80)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, max: 256)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, min: 1)
            try self.validate(self.traceHeader, name: "traceHeader", parent: name, max: 256)
            try self.validate(self.traceHeader, name: "traceHeader", parent: name, pattern: "^\\p{ASCII}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case name = "name"
            case stateMachineArn = "stateMachineArn"
            case traceHeader = "traceHeader"
        }
    }

    public struct StartExecutionOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies the execution.
        public let executionArn: String
        /// The date the execution is started.
        public let startDate: Date

        public init(executionArn: String, startDate: Date) {
            self.executionArn = executionArn
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
            case startDate = "startDate"
        }
    }

    public struct StartSyncExecutionInput: AWSEncodableShape {
        /// The string that contains the JSON input data for the execution, for example:  "input": "{\"first_name\" : \"test\"}"   If you don't include any JSON input data, you still must include the two braces, for example: "input": "{}"   Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// The name of the execution.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the state machine to execute.
        public let stateMachineArn: String
        /// Passes the X-Ray trace header. The trace header can also be passed in the request payload.
        public let traceHeader: String?

        public init(input: String? = nil, name: String? = nil, stateMachineArn: String, traceHeader: String? = nil) {
            self.input = input
            self.name = name
            self.stateMachineArn = stateMachineArn
            self.traceHeader = traceHeader
        }

        public func validate(name: String) throws {
            try self.validate(self.input, name: "input", parent: name, max: 262144)
            try self.validate(self.name, name: "name", parent: name, max: 80)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, max: 256)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, min: 1)
            try self.validate(self.traceHeader, name: "traceHeader", parent: name, max: 256)
            try self.validate(self.traceHeader, name: "traceHeader", parent: name, pattern: "^\\p{ASCII}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case name = "name"
            case stateMachineArn = "stateMachineArn"
            case traceHeader = "traceHeader"
        }
    }

    public struct StartSyncExecutionOutput: AWSDecodableShape {
        /// An object that describes workflow billing details, including billed duration and memory use.
        public let billingDetails: BillingDetails?
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The Amazon Resource Name (ARN) that identifies the execution.
        public let executionArn: String
        /// The string that contains the JSON input data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        public let inputDetails: CloudWatchEventsExecutionDataDetails?
        /// The name of the execution.
        public let name: String?
        /// The JSON output data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.  This field is set only if the execution succeeds. If the execution fails, this field is null.
        public let output: String?
        public let outputDetails: CloudWatchEventsExecutionDataDetails?
        /// The date the execution is started.
        public let startDate: Date
        /// The Amazon Resource Name (ARN) that identifies the state machine.
        public let stateMachineArn: String?
        /// The current status of the execution.
        public let status: SyncExecutionStatus
        /// If the execution has already ended, the date the execution stopped.
        public let stopDate: Date
        /// The X-Ray trace header that was passed to the execution.
        public let traceHeader: String?

        public init(billingDetails: BillingDetails? = nil, cause: String? = nil, error: String? = nil, executionArn: String, input: String? = nil, inputDetails: CloudWatchEventsExecutionDataDetails? = nil, name: String? = nil, output: String? = nil, outputDetails: CloudWatchEventsExecutionDataDetails? = nil, startDate: Date, stateMachineArn: String? = nil, status: SyncExecutionStatus, stopDate: Date, traceHeader: String? = nil) {
            self.billingDetails = billingDetails
            self.cause = cause
            self.error = error
            self.executionArn = executionArn
            self.input = input
            self.inputDetails = inputDetails
            self.name = name
            self.output = output
            self.outputDetails = outputDetails
            self.startDate = startDate
            self.stateMachineArn = stateMachineArn
            self.status = status
            self.stopDate = stopDate
            self.traceHeader = traceHeader
        }

        private enum CodingKeys: String, CodingKey {
            case billingDetails = "billingDetails"
            case cause = "cause"
            case error = "error"
            case executionArn = "executionArn"
            case input = "input"
            case inputDetails = "inputDetails"
            case name = "name"
            case output = "output"
            case outputDetails = "outputDetails"
            case startDate = "startDate"
            case stateMachineArn = "stateMachineArn"
            case status = "status"
            case stopDate = "stopDate"
            case traceHeader = "traceHeader"
        }
    }

    public struct StateEnteredEventDetails: AWSDecodableShape {
        /// The string that contains the JSON input data for the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// Contains details about the input for an execution history event.
        public let inputDetails: HistoryEventExecutionDataDetails?
        /// The name of the state.
        public let name: String

        public init(input: String? = nil, inputDetails: HistoryEventExecutionDataDetails? = nil, name: String) {
            self.input = input
            self.inputDetails = inputDetails
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case inputDetails = "inputDetails"
            case name = "name"
        }
    }

    public struct StateExitedEventDetails: AWSDecodableShape {
        /// The name of the state. A name must not contain:   white space   brackets  { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ & , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.
        public let name: String
        /// The JSON output data of the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?

        public init(name: String, output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil) {
            self.name = name
            self.output = output
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case output = "output"
            case outputDetails = "outputDetails"
        }
    }

    public struct StateMachineAliasListItem: AWSDecodableShape {
        /// The creation date of a state machine alias.
        public let creationDate: Date
        /// The Amazon Resource Name (ARN) that identifies a state machine alias. The alias ARN is a combination of state machine ARN and the alias name separated by a colon (:). For example, stateMachineARN:PROD.
        public let stateMachineAliasArn: String

        public init(creationDate: Date, stateMachineAliasArn: String) {
            self.creationDate = creationDate
            self.stateMachineAliasArn = stateMachineAliasArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case stateMachineAliasArn = "stateMachineAliasArn"
        }
    }

    public struct StateMachineListItem: AWSDecodableShape {
        /// The date the state machine is created.
        public let creationDate: Date
        /// The name of the state machine. A name must not contain:   white space   brackets  { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ & , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain  0-9, A-Z, a-z, - and _.
        public let name: String
        /// The Amazon Resource Name (ARN) that identifies the state machine.
        public let stateMachineArn: String
        public let type: StateMachineType

        public init(creationDate: Date, name: String, stateMachineArn: String, type: StateMachineType) {
            self.creationDate = creationDate
            self.name = name
            self.stateMachineArn = stateMachineArn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case name = "name"
            case stateMachineArn = "stateMachineArn"
            case type = "type"
        }
    }

    public struct StateMachineVersionListItem: AWSDecodableShape {
        /// The creation date of a state machine version.
        public let creationDate: Date
        /// The Amazon Resource Name (ARN) that identifies a state machine version. The version ARN is a combination of state machine ARN and the version number separated by a colon (:). For example, stateMachineARN:1.
        public let stateMachineVersionArn: String

        public init(creationDate: Date, stateMachineVersionArn: String) {
            self.creationDate = creationDate
            self.stateMachineVersionArn = stateMachineVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case stateMachineVersionArn = "stateMachineVersionArn"
        }
    }

    public struct StopExecutionInput: AWSEncodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The Amazon Resource Name (ARN) of the execution to stop.
        public let executionArn: String

        public init(cause: String? = nil, error: String? = nil, executionArn: String) {
            self.cause = cause
            self.error = error
            self.executionArn = executionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.cause, name: "cause", parent: name, max: 32768)
            try self.validate(self.error, name: "error", parent: name, max: 256)
            try self.validate(self.executionArn, name: "executionArn", parent: name, max: 256)
            try self.validate(self.executionArn, name: "executionArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case executionArn = "executionArn"
        }
    }

    public struct StopExecutionOutput: AWSDecodableShape {
        /// The date the execution is stopped.
        public let stopDate: Date

        public init(stopDate: Date) {
            self.stopDate = stopDate
        }

        private enum CodingKeys: String, CodingKey {
            case stopDate = "stopDate"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of a tag.
        public let key: String?
        /// The value of a tag.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
        public let resourceArn: String
        /// The list of tags to add to a resource. Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct TaskCredentials: AWSDecodableShape {
        /// The ARN of an IAM role that Step Functions assumes for the task. The role can allow cross-account access to resources.
        public let roleArn: String?

        public init(roleArn: String? = nil) {
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
        }
    }

    public struct TaskFailedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The action of the resource called by a task state.
        public let resource: String
        /// The service name of the resource in a task state.
        public let resourceType: String

        public init(cause: String? = nil, error: String? = nil, resource: String, resourceType: String) {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskScheduledEventDetails: AWSDecodableShape {
        /// The maximum allowed duration between two heartbeats for the task.
        public let heartbeatInSeconds: Int64?
        /// The JSON data passed to the resource referenced in a task state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let parameters: String
        /// The region of the scheduled task
        public let region: String
        /// The action of the resource called by a task state.
        public let resource: String
        /// The service name of the resource in a task state.
        public let resourceType: String
        /// The credentials that Step Functions uses for the task.
        public let taskCredentials: TaskCredentials?
        /// The maximum allowed duration of the task.
        public let timeoutInSeconds: Int64?

        public init(heartbeatInSeconds: Int64? = nil, parameters: String, region: String, resource: String, resourceType: String, taskCredentials: TaskCredentials? = nil, timeoutInSeconds: Int64? = nil) {
            self.heartbeatInSeconds = heartbeatInSeconds
            self.parameters = parameters
            self.region = region
            self.resource = resource
            self.resourceType = resourceType
            self.taskCredentials = taskCredentials
            self.timeoutInSeconds = timeoutInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case heartbeatInSeconds = "heartbeatInSeconds"
            case parameters = "parameters"
            case region = "region"
            case resource = "resource"
            case resourceType = "resourceType"
            case taskCredentials = "taskCredentials"
            case timeoutInSeconds = "timeoutInSeconds"
        }
    }

    public struct TaskStartFailedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The action of the resource called by a task state.
        public let resource: String
        /// The service name of the resource in a task state.
        public let resourceType: String

        public init(cause: String? = nil, error: String? = nil, resource: String, resourceType: String) {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskStartedEventDetails: AWSDecodableShape {
        /// The action of the resource called by a task state.
        public let resource: String
        /// The service name of the resource in a task state.
        public let resourceType: String

        public init(resource: String, resourceType: String) {
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskSubmitFailedEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The action of the resource called by a task state.
        public let resource: String
        /// The service name of the resource in a task state.
        public let resourceType: String

        public init(cause: String? = nil, error: String? = nil, resource: String, resourceType: String) {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskSubmittedEventDetails: AWSDecodableShape {
        /// The response from a resource when a task has started. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?
        /// The action of the resource called by a task state.
        public let resource: String
        /// The service name of the resource in a task state.
        public let resourceType: String

        public init(output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil, resource: String, resourceType: String) {
            self.output = output
            self.outputDetails = outputDetails
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case outputDetails = "outputDetails"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskSucceededEventDetails: AWSDecodableShape {
        /// The full JSON response from a resource when a task has succeeded. This response becomes the output of the related task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?
        /// The action of the resource called by a task state.
        public let resource: String
        /// The service name of the resource in a task state.
        public let resourceType: String

        public init(output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil, resource: String, resourceType: String) {
            self.output = output
            self.outputDetails = outputDetails
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case outputDetails = "outputDetails"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskTimedOutEventDetails: AWSDecodableShape {
        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The action of the resource called by a task state.
        public let resource: String
        /// The service name of the resource in a task state.
        public let resourceType: String

        public init(cause: String? = nil, error: String? = nil, resource: String, resourceType: String) {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TestStateInput: AWSEncodableShape {
        /// The Amazon States Language (ASL) definition of the state.
        public let definition: String
        /// A string that contains the JSON input data for the state.
        public let input: String?
        /// Determines the values to return when a state is tested. You can specify one of the following types:    INFO: Shows the final state output. By default, Step Functions sets inspectionLevel to INFO if you don't specify a level.    DEBUG: Shows the final state output along with the input and output data processing result.    TRACE: Shows the HTTP request and response for an HTTP Task. This level also shows the final state output along with the input and output data processing result.   Each of these levels also provide information about the status of the state execution and the next state to transition to.
        public let inspectionLevel: InspectionLevel?
        /// Specifies whether or not to include secret information in the test result. For HTTP Tasks, a secret includes the data that an EventBridge connection adds to modify the HTTP request headers, query parameters, and body. Step Functions doesn't omit any information included in the state definition or the HTTP response. If you set revealSecrets to true, you must make sure that the IAM user that calls the TestState API has permission for the states:RevealSecrets action. For an example of IAM policy that sets the states:RevealSecrets permission, see IAM permissions to test a state. Without this permission, Step Functions throws an access denied error. By default, revealSecrets is set to false.
        public let revealSecrets: Bool?
        /// The Amazon Resource Name (ARN) of the execution role with the required IAM permissions for the state.
        public let roleArn: String

        public init(definition: String, input: String? = nil, inspectionLevel: InspectionLevel? = nil, revealSecrets: Bool? = nil, roleArn: String) {
            self.definition = definition
            self.input = input
            self.inspectionLevel = inspectionLevel
            self.revealSecrets = revealSecrets
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.definition, name: "definition", parent: name, max: 1048576)
            try self.validate(self.definition, name: "definition", parent: name, min: 1)
            try self.validate(self.input, name: "input", parent: name, max: 262144)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case input = "input"
            case inspectionLevel = "inspectionLevel"
            case revealSecrets = "revealSecrets"
            case roleArn = "roleArn"
        }
    }

    public struct TestStateOutput: AWSDecodableShape {
        /// A detailed explanation of the cause for the error when the execution of a state fails.
        public let cause: String?
        /// The error returned when the execution of a state fails.
        public let error: String?
        /// Returns additional details about the state's execution, including its input and output data processing flow, and HTTP request and response information. The inspectionLevel request parameter specifies which details are returned.
        public let inspectionData: InspectionData?
        /// The name of the next state to transition to. If you haven't defined a next state in your definition or if the execution of the state fails, this ﬁeld doesn't contain a value.
        public let nextState: String?
        /// The JSON output data of the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// The execution status of the state.
        public let status: TestExecutionStatus?

        public init(cause: String? = nil, error: String? = nil, inspectionData: InspectionData? = nil, nextState: String? = nil, output: String? = nil, status: TestExecutionStatus? = nil) {
            self.cause = cause
            self.error = error
            self.inspectionData = inspectionData
            self.nextState = nextState
            self.output = output
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case inspectionData = "inspectionData"
            case nextState = "nextState"
            case output = "output"
            case status = "status"
        }
    }

    public struct TracingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// When set to true, X-Ray tracing is enabled.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
        public let resourceArn: String
        /// The list of tags to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMapRunInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of a Map Run.
        public let mapRunArn: String
        /// The maximum number of child workflow executions that can be specified to run in parallel for the Map Run at the same time.
        public let maxConcurrency: Int?
        /// The maximum number of failed items before the Map Run fails.
        public let toleratedFailureCount: Int64?
        /// The maximum percentage of failed items before the Map Run fails.
        public let toleratedFailurePercentage: Float?

        public init(mapRunArn: String, maxConcurrency: Int? = nil, toleratedFailureCount: Int64? = nil, toleratedFailurePercentage: Float? = nil) {
            self.mapRunArn = mapRunArn
            self.maxConcurrency = maxConcurrency
            self.toleratedFailureCount = toleratedFailureCount
            self.toleratedFailurePercentage = toleratedFailurePercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.mapRunArn, name: "mapRunArn", parent: name, max: 2000)
            try self.validate(self.mapRunArn, name: "mapRunArn", parent: name, min: 1)
            try self.validate(self.maxConcurrency, name: "maxConcurrency", parent: name, min: 0)
            try self.validate(self.toleratedFailureCount, name: "toleratedFailureCount", parent: name, min: 0)
            try self.validate(self.toleratedFailurePercentage, name: "toleratedFailurePercentage", parent: name, max: 100.0)
            try self.validate(self.toleratedFailurePercentage, name: "toleratedFailurePercentage", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case mapRunArn = "mapRunArn"
            case maxConcurrency = "maxConcurrency"
            case toleratedFailureCount = "toleratedFailureCount"
            case toleratedFailurePercentage = "toleratedFailurePercentage"
        }
    }

    public struct UpdateMapRunOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateStateMachineAliasInput: AWSEncodableShape {
        /// A description of the state machine alias.
        public let description: String?
        /// The routing configuration of the state machine alias. An array of RoutingConfig objects that specifies up to two state machine versions that the alias starts executions for.
        public let routingConfiguration: [RoutingConfigurationListItem]?
        /// The Amazon Resource Name (ARN) of the state machine alias.
        public let stateMachineAliasArn: String

        public init(description: String? = nil, routingConfiguration: [RoutingConfigurationListItem]? = nil, stateMachineAliasArn: String) {
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.stateMachineAliasArn = stateMachineAliasArn
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.routingConfiguration?.forEach {
                try $0.validate(name: "\(name).routingConfiguration[]")
            }
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, max: 2)
            try self.validate(self.routingConfiguration, name: "routingConfiguration", parent: name, min: 1)
            try self.validate(self.stateMachineAliasArn, name: "stateMachineAliasArn", parent: name, max: 256)
            try self.validate(self.stateMachineAliasArn, name: "stateMachineAliasArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case routingConfiguration = "routingConfiguration"
            case stateMachineAliasArn = "stateMachineAliasArn"
        }
    }

    public struct UpdateStateMachineAliasOutput: AWSDecodableShape {
        /// The date and time the state machine alias was updated.
        public let updateDate: Date

        public init(updateDate: Date) {
            self.updateDate = updateDate
        }

        private enum CodingKeys: String, CodingKey {
            case updateDate = "updateDate"
        }
    }

    public struct UpdateStateMachineInput: AWSEncodableShape {
        /// The Amazon States Language definition of the state machine. See Amazon States Language.
        public let definition: String?
        /// Use the LoggingConfiguration data type to set CloudWatch Logs options.
        public let loggingConfiguration: LoggingConfiguration?
        /// Specifies whether the state machine version is published. The default is false. To publish a version after updating the state machine, set publish to true.
        public let publish: Bool?
        /// The Amazon Resource Name (ARN) of the IAM role of the state machine.
        public let roleArn: String?
        /// The Amazon Resource Name (ARN) of the state machine.
        public let stateMachineArn: String
        /// Selects whether X-Ray tracing is enabled.
        public let tracingConfiguration: TracingConfiguration?
        /// An optional description of the state machine version to publish. You can only specify the versionDescription parameter if you've set publish to true.
        public let versionDescription: String?

        public init(definition: String? = nil, loggingConfiguration: LoggingConfiguration? = nil, publish: Bool? = nil, roleArn: String? = nil, stateMachineArn: String, tracingConfiguration: TracingConfiguration? = nil, versionDescription: String? = nil) {
            self.definition = definition
            self.loggingConfiguration = loggingConfiguration
            self.publish = publish
            self.roleArn = roleArn
            self.stateMachineArn = stateMachineArn
            self.tracingConfiguration = tracingConfiguration
            self.versionDescription = versionDescription
        }

        public func validate(name: String) throws {
            try self.validate(self.definition, name: "definition", parent: name, max: 1048576)
            try self.validate(self.definition, name: "definition", parent: name, min: 1)
            try self.loggingConfiguration?.validate(name: "\(name).loggingConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, max: 256)
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, min: 1)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case loggingConfiguration = "loggingConfiguration"
            case publish = "publish"
            case roleArn = "roleArn"
            case stateMachineArn = "stateMachineArn"
            case tracingConfiguration = "tracingConfiguration"
            case versionDescription = "versionDescription"
        }
    }

    public struct UpdateStateMachineOutput: AWSDecodableShape {
        /// The revision identifier for the updated state machine.
        public let revisionId: String?
        /// The Amazon Resource Name (ARN) of the published state machine version. If the publish parameter isn't set to true, this field returns null.
        public let stateMachineVersionArn: String?
        /// The date and time the state machine was updated.
        public let updateDate: Date

        public init(revisionId: String? = nil, stateMachineVersionArn: String? = nil, updateDate: Date) {
            self.revisionId = revisionId
            self.stateMachineVersionArn = stateMachineVersionArn
            self.updateDate = updateDate
        }

        private enum CodingKeys: String, CodingKey {
            case revisionId = "revisionId"
            case stateMachineVersionArn = "stateMachineVersionArn"
            case updateDate = "updateDate"
        }
    }
}

// MARK: - Errors

/// Error enum for SFN
public struct SFNErrorType: AWSErrorType {
    enum Code: String {
        case activityDoesNotExist = "ActivityDoesNotExist"
        case activityLimitExceeded = "ActivityLimitExceeded"
        case activityWorkerLimitExceeded = "ActivityWorkerLimitExceeded"
        case conflictException = "ConflictException"
        case executionAlreadyExists = "ExecutionAlreadyExists"
        case executionDoesNotExist = "ExecutionDoesNotExist"
        case executionLimitExceeded = "ExecutionLimitExceeded"
        case executionNotRedrivable = "ExecutionNotRedrivable"
        case invalidArn = "InvalidArn"
        case invalidDefinition = "InvalidDefinition"
        case invalidExecutionInput = "InvalidExecutionInput"
        case invalidLoggingConfiguration = "InvalidLoggingConfiguration"
        case invalidName = "InvalidName"
        case invalidOutput = "InvalidOutput"
        case invalidToken = "InvalidToken"
        case invalidTracingConfiguration = "InvalidTracingConfiguration"
        case missingRequiredParameter = "MissingRequiredParameter"
        case resourceNotFound = "ResourceNotFound"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case stateMachineAlreadyExists = "StateMachineAlreadyExists"
        case stateMachineDeleting = "StateMachineDeleting"
        case stateMachineDoesNotExist = "StateMachineDoesNotExist"
        case stateMachineLimitExceeded = "StateMachineLimitExceeded"
        case stateMachineTypeNotSupported = "StateMachineTypeNotSupported"
        case taskDoesNotExist = "TaskDoesNotExist"
        case taskTimedOut = "TaskTimedOut"
        case tooManyTags = "TooManyTags"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SFN
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The specified activity does not exist.
    public static var activityDoesNotExist: Self { .init(.activityDoesNotExist) }
    /// The maximum number of activities has been reached. Existing activities must be deleted before a new activity can be created.
    public static var activityLimitExceeded: Self { .init(.activityLimitExceeded) }
    /// The maximum number of workers concurrently polling for activity tasks has been reached.
    public static var activityWorkerLimitExceeded: Self { .init(.activityWorkerLimitExceeded) }
    /// Updating or deleting a resource can cause an inconsistent state. This error occurs when there're concurrent requests for DeleteStateMachineVersion, PublishStateMachineVersion, or UpdateStateMachine with the publish parameter set to true. HTTP Status Code: 409
    public static var conflictException: Self { .init(.conflictException) }
    /// The execution has the same name as another execution (but a different input).  Executions with the same name and input are considered idempotent.
    public static var executionAlreadyExists: Self { .init(.executionAlreadyExists) }
    /// The specified execution does not exist.
    public static var executionDoesNotExist: Self { .init(.executionDoesNotExist) }
    /// The maximum number of running executions has been reached. Running executions must end or be stopped before a new execution can be started.
    public static var executionLimitExceeded: Self { .init(.executionLimitExceeded) }
    /// The execution Amazon Resource Name (ARN) that you specified for executionArn cannot be redriven.
    public static var executionNotRedrivable: Self { .init(.executionNotRedrivable) }
    /// The provided Amazon Resource Name (ARN) is not valid.
    public static var invalidArn: Self { .init(.invalidArn) }
    /// The provided Amazon States Language definition is not valid.
    public static var invalidDefinition: Self { .init(.invalidDefinition) }
    /// The provided JSON input data is not valid.
    public static var invalidExecutionInput: Self { .init(.invalidExecutionInput) }
    public static var invalidLoggingConfiguration: Self { .init(.invalidLoggingConfiguration) }
    /// The provided name is not valid.
    public static var invalidName: Self { .init(.invalidName) }
    /// The provided JSON output data is not valid.
    public static var invalidOutput: Self { .init(.invalidOutput) }
    /// The provided token is not valid.
    public static var invalidToken: Self { .init(.invalidToken) }
    /// Your tracingConfiguration key does not match, or enabled has not been set to true or false.
    public static var invalidTracingConfiguration: Self { .init(.invalidTracingConfiguration) }
    /// Request is missing a required parameter. This error occurs if both definition and roleArn are not specified.
    public static var missingRequiredParameter: Self { .init(.missingRequiredParameter) }
    /// Could not find the referenced resource.
    public static var resourceNotFound: Self { .init(.resourceNotFound) }
    /// The request would cause a service quota to be exceeded. HTTP Status Code: 402
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// A state machine with the same name but a different definition or role ARN already exists.
    public static var stateMachineAlreadyExists: Self { .init(.stateMachineAlreadyExists) }
    /// The specified state machine is being deleted.
    public static var stateMachineDeleting: Self { .init(.stateMachineDeleting) }
    /// The specified state machine does not exist.
    public static var stateMachineDoesNotExist: Self { .init(.stateMachineDoesNotExist) }
    /// The maximum number of state machines has been reached. Existing state machines must be deleted before a new state machine can be created.
    public static var stateMachineLimitExceeded: Self { .init(.stateMachineLimitExceeded) }
    public static var stateMachineTypeNotSupported: Self { .init(.stateMachineTypeNotSupported) }
    /// The activity does not exist.
    public static var taskDoesNotExist: Self { .init(.taskDoesNotExist) }
    /// The task token has either expired or the task associated with the token has already been closed.
    public static var taskTimedOut: Self { .init(.taskTimedOut) }
    /// You've exceeded the number of tags allowed for a resource. See the  Limits Topic in the Step Functions Developer Guide.
    public static var tooManyTags: Self { .init(.tooManyTags) }
    /// The input does not satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension SFNErrorType: Equatable {
    public static func == (lhs: SFNErrorType, rhs: SFNErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SFNErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
