//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS Resiliencehub service.
///
/// AWS Resilience Hub helps you proactively prepare and protect your Amazon Web Services applications from disruptions. Resilience Hub offers continuous resiliency assessment and validation that integrates into your software development lifecycle. This enables you to uncover resiliency weaknesses, ensure recovery time objective (RTO) and recovery point objective (RPO) targets for your applications are met, and resolve issues before they are released into production.
public struct Resiliencehub: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Resiliencehub client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "resiliencehub",
            serviceProtocol: .restjson,
            apiVersion: "2020-04-30",
            endpoint: endpoint,
            errorType: ResiliencehubErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Adds the resource mapping for the draft application version.
    public func addDraftAppVersionResourceMappings(_ input: AddDraftAppVersionResourceMappingsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AddDraftAppVersionResourceMappingsResponse> {
        return self.client.execute(operation: "AddDraftAppVersionResourceMappings", path: "/add-draft-app-version-resource-mappings", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a Resilience Hub application. A Resilience Hub application is a collection of Amazon Web Services resources structured to prevent and recover Amazon Web Services application disruptions. To describe a Resilience Hub application, you provide an application name, resources from one or more–up to five–CloudFormation stacks, and an appropriate resiliency policy. After you create a Resilience Hub application, you publish it so that you can run a resiliency assessment on it. You can then use recommendations from the assessment to improve resiliency by running another assessment, comparing results, and then iterating the process until you achieve your goals for recovery time objective (RTO) and recovery point objective (RPO).
    public func createApp(_ input: CreateAppRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateAppResponse> {
        return self.client.execute(operation: "CreateApp", path: "/create-app", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new recommendation template.
    public func createRecommendationTemplate(_ input: CreateRecommendationTemplateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateRecommendationTemplateResponse> {
        return self.client.execute(operation: "CreateRecommendationTemplate", path: "/create-recommendation-template", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a resiliency policy for an application.
    public func createResiliencyPolicy(_ input: CreateResiliencyPolicyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateResiliencyPolicyResponse> {
        return self.client.execute(operation: "CreateResiliencyPolicy", path: "/create-resiliency-policy", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an AWS Resilience Hub application. This is a destructive action that can't be undone.
    public func deleteApp(_ input: DeleteAppRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteAppResponse> {
        return self.client.execute(operation: "DeleteApp", path: "/delete-app", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes an AWS Resilience Hub application assessment. This is a destructive action that can't be undone.
    public func deleteAppAssessment(_ input: DeleteAppAssessmentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteAppAssessmentResponse> {
        return self.client.execute(operation: "DeleteAppAssessment", path: "/delete-app-assessment", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a recommendation template. This is a destructive action that can't be undone.
    public func deleteRecommendationTemplate(_ input: DeleteRecommendationTemplateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteRecommendationTemplateResponse> {
        return self.client.execute(operation: "DeleteRecommendationTemplate", path: "/delete-recommendation-template", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a resiliency policy. This is a destructive action that can't be undone.
    public func deleteResiliencyPolicy(_ input: DeleteResiliencyPolicyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteResiliencyPolicyResponse> {
        return self.client.execute(operation: "DeleteResiliencyPolicy", path: "/delete-resiliency-policy", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes an AWS Resilience Hub application.
    public func describeApp(_ input: DescribeAppRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeAppResponse> {
        return self.client.execute(operation: "DescribeApp", path: "/describe-app", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes an assessment for an AWS Resilience Hub application.
    public func describeAppAssessment(_ input: DescribeAppAssessmentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeAppAssessmentResponse> {
        return self.client.execute(operation: "DescribeAppAssessment", path: "/describe-app-assessment", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns the resolution status for the specified resolution identifier for an application version. If resolutionId is not specified, the current resolution status is returned.
    public func describeAppVersionResourcesResolutionStatus(_ input: DescribeAppVersionResourcesResolutionStatusRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeAppVersionResourcesResolutionStatusResponse> {
        return self.client.execute(operation: "DescribeAppVersionResourcesResolutionStatus", path: "/describe-app-version-resources-resolution-status", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes details about an AWS Resilience Hub
    public func describeAppVersionTemplate(_ input: DescribeAppVersionTemplateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeAppVersionTemplateResponse> {
        return self.client.execute(operation: "DescribeAppVersionTemplate", path: "/describe-app-version-template", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes the status of importing resources to an application version.
    public func describeDraftAppVersionResourcesImportStatus(_ input: DescribeDraftAppVersionResourcesImportStatusRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeDraftAppVersionResourcesImportStatusResponse> {
        return self.client.execute(operation: "DescribeDraftAppVersionResourcesImportStatus", path: "/describe-draft-app-version-resources-import-status", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describes a specified resiliency policy for an AWS Resilience Hub application. The returned policy object includes creation time, data location constraints, the Amazon Resource Name (ARN) for the policy, tags, tier, and more.
    public func describeResiliencyPolicy(_ input: DescribeResiliencyPolicyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeResiliencyPolicyResponse> {
        return self.client.execute(operation: "DescribeResiliencyPolicy", path: "/describe-resiliency-policy", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Imports resources from sources such as a CloudFormation stack, resource-groups, or application registry app to a draft application version.
    public func importResourcesToDraftAppVersion(_ input: ImportResourcesToDraftAppVersionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ImportResourcesToDraftAppVersionResponse> {
        return self.client.execute(operation: "ImportResourcesToDraftAppVersion", path: "/import-resources-to-draft-app-version", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the alarm recommendations for a AWS Resilience Hub application.
    public func listAlarmRecommendations(_ input: ListAlarmRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAlarmRecommendationsResponse> {
        return self.client.execute(operation: "ListAlarmRecommendations", path: "/list-alarm-recommendations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the assessments for an AWS Resilience Hub application. You can use request parameters to refine the results for the response object.
    public func listAppAssessments(_ input: ListAppAssessmentsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAppAssessmentsResponse> {
        return self.client.execute(operation: "ListAppAssessments", path: "/list-app-assessments", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the compliances for an AWS Resilience Hub component.
    public func listAppComponentCompliances(_ input: ListAppComponentCompliancesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAppComponentCompliancesResponse> {
        return self.client.execute(operation: "ListAppComponentCompliances", path: "/list-app-component-compliances", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the recommendations for an AWS Resilience Hub component.
    public func listAppComponentRecommendations(_ input: ListAppComponentRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAppComponentRecommendationsResponse> {
        return self.client.execute(operation: "ListAppComponentRecommendations", path: "/list-app-component-recommendations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists how the resources in an application version are mapped/sourced from. Mappings can be physical resource identifiers, CloudFormation stacks, resource-groups, or an application registry app.
    public func listAppVersionResourceMappings(_ input: ListAppVersionResourceMappingsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAppVersionResourceMappingsResponse> {
        return self.client.execute(operation: "ListAppVersionResourceMappings", path: "/list-app-version-resource-mappings", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists all the resources in an application version.
    public func listAppVersionResources(_ input: ListAppVersionResourcesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAppVersionResourcesResponse> {
        return self.client.execute(operation: "ListAppVersionResources", path: "/list-app-version-resources", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the different versions for the Resilience Hub applications.
    public func listAppVersions(_ input: ListAppVersionsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAppVersionsResponse> {
        return self.client.execute(operation: "ListAppVersions", path: "/list-app-versions", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists your Resilience Hub applications.
    public func listApps(_ input: ListAppsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAppsResponse> {
        return self.client.execute(operation: "ListApps", path: "/list-apps", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the recommendation templates for the Resilience Hub applications.
    public func listRecommendationTemplates(_ input: ListRecommendationTemplatesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListRecommendationTemplatesResponse> {
        return self.client.execute(operation: "ListRecommendationTemplates", path: "/list-recommendation-templates", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the resiliency policies for the Resilience Hub applications.
    public func listResiliencyPolicies(_ input: ListResiliencyPoliciesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListResiliencyPoliciesResponse> {
        return self.client.execute(operation: "ListResiliencyPolicies", path: "/list-resiliency-policies", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the standard operating procedure (SOP) recommendations for the Resilience Hub applications.
    public func listSopRecommendations(_ input: ListSopRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSopRecommendationsResponse> {
        return self.client.execute(operation: "ListSopRecommendations", path: "/list-sop-recommendations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the suggested resiliency policies for the Resilience Hub applications.
    public func listSuggestedResiliencyPolicies(_ input: ListSuggestedResiliencyPoliciesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSuggestedResiliencyPoliciesResponse> {
        return self.client.execute(operation: "ListSuggestedResiliencyPolicies", path: "/list-suggested-resiliency-policies", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the tags for your resources in your Resilience Hub applications.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceResponse> {
        return self.client.execute(operation: "ListTagsForResource", path: "/tags/{resourceArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the test recommendations for the Resilience Hub application.
    public func listTestRecommendations(_ input: ListTestRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTestRecommendationsResponse> {
        return self.client.execute(operation: "ListTestRecommendations", path: "/list-test-recommendations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the resources that are not currently supported in AWS Resilience Hub. An unsupported resource is a resource that exists in the object that was used to create an app, but is not supported by Resilience Hub.
    public func listUnsupportedAppVersionResources(_ input: ListUnsupportedAppVersionResourcesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListUnsupportedAppVersionResourcesResponse> {
        return self.client.execute(operation: "ListUnsupportedAppVersionResources", path: "/list-unsupported-app-version-resources", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Publishes a new version of a specific Resilience Hub application.
    public func publishAppVersion(_ input: PublishAppVersionRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PublishAppVersionResponse> {
        return self.client.execute(operation: "PublishAppVersion", path: "/publish-app-version", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds or updates the app template for a draft version of a Resilience Hub app.
    public func putDraftAppVersionTemplate(_ input: PutDraftAppVersionTemplateRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<PutDraftAppVersionTemplateResponse> {
        return self.client.execute(operation: "PutDraftAppVersionTemplate", path: "/put-draft-app-version-template", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes resource mappings from a draft application version.
    public func removeDraftAppVersionResourceMappings(_ input: RemoveDraftAppVersionResourceMappingsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<RemoveDraftAppVersionResourceMappingsResponse> {
        return self.client.execute(operation: "RemoveDraftAppVersionResourceMappings", path: "/remove-draft-app-version-resource-mappings", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Resolves the resources for an application version.
    public func resolveAppVersionResources(_ input: ResolveAppVersionResourcesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ResolveAppVersionResourcesResponse> {
        return self.client.execute(operation: "ResolveAppVersionResources", path: "/resolve-app-version-resources", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new application assessment for an application.
    public func startAppAssessment(_ input: StartAppAssessmentRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartAppAssessmentResponse> {
        return self.client.execute(operation: "StartAppAssessment", path: "/start-app-assessment", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Applies one or more tags to a resource.
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceResponse> {
        return self.client.execute(operation: "TagResource", path: "/tags/{resourceArn}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes one or more tags from a resource.
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UntagResourceResponse> {
        return self.client.execute(operation: "UntagResource", path: "/tags/{resourceArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates an application.
    public func updateApp(_ input: UpdateAppRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateAppResponse> {
        return self.client.execute(operation: "UpdateApp", path: "/update-app", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a resiliency policy.
    public func updateResiliencyPolicy(_ input: UpdateResiliencyPolicyRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateResiliencyPolicyResponse> {
        return self.client.execute(operation: "UpdateResiliencyPolicy", path: "/update-resiliency-policy", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension Resiliencehub {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Resiliencehub, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension Resiliencehub {
    ///  Lists the alarm recommendations for a AWS Resilience Hub application.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAlarmRecommendationsPaginator<Result>(
        _ input: ListAlarmRecommendationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAlarmRecommendationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listAlarmRecommendations,
            inputKey: \ListAlarmRecommendationsRequest.nextToken,
            outputKey: \ListAlarmRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAlarmRecommendationsPaginator(
        _ input: ListAlarmRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAlarmRecommendationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listAlarmRecommendations,
            inputKey: \ListAlarmRecommendationsRequest.nextToken,
            outputKey: \ListAlarmRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the assessments for an AWS Resilience Hub application. You can use request parameters to refine the results for the response object.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppAssessmentsPaginator<Result>(
        _ input: ListAppAssessmentsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppAssessmentsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listAppAssessments,
            inputKey: \ListAppAssessmentsRequest.nextToken,
            outputKey: \ListAppAssessmentsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppAssessmentsPaginator(
        _ input: ListAppAssessmentsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppAssessmentsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listAppAssessments,
            inputKey: \ListAppAssessmentsRequest.nextToken,
            outputKey: \ListAppAssessmentsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the compliances for an AWS Resilience Hub component.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppComponentCompliancesPaginator<Result>(
        _ input: ListAppComponentCompliancesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppComponentCompliancesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listAppComponentCompliances,
            inputKey: \ListAppComponentCompliancesRequest.nextToken,
            outputKey: \ListAppComponentCompliancesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppComponentCompliancesPaginator(
        _ input: ListAppComponentCompliancesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppComponentCompliancesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listAppComponentCompliances,
            inputKey: \ListAppComponentCompliancesRequest.nextToken,
            outputKey: \ListAppComponentCompliancesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the recommendations for an AWS Resilience Hub component.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppComponentRecommendationsPaginator<Result>(
        _ input: ListAppComponentRecommendationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppComponentRecommendationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listAppComponentRecommendations,
            inputKey: \ListAppComponentRecommendationsRequest.nextToken,
            outputKey: \ListAppComponentRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppComponentRecommendationsPaginator(
        _ input: ListAppComponentRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppComponentRecommendationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listAppComponentRecommendations,
            inputKey: \ListAppComponentRecommendationsRequest.nextToken,
            outputKey: \ListAppComponentRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists how the resources in an application version are mapped/sourced from. Mappings can be physical resource identifiers, CloudFormation stacks, resource-groups, or an application registry app.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppVersionResourceMappingsPaginator<Result>(
        _ input: ListAppVersionResourceMappingsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppVersionResourceMappingsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listAppVersionResourceMappings,
            inputKey: \ListAppVersionResourceMappingsRequest.nextToken,
            outputKey: \ListAppVersionResourceMappingsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppVersionResourceMappingsPaginator(
        _ input: ListAppVersionResourceMappingsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppVersionResourceMappingsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listAppVersionResourceMappings,
            inputKey: \ListAppVersionResourceMappingsRequest.nextToken,
            outputKey: \ListAppVersionResourceMappingsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all the resources in an application version.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppVersionResourcesPaginator<Result>(
        _ input: ListAppVersionResourcesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppVersionResourcesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listAppVersionResources,
            inputKey: \ListAppVersionResourcesRequest.nextToken,
            outputKey: \ListAppVersionResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppVersionResourcesPaginator(
        _ input: ListAppVersionResourcesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppVersionResourcesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listAppVersionResources,
            inputKey: \ListAppVersionResourcesRequest.nextToken,
            outputKey: \ListAppVersionResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the different versions for the Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppVersionsPaginator<Result>(
        _ input: ListAppVersionsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppVersionsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listAppVersions,
            inputKey: \ListAppVersionsRequest.nextToken,
            outputKey: \ListAppVersionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppVersionsPaginator(
        _ input: ListAppVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppVersionsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listAppVersions,
            inputKey: \ListAppVersionsRequest.nextToken,
            outputKey: \ListAppVersionsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists your Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAppsPaginator<Result>(
        _ input: ListAppsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAppsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listApps,
            inputKey: \ListAppsRequest.nextToken,
            outputKey: \ListAppsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAppsPaginator(
        _ input: ListAppsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAppsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listApps,
            inputKey: \ListAppsRequest.nextToken,
            outputKey: \ListAppsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the recommendation templates for the Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listRecommendationTemplatesPaginator<Result>(
        _ input: ListRecommendationTemplatesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListRecommendationTemplatesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listRecommendationTemplates,
            inputKey: \ListRecommendationTemplatesRequest.nextToken,
            outputKey: \ListRecommendationTemplatesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listRecommendationTemplatesPaginator(
        _ input: ListRecommendationTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListRecommendationTemplatesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listRecommendationTemplates,
            inputKey: \ListRecommendationTemplatesRequest.nextToken,
            outputKey: \ListRecommendationTemplatesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the resiliency policies for the Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listResiliencyPoliciesPaginator<Result>(
        _ input: ListResiliencyPoliciesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListResiliencyPoliciesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listResiliencyPolicies,
            inputKey: \ListResiliencyPoliciesRequest.nextToken,
            outputKey: \ListResiliencyPoliciesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listResiliencyPoliciesPaginator(
        _ input: ListResiliencyPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListResiliencyPoliciesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listResiliencyPolicies,
            inputKey: \ListResiliencyPoliciesRequest.nextToken,
            outputKey: \ListResiliencyPoliciesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the standard operating procedure (SOP) recommendations for the Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSopRecommendationsPaginator<Result>(
        _ input: ListSopRecommendationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSopRecommendationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listSopRecommendations,
            inputKey: \ListSopRecommendationsRequest.nextToken,
            outputKey: \ListSopRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSopRecommendationsPaginator(
        _ input: ListSopRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSopRecommendationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listSopRecommendations,
            inputKey: \ListSopRecommendationsRequest.nextToken,
            outputKey: \ListSopRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the suggested resiliency policies for the Resilience Hub applications.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listSuggestedResiliencyPoliciesPaginator<Result>(
        _ input: ListSuggestedResiliencyPoliciesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListSuggestedResiliencyPoliciesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listSuggestedResiliencyPolicies,
            inputKey: \ListSuggestedResiliencyPoliciesRequest.nextToken,
            outputKey: \ListSuggestedResiliencyPoliciesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listSuggestedResiliencyPoliciesPaginator(
        _ input: ListSuggestedResiliencyPoliciesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListSuggestedResiliencyPoliciesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listSuggestedResiliencyPolicies,
            inputKey: \ListSuggestedResiliencyPoliciesRequest.nextToken,
            outputKey: \ListSuggestedResiliencyPoliciesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the test recommendations for the Resilience Hub application.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listTestRecommendationsPaginator<Result>(
        _ input: ListTestRecommendationsRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListTestRecommendationsResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listTestRecommendations,
            inputKey: \ListTestRecommendationsRequest.nextToken,
            outputKey: \ListTestRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listTestRecommendationsPaginator(
        _ input: ListTestRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListTestRecommendationsResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listTestRecommendations,
            inputKey: \ListTestRecommendationsRequest.nextToken,
            outputKey: \ListTestRecommendationsResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the resources that are not currently supported in AWS Resilience Hub. An unsupported resource is a resource that exists in the object that was used to create an app, but is not supported by Resilience Hub.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listUnsupportedAppVersionResourcesPaginator<Result>(
        _ input: ListUnsupportedAppVersionResourcesRequest,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListUnsupportedAppVersionResourcesResponse, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listUnsupportedAppVersionResources,
            inputKey: \ListUnsupportedAppVersionResourcesRequest.nextToken,
            outputKey: \ListUnsupportedAppVersionResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listUnsupportedAppVersionResourcesPaginator(
        _ input: ListUnsupportedAppVersionResourcesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListUnsupportedAppVersionResourcesResponse, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listUnsupportedAppVersionResources,
            inputKey: \ListUnsupportedAppVersionResourcesRequest.nextToken,
            outputKey: \ListUnsupportedAppVersionResourcesResponse.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension Resiliencehub.ListAlarmRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListAlarmRecommendationsRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Resiliencehub.ListAppAssessmentsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListAppAssessmentsRequest {
        return .init(
            appArn: self.appArn,
            assessmentName: self.assessmentName,
            assessmentStatus: self.assessmentStatus,
            complianceStatus: self.complianceStatus,
            invoker: self.invoker,
            maxResults: self.maxResults,
            nextToken: token,
            reverseOrder: self.reverseOrder
        )
    }
}

extension Resiliencehub.ListAppComponentCompliancesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListAppComponentCompliancesRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Resiliencehub.ListAppComponentRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListAppComponentRecommendationsRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Resiliencehub.ListAppVersionResourceMappingsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListAppVersionResourceMappingsRequest {
        return .init(
            appArn: self.appArn,
            appVersion: self.appVersion,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Resiliencehub.ListAppVersionResourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListAppVersionResourcesRequest {
        return .init(
            appArn: self.appArn,
            appVersion: self.appVersion,
            maxResults: self.maxResults,
            nextToken: token,
            resolutionId: self.resolutionId
        )
    }
}

extension Resiliencehub.ListAppVersionsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListAppVersionsRequest {
        return .init(
            appArn: self.appArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Resiliencehub.ListAppsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListAppsRequest {
        return .init(
            appArn: self.appArn,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension Resiliencehub.ListRecommendationTemplatesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListRecommendationTemplatesRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            recommendationTemplateArn: self.recommendationTemplateArn,
            reverseOrder: self.reverseOrder,
            status: self.status
        )
    }
}

extension Resiliencehub.ListResiliencyPoliciesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListResiliencyPoliciesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            policyName: self.policyName
        )
    }
}

extension Resiliencehub.ListSopRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListSopRecommendationsRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Resiliencehub.ListSuggestedResiliencyPoliciesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListSuggestedResiliencyPoliciesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Resiliencehub.ListTestRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListTestRecommendationsRequest {
        return .init(
            assessmentArn: self.assessmentArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Resiliencehub.ListUnsupportedAppVersionResourcesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Resiliencehub.ListUnsupportedAppVersionResourcesRequest {
        return .init(
            appArn: self.appArn,
            appVersion: self.appVersion,
            maxResults: self.maxResults,
            nextToken: token,
            resolutionId: self.resolutionId
        )
    }
}
