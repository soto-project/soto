//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Amplify {
    // MARK: Enums

    public enum CacheConfigType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amplifyManaged = "AMPLIFY_MANAGED"
        case amplifyManagedNoCookies = "AMPLIFY_MANAGED_NO_COOKIES"
        public var description: String { return self.rawValue }
    }

    public enum CertificateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amplifyManaged = "AMPLIFY_MANAGED"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum DomainStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case awaitingAppCname = "AWAITING_APP_CNAME"
        case creating = "CREATING"
        case failed = "FAILED"
        case importingCustomCertificate = "IMPORTING_CUSTOM_CERTIFICATE"
        case inProgress = "IN_PROGRESS"
        case pendingDeployment = "PENDING_DEPLOYMENT"
        case pendingVerification = "PENDING_VERIFICATION"
        case requestingCertificate = "REQUESTING_CERTIFICATE"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case created = "CREATED"
        case failed = "FAILED"
        case pending = "PENDING"
        case provisioning = "PROVISIONING"
        case running = "RUNNING"
        case succeed = "SUCCEED"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case manual = "MANUAL"
        case release = "RELEASE"
        case retry = "RETRY"
        case webHook = "WEB_HOOK"
        public var description: String { return self.rawValue }
    }

    public enum Platform: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case web = "WEB"
        case webCompute = "WEB_COMPUTE"
        case webDynamic = "WEB_DYNAMIC"
        public var description: String { return self.rawValue }
    }

    public enum RepositoryCloneMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sigv4 = "SIGV4"
        case ssh = "SSH"
        case token = "TOKEN"
        public var description: String { return self.rawValue }
    }

    public enum SourceUrlType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bucketPrefix = "BUCKET_PREFIX"
        case zip = "ZIP"
        public var description: String { return self.rawValue }
    }

    public enum Stage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case beta = "BETA"
        case development = "DEVELOPMENT"
        case experimental = "EXPERIMENTAL"
        case production = "PRODUCTION"
        case pullRequest = "PULL_REQUEST"
        public var description: String { return self.rawValue }
    }

    public enum UpdateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awaitingAppCname = "AWAITING_APP_CNAME"
        case importingCustomCertificate = "IMPORTING_CUSTOM_CERTIFICATE"
        case pendingDeployment = "PENDING_DEPLOYMENT"
        case pendingVerification = "PENDING_VERIFICATION"
        case requestingCertificate = "REQUESTING_CERTIFICATE"
        case updateComplete = "UPDATE_COMPLETE"
        case updateFailed = "UPDATE_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum WafStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associating = "ASSOCIATING"
        case associationFailed = "ASSOCIATION_FAILED"
        case associationSuccess = "ASSOCIATION_SUCCESS"
        case disassociating = "DISASSOCIATING"
        case disassociationFailed = "DISASSOCIATION_FAILED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct App: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amplify app.
        public let appArn: String
        /// The unique ID of the Amplify app.
        public let appId: String
        /// Describes the automated branch creation configuration for the Amplify app.
        public let autoBranchCreationConfig: AutoBranchCreationConfig?
        /// Describes the automated branch creation glob patterns for the Amplify app.
        public let autoBranchCreationPatterns: [String]?
        /// The basic authorization credentials for branches for the Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
        public let basicAuthCredentials: String?
        /// Describes the content of the build specification (build spec) for the Amplify app.
        public let buildSpec: String?
        /// The cache configuration for the Amplify app. If you don't specify the cache configuration type, Amplify uses the default AMPLIFY_MANAGED setting.
        public let cacheConfig: CacheConfig?
        /// The Amazon Resource Name (ARN) of the IAM role for an SSR app. The Compute role allows the Amplify Hosting compute service to securely access specific Amazon Web Services resources based on the role's permissions. For more information about the SSR Compute role, see Adding an SSR Compute role in the Amplify User Guide.
        public let computeRoleArn: String?
        /// A timestamp of when Amplify created the application.
        public let createTime: Date
        /// Describes the custom HTTP headers for the Amplify app.
        public let customHeaders: String?
        /// Describes the custom redirect and rewrite rules for the Amplify app.
        public let customRules: [CustomRule]?
        /// The default domain for the Amplify app.
        public let defaultDomain: String
        /// The description for the Amplify app.
        public let description: String?
        /// Enables automated branch creation for the Amplify app.
        public let enableAutoBranchCreation: Bool?
        /// Enables basic authorization for the Amplify app's branches.
        public let enableBasicAuth: Bool
        /// Enables the auto-building of branches for the Amplify app.
        public let enableBranchAutoBuild: Bool
        /// Automatically disconnect a branch in the Amplify console when you delete a branch from your Git repository.
        public let enableBranchAutoDeletion: Bool?
        /// The environment variables for the Amplify app.  For a list of the environment variables that are accessible to Amplify by default, see Amplify Environment variables in the Amplify Hosting User Guide.
        public let environmentVariables: [String: String]?
        /// The Amazon Resource Name (ARN) of the IAM service role for the Amplify app.
        public let iamServiceRoleArn: String?
        /// The name for the Amplify app.
        public let name: String
        /// The platform for the Amplify app. For a static app, set the platform type to WEB. For a dynamic server-side rendered (SSR) app, set the platform type to WEB_COMPUTE. For an app requiring Amplify Hosting's original SSR support only, set the platform type to WEB_DYNAMIC. If you are deploying an SSG only app with Next.js 14 or later, you must use the platform type WEB_COMPUTE.
        public let platform: Platform
        /// Describes the information about a production branch of the Amplify app.
        public let productionBranch: ProductionBranch?
        /// The Git repository for the Amplify app.
        public let repository: String?
        ///  This is for internal use.  The Amplify service uses this parameter to specify the authentication protocol to use to access the Git repository for an Amplify app. Amplify specifies TOKEN for a GitHub repository, SIGV4 for an Amazon Web Services CodeCommit repository, and SSH for GitLab and Bitbucket repositories.
        public let repositoryCloneMethod: RepositoryCloneMethod?
        /// The tag for the Amplify app.
        public let tags: [String: String]?
        /// A timestamp of when Amplify updated the application.
        public let updateTime: Date
        /// Describes the Firewall configuration for the Amplify app. Firewall support enables you to protect your hosted applications with a direct integration with WAF.
        public let wafConfiguration: WafConfiguration?
        /// A timestamp of when Amplify created the webhook in your Git repository.
        public let webhookCreateTime: Date?

        @inlinable
        public init(appArn: String, appId: String, autoBranchCreationConfig: AutoBranchCreationConfig? = nil, autoBranchCreationPatterns: [String]? = nil, basicAuthCredentials: String? = nil, buildSpec: String? = nil, cacheConfig: CacheConfig? = nil, computeRoleArn: String? = nil, createTime: Date, customHeaders: String? = nil, customRules: [CustomRule]? = nil, defaultDomain: String, description: String? = nil, enableAutoBranchCreation: Bool? = nil, enableBasicAuth: Bool, enableBranchAutoBuild: Bool, enableBranchAutoDeletion: Bool? = nil, environmentVariables: [String: String]? = nil, iamServiceRoleArn: String? = nil, name: String, platform: Platform, productionBranch: ProductionBranch? = nil, repository: String? = nil, repositoryCloneMethod: RepositoryCloneMethod? = nil, tags: [String: String]? = nil, updateTime: Date, wafConfiguration: WafConfiguration? = nil, webhookCreateTime: Date? = nil) {
            self.appArn = appArn
            self.appId = appId
            self.autoBranchCreationConfig = autoBranchCreationConfig
            self.autoBranchCreationPatterns = autoBranchCreationPatterns
            self.basicAuthCredentials = basicAuthCredentials
            self.buildSpec = buildSpec
            self.cacheConfig = cacheConfig
            self.computeRoleArn = computeRoleArn
            self.createTime = createTime
            self.customHeaders = customHeaders
            self.customRules = customRules
            self.defaultDomain = defaultDomain
            self.description = description
            self.enableAutoBranchCreation = enableAutoBranchCreation
            self.enableBasicAuth = enableBasicAuth
            self.enableBranchAutoBuild = enableBranchAutoBuild
            self.enableBranchAutoDeletion = enableBranchAutoDeletion
            self.environmentVariables = environmentVariables
            self.iamServiceRoleArn = iamServiceRoleArn
            self.name = name
            self.platform = platform
            self.productionBranch = productionBranch
            self.repository = repository
            self.repositoryCloneMethod = repositoryCloneMethod
            self.tags = tags
            self.updateTime = updateTime
            self.wafConfiguration = wafConfiguration
            self.webhookCreateTime = webhookCreateTime
        }

        private enum CodingKeys: String, CodingKey {
            case appArn = "appArn"
            case appId = "appId"
            case autoBranchCreationConfig = "autoBranchCreationConfig"
            case autoBranchCreationPatterns = "autoBranchCreationPatterns"
            case basicAuthCredentials = "basicAuthCredentials"
            case buildSpec = "buildSpec"
            case cacheConfig = "cacheConfig"
            case computeRoleArn = "computeRoleArn"
            case createTime = "createTime"
            case customHeaders = "customHeaders"
            case customRules = "customRules"
            case defaultDomain = "defaultDomain"
            case description = "description"
            case enableAutoBranchCreation = "enableAutoBranchCreation"
            case enableBasicAuth = "enableBasicAuth"
            case enableBranchAutoBuild = "enableBranchAutoBuild"
            case enableBranchAutoDeletion = "enableBranchAutoDeletion"
            case environmentVariables = "environmentVariables"
            case iamServiceRoleArn = "iamServiceRoleArn"
            case name = "name"
            case platform = "platform"
            case productionBranch = "productionBranch"
            case repository = "repository"
            case repositoryCloneMethod = "repositoryCloneMethod"
            case tags = "tags"
            case updateTime = "updateTime"
            case wafConfiguration = "wafConfiguration"
            case webhookCreateTime = "webhookCreateTime"
        }
    }

    public struct Artifact: AWSDecodableShape {
        /// The file name for the artifact.
        public let artifactFileName: String
        /// The unique ID for the artifact.
        public let artifactId: String

        @inlinable
        public init(artifactFileName: String, artifactId: String) {
            self.artifactFileName = artifactFileName
            self.artifactId = artifactId
        }

        private enum CodingKeys: String, CodingKey {
            case artifactFileName = "artifactFileName"
            case artifactId = "artifactId"
        }
    }

    public struct AutoBranchCreationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The basic authorization credentials for the autocreated branch. You must base64-encode the authorization credentials and provide them in the format user:password.
        public let basicAuthCredentials: String?
        /// The build specification (build spec) for the autocreated branch.
        public let buildSpec: String?
        /// Enables auto building for the autocreated branch.
        public let enableAutoBuild: Bool?
        /// Enables basic authorization for the autocreated branch.
        public let enableBasicAuth: Bool?
        /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
        public let enablePerformanceMode: Bool?
        /// Enables pull request previews for the autocreated branch.
        public let enablePullRequestPreview: Bool?
        /// The environment variables for the autocreated branch.
        public let environmentVariables: [String: String]?
        /// The framework for the autocreated branch.
        public let framework: String?
        /// The Amplify environment name for the pull request.
        public let pullRequestEnvironmentName: String?
        /// Describes the current stage for the autocreated branch.
        public let stage: Stage?

        @inlinable
        public init(basicAuthCredentials: String? = nil, buildSpec: String? = nil, enableAutoBuild: Bool? = nil, enableBasicAuth: Bool? = nil, enablePerformanceMode: Bool? = nil, enablePullRequestPreview: Bool? = nil, environmentVariables: [String: String]? = nil, framework: String? = nil, pullRequestEnvironmentName: String? = nil, stage: Stage? = nil) {
            self.basicAuthCredentials = basicAuthCredentials
            self.buildSpec = buildSpec
            self.enableAutoBuild = enableAutoBuild
            self.enableBasicAuth = enableBasicAuth
            self.enablePerformanceMode = enablePerformanceMode
            self.enablePullRequestPreview = enablePullRequestPreview
            self.environmentVariables = environmentVariables
            self.framework = framework
            self.pullRequestEnvironmentName = pullRequestEnvironmentName
            self.stage = stage
        }

        public func validate(name: String) throws {
            try self.validate(self.basicAuthCredentials, name: "basicAuthCredentials", parent: name, max: 2000)
            try self.validate(self.basicAuthCredentials, name: "basicAuthCredentials", parent: name, pattern: "^(?s)")
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, max: 25000)
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, min: 1)
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, pattern: "^(?s).+$")
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 255)
                try validate($0.key, name: "environmentVariables.key", parent: name, pattern: "^(?s)")
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5500)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, pattern: "^(?s)")
            }
            try self.validate(self.framework, name: "framework", parent: name, max: 255)
            try self.validate(self.framework, name: "framework", parent: name, pattern: "^(?s)")
            try self.validate(self.pullRequestEnvironmentName, name: "pullRequestEnvironmentName", parent: name, max: 20)
            try self.validate(self.pullRequestEnvironmentName, name: "pullRequestEnvironmentName", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: String, CodingKey {
            case basicAuthCredentials = "basicAuthCredentials"
            case buildSpec = "buildSpec"
            case enableAutoBuild = "enableAutoBuild"
            case enableBasicAuth = "enableBasicAuth"
            case enablePerformanceMode = "enablePerformanceMode"
            case enablePullRequestPreview = "enablePullRequestPreview"
            case environmentVariables = "environmentVariables"
            case framework = "framework"
            case pullRequestEnvironmentName = "pullRequestEnvironmentName"
            case stage = "stage"
        }
    }

    public struct Backend: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the CloudFormation stack.
        public let stackArn: String?

        @inlinable
        public init(stackArn: String? = nil) {
            self.stackArn = stackArn
        }

        public func validate(name: String) throws {
            try self.validate(self.stackArn, name: "stackArn", parent: name, max: 2048)
            try self.validate(self.stackArn, name: "stackArn", parent: name, min: 20)
            try self.validate(self.stackArn, name: "stackArn", parent: name, pattern: "^arn:aws:cloudformation:[a-z0-9-]+:\\d{12}:stack/.+/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case stackArn = "stackArn"
        }
    }

    public struct BackendEnvironment: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify app.
        public let backendEnvironmentArn: String
        /// The creation date and time for a backend environment that is part of an Amplify app.
        public let createTime: Date
        /// The name of deployment artifacts.
        public let deploymentArtifacts: String?
        /// The name for a backend environment that is part of an Amplify app.
        public let environmentName: String
        /// The AWS CloudFormation stack name of a backend environment.
        public let stackName: String?
        /// The last updated date and time for a backend environment that is part of an Amplify app.
        public let updateTime: Date

        @inlinable
        public init(backendEnvironmentArn: String, createTime: Date, deploymentArtifacts: String? = nil, environmentName: String, stackName: String? = nil, updateTime: Date) {
            self.backendEnvironmentArn = backendEnvironmentArn
            self.createTime = createTime
            self.deploymentArtifacts = deploymentArtifacts
            self.environmentName = environmentName
            self.stackName = stackName
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case backendEnvironmentArn = "backendEnvironmentArn"
            case createTime = "createTime"
            case deploymentArtifacts = "deploymentArtifacts"
            case environmentName = "environmentName"
            case stackName = "stackName"
            case updateTime = "updateTime"
        }
    }

    public struct Branch: AWSDecodableShape {
        ///  The ID of the active job for a branch of an Amplify app.
        public let activeJobId: String
        ///  A list of custom resources that are linked to this branch.
        public let associatedResources: [String]?
        public let backend: Backend?
        ///  The Amazon Resource Name (ARN) for a backend environment that is part of an Amplify app.  This property is available to Amplify Gen 1 apps only. When you deploy an application with Amplify Gen 2, you provision the app's backend infrastructure using Typescript code.
        public let backendEnvironmentArn: String?
        ///  The basic authorization credentials for a branch of an Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
        public let basicAuthCredentials: String?
        ///  The Amazon Resource Name (ARN) for a branch that is part of an Amplify app.
        public let branchArn: String
        ///  The name for the branch that is part of an Amplify app.
        public let branchName: String
        ///  The build specification (build spec) content for the branch of an Amplify app.
        public let buildSpec: String?
        /// The Amazon Resource Name (ARN) of the IAM role for a branch of an SSR app. The Compute role allows the Amplify Hosting compute service to securely access specific Amazon Web Services resources based on the role's permissions. For more information about the SSR Compute role, see Adding an SSR Compute role in the Amplify User Guide.
        public let computeRoleArn: String?
        /// A timestamp of when Amplify created the branch.
        public let createTime: Date
        ///  The custom domains for a branch of an Amplify app.
        public let customDomains: [String]
        ///  The description for the branch that is part of an Amplify app.
        public let description: String
        ///  The destination branch if the branch is a pull request branch.
        public let destinationBranch: String?
        ///  The display name for the branch. This is used as the default domain prefix.
        public let displayName: String
        ///  Enables auto-building on push for a branch of an Amplify app.
        public let enableAutoBuild: Bool
        ///  Enables basic authorization for a branch of an Amplify app.
        public let enableBasicAuth: Bool
        ///  Enables notifications for a branch that is part of an Amplify app.
        public let enableNotification: Bool
        /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
        public let enablePerformanceMode: Bool?
        ///  Enables pull request previews for the branch.
        public let enablePullRequestPreview: Bool
        /// Specifies whether the skew protection feature is enabled for the branch. Deployment skew protection is available to Amplify applications to eliminate version skew issues between client and servers in web applications. When you apply skew protection to a branch, you can ensure that your clients always interact with the correct version of server-side assets, regardless of when a deployment occurs. For more information about skew protection, see Skew protection for Amplify deployments in the Amplify User Guide.
        public let enableSkewProtection: Bool?
        ///  The environment variables specific to a branch of an Amplify app.
        public let environmentVariables: [String: String]
        ///  The framework for a branch of an Amplify app.
        public let framework: String
        ///  The Amplify environment name for the pull request.
        public let pullRequestEnvironmentName: String?
        ///  The source branch if the branch is a pull request branch.
        public let sourceBranch: String?
        ///  The current stage for the branch that is part of an Amplify app.
        public let stage: Stage
        ///  The tag for the branch of an Amplify app.
        public let tags: [String: String]?
        ///  The thumbnail URL for the branch of an Amplify app.
        public let thumbnailUrl: String?
        ///  The total number of jobs that are part of an Amplify app.
        public let totalNumberOfJobs: String
        ///  The content Time to Live (TTL) for the website in seconds.
        public let ttl: String
        /// A timestamp for the last updated time for a branch.
        public let updateTime: Date

        @inlinable
        public init(activeJobId: String, associatedResources: [String]? = nil, backend: Backend? = nil, backendEnvironmentArn: String? = nil, basicAuthCredentials: String? = nil, branchArn: String, branchName: String, buildSpec: String? = nil, computeRoleArn: String? = nil, createTime: Date, customDomains: [String], description: String, destinationBranch: String? = nil, displayName: String, enableAutoBuild: Bool, enableBasicAuth: Bool, enableNotification: Bool, enablePerformanceMode: Bool? = nil, enablePullRequestPreview: Bool, enableSkewProtection: Bool? = nil, environmentVariables: [String: String], framework: String, pullRequestEnvironmentName: String? = nil, sourceBranch: String? = nil, stage: Stage, tags: [String: String]? = nil, thumbnailUrl: String? = nil, totalNumberOfJobs: String, ttl: String, updateTime: Date) {
            self.activeJobId = activeJobId
            self.associatedResources = associatedResources
            self.backend = backend
            self.backendEnvironmentArn = backendEnvironmentArn
            self.basicAuthCredentials = basicAuthCredentials
            self.branchArn = branchArn
            self.branchName = branchName
            self.buildSpec = buildSpec
            self.computeRoleArn = computeRoleArn
            self.createTime = createTime
            self.customDomains = customDomains
            self.description = description
            self.destinationBranch = destinationBranch
            self.displayName = displayName
            self.enableAutoBuild = enableAutoBuild
            self.enableBasicAuth = enableBasicAuth
            self.enableNotification = enableNotification
            self.enablePerformanceMode = enablePerformanceMode
            self.enablePullRequestPreview = enablePullRequestPreview
            self.enableSkewProtection = enableSkewProtection
            self.environmentVariables = environmentVariables
            self.framework = framework
            self.pullRequestEnvironmentName = pullRequestEnvironmentName
            self.sourceBranch = sourceBranch
            self.stage = stage
            self.tags = tags
            self.thumbnailUrl = thumbnailUrl
            self.totalNumberOfJobs = totalNumberOfJobs
            self.ttl = ttl
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case activeJobId = "activeJobId"
            case associatedResources = "associatedResources"
            case backend = "backend"
            case backendEnvironmentArn = "backendEnvironmentArn"
            case basicAuthCredentials = "basicAuthCredentials"
            case branchArn = "branchArn"
            case branchName = "branchName"
            case buildSpec = "buildSpec"
            case computeRoleArn = "computeRoleArn"
            case createTime = "createTime"
            case customDomains = "customDomains"
            case description = "description"
            case destinationBranch = "destinationBranch"
            case displayName = "displayName"
            case enableAutoBuild = "enableAutoBuild"
            case enableBasicAuth = "enableBasicAuth"
            case enableNotification = "enableNotification"
            case enablePerformanceMode = "enablePerformanceMode"
            case enablePullRequestPreview = "enablePullRequestPreview"
            case enableSkewProtection = "enableSkewProtection"
            case environmentVariables = "environmentVariables"
            case framework = "framework"
            case pullRequestEnvironmentName = "pullRequestEnvironmentName"
            case sourceBranch = "sourceBranch"
            case stage = "stage"
            case tags = "tags"
            case thumbnailUrl = "thumbnailUrl"
            case totalNumberOfJobs = "totalNumberOfJobs"
            case ttl = "ttl"
            case updateTime = "updateTime"
        }
    }

    public struct CacheConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of cache configuration to use for an Amplify app. The AMPLIFY_MANAGED cache configuration automatically applies an optimized cache configuration for your app based on its platform, routing rules, and rewrite rules. This is the default setting. The AMPLIFY_MANAGED_NO_COOKIES cache configuration type is the same as AMPLIFY_MANAGED, except that it excludes all cookies from the cache key.
        public let type: CacheConfigType

        @inlinable
        public init(type: CacheConfigType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct Certificate: AWSDecodableShape {
        /// The DNS record for certificate verification.
        public let certificateVerificationDNSRecord: String?
        /// The Amazon resource name (ARN) for a custom certificate that you have already added to Certificate Manager in your Amazon Web Services account.  This field is required only when the certificate type is CUSTOM.
        public let customCertificateArn: String?
        /// The type of SSL/TLS certificate that you want to use. Specify AMPLIFY_MANAGED to use the default certificate that Amplify provisions for you. Specify CUSTOM to use your own certificate that you have already added to Certificate Manager in your Amazon Web Services account. Make sure you request (or import) the certificate in the US East (N. Virginia) Region (us-east-1). For more information about using ACM, see Importing certificates into Certificate Manager in the ACM User guide.
        public let type: CertificateType

        @inlinable
        public init(certificateVerificationDNSRecord: String? = nil, customCertificateArn: String? = nil, type: CertificateType) {
            self.certificateVerificationDNSRecord = certificateVerificationDNSRecord
            self.customCertificateArn = customCertificateArn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case certificateVerificationDNSRecord = "certificateVerificationDNSRecord"
            case customCertificateArn = "customCertificateArn"
            case type = "type"
        }
    }

    public struct CertificateSettings: AWSEncodableShape {
        /// The Amazon resource name (ARN) for the custom certificate that you have already added to Certificate Manager in your Amazon Web Services account. This field is required only when the certificate type is CUSTOM.
        public let customCertificateArn: String?
        /// The certificate type. Specify AMPLIFY_MANAGED to use the default certificate that Amplify provisions for you. Specify CUSTOM to use your own certificate that you have already added to Certificate Manager in your Amazon Web Services account. Make sure you request (or import) the certificate in the US East (N. Virginia) Region (us-east-1). For more information about using ACM, see Importing certificates into Certificate Manager in the ACM User guide.
        public let type: CertificateType

        @inlinable
        public init(customCertificateArn: String? = nil, type: CertificateType) {
            self.customCertificateArn = customCertificateArn
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.customCertificateArn, name: "customCertificateArn", parent: name, max: 1000)
            try self.validate(self.customCertificateArn, name: "customCertificateArn", parent: name, pattern: "^arn:aws:acm:[a-z0-9-]+:\\d{12}:certificate\\/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customCertificateArn = "customCertificateArn"
            case type = "type"
        }
    }

    public struct CreateAppRequest: AWSEncodableShape {
        /// The personal access token for a GitHub repository for an Amplify app. The personal access token is used to authorize access to a GitHub repository using the Amplify GitHub App. The token is not stored. Use accessToken for GitHub repositories only. To authorize access to a repository provider such as Bitbucket or CodeCommit, use oauthToken. You must specify either accessToken or oauthToken when you create a new app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see Migrating an existing OAuth app to the Amplify GitHub App in the Amplify User Guide .
        public let accessToken: String?
        /// The automated branch creation configuration for an Amplify app.
        public let autoBranchCreationConfig: AutoBranchCreationConfig?
        /// The automated branch creation glob patterns for an Amplify app.
        public let autoBranchCreationPatterns: [String]?
        /// The credentials for basic authorization for an Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
        public let basicAuthCredentials: String?
        /// The build specification (build spec) for an Amplify app.
        public let buildSpec: String?
        /// The cache configuration for the Amplify app.
        public let cacheConfig: CacheConfig?
        /// The Amazon Resource Name (ARN) of the IAM role to assign to an SSR app. The SSR Compute role allows the Amplify Hosting compute service to securely access specific Amazon Web Services resources based on the role's permissions. For more information about the SSR Compute role, see Adding an SSR Compute role in the Amplify User Guide.
        public let computeRoleArn: String?
        /// The custom HTTP headers for an Amplify app.
        public let customHeaders: String?
        /// The custom rewrite and redirect rules for an Amplify app.
        public let customRules: [CustomRule]?
        /// The description of the Amplify app.
        public let description: String?
        /// Enables automated branch creation for an Amplify app.
        public let enableAutoBranchCreation: Bool?
        /// Enables basic authorization for an Amplify app. This will apply to all branches that are part of this app.
        public let enableBasicAuth: Bool?
        /// Enables the auto building of branches for an Amplify app.
        public let enableBranchAutoBuild: Bool?
        /// Automatically disconnects a branch in the Amplify console when you delete a branch from your Git repository.
        public let enableBranchAutoDeletion: Bool?
        /// The environment variables map for an Amplify app.  For a list of the environment variables that are accessible to Amplify by default, see Amplify Environment variables in the Amplify Hosting User Guide.
        public let environmentVariables: [String: String]?
        /// The Amazon Resource Name (ARN) of the IAM service role for the Amplify app.
        public let iamServiceRoleArn: String?
        /// The name of the Amplify app.
        public let name: String
        /// The OAuth token for a third-party source control system for an Amplify app. The OAuth token is used to create a webhook and a read-only deploy key using SSH cloning. The OAuth token is not stored. Use oauthToken for repository providers other than GitHub, such as Bitbucket or CodeCommit. To authorize access to GitHub as your repository provider, use accessToken. You must specify either oauthToken or accessToken when you create a new app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see Migrating an existing OAuth app to the Amplify GitHub App in the Amplify User Guide .
        public let oauthToken: String?
        /// The platform for the Amplify app. For a static app, set the platform type to WEB. For a dynamic server-side rendered (SSR) app, set the platform type to WEB_COMPUTE. For an app requiring Amplify Hosting's original SSR support only, set the platform type to WEB_DYNAMIC. If you are deploying an SSG only app with Next.js version 14 or later, you must set the platform type to WEB_COMPUTE and set the artifacts baseDirectory to .next in the application's build settings. For an example of the build specification settings, see Amplify build settings for a Next.js 14 SSG application in the Amplify Hosting User Guide.
        public let platform: Platform?
        /// The Git repository for the Amplify app.
        public let repository: String?
        /// The tag for an Amplify app.
        public let tags: [String: String]?

        @inlinable
        public init(accessToken: String? = nil, autoBranchCreationConfig: AutoBranchCreationConfig? = nil, autoBranchCreationPatterns: [String]? = nil, basicAuthCredentials: String? = nil, buildSpec: String? = nil, cacheConfig: CacheConfig? = nil, computeRoleArn: String? = nil, customHeaders: String? = nil, customRules: [CustomRule]? = nil, description: String? = nil, enableAutoBranchCreation: Bool? = nil, enableBasicAuth: Bool? = nil, enableBranchAutoBuild: Bool? = nil, enableBranchAutoDeletion: Bool? = nil, environmentVariables: [String: String]? = nil, iamServiceRoleArn: String? = nil, name: String, oauthToken: String? = nil, platform: Platform? = nil, repository: String? = nil, tags: [String: String]? = nil) {
            self.accessToken = accessToken
            self.autoBranchCreationConfig = autoBranchCreationConfig
            self.autoBranchCreationPatterns = autoBranchCreationPatterns
            self.basicAuthCredentials = basicAuthCredentials
            self.buildSpec = buildSpec
            self.cacheConfig = cacheConfig
            self.computeRoleArn = computeRoleArn
            self.customHeaders = customHeaders
            self.customRules = customRules
            self.description = description
            self.enableAutoBranchCreation = enableAutoBranchCreation
            self.enableBasicAuth = enableBasicAuth
            self.enableBranchAutoBuild = enableBranchAutoBuild
            self.enableBranchAutoDeletion = enableBranchAutoDeletion
            self.environmentVariables = environmentVariables
            self.iamServiceRoleArn = iamServiceRoleArn
            self.name = name
            self.oauthToken = oauthToken
            self.platform = platform
            self.repository = repository
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 255)
            try self.validate(self.accessToken, name: "accessToken", parent: name, min: 1)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^(?s).+$")
            try self.autoBranchCreationConfig?.validate(name: "\(name).autoBranchCreationConfig")
            try self.autoBranchCreationPatterns?.forEach {
                try validate($0, name: "autoBranchCreationPatterns[]", parent: name, max: 2048)
                try validate($0, name: "autoBranchCreationPatterns[]", parent: name, min: 1)
                try validate($0, name: "autoBranchCreationPatterns[]", parent: name, pattern: "^(?s).+$")
            }
            try self.validate(self.basicAuthCredentials, name: "basicAuthCredentials", parent: name, max: 2000)
            try self.validate(self.basicAuthCredentials, name: "basicAuthCredentials", parent: name, pattern: "^(?s)")
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, max: 25000)
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, min: 1)
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, pattern: "^(?s).+$")
            try self.validate(self.computeRoleArn, name: "computeRoleArn", parent: name, max: 1000)
            try self.validate(self.computeRoleArn, name: "computeRoleArn", parent: name, pattern: "^(?s)")
            try self.validate(self.customHeaders, name: "customHeaders", parent: name, max: 25000)
            try self.validate(self.customHeaders, name: "customHeaders", parent: name, pattern: "^(?s)")
            try self.customRules?.forEach {
                try $0.validate(name: "\(name).customRules[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?s)")
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 255)
                try validate($0.key, name: "environmentVariables.key", parent: name, pattern: "^(?s)")
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5500)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, pattern: "^(?s)")
            }
            try self.validate(self.iamServiceRoleArn, name: "iamServiceRoleArn", parent: name, max: 1000)
            try self.validate(self.iamServiceRoleArn, name: "iamServiceRoleArn", parent: name, pattern: "^(?s)")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?s).+$")
            try self.validate(self.oauthToken, name: "oauthToken", parent: name, max: 1000)
            try self.validate(self.oauthToken, name: "oauthToken", parent: name, pattern: "^(?s)")
            try self.validate(self.repository, name: "repository", parent: name, max: 1000)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^(?s)")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case autoBranchCreationConfig = "autoBranchCreationConfig"
            case autoBranchCreationPatterns = "autoBranchCreationPatterns"
            case basicAuthCredentials = "basicAuthCredentials"
            case buildSpec = "buildSpec"
            case cacheConfig = "cacheConfig"
            case computeRoleArn = "computeRoleArn"
            case customHeaders = "customHeaders"
            case customRules = "customRules"
            case description = "description"
            case enableAutoBranchCreation = "enableAutoBranchCreation"
            case enableBasicAuth = "enableBasicAuth"
            case enableBranchAutoBuild = "enableBranchAutoBuild"
            case enableBranchAutoDeletion = "enableBranchAutoDeletion"
            case environmentVariables = "environmentVariables"
            case iamServiceRoleArn = "iamServiceRoleArn"
            case name = "name"
            case oauthToken = "oauthToken"
            case platform = "platform"
            case repository = "repository"
            case tags = "tags"
        }
    }

    public struct CreateAppResult: AWSDecodableShape {
        public let app: App

        @inlinable
        public init(app: App) {
            self.app = app
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
        }
    }

    public struct CreateBackendEnvironmentRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String
        /// The name of deployment artifacts.
        public let deploymentArtifacts: String?
        /// The name for the backend environment.
        public let environmentName: String
        /// The AWS CloudFormation stack name of a backend environment.
        public let stackName: String?

        @inlinable
        public init(appId: String, deploymentArtifacts: String? = nil, environmentName: String, stackName: String? = nil) {
            self.appId = appId
            self.deploymentArtifacts = deploymentArtifacts
            self.environmentName = environmentName
            self.stackName = stackName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            try container.encodeIfPresent(self.deploymentArtifacts, forKey: .deploymentArtifacts)
            try container.encode(self.environmentName, forKey: .environmentName)
            try container.encodeIfPresent(self.stackName, forKey: .stackName)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.deploymentArtifacts, name: "deploymentArtifacts", parent: name, max: 1000)
            try self.validate(self.deploymentArtifacts, name: "deploymentArtifacts", parent: name, min: 1)
            try self.validate(self.deploymentArtifacts, name: "deploymentArtifacts", parent: name, pattern: "^(?s).+$")
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 255)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.stackName, name: "stackName", parent: name, max: 255)
            try self.validate(self.stackName, name: "stackName", parent: name, min: 1)
            try self.validate(self.stackName, name: "stackName", parent: name, pattern: "^(?s).+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentArtifacts = "deploymentArtifacts"
            case environmentName = "environmentName"
            case stackName = "stackName"
        }
    }

    public struct CreateBackendEnvironmentResult: AWSDecodableShape {
        /// Describes the backend environment for an Amplify app.
        public let backendEnvironment: BackendEnvironment

        @inlinable
        public init(backendEnvironment: BackendEnvironment) {
            self.backendEnvironment = backendEnvironment
        }

        private enum CodingKeys: String, CodingKey {
            case backendEnvironment = "backendEnvironment"
        }
    }

    public struct CreateBranchRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        /// The backend for a Branch of an Amplify app. Use for a backend created from an CloudFormation stack. This field is available to Amplify Gen 2 apps only. When you deploy an application with Amplify Gen 2, you provision the app's backend infrastructure using Typescript code.
        public let backend: Backend?
        /// The Amazon Resource Name (ARN) for a backend environment that is part of a Gen 1 Amplify app.  This field is available to Amplify Gen 1 apps only where the backend is created using Amplify Studio or the Amplify command line interface (CLI).
        public let backendEnvironmentArn: String?
        ///  The basic authorization credentials for the branch. You must base64-encode the authorization credentials and provide them in the format user:password.
        public let basicAuthCredentials: String?
        /// The name for the branch.
        public let branchName: String
        ///  The build specification (build spec) for the branch.
        public let buildSpec: String?
        /// The Amazon Resource Name (ARN) of the IAM role to assign to a branch of an SSR app. The SSR Compute role allows the Amplify Hosting compute service to securely access specific Amazon Web Services resources based on the role's permissions. For more information about the SSR Compute role, see Adding an SSR Compute role in the Amplify User Guide.
        public let computeRoleArn: String?
        /// The description for the branch.
        public let description: String?
        ///  The display name for a branch. This is used as the default domain prefix.
        public let displayName: String?
        ///  Enables auto building for the branch.
        public let enableAutoBuild: Bool?
        ///  Enables basic authorization for the branch.
        public let enableBasicAuth: Bool?
        ///  Enables notifications for the branch.
        public let enableNotification: Bool?
        /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
        public let enablePerformanceMode: Bool?
        ///  Enables pull request previews for this branch.
        public let enablePullRequestPreview: Bool?
        /// Specifies whether the skew protection feature is enabled for the branch. Deployment skew protection is available to Amplify applications to eliminate version skew issues between client and servers in web applications. When you apply skew protection to a branch, you can ensure that your clients always interact with the correct version of server-side assets, regardless of when a deployment occurs. For more information about skew protection, see Skew protection for Amplify deployments in the Amplify User Guide.
        public let enableSkewProtection: Bool?
        ///  The environment variables for the branch.
        public let environmentVariables: [String: String]?
        ///  The framework for the branch.
        public let framework: String?
        ///  The Amplify environment name for the pull request.
        public let pullRequestEnvironmentName: String?
        /// Describes the current stage for the branch.
        public let stage: Stage?
        ///  The tag for the branch.
        public let tags: [String: String]?
        ///  The content Time To Live (TTL) for the website in seconds.
        public let ttl: String?

        @inlinable
        public init(appId: String, backend: Backend? = nil, backendEnvironmentArn: String? = nil, basicAuthCredentials: String? = nil, branchName: String, buildSpec: String? = nil, computeRoleArn: String? = nil, description: String? = nil, displayName: String? = nil, enableAutoBuild: Bool? = nil, enableBasicAuth: Bool? = nil, enableNotification: Bool? = nil, enablePerformanceMode: Bool? = nil, enablePullRequestPreview: Bool? = nil, enableSkewProtection: Bool? = nil, environmentVariables: [String: String]? = nil, framework: String? = nil, pullRequestEnvironmentName: String? = nil, stage: Stage? = nil, tags: [String: String]? = nil, ttl: String? = nil) {
            self.appId = appId
            self.backend = backend
            self.backendEnvironmentArn = backendEnvironmentArn
            self.basicAuthCredentials = basicAuthCredentials
            self.branchName = branchName
            self.buildSpec = buildSpec
            self.computeRoleArn = computeRoleArn
            self.description = description
            self.displayName = displayName
            self.enableAutoBuild = enableAutoBuild
            self.enableBasicAuth = enableBasicAuth
            self.enableNotification = enableNotification
            self.enablePerformanceMode = enablePerformanceMode
            self.enablePullRequestPreview = enablePullRequestPreview
            self.enableSkewProtection = enableSkewProtection
            self.environmentVariables = environmentVariables
            self.framework = framework
            self.pullRequestEnvironmentName = pullRequestEnvironmentName
            self.stage = stage
            self.tags = tags
            self.ttl = ttl
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            try container.encodeIfPresent(self.backend, forKey: .backend)
            try container.encodeIfPresent(self.backendEnvironmentArn, forKey: .backendEnvironmentArn)
            try container.encodeIfPresent(self.basicAuthCredentials, forKey: .basicAuthCredentials)
            try container.encode(self.branchName, forKey: .branchName)
            try container.encodeIfPresent(self.buildSpec, forKey: .buildSpec)
            try container.encodeIfPresent(self.computeRoleArn, forKey: .computeRoleArn)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.enableAutoBuild, forKey: .enableAutoBuild)
            try container.encodeIfPresent(self.enableBasicAuth, forKey: .enableBasicAuth)
            try container.encodeIfPresent(self.enableNotification, forKey: .enableNotification)
            try container.encodeIfPresent(self.enablePerformanceMode, forKey: .enablePerformanceMode)
            try container.encodeIfPresent(self.enablePullRequestPreview, forKey: .enablePullRequestPreview)
            try container.encodeIfPresent(self.enableSkewProtection, forKey: .enableSkewProtection)
            try container.encodeIfPresent(self.environmentVariables, forKey: .environmentVariables)
            try container.encodeIfPresent(self.framework, forKey: .framework)
            try container.encodeIfPresent(self.pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
            try container.encodeIfPresent(self.stage, forKey: .stage)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.ttl, forKey: .ttl)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.backend?.validate(name: "\(name).backend")
            try self.validate(self.backendEnvironmentArn, name: "backendEnvironmentArn", parent: name, max: 1000)
            try self.validate(self.backendEnvironmentArn, name: "backendEnvironmentArn", parent: name, pattern: "^(?s)")
            try self.validate(self.basicAuthCredentials, name: "basicAuthCredentials", parent: name, max: 2000)
            try self.validate(self.basicAuthCredentials, name: "basicAuthCredentials", parent: name, pattern: "^(?s)")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, max: 25000)
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, min: 1)
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, pattern: "^(?s).+$")
            try self.validate(self.computeRoleArn, name: "computeRoleArn", parent: name, max: 1000)
            try self.validate(self.computeRoleArn, name: "computeRoleArn", parent: name, pattern: "^(?s)")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?s)")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^(?s)")
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 255)
                try validate($0.key, name: "environmentVariables.key", parent: name, pattern: "^(?s)")
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5500)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, pattern: "^(?s)")
            }
            try self.validate(self.framework, name: "framework", parent: name, max: 255)
            try self.validate(self.framework, name: "framework", parent: name, pattern: "^(?s)")
            try self.validate(self.pullRequestEnvironmentName, name: "pullRequestEnvironmentName", parent: name, max: 20)
            try self.validate(self.pullRequestEnvironmentName, name: "pullRequestEnvironmentName", parent: name, pattern: "^(?s)")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.ttl, name: "ttl", parent: name, max: 32)
            try self.validate(self.ttl, name: "ttl", parent: name, pattern: "^\\d*$")
        }

        private enum CodingKeys: String, CodingKey {
            case backend = "backend"
            case backendEnvironmentArn = "backendEnvironmentArn"
            case basicAuthCredentials = "basicAuthCredentials"
            case branchName = "branchName"
            case buildSpec = "buildSpec"
            case computeRoleArn = "computeRoleArn"
            case description = "description"
            case displayName = "displayName"
            case enableAutoBuild = "enableAutoBuild"
            case enableBasicAuth = "enableBasicAuth"
            case enableNotification = "enableNotification"
            case enablePerformanceMode = "enablePerformanceMode"
            case enablePullRequestPreview = "enablePullRequestPreview"
            case enableSkewProtection = "enableSkewProtection"
            case environmentVariables = "environmentVariables"
            case framework = "framework"
            case pullRequestEnvironmentName = "pullRequestEnvironmentName"
            case stage = "stage"
            case tags = "tags"
            case ttl = "ttl"
        }
    }

    public struct CreateBranchResult: AWSDecodableShape {
        ///  Describes the branch for an Amplify app, which maps to a third-party repository branch.
        public let branch: Branch

        @inlinable
        public init(branch: Branch) {
            self.branch = branch
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
        }
    }

    public struct CreateDeploymentRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        ///  The name of the branch to use for the job.
        public let branchName: String
        ///  An optional file map that contains the file name as the key and the file content md5 hash as the value. If this argument is provided, the service will generate a unique upload URL per file. Otherwise, the service will only generate a single upload URL for the zipped files.
        public let fileMap: [String: String]?

        @inlinable
        public init(appId: String, branchName: String, fileMap: [String: String]? = nil) {
            self.appId = appId
            self.branchName = branchName
            self.fileMap = fileMap
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.branchName, key: "branchName")
            try container.encodeIfPresent(self.fileMap, forKey: .fileMap)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.fileMap?.forEach {
                try validate($0.key, name: "fileMap.key", parent: name, max: 255)
                try validate($0.key, name: "fileMap.key", parent: name, pattern: "^(?s)")
                try validate($0.value, name: "fileMap[\"\($0.key)\"]", parent: name, max: 32)
                try validate($0.value, name: "fileMap[\"\($0.key)\"]", parent: name, pattern: "^(?s)")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fileMap = "fileMap"
        }
    }

    public struct CreateDeploymentResult: AWSDecodableShape {
        ///  When the fileMap argument is provided in the request, fileUploadUrls will contain a map of file names to upload URLs.
        public let fileUploadUrls: [String: String]
        ///  The job ID for this deployment. will supply to start deployment api.
        public let jobId: String?
        ///  When the fileMap argument is not provided in the request, this zipUploadUrl is returned.
        public let zipUploadUrl: String

        @inlinable
        public init(fileUploadUrls: [String: String], jobId: String? = nil, zipUploadUrl: String) {
            self.fileUploadUrls = fileUploadUrls
            self.jobId = jobId
            self.zipUploadUrl = zipUploadUrl
        }

        private enum CodingKeys: String, CodingKey {
            case fileUploadUrls = "fileUploadUrls"
            case jobId = "jobId"
            case zipUploadUrl = "zipUploadUrl"
        }
    }

    public struct CreateDomainAssociationRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        ///  Sets the branch patterns for automatic subdomain creation.
        public let autoSubDomainCreationPatterns: [String]?
        ///  The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains.
        public let autoSubDomainIAMRole: String?
        /// The type of SSL/TLS certificate to use for your custom domain. If you don't specify a certificate type, Amplify uses the default certificate that it provisions and manages for you.
        public let certificateSettings: CertificateSettings?
        ///  The domain name for the domain association.
        public let domainName: String
        ///  Enables the automated creation of subdomains for branches.
        public let enableAutoSubDomain: Bool?
        ///  The setting for the subdomain.
        public let subDomainSettings: [SubDomainSetting]

        @inlinable
        public init(appId: String, autoSubDomainCreationPatterns: [String]? = nil, autoSubDomainIAMRole: String? = nil, certificateSettings: CertificateSettings? = nil, domainName: String, enableAutoSubDomain: Bool? = nil, subDomainSettings: [SubDomainSetting]) {
            self.appId = appId
            self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
            self.autoSubDomainIAMRole = autoSubDomainIAMRole
            self.certificateSettings = certificateSettings
            self.domainName = domainName
            self.enableAutoSubDomain = enableAutoSubDomain
            self.subDomainSettings = subDomainSettings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            try container.encodeIfPresent(self.autoSubDomainCreationPatterns, forKey: .autoSubDomainCreationPatterns)
            try container.encodeIfPresent(self.autoSubDomainIAMRole, forKey: .autoSubDomainIAMRole)
            try container.encodeIfPresent(self.certificateSettings, forKey: .certificateSettings)
            try container.encode(self.domainName, forKey: .domainName)
            try container.encodeIfPresent(self.enableAutoSubDomain, forKey: .enableAutoSubDomain)
            try container.encode(self.subDomainSettings, forKey: .subDomainSettings)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.autoSubDomainCreationPatterns?.forEach {
                try validate($0, name: "autoSubDomainCreationPatterns[]", parent: name, max: 2048)
                try validate($0, name: "autoSubDomainCreationPatterns[]", parent: name, min: 1)
                try validate($0, name: "autoSubDomainCreationPatterns[]", parent: name, pattern: "^(?s).+$")
            }
            try self.validate(self.autoSubDomainIAMRole, name: "autoSubDomainIAMRole", parent: name, max: 1000)
            try self.validate(self.autoSubDomainIAMRole, name: "autoSubDomainIAMRole", parent: name, pattern: "^$|^arn:aws:iam::\\d{12}:role.+$")
            try self.certificateSettings?.validate(name: "\(name).certificateSettings")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])(\\.)?$")
            try self.subDomainSettings.forEach {
                try $0.validate(name: "\(name).subDomainSettings[]")
            }
            try self.validate(self.subDomainSettings, name: "subDomainSettings", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case autoSubDomainCreationPatterns = "autoSubDomainCreationPatterns"
            case autoSubDomainIAMRole = "autoSubDomainIAMRole"
            case certificateSettings = "certificateSettings"
            case domainName = "domainName"
            case enableAutoSubDomain = "enableAutoSubDomain"
            case subDomainSettings = "subDomainSettings"
        }
    }

    public struct CreateDomainAssociationResult: AWSDecodableShape {
        ///  Describes the structure of a domain association, which associates a custom domain with an Amplify app.
        public let domainAssociation: DomainAssociation

        @inlinable
        public init(domainAssociation: DomainAssociation) {
            self.domainAssociation = domainAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case domainAssociation = "domainAssociation"
        }
    }

    public struct CreateWebhookRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String
        /// The name for a branch that is part of an Amplify app.
        public let branchName: String
        /// The description for a webhook.
        public let description: String?

        @inlinable
        public init(appId: String, branchName: String, description: String? = nil) {
            self.appId = appId
            self.branchName = branchName
            self.description = description
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            try container.encode(self.branchName, forKey: .branchName)
            try container.encodeIfPresent(self.description, forKey: .description)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branchName"
            case description = "description"
        }
    }

    public struct CreateWebhookResult: AWSDecodableShape {
        /// Describes a webhook that connects repository events to an Amplify app.
        public let webhook: Webhook

        @inlinable
        public init(webhook: Webhook) {
            self.webhook = webhook
        }

        private enum CodingKeys: String, CodingKey {
            case webhook = "webhook"
        }
    }

    public struct CustomRule: AWSEncodableShape & AWSDecodableShape {
        /// The condition for a URL rewrite or redirect rule, such as a country code.
        public let condition: String?
        /// The source pattern for a URL rewrite or redirect rule.
        public let source: String
        /// The status code for a URL rewrite or redirect rule.   200  Represents a 200 rewrite rule.  301  Represents a 301 (moved permanently) redirect rule. This and all future requests should be directed to the target URL.   302  Represents a 302 temporary redirect rule.  404  Represents a 404 redirect rule.  404-200  Represents a 404 rewrite rule.
        public let status: String?
        /// The target pattern for a URL rewrite or redirect rule.
        public let target: String

        @inlinable
        public init(condition: String? = nil, source: String, status: String? = nil, target: String) {
            self.condition = condition
            self.source = source
            self.status = status
            self.target = target
        }

        public func validate(name: String) throws {
            try self.validate(self.condition, name: "condition", parent: name, max: 2048)
            try self.validate(self.condition, name: "condition", parent: name, pattern: "^(?s)")
            try self.validate(self.source, name: "source", parent: name, max: 2048)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.validate(self.source, name: "source", parent: name, pattern: "^(?s).+$")
            try self.validate(self.status, name: "status", parent: name, max: 7)
            try self.validate(self.status, name: "status", parent: name, min: 3)
            try self.validate(self.status, name: "status", parent: name, pattern: "^.{3,7}$")
            try self.validate(self.target, name: "target", parent: name, max: 2048)
            try self.validate(self.target, name: "target", parent: name, min: 1)
            try self.validate(self.target, name: "target", parent: name, pattern: "^(?s).+$")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "condition"
            case source = "source"
            case status = "status"
            case target = "target"
        }
    }

    public struct DeleteAppRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String

        @inlinable
        public init(appId: String) {
            self.appId = appId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAppResult: AWSDecodableShape {
        public let app: App

        @inlinable
        public init(app: App) {
            self.app = app
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
        }
    }

    public struct DeleteBackendEnvironmentRequest: AWSEncodableShape {
        /// The unique ID of an Amplify app.
        public let appId: String
        /// The name of a backend environment of an Amplify app.
        public let environmentName: String

        @inlinable
        public init(appId: String, environmentName: String) {
            self.appId = appId
            self.environmentName = environmentName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 255)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^(?s).+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBackendEnvironmentResult: AWSDecodableShape {
        /// Describes the backend environment for an Amplify app.
        public let backendEnvironment: BackendEnvironment

        @inlinable
        public init(backendEnvironment: BackendEnvironment) {
            self.backendEnvironment = backendEnvironment
        }

        private enum CodingKeys: String, CodingKey {
            case backendEnvironment = "backendEnvironment"
        }
    }

    public struct DeleteBranchRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        /// The name of the branch.
        public let branchName: String

        @inlinable
        public init(appId: String, branchName: String) {
            self.appId = appId
            self.branchName = branchName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.branchName, key: "branchName")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBranchResult: AWSDecodableShape {
        /// The branch for an Amplify app, which maps to a third-party repository branch.
        public let branch: Branch

        @inlinable
        public init(branch: Branch) {
            self.branch = branch
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
        }
    }

    public struct DeleteDomainAssociationRequest: AWSEncodableShape {
        ///  The unique id for an Amplify app.
        public let appId: String
        ///  The name of the domain.
        public let domainName: String

        @inlinable
        public init(appId: String, domainName: String) {
            self.appId = appId
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.domainName, key: "domainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])(\\.)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainAssociationResult: AWSDecodableShape {
        public let domainAssociation: DomainAssociation

        @inlinable
        public init(domainAssociation: DomainAssociation) {
            self.domainAssociation = domainAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case domainAssociation = "domainAssociation"
        }
    }

    public struct DeleteJobRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        /// The name of the branch to use for the job.
        public let branchName: String
        ///  The unique ID for the job.
        public let jobId: String

        @inlinable
        public init(appId: String, branchName: String, jobId: String) {
            self.appId = appId
            self.branchName = branchName
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.branchName, key: "branchName")
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteJobResult: AWSDecodableShape {
        public let jobSummary: JobSummary

        @inlinable
        public init(jobSummary: JobSummary) {
            self.jobSummary = jobSummary
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummary = "jobSummary"
        }
    }

    public struct DeleteWebhookRequest: AWSEncodableShape {
        /// The unique ID for a webhook.
        public let webhookId: String

        @inlinable
        public init(webhookId: String) {
            self.webhookId = webhookId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.webhookId, key: "webhookId")
        }

        public func validate(name: String) throws {
            try self.validate(self.webhookId, name: "webhookId", parent: name, max: 255)
            try self.validate(self.webhookId, name: "webhookId", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWebhookResult: AWSDecodableShape {
        /// Describes a webhook that connects repository events to an Amplify app.
        public let webhook: Webhook

        @inlinable
        public init(webhook: Webhook) {
            self.webhook = webhook
        }

        private enum CodingKeys: String, CodingKey {
            case webhook = "webhook"
        }
    }

    public struct DomainAssociation: AWSDecodableShape {
        ///  Sets branch patterns for automatic subdomain creation.
        public let autoSubDomainCreationPatterns: [String]?
        ///  The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains.
        public let autoSubDomainIAMRole: String?
        /// Describes the SSL/TLS certificate for the domain association. This can be your own custom certificate or the default certificate that Amplify provisions for you. If you are updating your domain to use a different certificate, certificate points to the new certificate that is being created instead of the current active certificate. Otherwise, certificate points to the current active certificate.
        public let certificate: Certificate?
        ///  The DNS record for certificate verification.
        public let certificateVerificationDNSRecord: String?
        ///  The Amazon Resource Name (ARN) for the domain association.
        public let domainAssociationArn: String
        ///  The name of the domain.
        public let domainName: String
        ///  The current status of the domain association.
        public let domainStatus: DomainStatus
        ///  Enables the automated creation of subdomains for branches.
        public let enableAutoSubDomain: Bool
        ///  Additional information that describes why the domain association is in the current state.
        public let statusReason: String
        ///  The subdomains for the domain association.
        public let subDomains: [SubDomain]
        /// The status of the domain update operation that is currently in progress. The following list describes the valid update states.  REQUESTING_CERTIFICATE  The certificate is in the process of being updated.  PENDING_VERIFICATION  Indicates that an Amplify managed certificate is in the process of being verified. This occurs during the creation of a custom domain or when a custom domain is updated to use a managed certificate.  IMPORTING_CUSTOM_CERTIFICATE  Indicates that an Amplify custom certificate is in the process of being imported. This occurs during the creation of a custom domain or when a custom domain is updated to use a custom certificate.  PENDING_DEPLOYMENT  Indicates that the subdomain or certificate changes are being propagated.  AWAITING_APP_CNAME  Amplify is waiting for CNAME records corresponding to subdomains to be propagated. If your custom domain is on Route53, Amplify handles this for you automatically. For more information about custom domains, see Setting up custom domains in the Amplify Hosting User Guide.   UPDATE_COMPLETE  The certificate has been associated with a domain.  UPDATE_FAILED  The certificate has failed to be provisioned or associated, and there is no existing active certificate to roll back to.
        public let updateStatus: UpdateStatus?

        @inlinable
        public init(autoSubDomainCreationPatterns: [String]? = nil, autoSubDomainIAMRole: String? = nil, certificate: Certificate? = nil, certificateVerificationDNSRecord: String? = nil, domainAssociationArn: String, domainName: String, domainStatus: DomainStatus, enableAutoSubDomain: Bool, statusReason: String, subDomains: [SubDomain], updateStatus: UpdateStatus? = nil) {
            self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
            self.autoSubDomainIAMRole = autoSubDomainIAMRole
            self.certificate = certificate
            self.certificateVerificationDNSRecord = certificateVerificationDNSRecord
            self.domainAssociationArn = domainAssociationArn
            self.domainName = domainName
            self.domainStatus = domainStatus
            self.enableAutoSubDomain = enableAutoSubDomain
            self.statusReason = statusReason
            self.subDomains = subDomains
            self.updateStatus = updateStatus
        }

        private enum CodingKeys: String, CodingKey {
            case autoSubDomainCreationPatterns = "autoSubDomainCreationPatterns"
            case autoSubDomainIAMRole = "autoSubDomainIAMRole"
            case certificate = "certificate"
            case certificateVerificationDNSRecord = "certificateVerificationDNSRecord"
            case domainAssociationArn = "domainAssociationArn"
            case domainName = "domainName"
            case domainStatus = "domainStatus"
            case enableAutoSubDomain = "enableAutoSubDomain"
            case statusReason = "statusReason"
            case subDomains = "subDomains"
            case updateStatus = "updateStatus"
        }
    }

    public struct GenerateAccessLogsRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String
        /// The name of the domain.
        public let domainName: String
        /// The time at which the logs should end. The time range specified is inclusive of the end time.
        public let endTime: Date?
        /// The time at which the logs should start. The time range specified is inclusive of the start time.
        public let startTime: Date?

        @inlinable
        public init(appId: String, domainName: String, endTime: Date? = nil, startTime: Date? = nil) {
            self.appId = appId
            self.domainName = domainName
            self.endTime = endTime
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            try container.encode(self.domainName, forKey: .domainName)
            try container.encodeIfPresent(self.endTime, forKey: .endTime)
            try container.encodeIfPresent(self.startTime, forKey: .startTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])(\\.)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case endTime = "endTime"
            case startTime = "startTime"
        }
    }

    public struct GenerateAccessLogsResult: AWSDecodableShape {
        /// The pre-signed URL for the requested access logs.
        public let logUrl: String?

        @inlinable
        public init(logUrl: String? = nil) {
            self.logUrl = logUrl
        }

        private enum CodingKeys: String, CodingKey {
            case logUrl = "logUrl"
        }
    }

    public struct GetAppRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String

        @inlinable
        public init(appId: String) {
            self.appId = appId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAppResult: AWSDecodableShape {
        public let app: App

        @inlinable
        public init(app: App) {
            self.app = app
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
        }
    }

    public struct GetArtifactUrlRequest: AWSEncodableShape {
        /// The unique ID for an artifact.
        public let artifactId: String

        @inlinable
        public init(artifactId: String) {
            self.artifactId = artifactId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.artifactId, key: "artifactId")
        }

        public func validate(name: String) throws {
            try self.validate(self.artifactId, name: "artifactId", parent: name, max: 255)
            try self.validate(self.artifactId, name: "artifactId", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetArtifactUrlResult: AWSDecodableShape {
        /// The unique ID for an artifact.
        public let artifactId: String
        /// The presigned URL for the artifact.
        public let artifactUrl: String

        @inlinable
        public init(artifactId: String, artifactUrl: String) {
            self.artifactId = artifactId
            self.artifactUrl = artifactUrl
        }

        private enum CodingKeys: String, CodingKey {
            case artifactId = "artifactId"
            case artifactUrl = "artifactUrl"
        }
    }

    public struct GetBackendEnvironmentRequest: AWSEncodableShape {
        /// The unique id for an Amplify app.
        public let appId: String
        /// The name for the backend environment.
        public let environmentName: String

        @inlinable
        public init(appId: String, environmentName: String) {
            self.appId = appId
            self.environmentName = environmentName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.environmentName, key: "environmentName")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 255)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^(?s).+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBackendEnvironmentResult: AWSDecodableShape {
        /// Describes the backend environment for an Amplify app.
        public let backendEnvironment: BackendEnvironment

        @inlinable
        public init(backendEnvironment: BackendEnvironment) {
            self.backendEnvironment = backendEnvironment
        }

        private enum CodingKeys: String, CodingKey {
            case backendEnvironment = "backendEnvironment"
        }
    }

    public struct GetBranchRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        /// The name of the branch.
        public let branchName: String

        @inlinable
        public init(appId: String, branchName: String) {
            self.appId = appId
            self.branchName = branchName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.branchName, key: "branchName")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBranchResult: AWSDecodableShape {
        public let branch: Branch

        @inlinable
        public init(branch: Branch) {
            self.branch = branch
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
        }
    }

    public struct GetDomainAssociationRequest: AWSEncodableShape {
        ///  The unique id for an Amplify app.
        public let appId: String
        ///  The name of the domain.
        public let domainName: String

        @inlinable
        public init(appId: String, domainName: String) {
            self.appId = appId
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.domainName, key: "domainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])(\\.)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainAssociationResult: AWSDecodableShape {
        ///  Describes the structure of a domain association, which associates a custom domain with an Amplify app.
        public let domainAssociation: DomainAssociation

        @inlinable
        public init(domainAssociation: DomainAssociation) {
            self.domainAssociation = domainAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case domainAssociation = "domainAssociation"
        }
    }

    public struct GetJobRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String
        /// The name of the branch to use for the job.
        public let branchName: String
        /// The unique ID for the job.
        public let jobId: String

        @inlinable
        public init(appId: String, branchName: String, jobId: String) {
            self.appId = appId
            self.branchName = branchName
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.branchName, key: "branchName")
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetJobResult: AWSDecodableShape {
        public let job: Job

        @inlinable
        public init(job: Job) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "job"
        }
    }

    public struct GetWebhookRequest: AWSEncodableShape {
        /// The unique ID for a webhook.
        public let webhookId: String

        @inlinable
        public init(webhookId: String) {
            self.webhookId = webhookId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.webhookId, key: "webhookId")
        }

        public func validate(name: String) throws {
            try self.validate(self.webhookId, name: "webhookId", parent: name, max: 255)
            try self.validate(self.webhookId, name: "webhookId", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWebhookResult: AWSDecodableShape {
        /// Describes the structure of a webhook.
        public let webhook: Webhook

        @inlinable
        public init(webhook: Webhook) {
            self.webhook = webhook
        }

        private enum CodingKeys: String, CodingKey {
            case webhook = "webhook"
        }
    }

    public struct Job: AWSDecodableShape {
        ///  The execution steps for an execution job, for an Amplify app.
        public let steps: [Step]
        ///  Describes the summary for an execution job for an Amplify app.
        public let summary: JobSummary

        @inlinable
        public init(steps: [Step], summary: JobSummary) {
            self.steps = steps
            self.summary = summary
        }

        private enum CodingKeys: String, CodingKey {
            case steps = "steps"
            case summary = "summary"
        }
    }

    public struct JobSummary: AWSDecodableShape {
        ///  The commit ID from a third-party repository provider for the job.
        public let commitId: String
        ///  The commit message from a third-party repository provider for the job.
        public let commitMessage: String
        /// The commit date and time for the job.
        public let commitTime: Date
        ///  The end date and time for the job.
        public let endTime: Date?
        ///  The Amazon Resource Name (ARN) for the job.
        public let jobArn: String
        ///  The unique ID for the job.
        public let jobId: String
        ///  The type for the job. If the value is RELEASE, the job was manually released from its source by using the StartJob API. This value is available only for apps that are connected to a repository. If the value is RETRY, the job was manually retried using the StartJob API. If the value is WEB_HOOK, the job was automatically triggered by webhooks. If the value is MANUAL, the job is for a manually deployed app. Manually deployed apps are not connected to a Git repository.
        public let jobType: JobType
        /// The source URL for the files to deploy. The source URL can be either an HTTP GET URL that is publicly accessible and downloads a single .zip file, or an Amazon S3 bucket and prefix.
        public let sourceUrl: String?
        /// The type of source specified by the sourceURL. If the value is ZIP, the source is a .zip file. If the value is BUCKET_PREFIX, the source is an Amazon S3 bucket and prefix. If no value is specified, the default is ZIP.
        public let sourceUrlType: SourceUrlType?
        ///  The start date and time for the job.
        public let startTime: Date
        ///  The current status for the job.
        public let status: JobStatus

        @inlinable
        public init(commitId: String, commitMessage: String, commitTime: Date, endTime: Date? = nil, jobArn: String, jobId: String, jobType: JobType, sourceUrl: String? = nil, sourceUrlType: SourceUrlType? = nil, startTime: Date, status: JobStatus) {
            self.commitId = commitId
            self.commitMessage = commitMessage
            self.commitTime = commitTime
            self.endTime = endTime
            self.jobArn = jobArn
            self.jobId = jobId
            self.jobType = jobType
            self.sourceUrl = sourceUrl
            self.sourceUrlType = sourceUrlType
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case commitId = "commitId"
            case commitMessage = "commitMessage"
            case commitTime = "commitTime"
            case endTime = "endTime"
            case jobArn = "jobArn"
            case jobId = "jobId"
            case jobType = "jobType"
            case sourceUrl = "sourceUrl"
            case sourceUrlType = "sourceUrlType"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct ListAppsRequest: AWSEncodableShape {
        /// The maximum number of records to list in a single response.
        public let maxResults: Int?
        /// A pagination token. If non-null, the pagination token is returned in a result. Pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAppsResult: AWSDecodableShape {
        /// A list of Amplify apps.
        public let apps: [App]
        /// A pagination token. Set to null to start listing apps from start. If non-null, the pagination token is returned in a result. Pass its value in here to list more projects.
        public let nextToken: String?

        @inlinable
        public init(apps: [App], nextToken: String? = nil) {
            self.apps = apps
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case apps = "apps"
            case nextToken = "nextToken"
        }
    }

    public struct ListArtifactsRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String
        /// The name of a branch that is part of an Amplify app.
        public let branchName: String
        /// The unique ID for a job.
        public let jobId: String
        /// The maximum number of records to list in a single response.
        public let maxResults: Int?
        /// A pagination token. Set to null to start listing artifacts from start. If a non-null pagination token is returned in a result, pass its value in here to list more artifacts.
        public let nextToken: String?

        @inlinable
        public init(appId: String, branchName: String, jobId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appId = appId
            self.branchName = branchName
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.branchName, key: "branchName")
            request.encodePath(self.jobId, key: "jobId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListArtifactsResult: AWSDecodableShape {
        /// A list of artifacts.
        public let artifacts: [Artifact]
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(artifacts: [Artifact], nextToken: String? = nil) {
            self.artifacts = artifacts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case artifacts = "artifacts"
            case nextToken = "nextToken"
        }
    }

    public struct ListBackendEnvironmentsRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String
        /// The name of the backend environment
        public let environmentName: String?
        /// The maximum number of records to list in a single response.
        public let maxResults: Int?
        /// A pagination token. Set to null to start listing backend environments from the start. If a non-null pagination token is returned in a result, pass its value in here to list more backend environments.
        public let nextToken: String?

        @inlinable
        public init(appId: String, environmentName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appId = appId
            self.environmentName = environmentName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.environmentName, key: "environmentName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.environmentName, name: "environmentName", parent: name, max: 255)
            try self.validate(self.environmentName, name: "environmentName", parent: name, min: 1)
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBackendEnvironmentsResult: AWSDecodableShape {
        /// The list of backend environments for an Amplify app.
        public let backendEnvironments: [BackendEnvironment]
        /// A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(backendEnvironments: [BackendEnvironment], nextToken: String? = nil) {
            self.backendEnvironments = backendEnvironments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case backendEnvironments = "backendEnvironments"
            case nextToken = "nextToken"
        }
    }

    public struct ListBranchesRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String
        ///  The maximum number of records to list in a single response.
        public let maxResults: Int?
        /// A pagination token. Set to null to start listing branches from the start. If a non-null pagination token is returned in a result, pass its value in here to list more branches.
        public let nextToken: String?

        @inlinable
        public init(appId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appId = appId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBranchesResult: AWSDecodableShape {
        ///  A list of branches for an Amplify app.
        public let branches: [Branch]
        ///  A pagination token. If a non-null pagination token is returned in a result, pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(branches: [Branch], nextToken: String? = nil) {
            self.branches = branches
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case branches = "branches"
            case nextToken = "nextToken"
        }
    }

    public struct ListDomainAssociationsRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        ///  The maximum number of records to list in a single response.
        public let maxResults: Int?
        ///  A pagination token. Set to null to start listing apps from the start. If non-null, a pagination token is returned in a result. Pass its value in here to list more projects.
        public let nextToken: String?

        @inlinable
        public init(appId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appId = appId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainAssociationsResult: AWSDecodableShape {
        ///  A list of domain associations.
        public let domainAssociations: [DomainAssociation]
        ///  A pagination token. If non-null, a pagination token is returned in a result. Pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(domainAssociations: [DomainAssociation], nextToken: String? = nil) {
            self.domainAssociations = domainAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domainAssociations = "domainAssociations"
            case nextToken = "nextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        /// The name of the branch to use for the request.
        public let branchName: String
        /// The maximum number of records to list in a single response.
        public let maxResults: Int?
        /// A pagination token. Set to null to start listing steps from the start. If a non-null pagination token is returned in a result, pass its value in here to list more steps.
        public let nextToken: String?

        @inlinable
        public init(appId: String, branchName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appId = appId
            self.branchName = branchName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.branchName, key: "branchName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobsResult: AWSDecodableShape {
        /// The result structure for the list job result request.
        public let jobSummaries: [JobSummary]
        /// A pagination token. If non-null the pagination token is returned in a result. Pass its value in another request to retrieve more entries.
        public let nextToken: String?

        @inlinable
        public init(jobSummaries: [JobSummary], nextToken: String? = nil) {
            self.jobSummaries = jobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummaries = "jobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to list tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:amplify:")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags for the specified The Amazon Resource Name (ARN).
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWebhooksRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String
        /// The maximum number of records to list in a single response.
        public let maxResults: Int?
        /// A pagination token. Set to null to start listing webhooks from the start. If non-null,the pagination token is returned in a result. Pass its value in here to list more webhooks.
        public let nextToken: String?

        @inlinable
        public init(appId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appId = appId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWebhooksResult: AWSDecodableShape {
        /// A pagination token. If non-null, the pagination token is returned in a result. Pass its value in another request to retrieve more entries.
        public let nextToken: String?
        /// A list of webhooks.
        public let webhooks: [Webhook]

        @inlinable
        public init(nextToken: String? = nil, webhooks: [Webhook]) {
            self.nextToken = nextToken
            self.webhooks = webhooks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case webhooks = "webhooks"
        }
    }

    public struct ProductionBranch: AWSDecodableShape {
        /// The branch name for the production branch.
        public let branchName: String?
        /// The last deploy time of the production branch.
        public let lastDeployTime: Date?
        /// The status of the production branch.
        public let status: String?
        /// The thumbnail URL for the production branch.
        public let thumbnailUrl: String?

        @inlinable
        public init(branchName: String? = nil, lastDeployTime: Date? = nil, status: String? = nil, thumbnailUrl: String? = nil) {
            self.branchName = branchName
            self.lastDeployTime = lastDeployTime
            self.status = status
            self.thumbnailUrl = thumbnailUrl
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branchName"
            case lastDeployTime = "lastDeployTime"
            case status = "status"
            case thumbnailUrl = "thumbnailUrl"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let code: String
        public let message: String

        @inlinable
        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct StartDeploymentRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String
        /// The name of the branch to use for the deployment job.
        public let branchName: String
        /// The job ID for this deployment that is generated by the CreateDeployment request.
        public let jobId: String?
        /// The source URL for the deployment that is used when calling StartDeployment without CreateDeployment. The source URL can be either an HTTP GET URL that is publicly accessible and downloads a single .zip file, or an Amazon S3 bucket and prefix.
        public let sourceUrl: String?
        /// The type of source specified by the sourceURL. If the value is ZIP, the source is a .zip file. If the value is BUCKET_PREFIX, the source is an Amazon S3 bucket and prefix. If no value is specified, the default is ZIP.
        public let sourceUrlType: SourceUrlType?

        @inlinable
        public init(appId: String, branchName: String, jobId: String? = nil, sourceUrl: String? = nil, sourceUrlType: SourceUrlType? = nil) {
            self.appId = appId
            self.branchName = branchName
            self.jobId = jobId
            self.sourceUrl = sourceUrl
            self.sourceUrlType = sourceUrlType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.branchName, key: "branchName")
            try container.encodeIfPresent(self.jobId, forKey: .jobId)
            try container.encodeIfPresent(self.sourceUrl, forKey: .sourceUrl)
            try container.encodeIfPresent(self.sourceUrlType, forKey: .sourceUrlType)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.sourceUrl, name: "sourceUrl", parent: name, max: 3000)
            try self.validate(self.sourceUrl, name: "sourceUrl", parent: name, pattern: "^(s3|https|http)://")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case sourceUrl = "sourceUrl"
            case sourceUrlType = "sourceUrlType"
        }
    }

    public struct StartDeploymentResult: AWSDecodableShape {
        /// The summary for the job.
        public let jobSummary: JobSummary

        @inlinable
        public init(jobSummary: JobSummary) {
            self.jobSummary = jobSummary
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummary = "jobSummary"
        }
    }

    public struct StartJobRequest: AWSEncodableShape {
        /// The unique ID for an Amplify app.
        public let appId: String
        /// The name of the branch to use for the job.
        public let branchName: String
        ///  The commit ID from a third-party repository provider for the job.
        public let commitId: String?
        ///  The commit message from a third-party repository provider for the job.
        public let commitMessage: String?
        ///  The commit date and time for the job.
        public let commitTime: Date?
        /// The unique ID for an existing job. This is required if the value of jobType is RETRY.
        public let jobId: String?
        /// A descriptive reason for starting the job.
        public let jobReason: String?
        /// Describes the type for the job. The job type RELEASE starts a new job with the latest change from the specified branch. This value is available only for apps that are connected to a repository.  The job type RETRY retries an existing job. If the job type value is RETRY, the jobId is also required.
        public let jobType: JobType

        @inlinable
        public init(appId: String, branchName: String, commitId: String? = nil, commitMessage: String? = nil, commitTime: Date? = nil, jobId: String? = nil, jobReason: String? = nil, jobType: JobType) {
            self.appId = appId
            self.branchName = branchName
            self.commitId = commitId
            self.commitMessage = commitMessage
            self.commitTime = commitTime
            self.jobId = jobId
            self.jobReason = jobReason
            self.jobType = jobType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.branchName, key: "branchName")
            try container.encodeIfPresent(self.commitId, forKey: .commitId)
            try container.encodeIfPresent(self.commitMessage, forKey: .commitMessage)
            try container.encodeIfPresent(self.commitTime, forKey: .commitTime)
            try container.encodeIfPresent(self.jobId, forKey: .jobId)
            try container.encodeIfPresent(self.jobReason, forKey: .jobReason)
            try container.encode(self.jobType, forKey: .jobType)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.commitId, name: "commitId", parent: name, max: 255)
            try self.validate(self.commitId, name: "commitId", parent: name, pattern: "^(?s)")
            try self.validate(self.commitMessage, name: "commitMessage", parent: name, max: 10000)
            try self.validate(self.commitMessage, name: "commitMessage", parent: name, pattern: "^(?s)")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.jobReason, name: "jobReason", parent: name, max: 255)
            try self.validate(self.jobReason, name: "jobReason", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: String, CodingKey {
            case commitId = "commitId"
            case commitMessage = "commitMessage"
            case commitTime = "commitTime"
            case jobId = "jobId"
            case jobReason = "jobReason"
            case jobType = "jobType"
        }
    }

    public struct StartJobResult: AWSDecodableShape {
        ///  The summary for the job.
        public let jobSummary: JobSummary

        @inlinable
        public init(jobSummary: JobSummary) {
            self.jobSummary = jobSummary
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummary = "jobSummary"
        }
    }

    public struct Step: AWSDecodableShape {
        ///  The URL to the build artifact for the execution step.
        public let artifactsUrl: String?
        ///  The context for the current step. Includes a build image if the step is build.
        public let context: String?
        ///  The end date and time of the execution step.
        public let endTime: Date
        ///  The URL to the logs for the execution step.
        public let logUrl: String?
        ///  The list of screenshot URLs for the execution step, if relevant.
        public let screenshots: [String: String]?
        ///  The start date and time of the execution step.
        public let startTime: Date
        ///  The status of the execution step.
        public let status: JobStatus
        ///  The reason for the current step status.
        public let statusReason: String?
        ///  The name of the execution step.
        public let stepName: String
        ///  The URL to the test artifact for the execution step.
        public let testArtifactsUrl: String?
        ///  The URL to the test configuration for the execution step.
        public let testConfigUrl: String?

        @inlinable
        public init(artifactsUrl: String? = nil, context: String? = nil, endTime: Date, logUrl: String? = nil, screenshots: [String: String]? = nil, startTime: Date, status: JobStatus, statusReason: String? = nil, stepName: String, testArtifactsUrl: String? = nil, testConfigUrl: String? = nil) {
            self.artifactsUrl = artifactsUrl
            self.context = context
            self.endTime = endTime
            self.logUrl = logUrl
            self.screenshots = screenshots
            self.startTime = startTime
            self.status = status
            self.statusReason = statusReason
            self.stepName = stepName
            self.testArtifactsUrl = testArtifactsUrl
            self.testConfigUrl = testConfigUrl
        }

        private enum CodingKeys: String, CodingKey {
            case artifactsUrl = "artifactsUrl"
            case context = "context"
            case endTime = "endTime"
            case logUrl = "logUrl"
            case screenshots = "screenshots"
            case startTime = "startTime"
            case status = "status"
            case statusReason = "statusReason"
            case stepName = "stepName"
            case testArtifactsUrl = "testArtifactsUrl"
            case testConfigUrl = "testConfigUrl"
        }
    }

    public struct StopJobRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        /// The name of the branch to use for the stop job request.
        public let branchName: String
        ///  The unique id for the job.
        public let jobId: String

        @inlinable
        public init(appId: String, branchName: String, jobId: String) {
            self.appId = appId
            self.branchName = branchName
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            request.encodePath(self.branchName, key: "branchName")
            request.encodePath(self.jobId, key: "jobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 255)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopJobResult: AWSDecodableShape {
        ///  The summary for the job.
        public let jobSummary: JobSummary

        @inlinable
        public init(jobSummary: JobSummary) {
            self.jobSummary = jobSummary
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummary = "jobSummary"
        }
    }

    public struct SubDomain: AWSDecodableShape {
        ///  The DNS record for the subdomain.
        public let dnsRecord: String
        ///  Describes the settings for the subdomain.
        public let subDomainSetting: SubDomainSetting
        ///  The verified status of the subdomain
        public let verified: Bool

        @inlinable
        public init(dnsRecord: String, subDomainSetting: SubDomainSetting, verified: Bool) {
            self.dnsRecord = dnsRecord
            self.subDomainSetting = subDomainSetting
            self.verified = verified
        }

        private enum CodingKeys: String, CodingKey {
            case dnsRecord = "dnsRecord"
            case subDomainSetting = "subDomainSetting"
            case verified = "verified"
        }
    }

    public struct SubDomainSetting: AWSEncodableShape & AWSDecodableShape {
        ///  The branch name setting for the subdomain.
        public let branchName: String
        ///  The prefix setting for the subdomain.
        public let prefix: String

        @inlinable
        public init(branchName: String, prefix: String) {
            self.branchName = branchName
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 255)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branchName"
            case prefix = "prefix"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) to use to tag a resource.
        public let resourceArn: String
        /// The tags used to tag the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:amplify:")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) to use to untag a resource.
        public let resourceArn: String
        /// The tag keys to use to untag a resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:amplify:")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAppRequest: AWSEncodableShape {
        /// The personal access token for a GitHub repository for an Amplify app. The personal access token is used to authorize access to a GitHub repository using the Amplify GitHub App. The token is not stored. Use accessToken for GitHub repositories only. To authorize access to a repository provider such as Bitbucket or CodeCommit, use oauthToken. You must specify either accessToken or oauthToken when you update an app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see Migrating an existing OAuth app to the Amplify GitHub App in the Amplify User Guide .
        public let accessToken: String?
        /// The unique ID for an Amplify app.
        public let appId: String
        /// The automated branch creation configuration for an Amplify app.
        public let autoBranchCreationConfig: AutoBranchCreationConfig?
        /// Describes the automated branch creation glob patterns for an Amplify app.
        public let autoBranchCreationPatterns: [String]?
        /// The basic authorization credentials for an Amplify app. You must base64-encode the authorization credentials and provide them in the format user:password.
        public let basicAuthCredentials: String?
        /// The build specification (build spec) for an Amplify app.
        public let buildSpec: String?
        /// The cache configuration for the Amplify app.
        public let cacheConfig: CacheConfig?
        /// The Amazon Resource Name (ARN) of the IAM role to assign to an SSR app. The SSR Compute role allows the Amplify Hosting compute service to securely access specific Amazon Web Services resources based on the role's permissions. For more information about the SSR Compute role, see Adding an SSR Compute role in the Amplify User Guide.
        public let computeRoleArn: String?
        /// The custom HTTP headers for an Amplify app.
        public let customHeaders: String?
        /// The custom redirect and rewrite rules for an Amplify app.
        public let customRules: [CustomRule]?
        /// The description for an Amplify app.
        public let description: String?
        /// Enables automated branch creation for an Amplify app.
        public let enableAutoBranchCreation: Bool?
        /// Enables basic authorization for an Amplify app.
        public let enableBasicAuth: Bool?
        /// Enables branch auto-building for an Amplify app.
        public let enableBranchAutoBuild: Bool?
        /// Automatically disconnects a branch in the Amplify console when you delete a branch from your Git repository.
        public let enableBranchAutoDeletion: Bool?
        /// The environment variables for an Amplify app.
        public let environmentVariables: [String: String]?
        /// The Amazon Resource Name (ARN) of the IAM service role for the Amplify app.
        public let iamServiceRoleArn: String?
        /// The name for an Amplify app.
        public let name: String?
        /// The OAuth token for a third-party source control system for an Amplify app. The OAuth token is used to create a webhook and a read-only deploy key using SSH cloning. The OAuth token is not stored. Use oauthToken for repository providers other than GitHub, such as Bitbucket or CodeCommit. To authorize access to GitHub as your repository provider, use accessToken. You must specify either oauthToken or accessToken when you update an app. Existing Amplify apps deployed from a GitHub repository using OAuth continue to work with CI/CD. However, we strongly recommend that you migrate these apps to use the GitHub App. For more information, see Migrating an existing OAuth app to the Amplify GitHub App in the Amplify User Guide .
        public let oauthToken: String?
        /// The platform for the Amplify app. For a static app, set the platform type to WEB. For a dynamic server-side rendered (SSR) app, set the platform type to WEB_COMPUTE. For an app requiring Amplify Hosting's original SSR support only, set the platform type to WEB_DYNAMIC. If you are deploying an SSG only app with Next.js version 14 or later, you must set the platform type to WEB_COMPUTE.
        public let platform: Platform?
        /// The name of the Git repository for an Amplify app.
        public let repository: String?

        @inlinable
        public init(accessToken: String? = nil, appId: String, autoBranchCreationConfig: AutoBranchCreationConfig? = nil, autoBranchCreationPatterns: [String]? = nil, basicAuthCredentials: String? = nil, buildSpec: String? = nil, cacheConfig: CacheConfig? = nil, computeRoleArn: String? = nil, customHeaders: String? = nil, customRules: [CustomRule]? = nil, description: String? = nil, enableAutoBranchCreation: Bool? = nil, enableBasicAuth: Bool? = nil, enableBranchAutoBuild: Bool? = nil, enableBranchAutoDeletion: Bool? = nil, environmentVariables: [String: String]? = nil, iamServiceRoleArn: String? = nil, name: String? = nil, oauthToken: String? = nil, platform: Platform? = nil, repository: String? = nil) {
            self.accessToken = accessToken
            self.appId = appId
            self.autoBranchCreationConfig = autoBranchCreationConfig
            self.autoBranchCreationPatterns = autoBranchCreationPatterns
            self.basicAuthCredentials = basicAuthCredentials
            self.buildSpec = buildSpec
            self.cacheConfig = cacheConfig
            self.computeRoleArn = computeRoleArn
            self.customHeaders = customHeaders
            self.customRules = customRules
            self.description = description
            self.enableAutoBranchCreation = enableAutoBranchCreation
            self.enableBasicAuth = enableBasicAuth
            self.enableBranchAutoBuild = enableBranchAutoBuild
            self.enableBranchAutoDeletion = enableBranchAutoDeletion
            self.environmentVariables = environmentVariables
            self.iamServiceRoleArn = iamServiceRoleArn
            self.name = name
            self.oauthToken = oauthToken
            self.platform = platform
            self.repository = repository
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accessToken, forKey: .accessToken)
            request.encodePath(self.appId, key: "appId")
            try container.encodeIfPresent(self.autoBranchCreationConfig, forKey: .autoBranchCreationConfig)
            try container.encodeIfPresent(self.autoBranchCreationPatterns, forKey: .autoBranchCreationPatterns)
            try container.encodeIfPresent(self.basicAuthCredentials, forKey: .basicAuthCredentials)
            try container.encodeIfPresent(self.buildSpec, forKey: .buildSpec)
            try container.encodeIfPresent(self.cacheConfig, forKey: .cacheConfig)
            try container.encodeIfPresent(self.computeRoleArn, forKey: .computeRoleArn)
            try container.encodeIfPresent(self.customHeaders, forKey: .customHeaders)
            try container.encodeIfPresent(self.customRules, forKey: .customRules)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.enableAutoBranchCreation, forKey: .enableAutoBranchCreation)
            try container.encodeIfPresent(self.enableBasicAuth, forKey: .enableBasicAuth)
            try container.encodeIfPresent(self.enableBranchAutoBuild, forKey: .enableBranchAutoBuild)
            try container.encodeIfPresent(self.enableBranchAutoDeletion, forKey: .enableBranchAutoDeletion)
            try container.encodeIfPresent(self.environmentVariables, forKey: .environmentVariables)
            try container.encodeIfPresent(self.iamServiceRoleArn, forKey: .iamServiceRoleArn)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.oauthToken, forKey: .oauthToken)
            try container.encodeIfPresent(self.platform, forKey: .platform)
            try container.encodeIfPresent(self.repository, forKey: .repository)
        }

        public func validate(name: String) throws {
            try self.validate(self.accessToken, name: "accessToken", parent: name, max: 255)
            try self.validate(self.accessToken, name: "accessToken", parent: name, min: 1)
            try self.validate(self.accessToken, name: "accessToken", parent: name, pattern: "^(?s).+$")
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.autoBranchCreationConfig?.validate(name: "\(name).autoBranchCreationConfig")
            try self.autoBranchCreationPatterns?.forEach {
                try validate($0, name: "autoBranchCreationPatterns[]", parent: name, max: 2048)
                try validate($0, name: "autoBranchCreationPatterns[]", parent: name, min: 1)
                try validate($0, name: "autoBranchCreationPatterns[]", parent: name, pattern: "^(?s).+$")
            }
            try self.validate(self.basicAuthCredentials, name: "basicAuthCredentials", parent: name, max: 2000)
            try self.validate(self.basicAuthCredentials, name: "basicAuthCredentials", parent: name, pattern: "^(?s)")
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, max: 25000)
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, min: 1)
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, pattern: "^(?s).+$")
            try self.validate(self.computeRoleArn, name: "computeRoleArn", parent: name, max: 1000)
            try self.validate(self.computeRoleArn, name: "computeRoleArn", parent: name, pattern: "^(?s)")
            try self.validate(self.customHeaders, name: "customHeaders", parent: name, max: 25000)
            try self.validate(self.customHeaders, name: "customHeaders", parent: name, pattern: "^(?s)")
            try self.customRules?.forEach {
                try $0.validate(name: "\(name).customRules[]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?s)")
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 255)
                try validate($0.key, name: "environmentVariables.key", parent: name, pattern: "^(?s)")
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5500)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, pattern: "^(?s)")
            }
            try self.validate(self.iamServiceRoleArn, name: "iamServiceRoleArn", parent: name, max: 1000)
            try self.validate(self.iamServiceRoleArn, name: "iamServiceRoleArn", parent: name, pattern: "^(?s)")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?s).+$")
            try self.validate(self.oauthToken, name: "oauthToken", parent: name, max: 1000)
            try self.validate(self.oauthToken, name: "oauthToken", parent: name, pattern: "^(?s)")
            try self.validate(self.repository, name: "repository", parent: name, max: 1000)
            try self.validate(self.repository, name: "repository", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case autoBranchCreationConfig = "autoBranchCreationConfig"
            case autoBranchCreationPatterns = "autoBranchCreationPatterns"
            case basicAuthCredentials = "basicAuthCredentials"
            case buildSpec = "buildSpec"
            case cacheConfig = "cacheConfig"
            case computeRoleArn = "computeRoleArn"
            case customHeaders = "customHeaders"
            case customRules = "customRules"
            case description = "description"
            case enableAutoBranchCreation = "enableAutoBranchCreation"
            case enableBasicAuth = "enableBasicAuth"
            case enableBranchAutoBuild = "enableBranchAutoBuild"
            case enableBranchAutoDeletion = "enableBranchAutoDeletion"
            case environmentVariables = "environmentVariables"
            case iamServiceRoleArn = "iamServiceRoleArn"
            case name = "name"
            case oauthToken = "oauthToken"
            case platform = "platform"
            case repository = "repository"
        }
    }

    public struct UpdateAppResult: AWSDecodableShape {
        /// Represents the updated Amplify app.
        public let app: App

        @inlinable
        public init(app: App) {
            self.app = app
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
        }
    }

    public struct UpdateBranchRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        /// The backend for a Branch of an Amplify app. Use for a backend created from an CloudFormation stack. This field is available to Amplify Gen 2 apps only. When you deploy an application with Amplify Gen 2, you provision the app's backend infrastructure using Typescript code.
        public let backend: Backend?
        /// The Amazon Resource Name (ARN) for a backend environment that is part of a Gen 1 Amplify app.  This field is available to Amplify Gen 1 apps only where the backend is created using Amplify Studio or the Amplify command line interface (CLI).
        public let backendEnvironmentArn: String?
        ///  The basic authorization credentials for the branch. You must base64-encode the authorization credentials and provide them in the format user:password.
        public let basicAuthCredentials: String?
        /// The name of the branch.
        public let branchName: String
        ///  The build specification (build spec) for the branch.
        public let buildSpec: String?
        /// The Amazon Resource Name (ARN) of the IAM role to assign to a branch of an SSR app. The SSR Compute role allows the Amplify Hosting compute service to securely access specific Amazon Web Services resources based on the role's permissions. For more information about the SSR Compute role, see Adding an SSR Compute role in the Amplify User Guide.
        public let computeRoleArn: String?
        ///  The description for the branch.
        public let description: String?
        ///  The display name for a branch. This is used as the default domain prefix.
        public let displayName: String?
        ///  Enables auto building for the branch.
        public let enableAutoBuild: Bool?
        ///  Enables basic authorization for the branch.
        public let enableBasicAuth: Bool?
        ///  Enables notifications for the branch.
        public let enableNotification: Bool?
        /// Enables performance mode for the branch. Performance mode optimizes for faster hosting performance by keeping content cached at the edge for a longer interval. When performance mode is enabled, hosting configuration or code changes can take up to 10 minutes to roll out.
        public let enablePerformanceMode: Bool?
        ///  Enables pull request previews for this branch.
        public let enablePullRequestPreview: Bool?
        /// Specifies whether the skew protection feature is enabled for the branch. Deployment skew protection is available to Amplify applications to eliminate version skew issues between client and servers in web applications. When you apply skew protection to a branch, you can ensure that your clients always interact with the correct version of server-side assets, regardless of when a deployment occurs. For more information about skew protection, see Skew protection for Amplify deployments in the Amplify User Guide.
        public let enableSkewProtection: Bool?
        ///  The environment variables for the branch.
        public let environmentVariables: [String: String]?
        ///  The framework for the branch.
        public let framework: String?
        ///  The Amplify environment name for the pull request.
        public let pullRequestEnvironmentName: String?
        ///  Describes the current stage for the branch.
        public let stage: Stage?
        ///  The content Time to Live (TTL) for the website in seconds.
        public let ttl: String?

        @inlinable
        public init(appId: String, backend: Backend? = nil, backendEnvironmentArn: String? = nil, basicAuthCredentials: String? = nil, branchName: String, buildSpec: String? = nil, computeRoleArn: String? = nil, description: String? = nil, displayName: String? = nil, enableAutoBuild: Bool? = nil, enableBasicAuth: Bool? = nil, enableNotification: Bool? = nil, enablePerformanceMode: Bool? = nil, enablePullRequestPreview: Bool? = nil, enableSkewProtection: Bool? = nil, environmentVariables: [String: String]? = nil, framework: String? = nil, pullRequestEnvironmentName: String? = nil, stage: Stage? = nil, ttl: String? = nil) {
            self.appId = appId
            self.backend = backend
            self.backendEnvironmentArn = backendEnvironmentArn
            self.basicAuthCredentials = basicAuthCredentials
            self.branchName = branchName
            self.buildSpec = buildSpec
            self.computeRoleArn = computeRoleArn
            self.description = description
            self.displayName = displayName
            self.enableAutoBuild = enableAutoBuild
            self.enableBasicAuth = enableBasicAuth
            self.enableNotification = enableNotification
            self.enablePerformanceMode = enablePerformanceMode
            self.enablePullRequestPreview = enablePullRequestPreview
            self.enableSkewProtection = enableSkewProtection
            self.environmentVariables = environmentVariables
            self.framework = framework
            self.pullRequestEnvironmentName = pullRequestEnvironmentName
            self.stage = stage
            self.ttl = ttl
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            try container.encodeIfPresent(self.backend, forKey: .backend)
            try container.encodeIfPresent(self.backendEnvironmentArn, forKey: .backendEnvironmentArn)
            try container.encodeIfPresent(self.basicAuthCredentials, forKey: .basicAuthCredentials)
            request.encodePath(self.branchName, key: "branchName")
            try container.encodeIfPresent(self.buildSpec, forKey: .buildSpec)
            try container.encodeIfPresent(self.computeRoleArn, forKey: .computeRoleArn)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.enableAutoBuild, forKey: .enableAutoBuild)
            try container.encodeIfPresent(self.enableBasicAuth, forKey: .enableBasicAuth)
            try container.encodeIfPresent(self.enableNotification, forKey: .enableNotification)
            try container.encodeIfPresent(self.enablePerformanceMode, forKey: .enablePerformanceMode)
            try container.encodeIfPresent(self.enablePullRequestPreview, forKey: .enablePullRequestPreview)
            try container.encodeIfPresent(self.enableSkewProtection, forKey: .enableSkewProtection)
            try container.encodeIfPresent(self.environmentVariables, forKey: .environmentVariables)
            try container.encodeIfPresent(self.framework, forKey: .framework)
            try container.encodeIfPresent(self.pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
            try container.encodeIfPresent(self.stage, forKey: .stage)
            try container.encodeIfPresent(self.ttl, forKey: .ttl)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.backend?.validate(name: "\(name).backend")
            try self.validate(self.backendEnvironmentArn, name: "backendEnvironmentArn", parent: name, max: 1000)
            try self.validate(self.backendEnvironmentArn, name: "backendEnvironmentArn", parent: name, pattern: "^(?s)")
            try self.validate(self.basicAuthCredentials, name: "basicAuthCredentials", parent: name, max: 2000)
            try self.validate(self.basicAuthCredentials, name: "basicAuthCredentials", parent: name, pattern: "^(?s)")
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, max: 25000)
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, min: 1)
            try self.validate(self.buildSpec, name: "buildSpec", parent: name, pattern: "^(?s).+$")
            try self.validate(self.computeRoleArn, name: "computeRoleArn", parent: name, max: 1000)
            try self.validate(self.computeRoleArn, name: "computeRoleArn", parent: name, pattern: "^(?s)")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?s)")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^(?s)")
            try self.environmentVariables?.forEach {
                try validate($0.key, name: "environmentVariables.key", parent: name, max: 255)
                try validate($0.key, name: "environmentVariables.key", parent: name, pattern: "^(?s)")
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, max: 5500)
                try validate($0.value, name: "environmentVariables[\"\($0.key)\"]", parent: name, pattern: "^(?s)")
            }
            try self.validate(self.framework, name: "framework", parent: name, max: 255)
            try self.validate(self.framework, name: "framework", parent: name, pattern: "^(?s)")
            try self.validate(self.pullRequestEnvironmentName, name: "pullRequestEnvironmentName", parent: name, max: 20)
            try self.validate(self.pullRequestEnvironmentName, name: "pullRequestEnvironmentName", parent: name, pattern: "^(?s)")
            try self.validate(self.ttl, name: "ttl", parent: name, max: 32)
            try self.validate(self.ttl, name: "ttl", parent: name, pattern: "^\\d*$")
        }

        private enum CodingKeys: String, CodingKey {
            case backend = "backend"
            case backendEnvironmentArn = "backendEnvironmentArn"
            case basicAuthCredentials = "basicAuthCredentials"
            case buildSpec = "buildSpec"
            case computeRoleArn = "computeRoleArn"
            case description = "description"
            case displayName = "displayName"
            case enableAutoBuild = "enableAutoBuild"
            case enableBasicAuth = "enableBasicAuth"
            case enableNotification = "enableNotification"
            case enablePerformanceMode = "enablePerformanceMode"
            case enablePullRequestPreview = "enablePullRequestPreview"
            case enableSkewProtection = "enableSkewProtection"
            case environmentVariables = "environmentVariables"
            case framework = "framework"
            case pullRequestEnvironmentName = "pullRequestEnvironmentName"
            case stage = "stage"
            case ttl = "ttl"
        }
    }

    public struct UpdateBranchResult: AWSDecodableShape {
        ///  The branch for an Amplify app, which maps to a third-party repository branch.
        public let branch: Branch

        @inlinable
        public init(branch: Branch) {
            self.branch = branch
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
        }
    }

    public struct UpdateDomainAssociationRequest: AWSEncodableShape {
        ///  The unique ID for an Amplify app.
        public let appId: String
        ///  Sets the branch patterns for automatic subdomain creation.
        public let autoSubDomainCreationPatterns: [String]?
        ///  The required AWS Identity and Access Management (IAM) service role for the Amazon Resource Name (ARN) for automatically creating subdomains.
        public let autoSubDomainIAMRole: String?
        /// The type of SSL/TLS certificate to use for your custom domain.
        public let certificateSettings: CertificateSettings?
        ///  The name of the domain.
        public let domainName: String
        ///  Enables the automated creation of subdomains for branches.
        public let enableAutoSubDomain: Bool?
        ///  Describes the settings for the subdomain.
        public let subDomainSettings: [SubDomainSetting]?

        @inlinable
        public init(appId: String, autoSubDomainCreationPatterns: [String]? = nil, autoSubDomainIAMRole: String? = nil, certificateSettings: CertificateSettings? = nil, domainName: String, enableAutoSubDomain: Bool? = nil, subDomainSettings: [SubDomainSetting]? = nil) {
            self.appId = appId
            self.autoSubDomainCreationPatterns = autoSubDomainCreationPatterns
            self.autoSubDomainIAMRole = autoSubDomainIAMRole
            self.certificateSettings = certificateSettings
            self.domainName = domainName
            self.enableAutoSubDomain = enableAutoSubDomain
            self.subDomainSettings = subDomainSettings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appId, key: "appId")
            try container.encodeIfPresent(self.autoSubDomainCreationPatterns, forKey: .autoSubDomainCreationPatterns)
            try container.encodeIfPresent(self.autoSubDomainIAMRole, forKey: .autoSubDomainIAMRole)
            try container.encodeIfPresent(self.certificateSettings, forKey: .certificateSettings)
            request.encodePath(self.domainName, key: "domainName")
            try container.encodeIfPresent(self.enableAutoSubDomain, forKey: .enableAutoSubDomain)
            try container.encodeIfPresent(self.subDomainSettings, forKey: .subDomainSettings)
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, max: 20)
            try self.validate(self.appId, name: "appId", parent: name, min: 1)
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^d[a-z0-9]+$")
            try self.autoSubDomainCreationPatterns?.forEach {
                try validate($0, name: "autoSubDomainCreationPatterns[]", parent: name, max: 2048)
                try validate($0, name: "autoSubDomainCreationPatterns[]", parent: name, min: 1)
                try validate($0, name: "autoSubDomainCreationPatterns[]", parent: name, pattern: "^(?s).+$")
            }
            try self.validate(self.autoSubDomainIAMRole, name: "autoSubDomainIAMRole", parent: name, max: 1000)
            try self.validate(self.autoSubDomainIAMRole, name: "autoSubDomainIAMRole", parent: name, pattern: "^$|^arn:aws:iam::\\d{12}:role.+$")
            try self.certificateSettings?.validate(name: "\(name).certificateSettings")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])(\\.)?$")
            try self.subDomainSettings?.forEach {
                try $0.validate(name: "\(name).subDomainSettings[]")
            }
            try self.validate(self.subDomainSettings, name: "subDomainSettings", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case autoSubDomainCreationPatterns = "autoSubDomainCreationPatterns"
            case autoSubDomainIAMRole = "autoSubDomainIAMRole"
            case certificateSettings = "certificateSettings"
            case enableAutoSubDomain = "enableAutoSubDomain"
            case subDomainSettings = "subDomainSettings"
        }
    }

    public struct UpdateDomainAssociationResult: AWSDecodableShape {
        ///  Describes a domain association, which associates a custom domain with an Amplify app.
        public let domainAssociation: DomainAssociation

        @inlinable
        public init(domainAssociation: DomainAssociation) {
            self.domainAssociation = domainAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case domainAssociation = "domainAssociation"
        }
    }

    public struct UpdateWebhookRequest: AWSEncodableShape {
        /// The name for a branch that is part of an Amplify app.
        public let branchName: String?
        /// The description for a webhook.
        public let description: String?
        /// The unique ID for a webhook.
        public let webhookId: String

        @inlinable
        public init(branchName: String? = nil, description: String? = nil, webhookId: String) {
            self.branchName = branchName
            self.description = description
            self.webhookId = webhookId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.branchName, forKey: .branchName)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.webhookId, key: "webhookId")
        }

        public func validate(name: String) throws {
            try self.validate(self.branchName, name: "branchName", parent: name, max: 255)
            try self.validate(self.branchName, name: "branchName", parent: name, min: 1)
            try self.validate(self.branchName, name: "branchName", parent: name, pattern: "^(?s).+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?s)")
            try self.validate(self.webhookId, name: "webhookId", parent: name, max: 255)
            try self.validate(self.webhookId, name: "webhookId", parent: name, pattern: "^(?s)")
        }

        private enum CodingKeys: String, CodingKey {
            case branchName = "branchName"
            case description = "description"
        }
    }

    public struct UpdateWebhookResult: AWSDecodableShape {
        /// Describes a webhook that connects repository events to an Amplify app.
        public let webhook: Webhook

        @inlinable
        public init(webhook: Webhook) {
            self.webhook = webhook
        }

        private enum CodingKeys: String, CodingKey {
            case webhook = "webhook"
        }
    }

    public struct WafConfiguration: AWSDecodableShape {
        /// The reason for the current status of the Firewall configuration.
        public let statusReason: String?
        /// The status of the process to associate or disassociate a web ACL to an Amplify app.
        public let wafStatus: WafStatus?
        /// The Amazon Resource Name (ARN) for the web ACL associated with an Amplify app.
        public let webAclArn: String?

        @inlinable
        public init(statusReason: String? = nil, wafStatus: WafStatus? = nil, webAclArn: String? = nil) {
            self.statusReason = statusReason
            self.wafStatus = wafStatus
            self.webAclArn = webAclArn
        }

        private enum CodingKeys: String, CodingKey {
            case statusReason = "statusReason"
            case wafStatus = "wafStatus"
            case webAclArn = "webAclArn"
        }
    }

    public struct Webhook: AWSDecodableShape {
        /// The unique ID of an Amplify app.
        public let appId: String?
        /// The name for a branch that is part of an Amplify app.
        public let branchName: String
        /// A timestamp of when Amplify created the webhook in your Git repository.
        public let createTime: Date
        /// The description for a webhook.
        public let description: String
        /// A timestamp of when Amplify updated the webhook in your Git repository.
        public let updateTime: Date
        /// The Amazon Resource Name (ARN) for the webhook.
        public let webhookArn: String
        /// The ID of the webhook.
        public let webhookId: String
        /// The URL of the webhook.
        public let webhookUrl: String

        @inlinable
        public init(appId: String? = nil, branchName: String, createTime: Date, description: String, updateTime: Date, webhookArn: String, webhookId: String, webhookUrl: String) {
            self.appId = appId
            self.branchName = branchName
            self.createTime = createTime
            self.description = description
            self.updateTime = updateTime
            self.webhookArn = webhookArn
            self.webhookId = webhookId
            self.webhookUrl = webhookUrl
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case branchName = "branchName"
            case createTime = "createTime"
            case description = "description"
            case updateTime = "updateTime"
            case webhookArn = "webhookArn"
            case webhookId = "webhookId"
            case webhookUrl = "webhookUrl"
        }
    }
}

// MARK: - Errors

/// Error enum for Amplify
public struct AmplifyErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case dependentServiceFailureException = "DependentServiceFailureException"
        case internalFailureException = "InternalFailureException"
        case limitExceededException = "LimitExceededException"
        case notFoundException = "NotFoundException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Amplify
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// A request contains unexpected data.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// An operation failed because a dependent service threw an exception.
    public static var dependentServiceFailureException: Self { .init(.dependentServiceFailureException) }
    /// The service failed to perform an operation due to an internal issue.
    public static var internalFailureException: Self { .init(.internalFailureException) }
    /// A resource could not be created because service quotas were exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// An entity was not found during an operation.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// An operation failed due to a non-existent resource.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// An operation failed due to a lack of access.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension AmplifyErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ResourceNotFoundException": Amplify.ResourceNotFoundException.self
    ]
}

extension AmplifyErrorType: Equatable {
    public static func == (lhs: AmplifyErrorType, rhs: AmplifyErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AmplifyErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
