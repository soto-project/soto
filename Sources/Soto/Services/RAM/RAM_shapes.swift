//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension RAM {
    // MARK: Enums

    public enum PermissionFeatureSet: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdFromPolicy = "CREATED_FROM_POLICY"
        case promotingToStandard = "PROMOTING_TO_STANDARD"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum PermissionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachable = "ATTACHABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case unattachable = "UNATTACHABLE"
        public var description: String { return self.rawValue }
    }

    public enum PermissionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsManaged = "AWS_MANAGED"
        case customerManaged = "CUSTOMER_MANAGED"
        public var description: String { return self.rawValue }
    }

    public enum PermissionTypeFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case awsManaged = "AWS_MANAGED"
        case customerManaged = "CUSTOMER_MANAGED"
        public var description: String { return self.rawValue }
    }

    public enum ReplacePermissionAssociationsWorkStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceOwner: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case _self = "SELF"
        case otherAccounts = "OTHER-ACCOUNTS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceRegionScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case global = "GLOBAL"
        case regional = "REGIONAL"
        public var description: String { return self.rawValue }
    }

    public enum ResourceRegionScopeFilter: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case global = "GLOBAL"
        case regional = "REGIONAL"
        public var description: String { return self.rawValue }
    }

    public enum ResourceShareAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associated = "ASSOCIATED"
        case associating = "ASSOCIATING"
        case disassociated = "DISASSOCIATED"
        case disassociating = "DISASSOCIATING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ResourceShareAssociationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case principal = "PRINCIPAL"
        case resource = "RESOURCE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceShareFeatureSet: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdFromPolicy = "CREATED_FROM_POLICY"
        case promotingToStandard = "PROMOTING_TO_STANDARD"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum ResourceShareInvitationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accepted = "ACCEPTED"
        case expired = "EXPIRED"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum ResourceShareStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case limitExceeded = "LIMIT_EXCEEDED"
        case pending = "PENDING"
        case unavailable = "UNAVAILABLE"
        case zonalResourceInaccessible = "ZONAL_RESOURCE_INACCESSIBLE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcceptResourceShareInvitationRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the invitation that you want to accept.
        public let resourceShareInvitationArn: String

        @inlinable
        public init(clientToken: String? = nil, resourceShareInvitationArn: String) {
            self.clientToken = clientToken
            self.resourceShareInvitationArn = resourceShareInvitationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceShareInvitationArn = "resourceShareInvitationArn"
        }
    }

    public struct AcceptResourceShareInvitationResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// An object that contains information about the specified invitation.
        public let resourceShareInvitation: ResourceShareInvitation?

        @inlinable
        public init(clientToken: String? = nil, resourceShareInvitation: ResourceShareInvitation? = nil) {
            self.clientToken = clientToken
            self.resourceShareInvitation = resourceShareInvitation
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceShareInvitation = "resourceShareInvitation"
        }
    }

    public struct AssociateResourceSharePermissionRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the RAM permission to associate with the resource share. To find the ARN for a permission, use either the ListPermissions operation or go to the Permissions library page in the RAM console and  then choose the name of the permission. The ARN is displayed on the detail page.
        public let permissionArn: String
        /// Specifies the version of the RAM permission to associate with the resource share. You can specify only the version that is currently set as the default version for the permission. If you also set the replace pararameter to true, then this operation updates an outdated version of the permission to the current default version.  You don't need to specify this parameter because the default behavior is to use the version that is currently set as the default version for the permission. This parameter is supported for backwards compatibility.
        public let permissionVersion: Int?
        /// Specifies whether the specified permission should replace the existing permission associated with the resource share. Use true to replace the current permissions. Use false to add the permission to a resource share that currently doesn't have a permission. The default value is false.  A resource share can have only one permission per resource type. If a resource share already has a permission for the specified resource type and you don't set replace to true then the operation returns an error. This helps prevent accidental overwriting of a permission.
        public let replace: Bool?
        /// Specifies the Amazon Resource Name (ARN) of the resource share to which you want to add or replace permissions.
        public let resourceShareArn: String

        @inlinable
        public init(clientToken: String? = nil, permissionArn: String, permissionVersion: Int? = nil, replace: Bool? = nil, resourceShareArn: String) {
            self.clientToken = clientToken
            self.permissionArn = permissionArn
            self.permissionVersion = permissionVersion
            self.replace = replace
            self.resourceShareArn = resourceShareArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case permissionArn = "permissionArn"
            case permissionVersion = "permissionVersion"
            case replace = "replace"
            case resourceShareArn = "resourceShareArn"
        }
    }

    public struct AssociateResourceSharePermissionResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// A return value of true indicates that the request succeeded.  A value of false indicates that the request failed.
        public let returnValue: Bool?

        @inlinable
        public init(clientToken: String? = nil, returnValue: Bool? = nil) {
            self.clientToken = clientToken
            self.returnValue = returnValue
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case returnValue = "returnValue"
        }
    }

    public struct AssociateResourceShareRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies a list of principals to whom you want to the resource share. This can be null if you want to add only resources. What the principals can do with the resources in the share is determined by the RAM permissions that you associate with the resource share. See AssociateResourceSharePermission. You can include the following values:   An Amazon Web Services account ID, for example: 123456789012    An Amazon Resource Name (ARN) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid    An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123    An ARN of an IAM role, for example: iam::123456789012:role/rolename    An ARN of an IAM user, for example: iam::123456789012user/username     Not all resource types can be shared with IAM roles and users.  For more information, see Sharing with IAM roles and users in the Resource Access Manager User Guide.
        public let principals: [String]?
        /// Specifies a list of Amazon Resource Names (ARNs) of the resources that you want to share. This can be null if you want to add only principals.
        public let resourceArns: [String]?
        /// Specifies the Amazon Resource Name (ARN) of the resource share that you want to add principals or resources to.
        public let resourceShareArn: String
        /// Specifies from which source accounts the service principal has access to the resources in this resource share.
        public let sources: [String]?

        @inlinable
        public init(clientToken: String? = nil, principals: [String]? = nil, resourceArns: [String]? = nil, resourceShareArn: String, sources: [String]? = nil) {
            self.clientToken = clientToken
            self.principals = principals
            self.resourceArns = resourceArns
            self.resourceShareArn = resourceShareArn
            self.sources = sources
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case principals = "principals"
            case resourceArns = "resourceArns"
            case resourceShareArn = "resourceShareArn"
            case sources = "sources"
        }
    }

    public struct AssociateResourceShareResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// An array of objects that contain information about the associations.
        public let resourceShareAssociations: [ResourceShareAssociation]?

        @inlinable
        public init(clientToken: String? = nil, resourceShareAssociations: [ResourceShareAssociation]? = nil) {
            self.clientToken = clientToken
            self.resourceShareAssociations = resourceShareAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceShareAssociations = "resourceShareAssociations"
        }
    }

    public struct AssociatedPermission: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the associated managed permission.
        public let arn: String?
        /// Indicates whether the associated resource share is using the default version of the permission.
        public let defaultVersion: Bool?
        /// Indicates what features are available for this resource share. This parameter can have one of the following values:    STANDARD – A resource share that supports all functionality. These resource shares are visible to all principals you share the resource share with.  You can modify these resource shares in RAM using the console or APIs. This resource share might  have been created by RAM, or it might have been CREATED_FROM_POLICY and then promoted.    CREATED_FROM_POLICY – The customer manually shared a resource by attaching a resource-based policy. That policy did not match any existing managed permissions, so RAM created this customer managed permission automatically on the customer's behalf based on the attached policy document. This type of resource share  is visible only to the Amazon Web Services account that created it. You can't modify it in  RAM unless you promote it. For more information,  see PromoteResourceShareCreatedFromPolicy.    PROMOTING_TO_STANDARD – This resource share was originally CREATED_FROM_POLICY, but the customer ran the PromoteResourceShareCreatedFromPolicy and that operation is still in progress. This value changes to STANDARD when complete.
        public let featureSet: PermissionFeatureSet?
        /// The date and time when the association between the permission and the resource share was last updated.
        public let lastUpdatedTime: Date?
        /// The version of the permission currently associated with the resource share.
        public let permissionVersion: String?
        /// The Amazon Resource Name (ARN) of a resource share associated with this permission.
        public let resourceShareArn: String?
        /// The resource type to which this permission applies.
        public let resourceType: String?
        /// The current status of the association between the permission and the resource share. The following are the possible values:    ATTACHABLE – This permission or version can be associated  with resource shares.    UNATTACHABLE – This permission or version can't  currently be associated with resource shares.    DELETING – This permission or version is in the process of being deleted.    DELETED – This permission or version is deleted.
        public let status: String?

        @inlinable
        public init(arn: String? = nil, defaultVersion: Bool? = nil, featureSet: PermissionFeatureSet? = nil, lastUpdatedTime: Date? = nil, permissionVersion: String? = nil, resourceShareArn: String? = nil, resourceType: String? = nil, status: String? = nil) {
            self.arn = arn
            self.defaultVersion = defaultVersion
            self.featureSet = featureSet
            self.lastUpdatedTime = lastUpdatedTime
            self.permissionVersion = permissionVersion
            self.resourceShareArn = resourceShareArn
            self.resourceType = resourceType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case defaultVersion = "defaultVersion"
            case featureSet = "featureSet"
            case lastUpdatedTime = "lastUpdatedTime"
            case permissionVersion = "permissionVersion"
            case resourceShareArn = "resourceShareArn"
            case resourceType = "resourceType"
            case status = "status"
        }
    }

    public struct CreatePermissionRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies the name of the customer managed permission. The name must be unique within the Amazon Web Services Region.
        public let name: String
        /// A string in JSON format string that contains the following elements of a resource-based policy:    Effect: must be set to ALLOW.    Action: specifies the actions that are allowed by this customer managed permission. The list must contain only actions that are supported by the specified resource type. For a list of all actions supported by each resource type, see Actions, resources, and condition keys for Amazon Web Services services in the Identity and Access Management User Guide.    Condition: (optional) specifies conditional  parameters that must evaluate to true when a user attempts an action for that  action to be allowed. For more information about the Condition element, see  IAM policies: Condition element in the Identity and Access Management User Guide.   This template can't include either the Resource or Principal elements. Those are both filled in by RAM when it instantiates  the resource-based policy on each resource shared using this managed permission. The  Resource comes from the ARN of the specific resource that you are sharing.  The Principal comes from the list of identities added to the resource  share.
        public let policyTemplate: String
        /// Specifies the name of the resource type that this customer managed permission applies to. The format is  :  and is not case sensitive. For example, to specify an Amazon EC2 Subnet, you can use the string ec2:subnet. To see the list of valid values for this parameter, query the ListResourceTypes operation.
        public let resourceType: String
        /// Specifies a list of one or more tag key and value pairs to attach to the permission.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = nil, name: String, policyTemplate: String, resourceType: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.name = name
            self.policyTemplate = policyTemplate
            self.resourceType = resourceType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 36)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w.-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case policyTemplate = "policyTemplate"
            case resourceType = "resourceType"
            case tags = "tags"
        }
    }

    public struct CreatePermissionResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// A structure with information about this customer managed permission.
        public let permission: ResourceSharePermissionSummary?

        @inlinable
        public init(clientToken: String? = nil, permission: ResourceSharePermissionSummary? = nil) {
            self.clientToken = clientToken
            self.permission = permission
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case permission = "permission"
        }
    }

    public struct CreatePermissionVersionRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the customer managed permission you're creating a new version for.
        public let permissionArn: String
        /// A string in JSON format string that contains the following elements of a resource-based policy:    Effect: must be set to ALLOW.    Action: specifies the actions that are allowed by this customer managed permission. The list must contain only actions that are supported by the specified resource type. For a list of all actions supported by each resource type, see Actions, resources, and condition keys for Amazon Web Services services in the Identity and Access Management User Guide.    Condition: (optional) specifies conditional  parameters that must evaluate to true when a user attempts an action for that  action to be allowed. For more information about the Condition element, see  IAM policies: Condition element in the Identity and Access Management User Guide.   This template can't include either the Resource or Principal elements. Those are both filled in by RAM when it instantiates  the resource-based policy on each resource shared using this managed permission. The  Resource comes from the ARN of the specific resource that you are sharing.  The Principal comes from the list of identities added to the resource  share.
        public let policyTemplate: String

        @inlinable
        public init(clientToken: String? = nil, permissionArn: String, policyTemplate: String) {
            self.clientToken = clientToken
            self.permissionArn = permissionArn
            self.policyTemplate = policyTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case permissionArn = "permissionArn"
            case policyTemplate = "policyTemplate"
        }
    }

    public struct CreatePermissionVersionResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        public let permission: ResourceSharePermissionDetail?

        @inlinable
        public init(clientToken: String? = nil, permission: ResourceSharePermissionDetail? = nil) {
            self.clientToken = clientToken
            self.permission = permission
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case permission = "permission"
        }
    }

    public struct CreateResourceShareRequest: AWSEncodableShape {
        /// Specifies whether principals outside your organization in Organizations can be associated with a resource share. A value of true lets you share with individual Amazon Web Services accounts that are not in your organization. A value of false only has meaning if your account is a member of an Amazon Web Services Organization. The default value is true.
        public let allowExternalPrincipals: Bool?
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies the name of the resource share.
        public let name: String
        /// Specifies the Amazon Resource Names (ARNs) of the RAM permission to associate with the resource share. If you do not specify an ARN for the permission, RAM automatically attaches the default version of the permission for each resource type. You can associate only one permission with each resource type included in the resource share.
        public let permissionArns: [String]?
        /// Specifies a list of one or more principals to associate with the resource share. You can include the following values:   An Amazon Web Services account ID, for example: 123456789012    An Amazon Resource Name (ARN) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid    An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123    An ARN of an IAM role, for example: iam::123456789012:role/rolename    An ARN of an IAM user, for example: iam::123456789012user/username     Not all resource types can be shared with IAM roles and users.  For more information, see Sharing with IAM roles and users in the Resource Access Manager User Guide.
        public let principals: [String]?
        /// Specifies a list of one or more ARNs of the resources to associate with the resource share.
        public let resourceArns: [String]?
        /// Specifies from which source accounts the service principal has access to the resources in this resource share.
        public let sources: [String]?
        /// Specifies one or more tags to attach to the resource share itself. It doesn't attach the tags to the resources associated with the resource share.
        public let tags: [Tag]?

        @inlinable
        public init(allowExternalPrincipals: Bool? = nil, clientToken: String? = nil, name: String, permissionArns: [String]? = nil, principals: [String]? = nil, resourceArns: [String]? = nil, sources: [String]? = nil, tags: [Tag]? = nil) {
            self.allowExternalPrincipals = allowExternalPrincipals
            self.clientToken = clientToken
            self.name = name
            self.permissionArns = permissionArns
            self.principals = principals
            self.resourceArns = resourceArns
            self.sources = sources
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case allowExternalPrincipals = "allowExternalPrincipals"
            case clientToken = "clientToken"
            case name = "name"
            case permissionArns = "permissionArns"
            case principals = "principals"
            case resourceArns = "resourceArns"
            case sources = "sources"
            case tags = "tags"
        }
    }

    public struct CreateResourceShareResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// An object with information about the new resource share.
        public let resourceShare: ResourceShare?

        @inlinable
        public init(clientToken: String? = nil, resourceShare: ResourceShare? = nil) {
            self.clientToken = clientToken
            self.resourceShare = resourceShare
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceShare = "resourceShare"
        }
    }

    public struct DeletePermissionRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the customer managed permission that you want to delete.
        public let permissionArn: String

        @inlinable
        public init(clientToken: String? = nil, permissionArn: String) {
            self.clientToken = clientToken
            self.permissionArn = permissionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodeQuery(self.permissionArn, key: "permissionArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePermissionResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// This operation is performed asynchronously, and this response parameter indicates the current status.
        public let permissionStatus: PermissionStatus?
        /// A boolean that indicates whether the delete operations succeeded.
        public let returnValue: Bool?

        @inlinable
        public init(clientToken: String? = nil, permissionStatus: PermissionStatus? = nil, returnValue: Bool? = nil) {
            self.clientToken = clientToken
            self.permissionStatus = permissionStatus
            self.returnValue = returnValue
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case permissionStatus = "permissionStatus"
            case returnValue = "returnValue"
        }
    }

    public struct DeletePermissionVersionRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the permission with the version you want to delete.
        public let permissionArn: String
        /// Specifies the version number to delete. You can't delete the default version for a customer managed permission. You can't delete a version if it's the only version of the permission. You must either first create another version, or delete the permission completely. You can't delete a version if it is attached to any resource shares. If the version is the default, you must first use SetDefaultPermissionVersion to set a different version as the default for the customer managed permission, and then use AssociateResourceSharePermission to update your resource shares to use the new default version.
        public let permissionVersion: Int

        @inlinable
        public init(clientToken: String? = nil, permissionArn: String, permissionVersion: Int) {
            self.clientToken = clientToken
            self.permissionArn = permissionArn
            self.permissionVersion = permissionVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodeQuery(self.permissionArn, key: "permissionArn")
            request.encodeQuery(self.permissionVersion, key: "permissionVersion")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePermissionVersionResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// This operation is performed asynchronously, and this response parameter indicates the current status.
        public let permissionStatus: PermissionStatus?
        /// A boolean value that indicates whether the operation is successful.
        public let returnValue: Bool?

        @inlinable
        public init(clientToken: String? = nil, permissionStatus: PermissionStatus? = nil, returnValue: Bool? = nil) {
            self.clientToken = clientToken
            self.permissionStatus = permissionStatus
            self.returnValue = returnValue
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case permissionStatus = "permissionStatus"
            case returnValue = "returnValue"
        }
    }

    public struct DeleteResourceShareRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the resource share to delete.
        public let resourceShareArn: String

        @inlinable
        public init(clientToken: String? = nil, resourceShareArn: String) {
            self.clientToken = clientToken
            self.resourceShareArn = resourceShareArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodeQuery(self.resourceShareArn, key: "resourceShareArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourceShareResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// A return value of true indicates that the request succeeded.  A value of false indicates that the request failed.
        public let returnValue: Bool?

        @inlinable
        public init(clientToken: String? = nil, returnValue: Bool? = nil) {
            self.clientToken = clientToken
            self.returnValue = returnValue
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case returnValue = "returnValue"
        }
    }

    public struct DisassociateResourceSharePermissionRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the managed permission to disassociate from the resource share. Changes to permissions take effect immediately.
        public let permissionArn: String
        /// The Amazon Resource Name (ARN) of the resource share that you want to remove the managed permission from.
        public let resourceShareArn: String

        @inlinable
        public init(clientToken: String? = nil, permissionArn: String, resourceShareArn: String) {
            self.clientToken = clientToken
            self.permissionArn = permissionArn
            self.resourceShareArn = resourceShareArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case permissionArn = "permissionArn"
            case resourceShareArn = "resourceShareArn"
        }
    }

    public struct DisassociateResourceSharePermissionResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// A return value of true indicates that the request succeeded.  A value of false indicates that the request failed.
        public let returnValue: Bool?

        @inlinable
        public init(clientToken: String? = nil, returnValue: Bool? = nil) {
            self.clientToken = clientToken
            self.returnValue = returnValue
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case returnValue = "returnValue"
        }
    }

    public struct DisassociateResourceShareRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies a list of one or more principals that no longer are to have access to the resources in this resource share. You can include the following values:   An Amazon Web Services account ID, for example: 123456789012    An Amazon Resource Name (ARN) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid    An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123    An ARN of an IAM role, for example: iam::123456789012:role/rolename    An ARN of an IAM user, for example: iam::123456789012user/username     Not all resource types can be shared with IAM roles and users.  For more information, see Sharing with IAM roles and users in the Resource Access Manager User Guide.
        public let principals: [String]?
        /// Specifies a list of Amazon Resource Names (ARNs) for one or more resources that you want to remove from the resource share. After the operation runs, these resources are no longer shared with principals associated with the resource share.
        public let resourceArns: [String]?
        /// Specifies Amazon Resource Name (ARN) of the resource share that you want to remove resources or principals from.
        public let resourceShareArn: String
        /// Specifies from which source accounts the service principal no longer has access to the resources in this resource share.
        public let sources: [String]?

        @inlinable
        public init(clientToken: String? = nil, principals: [String]? = nil, resourceArns: [String]? = nil, resourceShareArn: String, sources: [String]? = nil) {
            self.clientToken = clientToken
            self.principals = principals
            self.resourceArns = resourceArns
            self.resourceShareArn = resourceShareArn
            self.sources = sources
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case principals = "principals"
            case resourceArns = "resourceArns"
            case resourceShareArn = "resourceShareArn"
            case sources = "sources"
        }
    }

    public struct DisassociateResourceShareResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// An array of objects with information about the updated associations for this resource share.
        public let resourceShareAssociations: [ResourceShareAssociation]?

        @inlinable
        public init(clientToken: String? = nil, resourceShareAssociations: [ResourceShareAssociation]? = nil) {
            self.clientToken = clientToken
            self.resourceShareAssociations = resourceShareAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceShareAssociations = "resourceShareAssociations"
        }
    }

    public struct EnableSharingWithAwsOrganizationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct EnableSharingWithAwsOrganizationResponse: AWSDecodableShape {
        /// A return value of true indicates that the request succeeded.  A value of false indicates that the request failed.
        public let returnValue: Bool?

        @inlinable
        public init(returnValue: Bool? = nil) {
            self.returnValue = returnValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnValue = "returnValue"
        }
    }

    public struct GetPermissionRequest: AWSEncodableShape {
        /// Specifies the Amazon Resource Name (ARN) of the permission whose contents you want to retrieve. To find the ARN for a permission, use either the ListPermissions operation or go to the Permissions library page in the RAM console and  then choose the name of the permission. The ARN is displayed on the detail page.
        public let permissionArn: String
        /// Specifies the version number of the RAM permission to retrieve. If you don't specify this parameter, the operation retrieves the default version. To see the list of available versions, use ListPermissionVersions.
        public let permissionVersion: Int?

        @inlinable
        public init(permissionArn: String, permissionVersion: Int? = nil) {
            self.permissionArn = permissionArn
            self.permissionVersion = permissionVersion
        }

        private enum CodingKeys: String, CodingKey {
            case permissionArn = "permissionArn"
            case permissionVersion = "permissionVersion"
        }
    }

    public struct GetPermissionResponse: AWSDecodableShape {
        /// An object with details about the permission.
        public let permission: ResourceSharePermissionDetail?

        @inlinable
        public init(permission: ResourceSharePermissionDetail? = nil) {
            self.permission = permission
        }

        private enum CodingKeys: String, CodingKey {
            case permission = "permission"
        }
    }

    public struct GetResourcePoliciesRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies the principal.
        public let principal: String?
        /// Specifies the Amazon Resource Names (ARNs) of the resources whose policies you want to retrieve.
        public let resourceArns: [String]

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, principal: String? = nil, resourceArns: [String]) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principal = principal
            self.resourceArns = resourceArns
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case principal = "principal"
            case resourceArns = "resourceArns"
        }
    }

    public struct GetResourcePoliciesResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of resource policy documents in JSON format.
        public let policies: [String]?

        @inlinable
        public init(nextToken: String? = nil, policies: [String]? = nil) {
            self.nextToken = nextToken
            self.policies = policies
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case policies = "policies"
        }
    }

    public struct GetResourceShareAssociationsRequest: AWSEncodableShape {
        /// Specifies that you want to retrieve only associations that have this status.
        public let associationStatus: ResourceShareAssociationStatus?
        /// Specifies whether you want to retrieve the associations that involve a specified resource or principal.    PRINCIPAL – list the principals whose associations you want to see.    RESOURCE – list the resources whose associations you want to see.
        public let associationType: ResourceShareAssociationType
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies the ID of the principal whose resource shares you want to retrieve. This can be an Amazon Web Services account ID, an organization ID, an organizational unit ID, or the Amazon Resource Name (ARN) of an individual IAM role or user. You cannot specify this parameter if the association type is RESOURCE.
        public let principal: String?
        /// Specifies the Amazon Resource Name (ARN) of a resource whose resource shares you want to retrieve. You cannot specify this parameter if the association type is PRINCIPAL.
        public let resourceArn: String?
        /// Specifies a list of Amazon Resource Names (ARNs) of the resource share whose associations you want to retrieve.
        public let resourceShareArns: [String]?

        @inlinable
        public init(associationStatus: ResourceShareAssociationStatus? = nil, associationType: ResourceShareAssociationType, maxResults: Int? = nil, nextToken: String? = nil, principal: String? = nil, resourceArn: String? = nil, resourceShareArns: [String]? = nil) {
            self.associationStatus = associationStatus
            self.associationType = associationType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principal = principal
            self.resourceArn = resourceArn
            self.resourceShareArns = resourceShareArns
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case associationStatus = "associationStatus"
            case associationType = "associationType"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case principal = "principal"
            case resourceArn = "resourceArn"
            case resourceShareArns = "resourceShareArns"
        }
    }

    public struct GetResourceShareAssociationsResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of objects that contain the details about the associations.
        public let resourceShareAssociations: [ResourceShareAssociation]?

        @inlinable
        public init(nextToken: String? = nil, resourceShareAssociations: [ResourceShareAssociation]? = nil) {
            self.nextToken = nextToken
            self.resourceShareAssociations = resourceShareAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resourceShareAssociations = "resourceShareAssociations"
        }
    }

    public struct GetResourceShareInvitationsRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies that you want details about invitations only for the resource shares described by this list of Amazon Resource Names (ARNs)
        public let resourceShareArns: [String]?
        /// Specifies the Amazon Resource Names (ARNs) of the resource share invitations you want information about.
        public let resourceShareInvitationArns: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceShareArns: [String]? = nil, resourceShareInvitationArns: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceShareArns = resourceShareArns
            self.resourceShareInvitationArns = resourceShareInvitationArns
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceShareArns = "resourceShareArns"
            case resourceShareInvitationArns = "resourceShareInvitationArns"
        }
    }

    public struct GetResourceShareInvitationsResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of objects that contain the details about the invitations.
        public let resourceShareInvitations: [ResourceShareInvitation]?

        @inlinable
        public init(nextToken: String? = nil, resourceShareInvitations: [ResourceShareInvitation]? = nil) {
            self.nextToken = nextToken
            self.resourceShareInvitations = resourceShareInvitations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resourceShareInvitations = "resourceShareInvitations"
        }
    }

    public struct GetResourceSharesRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies the name of an individual resource share that you want to retrieve details about.
        public let name: String?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies that you want to retrieve details of only those resource shares that use the managed permission with this Amazon Resource Name (ARN).
        public let permissionArn: String?
        /// Specifies that you want to retrieve details for only those resource shares that use the specified version of the managed permission.
        public let permissionVersion: Int?
        /// Specifies that you want to retrieve details of only those resource shares that match the following:     SELF – resource shares that your account shares with other accounts     OTHER-ACCOUNTS – resource shares that other accounts share with your account
        public let resourceOwner: ResourceOwner
        /// Specifies the Amazon Resource Names (ARNs) of individual resource shares that you want information about.
        public let resourceShareArns: [String]?
        /// Specifies that you want to retrieve details of only those resource shares that have this status.
        public let resourceShareStatus: ResourceShareStatus?
        /// Specifies that you want to retrieve details of only those resource shares that match the specified tag keys and values.
        public let tagFilters: [TagFilter]?

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, permissionArn: String? = nil, permissionVersion: Int? = nil, resourceOwner: ResourceOwner, resourceShareArns: [String]? = nil, resourceShareStatus: ResourceShareStatus? = nil, tagFilters: [TagFilter]? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.permissionArn = permissionArn
            self.permissionVersion = permissionVersion
            self.resourceOwner = resourceOwner
            self.resourceShareArns = resourceShareArns
            self.resourceShareStatus = resourceShareStatus
            self.tagFilters = tagFilters
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case name = "name"
            case nextToken = "nextToken"
            case permissionArn = "permissionArn"
            case permissionVersion = "permissionVersion"
            case resourceOwner = "resourceOwner"
            case resourceShareArns = "resourceShareArns"
            case resourceShareStatus = "resourceShareStatus"
            case tagFilters = "tagFilters"
        }
    }

    public struct GetResourceSharesResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of objects that contain the information about the resource shares.
        public let resourceShares: [ResourceShare]?

        @inlinable
        public init(nextToken: String? = nil, resourceShares: [ResourceShare]? = nil) {
            self.nextToken = nextToken
            self.resourceShares = resourceShares
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resourceShares = "resourceShares"
        }
    }

    public struct ListPendingInvitationResourcesRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies that you want the results to include only  resources that have the specified scope.    ALL – the results include both global and  regional resources or resource types.    GLOBAL – the results include only global  resources or resource types.    REGIONAL – the results include only regional  resources or resource types.   The default value is ALL.
        public let resourceRegionScope: ResourceRegionScopeFilter?
        /// Specifies the Amazon Resource Name (ARN) of the invitation. You can use GetResourceShareInvitations to find the ARN of the invitation.
        public let resourceShareInvitationArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceRegionScope: ResourceRegionScopeFilter? = nil, resourceShareInvitationArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceRegionScope = resourceRegionScope
            self.resourceShareInvitationArn = resourceShareInvitationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceRegionScope = "resourceRegionScope"
            case resourceShareInvitationArn = "resourceShareInvitationArn"
        }
    }

    public struct ListPendingInvitationResourcesResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of objects that contain the information about the resources included the specified resource share.
        public let resources: [Resource]?

        @inlinable
        public init(nextToken: String? = nil, resources: [Resource]? = nil) {
            self.nextToken = nextToken
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resources = "resources"
        }
    }

    public struct ListPermissionAssociationsRequest: AWSEncodableShape {
        /// Specifies that you want to list only those associations with resource shares that match this status.
        public let associationStatus: ResourceShareAssociationStatus?
        /// When true, specifies that you want to list only those associations with resource shares that use the default version of the specified managed permission. When false (the default value), lists associations with resource shares that use any version of the specified managed permission.
        public let defaultVersion: Bool?
        /// Specifies that you want to list only those associations with resource shares that have a featureSet with this value.
        public let featureSet: PermissionFeatureSet?
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the managed permission.
        public let permissionArn: String?
        /// Specifies that you want to list only those associations with resource shares that use this version of the managed permission. If you don't provide a value for this parameter, then the operation returns information about associations with resource shares that use any version of the managed permission.
        public let permissionVersion: Int?
        /// Specifies that you want to list only those associations with resource shares that include at least one resource of this resource type.
        public let resourceType: String?

        @inlinable
        public init(associationStatus: ResourceShareAssociationStatus? = nil, defaultVersion: Bool? = nil, featureSet: PermissionFeatureSet? = nil, maxResults: Int? = nil, nextToken: String? = nil, permissionArn: String? = nil, permissionVersion: Int? = nil, resourceType: String? = nil) {
            self.associationStatus = associationStatus
            self.defaultVersion = defaultVersion
            self.featureSet = featureSet
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.permissionArn = permissionArn
            self.permissionVersion = permissionVersion
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case associationStatus = "associationStatus"
            case defaultVersion = "defaultVersion"
            case featureSet = "featureSet"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case permissionArn = "permissionArn"
            case permissionVersion = "permissionVersion"
            case resourceType = "resourceType"
        }
    }

    public struct ListPermissionAssociationsResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// A structure with information about this customer managed permission.
        public let permissions: [AssociatedPermission]?

        @inlinable
        public init(nextToken: String? = nil, permissions: [AssociatedPermission]? = nil) {
            self.nextToken = nextToken
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case permissions = "permissions"
        }
    }

    public struct ListPermissionVersionsRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the RAM permission whose versions you want to list. You can use the permissionVersion parameter on the AssociateResourceSharePermission operation to specify a non-default version to attach.
        public let permissionArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, permissionArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.permissionArn = permissionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case permissionArn = "permissionArn"
        }
    }

    public struct ListPermissionVersionsResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of objects that contain details for each of the available versions.
        public let permissions: [ResourceSharePermissionSummary]?

        @inlinable
        public init(nextToken: String? = nil, permissions: [ResourceSharePermissionSummary]? = nil) {
            self.nextToken = nextToken
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case permissions = "permissions"
        }
    }

    public struct ListPermissionsRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies that you want to list only permissions of this type:    AWS – returns only Amazon Web Services managed permissions.    LOCAL – returns only customer managed permissions    ALL – returns both Amazon Web Services managed permissions and customer managed permissions.   If you don't specify this parameter, the default is All.
        public let permissionType: PermissionTypeFilter?
        /// Specifies that you want to list only those permissions that apply to the specified resource type. This parameter is not case sensitive. For example, to list only permissions that apply to Amazon EC2 subnets, specify ec2:subnet. You can use the ListResourceTypes operation to get the specific string required.
        public let resourceType: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, permissionType: PermissionTypeFilter? = nil, resourceType: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.permissionType = permissionType
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case permissionType = "permissionType"
            case resourceType = "resourceType"
        }
    }

    public struct ListPermissionsResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of objects with information about the permissions.
        public let permissions: [ResourceSharePermissionSummary]?

        @inlinable
        public init(nextToken: String? = nil, permissions: [ResourceSharePermissionSummary]? = nil) {
            self.nextToken = nextToken
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case permissions = "permissions"
        }
    }

    public struct ListPrincipalsRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies that you want to list information for only the listed principals. You can include the following values:   An Amazon Web Services account ID, for example: 123456789012    An Amazon Resource Name (ARN) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid    An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123    An ARN of an IAM role, for example: iam::123456789012:role/rolename    An ARN of an IAM user, for example: iam::123456789012user/username     Not all resource types can be shared with IAM roles and users.  For more information, see Sharing with IAM roles and users in the Resource Access Manager User Guide.
        public let principals: [String]?
        /// Specifies that you want to list principal information for the resource share with the specified Amazon Resource Name (ARN).
        public let resourceArn: String?
        /// Specifies that you want to list information for only resource shares that match the following:     SELF – principals that your account is sharing resources with     OTHER-ACCOUNTS – principals that are sharing resources with your account
        public let resourceOwner: ResourceOwner
        /// Specifies that you want to list information for only principals associated with the resource shares specified by a list the Amazon Resource Names (ARNs).
        public let resourceShareArns: [String]?
        /// Specifies that you want to list information for only principals associated with resource shares that include the specified resource type. For a list of valid values, query the ListResourceTypes operation.
        public let resourceType: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, principals: [String]? = nil, resourceArn: String? = nil, resourceOwner: ResourceOwner, resourceShareArns: [String]? = nil, resourceType: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principals = principals
            self.resourceArn = resourceArn
            self.resourceOwner = resourceOwner
            self.resourceShareArns = resourceShareArns
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case principals = "principals"
            case resourceArn = "resourceArn"
            case resourceOwner = "resourceOwner"
            case resourceShareArns = "resourceShareArns"
            case resourceType = "resourceType"
        }
    }

    public struct ListPrincipalsResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of objects that contain the details about the principals.
        public let principals: [Principal]?

        @inlinable
        public init(nextToken: String? = nil, principals: [Principal]? = nil) {
            self.nextToken = nextToken
            self.principals = principals
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case principals = "principals"
        }
    }

    public struct ListReplacePermissionAssociationsWorkRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies that you want to see only the details about requests with a status that matches this value.
        public let status: ReplacePermissionAssociationsWorkStatus?
        /// A list of IDs. These values come from the idfield of the replacePermissionAssociationsWorkstructure returned by the ReplacePermissionAssociations operation.
        public let workIds: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, status: ReplacePermissionAssociationsWorkStatus? = nil, workIds: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
            self.workIds = workIds
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case status = "status"
            case workIds = "workIds"
        }
    }

    public struct ListReplacePermissionAssociationsWorkResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of data structures that provide details of the matching work IDs.
        public let replacePermissionAssociationsWorks: [ReplacePermissionAssociationsWork]?

        @inlinable
        public init(nextToken: String? = nil, replacePermissionAssociationsWorks: [ReplacePermissionAssociationsWork]? = nil) {
            self.nextToken = nextToken
            self.replacePermissionAssociationsWorks = replacePermissionAssociationsWorks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case replacePermissionAssociationsWorks = "replacePermissionAssociationsWorks"
        }
    }

    public struct ListResourceSharePermissionsRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the resource share for which you want to retrieve the associated permissions.
        public let resourceShareArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceShareArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceShareArn = resourceShareArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceShareArn = "resourceShareArn"
        }
    }

    public struct ListResourceSharePermissionsResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of objects that describe the permissions associated with the resource share.
        public let permissions: [ResourceSharePermissionSummary]?

        @inlinable
        public init(nextToken: String? = nil, permissions: [ResourceSharePermissionSummary]? = nil) {
            self.nextToken = nextToken
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case permissions = "permissions"
        }
    }

    public struct ListResourceTypesRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies that you want the results to include only  resources that have the specified scope.    ALL – the results include both global and  regional resources or resource types.    GLOBAL – the results include only global  resources or resource types.    REGIONAL – the results include only regional  resources or resource types.   The default value is ALL.
        public let resourceRegionScope: ResourceRegionScopeFilter?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceRegionScope: ResourceRegionScopeFilter? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceRegionScope = resourceRegionScope
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceRegionScope = "resourceRegionScope"
        }
    }

    public struct ListResourceTypesResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of objects that contain information about the resource types that can be shared using RAM.
        public let resourceTypes: [ServiceNameAndResourceType]?

        @inlinable
        public init(nextToken: String? = nil, resourceTypes: [ServiceNameAndResourceType]? = nil) {
            self.nextToken = nextToken
            self.resourceTypes = resourceTypes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resourceTypes = "resourceTypes"
        }
    }

    public struct ListResourcesRequest: AWSEncodableShape {
        /// Specifies the total number of results that you want included on each page  of the response. If you do not include this parameter, it defaults to a value that is  specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next  call to the operation to get the next part of the results. Note that the service might  return fewer results than the maximum even when there are more results available. You  should check NextToken after every operation to ensure that you receive all of the results.
        public let maxResults: Int?
        /// Specifies that you want to receive the next page of results. Valid  only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value  provided by the previous call's NextToken response to request the  next page of results.
        public let nextToken: String?
        /// Specifies that you want to list only the resource shares that are associated with the specified principal.
        public let principal: String?
        /// Specifies that you want to list only the resource shares that include resources with the specified Amazon Resource Names (ARNs).
        public let resourceArns: [String]?
        /// Specifies that you want to list only the resource shares that match the following:     SELF – resources that your account shares with other accounts     OTHER-ACCOUNTS – resources that other accounts share with your account
        public let resourceOwner: ResourceOwner
        /// Specifies that you want the results to include only  resources that have the specified scope.    ALL – the results include both global and  regional resources or resource types.    GLOBAL – the results include only global  resources or resource types.    REGIONAL – the results include only regional  resources or resource types.   The default value is ALL.
        public let resourceRegionScope: ResourceRegionScopeFilter?
        /// Specifies that you want to list only resources in the resource shares identified by the specified Amazon Resource Names (ARNs).
        public let resourceShareArns: [String]?
        /// Specifies that you want to list only the resource shares that include resources of the specified resource type. For valid values, query the ListResourceTypes operation.
        public let resourceType: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, principal: String? = nil, resourceArns: [String]? = nil, resourceOwner: ResourceOwner, resourceRegionScope: ResourceRegionScopeFilter? = nil, resourceShareArns: [String]? = nil, resourceType: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principal = principal
            self.resourceArns = resourceArns
            self.resourceOwner = resourceOwner
            self.resourceRegionScope = resourceRegionScope
            self.resourceShareArns = resourceShareArns
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case principal = "principal"
            case resourceArns = "resourceArns"
            case resourceOwner = "resourceOwner"
            case resourceRegionScope = "resourceRegionScope"
            case resourceShareArns = "resourceShareArns"
            case resourceType = "resourceType"
        }
    }

    public struct ListResourcesResponse: AWSDecodableShape {
        /// If present, this value indicates that more output is available than  is included in the current response. Use this value in the NextToken  request parameter in a subsequent call to the operation to get the next part of the  output. You should repeat this until the NextToken response element comes  back as null. This indicates that this is the last page of results.
        public let nextToken: String?
        /// An array of objects that contain information about the resources.
        public let resources: [Resource]?

        @inlinable
        public init(nextToken: String? = nil, resources: [Resource]? = nil) {
            self.nextToken = nextToken
            self.resources = resources
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resources = "resources"
        }
    }

    public struct Principal: AWSDecodableShape {
        /// The date and time when the principal was associated with the resource share.
        public let creationTime: Date?
        /// Indicates the relationship between the Amazon Web Services account the principal belongs to and the account that owns the resource share:    True – The two accounts belong to same organization.    False – The two accounts do not belong to the same organization.
        public let external: Bool?
        /// The ID of the principal that can be associated with a resource share.
        public let id: String?
        /// The date and time when the association between the resource share and the principal was last updated.
        public let lastUpdatedTime: Date?
        /// The Amazon Resource Name (ARN) of a resource share the principal is associated with.
        public let resourceShareArn: String?

        @inlinable
        public init(creationTime: Date? = nil, external: Bool? = nil, id: String? = nil, lastUpdatedTime: Date? = nil, resourceShareArn: String? = nil) {
            self.creationTime = creationTime
            self.external = external
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceShareArn = resourceShareArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case external = "external"
            case id = "id"
            case lastUpdatedTime = "lastUpdatedTime"
            case resourceShareArn = "resourceShareArn"
        }
    }

    public struct PromotePermissionCreatedFromPolicyRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies a name for the promoted customer managed permission.
        public let name: String
        /// Specifies the Amazon Resource Name (ARN) of the CREATED_FROM_POLICY permission that you want to promote. You can get this Amazon Resource Name (ARN) by calling the ListResourceSharePermissions operation.
        public let permissionArn: String

        @inlinable
        public init(clientToken: String? = nil, name: String, permissionArn: String) {
            self.clientToken = clientToken
            self.name = name
            self.permissionArn = permissionArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case permissionArn = "permissionArn"
        }
    }

    public struct PromotePermissionCreatedFromPolicyResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        public let permission: ResourceSharePermissionSummary?

        @inlinable
        public init(clientToken: String? = nil, permission: ResourceSharePermissionSummary? = nil) {
            self.clientToken = clientToken
            self.permission = permission
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case permission = "permission"
        }
    }

    public struct PromoteResourceShareCreatedFromPolicyRequest: AWSEncodableShape {
        /// Specifies the Amazon Resource Name (ARN) of the resource share to promote.
        public let resourceShareArn: String

        @inlinable
        public init(resourceShareArn: String) {
            self.resourceShareArn = resourceShareArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceShareArn, key: "resourceShareArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PromoteResourceShareCreatedFromPolicyResponse: AWSDecodableShape {
        /// A return value of true indicates that the request succeeded.  A value of false indicates that the request failed.
        public let returnValue: Bool?

        @inlinable
        public init(returnValue: Bool? = nil) {
            self.returnValue = returnValue
        }

        private enum CodingKeys: String, CodingKey {
            case returnValue = "returnValue"
        }
    }

    public struct RejectResourceShareInvitationRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the invitation that you want to reject.
        public let resourceShareInvitationArn: String

        @inlinable
        public init(clientToken: String? = nil, resourceShareInvitationArn: String) {
            self.clientToken = clientToken
            self.resourceShareInvitationArn = resourceShareInvitationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceShareInvitationArn = "resourceShareInvitationArn"
        }
    }

    public struct RejectResourceShareInvitationResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// An object that contains the details about the rejected invitation.
        public let resourceShareInvitation: ResourceShareInvitation?

        @inlinable
        public init(clientToken: String? = nil, resourceShareInvitation: ResourceShareInvitation? = nil) {
            self.clientToken = clientToken
            self.resourceShareInvitation = resourceShareInvitation
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceShareInvitation = "resourceShareInvitation"
        }
    }

    public struct ReplacePermissionAssociationsRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the managed permission that you want to replace.
        public let fromPermissionArn: String
        /// Specifies that you want to updated the permissions for only those resource shares that use the specified version of the managed permission.
        public let fromPermissionVersion: Int?
        /// Specifies the ARN of the managed permission that you want to associate with resource shares in place of the one specified by fromPerssionArn and fromPermissionVersion. The operation always associates the version that is currently the default for the specified managed permission.
        public let toPermissionArn: String

        @inlinable
        public init(clientToken: String? = nil, fromPermissionArn: String, fromPermissionVersion: Int? = nil, toPermissionArn: String) {
            self.clientToken = clientToken
            self.fromPermissionArn = fromPermissionArn
            self.fromPermissionVersion = fromPermissionVersion
            self.toPermissionArn = toPermissionArn
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case fromPermissionArn = "fromPermissionArn"
            case fromPermissionVersion = "fromPermissionVersion"
            case toPermissionArn = "toPermissionArn"
        }
    }

    public struct ReplacePermissionAssociationsResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// Specifies a data structure that you can use to track the asynchronous tasks that RAM performs to complete this operation. You can use the ListReplacePermissionAssociationsWork operation and pass the id value returned in this structure.
        public let replacePermissionAssociationsWork: ReplacePermissionAssociationsWork?

        @inlinable
        public init(clientToken: String? = nil, replacePermissionAssociationsWork: ReplacePermissionAssociationsWork? = nil) {
            self.clientToken = clientToken
            self.replacePermissionAssociationsWork = replacePermissionAssociationsWork
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case replacePermissionAssociationsWork = "replacePermissionAssociationsWork"
        }
    }

    public struct ReplacePermissionAssociationsWork: AWSDecodableShape {
        /// The date and time when this asynchronous background task was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the managed permission that this background task is replacing.
        public let fromPermissionArn: String?
        /// The version of the managed permission that this background task is replacing.
        public let fromPermissionVersion: String?
        /// The unique identifier for the background task associated with one ReplacePermissionAssociations request.
        public let id: String?
        /// The date and time when the status of this background task was last updated.
        public let lastUpdatedTime: Date?
        /// Specifies the current status of the background tasks for the specified ID. The output is one of the following strings:    IN_PROGRESS     COMPLETED     FAILED
        public let status: ReplacePermissionAssociationsWorkStatus?
        /// Specifies the reason for a FAILED status. This field is present only when there status is FAILED.
        public let statusMessage: String?
        /// The ARN of the managed permission that this background task is associating with the resource shares in place of the managed permission and version specified in fromPermissionArn and fromPermissionVersion.
        public let toPermissionArn: String?
        /// The version of the managed permission that this background task is associating with the resource shares. This is always the version that is currently the default for this managed permission.
        public let toPermissionVersion: String?

        @inlinable
        public init(creationTime: Date? = nil, fromPermissionArn: String? = nil, fromPermissionVersion: String? = nil, id: String? = nil, lastUpdatedTime: Date? = nil, status: ReplacePermissionAssociationsWorkStatus? = nil, statusMessage: String? = nil, toPermissionArn: String? = nil, toPermissionVersion: String? = nil) {
            self.creationTime = creationTime
            self.fromPermissionArn = fromPermissionArn
            self.fromPermissionVersion = fromPermissionVersion
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
            self.statusMessage = statusMessage
            self.toPermissionArn = toPermissionArn
            self.toPermissionVersion = toPermissionVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case fromPermissionArn = "fromPermissionArn"
            case fromPermissionVersion = "fromPermissionVersion"
            case id = "id"
            case lastUpdatedTime = "lastUpdatedTime"
            case status = "status"
            case statusMessage = "statusMessage"
            case toPermissionArn = "toPermissionArn"
            case toPermissionVersion = "toPermissionVersion"
        }
    }

    public struct Resource: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?
        /// The date and time when the resource was associated with the resource share.
        public let creationTime: Date?
        /// The date an time when the association between the resource and the resource share was last updated.
        public let lastUpdatedTime: Date?
        /// The Amazon Resource Name (ARN) of the resource group. This value is available only if the resource is part of a resource group.
        public let resourceGroupArn: String?
        /// Specifies the scope of visibility of this resource:    REGIONAL – The resource can be accessed only by using requests that target the Amazon Web Services Region in which the resource exists.    GLOBAL – The resource can be accessed from any Amazon Web Services Region.
        public let resourceRegionScope: ResourceRegionScope?
        /// The Amazon Resource Name (ARN) of the resource share this resource is associated with.
        public let resourceShareArn: String?
        /// The current status of the resource.
        public let status: ResourceStatus?
        /// A message about the status of the resource.
        public let statusMessage: String?
        /// The resource type. This takes the form of: service-code:resource-code, and is case-insensitive. For example, an Amazon EC2 Subnet would be represented by the string ec2:subnet.
        public let type: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, lastUpdatedTime: Date? = nil, resourceGroupArn: String? = nil, resourceRegionScope: ResourceRegionScope? = nil, resourceShareArn: String? = nil, status: ResourceStatus? = nil, statusMessage: String? = nil, type: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceGroupArn = resourceGroupArn
            self.resourceRegionScope = resourceRegionScope
            self.resourceShareArn = resourceShareArn
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case lastUpdatedTime = "lastUpdatedTime"
            case resourceGroupArn = "resourceGroupArn"
            case resourceRegionScope = "resourceRegionScope"
            case resourceShareArn = "resourceShareArn"
            case status = "status"
            case statusMessage = "statusMessage"
            case type = "type"
        }
    }

    public struct ResourceShare: AWSDecodableShape {
        /// Indicates whether principals outside your organization in Organizations can be associated with a resource share.    True – the resource share can be shared with any Amazon Web Services account.    False – the resource share can be shared with only accounts in the same organization as the account that owns the resource share.
        public let allowExternalPrincipals: Bool?
        /// The date and time when the resource share was created.
        public let creationTime: Date?
        /// Indicates what features are available for this resource share. This parameter can have one of the following values:    STANDARD – A resource share that supports all functionality. These resource shares are visible to all principals you share the resource share with.  You can modify these resource shares in RAM using the console or APIs. This resource share might  have been created by RAM, or it might have been CREATED_FROM_POLICY and then promoted.    CREATED_FROM_POLICY – The customer manually shared a resource by attaching a resource-based policy. That policy did not match any existing managed permissions, so RAM created this customer managed permission automatically on the customer's behalf based on the attached policy document. This type of resource share  is visible only to the Amazon Web Services account that created it. You can't modify it in  RAM unless you promote it. For more information,  see PromoteResourceShareCreatedFromPolicy.    PROMOTING_TO_STANDARD – This resource share was originally CREATED_FROM_POLICY, but the customer ran the PromoteResourceShareCreatedFromPolicy and that operation is still in progress. This value changes to STANDARD when complete.
        public let featureSet: ResourceShareFeatureSet?
        /// The date and time when the resource share was last updated.
        public let lastUpdatedTime: Date?
        /// The name of the resource share.
        public let name: String?
        /// The ID of the Amazon Web Services account that owns the resource share.
        public let owningAccountId: String?
        /// The Amazon Resource Name (ARN) of the resource share
        public let resourceShareArn: String?
        /// The current status of the resource share.
        public let status: ResourceShareStatus?
        /// A message about the status of the resource share.
        public let statusMessage: String?
        /// The tag key and value pairs attached to the resource share.
        public let tags: [Tag]?

        @inlinable
        public init(allowExternalPrincipals: Bool? = nil, creationTime: Date? = nil, featureSet: ResourceShareFeatureSet? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, owningAccountId: String? = nil, resourceShareArn: String? = nil, status: ResourceShareStatus? = nil, statusMessage: String? = nil, tags: [Tag]? = nil) {
            self.allowExternalPrincipals = allowExternalPrincipals
            self.creationTime = creationTime
            self.featureSet = featureSet
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.owningAccountId = owningAccountId
            self.resourceShareArn = resourceShareArn
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case allowExternalPrincipals = "allowExternalPrincipals"
            case creationTime = "creationTime"
            case featureSet = "featureSet"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case owningAccountId = "owningAccountId"
            case resourceShareArn = "resourceShareArn"
            case status = "status"
            case statusMessage = "statusMessage"
            case tags = "tags"
        }
    }

    public struct ResourceShareAssociation: AWSDecodableShape {
        /// The associated entity. This can be either of the following:   For a resource association, this is the Amazon Resource Name (ARN) of the resource.   For principal associations, this is one of the following:   The ID of an Amazon Web Services account   The Amazon Resource Name (ARN) of an organization in Organizations   The ARN of an organizational unit (OU) in Organizations   The ARN of an IAM role   The ARN of an IAM user
        public let associatedEntity: String?
        /// The type of entity included in this association.
        public let associationType: ResourceShareAssociationType?
        /// The date and time when the association was created.
        public let creationTime: Date?
        /// Indicates whether the principal belongs to the same organization in Organizations as the Amazon Web Services account that owns the resource share.
        public let external: Bool?
        /// The date and time when the association was last updated.
        public let lastUpdatedTime: Date?
        /// The Amazon Resource Name (ARN) of the resource share.
        public let resourceShareArn: String?
        /// The name of the resource share.
        public let resourceShareName: String?
        /// The current status of the association.
        public let status: ResourceShareAssociationStatus?
        /// A message about the status of the association.
        public let statusMessage: String?

        @inlinable
        public init(associatedEntity: String? = nil, associationType: ResourceShareAssociationType? = nil, creationTime: Date? = nil, external: Bool? = nil, lastUpdatedTime: Date? = nil, resourceShareArn: String? = nil, resourceShareName: String? = nil, status: ResourceShareAssociationStatus? = nil, statusMessage: String? = nil) {
            self.associatedEntity = associatedEntity
            self.associationType = associationType
            self.creationTime = creationTime
            self.external = external
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceShareArn = resourceShareArn
            self.resourceShareName = resourceShareName
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case associatedEntity = "associatedEntity"
            case associationType = "associationType"
            case creationTime = "creationTime"
            case external = "external"
            case lastUpdatedTime = "lastUpdatedTime"
            case resourceShareArn = "resourceShareArn"
            case resourceShareName = "resourceShareName"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct ResourceShareInvitation: AWSDecodableShape {
        /// The date and time when the invitation was sent.
        public let invitationTimestamp: Date?
        /// The ID of the Amazon Web Services account that received the invitation.
        public let receiverAccountId: String?
        /// The Amazon Resource Name (ARN) of the IAM user or role that received the invitation.
        public let receiverArn: String?
        /// The Amazon Resource Name (ARN) of the resource share
        public let resourceShareArn: String?
        /// To view the resources associated with a pending resource share invitation, use ListPendingInvitationResources.
        public let resourceShareAssociations: [ResourceShareAssociation]?
        /// The Amazon Resource Name (ARN) of the invitation.
        public let resourceShareInvitationArn: String?
        /// The name of the resource share.
        public let resourceShareName: String?
        /// The ID of the Amazon Web Services account that sent the invitation.
        public let senderAccountId: String?
        /// The current status of the invitation.
        public let status: ResourceShareInvitationStatus?

        @inlinable
        public init(invitationTimestamp: Date? = nil, receiverAccountId: String? = nil, receiverArn: String? = nil, resourceShareArn: String? = nil, resourceShareInvitationArn: String? = nil, resourceShareName: String? = nil, senderAccountId: String? = nil, status: ResourceShareInvitationStatus? = nil) {
            self.invitationTimestamp = invitationTimestamp
            self.receiverAccountId = receiverAccountId
            self.receiverArn = receiverArn
            self.resourceShareArn = resourceShareArn
            self.resourceShareAssociations = nil
            self.resourceShareInvitationArn = resourceShareInvitationArn
            self.resourceShareName = resourceShareName
            self.senderAccountId = senderAccountId
            self.status = status
        }

        @available(*, deprecated, message: "Members resourceShareAssociations have been deprecated")
        @inlinable
        public init(invitationTimestamp: Date? = nil, receiverAccountId: String? = nil, receiverArn: String? = nil, resourceShareArn: String? = nil, resourceShareAssociations: [ResourceShareAssociation]? = nil, resourceShareInvitationArn: String? = nil, resourceShareName: String? = nil, senderAccountId: String? = nil, status: ResourceShareInvitationStatus? = nil) {
            self.invitationTimestamp = invitationTimestamp
            self.receiverAccountId = receiverAccountId
            self.receiverArn = receiverArn
            self.resourceShareArn = resourceShareArn
            self.resourceShareAssociations = resourceShareAssociations
            self.resourceShareInvitationArn = resourceShareInvitationArn
            self.resourceShareName = resourceShareName
            self.senderAccountId = senderAccountId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case invitationTimestamp = "invitationTimestamp"
            case receiverAccountId = "receiverAccountId"
            case receiverArn = "receiverArn"
            case resourceShareArn = "resourceShareArn"
            case resourceShareAssociations = "resourceShareAssociations"
            case resourceShareInvitationArn = "resourceShareInvitationArn"
            case resourceShareName = "resourceShareName"
            case senderAccountId = "senderAccountId"
            case status = "status"
        }
    }

    public struct ResourceSharePermissionDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this RAM managed permission.
        public let arn: String?
        /// The date and time when the permission was created.
        public let creationTime: Date?
        /// Specifies whether the version of the permission represented in this response is the default version for this permission.
        public let defaultVersion: Bool?
        /// Indicates what features are available for this resource share. This parameter can have one of the following values:    STANDARD – A resource share that supports all functionality. These resource shares are visible to all principals you share the resource share with.  You can modify these resource shares in RAM using the console or APIs. This resource share might  have been created by RAM, or it might have been CREATED_FROM_POLICY and then promoted.    CREATED_FROM_POLICY – The customer manually shared a resource by attaching a resource-based policy. That policy did not match any existing managed permissions, so RAM created this customer managed permission automatically on the customer's behalf based on the attached policy document. This type of resource share  is visible only to the Amazon Web Services account that created it. You can't modify it in  RAM unless you promote it. For more information,  see PromoteResourceShareCreatedFromPolicy.    PROMOTING_TO_STANDARD – This resource share was originally CREATED_FROM_POLICY, but the customer ran the PromoteResourceShareCreatedFromPolicy and that operation is still in progress. This value changes to STANDARD when complete.
        public let featureSet: PermissionFeatureSet?
        /// Specifies whether the version of the permission represented in this response is the default version for all resources of this resource type.
        public let isResourceTypeDefault: Bool?
        /// The date and time when the permission was last updated.
        public let lastUpdatedTime: Date?
        /// The name of this permission.
        public let name: String?
        /// The permission's effect and actions in JSON format. The effect indicates whether the specified actions are allowed or denied. The actions list the operations to which the principal is granted or denied access.
        public let permission: String?
        /// The type of managed permission. This can be one of the following values:    AWS_MANAGED – Amazon Web Services created and manages this managed permission. You can associate it with your resource shares, but you can't modify it.    CUSTOMER_MANAGED – You, or another principal in your account created this managed permission. You can associate it with your resource shares and create new versions that have different permissions.
        public let permissionType: PermissionType?
        /// The resource type to which this permission applies.
        public let resourceType: String?
        /// The current status of the association between the permission and the resource share. The following are the possible values:    ATTACHABLE – This permission or version can be associated  with resource shares.    UNATTACHABLE – This permission or version can't  currently be associated with resource shares.    DELETING – This permission or version is in the process of being deleted.    DELETED – This permission or version is deleted.
        public let status: PermissionStatus?
        /// The tag key and value pairs attached to the resource share.
        public let tags: [Tag]?
        /// The version of the permission described in this response.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, defaultVersion: Bool? = nil, featureSet: PermissionFeatureSet? = nil, isResourceTypeDefault: Bool? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, permission: String? = nil, permissionType: PermissionType? = nil, resourceType: String? = nil, status: PermissionStatus? = nil, tags: [Tag]? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.defaultVersion = defaultVersion
            self.featureSet = featureSet
            self.isResourceTypeDefault = isResourceTypeDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.permission = permission
            self.permissionType = permissionType
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case defaultVersion = "defaultVersion"
            case featureSet = "featureSet"
            case isResourceTypeDefault = "isResourceTypeDefault"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case permission = "permission"
            case permissionType = "permissionType"
            case resourceType = "resourceType"
            case status = "status"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct ResourceSharePermissionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the permission you want information about.
        public let arn: String?
        /// The date and time when the permission was created.
        public let creationTime: Date?
        /// Specifies whether the version of the managed permission used by this resource share is the default version for this managed permission.
        public let defaultVersion: Bool?
        /// Indicates what features are available for this resource share. This parameter can have one of the following values:    STANDARD – A resource share that supports all functionality. These resource shares are visible to all principals you share the resource share with.  You can modify these resource shares in RAM using the console or APIs. This resource share might  have been created by RAM, or it might have been CREATED_FROM_POLICY and then promoted.    CREATED_FROM_POLICY – The customer manually shared a resource by attaching a resource-based policy. That policy did not match any existing managed permissions, so RAM created this customer managed permission automatically on the customer's behalf based on the attached policy document. This type of resource share  is visible only to the Amazon Web Services account that created it. You can't modify it in  RAM unless you promote it. For more information,  see PromoteResourceShareCreatedFromPolicy.    PROMOTING_TO_STANDARD – This resource share was originally CREATED_FROM_POLICY, but the customer ran the PromoteResourceShareCreatedFromPolicy and that operation is still in progress. This value changes to STANDARD when complete.
        public let featureSet: PermissionFeatureSet?
        /// Specifies whether the managed permission associated with this resource share is the default managed permission for all resources of this resource type.
        public let isResourceTypeDefault: Bool?
        /// The date and time when the permission was last updated.
        public let lastUpdatedTime: Date?
        /// The name of this managed permission.
        public let name: String?
        /// The type of managed permission. This can be one of the following values:    AWS_MANAGED – Amazon Web Services created and manages this managed permission. You can associate it with your resource shares, but you can't modify it.    CUSTOMER_MANAGED – You, or another principal in your account created this managed permission. You can associate it with your resource shares and create new versions that have different permissions.
        public let permissionType: PermissionType?
        /// The type of resource to which this permission applies. This takes the form of: service-code:resource-code, and is case-insensitive. For example, an Amazon EC2 Subnet would be represented by the string ec2:subnet.
        public let resourceType: String?
        /// The current status of the permission.
        public let status: String?
        /// A list of the tag key value pairs currently attached to the permission.
        public let tags: [Tag]?
        /// The version of the permission associated with this resource share.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, defaultVersion: Bool? = nil, featureSet: PermissionFeatureSet? = nil, isResourceTypeDefault: Bool? = nil, lastUpdatedTime: Date? = nil, name: String? = nil, permissionType: PermissionType? = nil, resourceType: String? = nil, status: String? = nil, tags: [Tag]? = nil, version: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.defaultVersion = defaultVersion
            self.featureSet = featureSet
            self.isResourceTypeDefault = isResourceTypeDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.permissionType = permissionType
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case defaultVersion = "defaultVersion"
            case featureSet = "featureSet"
            case isResourceTypeDefault = "isResourceTypeDefault"
            case lastUpdatedTime = "lastUpdatedTime"
            case name = "name"
            case permissionType = "permissionType"
            case resourceType = "resourceType"
            case status = "status"
            case tags = "tags"
            case version = "version"
        }
    }

    public struct ServiceNameAndResourceType: AWSDecodableShape {
        /// Specifies the scope of visibility of resources of this type:    REGIONAL – The resource can be accessed only by using requests that target the Amazon Web Services Region in which the resource exists.    GLOBAL – The resource can be accessed from any Amazon Web Services Region.
        public let resourceRegionScope: ResourceRegionScope?
        /// The type of the resource. This takes the form of: service-code:resource-code, and is case-insensitive. For example, an Amazon EC2 Subnet would be represented by the string ec2:subnet.
        public let resourceType: String?
        /// The name of the Amazon Web Services service to which resources of this type belong.
        public let serviceName: String?

        @inlinable
        public init(resourceRegionScope: ResourceRegionScope? = nil, resourceType: String? = nil, serviceName: String? = nil) {
            self.resourceRegionScope = resourceRegionScope
            self.resourceType = resourceType
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case resourceRegionScope = "resourceRegionScope"
            case resourceType = "resourceType"
            case serviceName = "serviceName"
        }
    }

    public struct SetDefaultPermissionVersionRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Specifies the Amazon Resource Name (ARN) of the customer managed permission whose default version you want to change.
        public let permissionArn: String
        /// Specifies the version number that you want to designate as the default for customer managed permission. To see a list of all available version numbers, use ListPermissionVersions.
        public let permissionVersion: Int

        @inlinable
        public init(clientToken: String? = nil, permissionArn: String, permissionVersion: Int) {
            self.clientToken = clientToken
            self.permissionArn = permissionArn
            self.permissionVersion = permissionVersion
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case permissionArn = "permissionArn"
            case permissionVersion = "permissionVersion"
        }
    }

    public struct SetDefaultPermissionVersionResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// A boolean value that indicates whether the operation was successful.
        public let returnValue: Bool?

        @inlinable
        public init(clientToken: String? = nil, returnValue: Bool? = nil) {
            self.clientToken = clientToken
            self.returnValue = returnValue
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case returnValue = "returnValue"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key, or name, attached to the tag. Every tag must have a key. Key names are case sensitive.
        public let key: String?
        /// The string value attached to the tag. The value can be an empty string. Key values are case sensitive.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagFilter: AWSEncodableShape {
        /// The tag key. This must have a valid string value and can't be empty.
        public let tagKey: String?
        /// A list of zero or more tag values. If no values are provided, then the filter matches any tag with the specified key, regardless of its value.
        public let tagValues: [String]?

        @inlinable
        public init(tagKey: String? = nil, tagValues: [String]? = nil) {
            self.tagKey = tagKey
            self.tagValues = tagValues
        }

        private enum CodingKeys: String, CodingKey {
            case tagKey = "tagKey"
            case tagValues = "tagValues"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Specifies the Amazon Resource Name (ARN) of the managed permission that you want to add tags to. You must specify either resourceArn, or resourceShareArn, but not both.
        public let resourceArn: String?
        /// Specifies the Amazon Resource Name (ARN) of the resource share that you want to add tags to. You must specify either resourceShareArn, or resourceArn, but not both.
        public let resourceShareArn: String?
        /// A list of one or more tag key and value pairs. The tag key must be present and not be an empty string. The tag value must be present but can be an empty string.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String? = nil, resourceShareArn: String? = nil, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.resourceShareArn = resourceShareArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case resourceShareArn = "resourceShareArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Specifies the Amazon Resource Name (ARN) of the managed permission that you want to remove tags from. You must specify either resourceArn, or resourceShareArn, but not both.
        public let resourceArn: String?
        /// Specifies the Amazon Resource Name (ARN) of the resource share that you want to remove tags from. The tags are removed from the resource share, not the resources in the resource share. You must specify either resourceShareArn, or resourceArn, but not both.
        public let resourceShareArn: String?
        /// Specifies a list of one or more tag keys that you want to remove.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String? = nil, resourceShareArn: String? = nil, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.resourceShareArn = resourceShareArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case resourceShareArn = "resourceShareArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateResourceShareRequest: AWSEncodableShape {
        /// Specifies whether principals outside your organization in Organizations can be associated with a resource share.
        public let allowExternalPrincipals: Bool?
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other  parameters. We recommend that you use a UUID type of  value.. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with  different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// If specified, the new name that you want to attach to the resource share.
        public let name: String?
        /// Specifies the Amazon Resource Name (ARN) of the resource share that you want to modify.
        public let resourceShareArn: String

        @inlinable
        public init(allowExternalPrincipals: Bool? = nil, clientToken: String? = nil, name: String? = nil, resourceShareArn: String) {
            self.allowExternalPrincipals = allowExternalPrincipals
            self.clientToken = clientToken
            self.name = name
            self.resourceShareArn = resourceShareArn
        }

        private enum CodingKeys: String, CodingKey {
            case allowExternalPrincipals = "allowExternalPrincipals"
            case clientToken = "clientToken"
            case name = "name"
            case resourceShareArn = "resourceShareArn"
        }
    }

    public struct UpdateResourceShareResponse: AWSDecodableShape {
        /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other  parameters must also have the same values that you used in the first call.
        public let clientToken: String?
        /// Information about the resource share.
        public let resourceShare: ResourceShare?

        @inlinable
        public init(clientToken: String? = nil, resourceShare: ResourceShare? = nil) {
            self.clientToken = clientToken
            self.resourceShare = resourceShare
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceShare = "resourceShare"
        }
    }
}

// MARK: - Errors

/// Error enum for RAM
public struct RAMErrorType: AWSErrorType {
    enum Code: String {
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case invalidClientTokenException = "InvalidClientTokenException"
        case invalidMaxResultsException = "InvalidMaxResultsException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case invalidParameterException = "InvalidParameterException"
        case invalidPolicyException = "InvalidPolicyException"
        case invalidResourceTypeException = "InvalidResourceTypeException"
        case invalidStateTransitionException = "InvalidStateTransitionException"
        case malformedArnException = "MalformedArnException"
        case malformedPolicyTemplateException = "MalformedPolicyTemplateException"
        case missingRequiredParameterException = "MissingRequiredParameterException"
        case operationNotPermittedException = "OperationNotPermittedException"
        case permissionAlreadyExistsException = "PermissionAlreadyExistsException"
        case permissionLimitExceededException = "PermissionLimitExceededException"
        case permissionVersionsLimitExceededException = "PermissionVersionsLimitExceededException"
        case resourceArnNotFoundException = "ResourceArnNotFoundException"
        case resourceShareInvitationAlreadyAcceptedException = "ResourceShareInvitationAlreadyAcceptedException"
        case resourceShareInvitationAlreadyRejectedException = "ResourceShareInvitationAlreadyRejectedException"
        case resourceShareInvitationArnNotFoundException = "ResourceShareInvitationArnNotFoundException"
        case resourceShareInvitationExpiredException = "ResourceShareInvitationExpiredException"
        case resourceShareLimitExceededException = "ResourceShareLimitExceededException"
        case serverInternalException = "ServerInternalException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case tagLimitExceededException = "TagLimitExceededException"
        case tagPolicyViolationException = "TagPolicyViolationException"
        case throttlingException = "ThrottlingException"
        case unknownResourceException = "UnknownResourceException"
        case unmatchedPolicyPermissionException = "UnmatchedPolicyPermissionException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize RAM
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The operation failed because the client token input parameter matched one that was used with a previous call to the operation, but at least one of the other input parameters is different from the previous call.
    public static var idempotentParameterMismatchException: Self { .init(.idempotentParameterMismatchException) }
    /// The operation failed because the specified client token isn't valid.
    public static var invalidClientTokenException: Self { .init(.invalidClientTokenException) }
    /// The operation failed because the specified value for MaxResults isn't valid.
    public static var invalidMaxResultsException: Self { .init(.invalidMaxResultsException) }
    /// The operation failed because the specified value for NextToken isn't valid. You must specify a value you received in the NextToken response of a previous call to this operation.
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    /// The operation failed because a parameter you specified isn't valid.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The operation failed because a policy you specified isn't valid.
    public static var invalidPolicyException: Self { .init(.invalidPolicyException) }
    /// The operation failed because the specified resource type isn't valid.
    public static var invalidResourceTypeException: Self { .init(.invalidResourceTypeException) }
    /// The operation failed because the requested operation isn't valid for the resource share in its current state.
    public static var invalidStateTransitionException: Self { .init(.invalidStateTransitionException) }
    /// The operation failed because the specified Amazon Resource Name (ARN) has a format that isn't valid.
    public static var malformedArnException: Self { .init(.malformedArnException) }
    /// The operation failed because the policy template that you provided isn't valid.
    public static var malformedPolicyTemplateException: Self { .init(.malformedPolicyTemplateException) }
    /// The operation failed because a required input parameter is missing.
    public static var missingRequiredParameterException: Self { .init(.missingRequiredParameterException) }
    /// The operation failed because the requested operation isn't permitted.
    public static var operationNotPermittedException: Self { .init(.operationNotPermittedException) }
    /// The operation failed because a permission with the specified name already exists in the requested Amazon Web Services Region. Choose a different name.
    public static var permissionAlreadyExistsException: Self { .init(.permissionAlreadyExistsException) }
    /// The operation failed because it would exceed the maximum number of permissions you can create in each Amazon Web Services Region. To view the limits for your Amazon Web Services account, see the RAM page in the Service Quotas console.
    public static var permissionLimitExceededException: Self { .init(.permissionLimitExceededException) }
    /// The operation failed because it would exceed the limit for the number of versions you can have for a permission. To view the limits for your Amazon Web Services account, see the RAM page in the Service Quotas console.
    public static var permissionVersionsLimitExceededException: Self { .init(.permissionVersionsLimitExceededException) }
    /// The operation failed because the specified Amazon Resource Name (ARN) was not found.
    public static var resourceArnNotFoundException: Self { .init(.resourceArnNotFoundException) }
    /// The operation failed because the specified invitation was already accepted.
    public static var resourceShareInvitationAlreadyAcceptedException: Self { .init(.resourceShareInvitationAlreadyAcceptedException) }
    /// The operation failed because the specified invitation was already rejected.
    public static var resourceShareInvitationAlreadyRejectedException: Self { .init(.resourceShareInvitationAlreadyRejectedException) }
    /// The operation failed because the specified Amazon Resource Name (ARN) for an invitation was not found.
    public static var resourceShareInvitationArnNotFoundException: Self { .init(.resourceShareInvitationArnNotFoundException) }
    /// The operation failed because the specified invitation is past its expiration date and time.
    public static var resourceShareInvitationExpiredException: Self { .init(.resourceShareInvitationExpiredException) }
    /// The operation failed because it would exceed the limit for resource shares for your account. To view the limits for your Amazon Web Services account, see the RAM page in the Service Quotas console.
    public static var resourceShareLimitExceededException: Self { .init(.resourceShareLimitExceededException) }
    /// The operation failed because the service could not respond to the request due to an internal problem. Try again later.
    public static var serverInternalException: Self { .init(.serverInternalException) }
    /// The operation failed because the service isn't available. Try again later.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The operation failed because it would exceed the limit for tags for your Amazon Web Services account.
    public static var tagLimitExceededException: Self { .init(.tagLimitExceededException) }
    /// The operation failed because the specified tag key is a reserved word and can't be used.
    public static var tagPolicyViolationException: Self { .init(.tagPolicyViolationException) }
    /// The operation failed because it exceeded the rate at which you are allowed to perform this operation. Please try again later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The operation failed because a specified resource couldn't be found.
    public static var unknownResourceException: Self { .init(.unknownResourceException) }
    /// There isn't an existing managed permission defined in RAM that has the same IAM permissions as the resource-based policy attached to the resource. You should first run PromotePermissionCreatedFromPolicy to create that managed permission.
    public static var unmatchedPolicyPermissionException: Self { .init(.unmatchedPolicyPermissionException) }
}

extension RAMErrorType: Equatable {
    public static func == (lhs: RAMErrorType, rhs: RAMErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension RAMErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
