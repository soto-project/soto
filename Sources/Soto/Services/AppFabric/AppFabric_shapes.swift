//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension AppFabric {
    // MARK: Enums

    public enum AppAuthorizationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connected = "Connected"
        case connectionValidationFailed = "ConnectionValidationFailed"
        case pendingConnect = "PendingConnect"
        case tokenAutoRotationFailed = "TokenAutoRotationFailed"
        public var description: String { return self.rawValue }
    }

    public enum AuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case apiKey = "apiKey"
        case oauth2 = "oauth2"
        public var description: String { return self.rawValue }
    }

    public enum Format: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "json"
        case parquet = "parquet"
        public var description: String { return self.rawValue }
    }

    public enum IngestionDestinationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case failed = "Failed"
        public var description: String { return self.rawValue }
    }

    public enum IngestionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case enabled = "enabled"
        public var description: String { return self.rawValue }
    }

    public enum IngestionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auditLog = "auditLog"
        public var description: String { return self.rawValue }
    }

    public enum Persona: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case admin = "admin"
        case enduser = "endUser"
        public var description: String { return self.rawValue }
    }

    public enum ResultStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case expired = "EXPIRED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum Schema: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ocsf = "ocsf"
        case raw = "raw"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum Credential: AWSEncodableShape, Sendable {
        /// Contains API key credential information.
        case apiKeyCredential(ApiKeyCredential)
        /// Contains OAuth2 client credential information.
        case oauth2Credential(Oauth2Credential)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .apiKeyCredential(let value):
                try container.encode(value, forKey: .apiKeyCredential)
            case .oauth2Credential(let value):
                try container.encode(value, forKey: .oauth2Credential)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .apiKeyCredential(let value):
                try value.validate(name: "\(name).apiKeyCredential")
            case .oauth2Credential(let value):
                try value.validate(name: "\(name).oauth2Credential")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeyCredential = "apiKeyCredential"
            case oauth2Credential = "oauth2Credential"
        }
    }

    public enum Destination: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Contains information about an Amazon Kinesis Data Firehose delivery stream.
        case firehoseStream(FirehoseStream)
        /// Contains information about an Amazon S3 bucket.
        case s3Bucket(S3Bucket)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .firehoseStream:
                let value = try container.decode(FirehoseStream.self, forKey: .firehoseStream)
                self = .firehoseStream(value)
            case .s3Bucket:
                let value = try container.decode(S3Bucket.self, forKey: .s3Bucket)
                self = .s3Bucket(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .firehoseStream(let value):
                try container.encode(value, forKey: .firehoseStream)
            case .s3Bucket(let value):
                try container.encode(value, forKey: .s3Bucket)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .firehoseStream(let value):
                try value.validate(name: "\(name).firehoseStream")
            case .s3Bucket(let value):
                try value.validate(name: "\(name).s3Bucket")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case firehoseStream = "firehoseStream"
            case s3Bucket = "s3Bucket"
        }
    }

    // MARK: Shapes

    public struct ApiKeyCredential: AWSEncodableShape {
        /// An API key for an application.
        public let apiKey: String

        @inlinable
        public init(apiKey: String) {
            self.apiKey = apiKey
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKey, name: "apiKey", parent: name, max: 2048)
            try self.validate(self.apiKey, name: "apiKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
        }
    }

    public struct AppAuthorization: AWSDecodableShape {
        /// The name of the application.
        public let app: String
        /// The Amazon Resource Name (ARN) of the app authorization.
        public let appAuthorizationArn: String
        /// The Amazon Resource Name (ARN) of the app bundle for the app authorization.
        public let appBundleArn: String
        /// The authorization type.
        public let authType: AuthType
        /// The application URL for the OAuth flow.
        public let authUrl: String?
        /// The timestamp of when the app authorization was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user persona of the app authorization. This field should always be admin.
        public let persona: Persona?
        /// The state of the app authorization. The following states are possible:    PendingConnect: The initial state of the app authorization. The app authorization is created but not yet connected.    Connected: The app authorization is connected to the application, and is ready to be used.    ConnectionValidationFailed: The app authorization received a validation exception when trying to connect to the application. If the app authorization is in this state, you should verify the configured credentials and try to connect the app authorization again.    TokenAutoRotationFailed: AppFabric failed to refresh the access token. If the app authorization is in this state, you should try to reconnect the app authorization.
        public let status: AppAuthorizationStatus
        /// Contains information about an application tenant, such as the application display name and identifier.
        public let tenant: Tenant
        /// The timestamp of when the app authorization was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(app: String, appAuthorizationArn: String, appBundleArn: String, authType: AuthType, authUrl: String? = nil, createdAt: Date, persona: Persona? = nil, status: AppAuthorizationStatus, tenant: Tenant, updatedAt: Date) {
            self.app = app
            self.appAuthorizationArn = appAuthorizationArn
            self.appBundleArn = appBundleArn
            self.authType = authType
            self.authUrl = authUrl
            self.createdAt = createdAt
            self.persona = persona
            self.status = status
            self.tenant = tenant
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
            case appAuthorizationArn = "appAuthorizationArn"
            case appBundleArn = "appBundleArn"
            case authType = "authType"
            case authUrl = "authUrl"
            case createdAt = "createdAt"
            case persona = "persona"
            case status = "status"
            case tenant = "tenant"
            case updatedAt = "updatedAt"
        }
    }

    public struct AppAuthorizationSummary: AWSDecodableShape {
        /// The name of the application.
        public let app: String
        /// The Amazon Resource Name (ARN) of the app authorization.
        public let appAuthorizationArn: String
        /// The Amazon Resource Name (ARN) of the app bundle for the app authorization.
        public let appBundleArn: String
        /// The state of the app authorization. The following states are possible:    PendingConnect: The initial state of the app authorization. The app authorization is created but not yet connected.    Connected: The app authorization is connected to the application, and is ready to be used.    ConnectionValidationFailed: The app authorization received a validation exception when trying to connect to the application. If the app authorization is in this state, you should verify the configured credentials and try to connect the app authorization again.    TokenAutoRotationFailed: AppFabric failed to refresh the access token. If the app authorization is in this state, you should try to reconnect the app authorization.
        public let status: AppAuthorizationStatus
        /// Contains information about an application tenant, such as the application display name and identifier.
        public let tenant: Tenant
        /// Timestamp for when the app authorization was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(app: String, appAuthorizationArn: String, appBundleArn: String, status: AppAuthorizationStatus, tenant: Tenant, updatedAt: Date) {
            self.app = app
            self.appAuthorizationArn = appAuthorizationArn
            self.appBundleArn = appBundleArn
            self.status = status
            self.tenant = tenant
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
            case appAuthorizationArn = "appAuthorizationArn"
            case appBundleArn = "appBundleArn"
            case status = "status"
            case tenant = "tenant"
            case updatedAt = "updatedAt"
        }
    }

    public struct AppBundle: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the app bundle.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key used to encrypt the application data.
        public let customerManagedKeyArn: String?

        @inlinable
        public init(arn: String, customerManagedKeyArn: String? = nil) {
            self.arn = arn
            self.customerManagedKeyArn = customerManagedKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case customerManagedKeyArn = "customerManagedKeyArn"
        }
    }

    public struct AppBundleSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the app bundle.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct AuditLogDestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about an audit log destination.
        public let destination: Destination

        @inlinable
        public init(destination: Destination) {
            self.destination = destination
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
        }
    }

    public struct AuditLogProcessingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The format in which the audit logs need to be formatted.
        public let format: Format
        /// The event schema in which the audit logs need to be formatted.
        public let schema: Schema

        @inlinable
        public init(format: Format, schema: Schema) {
            self.format = format
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case schema = "schema"
        }
    }

    public struct AuthRequest: AWSEncodableShape {
        /// The authorization code returned by the application after permission is granted in the application OAuth page (after clicking on the AuthURL).
        public let code: String
        /// The redirect URL that is specified in the AuthURL and the application client.
        public let redirectUri: String

        @inlinable
        public init(code: String, redirectUri: String) {
            self.code = code
            self.redirectUri = redirectUri
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, max: 2048)
            try self.validate(self.code, name: "code", parent: name, min: 1)
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, max: 1024)
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, pattern: "^https://[-a-zA-Z0-9-._~:/?#@!$&'()*+,;=]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case redirectUri = "redirectUri"
        }
    }

    public struct BatchGetUserAccessTasksRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The tasks IDs to use for the request.
        public let taskIdList: [String]

        @inlinable
        public init(appBundleIdentifier: String, taskIdList: [String]) {
            self.appBundleIdentifier = appBundleIdentifier
            self.taskIdList = taskIdList
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.taskIdList.forEach {
                try validate($0, name: "taskIdList[]", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            }
            try self.validate(self.taskIdList, name: "taskIdList", parent: name, max: 50)
            try self.validate(self.taskIdList, name: "taskIdList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appBundleIdentifier = "appBundleIdentifier"
            case taskIdList = "taskIdList"
        }
    }

    public struct BatchGetUserAccessTasksResponse: AWSDecodableShape {
        /// Contains a list of user access results.
        public let userAccessResultsList: [UserAccessResultItem]?

        @inlinable
        public init(userAccessResultsList: [UserAccessResultItem]? = nil) {
            self.userAccessResultsList = userAccessResultsList
        }

        private enum CodingKeys: String, CodingKey {
            case userAccessResultsList = "userAccessResultsList"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The resource ID.
        public let resourceId: String
        /// The resource type.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ConnectAppAuthorizationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
        public let appAuthorizationIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle that contains the app authorization to use for the request.
        public let appBundleIdentifier: String
        /// Contains OAuth2 authorization information. This is required if the app authorization for the request is configured with an OAuth2 (oauth2) authorization type.
        public let authRequest: AuthRequest?

        @inlinable
        public init(appAuthorizationIdentifier: String, appBundleIdentifier: String, authRequest: AuthRequest? = nil) {
            self.appAuthorizationIdentifier = appAuthorizationIdentifier
            self.appBundleIdentifier = appBundleIdentifier
            self.authRequest = authRequest
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appAuthorizationIdentifier, key: "appAuthorizationIdentifier")
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            try container.encodeIfPresent(self.authRequest, forKey: .authRequest)
        }

        public func validate(name: String) throws {
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, max: 1011)
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, min: 1)
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.authRequest?.validate(name: "\(name).authRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case authRequest = "authRequest"
        }
    }

    public struct ConnectAppAuthorizationResponse: AWSDecodableShape {
        /// Contains a summary of the app authorization.
        public let appAuthorizationSummary: AppAuthorizationSummary

        @inlinable
        public init(appAuthorizationSummary: AppAuthorizationSummary) {
            self.appAuthorizationSummary = appAuthorizationSummary
        }

        private enum CodingKeys: String, CodingKey {
            case appAuthorizationSummary = "appAuthorizationSummary"
        }
    }

    public struct CreateAppAuthorizationRequest: AWSEncodableShape {
        /// The name of the application. Valid values are:    SLACK     ASANA     JIRA     M365     M365AUDITLOGS     ZOOM     ZENDESK     OKTA     GOOGLE     DROPBOX     SMARTSHEET     CISCO
        public let app: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The authorization type for the app authorization.
        public let authType: AuthType
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Contains credentials for the application, such as an API key or OAuth2 client ID and secret. Specify credentials that match the authorization type for your request. For example, if the authorization type for your request is OAuth2 (oauth2), then you should provide only the OAuth2 credentials.
        public let credential: Credential
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [Tag]?
        /// Contains information about an application tenant, such as the application display name and identifier.
        public let tenant: Tenant

        @inlinable
        public init(app: String, appBundleIdentifier: String, authType: AuthType, clientToken: String? = CreateAppAuthorizationRequest.idempotencyToken(), credential: Credential, tags: [Tag]? = nil, tenant: Tenant) {
            self.app = app
            self.appBundleIdentifier = appBundleIdentifier
            self.authType = authType
            self.clientToken = clientToken
            self.credential = credential
            self.tags = tags
            self.tenant = tenant
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.app, forKey: .app)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            try container.encode(self.authType, forKey: .authType)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.credential, forKey: .credential)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.tenant, forKey: .tenant)
        }

        public func validate(name: String) throws {
            try self.validate(self.app, name: "app", parent: name, max: 255)
            try self.validate(self.app, name: "app", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.credential.validate(name: "\(name).credential")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.tenant.validate(name: "\(name).tenant")
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
            case authType = "authType"
            case clientToken = "clientToken"
            case credential = "credential"
            case tags = "tags"
            case tenant = "tenant"
        }
    }

    public struct CreateAppAuthorizationResponse: AWSDecodableShape {
        /// Contains information about an app authorization.
        public let appAuthorization: AppAuthorization

        @inlinable
        public init(appAuthorization: AppAuthorization) {
            self.appAuthorization = appAuthorization
        }

        private enum CodingKeys: String, CodingKey {
            case appAuthorization = "appAuthorization"
        }
    }

    public struct CreateAppBundleRequest: AWSEncodableShape {
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key to use to encrypt the application data. If this is not specified, an Amazon Web Services owned key is used for encryption.
        public let customerManagedKeyIdentifier: String?
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateAppBundleRequest.idempotencyToken(), customerManagedKeyIdentifier: String? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.customerManagedKeyIdentifier = customerManagedKeyIdentifier
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.customerManagedKeyIdentifier, name: "customerManagedKeyIdentifier", parent: name, max: 1011)
            try self.validate(self.customerManagedKeyIdentifier, name: "customerManagedKeyIdentifier", parent: name, min: 1)
            try self.validate(self.customerManagedKeyIdentifier, name: "customerManagedKeyIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case customerManagedKeyIdentifier = "customerManagedKeyIdentifier"
            case tags = "tags"
        }
    }

    public struct CreateAppBundleResponse: AWSDecodableShape {
        /// Contains information about an app bundle.
        public let appBundle: AppBundle

        @inlinable
        public init(appBundle: AppBundle) {
            self.appBundle = appBundle
        }

        private enum CodingKeys: String, CodingKey {
            case appBundle = "appBundle"
        }
    }

    public struct CreateIngestionDestinationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// Contains information about the destination of ingested data.
        public let destinationConfiguration: DestinationConfiguration
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
        public let ingestionIdentifier: String
        /// Contains information about how ingested data is processed.
        public let processingConfiguration: ProcessingConfiguration
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [Tag]?

        @inlinable
        public init(appBundleIdentifier: String, clientToken: String? = CreateIngestionDestinationRequest.idempotencyToken(), destinationConfiguration: DestinationConfiguration, ingestionIdentifier: String, processingConfiguration: ProcessingConfiguration, tags: [Tag]? = nil) {
            self.appBundleIdentifier = appBundleIdentifier
            self.clientToken = clientToken
            self.destinationConfiguration = destinationConfiguration
            self.ingestionIdentifier = ingestionIdentifier
            self.processingConfiguration = processingConfiguration
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.destinationConfiguration, forKey: .destinationConfiguration)
            request.encodePath(self.ingestionIdentifier, key: "ingestionIdentifier")
            try container.encode(self.processingConfiguration, forKey: .processingConfiguration)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.destinationConfiguration.validate(name: "\(name).destinationConfiguration")
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case destinationConfiguration = "destinationConfiguration"
            case processingConfiguration = "processingConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateIngestionDestinationResponse: AWSDecodableShape {
        /// Contains information about an ingestion destination.
        public let ingestionDestination: IngestionDestination

        @inlinable
        public init(ingestionDestination: IngestionDestination) {
            self.ingestionDestination = ingestionDestination
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionDestination = "ingestionDestination"
        }
    }

    public struct CreateIngestionRequest: AWSEncodableShape {
        /// The name of the application. Valid values are:    SLACK     ASANA     JIRA     M365     M365AUDITLOGS     ZOOM     ZENDESK     OKTA     GOOGLE     DROPBOX     SMARTSHEET     CISCO
        public let app: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a UUID type of value. If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
        public let clientToken: String?
        /// The ingestion type.
        public let ingestionType: IngestionType
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [Tag]?
        /// The ID of the application tenant.
        public let tenantId: String

        @inlinable
        public init(app: String, appBundleIdentifier: String, clientToken: String? = CreateIngestionRequest.idempotencyToken(), ingestionType: IngestionType, tags: [Tag]? = nil, tenantId: String) {
            self.app = app
            self.appBundleIdentifier = appBundleIdentifier
            self.clientToken = clientToken
            self.ingestionType = ingestionType
            self.tags = tags
            self.tenantId = tenantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.app, forKey: .app)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.ingestionType, forKey: .ingestionType)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.tenantId, forKey: .tenantId)
        }

        public func validate(name: String) throws {
            try self.validate(self.app, name: "app", parent: name, max: 255)
            try self.validate(self.app, name: "app", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tenantId, name: "tenantId", parent: name, max: 1024)
            try self.validate(self.tenantId, name: "tenantId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
            case clientToken = "clientToken"
            case ingestionType = "ingestionType"
            case tags = "tags"
            case tenantId = "tenantId"
        }
    }

    public struct CreateIngestionResponse: AWSDecodableShape {
        /// Contains information about an ingestion.
        public let ingestion: Ingestion

        @inlinable
        public init(ingestion: Ingestion) {
            self.ingestion = ingestion
        }

        private enum CodingKeys: String, CodingKey {
            case ingestion = "ingestion"
        }
    }

    public struct DeleteAppAuthorizationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
        public let appAuthorizationIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String

        @inlinable
        public init(appAuthorizationIdentifier: String, appBundleIdentifier: String) {
            self.appAuthorizationIdentifier = appAuthorizationIdentifier
            self.appBundleIdentifier = appBundleIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appAuthorizationIdentifier, key: "appAuthorizationIdentifier")
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, max: 1011)
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, min: 1)
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAppAuthorizationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAppBundleRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the app bundle that needs to be deleted.
        public let appBundleIdentifier: String

        @inlinable
        public init(appBundleIdentifier: String) {
            self.appBundleIdentifier = appBundleIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAppBundleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIngestionDestinationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
        public let ingestionDestinationIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
        public let ingestionIdentifier: String

        @inlinable
        public init(appBundleIdentifier: String, ingestionDestinationIdentifier: String, ingestionIdentifier: String) {
            self.appBundleIdentifier = appBundleIdentifier
            self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
            self.ingestionIdentifier = ingestionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            request.encodePath(self.ingestionDestinationIdentifier, key: "ingestionDestinationIdentifier")
            request.encodePath(self.ingestionIdentifier, key: "ingestionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.ingestionDestinationIdentifier, name: "ingestionDestinationIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionDestinationIdentifier, name: "ingestionDestinationIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionDestinationIdentifier, name: "ingestionDestinationIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIngestionDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIngestionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
        public let ingestionIdentifier: String

        @inlinable
        public init(appBundleIdentifier: String, ingestionIdentifier: String) {
            self.appBundleIdentifier = appBundleIdentifier
            self.ingestionIdentifier = ingestionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            request.encodePath(self.ingestionIdentifier, key: "ingestionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIngestionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct FirehoseStream: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon Kinesis Data Firehose delivery stream.
        public let streamName: String

        @inlinable
        public init(streamName: String) {
            self.streamName = streamName
        }

        public func validate(name: String) throws {
            try self.validate(self.streamName, name: "streamName", parent: name, max: 64)
            try self.validate(self.streamName, name: "streamName", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case streamName = "streamName"
        }
    }

    public struct GetAppAuthorizationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
        public let appAuthorizationIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String

        @inlinable
        public init(appAuthorizationIdentifier: String, appBundleIdentifier: String) {
            self.appAuthorizationIdentifier = appAuthorizationIdentifier
            self.appBundleIdentifier = appBundleIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appAuthorizationIdentifier, key: "appAuthorizationIdentifier")
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, max: 1011)
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, min: 1)
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAppAuthorizationResponse: AWSDecodableShape {
        /// Contains information about an app authorization.
        public let appAuthorization: AppAuthorization

        @inlinable
        public init(appAuthorization: AppAuthorization) {
            self.appAuthorization = appAuthorization
        }

        private enum CodingKeys: String, CodingKey {
            case appAuthorization = "appAuthorization"
        }
    }

    public struct GetAppBundleRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String

        @inlinable
        public init(appBundleIdentifier: String) {
            self.appBundleIdentifier = appBundleIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAppBundleResponse: AWSDecodableShape {
        /// Contains information about an app bundle.
        public let appBundle: AppBundle

        @inlinable
        public init(appBundle: AppBundle) {
            self.appBundle = appBundle
        }

        private enum CodingKeys: String, CodingKey {
            case appBundle = "appBundle"
        }
    }

    public struct GetIngestionDestinationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
        public let ingestionDestinationIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
        public let ingestionIdentifier: String

        @inlinable
        public init(appBundleIdentifier: String, ingestionDestinationIdentifier: String, ingestionIdentifier: String) {
            self.appBundleIdentifier = appBundleIdentifier
            self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
            self.ingestionIdentifier = ingestionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            request.encodePath(self.ingestionDestinationIdentifier, key: "ingestionDestinationIdentifier")
            request.encodePath(self.ingestionIdentifier, key: "ingestionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.ingestionDestinationIdentifier, name: "ingestionDestinationIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionDestinationIdentifier, name: "ingestionDestinationIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionDestinationIdentifier, name: "ingestionDestinationIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIngestionDestinationResponse: AWSDecodableShape {
        /// Contains information about an ingestion destination.
        public let ingestionDestination: IngestionDestination

        @inlinable
        public init(ingestionDestination: IngestionDestination) {
            self.ingestionDestination = ingestionDestination
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionDestination = "ingestionDestination"
        }
    }

    public struct GetIngestionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
        public let ingestionIdentifier: String

        @inlinable
        public init(appBundleIdentifier: String, ingestionIdentifier: String) {
            self.appBundleIdentifier = appBundleIdentifier
            self.ingestionIdentifier = ingestionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            request.encodePath(self.ingestionIdentifier, key: "ingestionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIngestionResponse: AWSDecodableShape {
        /// Contains information about an ingestion.
        public let ingestion: Ingestion

        @inlinable
        public init(ingestion: Ingestion) {
            self.ingestion = ingestion
        }

        private enum CodingKeys: String, CodingKey {
            case ingestion = "ingestion"
        }
    }

    public struct Ingestion: AWSDecodableShape {
        /// The name of the application.
        public let app: String
        /// The Amazon Resource Name (ARN) of the app bundle for the ingestion.
        public let appBundleArn: String
        /// The Amazon Resource Name (ARN) of the ingestion.
        public let arn: String
        /// The timestamp of when the ingestion was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The type of the ingestion.
        public let ingestionType: IngestionType
        /// The status of the ingestion.
        public let state: IngestionState
        /// The ID of the application tenant.
        public let tenantId: String
        /// The timestamp of when the ingestion was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(app: String, appBundleArn: String, arn: String, createdAt: Date, ingestionType: IngestionType, state: IngestionState, tenantId: String, updatedAt: Date) {
            self.app = app
            self.appBundleArn = appBundleArn
            self.arn = arn
            self.createdAt = createdAt
            self.ingestionType = ingestionType
            self.state = state
            self.tenantId = tenantId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
            case appBundleArn = "appBundleArn"
            case arn = "arn"
            case createdAt = "createdAt"
            case ingestionType = "ingestionType"
            case state = "state"
            case tenantId = "tenantId"
            case updatedAt = "updatedAt"
        }
    }

    public struct IngestionDestination: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the ingestion destination.
        public let arn: String
        /// The timestamp of when the ingestion destination was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// Contains information about the destination of ingested data.
        public let destinationConfiguration: DestinationConfiguration
        /// The Amazon Resource Name (ARN) of the ingestion.
        public let ingestionArn: String
        /// Contains information about how ingested data is processed.
        public let processingConfiguration: ProcessingConfiguration
        /// The state of the ingestion destination. The following states are possible:    Active: The ingestion destination is active and is ready to be used.    Failed: The ingestion destination has failed. If the ingestion destination is in this state, you should verify the ingestion destination configuration and try again.
        public let status: IngestionDestinationStatus?
        /// The reason for the current status of the ingestion destination. Only present when the status of ingestion destination is Failed.
        public let statusReason: String?
        /// The timestamp of when the ingestion destination was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String, createdAt: Date? = nil, destinationConfiguration: DestinationConfiguration, ingestionArn: String, processingConfiguration: ProcessingConfiguration, status: IngestionDestinationStatus? = nil, statusReason: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationConfiguration = destinationConfiguration
            self.ingestionArn = ingestionArn
            self.processingConfiguration = processingConfiguration
            self.status = status
            self.statusReason = statusReason
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case destinationConfiguration = "destinationConfiguration"
            case ingestionArn = "ingestionArn"
            case processingConfiguration = "processingConfiguration"
            case status = "status"
            case statusReason = "statusReason"
            case updatedAt = "updatedAt"
        }
    }

    public struct IngestionDestinationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the ingestion destination.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct IngestionSummary: AWSDecodableShape {
        /// The name of the application.
        public let app: String
        /// The Amazon Resource Name (ARN) of the ingestion.
        public let arn: String
        /// The status of the ingestion.
        public let state: IngestionState
        /// The ID of the application tenant.
        public let tenantId: String

        @inlinable
        public init(app: String, arn: String, state: IngestionState, tenantId: String) {
            self.app = app
            self.arn = arn
            self.state = state
            self.tenantId = tenantId
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
            case arn = "arn"
            case state = "state"
            case tenantId = "tenantId"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// The period of time after which you should retry your request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ListAppAuthorizationsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(appBundleIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appBundleIdentifier = appBundleIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAppAuthorizationsResponse: AWSDecodableShape {
        /// Contains a list of app authorization summaries.
        public let appAuthorizationSummaryList: [AppAuthorizationSummary]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(appAuthorizationSummaryList: [AppAuthorizationSummary], nextToken: String? = nil) {
            self.appAuthorizationSummaryList = appAuthorizationSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case appAuthorizationSummaryList = "appAuthorizationSummaryList"
            case nextToken = "nextToken"
        }
    }

    public struct ListAppBundlesRequest: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAppBundlesResponse: AWSDecodableShape {
        /// Contains a list of app bundle summaries.
        public let appBundleSummaryList: [AppBundleSummary]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(appBundleSummaryList: [AppBundleSummary], nextToken: String? = nil) {
            self.appBundleSummaryList = appBundleSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case appBundleSummaryList = "appBundleSummaryList"
            case nextToken = "nextToken"
        }
    }

    public struct ListIngestionDestinationsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
        public let ingestionIdentifier: String
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(appBundleIdentifier: String, ingestionIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appBundleIdentifier = appBundleIdentifier
            self.ingestionIdentifier = ingestionIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            request.encodePath(self.ingestionIdentifier, key: "ingestionIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIngestionDestinationsResponse: AWSDecodableShape {
        /// Contains a list of ingestion destination summaries.
        public let ingestionDestinations: [IngestionDestinationSummary]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(ingestionDestinations: [IngestionDestinationSummary], nextToken: String? = nil) {
            self.ingestionDestinations = ingestionDestinations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionDestinations = "ingestionDestinations"
            case nextToken = "nextToken"
        }
    }

    public struct ListIngestionsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(appBundleIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appBundleIdentifier = appBundleIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIngestionsResponse: AWSDecodableShape {
        /// Contains a list of ingestion summaries.
        public let ingestions: [IngestionSummary]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        @inlinable
        public init(ingestions: [IngestionSummary], nextToken: String? = nil) {
            self.ingestions = ingestions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ingestions = "ingestions"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Oauth2Credential: AWSEncodableShape {
        /// The client ID of the client application.
        public let clientId: String
        /// The client secret of the client application.
        public let clientSecret: String

        @inlinable
        public init(clientId: String, clientSecret: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, max: 2048)
            try self.validate(self.clientId, name: "clientId", parent: name, min: 1)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, max: 2048)
            try self.validate(self.clientSecret, name: "clientSecret", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The resource ID.
        public let resourceId: String
        /// The resource type.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct S3Bucket: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon S3 bucket.
        public let bucketName: String
        /// The object key to use.
        public let prefix: String?

        @inlinable
        public init(bucketName: String, prefix: String? = nil) {
            self.bucketName = bucketName
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.prefix, name: "prefix", parent: name, max: 120)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case prefix = "prefix"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The code for the quota exceeded.
        public let quotaCode: String
        /// The resource ID.
        public let resourceId: String
        /// The resource type.
        public let resourceType: String
        /// The code of the service.
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String, resourceType: String, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct StartIngestionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
        public let ingestionIdentifier: String

        @inlinable
        public init(appBundleIdentifier: String, ingestionIdentifier: String) {
            self.appBundleIdentifier = appBundleIdentifier
            self.ingestionIdentifier = ingestionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            request.encodePath(self.ingestionIdentifier, key: "ingestionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartIngestionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartUserAccessTasksRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The email address of the target user.
        public let email: String

        @inlinable
        public init(appBundleIdentifier: String, email: String) {
            self.appBundleIdentifier = appBundleIdentifier
            self.email = email
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.email, name: "email", parent: name, max: 320)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[a-zA-Z0-9.!#$%&*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case appBundleIdentifier = "appBundleIdentifier"
            case email = "email"
        }
    }

    public struct StartUserAccessTasksResponse: AWSDecodableShape {
        /// Contains a list of user access task information.
        public let userAccessTasksList: [UserAccessTaskItem]?

        @inlinable
        public init(userAccessTasksList: [UserAccessTaskItem]? = nil) {
            self.userAccessTasksList = userAccessTasksList
        }

        private enum CodingKeys: String, CodingKey {
            case userAccessTasksList = "userAccessTasksList"
        }
    }

    public struct StopIngestionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
        public let ingestionIdentifier: String

        @inlinable
        public init(appBundleIdentifier: String, ingestionIdentifier: String) {
            self.appBundleIdentifier = appBundleIdentifier
            self.ingestionIdentifier = ingestionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            request.encodePath(self.ingestionIdentifier, key: "ingestionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopIngestionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Tag key.
        public let key: String
        /// Tag value.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to tag.
        public let resourceArn: String
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TaskError: AWSDecodableShape {
        /// The code of the error.
        public let errorCode: String?
        /// The message of the error.
        public let errorMessage: String?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct Tenant: AWSEncodableShape & AWSDecodableShape {
        /// The display name of the tenant.
        public let tenantDisplayName: String
        /// The ID of the application tenant.
        public let tenantIdentifier: String

        @inlinable
        public init(tenantDisplayName: String, tenantIdentifier: String) {
            self.tenantDisplayName = tenantDisplayName
            self.tenantIdentifier = tenantIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.tenantDisplayName, name: "tenantDisplayName", parent: name, max: 2048)
            try self.validate(self.tenantDisplayName, name: "tenantDisplayName", parent: name, min: 1)
            try self.validate(self.tenantIdentifier, name: "tenantIdentifier", parent: name, max: 1024)
            try self.validate(self.tenantIdentifier, name: "tenantIdentifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tenantDisplayName = "tenantDisplayName"
            case tenantIdentifier = "tenantIdentifier"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The code for the quota exceeded.
        public let quotaCode: String?
        /// The period of time after which you should retry your request.
        public let retryAfterSeconds: Int?
        /// The code of the service.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to untag.
        public let resourceArn: String
        /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAppAuthorizationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
        public let appAuthorizationIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// Contains credentials for the application, such as an API key or OAuth2 client ID and secret. Specify credentials that match the authorization type of the app authorization to update. For example, if the authorization type of the app authorization is OAuth2 (oauth2), then you should provide only the OAuth2 credentials.
        public let credential: Credential?
        /// Contains information about an application tenant, such as the application display name and identifier.
        public let tenant: Tenant?

        @inlinable
        public init(appAuthorizationIdentifier: String, appBundleIdentifier: String, credential: Credential? = nil, tenant: Tenant? = nil) {
            self.appAuthorizationIdentifier = appAuthorizationIdentifier
            self.appBundleIdentifier = appBundleIdentifier
            self.credential = credential
            self.tenant = tenant
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appAuthorizationIdentifier, key: "appAuthorizationIdentifier")
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            try container.encodeIfPresent(self.credential, forKey: .credential)
            try container.encodeIfPresent(self.tenant, forKey: .tenant)
        }

        public func validate(name: String) throws {
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, max: 1011)
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, min: 1)
            try self.validate(self.appAuthorizationIdentifier, name: "appAuthorizationIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.credential?.validate(name: "\(name).credential")
            try self.tenant?.validate(name: "\(name).tenant")
        }

        private enum CodingKeys: String, CodingKey {
            case credential = "credential"
            case tenant = "tenant"
        }
    }

    public struct UpdateAppAuthorizationResponse: AWSDecodableShape {
        /// Contains information about an app authorization.
        public let appAuthorization: AppAuthorization

        @inlinable
        public init(appAuthorization: AppAuthorization) {
            self.appAuthorization = appAuthorization
        }

        private enum CodingKeys: String, CodingKey {
            case appAuthorization = "appAuthorization"
        }
    }

    public struct UpdateIngestionDestinationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
        public let appBundleIdentifier: String
        /// Contains information about the destination of ingested data.
        public let destinationConfiguration: DestinationConfiguration
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
        public let ingestionDestinationIdentifier: String
        /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
        public let ingestionIdentifier: String

        @inlinable
        public init(appBundleIdentifier: String, destinationConfiguration: DestinationConfiguration, ingestionDestinationIdentifier: String, ingestionIdentifier: String) {
            self.appBundleIdentifier = appBundleIdentifier
            self.destinationConfiguration = destinationConfiguration
            self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
            self.ingestionIdentifier = ingestionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appBundleIdentifier, key: "appBundleIdentifier")
            try container.encode(self.destinationConfiguration, forKey: .destinationConfiguration)
            request.encodePath(self.ingestionDestinationIdentifier, key: "ingestionDestinationIdentifier")
            request.encodePath(self.ingestionIdentifier, key: "ingestionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, max: 1011)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, min: 1)
            try self.validate(self.appBundleIdentifier, name: "appBundleIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.destinationConfiguration.validate(name: "\(name).destinationConfiguration")
            try self.validate(self.ingestionDestinationIdentifier, name: "ingestionDestinationIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionDestinationIdentifier, name: "ingestionDestinationIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionDestinationIdentifier, name: "ingestionDestinationIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, max: 1011)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, min: 1)
            try self.validate(self.ingestionIdentifier, name: "ingestionIdentifier", parent: name, pattern: "^arn:.+$|^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationConfiguration = "destinationConfiguration"
        }
    }

    public struct UpdateIngestionDestinationResponse: AWSDecodableShape {
        /// Contains information about an ingestion destination.
        public let ingestionDestination: IngestionDestination

        @inlinable
        public init(ingestionDestination: IngestionDestination) {
            self.ingestionDestination = ingestionDestination
        }

        private enum CodingKeys: String, CodingKey {
            case ingestionDestination = "ingestionDestination"
        }
    }

    public struct UserAccessResultItem: AWSDecodableShape {
        /// The name of the application.
        public let app: String?
        /// The email address of the target user.
        public let email: String?
        /// The status of the user access result item. The following states are possible:    IN_PROGRESS: The user access task is in progress.    COMPLETED: The user access task completed successfully.    FAILED: The user access task failed.    EXPIRED: The user access task expired.
        public let resultStatus: ResultStatus?
        /// Contains information about an error returned from a user access task.
        public let taskError: TaskError?
        /// The unique ID of the task.
        public let taskId: String?
        /// The display name of the tenant.
        public let tenantDisplayName: String?
        /// The ID of the application tenant.
        public let tenantId: String?
        /// The first name of the user.
        public let userFirstName: String?
        /// The full name of the user.
        public let userFullName: String?
        /// The unique ID of user.
        public let userId: String?
        /// The last name of the user.
        public let userLastName: String?
        /// The status of the user returned by the application.
        public let userStatus: String?

        @inlinable
        public init(app: String? = nil, email: String? = nil, resultStatus: ResultStatus? = nil, taskError: TaskError? = nil, taskId: String? = nil, tenantDisplayName: String? = nil, tenantId: String? = nil, userFirstName: String? = nil, userFullName: String? = nil, userId: String? = nil, userLastName: String? = nil, userStatus: String? = nil) {
            self.app = app
            self.email = email
            self.resultStatus = resultStatus
            self.taskError = taskError
            self.taskId = taskId
            self.tenantDisplayName = tenantDisplayName
            self.tenantId = tenantId
            self.userFirstName = userFirstName
            self.userFullName = userFullName
            self.userId = userId
            self.userLastName = userLastName
            self.userStatus = userStatus
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
            case email = "email"
            case resultStatus = "resultStatus"
            case taskError = "taskError"
            case taskId = "taskId"
            case tenantDisplayName = "tenantDisplayName"
            case tenantId = "tenantId"
            case userFirstName = "userFirstName"
            case userFullName = "userFullName"
            case userId = "userId"
            case userLastName = "userLastName"
            case userStatus = "userStatus"
        }
    }

    public struct UserAccessTaskItem: AWSDecodableShape {
        /// The name of the application.
        public let app: String
        /// Error from the task, if any.
        public let error: TaskError?
        /// The unique ID of the task.
        public let taskId: String?
        /// The ID of the application tenant.
        public let tenantId: String

        @inlinable
        public init(app: String, error: TaskError? = nil, taskId: String? = nil, tenantId: String) {
            self.app = app
            self.error = error
            self.taskId = taskId
            self.tenantId = tenantId
        }

        private enum CodingKeys: String, CodingKey {
            case app = "app"
            case error = "error"
            case taskId = "taskId"
            case tenantId = "tenantId"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The field list.
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        /// The reason for the exception.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message about the validation exception.
        public let message: String
        /// The field name where the invalid entry was detected.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct DestinationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about an audit log destination configuration.
        public let auditLog: AuditLogDestinationConfiguration?

        @inlinable
        public init(auditLog: AuditLogDestinationConfiguration? = nil) {
            self.auditLog = auditLog
        }

        public func validate(name: String) throws {
            try self.auditLog?.validate(name: "\(name).auditLog")
        }

        private enum CodingKeys: String, CodingKey {
            case auditLog = "auditLog"
        }
    }

    public struct ProcessingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about an audit log processing configuration.
        public let auditLog: AuditLogProcessingConfiguration?

        @inlinable
        public init(auditLog: AuditLogProcessingConfiguration? = nil) {
            self.auditLog = auditLog
        }

        private enum CodingKeys: String, CodingKey {
            case auditLog = "auditLog"
        }
    }
}

// MARK: - Errors

/// Error enum for AppFabric
public struct AppFabricErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AppFabric
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You are not authorized to perform this operation.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request has created a conflict. Check the request parameters and try again.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request processing has failed because of an unknown error, exception, or failure with an internal server.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request exceeds a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request rate exceeds the limit.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request has invalid or missing parameters.
    public static var validationException: Self { .init(.validationException) }
}

extension AppFabricErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": AppFabric.ConflictException.self,
        "InternalServerException": AppFabric.InternalServerException.self,
        "ResourceNotFoundException": AppFabric.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": AppFabric.ServiceQuotaExceededException.self,
        "ThrottlingException": AppFabric.ThrottlingException.self,
        "ValidationException": AppFabric.ValidationException.self
    ]
}

extension AppFabricErrorType: Equatable {
    public static func == (lhs: AppFabricErrorType, rhs: AppFabricErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AppFabricErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
