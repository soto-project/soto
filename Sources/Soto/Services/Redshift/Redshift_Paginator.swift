//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension Redshift {
    ///  Returns an array of ClusterDbRevision objects.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClusterDbRevisionsPaginator<Result>(
        _ input: DescribeClusterDbRevisionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ClusterDbRevisionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClusterDbRevisions,
            inputKey: \DescribeClusterDbRevisionsMessage.marker,
            outputKey: \ClusterDbRevisionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClusterDbRevisionsPaginator(
        _ input: DescribeClusterDbRevisionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ClusterDbRevisionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClusterDbRevisions,
            inputKey: \DescribeClusterDbRevisionsMessage.marker,
            outputKey: \ClusterDbRevisionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.  For more information about parameters and parameter groups, go to Amazon Redshift Parameter Groups in the Amazon Redshift Cluster Management Guide. If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have owner and environment for tag keys, and admin and test for tag values, all parameter groups that have any combination of those values are returned. If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClusterParameterGroupsPaginator<Result>(
        _ input: DescribeClusterParameterGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ClusterParameterGroupsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClusterParameterGroups,
            inputKey: \DescribeClusterParameterGroupsMessage.marker,
            outputKey: \ClusterParameterGroupsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClusterParameterGroupsPaginator(
        _ input: DescribeClusterParameterGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ClusterParameterGroupsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClusterParameterGroups,
            inputKey: \DescribeClusterParameterGroupsMessage.marker,
            outputKey: \ClusterParameterGroupsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on. You can specify source filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from ModifyClusterParameterGroup, you can specify source equal to user.  For more information about parameters and parameter groups, go to Amazon Redshift Parameter Groups in the Amazon Redshift Cluster Management Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClusterParametersPaginator<Result>(
        _ input: DescribeClusterParametersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ClusterParameterGroupDetails, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClusterParameters,
            inputKey: \DescribeClusterParametersMessage.marker,
            outputKey: \ClusterParameterGroupDetails.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClusterParametersPaginator(
        _ input: DescribeClusterParametersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ClusterParameterGroupDetails, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClusterParameters,
            inputKey: \DescribeClusterParametersMessage.marker,
            outputKey: \ClusterParameterGroupDetails.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.  For information about managing security groups, go to Amazon Redshift Cluster Security Groups in the Amazon Redshift Cluster Management Guide. If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have owner and environment for tag keys, and admin and test for tag values, all security groups that have any combination of those values are returned. If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClusterSecurityGroupsPaginator<Result>(
        _ input: DescribeClusterSecurityGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ClusterSecurityGroupMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClusterSecurityGroups,
            inputKey: \DescribeClusterSecurityGroupsMessage.marker,
            outputKey: \ClusterSecurityGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClusterSecurityGroupsPaginator(
        _ input: DescribeClusterSecurityGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ClusterSecurityGroupMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClusterSecurityGroups,
            inputKey: \DescribeClusterSecurityGroupsMessage.marker,
            outputKey: \ClusterSecurityGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by your account. No information is returned for snapshots owned by inactive accounts. If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have owner and environment for tag keys, and admin and test for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters. If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClusterSnapshotsPaginator<Result>(
        _ input: DescribeClusterSnapshotsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SnapshotMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClusterSnapshots,
            inputKey: \DescribeClusterSnapshotsMessage.marker,
            outputKey: \SnapshotMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClusterSnapshotsPaginator(
        _ input: DescribeClusterSnapshotsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SnapshotMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClusterSnapshots,
            inputKey: \DescribeClusterSnapshotsMessage.marker,
            outputKey: \SnapshotMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in your account. If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have owner and environment for tag keys, and admin and test for tag values, all subnet groups that have any combination of those values are returned. If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClusterSubnetGroupsPaginator<Result>(
        _ input: DescribeClusterSubnetGroupsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ClusterSubnetGroupMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClusterSubnetGroups,
            inputKey: \DescribeClusterSubnetGroupsMessage.marker,
            outputKey: \ClusterSubnetGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClusterSubnetGroupsPaginator(
        _ input: DescribeClusterSubnetGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ClusterSubnetGroupMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClusterSubnetGroups,
            inputKey: \DescribeClusterSubnetGroupsMessage.marker,
            outputKey: \ClusterSubnetGroupMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of all the available maintenance tracks.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClusterTracksPaginator<Result>(
        _ input: DescribeClusterTracksMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, TrackListMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClusterTracks,
            inputKey: \DescribeClusterTracksMessage.marker,
            outputKey: \TrackListMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClusterTracksPaginator(
        _ input: DescribeClusterTracksMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (TrackListMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClusterTracks,
            inputKey: \DescribeClusterTracksMessage.marker,
            outputKey: \TrackListMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to Amazon Redshift Clusters in the Amazon Redshift Cluster Management Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClusterVersionsPaginator<Result>(
        _ input: DescribeClusterVersionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ClusterVersionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClusterVersions,
            inputKey: \DescribeClusterVersionsMessage.marker,
            outputKey: \ClusterVersionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClusterVersionsPaginator(
        _ input: DescribeClusterVersionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ClusterVersionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClusterVersions,
            inputKey: \DescribeClusterVersionsMessage.marker,
            outputKey: \ClusterVersionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to Amazon Redshift Clusters in the Amazon Redshift Cluster Management Guide. If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have owner and environment for tag keys, and admin and test for tag values, all clusters that have any combination of those values are returned. If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeClustersPaginator<Result>(
        _ input: DescribeClustersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ClustersMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeClusters,
            inputKey: \DescribeClustersMessage.marker,
            outputKey: \ClustersMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeClustersPaginator(
        _ input: DescribeClustersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ClustersMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeClusters,
            inputKey: \DescribeClustersMessage.marker,
            outputKey: \ClustersMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of parameter settings for the specified parameter group family.  For more information about parameters and parameter groups, go to Amazon Redshift Parameter Groups in the Amazon Redshift Cluster Management Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeDefaultClusterParametersPaginator<Result>(
        _ input: DescribeDefaultClusterParametersMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeDefaultClusterParametersResult, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeDefaultClusterParameters,
            inputKey: \DescribeDefaultClusterParametersMessage.marker,
            outputKey: \DescribeDefaultClusterParametersResult.defaultClusterParameters?.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeDefaultClusterParametersPaginator(
        _ input: DescribeDefaultClusterParametersMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeDefaultClusterParametersResult, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeDefaultClusterParameters,
            inputKey: \DescribeDefaultClusterParametersMessage.marker,
            outputKey: \DescribeDefaultClusterParametersResult.defaultClusterParameters?.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes a Redshift-managed VPC endpoint.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEndpointAccessPaginator<Result>(
        _ input: DescribeEndpointAccessMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, EndpointAccessList, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEndpointAccess,
            inputKey: \DescribeEndpointAccessMessage.marker,
            outputKey: \EndpointAccessList.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEndpointAccessPaginator(
        _ input: DescribeEndpointAccessMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (EndpointAccessList, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEndpointAccess,
            inputKey: \DescribeEndpointAccessMessage.marker,
            outputKey: \EndpointAccessList.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes an endpoint authorization.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEndpointAuthorizationPaginator<Result>(
        _ input: DescribeEndpointAuthorizationMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, EndpointAuthorizationList, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEndpointAuthorization,
            inputKey: \DescribeEndpointAuthorizationMessage.marker,
            outputKey: \EndpointAuthorizationList.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEndpointAuthorizationPaginator(
        _ input: DescribeEndpointAuthorizationMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (EndpointAuthorizationList, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEndpointAuthorization,
            inputKey: \DescribeEndpointAuthorizationMessage.marker,
            outputKey: \EndpointAuthorizationList.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription. If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have owner and environment for tag keys, and admin and test for tag values, all subscriptions that have any combination of those values are returned. If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEventSubscriptionsPaginator<Result>(
        _ input: DescribeEventSubscriptionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, EventSubscriptionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEventSubscriptions,
            inputKey: \DescribeEventSubscriptionsMessage.marker,
            outputKey: \EventSubscriptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEventSubscriptionsPaginator(
        _ input: DescribeEventSubscriptionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (EventSubscriptionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEventSubscriptions,
            inputKey: \DescribeEventSubscriptionsMessage.marker,
            outputKey: \EventSubscriptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeEventsPaginator<Result>(
        _ input: DescribeEventsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, EventsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeEvents,
            inputKey: \DescribeEventsMessage.marker,
            outputKey: \EventsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeEventsPaginator(
        _ input: DescribeEventsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (EventsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeEvents,
            inputKey: \DescribeEventsMessage.marker,
            outputKey: \EventsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your account. If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have owner and environment for tag keys, and admin and test for tag values, all HSM client certificates that have any combination of those values are returned. If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeHsmClientCertificatesPaginator<Result>(
        _ input: DescribeHsmClientCertificatesMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, HsmClientCertificateMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeHsmClientCertificates,
            inputKey: \DescribeHsmClientCertificatesMessage.marker,
            outputKey: \HsmClientCertificateMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeHsmClientCertificatesPaginator(
        _ input: DescribeHsmClientCertificatesMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (HsmClientCertificateMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeHsmClientCertificates,
            inputKey: \DescribeHsmClientCertificatesMessage.marker,
            outputKey: \HsmClientCertificateMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your account. If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have owner and environment for tag keys, and admin and test for tag values, all HSM connections that have any combination of those values are returned. If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeHsmConfigurationsPaginator<Result>(
        _ input: DescribeHsmConfigurationsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, HsmConfigurationMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeHsmConfigurations,
            inputKey: \DescribeHsmConfigurationsMessage.marker,
            outputKey: \HsmConfigurationMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeHsmConfigurationsPaginator(
        _ input: DescribeHsmConfigurationsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (HsmConfigurationMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeHsmConfigurations,
            inputKey: \DescribeHsmConfigurationsMessage.marker,
            outputKey: \HsmConfigurationMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeNodeConfigurationOptionsPaginator<Result>(
        _ input: DescribeNodeConfigurationOptionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, NodeConfigurationOptionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeNodeConfigurationOptions,
            inputKey: \DescribeNodeConfigurationOptionsMessage.marker,
            outputKey: \NodeConfigurationOptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeNodeConfigurationOptionsPaginator(
        _ input: DescribeNodeConfigurationOptionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (NodeConfigurationOptionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeNodeConfigurationOptions,
            inputKey: \DescribeNodeConfigurationOptionsMessage.marker,
            outputKey: \NodeConfigurationOptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to Amazon Redshift Clusters in the Amazon Redshift Cluster Management Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeOrderableClusterOptionsPaginator<Result>(
        _ input: DescribeOrderableClusterOptionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, OrderableClusterOptionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeOrderableClusterOptions,
            inputKey: \DescribeOrderableClusterOptionsMessage.marker,
            outputKey: \OrderableClusterOptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeOrderableClusterOptionsPaginator(
        _ input: DescribeOrderableClusterOptionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (OrderableClusterOptionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeOrderableClusterOptions,
            inputKey: \DescribeOrderableClusterOptionsMessage.marker,
            outputKey: \OrderableClusterOptionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to PurchaseReservedNodeOffering to reserve one or more nodes for your Amazon Redshift cluster.   For more information about reserved node offerings, go to Purchasing Reserved Nodes in the Amazon Redshift Cluster Management Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeReservedNodeOfferingsPaginator<Result>(
        _ input: DescribeReservedNodeOfferingsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ReservedNodeOfferingsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeReservedNodeOfferings,
            inputKey: \DescribeReservedNodeOfferingsMessage.marker,
            outputKey: \ReservedNodeOfferingsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeReservedNodeOfferingsPaginator(
        _ input: DescribeReservedNodeOfferingsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ReservedNodeOfferingsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeReservedNodeOfferings,
            inputKey: \DescribeReservedNodeOfferingsMessage.marker,
            outputKey: \ReservedNodeOfferingsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns the descriptions of the reserved nodes.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeReservedNodesPaginator<Result>(
        _ input: DescribeReservedNodesMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ReservedNodesMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeReservedNodes,
            inputKey: \DescribeReservedNodesMessage.marker,
            outputKey: \ReservedNodesMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeReservedNodesPaginator(
        _ input: DescribeReservedNodesMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ReservedNodesMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeReservedNodes,
            inputKey: \DescribeReservedNodesMessage.marker,
            outputKey: \ReservedNodesMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes properties of scheduled actions.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeScheduledActionsPaginator<Result>(
        _ input: DescribeScheduledActionsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ScheduledActionsMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeScheduledActions,
            inputKey: \DescribeScheduledActionsMessage.marker,
            outputKey: \ScheduledActionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeScheduledActionsPaginator(
        _ input: DescribeScheduledActionsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ScheduledActionsMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeScheduledActions,
            inputKey: \DescribeScheduledActionsMessage.marker,
            outputKey: \ScheduledActionsMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of snapshot copy grants owned by the account in the destination region.  For more information about managing snapshot copy grants, go to Amazon Redshift Database Encryption in the Amazon Redshift Cluster Management Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSnapshotCopyGrantsPaginator<Result>(
        _ input: DescribeSnapshotCopyGrantsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SnapshotCopyGrantMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSnapshotCopyGrants,
            inputKey: \DescribeSnapshotCopyGrantsMessage.marker,
            outputKey: \SnapshotCopyGrantMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSnapshotCopyGrantsPaginator(
        _ input: DescribeSnapshotCopyGrantsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SnapshotCopyGrantMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSnapshotCopyGrants,
            inputKey: \DescribeSnapshotCopyGrantsMessage.marker,
            outputKey: \SnapshotCopyGrantMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of snapshot schedules.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeSnapshotSchedulesPaginator<Result>(
        _ input: DescribeSnapshotSchedulesMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeSnapshotSchedulesOutputMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeSnapshotSchedules,
            inputKey: \DescribeSnapshotSchedulesMessage.marker,
            outputKey: \DescribeSnapshotSchedulesOutputMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeSnapshotSchedulesPaginator(
        _ input: DescribeSnapshotSchedulesMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeSnapshotSchedulesOutputMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeSnapshotSchedules,
            inputKey: \DescribeSnapshotSchedulesMessage.marker,
            outputKey: \DescribeSnapshotSchedulesOutputMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the status of one or more table restore requests made using the RestoreTableFromClusterSnapshot API action. If you don't specify a value for the TableRestoreRequestId parameter, then DescribeTableRestoreStatus returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise DescribeTableRestoreStatus returns the status of the table specified by TableRestoreRequestId.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTableRestoreStatusPaginator<Result>(
        _ input: DescribeTableRestoreStatusMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, TableRestoreStatusMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTableRestoreStatus,
            inputKey: \DescribeTableRestoreStatusMessage.marker,
            outputKey: \TableRestoreStatusMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTableRestoreStatusPaginator(
        _ input: DescribeTableRestoreStatusMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (TableRestoreStatusMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTableRestoreStatus,
            inputKey: \DescribeTableRestoreStatusMessage.marker,
            outputKey: \TableRestoreStatusMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on. The following are limitations for DescribeTags:    You cannot specify an ARN and a resource-type value together in the same request.   You cannot use the MaxRecords and Marker parameters together with the ARN parameter.   The MaxRecords parameter can be a range from 10 to 50 results to return in a request.   If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have owner and environment for tag keys, and admin and test for tag values, all resources that have any combination of those values are returned. If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTagsPaginator<Result>(
        _ input: DescribeTagsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, TaggedResourceListMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTags,
            inputKey: \DescribeTagsMessage.marker,
            outputKey: \TaggedResourceListMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTagsPaginator(
        _ input: DescribeTagsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (TaggedResourceListMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTags,
            inputKey: \DescribeTagsMessage.marker,
            outputKey: \TaggedResourceListMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Shows usage limits on a cluster. Results are filtered based on the combination of input usage limit identifier, cluster identifier, and feature type parameters:   If usage limit identifier, cluster identifier, and feature type are not provided, then all usage limit objects for the current account in the current region are returned.   If usage limit identifier is provided, then the corresponding usage limit object is returned.   If cluster identifier is provided, then all usage limit objects for the specified cluster are returned.   If cluster identifier and feature type are provided, then all usage limit objects for the combination of cluster and feature are returned.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeUsageLimitsPaginator<Result>(
        _ input: DescribeUsageLimitsMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, UsageLimitList, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeUsageLimits,
            inputKey: \DescribeUsageLimitsMessage.marker,
            outputKey: \UsageLimitList.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeUsageLimitsPaginator(
        _ input: DescribeUsageLimitsMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (UsageLimitList, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeUsageLimits,
            inputKey: \DescribeUsageLimitsMessage.marker,
            outputKey: \UsageLimitList.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getReservedNodeExchangeOfferingsPaginator<Result>(
        _ input: GetReservedNodeExchangeOfferingsInputMessage,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetReservedNodeExchangeOfferingsOutputMessage, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getReservedNodeExchangeOfferings,
            inputKey: \GetReservedNodeExchangeOfferingsInputMessage.marker,
            outputKey: \GetReservedNodeExchangeOfferingsOutputMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getReservedNodeExchangeOfferingsPaginator(
        _ input: GetReservedNodeExchangeOfferingsInputMessage,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetReservedNodeExchangeOfferingsOutputMessage, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getReservedNodeExchangeOfferings,
            inputKey: \GetReservedNodeExchangeOfferingsInputMessage.marker,
            outputKey: \GetReservedNodeExchangeOfferingsOutputMessage.marker,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension Redshift.DescribeClusterDbRevisionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeClusterDbRevisionsMessage {
        return .init(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension Redshift.DescribeClusterParameterGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeClusterParameterGroupsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            parameterGroupName: self.parameterGroupName,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeClusterParametersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeClusterParametersMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            parameterGroupName: self.parameterGroupName,
            source: self.source
        )
    }
}

extension Redshift.DescribeClusterSecurityGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeClusterSecurityGroupsMessage {
        return .init(
            clusterSecurityGroupName: self.clusterSecurityGroupName,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeClusterSnapshotsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeClusterSnapshotsMessage {
        return .init(
            clusterExists: self.clusterExists,
            clusterIdentifier: self.clusterIdentifier,
            endTime: self.endTime,
            marker: token,
            maxRecords: self.maxRecords,
            ownerAccount: self.ownerAccount,
            snapshotIdentifier: self.snapshotIdentifier,
            snapshotType: self.snapshotType,
            sortingEntities: self.sortingEntities,
            startTime: self.startTime,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeClusterSubnetGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeClusterSubnetGroupsMessage {
        return .init(
            clusterSubnetGroupName: self.clusterSubnetGroupName,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeClusterTracksMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeClusterTracksMessage {
        return .init(
            maintenanceTrackName: self.maintenanceTrackName,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension Redshift.DescribeClusterVersionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeClusterVersionsMessage {
        return .init(
            clusterParameterGroupFamily: self.clusterParameterGroupFamily,
            clusterVersion: self.clusterVersion,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension Redshift.DescribeClustersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeClustersMessage {
        return .init(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeDefaultClusterParametersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeDefaultClusterParametersMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            parameterGroupFamily: self.parameterGroupFamily
        )
    }
}

extension Redshift.DescribeEndpointAccessMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeEndpointAccessMessage {
        return .init(
            clusterIdentifier: self.clusterIdentifier,
            endpointName: self.endpointName,
            marker: token,
            maxRecords: self.maxRecords,
            resourceOwner: self.resourceOwner,
            vpcId: self.vpcId
        )
    }
}

extension Redshift.DescribeEndpointAuthorizationMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeEndpointAuthorizationMessage {
        return .init(
            account: self.account,
            clusterIdentifier: self.clusterIdentifier,
            grantee: self.grantee,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension Redshift.DescribeEventSubscriptionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeEventSubscriptionsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            subscriptionName: self.subscriptionName,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeEventsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeEventsMessage {
        return .init(
            duration: self.duration,
            endTime: self.endTime,
            marker: token,
            maxRecords: self.maxRecords,
            sourceIdentifier: self.sourceIdentifier,
            sourceType: self.sourceType,
            startTime: self.startTime
        )
    }
}

extension Redshift.DescribeHsmClientCertificatesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeHsmClientCertificatesMessage {
        return .init(
            hsmClientCertificateIdentifier: self.hsmClientCertificateIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeHsmConfigurationsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeHsmConfigurationsMessage {
        return .init(
            hsmConfigurationIdentifier: self.hsmConfigurationIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeNodeConfigurationOptionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeNodeConfigurationOptionsMessage {
        return .init(
            actionType: self.actionType,
            clusterIdentifier: self.clusterIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            ownerAccount: self.ownerAccount,
            snapshotIdentifier: self.snapshotIdentifier
        )
    }
}

extension Redshift.DescribeOrderableClusterOptionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeOrderableClusterOptionsMessage {
        return .init(
            clusterVersion: self.clusterVersion,
            marker: token,
            maxRecords: self.maxRecords,
            nodeType: self.nodeType
        )
    }
}

extension Redshift.DescribeReservedNodeOfferingsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeReservedNodeOfferingsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeOfferingId: self.reservedNodeOfferingId
        )
    }
}

extension Redshift.DescribeReservedNodesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeReservedNodesMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeId: self.reservedNodeId
        )
    }
}

extension Redshift.DescribeScheduledActionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeScheduledActionsMessage {
        return .init(
            active: self.active,
            endTime: self.endTime,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            scheduledActionName: self.scheduledActionName,
            startTime: self.startTime,
            targetActionType: self.targetActionType
        )
    }
}

extension Redshift.DescribeSnapshotCopyGrantsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeSnapshotCopyGrantsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            snapshotCopyGrantName: self.snapshotCopyGrantName,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeSnapshotSchedulesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeSnapshotSchedulesMessage {
        return .init(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            scheduleIdentifier: self.scheduleIdentifier,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeTableRestoreStatusMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeTableRestoreStatusMessage {
        return .init(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tableRestoreRequestId: self.tableRestoreRequestId
        )
    }
}

extension Redshift.DescribeTagsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeTagsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            resourceName: self.resourceName,
            resourceType: self.resourceType,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )
    }
}

extension Redshift.DescribeUsageLimitsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.DescribeUsageLimitsMessage {
        return .init(
            clusterIdentifier: self.clusterIdentifier,
            featureType: self.featureType,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues,
            usageLimitId: self.usageLimitId
        )
    }
}

extension Redshift.GetReservedNodeExchangeOfferingsInputMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> Redshift.GetReservedNodeExchangeOfferingsInputMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeId: self.reservedNodeId
        )
    }
}
