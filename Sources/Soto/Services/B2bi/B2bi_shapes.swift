//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension B2bi {
    // MARK: Enums

    public enum CapabilityDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
        public var description: String { return self.rawValue }
    }

    public enum CapabilityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case edi = "edi"
        public var description: String { return self.rawValue }
    }

    public enum ConversionSourceFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case xml = "XML"
        public var description: String { return self.rawValue }
    }

    public enum ConversionTargetFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case x12 = "X12"
        public var description: String { return self.rawValue }
    }

    public enum FileFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case notUsed = "NOT_USED"
        case xml = "XML"
        public var description: String { return self.rawValue }
    }

    public enum FromFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case x12 = "X12"
        public var description: String { return self.rawValue }
    }

    public enum Logging: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum MappingTemplateLanguage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jsonata = "JSONATA"
        case xslt = "XSLT"
        public var description: String { return self.rawValue }
    }

    public enum MappingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jsonata = "JSONATA"
        case xslt = "XSLT"
        public var description: String { return self.rawValue }
    }

    public enum ToFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case x12 = "X12"
        public var description: String { return self.rawValue }
    }

    public enum TransformerJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "failed"
        case running = "running"
        case succeeded = "succeeded"
        public var description: String { return self.rawValue }
    }

    public enum TransformerStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "active"
        case inactive = "inactive"
        public var description: String { return self.rawValue }
    }

    public enum X12TransactionSet: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case x12100 = "X12_100"
        case x12101 = "X12_101"
        case x12102 = "X12_102"
        case x12103 = "X12_103"
        case x12104 = "X12_104"
        case x12105 = "X12_105"
        case x12106 = "X12_106"
        case x12107 = "X12_107"
        case x12108 = "X12_108"
        case x12109 = "X12_109"
        case x12110 = "X12_110"
        case x12111 = "X12_111"
        case x12112 = "X12_112"
        case x12113 = "X12_113"
        case x12120 = "X12_120"
        case x12121 = "X12_121"
        case x12124 = "X12_124"
        case x12125 = "X12_125"
        case x12126 = "X12_126"
        case x12127 = "X12_127"
        case x12128 = "X12_128"
        case x12129 = "X12_129"
        case x12130 = "X12_130"
        case x12131 = "X12_131"
        case x12132 = "X12_132"
        case x12133 = "X12_133"
        case x12135 = "X12_135"
        case x12138 = "X12_138"
        case x12139 = "X12_139"
        case x12140 = "X12_140"
        case x12141 = "X12_141"
        case x12142 = "X12_142"
        case x12143 = "X12_143"
        case x12144 = "X12_144"
        case x12146 = "X12_146"
        case x12147 = "X12_147"
        case x12148 = "X12_148"
        case x12149 = "X12_149"
        case x12150 = "X12_150"
        case x12151 = "X12_151"
        case x12152 = "X12_152"
        case x12153 = "X12_153"
        case x12154 = "X12_154"
        case x12155 = "X12_155"
        case x12157 = "X12_157"
        case x12158 = "X12_158"
        case x12159 = "X12_159"
        case x12160 = "X12_160"
        case x12161 = "X12_161"
        case x12163 = "X12_163"
        case x12170 = "X12_170"
        case x12175 = "X12_175"
        case x12176 = "X12_176"
        case x12179 = "X12_179"
        case x12180 = "X12_180"
        case x12185 = "X12_185"
        case x12186 = "X12_186"
        case x12187 = "X12_187"
        case x12188 = "X12_188"
        case x12189 = "X12_189"
        case x12190 = "X12_190"
        case x12191 = "X12_191"
        case x12194 = "X12_194"
        case x12195 = "X12_195"
        case x12196 = "X12_196"
        case x12197 = "X12_197"
        case x12198 = "X12_198"
        case x12199 = "X12_199"
        case x12200 = "X12_200"
        case x12201 = "X12_201"
        case x12202 = "X12_202"
        case x12203 = "X12_203"
        case x12204 = "X12_204"
        case x12205 = "X12_205"
        case x12206 = "X12_206"
        case x12210 = "X12_210"
        case x12211 = "X12_211"
        case x12212 = "X12_212"
        case x12213 = "X12_213"
        case x12214 = "X12_214"
        case x12215 = "X12_215"
        case x12216 = "X12_216"
        case x12217 = "X12_217"
        case x12218 = "X12_218"
        case x12219 = "X12_219"
        case x12220 = "X12_220"
        case x12222 = "X12_222"
        case x12223 = "X12_223"
        case x12224 = "X12_224"
        case x12225 = "X12_225"
        case x12227 = "X12_227"
        case x12228 = "X12_228"
        case x12240 = "X12_240"
        case x12242 = "X12_242"
        case x12244 = "X12_244"
        case x12245 = "X12_245"
        case x12248 = "X12_248"
        case x12249 = "X12_249"
        case x12250 = "X12_250"
        case x12251 = "X12_251"
        case x12252 = "X12_252"
        case x12255 = "X12_255"
        case x12256 = "X12_256"
        case x12259 = "X12_259"
        case x12260 = "X12_260"
        case x12261 = "X12_261"
        case x12262 = "X12_262"
        case x12263 = "X12_263"
        case x12264 = "X12_264"
        case x12265 = "X12_265"
        case x12266 = "X12_266"
        case x12267 = "X12_267"
        case x12268 = "X12_268"
        case x12269 = "X12_269"
        case x12270 = "X12_270"
        case x12270X279 = "X12_270_X279"
        case x12271 = "X12_271"
        case x12271X279 = "X12_271_X279"
        case x12272 = "X12_272"
        case x12273 = "X12_273"
        case x12274 = "X12_274"
        case x12275 = "X12_275"
        case x12275X210 = "X12_275_X210"
        case x12275X211 = "X12_275_X211"
        case x12276 = "X12_276"
        case x12276X212 = "X12_276_X212"
        case x12277 = "X12_277"
        case x12277X212 = "X12_277_X212"
        case x12277X214 = "X12_277_X214"
        case x12277X364 = "X12_277_X364"
        case x12278 = "X12_278"
        case x12278X217 = "X12_278_X217"
        case x12280 = "X12_280"
        case x12283 = "X12_283"
        case x12284 = "X12_284"
        case x12285 = "X12_285"
        case x12286 = "X12_286"
        case x12288 = "X12_288"
        case x12290 = "X12_290"
        case x12300 = "X12_300"
        case x12301 = "X12_301"
        case x12303 = "X12_303"
        case x12304 = "X12_304"
        case x12309 = "X12_309"
        case x12310 = "X12_310"
        case x12311 = "X12_311"
        case x12312 = "X12_312"
        case x12313 = "X12_313"
        case x12315 = "X12_315"
        case x12317 = "X12_317"
        case x12319 = "X12_319"
        case x12322 = "X12_322"
        case x12323 = "X12_323"
        case x12324 = "X12_324"
        case x12325 = "X12_325"
        case x12326 = "X12_326"
        case x12350 = "X12_350"
        case x12352 = "X12_352"
        case x12353 = "X12_353"
        case x12354 = "X12_354"
        case x12355 = "X12_355"
        case x12356 = "X12_356"
        case x12357 = "X12_357"
        case x12358 = "X12_358"
        case x12361 = "X12_361"
        case x12362 = "X12_362"
        case x12404 = "X12_404"
        case x12410 = "X12_410"
        case x12412 = "X12_412"
        case x12414 = "X12_414"
        case x12417 = "X12_417"
        case x12418 = "X12_418"
        case x12419 = "X12_419"
        case x12420 = "X12_420"
        case x12421 = "X12_421"
        case x12422 = "X12_422"
        case x12423 = "X12_423"
        case x12424 = "X12_424"
        case x12425 = "X12_425"
        case x12426 = "X12_426"
        case x12429 = "X12_429"
        case x12431 = "X12_431"
        case x12432 = "X12_432"
        case x12433 = "X12_433"
        case x12434 = "X12_434"
        case x12435 = "X12_435"
        case x12436 = "X12_436"
        case x12437 = "X12_437"
        case x12440 = "X12_440"
        case x12451 = "X12_451"
        case x12452 = "X12_452"
        case x12453 = "X12_453"
        case x12455 = "X12_455"
        case x12456 = "X12_456"
        case x12460 = "X12_460"
        case x12463 = "X12_463"
        case x12466 = "X12_466"
        case x12468 = "X12_468"
        case x12470 = "X12_470"
        case x12475 = "X12_475"
        case x12485 = "X12_485"
        case x12486 = "X12_486"
        case x12490 = "X12_490"
        case x12492 = "X12_492"
        case x12494 = "X12_494"
        case x12500 = "X12_500"
        case x12501 = "X12_501"
        case x12503 = "X12_503"
        case x12504 = "X12_504"
        case x12511 = "X12_511"
        case x12517 = "X12_517"
        case x12521 = "X12_521"
        case x12527 = "X12_527"
        case x12536 = "X12_536"
        case x12540 = "X12_540"
        case x12561 = "X12_561"
        case x12567 = "X12_567"
        case x12568 = "X12_568"
        case x12601 = "X12_601"
        case x12602 = "X12_602"
        case x12620 = "X12_620"
        case x12625 = "X12_625"
        case x12650 = "X12_650"
        case x12715 = "X12_715"
        case x12753 = "X12_753"
        case x12754 = "X12_754"
        case x12805 = "X12_805"
        case x12806 = "X12_806"
        case x12810 = "X12_810"
        case x12811 = "X12_811"
        case x12812 = "X12_812"
        case x12813 = "X12_813"
        case x12814 = "X12_814"
        case x12815 = "X12_815"
        case x12816 = "X12_816"
        case x12818 = "X12_818"
        case x12819 = "X12_819"
        case x12820 = "X12_820"
        case x12820X218 = "X12_820_X218"
        case x12820X306 = "X12_820_X306"
        case x12821 = "X12_821"
        case x12822 = "X12_822"
        case x12823 = "X12_823"
        case x12824 = "X12_824"
        case x12824X186 = "X12_824_X186"
        case x12826 = "X12_826"
        case x12827 = "X12_827"
        case x12828 = "X12_828"
        case x12829 = "X12_829"
        case x12830 = "X12_830"
        case x12831 = "X12_831"
        case x12832 = "X12_832"
        case x12833 = "X12_833"
        case x12834 = "X12_834"
        case x12834X220 = "X12_834_X220"
        case x12834X307 = "X12_834_X307"
        case x12834X318 = "X12_834_X318"
        case x12835 = "X12_835"
        case x12835X221 = "X12_835_X221"
        case x12836 = "X12_836"
        case x12837 = "X12_837"
        case x12837X222 = "X12_837_X222"
        case x12837X223 = "X12_837_X223"
        case x12837X224 = "X12_837_X224"
        case x12837X291 = "X12_837_X291"
        case x12837X292 = "X12_837_X292"
        case x12837X298 = "X12_837_X298"
        case x12838 = "X12_838"
        case x12839 = "X12_839"
        case x12840 = "X12_840"
        case x12841 = "X12_841"
        case x12842 = "X12_842"
        case x12843 = "X12_843"
        case x12844 = "X12_844"
        case x12845 = "X12_845"
        case x12846 = "X12_846"
        case x12847 = "X12_847"
        case x12848 = "X12_848"
        case x12849 = "X12_849"
        case x12850 = "X12_850"
        case x12851 = "X12_851"
        case x12852 = "X12_852"
        case x12853 = "X12_853"
        case x12854 = "X12_854"
        case x12855 = "X12_855"
        case x12856 = "X12_856"
        case x12857 = "X12_857"
        case x12858 = "X12_858"
        case x12859 = "X12_859"
        case x12860 = "X12_860"
        case x12861 = "X12_861"
        case x12862 = "X12_862"
        case x12863 = "X12_863"
        case x12864 = "X12_864"
        case x12865 = "X12_865"
        case x12866 = "X12_866"
        case x12867 = "X12_867"
        case x12868 = "X12_868"
        case x12869 = "X12_869"
        case x12870 = "X12_870"
        case x12871 = "X12_871"
        case x12872 = "X12_872"
        case x12873 = "X12_873"
        case x12874 = "X12_874"
        case x12875 = "X12_875"
        case x12876 = "X12_876"
        case x12877 = "X12_877"
        case x12878 = "X12_878"
        case x12879 = "X12_879"
        case x12880 = "X12_880"
        case x12881 = "X12_881"
        case x12882 = "X12_882"
        case x12883 = "X12_883"
        case x12884 = "X12_884"
        case x12885 = "X12_885"
        case x12886 = "X12_886"
        case x12887 = "X12_887"
        case x12888 = "X12_888"
        case x12889 = "X12_889"
        case x12891 = "X12_891"
        case x12893 = "X12_893"
        case x12894 = "X12_894"
        case x12895 = "X12_895"
        case x12896 = "X12_896"
        case x12920 = "X12_920"
        case x12924 = "X12_924"
        case x12925 = "X12_925"
        case x12926 = "X12_926"
        case x12928 = "X12_928"
        case x12940 = "X12_940"
        case x12943 = "X12_943"
        case x12944 = "X12_944"
        case x12945 = "X12_945"
        case x12947 = "X12_947"
        case x12980 = "X12_980"
        case x12990 = "X12_990"
        case x12993 = "X12_993"
        case x12996 = "X12_996"
        case x12997 = "X12_997"
        case x12998 = "X12_998"
        case x12999 = "X12_999"
        case x12999X231 = "X12_999_X231"
        public var description: String { return self.rawValue }
    }

    public enum X12Version: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case version4010 = "VERSION_4010"
        case version4030 = "VERSION_4030"
        case version4050 = "VERSION_4050"
        case version4060 = "VERSION_4060"
        case version5010 = "VERSION_5010"
        case version5010Hipaa = "VERSION_5010_HIPAA"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CapabilityOptions: AWSEncodableShape & AWSDecodableShape {
        /// A structure that contains the outbound EDI options.
        public let outboundEdi: OutboundEdiOptions?

        @inlinable
        public init(outboundEdi: OutboundEdiOptions? = nil) {
            self.outboundEdi = outboundEdi
        }

        public func validate(name: String) throws {
            try self.outboundEdi?.validate(name: "\(name).outboundEdi")
        }

        private enum CodingKeys: String, CodingKey {
            case outboundEdi = "outboundEdi"
        }
    }

    public struct CapabilitySummary: AWSDecodableShape {
        /// Returns a system-assigned unique identifier for the capability.
        public let capabilityId: String
        /// Returns a timestamp for creation date and time of the capability.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns a timestamp that identifies the most recent date and time that the capability was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// The display name of the capability.
        public let name: String
        /// Returns the type of the capability. Currently, only edi is supported.
        public let type: CapabilityType

        @inlinable
        public init(capabilityId: String, createdAt: Date, modifiedAt: Date? = nil, name: String, type: CapabilityType) {
            self.capabilityId = capabilityId
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityId = "capabilityId"
            case createdAt = "createdAt"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case type = "type"
        }
    }

    public struct ConversionSource: AWSEncodableShape {
        /// The format for the input file: either JSON or XML.
        public let fileFormat: ConversionSourceFormat
        /// File to be converted
        public let inputFile: InputFileSource

        @inlinable
        public init(fileFormat: ConversionSourceFormat, inputFile: InputFileSource) {
            self.fileFormat = fileFormat
            self.inputFile = inputFile
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormat = "fileFormat"
            case inputFile = "inputFile"
        }
    }

    public struct ConversionTarget: AWSEncodableShape {
        /// Currently, only X12 format is supported.
        public let fileFormat: ConversionTargetFormat
        /// A structure that contains the formatting details for the conversion target.
        public let formatDetails: ConversionTargetFormatDetails?
        /// Customer uses this to provide a sample on what should file look like after conversion
        /// X12 EDI use case around this would be discovering the file syntax
        public let outputSampleFile: OutputSampleFileSource?

        @inlinable
        public init(fileFormat: ConversionTargetFormat, formatDetails: ConversionTargetFormatDetails? = nil, outputSampleFile: OutputSampleFileSource? = nil) {
            self.fileFormat = fileFormat
            self.formatDetails = formatDetails
            self.outputSampleFile = outputSampleFile
        }

        public func validate(name: String) throws {
            try self.outputSampleFile?.validate(name: "\(name).outputSampleFile")
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormat = "fileFormat"
            case formatDetails = "formatDetails"
            case outputSampleFile = "outputSampleFile"
        }
    }

    public struct CreateCapabilityRequest: AWSEncodableShape {
        /// Reserved for future use.
        public let clientToken: String?
        /// Specifies a structure that contains the details for a capability.
        public let configuration: CapabilityConfiguration
        /// Specifies one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
        public let instructionsDocuments: [S3Location]?
        /// Specifies the name of the capability, used to identify it.
        public let name: String
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]?
        /// Specifies the type of the capability. Currently, only edi is supported.
        public let type: CapabilityType

        @inlinable
        public init(clientToken: String? = CreateCapabilityRequest.idempotencyToken(), configuration: CapabilityConfiguration, instructionsDocuments: [S3Location]? = nil, name: String, tags: [Tag]? = nil, type: CapabilityType) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.instructionsDocuments = instructionsDocuments
            self.name = name
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.instructionsDocuments?.forEach {
                try $0.validate(name: "\(name).instructionsDocuments[]")
            }
            try self.validate(self.instructionsDocuments, name: "instructionsDocuments", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case instructionsDocuments = "instructionsDocuments"
            case name = "name"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateCapabilityResponse: AWSDecodableShape {
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let capabilityArn: String
        /// Returns a system-assigned unique identifier for the capability.
        public let capabilityId: String
        /// Returns a structure that contains the details for a capability.
        public let configuration: CapabilityConfiguration
        /// Returns a timestamp for creation date and time of the capability.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
        public let instructionsDocuments: [S3Location]?
        /// Returns the name of the capability used to identify it.
        public let name: String
        /// Returns the type of the capability. Currently, only edi is supported.
        public let type: CapabilityType

        @inlinable
        public init(capabilityArn: String, capabilityId: String, configuration: CapabilityConfiguration, createdAt: Date, instructionsDocuments: [S3Location]? = nil, name: String, type: CapabilityType) {
            self.capabilityArn = capabilityArn
            self.capabilityId = capabilityId
            self.configuration = configuration
            self.createdAt = createdAt
            self.instructionsDocuments = instructionsDocuments
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityArn = "capabilityArn"
            case capabilityId = "capabilityId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case instructionsDocuments = "instructionsDocuments"
            case name = "name"
            case type = "type"
        }
    }

    public struct CreatePartnershipRequest: AWSEncodableShape {
        /// Specifies a list of the capabilities associated with this partnership.
        public let capabilities: [String]
        /// Specify the structure that contains the details for the associated capabilities.
        public let capabilityOptions: CapabilityOptions?
        /// Reserved for future use.
        public let clientToken: String?
        /// Specifies the email address associated with this trading partner.
        public let email: String
        /// Specifies a descriptive name for the partnership.
        public let name: String
        /// Specifies the phone number associated with the partnership.
        public let phone: String?
        /// Specifies the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]?

        @inlinable
        public init(capabilities: [String], capabilityOptions: CapabilityOptions? = nil, clientToken: String? = CreatePartnershipRequest.idempotencyToken(), email: String, name: String, phone: String? = nil, profileId: String, tags: [Tag]? = nil) {
            self.capabilities = capabilities
            self.capabilityOptions = capabilityOptions
            self.clientToken = clientToken
            self.email = email
            self.name = name
            self.phone = phone
            self.profileId = profileId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.capabilities.forEach {
                try validate($0, name: "capabilities[]", parent: name, max: 64)
                try validate($0, name: "capabilities[]", parent: name, min: 1)
                try validate($0, name: "capabilities[]", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
            try self.capabilityOptions?.validate(name: "\(name).capabilityOptions")
            try self.validate(self.email, name: "email", parent: name, max: 254)
            try self.validate(self.email, name: "email", parent: name, min: 5)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[\\w\\.\\-]+@[\\w\\.\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.phone, name: "phone", parent: name, max: 22)
            try self.validate(self.phone, name: "phone", parent: name, min: 7)
            try self.validate(self.phone, name: "phone", parent: name, pattern: "^\\+?([0-9 \\t\\-()\\/]{7,})(?:\\s*(?:#|x\\.?|ext\\.?|extension) \\t*(\\d+))?$")
            try self.validate(self.profileId, name: "profileId", parent: name, max: 64)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case capabilityOptions = "capabilityOptions"
            case clientToken = "clientToken"
            case email = "email"
            case name = "name"
            case phone = "phone"
            case profileId = "profileId"
            case tags = "tags"
        }
    }

    public struct CreatePartnershipResponse: AWSDecodableShape {
        /// Returns one or more capabilities associated with this partnership.
        public let capabilities: [String]?
        /// Returns the structure that contains the details for the associated capabilities.
        public let capabilityOptions: CapabilityOptions?
        /// Returns a timestamp for creation date and time of the partnership.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this trading partner.
        public let email: String?
        /// Returns a descriptive name for the partnership.
        public let name: String?
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let partnershipArn: String
        /// Returns the unique, system-generated identifier for a partnership.
        public let partnershipId: String
        /// Returns the phone number associated with the partnership.
        public let phone: String?
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String
        /// Returns the unique, system-generated identifier for a trading partner.
        public let tradingPartnerId: String?

        @inlinable
        public init(capabilities: [String]? = nil, capabilityOptions: CapabilityOptions? = nil, createdAt: Date, email: String? = nil, name: String? = nil, partnershipArn: String, partnershipId: String, phone: String? = nil, profileId: String, tradingPartnerId: String? = nil) {
            self.capabilities = capabilities
            self.capabilityOptions = capabilityOptions
            self.createdAt = createdAt
            self.email = email
            self.name = name
            self.partnershipArn = partnershipArn
            self.partnershipId = partnershipId
            self.phone = phone
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case capabilityOptions = "capabilityOptions"
            case createdAt = "createdAt"
            case email = "email"
            case name = "name"
            case partnershipArn = "partnershipArn"
            case partnershipId = "partnershipId"
            case phone = "phone"
            case profileId = "profileId"
            case tradingPartnerId = "tradingPartnerId"
        }
    }

    public struct CreateProfileRequest: AWSEncodableShape {
        /// Specifies the name for the business associated with this profile.
        public let businessName: String
        /// Reserved for future use.
        public let clientToken: String?
        /// Specifies the email address associated with this customer profile.
        public let email: String?
        /// Specifies whether or not logging is enabled for this profile.
        public let logging: Logging
        /// Specifies the name of the profile.
        public let name: String
        /// Specifies the phone number associated with the profile.
        public let phone: String
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]?

        @inlinable
        public init(businessName: String, clientToken: String? = CreateProfileRequest.idempotencyToken(), email: String? = nil, logging: Logging, name: String, phone: String, tags: [Tag]? = nil) {
            self.businessName = businessName
            self.clientToken = clientToken
            self.email = email
            self.logging = logging
            self.name = name
            self.phone = phone
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.businessName, name: "businessName", parent: name, max: 254)
            try self.validate(self.businessName, name: "businessName", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, max: 254)
            try self.validate(self.email, name: "email", parent: name, min: 5)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[\\w\\.\\-]+@[\\w\\.\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.phone, name: "phone", parent: name, max: 22)
            try self.validate(self.phone, name: "phone", parent: name, min: 7)
            try self.validate(self.phone, name: "phone", parent: name, pattern: "^\\+?([0-9 \\t\\-()\\/]{7,})(?:\\s*(?:#|x\\.?|ext\\.?|extension) \\t*(\\d+))?$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case clientToken = "clientToken"
            case email = "email"
            case logging = "logging"
            case name = "name"
            case phone = "phone"
            case tags = "tags"
        }
    }

    public struct CreateProfileResponse: AWSDecodableShape {
        /// Returns the name for the business associated with this profile.
        public let businessName: String
        /// Returns a timestamp representing the time the profile was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this customer profile.
        public let email: String?
        /// Returns whether or not logging is turned on for this profile.
        public let logging: Logging?
        /// Returns the name of the logging group.
        public let logGroupName: String?
        /// Returns the name of the profile, used to identify it.
        public let name: String
        /// Returns the phone number associated with the profile.
        public let phone: String
        /// Returns an Amazon Resource Name (ARN) for the profile.
        public let profileArn: String
        /// Returns the unique, system-generated identifier for the profile.
        public let profileId: String

        @inlinable
        public init(businessName: String, createdAt: Date, email: String? = nil, logging: Logging? = nil, logGroupName: String? = nil, name: String, phone: String, profileArn: String, profileId: String) {
            self.businessName = businessName
            self.createdAt = createdAt
            self.email = email
            self.logging = logging
            self.logGroupName = logGroupName
            self.name = name
            self.phone = phone
            self.profileArn = profileArn
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case createdAt = "createdAt"
            case email = "email"
            case logging = "logging"
            case logGroupName = "logGroupName"
            case name = "name"
            case phone = "phone"
            case profileArn = "profileArn"
            case profileId = "profileId"
        }
    }

    public struct CreateStarterMappingTemplateRequest: AWSEncodableShape {
        /// Specify the format for the mapping template: either JSONATA or XSLT.
        public let mappingType: MappingType
        /// Specify the location of the sample EDI file that is used to generate the mapping template.
        public let outputSampleLocation: S3Location?
        ///  Describes the details needed for generating the template. Specify the X12 transaction set and version for which the template is used: currently, we only support X12.
        public let templateDetails: TemplateDetails

        @inlinable
        public init(mappingType: MappingType, outputSampleLocation: S3Location? = nil, templateDetails: TemplateDetails) {
            self.mappingType = mappingType
            self.outputSampleLocation = outputSampleLocation
            self.templateDetails = templateDetails
        }

        public func validate(name: String) throws {
            try self.outputSampleLocation?.validate(name: "\(name).outputSampleLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case mappingType = "mappingType"
            case outputSampleLocation = "outputSampleLocation"
            case templateDetails = "templateDetails"
        }
    }

    public struct CreateStarterMappingTemplateResponse: AWSDecodableShape {
        /// Returns a string that represents the mapping template.
        public let mappingTemplate: String

        @inlinable
        public init(mappingTemplate: String) {
            self.mappingTemplate = mappingTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case mappingTemplate = "mappingTemplate"
        }
    }

    public struct CreateTransformerRequest: AWSEncodableShape {
        /// Reserved for future use.
        public let clientToken: String?
        /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType?
        /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat?
        /// Specify  the InputConversion object, which contains the format options for the inbound transformation.
        public let inputConversion: InputConversion?
        /// Specify the structure that contains the mapping template and its language (either XSLT or JSONATA).
        public let mapping: Mapping?
        /// Specifies the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.  This parameter is available for backwards compatibility. Use the Mapping data type instead.
        public let mappingTemplate: String?
        /// Specifies the name of the transformer, used to identify it.
        public let name: String
        /// A structure that contains the OutputConversion object, which contains the format options for the outbound transformation.
        public let outputConversion: OutputConversion?
        /// Specifies a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Specify a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
        public let sampleDocuments: SampleDocuments?
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateTransformerRequest.idempotencyToken(), inputConversion: InputConversion? = nil, mapping: Mapping? = nil, name: String, outputConversion: OutputConversion? = nil, sampleDocuments: SampleDocuments? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.ediType = nil
            self.fileFormat = nil
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = nil
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = nil
            self.sampleDocuments = sampleDocuments
            self.tags = tags
        }

        @available(*, deprecated, message: "Members ediType, fileFormat, mappingTemplate, sampleDocument have been deprecated")
        @inlinable
        public init(clientToken: String? = CreateTransformerRequest.idempotencyToken(), ediType: EdiType? = nil, fileFormat: FileFormat? = nil, inputConversion: InputConversion? = nil, mapping: Mapping? = nil, mappingTemplate: String? = nil, name: String, outputConversion: OutputConversion? = nil, sampleDocument: String? = nil, sampleDocuments: SampleDocuments? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = mappingTemplate
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = sampleDocument
            self.sampleDocuments = sampleDocuments
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.mapping?.validate(name: "\(name).mapping")
            try self.validate(self.mappingTemplate, name: "mappingTemplate", parent: name, max: 350000)
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]{1,512}$")
            try self.validate(self.sampleDocument, name: "sampleDocument", parent: name, max: 1024)
            try self.sampleDocuments?.validate(name: "\(name).sampleDocuments")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case inputConversion = "inputConversion"
            case mapping = "mapping"
            case mappingTemplate = "mappingTemplate"
            case name = "name"
            case outputConversion = "outputConversion"
            case sampleDocument = "sampleDocument"
            case sampleDocuments = "sampleDocuments"
            case tags = "tags"
        }
    }

    public struct CreateTransformerResponse: AWSDecodableShape {
        /// Returns a timestamp for creation date and time of the transformer.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType?
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat?
        /// Returns the InputConversion object, which contains the format options for the inbound transformation.
        public let inputConversion: InputConversion?
        /// Returns the structure that contains the mapping template and its language (either XSLT or JSONATA).
        public let mapping: Mapping?
        /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
        public let mappingTemplate: String?
        /// Returns the name of the transformer, used to identify it.
        public let name: String
        /// Returns the OutputConversion object, which contains the format options for the outbound transformation.
        public let outputConversion: OutputConversion?
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Returns a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
        public let sampleDocuments: SampleDocuments?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        public let status: TransformerStatus
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let transformerArn: String
        /// Returns the system-assigned unique identifier for the transformer.
        public let transformerId: String

        @inlinable
        public init(createdAt: Date, inputConversion: InputConversion? = nil, mapping: Mapping? = nil, name: String, outputConversion: OutputConversion? = nil, sampleDocuments: SampleDocuments? = nil, status: TransformerStatus, transformerArn: String, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = nil
            self.fileFormat = nil
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = nil
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = nil
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerArn = transformerArn
            self.transformerId = transformerId
        }

        @available(*, deprecated, message: "Members ediType, fileFormat, mappingTemplate, sampleDocument have been deprecated")
        @inlinable
        public init(createdAt: Date, ediType: EdiType? = nil, fileFormat: FileFormat? = nil, inputConversion: InputConversion? = nil, mapping: Mapping? = nil, mappingTemplate: String? = nil, name: String, outputConversion: OutputConversion? = nil, sampleDocument: String? = nil, sampleDocuments: SampleDocuments? = nil, status: TransformerStatus, transformerArn: String, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = mappingTemplate
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = sampleDocument
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerArn = transformerArn
            self.transformerId = transformerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case inputConversion = "inputConversion"
            case mapping = "mapping"
            case mappingTemplate = "mappingTemplate"
            case name = "name"
            case outputConversion = "outputConversion"
            case sampleDocument = "sampleDocument"
            case sampleDocuments = "sampleDocuments"
            case status = "status"
            case transformerArn = "transformerArn"
            case transformerId = "transformerId"
        }
    }

    public struct DeleteCapabilityRequest: AWSEncodableShape {
        /// Specifies a system-assigned unique identifier for the capability.
        public let capabilityId: String

        @inlinable
        public init(capabilityId: String) {
            self.capabilityId = capabilityId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capabilityId, key: "capabilityId")
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, max: 64)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, min: 1)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePartnershipRequest: AWSEncodableShape {
        /// Specifies the unique, system-generated identifier for a partnership.
        public let partnershipId: String

        @inlinable
        public init(partnershipId: String) {
            self.partnershipId = partnershipId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.partnershipId, key: "partnershipId")
        }

        public func validate(name: String) throws {
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, max: 64)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, min: 1)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProfileRequest: AWSEncodableShape {
        /// Specifies the unique, system-generated identifier for the profile.
        public let profileId: String

        @inlinable
        public init(profileId: String) {
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profileId, key: "profileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.profileId, name: "profileId", parent: name, max: 64)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTransformerRequest: AWSEncodableShape {
        /// Specifies the system-assigned unique identifier for the transformer.
        public let transformerId: String

        @inlinable
        public init(transformerId: String) {
            self.transformerId = transformerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.transformerId, key: "transformerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct EdiConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether this is capability is for inbound or outbound transformations.
        public let capabilityDirection: CapabilityDirection?
        /// Contains the Amazon S3 bucket and prefix for the location of the input file, which is contained in an S3Location object.
        public let inputLocation: S3Location
        /// Contains the Amazon S3 bucket and prefix for the location of the output file, which is contained in an S3Location object.
        public let outputLocation: S3Location
        /// Returns the system-assigned unique identifier for the transformer.
        public let transformerId: String
        /// Returns the type of the capability. Currently, only edi is supported.
        public let type: EdiType

        @inlinable
        public init(capabilityDirection: CapabilityDirection? = nil, inputLocation: S3Location, outputLocation: S3Location, transformerId: String, type: EdiType) {
            self.capabilityDirection = capabilityDirection
            self.inputLocation = inputLocation
            self.outputLocation = outputLocation
            self.transformerId = transformerId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.inputLocation.validate(name: "\(name).inputLocation")
            try self.outputLocation.validate(name: "\(name).outputLocation")
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityDirection = "capabilityDirection"
            case inputLocation = "inputLocation"
            case outputLocation = "outputLocation"
            case transformerId = "transformerId"
            case type = "type"
        }
    }

    public struct GenerateMappingRequest: AWSEncodableShape {
        /// Provide the contents of a sample X12 EDI file (for inbound EDI) or JSON/XML file (for outbound EDI) to use as a starting point for the mapping.
        public let inputFileContent: String
        /// Specify the mapping type: either JSONATA or XSLT.
        public let mappingType: MappingType
        /// Provide the contents of a sample X12 EDI file (for outbound EDI) or JSON/XML file (for inbound EDI) to use as a target for the mapping.
        public let outputFileContent: String

        @inlinable
        public init(inputFileContent: String, mappingType: MappingType, outputFileContent: String) {
            self.inputFileContent = inputFileContent
            self.mappingType = mappingType
            self.outputFileContent = outputFileContent
        }

        public func validate(name: String) throws {
            try self.validate(self.inputFileContent, name: "inputFileContent", parent: name, max: 5000000)
            try self.validate(self.outputFileContent, name: "outputFileContent", parent: name, max: 5000000)
        }

        private enum CodingKeys: String, CodingKey {
            case inputFileContent = "inputFileContent"
            case mappingType = "mappingType"
            case outputFileContent = "outputFileContent"
        }
    }

    public struct GenerateMappingResponse: AWSDecodableShape {
        /// Returns a percentage that estimates the accuracy of the generated mapping.
        public let mappingAccuracy: Float?
        /// Returns a mapping template based on your inputs.
        public let mappingTemplate: String

        @inlinable
        public init(mappingAccuracy: Float? = nil, mappingTemplate: String) {
            self.mappingAccuracy = mappingAccuracy
            self.mappingTemplate = mappingTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case mappingAccuracy = "mappingAccuracy"
            case mappingTemplate = "mappingTemplate"
        }
    }

    public struct GetCapabilityRequest: AWSEncodableShape {
        /// Specifies a system-assigned unique identifier for the capability.
        public let capabilityId: String

        @inlinable
        public init(capabilityId: String) {
            self.capabilityId = capabilityId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capabilityId, key: "capabilityId")
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, max: 64)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, min: 1)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCapabilityResponse: AWSDecodableShape {
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let capabilityArn: String
        /// Returns a system-assigned unique identifier for the capability.
        public let capabilityId: String
        /// Returns a structure that contains the details for a capability.
        public let configuration: CapabilityConfiguration
        /// Returns a timestamp for creation date and time of the capability.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
        public let instructionsDocuments: [S3Location]?
        /// Returns a timestamp for last time the capability was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the capability, used to identify it.
        public let name: String
        /// Returns the type of the capability. Currently, only edi is supported.
        public let type: CapabilityType

        @inlinable
        public init(capabilityArn: String, capabilityId: String, configuration: CapabilityConfiguration, createdAt: Date, instructionsDocuments: [S3Location]? = nil, modifiedAt: Date? = nil, name: String, type: CapabilityType) {
            self.capabilityArn = capabilityArn
            self.capabilityId = capabilityId
            self.configuration = configuration
            self.createdAt = createdAt
            self.instructionsDocuments = instructionsDocuments
            self.modifiedAt = modifiedAt
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityArn = "capabilityArn"
            case capabilityId = "capabilityId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case instructionsDocuments = "instructionsDocuments"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case type = "type"
        }
    }

    public struct GetPartnershipRequest: AWSEncodableShape {
        /// Specifies the unique, system-generated identifier for a partnership.
        public let partnershipId: String

        @inlinable
        public init(partnershipId: String) {
            self.partnershipId = partnershipId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.partnershipId, key: "partnershipId")
        }

        public func validate(name: String) throws {
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, max: 64)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, min: 1)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPartnershipResponse: AWSDecodableShape {
        /// Returns one or more capabilities associated with this partnership.
        public let capabilities: [String]?
        public let capabilityOptions: CapabilityOptions?
        /// Returns a timestamp for creation date and time of the partnership.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this trading partner.
        public let email: String?
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the display name of the partnership
        public let name: String?
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let partnershipArn: String
        /// Returns the unique, system-generated identifier for a partnership.
        public let partnershipId: String
        /// Returns the phone number associated with the partnership.
        public let phone: String?
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String
        /// Returns the unique identifier for the partner for this partnership.
        public let tradingPartnerId: String?

        @inlinable
        public init(capabilities: [String]? = nil, capabilityOptions: CapabilityOptions? = nil, createdAt: Date, email: String? = nil, modifiedAt: Date? = nil, name: String? = nil, partnershipArn: String, partnershipId: String, phone: String? = nil, profileId: String, tradingPartnerId: String? = nil) {
            self.capabilities = capabilities
            self.capabilityOptions = capabilityOptions
            self.createdAt = createdAt
            self.email = email
            self.modifiedAt = modifiedAt
            self.name = name
            self.partnershipArn = partnershipArn
            self.partnershipId = partnershipId
            self.phone = phone
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case capabilityOptions = "capabilityOptions"
            case createdAt = "createdAt"
            case email = "email"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case partnershipArn = "partnershipArn"
            case partnershipId = "partnershipId"
            case phone = "phone"
            case profileId = "profileId"
            case tradingPartnerId = "tradingPartnerId"
        }
    }

    public struct GetProfileRequest: AWSEncodableShape {
        /// Specifies the unique, system-generated identifier for the profile.
        public let profileId: String

        @inlinable
        public init(profileId: String) {
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profileId, key: "profileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.profileId, name: "profileId", parent: name, max: 64)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProfileResponse: AWSDecodableShape {
        /// Returns the name for the business associated with this profile.
        public let businessName: String
        /// Returns a timestamp for creation date and time of the transformer.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this customer profile.
        public let email: String?
        /// Returns whether or not logging is enabled for this profile.
        public let logging: Logging?
        /// Returns the name of the logging group.
        public let logGroupName: String?
        /// Returns a timestamp for last time the profile was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the profile, used to identify it.
        public let name: String
        /// Returns the phone number associated with the profile.
        public let phone: String
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let profileArn: String
        /// Returns the unique, system-generated identifier for the profile.
        public let profileId: String

        @inlinable
        public init(businessName: String, createdAt: Date, email: String? = nil, logging: Logging? = nil, logGroupName: String? = nil, modifiedAt: Date? = nil, name: String, phone: String, profileArn: String, profileId: String) {
            self.businessName = businessName
            self.createdAt = createdAt
            self.email = email
            self.logging = logging
            self.logGroupName = logGroupName
            self.modifiedAt = modifiedAt
            self.name = name
            self.phone = phone
            self.profileArn = profileArn
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case createdAt = "createdAt"
            case email = "email"
            case logging = "logging"
            case logGroupName = "logGroupName"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case phone = "phone"
            case profileArn = "profileArn"
            case profileId = "profileId"
        }
    }

    public struct GetTransformerJobRequest: AWSEncodableShape {
        /// Specifies the system-assigned unique identifier for the transformer.
        public let transformerId: String
        /// Specifies the unique, system-generated identifier for a transformer run.
        public let transformerJobId: String

        @inlinable
        public init(transformerId: String, transformerJobId: String) {
            self.transformerId = transformerId
            self.transformerJobId = transformerJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.transformerId, key: "transformerId")
            request.encodePath(self.transformerJobId, key: "transformerJobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.transformerJobId, name: "transformerJobId", parent: name, max: 25)
            try self.validate(self.transformerJobId, name: "transformerJobId", parent: name, min: 25)
            try self.validate(self.transformerJobId, name: "transformerJobId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransformerJobResponse: AWSDecodableShape {
        /// Returns an optional error message, which gets populated when the job is not run successfully.
        public let message: String?
        /// Returns the location for the output files. If the caller specified a directory for the output, then this contains the full path to the output file, including the file name generated by the service.
        public let outputFiles: [S3Location]?
        /// Returns the current state of the transformer job, either running, succeeded, or failed.
        public let status: TransformerJobStatus

        @inlinable
        public init(message: String? = nil, outputFiles: [S3Location]? = nil, status: TransformerJobStatus) {
            self.message = message
            self.outputFiles = outputFiles
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case outputFiles = "outputFiles"
            case status = "status"
        }
    }

    public struct GetTransformerRequest: AWSEncodableShape {
        /// Specifies the system-assigned unique identifier for the transformer.
        public let transformerId: String

        @inlinable
        public init(transformerId: String) {
            self.transformerId = transformerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.transformerId, key: "transformerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransformerResponse: AWSDecodableShape {
        /// Returns a timestamp for creation date and time of the transformer.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType?
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat?
        /// Returns the InputConversion object, which contains the format options for the inbound transformation.
        public let inputConversion: InputConversion?
        /// Returns the structure that contains the mapping template and its language (either XSLT or JSONATA).
        public let mapping: Mapping?
        /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
        public let mappingTemplate: String?
        /// Returns a timestamp for last time the transformer was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the transformer, used to identify it.
        public let name: String
        /// Returns the OutputConversion object, which contains the format options for the outbound transformation.
        public let outputConversion: OutputConversion?
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Returns a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
        public let sampleDocuments: SampleDocuments?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        public let status: TransformerStatus
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let transformerArn: String
        /// Returns the system-assigned unique identifier for the transformer.
        public let transformerId: String

        @inlinable
        public init(createdAt: Date, inputConversion: InputConversion? = nil, mapping: Mapping? = nil, modifiedAt: Date? = nil, name: String, outputConversion: OutputConversion? = nil, sampleDocuments: SampleDocuments? = nil, status: TransformerStatus, transformerArn: String, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = nil
            self.fileFormat = nil
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = nil
            self.modifiedAt = modifiedAt
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = nil
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerArn = transformerArn
            self.transformerId = transformerId
        }

        @available(*, deprecated, message: "Members ediType, fileFormat, mappingTemplate, sampleDocument have been deprecated")
        @inlinable
        public init(createdAt: Date, ediType: EdiType? = nil, fileFormat: FileFormat? = nil, inputConversion: InputConversion? = nil, mapping: Mapping? = nil, mappingTemplate: String? = nil, modifiedAt: Date? = nil, name: String, outputConversion: OutputConversion? = nil, sampleDocument: String? = nil, sampleDocuments: SampleDocuments? = nil, status: TransformerStatus, transformerArn: String, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = mappingTemplate
            self.modifiedAt = modifiedAt
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = sampleDocument
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerArn = transformerArn
            self.transformerId = transformerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case inputConversion = "inputConversion"
            case mapping = "mapping"
            case mappingTemplate = "mappingTemplate"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case outputConversion = "outputConversion"
            case sampleDocument = "sampleDocument"
            case sampleDocuments = "sampleDocuments"
            case status = "status"
            case transformerArn = "transformerArn"
            case transformerId = "transformerId"
        }
    }

    public struct InputConversion: AWSEncodableShape & AWSDecodableShape {
        /// A structure that contains the formatting options for an inbound transformer.
        public let formatOptions: FormatOptions?
        /// The format for the transformer input: currently on X12 is supported.
        public let fromFormat: FromFormat

        @inlinable
        public init(formatOptions: FormatOptions? = nil, fromFormat: FromFormat) {
            self.formatOptions = formatOptions
            self.fromFormat = fromFormat
        }

        private enum CodingKeys: String, CodingKey {
            case formatOptions = "formatOptions"
            case fromFormat = "fromFormat"
        }
    }

    public struct ListCapabilitiesRequest: AWSEncodableShape {
        /// Specifies the maximum number of capabilities to return.
        public let maxResults: Int?
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCapabilitiesResponse: AWSDecodableShape {
        /// Returns one or more capabilities associated with this partnership.
        public let capabilities: [CapabilitySummary]
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?

        @inlinable
        public init(capabilities: [CapabilitySummary], nextToken: String? = nil) {
            self.capabilities = capabilities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case nextToken = "nextToken"
        }
    }

    public struct ListPartnershipsRequest: AWSEncodableShape {
        /// Specifies the maximum number of capabilities to return.
        public let maxResults: Int?
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?
        /// Specifies the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, profileId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.profileId, key: "profileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, max: 64)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPartnershipsResponse: AWSDecodableShape {
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?
        /// Specifies a list of your partnerships.
        public let partnerships: [PartnershipSummary]

        @inlinable
        public init(nextToken: String? = nil, partnerships: [PartnershipSummary]) {
            self.nextToken = nextToken
            self.partnerships = partnerships
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case partnerships = "partnerships"
        }
    }

    public struct ListProfilesRequest: AWSEncodableShape {
        /// Specifies the maximum number of profiles to return.
        public let maxResults: Int?
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfilesResponse: AWSDecodableShape {
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?
        /// Returns an array of ProfileSummary objects.
        public let profiles: [ProfileSummary]

        @inlinable
        public init(nextToken: String? = nil, profiles: [ProfileSummary]) {
            self.nextToken = nextToken
            self.profiles = profiles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case profiles = "profiles"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an identifier for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "ResourceARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Returns the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListTransformersRequest: AWSEncodableShape {
        /// Specifies the number of items to return for the API response.
        public let maxResults: Int?
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTransformersResponse: AWSDecodableShape {
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?
        /// Returns an array of one or more transformer objects. For each transformer, a TransformerSummary object is returned. The TransformerSummary contains all the details for a specific transformer.
        public let transformers: [TransformerSummary]

        @inlinable
        public init(nextToken: String? = nil, transformers: [TransformerSummary]) {
            self.nextToken = nextToken
            self.transformers = transformers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case transformers = "transformers"
        }
    }

    public struct Mapping: AWSEncodableShape & AWSDecodableShape {
        /// A string that represents the mapping template, in the transformation language specified in templateLanguage.
        public let template: String?
        /// The transformation language for the template, either XSLT or JSONATA.
        public let templateLanguage: MappingTemplateLanguage

        @inlinable
        public init(template: String? = nil, templateLanguage: MappingTemplateLanguage) {
            self.template = template
            self.templateLanguage = templateLanguage
        }

        public func validate(name: String) throws {
            try self.validate(self.template, name: "template", parent: name, max: 350000)
        }

        private enum CodingKeys: String, CodingKey {
            case template = "template"
            case templateLanguage = "templateLanguage"
        }
    }

    public struct OutputConversion: AWSEncodableShape & AWSDecodableShape {
        /// A structure that contains the X12 transaction set and version for the transformer output.
        public let formatOptions: FormatOptions?
        /// The format for the output from an outbound transformer: only X12 is currently supported.
        public let toFormat: ToFormat

        @inlinable
        public init(formatOptions: FormatOptions? = nil, toFormat: ToFormat) {
            self.formatOptions = formatOptions
            self.toFormat = toFormat
        }

        private enum CodingKeys: String, CodingKey {
            case formatOptions = "formatOptions"
            case toFormat = "toFormat"
        }
    }

    public struct PartnershipSummary: AWSDecodableShape {
        /// Returns one or more capabilities associated with this partnership.
        public let capabilities: [String]?
        public let capabilityOptions: CapabilityOptions?
        /// Returns a timestamp for creation date and time of the partnership.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the partnership.
        public let name: String?
        /// Returns the unique, system-generated identifier for a partnership.
        public let partnershipId: String
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String
        /// Returns the unique, system-generated identifier for a trading partner.
        public let tradingPartnerId: String?

        @inlinable
        public init(capabilities: [String]? = nil, capabilityOptions: CapabilityOptions? = nil, createdAt: Date, modifiedAt: Date? = nil, name: String? = nil, partnershipId: String, profileId: String, tradingPartnerId: String? = nil) {
            self.capabilities = capabilities
            self.capabilityOptions = capabilityOptions
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.partnershipId = partnershipId
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case capabilityOptions = "capabilityOptions"
            case createdAt = "createdAt"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case partnershipId = "partnershipId"
            case profileId = "profileId"
            case tradingPartnerId = "tradingPartnerId"
        }
    }

    public struct ProfileSummary: AWSDecodableShape {
        /// Returns the name for the business associated with this profile.
        public let businessName: String
        /// Returns the timestamp for creation date and time of the profile.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Specifies whether or not logging is enabled for this profile.
        public let logging: Logging?
        /// Returns the name of the logging group.
        public let logGroupName: String?
        /// Returns the timestamp that identifies the most recent date and time that the profile was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the display name for profile.
        public let name: String
        /// Returns the unique, system-generated identifier for the profile.
        public let profileId: String

        @inlinable
        public init(businessName: String, createdAt: Date, logging: Logging? = nil, logGroupName: String? = nil, modifiedAt: Date? = nil, name: String, profileId: String) {
            self.businessName = businessName
            self.createdAt = createdAt
            self.logging = logging
            self.logGroupName = logGroupName
            self.modifiedAt = modifiedAt
            self.name = name
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case createdAt = "createdAt"
            case logging = "logging"
            case logGroupName = "logGroupName"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case profileId = "profileId"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the name of the Amazon S3 bucket.
        public let bucketName: String?
        /// Specifies the Amazon S3 key for the file location.
        public let key: String?

        @inlinable
        public init(bucketName: String? = nil, key: String? = nil) {
            self.bucketName = bucketName
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.key, name: "key", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case key = "key"
        }
    }

    public struct SampleDocumentKeys: AWSEncodableShape & AWSDecodableShape {
        /// An array of keys for your input sample documents.
        public let input: String?
        /// An array of keys for your output sample documents.
        public let output: String?

        @inlinable
        public init(input: String? = nil, output: String? = nil) {
            self.input = input
            self.output = output
        }

        public func validate(name: String) throws {
            try self.validate(self.input, name: "input", parent: name, max: 1024)
            try self.validate(self.output, name: "output", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case output = "output"
        }
    }

    public struct SampleDocuments: AWSEncodableShape & AWSDecodableShape {
        /// Contains the Amazon S3 bucket that is used to hold your sample documents.
        public let bucketName: String
        /// Contains an array of the Amazon S3 keys used to identify the location for your sample documents.
        public let keys: [SampleDocumentKeys]

        @inlinable
        public init(bucketName: String, keys: [SampleDocumentKeys]) {
            self.bucketName = bucketName
            self.keys = keys
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.keys.forEach {
                try $0.validate(name: "\(name).keys[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case keys = "keys"
        }
    }

    public struct StartTransformerJobRequest: AWSEncodableShape {
        /// Reserved for future use.
        public let clientToken: String?
        /// Specifies the location of the input file for the transformation. The location consists of an Amazon S3 bucket and prefix.
        public let inputFile: S3Location
        /// Specifies the location of the output file for the transformation. The location consists of an Amazon S3 bucket and prefix.
        public let outputLocation: S3Location
        /// Specifies the system-assigned unique identifier for the transformer.
        public let transformerId: String

        @inlinable
        public init(clientToken: String? = StartTransformerJobRequest.idempotencyToken(), inputFile: S3Location, outputLocation: S3Location, transformerId: String) {
            self.clientToken = clientToken
            self.inputFile = inputFile
            self.outputLocation = outputLocation
            self.transformerId = transformerId
        }

        public func validate(name: String) throws {
            try self.inputFile.validate(name: "\(name).inputFile")
            try self.outputLocation.validate(name: "\(name).outputLocation")
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case inputFile = "inputFile"
            case outputLocation = "outputLocation"
            case transformerId = "transformerId"
        }
    }

    public struct StartTransformerJobResponse: AWSDecodableShape {
        /// Returns the unique, system-generated identifier for a transformer run.
        public let transformerJobId: String

        @inlinable
        public init(transformerJobId: String) {
            self.transformerJobId = transformerJobId
        }

        private enum CodingKeys: String, CodingKey {
            case transformerJobId = "transformerJobId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the name assigned to the tag that you create.
        public let key: String
        /// Contains one or more values that you assigned to the key name that you create.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Specifies an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let resourceARN: String
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "ResourceARN")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TestConversionRequest: AWSEncodableShape {
        /// Specify the source file for an outbound EDI request.
        public let source: ConversionSource
        /// Specify the format (X12 is the only currently supported format), and other details for the conversion target.
        public let target: ConversionTarget

        @inlinable
        public init(source: ConversionSource, target: ConversionTarget) {
            self.source = source
            self.target = target
        }

        public func validate(name: String) throws {
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case target = "target"
        }
    }

    public struct TestConversionResponse: AWSDecodableShape {
        /// Returns the converted file content.
        public let convertedFileContent: String
        /// Returns an array of strings, each containing a message that Amazon Web Services B2B Data Interchange generates during the conversion.
        public let validationMessages: [String]?

        @inlinable
        public init(convertedFileContent: String, validationMessages: [String]? = nil) {
            self.convertedFileContent = convertedFileContent
            self.validationMessages = validationMessages
        }

        private enum CodingKeys: String, CodingKey {
            case convertedFileContent = "convertedFileContent"
            case validationMessages = "validationMessages"
        }
    }

    public struct TestMappingRequest: AWSEncodableShape {
        /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat
        /// Specify the contents of the EDI (electronic data interchange) XML or JSON file that is used as input for the transform.
        public let inputFileContent: String
        /// Specifies the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.  This parameter is available for backwards compatibility. Use the Mapping data type instead.
        public let mappingTemplate: String

        @inlinable
        public init(fileFormat: FileFormat, inputFileContent: String, mappingTemplate: String) {
            self.fileFormat = fileFormat
            self.inputFileContent = inputFileContent
            self.mappingTemplate = mappingTemplate
        }

        public func validate(name: String) throws {
            try self.validate(self.inputFileContent, name: "inputFileContent", parent: name, max: 5000000)
            try self.validate(self.mappingTemplate, name: "mappingTemplate", parent: name, max: 350000)
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormat = "fileFormat"
            case inputFileContent = "inputFileContent"
            case mappingTemplate = "mappingTemplate"
        }
    }

    public struct TestMappingResponse: AWSDecodableShape {
        /// Returns a string for the mapping that can be used to identify the mapping. Similar to a fingerprint
        public let mappedFileContent: String

        @inlinable
        public init(mappedFileContent: String) {
            self.mappedFileContent = mappedFileContent
        }

        private enum CodingKeys: String, CodingKey {
            case mappedFileContent = "mappedFileContent"
        }
    }

    public struct TestParsingRequest: AWSEncodableShape {
        /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType
        /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat
        /// Specifies an S3Location object, which contains the Amazon S3 bucket and prefix for the location of the input file.
        public let inputFile: S3Location

        @inlinable
        public init(ediType: EdiType, fileFormat: FileFormat, inputFile: S3Location) {
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.inputFile = inputFile
        }

        public func validate(name: String) throws {
            try self.inputFile.validate(name: "\(name).inputFile")
        }

        private enum CodingKeys: String, CodingKey {
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case inputFile = "inputFile"
        }
    }

    public struct TestParsingResponse: AWSDecodableShape {
        /// Returns the contents of the input file being tested, parsed according to the specified EDI (electronic data interchange) type.
        public let parsedFileContent: String

        @inlinable
        public init(parsedFileContent: String) {
            self.parsedFileContent = parsedFileContent
        }

        private enum CodingKeys: String, CodingKey {
            case parsedFileContent = "parsedFileContent"
        }
    }

    public struct TransformerSummary: AWSDecodableShape {
        /// Returns a timestamp indicating when the transformer was created. For example, 2023-07-20T19:58:44.624Z.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType?
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat?
        /// Returns a structure that contains the format options for the transformation.
        public let inputConversion: InputConversion?
        /// Returns the structure that contains the mapping template and its language (either XSLT or JSONATA).
        public let mapping: Mapping?
        /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
        public let mappingTemplate: String?
        /// Returns a timestamp representing the date and time for the most recent change for the transformer object.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the descriptive name for the transformer.
        public let name: String
        /// Returns the OutputConversion object, which contains the format options for the outbound transformation.
        public let outputConversion: OutputConversion?
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Returns a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
        public let sampleDocuments: SampleDocuments?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        public let status: TransformerStatus
        /// Returns the system-assigned unique identifier for the transformer.
        public let transformerId: String

        @inlinable
        public init(createdAt: Date, inputConversion: InputConversion? = nil, mapping: Mapping? = nil, modifiedAt: Date? = nil, name: String, outputConversion: OutputConversion? = nil, sampleDocuments: SampleDocuments? = nil, status: TransformerStatus, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = nil
            self.fileFormat = nil
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = nil
            self.modifiedAt = modifiedAt
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = nil
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerId = transformerId
        }

        @available(*, deprecated, message: "Members ediType, fileFormat, mappingTemplate, sampleDocument have been deprecated")
        @inlinable
        public init(createdAt: Date, ediType: EdiType? = nil, fileFormat: FileFormat? = nil, inputConversion: InputConversion? = nil, mapping: Mapping? = nil, mappingTemplate: String? = nil, modifiedAt: Date? = nil, name: String, outputConversion: OutputConversion? = nil, sampleDocument: String? = nil, sampleDocuments: SampleDocuments? = nil, status: TransformerStatus, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = mappingTemplate
            self.modifiedAt = modifiedAt
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = sampleDocument
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerId = transformerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case inputConversion = "inputConversion"
            case mapping = "mapping"
            case mappingTemplate = "mappingTemplate"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case outputConversion = "outputConversion"
            case sampleDocument = "sampleDocument"
            case sampleDocuments = "sampleDocuments"
            case status = "status"
            case transformerId = "transformerId"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Specifies an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let resourceARN: String
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "ResourceARN")
            request.encodeQuery(self.tagKeys, key: "TagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateCapabilityRequest: AWSEncodableShape {
        /// Specifies a system-assigned unique identifier for the capability.
        public let capabilityId: String
        /// Specifies a structure that contains the details for a capability.
        public let configuration: CapabilityConfiguration?
        /// Specifies one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
        public let instructionsDocuments: [S3Location]?
        /// Specifies a new name for the capability, to replace the existing name.
        public let name: String?

        @inlinable
        public init(capabilityId: String, configuration: CapabilityConfiguration? = nil, instructionsDocuments: [S3Location]? = nil, name: String? = nil) {
            self.capabilityId = capabilityId
            self.configuration = configuration
            self.instructionsDocuments = instructionsDocuments
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capabilityId, key: "capabilityId")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.instructionsDocuments, forKey: .instructionsDocuments)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, max: 64)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, min: 1)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.instructionsDocuments?.forEach {
                try $0.validate(name: "\(name).instructionsDocuments[]")
            }
            try self.validate(self.instructionsDocuments, name: "instructionsDocuments", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case instructionsDocuments = "instructionsDocuments"
            case name = "name"
        }
    }

    public struct UpdateCapabilityResponse: AWSDecodableShape {
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let capabilityArn: String
        /// Returns a system-assigned unique identifier for the capability.
        public let capabilityId: String
        /// Returns a structure that contains the details for a capability.
        public let configuration: CapabilityConfiguration
        /// Returns a timestamp for creation date and time of the capability.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
        public let instructionsDocuments: [S3Location]?
        /// Returns a timestamp for last time the capability was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the capability, used to identify it.
        public let name: String
        /// Returns the type of the capability. Currently, only edi is supported.
        public let type: CapabilityType

        @inlinable
        public init(capabilityArn: String, capabilityId: String, configuration: CapabilityConfiguration, createdAt: Date, instructionsDocuments: [S3Location]? = nil, modifiedAt: Date? = nil, name: String, type: CapabilityType) {
            self.capabilityArn = capabilityArn
            self.capabilityId = capabilityId
            self.configuration = configuration
            self.createdAt = createdAt
            self.instructionsDocuments = instructionsDocuments
            self.modifiedAt = modifiedAt
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityArn = "capabilityArn"
            case capabilityId = "capabilityId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case instructionsDocuments = "instructionsDocuments"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case type = "type"
        }
    }

    public struct UpdatePartnershipRequest: AWSEncodableShape {
        /// List of the capabilities associated with this partnership.
        public let capabilities: [String]?
        /// To update, specify the structure that contains the details for the associated capabilities.
        public let capabilityOptions: CapabilityOptions?
        /// The name of the partnership, used to identify it.
        public let name: String?
        /// Specifies the unique, system-generated identifier for a partnership.
        public let partnershipId: String

        @inlinable
        public init(capabilities: [String]? = nil, capabilityOptions: CapabilityOptions? = nil, name: String? = nil, partnershipId: String) {
            self.capabilities = capabilities
            self.capabilityOptions = capabilityOptions
            self.name = name
            self.partnershipId = partnershipId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.capabilities, forKey: .capabilities)
            try container.encodeIfPresent(self.capabilityOptions, forKey: .capabilityOptions)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.partnershipId, key: "partnershipId")
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, max: 64)
                try validate($0, name: "capabilities[]", parent: name, min: 1)
                try validate($0, name: "capabilities[]", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
            try self.capabilityOptions?.validate(name: "\(name).capabilityOptions")
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, max: 64)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, min: 1)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case capabilityOptions = "capabilityOptions"
            case name = "name"
        }
    }

    public struct UpdatePartnershipResponse: AWSDecodableShape {
        /// Returns one or more capabilities associated with this partnership.
        public let capabilities: [String]?
        /// Returns the structure that contains the details for the associated capabilities.
        public let capabilityOptions: CapabilityOptions?
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this trading partner.
        public let email: String?
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// The name of the partnership, used to identify it.
        public let name: String?
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let partnershipArn: String
        /// Returns the unique, system-generated identifier for a partnership.
        public let partnershipId: String
        /// Returns the phone number associated with the partnership.
        public let phone: String?
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String
        /// Returns the unique, system-generated identifier for a trading partner.
        public let tradingPartnerId: String?

        @inlinable
        public init(capabilities: [String]? = nil, capabilityOptions: CapabilityOptions? = nil, createdAt: Date, email: String? = nil, modifiedAt: Date? = nil, name: String? = nil, partnershipArn: String, partnershipId: String, phone: String? = nil, profileId: String, tradingPartnerId: String? = nil) {
            self.capabilities = capabilities
            self.capabilityOptions = capabilityOptions
            self.createdAt = createdAt
            self.email = email
            self.modifiedAt = modifiedAt
            self.name = name
            self.partnershipArn = partnershipArn
            self.partnershipId = partnershipId
            self.phone = phone
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case capabilityOptions = "capabilityOptions"
            case createdAt = "createdAt"
            case email = "email"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case partnershipArn = "partnershipArn"
            case partnershipId = "partnershipId"
            case phone = "phone"
            case profileId = "profileId"
            case tradingPartnerId = "tradingPartnerId"
        }
    }

    public struct UpdateProfileRequest: AWSEncodableShape {
        /// Specifies the name for the business associated with this profile.
        public let businessName: String?
        /// Specifies the email address associated with this customer profile.
        public let email: String?
        /// The name of the profile, used to identify it.
        public let name: String?
        /// Specifies the phone number associated with the profile.
        public let phone: String?
        /// Specifies the unique, system-generated identifier for the profile.
        public let profileId: String

        @inlinable
        public init(businessName: String? = nil, email: String? = nil, name: String? = nil, phone: String? = nil, profileId: String) {
            self.businessName = businessName
            self.email = email
            self.name = name
            self.phone = phone
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.businessName, forKey: .businessName)
            try container.encodeIfPresent(self.email, forKey: .email)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.phone, forKey: .phone)
            request.encodePath(self.profileId, key: "profileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.businessName, name: "businessName", parent: name, max: 254)
            try self.validate(self.businessName, name: "businessName", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, max: 254)
            try self.validate(self.email, name: "email", parent: name, min: 5)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[\\w\\.\\-]+@[\\w\\.\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.phone, name: "phone", parent: name, max: 22)
            try self.validate(self.phone, name: "phone", parent: name, min: 7)
            try self.validate(self.phone, name: "phone", parent: name, pattern: "^\\+?([0-9 \\t\\-()\\/]{7,})(?:\\s*(?:#|x\\.?|ext\\.?|extension) \\t*(\\d+))?$")
            try self.validate(self.profileId, name: "profileId", parent: name, max: 64)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case email = "email"
            case name = "name"
            case phone = "phone"
        }
    }

    public struct UpdateProfileResponse: AWSDecodableShape {
        /// Returns the name for the business associated with this profile.
        public let businessName: String
        /// Returns a timestamp for creation date and time of the profile.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this customer profile.
        public let email: String?
        /// Specifies whether or not logging is enabled for this profile.
        public let logging: Logging?
        /// Returns the name of the logging group.
        public let logGroupName: String?
        /// Returns a timestamp for last time the profile was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the profile.
        public let name: String
        /// Returns the phone number associated with the profile.
        public let phone: String
        /// Returns an Amazon Resource Name (ARN) for the profile.
        public let profileArn: String
        /// Returns the unique, system-generated identifier for the profile.
        public let profileId: String

        @inlinable
        public init(businessName: String, createdAt: Date, email: String? = nil, logging: Logging? = nil, logGroupName: String? = nil, modifiedAt: Date? = nil, name: String, phone: String, profileArn: String, profileId: String) {
            self.businessName = businessName
            self.createdAt = createdAt
            self.email = email
            self.logging = logging
            self.logGroupName = logGroupName
            self.modifiedAt = modifiedAt
            self.name = name
            self.phone = phone
            self.profileArn = profileArn
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case createdAt = "createdAt"
            case email = "email"
            case logging = "logging"
            case logGroupName = "logGroupName"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case phone = "phone"
            case profileArn = "profileArn"
            case profileId = "profileId"
        }
    }

    public struct UpdateTransformerRequest: AWSEncodableShape {
        /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType?
        /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat?
        /// To update, specify the InputConversion object, which contains the format options for the inbound transformation.
        public let inputConversion: InputConversion?
        /// Specify the structure that contains the mapping template and its language (either XSLT or JSONATA).
        public let mapping: Mapping?
        /// Specifies the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.  This parameter is available for backwards compatibility. Use the Mapping data type instead.
        public let mappingTemplate: String?
        /// Specify a new name for the transformer, if you want to update it.
        public let name: String?
        /// To update, specify the OutputConversion object, which contains the format options for the outbound transformation.
        public let outputConversion: OutputConversion?
        /// Specifies a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Specify a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
        public let sampleDocuments: SampleDocuments?
        /// Specifies the transformer's status. You can update the state of the transformer from inactive to active.
        public let status: TransformerStatus?
        /// Specifies the system-assigned unique identifier for the transformer.
        public let transformerId: String

        @inlinable
        public init(inputConversion: InputConversion? = nil, mapping: Mapping? = nil, name: String? = nil, outputConversion: OutputConversion? = nil, sampleDocuments: SampleDocuments? = nil, status: TransformerStatus? = nil, transformerId: String) {
            self.ediType = nil
            self.fileFormat = nil
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = nil
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = nil
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerId = transformerId
        }

        @available(*, deprecated, message: "Members ediType, fileFormat, mappingTemplate, sampleDocument have been deprecated")
        @inlinable
        public init(ediType: EdiType? = nil, fileFormat: FileFormat? = nil, inputConversion: InputConversion? = nil, mapping: Mapping? = nil, mappingTemplate: String? = nil, name: String? = nil, outputConversion: OutputConversion? = nil, sampleDocument: String? = nil, sampleDocuments: SampleDocuments? = nil, status: TransformerStatus? = nil, transformerId: String) {
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = mappingTemplate
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = sampleDocument
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerId = transformerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.ediType, forKey: .ediType)
            try container.encodeIfPresent(self.fileFormat, forKey: .fileFormat)
            try container.encodeIfPresent(self.inputConversion, forKey: .inputConversion)
            try container.encodeIfPresent(self.mapping, forKey: .mapping)
            try container.encodeIfPresent(self.mappingTemplate, forKey: .mappingTemplate)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.outputConversion, forKey: .outputConversion)
            try container.encodeIfPresent(self.sampleDocument, forKey: .sampleDocument)
            try container.encodeIfPresent(self.sampleDocuments, forKey: .sampleDocuments)
            try container.encodeIfPresent(self.status, forKey: .status)
            request.encodePath(self.transformerId, key: "transformerId")
        }

        public func validate(name: String) throws {
            try self.mapping?.validate(name: "\(name).mapping")
            try self.validate(self.mappingTemplate, name: "mappingTemplate", parent: name, max: 350000)
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]{1,512}$")
            try self.validate(self.sampleDocument, name: "sampleDocument", parent: name, max: 1024)
            try self.sampleDocuments?.validate(name: "\(name).sampleDocuments")
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case inputConversion = "inputConversion"
            case mapping = "mapping"
            case mappingTemplate = "mappingTemplate"
            case name = "name"
            case outputConversion = "outputConversion"
            case sampleDocument = "sampleDocument"
            case sampleDocuments = "sampleDocuments"
            case status = "status"
        }
    }

    public struct UpdateTransformerResponse: AWSDecodableShape {
        /// Returns a timestamp for creation date and time of the transformer.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType?
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat?
        /// Returns the InputConversion object, which contains the format options for the inbound transformation.
        public let inputConversion: InputConversion?
        /// Returns the structure that contains the mapping template and its language (either XSLT or JSONATA).
        public let mapping: Mapping?
        /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
        public let mappingTemplate: String?
        /// Returns a timestamp for last time the transformer was modified.
        @CustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date
        /// Returns the name of the transformer.
        public let name: String
        /// Returns the OutputConversion object, which contains the format options for the outbound transformation.
        public let outputConversion: OutputConversion?
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Returns a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
        public let sampleDocuments: SampleDocuments?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        public let status: TransformerStatus
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let transformerArn: String
        /// Returns the system-assigned unique identifier for the transformer.
        public let transformerId: String

        @inlinable
        public init(createdAt: Date, inputConversion: InputConversion? = nil, mapping: Mapping? = nil, modifiedAt: Date, name: String, outputConversion: OutputConversion? = nil, sampleDocuments: SampleDocuments? = nil, status: TransformerStatus, transformerArn: String, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = nil
            self.fileFormat = nil
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = nil
            self.modifiedAt = modifiedAt
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = nil
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerArn = transformerArn
            self.transformerId = transformerId
        }

        @available(*, deprecated, message: "Members ediType, fileFormat, mappingTemplate, sampleDocument have been deprecated")
        @inlinable
        public init(createdAt: Date, ediType: EdiType? = nil, fileFormat: FileFormat? = nil, inputConversion: InputConversion? = nil, mapping: Mapping? = nil, mappingTemplate: String? = nil, modifiedAt: Date, name: String, outputConversion: OutputConversion? = nil, sampleDocument: String? = nil, sampleDocuments: SampleDocuments? = nil, status: TransformerStatus, transformerArn: String, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = mappingTemplate
            self.modifiedAt = modifiedAt
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = sampleDocument
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerArn = transformerArn
            self.transformerId = transformerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case inputConversion = "inputConversion"
            case mapping = "mapping"
            case mappingTemplate = "mappingTemplate"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case outputConversion = "outputConversion"
            case sampleDocument = "sampleDocument"
            case sampleDocuments = "sampleDocuments"
            case status = "status"
            case transformerArn = "transformerArn"
            case transformerId = "transformerId"
        }
    }

    public struct X12Delimiters: AWSEncodableShape & AWSDecodableShape {
        /// The component, or sub-element, separator. The default value is : (colon).
        public let componentSeparator: String?
        /// The data element separator. The default value is * (asterisk).
        public let dataElementSeparator: String?
        /// The segment terminator. The default value is ~ (tilde).
        public let segmentTerminator: String?

        @inlinable
        public init(componentSeparator: String? = nil, dataElementSeparator: String? = nil, segmentTerminator: String? = nil) {
            self.componentSeparator = componentSeparator
            self.dataElementSeparator = dataElementSeparator
            self.segmentTerminator = segmentTerminator
        }

        public func validate(name: String) throws {
            try self.validate(self.componentSeparator, name: "componentSeparator", parent: name, max: 1)
            try self.validate(self.componentSeparator, name: "componentSeparator", parent: name, min: 1)
            try self.validate(self.componentSeparator, name: "componentSeparator", parent: name, pattern: "^[!&'()*+,\\-./:;?=%@\\[\\]_{}|<>~^`\"]$")
            try self.validate(self.dataElementSeparator, name: "dataElementSeparator", parent: name, max: 1)
            try self.validate(self.dataElementSeparator, name: "dataElementSeparator", parent: name, min: 1)
            try self.validate(self.dataElementSeparator, name: "dataElementSeparator", parent: name, pattern: "^[!&'()*+,\\-./:;?=%@\\[\\]_{}|<>~^`\"]$")
            try self.validate(self.segmentTerminator, name: "segmentTerminator", parent: name, max: 1)
            try self.validate(self.segmentTerminator, name: "segmentTerminator", parent: name, min: 1)
            try self.validate(self.segmentTerminator, name: "segmentTerminator", parent: name, pattern: "^[!&'()*+,\\-./:;?=%@\\[\\]_{}|<>~^`\"]$")
        }

        private enum CodingKeys: String, CodingKey {
            case componentSeparator = "componentSeparator"
            case dataElementSeparator = "dataElementSeparator"
            case segmentTerminator = "segmentTerminator"
        }
    }

    public struct X12Details: AWSEncodableShape & AWSDecodableShape {
        /// Returns an enumerated type where each value identifies an X12 transaction set. Transaction sets are maintained by the X12 Accredited Standards Committee.
        public let transactionSet: X12TransactionSet?
        /// Returns the version to use for the specified X12 transaction set.
        public let version: X12Version?

        @inlinable
        public init(transactionSet: X12TransactionSet? = nil, version: X12Version? = nil) {
            self.transactionSet = transactionSet
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case transactionSet = "transactionSet"
            case version = "version"
        }
    }

    public struct X12Envelope: AWSEncodableShape & AWSDecodableShape {
        /// A container for the X12 outbound EDI headers.
        public let common: X12OutboundEdiHeaders?

        @inlinable
        public init(common: X12OutboundEdiHeaders? = nil) {
            self.common = common
        }

        public func validate(name: String) throws {
            try self.common?.validate(name: "\(name).common")
        }

        private enum CodingKeys: String, CodingKey {
            case common = "common"
        }
    }

    public struct X12FunctionalGroupHeaders: AWSEncodableShape & AWSDecodableShape {
        /// A value representing the code used to identify the party receiving a message, at position GS-03.
        public let applicationReceiverCode: String?
        /// A value representing the code used to identify the party transmitting a message, at position GS-02.
        public let applicationSenderCode: String?
        /// A code that identifies the issuer of the standard, at position GS-07.
        public let responsibleAgencyCode: String?

        @inlinable
        public init(applicationReceiverCode: String? = nil, applicationSenderCode: String? = nil, responsibleAgencyCode: String? = nil) {
            self.applicationReceiverCode = applicationReceiverCode
            self.applicationSenderCode = applicationSenderCode
            self.responsibleAgencyCode = responsibleAgencyCode
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationReceiverCode, name: "applicationReceiverCode", parent: name, max: 15)
            try self.validate(self.applicationReceiverCode, name: "applicationReceiverCode", parent: name, min: 2)
            try self.validate(self.applicationReceiverCode, name: "applicationReceiverCode", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.applicationSenderCode, name: "applicationSenderCode", parent: name, max: 15)
            try self.validate(self.applicationSenderCode, name: "applicationSenderCode", parent: name, min: 2)
            try self.validate(self.applicationSenderCode, name: "applicationSenderCode", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.responsibleAgencyCode, name: "responsibleAgencyCode", parent: name, max: 2)
            try self.validate(self.responsibleAgencyCode, name: "responsibleAgencyCode", parent: name, min: 1)
            try self.validate(self.responsibleAgencyCode, name: "responsibleAgencyCode", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationReceiverCode = "applicationReceiverCode"
            case applicationSenderCode = "applicationSenderCode"
            case responsibleAgencyCode = "responsibleAgencyCode"
        }
    }

    public struct X12InterchangeControlHeaders: AWSEncodableShape & AWSDecodableShape {
        /// Located at position ISA-14 in the header. The value "1" indicates that the sender is requesting an interchange acknowledgment at receipt of the interchange. The value "0" is used otherwise.
        public let acknowledgmentRequestedCode: String?
        /// Located at position ISA-08 in the header. This value (along with the receiverIdQualifier) identifies the intended recipient of the interchange.
        public let receiverId: String?
        /// Located at position ISA-07 in the header. Qualifier for the receiver ID. Together, the ID and qualifier uniquely identify the receiving trading partner.
        public let receiverIdQualifier: String?
        /// Located at position ISA-11 in the header. This string makes it easier when you need to group similar adjacent element values together without using extra segments.  This parameter is only honored for version greater than 401 (VERSION_4010 and higher). For versions less than 401, this field is called StandardsId, in which case our service sets the value to U.
        public let repetitionSeparator: String?
        /// Located at position ISA-06 in the header. This value (along with the senderIdQualifier) identifies the sender of the interchange.
        public let senderId: String?
        /// Located at position ISA-05 in the header. Qualifier for the sender ID. Together, the ID and qualifier uniquely identify the sending trading partner.
        public let senderIdQualifier: String?
        /// Located at position ISA-15 in the header. Specifies how this interchange is being used:    T indicates this interchange is for testing.    P indicates this interchange is for production.    I indicates this interchange is informational.
        public let usageIndicatorCode: String?

        @inlinable
        public init(acknowledgmentRequestedCode: String? = nil, receiverId: String? = nil, receiverIdQualifier: String? = nil, repetitionSeparator: String? = nil, senderId: String? = nil, senderIdQualifier: String? = nil, usageIndicatorCode: String? = nil) {
            self.acknowledgmentRequestedCode = acknowledgmentRequestedCode
            self.receiverId = receiverId
            self.receiverIdQualifier = receiverIdQualifier
            self.repetitionSeparator = repetitionSeparator
            self.senderId = senderId
            self.senderIdQualifier = senderIdQualifier
            self.usageIndicatorCode = usageIndicatorCode
        }

        public func validate(name: String) throws {
            try self.validate(self.acknowledgmentRequestedCode, name: "acknowledgmentRequestedCode", parent: name, max: 1)
            try self.validate(self.acknowledgmentRequestedCode, name: "acknowledgmentRequestedCode", parent: name, min: 1)
            try self.validate(self.acknowledgmentRequestedCode, name: "acknowledgmentRequestedCode", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.receiverId, name: "receiverId", parent: name, max: 15)
            try self.validate(self.receiverId, name: "receiverId", parent: name, min: 15)
            try self.validate(self.receiverId, name: "receiverId", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.receiverIdQualifier, name: "receiverIdQualifier", parent: name, max: 2)
            try self.validate(self.receiverIdQualifier, name: "receiverIdQualifier", parent: name, min: 2)
            try self.validate(self.receiverIdQualifier, name: "receiverIdQualifier", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.repetitionSeparator, name: "repetitionSeparator", parent: name, max: 1)
            try self.validate(self.repetitionSeparator, name: "repetitionSeparator", parent: name, min: 1)
            try self.validate(self.senderId, name: "senderId", parent: name, max: 15)
            try self.validate(self.senderId, name: "senderId", parent: name, min: 15)
            try self.validate(self.senderId, name: "senderId", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.senderIdQualifier, name: "senderIdQualifier", parent: name, max: 2)
            try self.validate(self.senderIdQualifier, name: "senderIdQualifier", parent: name, min: 2)
            try self.validate(self.senderIdQualifier, name: "senderIdQualifier", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.usageIndicatorCode, name: "usageIndicatorCode", parent: name, max: 1)
            try self.validate(self.usageIndicatorCode, name: "usageIndicatorCode", parent: name, min: 1)
            try self.validate(self.usageIndicatorCode, name: "usageIndicatorCode", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case acknowledgmentRequestedCode = "acknowledgmentRequestedCode"
            case receiverId = "receiverId"
            case receiverIdQualifier = "receiverIdQualifier"
            case repetitionSeparator = "repetitionSeparator"
            case senderId = "senderId"
            case senderIdQualifier = "senderIdQualifier"
            case usageIndicatorCode = "usageIndicatorCode"
        }
    }

    public struct X12OutboundEdiHeaders: AWSEncodableShape & AWSDecodableShape {
        /// The delimiters, for example semicolon (;), that separates sections of the headers for the X12 object.
        public let delimiters: X12Delimiters?
        /// The functional group headers for the X12 object.
        public let functionalGroupHeaders: X12FunctionalGroupHeaders?
        /// In X12 EDI messages, delimiters are used to mark the end of segments or elements, and are defined in the interchange control header.
        public let interchangeControlHeaders: X12InterchangeControlHeaders?
        /// Specifies whether or not to validate the EDI for this X12 object: TRUE or FALSE.
        public let validateEdi: Bool?

        @inlinable
        public init(delimiters: X12Delimiters? = nil, functionalGroupHeaders: X12FunctionalGroupHeaders? = nil, interchangeControlHeaders: X12InterchangeControlHeaders? = nil, validateEdi: Bool? = nil) {
            self.delimiters = delimiters
            self.functionalGroupHeaders = functionalGroupHeaders
            self.interchangeControlHeaders = interchangeControlHeaders
            self.validateEdi = validateEdi
        }

        public func validate(name: String) throws {
            try self.delimiters?.validate(name: "\(name).delimiters")
            try self.functionalGroupHeaders?.validate(name: "\(name).functionalGroupHeaders")
            try self.interchangeControlHeaders?.validate(name: "\(name).interchangeControlHeaders")
        }

        private enum CodingKeys: String, CodingKey {
            case delimiters = "delimiters"
            case functionalGroupHeaders = "functionalGroupHeaders"
            case interchangeControlHeaders = "interchangeControlHeaders"
            case validateEdi = "validateEdi"
        }
    }

    public struct CapabilityConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An EDI (electronic data interchange) configuration object.
        public let edi: EdiConfiguration?

        @inlinable
        public init(edi: EdiConfiguration? = nil) {
            self.edi = edi
        }

        public func validate(name: String) throws {
            try self.edi?.validate(name: "\(name).edi")
        }

        private enum CodingKeys: String, CodingKey {
            case edi = "edi"
        }
    }

    public struct ConversionTargetFormatDetails: AWSEncodableShape {
        public let x12: X12Details?

        @inlinable
        public init(x12: X12Details? = nil) {
            self.x12 = x12
        }

        private enum CodingKeys: String, CodingKey {
            case x12 = "x12"
        }
    }

    public struct EdiType: AWSEncodableShape & AWSDecodableShape {
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let x12Details: X12Details?

        @inlinable
        public init(x12Details: X12Details? = nil) {
            self.x12Details = x12Details
        }

        private enum CodingKeys: String, CodingKey {
            case x12Details = "x12Details"
        }
    }

    public struct FormatOptions: AWSEncodableShape & AWSDecodableShape {
        public let x12: X12Details?

        @inlinable
        public init(x12: X12Details? = nil) {
            self.x12 = x12
        }

        private enum CodingKeys: String, CodingKey {
            case x12 = "x12"
        }
    }

    public struct InputFileSource: AWSEncodableShape {
        /// Specify the input contents, as a string, for the source of an outbound transformation.
        public let fileContent: String?

        @inlinable
        public init(fileContent: String? = nil) {
            self.fileContent = fileContent
        }

        private enum CodingKeys: String, CodingKey {
            case fileContent = "fileContent"
        }
    }

    public struct OutboundEdiOptions: AWSEncodableShape & AWSDecodableShape {
        /// A structure that contains an X12 envelope structure.
        public let x12: X12Envelope?

        @inlinable
        public init(x12: X12Envelope? = nil) {
            self.x12 = x12
        }

        public func validate(name: String) throws {
            try self.x12?.validate(name: "\(name).x12")
        }

        private enum CodingKeys: String, CodingKey {
            case x12 = "x12"
        }
    }

    public struct OutputSampleFileSource: AWSEncodableShape {
        public let fileLocation: S3Location?

        @inlinable
        public init(fileLocation: S3Location? = nil) {
            self.fileLocation = fileLocation
        }

        public func validate(name: String) throws {
            try self.fileLocation?.validate(name: "\(name).fileLocation")
        }

        private enum CodingKeys: String, CodingKey {
            case fileLocation = "fileLocation"
        }
    }

    public struct TemplateDetails: AWSEncodableShape {
        public let x12: X12Details?

        @inlinable
        public init(x12: X12Details? = nil) {
            self.x12 = x12
        }

        private enum CodingKeys: String, CodingKey {
            case x12 = "x12"
        }
    }
}

// MARK: - Errors

/// Error enum for B2bi
public struct B2biErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize B2bi
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A conflict exception is thrown when you attempt to delete a resource (such as a profile or a capability) that is being used by other resources.
    public static var conflictException: Self { .init(.conflictException) }
    /// This exception is thrown when an error occurs in the Amazon Web Services B2B Data Interchange service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Occurs when the requested resource does not exist, or cannot be found. In some cases, the resource exists in a region other than the region specified in the API call.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Occurs when the calling command attempts to exceed one of the service quotas, for example trying to create a capability when you already have the maximum number of capabilities allowed.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to throttling: the data speed and rendering may be limited depending on various parameters and conditions.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Occurs when a B2BI object cannot be validated against a request from another object.
    public static var validationException: Self { .init(.validationException) }
}

extension B2biErrorType: Equatable {
    public static func == (lhs: B2biErrorType, rhs: B2biErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension B2biErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
