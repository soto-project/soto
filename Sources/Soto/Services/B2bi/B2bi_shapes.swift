//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension B2bi {
    // MARK: Enums

    public enum CapabilityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case edi = "edi"
        public var description: String { return self.rawValue }
    }

    public enum FileFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case xml = "XML"
        public var description: String { return self.rawValue }
    }

    public enum Logging: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum TransformerJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "failed"
        case running = "running"
        case succeeded = "succeeded"
        public var description: String { return self.rawValue }
    }

    public enum TransformerStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "active"
        case inactive = "inactive"
        public var description: String { return self.rawValue }
    }

    public enum X12TransactionSet: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case x12110 = "X12_110"
        case x12180 = "X12_180"
        case x12204 = "X12_204"
        case x12210 = "X12_210"
        case x12211 = "X12_211"
        case x12214 = "X12_214"
        case x12215 = "X12_215"
        case x12259 = "X12_259"
        case x12260 = "X12_260"
        case x12266 = "X12_266"
        case x12269 = "X12_269"
        case x12270 = "X12_270"
        case x12270X279 = "X12_270_X279"
        case x12271 = "X12_271"
        case x12271X279 = "X12_271_X279"
        case x12274 = "X12_274"
        case x12275 = "X12_275"
        case x12275X210 = "X12_275_X210"
        case x12275X211 = "X12_275_X211"
        case x12276 = "X12_276"
        case x12276X212 = "X12_276_X212"
        case x12277 = "X12_277"
        case x12277X212 = "X12_277_X212"
        case x12277X214 = "X12_277_X214"
        case x12277X364 = "X12_277_X364"
        case x12278 = "X12_278"
        case x12278X217 = "X12_278_X217"
        case x12310 = "X12_310"
        case x12315 = "X12_315"
        case x12322 = "X12_322"
        case x12404 = "X12_404"
        case x12410 = "X12_410"
        case x12417 = "X12_417"
        case x12421 = "X12_421"
        case x12426 = "X12_426"
        case x12810 = "X12_810"
        case x12820 = "X12_820"
        case x12820X218 = "X12_820_X218"
        case x12820X306 = "X12_820_X306"
        case x12824 = "X12_824"
        case x12824X186 = "X12_824_X186"
        case x12830 = "X12_830"
        case x12832 = "X12_832"
        case x12834 = "X12_834"
        case x12834X220 = "X12_834_X220"
        case x12834X307 = "X12_834_X307"
        case x12834X318 = "X12_834_X318"
        case x12835 = "X12_835"
        case x12835X221 = "X12_835_X221"
        case x12837 = "X12_837"
        case x12837X222 = "X12_837_X222"
        case x12837X223 = "X12_837_X223"
        case x12837X224 = "X12_837_X224"
        case x12837X291 = "X12_837_X291"
        case x12837X292 = "X12_837_X292"
        case x12837X298 = "X12_837_X298"
        case x12844 = "X12_844"
        case x12846 = "X12_846"
        case x12849 = "X12_849"
        case x12850 = "X12_850"
        case x12852 = "X12_852"
        case x12855 = "X12_855"
        case x12856 = "X12_856"
        case x12860 = "X12_860"
        case x12861 = "X12_861"
        case x12864 = "X12_864"
        case x12865 = "X12_865"
        case x12869 = "X12_869"
        case x12870 = "X12_870"
        case x12940 = "X12_940"
        case x12945 = "X12_945"
        case x12990 = "X12_990"
        case x12997 = "X12_997"
        case x12999 = "X12_999"
        case x12999X231 = "X12_999_X231"
        public var description: String { return self.rawValue }
    }

    public enum X12Version: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case version4010 = "VERSION_4010"
        case version4030 = "VERSION_4030"
        case version5010 = "VERSION_5010"
        case version5010Hipaa = "VERSION_5010_HIPAA"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CapabilitySummary: AWSDecodableShape {
        /// Returns a system-assigned unique identifier for the capability.
        public let capabilityId: String
        /// Returns a timestamp for creation date and time of the capability.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns a timestamp that identifies the most recent date and time that the capability was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// The display name of the capability.
        public let name: String
        /// Returns the type of the capability. Currently, only edi is supported.
        public let type: CapabilityType

        public init(capabilityId: String, createdAt: Date, modifiedAt: Date? = nil, name: String, type: CapabilityType) {
            self.capabilityId = capabilityId
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityId = "capabilityId"
            case createdAt = "createdAt"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case type = "type"
        }
    }

    public struct CreateCapabilityRequest: AWSEncodableShape {
        /// Reserved for future use.
        public let clientToken: String?
        /// Specifies a structure that contains the details for a capability.
        public let configuration: CapabilityConfiguration
        /// Specifies one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
        public let instructionsDocuments: [S3Location]?
        /// Specifies the name of the capability, used to identify it.
        public let name: String
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]?
        /// Specifies the type of the capability. Currently, only edi is supported.
        public let type: CapabilityType

        public init(clientToken: String? = CreateCapabilityRequest.idempotencyToken(), configuration: CapabilityConfiguration, instructionsDocuments: [S3Location]? = nil, name: String, tags: [Tag]? = nil, type: CapabilityType) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.instructionsDocuments = instructionsDocuments
            self.name = name
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.instructionsDocuments?.forEach {
                try $0.validate(name: "\(name).instructionsDocuments[]")
            }
            try self.validate(self.instructionsDocuments, name: "instructionsDocuments", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case instructionsDocuments = "instructionsDocuments"
            case name = "name"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateCapabilityResponse: AWSDecodableShape {
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let capabilityArn: String
        /// Returns a system-assigned unique identifier for the capability.
        public let capabilityId: String
        /// Returns a structure that contains the details for a capability.
        public let configuration: CapabilityConfiguration
        /// Returns a timestamp for creation date and time of the capability.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
        public let instructionsDocuments: [S3Location]?
        /// Returns the name of the capability used to identify it.
        public let name: String
        /// Returns the type of the capability. Currently, only edi is supported.
        public let type: CapabilityType

        public init(capabilityArn: String, capabilityId: String, configuration: CapabilityConfiguration, createdAt: Date, instructionsDocuments: [S3Location]? = nil, name: String, type: CapabilityType) {
            self.capabilityArn = capabilityArn
            self.capabilityId = capabilityId
            self.configuration = configuration
            self.createdAt = createdAt
            self.instructionsDocuments = instructionsDocuments
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityArn = "capabilityArn"
            case capabilityId = "capabilityId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case instructionsDocuments = "instructionsDocuments"
            case name = "name"
            case type = "type"
        }
    }

    public struct CreatePartnershipRequest: AWSEncodableShape {
        /// Specifies a list of the capabilities associated with this partnership.
        public let capabilities: [String]?
        /// Reserved for future use.
        public let clientToken: String?
        /// Specifies the email address associated with this trading partner.
        public let email: String
        /// Specifies a descriptive name for the partnership.
        public let name: String
        /// Specifies the phone number associated with the partnership.
        public let phone: String?
        /// Specifies the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]?

        public init(capabilities: [String]? = nil, clientToken: String? = CreatePartnershipRequest.idempotencyToken(), email: String, name: String, phone: String? = nil, profileId: String, tags: [Tag]? = nil) {
            self.capabilities = capabilities
            self.clientToken = clientToken
            self.email = email
            self.name = name
            self.phone = phone
            self.profileId = profileId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, max: 64)
                try validate($0, name: "capabilities[]", parent: name, min: 1)
                try validate($0, name: "capabilities[]", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
            try self.validate(self.email, name: "email", parent: name, max: 254)
            try self.validate(self.email, name: "email", parent: name, min: 5)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[\\w\\.\\-]+@[\\w\\.\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.phone, name: "phone", parent: name, max: 22)
            try self.validate(self.phone, name: "phone", parent: name, min: 7)
            try self.validate(self.phone, name: "phone", parent: name, pattern: "^\\+?([0-9 \\t\\-()\\/]{7,})(?:\\s*(?:#|x\\.?|ext\\.?|extension) \\t*(\\d+))?$")
            try self.validate(self.profileId, name: "profileId", parent: name, max: 64)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case clientToken = "clientToken"
            case email = "email"
            case name = "name"
            case phone = "phone"
            case profileId = "profileId"
            case tags = "tags"
        }
    }

    public struct CreatePartnershipResponse: AWSDecodableShape {
        /// Returns one or more capabilities associated with this partnership.
        public let capabilities: [String]?
        /// Returns a timestamp for creation date and time of the partnership.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this trading partner.
        public let email: String?
        /// Returns a descriptive name for the partnership.
        public let name: String?
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let partnershipArn: String
        /// Returns the unique, system-generated identifier for a partnership.
        public let partnershipId: String
        /// Returns the phone number associated with the partnership.
        public let phone: String?
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String
        /// Returns the unique, system-generated identifier for a trading partner.
        public let tradingPartnerId: String?

        public init(capabilities: [String]? = nil, createdAt: Date, email: String? = nil, name: String? = nil, partnershipArn: String, partnershipId: String, phone: String? = nil, profileId: String, tradingPartnerId: String? = nil) {
            self.capabilities = capabilities
            self.createdAt = createdAt
            self.email = email
            self.name = name
            self.partnershipArn = partnershipArn
            self.partnershipId = partnershipId
            self.phone = phone
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case createdAt = "createdAt"
            case email = "email"
            case name = "name"
            case partnershipArn = "partnershipArn"
            case partnershipId = "partnershipId"
            case phone = "phone"
            case profileId = "profileId"
            case tradingPartnerId = "tradingPartnerId"
        }
    }

    public struct CreateProfileRequest: AWSEncodableShape {
        /// Specifies the name for the business associated with this profile.
        public let businessName: String
        /// Reserved for future use.
        public let clientToken: String?
        /// Specifies the email address associated with this customer profile.
        public let email: String?
        /// Specifies whether or not logging is enabled for this profile.
        public let logging: Logging
        /// Specifies the name of the profile.
        public let name: String
        /// Specifies the phone number associated with the profile.
        public let phone: String
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]?

        public init(businessName: String, clientToken: String? = CreateProfileRequest.idempotencyToken(), email: String? = nil, logging: Logging, name: String, phone: String, tags: [Tag]? = nil) {
            self.businessName = businessName
            self.clientToken = clientToken
            self.email = email
            self.logging = logging
            self.name = name
            self.phone = phone
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.businessName, name: "businessName", parent: name, max: 254)
            try self.validate(self.businessName, name: "businessName", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, max: 254)
            try self.validate(self.email, name: "email", parent: name, min: 5)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[\\w\\.\\-]+@[\\w\\.\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.phone, name: "phone", parent: name, max: 22)
            try self.validate(self.phone, name: "phone", parent: name, min: 7)
            try self.validate(self.phone, name: "phone", parent: name, pattern: "^\\+?([0-9 \\t\\-()\\/]{7,})(?:\\s*(?:#|x\\.?|ext\\.?|extension) \\t*(\\d+))?$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case clientToken = "clientToken"
            case email = "email"
            case logging = "logging"
            case name = "name"
            case phone = "phone"
            case tags = "tags"
        }
    }

    public struct CreateProfileResponse: AWSDecodableShape {
        /// Returns the name for the business associated with this profile.
        public let businessName: String
        /// Returns a timestamp representing the time the profile was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this customer profile.
        public let email: String?
        /// Returns whether or not logging is turned on for this profile.
        public let logging: Logging?
        /// Returns the name of the logging group.
        public let logGroupName: String?
        /// Returns the name of the profile, used to identify it.
        public let name: String
        /// Returns the phone number associated with the profile.
        public let phone: String
        /// Returns an Amazon Resource Name (ARN) for the profile.
        public let profileArn: String
        /// Returns the unique, system-generated identifier for the profile.
        public let profileId: String

        public init(businessName: String, createdAt: Date, email: String? = nil, logging: Logging? = nil, logGroupName: String? = nil, name: String, phone: String, profileArn: String, profileId: String) {
            self.businessName = businessName
            self.createdAt = createdAt
            self.email = email
            self.logging = logging
            self.logGroupName = logGroupName
            self.name = name
            self.phone = phone
            self.profileArn = profileArn
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case createdAt = "createdAt"
            case email = "email"
            case logging = "logging"
            case logGroupName = "logGroupName"
            case name = "name"
            case phone = "phone"
            case profileArn = "profileArn"
            case profileId = "profileId"
        }
    }

    public struct CreateTransformerRequest: AWSEncodableShape {
        /// Reserved for future use.
        public let clientToken: String?
        /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType
        /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat
        /// Specifies the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
        public let mappingTemplate: String
        /// Specifies the name of the transformer, used to identify it.
        public let name: String
        /// Specifies a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateTransformerRequest.idempotencyToken(), ediType: EdiType, fileFormat: FileFormat, mappingTemplate: String, name: String, sampleDocument: String? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.mappingTemplate = mappingTemplate
            self.name = name
            self.sampleDocument = sampleDocument
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.mappingTemplate, name: "mappingTemplate", parent: name, max: 350000)
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.sampleDocument, name: "sampleDocument", parent: name, max: 1024)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case mappingTemplate = "mappingTemplate"
            case name = "name"
            case sampleDocument = "sampleDocument"
            case tags = "tags"
        }
    }

    public struct CreateTransformerResponse: AWSDecodableShape {
        /// Returns a timestamp for creation date and time of the transformer.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat
        /// Returns the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
        public let mappingTemplate: String
        /// Returns the name of the transformer, used to identify it.
        public let name: String
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        public let status: TransformerStatus
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let transformerArn: String
        /// Returns the system-assigned unique identifier for the transformer.
        public let transformerId: String

        public init(createdAt: Date, ediType: EdiType, fileFormat: FileFormat, mappingTemplate: String, name: String, sampleDocument: String? = nil, status: TransformerStatus, transformerArn: String, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.mappingTemplate = mappingTemplate
            self.name = name
            self.sampleDocument = sampleDocument
            self.status = status
            self.transformerArn = transformerArn
            self.transformerId = transformerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case mappingTemplate = "mappingTemplate"
            case name = "name"
            case sampleDocument = "sampleDocument"
            case status = "status"
            case transformerArn = "transformerArn"
            case transformerId = "transformerId"
        }
    }

    public struct DeleteCapabilityRequest: AWSEncodableShape {
        /// Specifies a system-assigned unique identifier for the capability.
        public let capabilityId: String

        public init(capabilityId: String) {
            self.capabilityId = capabilityId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capabilityId, key: "capabilityId")
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, max: 64)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, min: 1)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePartnershipRequest: AWSEncodableShape {
        /// Specifies the unique, system-generated identifier for a partnership.
        public let partnershipId: String

        public init(partnershipId: String) {
            self.partnershipId = partnershipId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.partnershipId, key: "partnershipId")
        }

        public func validate(name: String) throws {
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, max: 64)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, min: 1)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProfileRequest: AWSEncodableShape {
        /// Specifies the unique, system-generated identifier for the profile.
        public let profileId: String

        public init(profileId: String) {
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profileId, key: "profileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.profileId, name: "profileId", parent: name, max: 64)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTransformerRequest: AWSEncodableShape {
        /// Specifies the system-assigned unique identifier for the transformer.
        public let transformerId: String

        public init(transformerId: String) {
            self.transformerId = transformerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.transformerId, key: "transformerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct EdiConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains the Amazon S3 bucket and prefix for the location of the input file, which is contained in an S3Location object.
        public let inputLocation: S3Location
        /// Contains the Amazon S3 bucket and prefix for the location of the output file, which is contained in an S3Location object.
        public let outputLocation: S3Location
        /// Returns the system-assigned unique identifier for the transformer.
        public let transformerId: String
        /// Returns the type of the capability. Currently, only edi is supported.
        public let type: EdiType

        public init(inputLocation: S3Location, outputLocation: S3Location, transformerId: String, type: EdiType) {
            self.inputLocation = inputLocation
            self.outputLocation = outputLocation
            self.transformerId = transformerId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.inputLocation.validate(name: "\(name).inputLocation")
            try self.outputLocation.validate(name: "\(name).outputLocation")
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputLocation = "inputLocation"
            case outputLocation = "outputLocation"
            case transformerId = "transformerId"
            case type = "type"
        }
    }

    public struct GetCapabilityRequest: AWSEncodableShape {
        /// Specifies a system-assigned unique identifier for the capability.
        public let capabilityId: String

        public init(capabilityId: String) {
            self.capabilityId = capabilityId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capabilityId, key: "capabilityId")
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, max: 64)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, min: 1)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCapabilityResponse: AWSDecodableShape {
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let capabilityArn: String
        /// Returns a system-assigned unique identifier for the capability.
        public let capabilityId: String
        /// Returns a structure that contains the details for a capability.
        public let configuration: CapabilityConfiguration
        /// Returns a timestamp for creation date and time of the capability.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
        public let instructionsDocuments: [S3Location]?
        /// Returns a timestamp for last time the capability was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the capability, used to identify it.
        public let name: String
        /// Returns the type of the capability. Currently, only edi is supported.
        public let type: CapabilityType

        public init(capabilityArn: String, capabilityId: String, configuration: CapabilityConfiguration, createdAt: Date, instructionsDocuments: [S3Location]? = nil, modifiedAt: Date? = nil, name: String, type: CapabilityType) {
            self.capabilityArn = capabilityArn
            self.capabilityId = capabilityId
            self.configuration = configuration
            self.createdAt = createdAt
            self.instructionsDocuments = instructionsDocuments
            self.modifiedAt = modifiedAt
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityArn = "capabilityArn"
            case capabilityId = "capabilityId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case instructionsDocuments = "instructionsDocuments"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case type = "type"
        }
    }

    public struct GetPartnershipRequest: AWSEncodableShape {
        /// Specifies the unique, system-generated identifier for a partnership.
        public let partnershipId: String

        public init(partnershipId: String) {
            self.partnershipId = partnershipId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.partnershipId, key: "partnershipId")
        }

        public func validate(name: String) throws {
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, max: 64)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, min: 1)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPartnershipResponse: AWSDecodableShape {
        /// Returns one or more capabilities associated with this partnership.
        public let capabilities: [String]?
        /// Returns a timestamp for creation date and time of the partnership.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this trading partner.
        public let email: String?
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the display name of the partnership
        public let name: String?
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let partnershipArn: String
        /// Returns the unique, system-generated identifier for a partnership.
        public let partnershipId: String
        /// Returns the phone number associated with the partnership.
        public let phone: String?
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String
        /// Returns the unique identifier for the partner for this partnership.
        public let tradingPartnerId: String?

        public init(capabilities: [String]? = nil, createdAt: Date, email: String? = nil, modifiedAt: Date? = nil, name: String? = nil, partnershipArn: String, partnershipId: String, phone: String? = nil, profileId: String, tradingPartnerId: String? = nil) {
            self.capabilities = capabilities
            self.createdAt = createdAt
            self.email = email
            self.modifiedAt = modifiedAt
            self.name = name
            self.partnershipArn = partnershipArn
            self.partnershipId = partnershipId
            self.phone = phone
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case createdAt = "createdAt"
            case email = "email"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case partnershipArn = "partnershipArn"
            case partnershipId = "partnershipId"
            case phone = "phone"
            case profileId = "profileId"
            case tradingPartnerId = "tradingPartnerId"
        }
    }

    public struct GetProfileRequest: AWSEncodableShape {
        /// Specifies the unique, system-generated identifier for the profile.
        public let profileId: String

        public init(profileId: String) {
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profileId, key: "profileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.profileId, name: "profileId", parent: name, max: 64)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProfileResponse: AWSDecodableShape {
        /// Returns the name for the business associated with this profile.
        public let businessName: String
        /// Returns a timestamp for creation date and time of the transformer.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this customer profile.
        public let email: String?
        /// Returns whether or not logging is enabled for this profile.
        public let logging: Logging?
        /// Returns the name of the logging group.
        public let logGroupName: String?
        /// Returns a timestamp for last time the profile was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the profile, used to identify it.
        public let name: String
        /// Returns the phone number associated with the profile.
        public let phone: String
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let profileArn: String
        /// Returns the unique, system-generated identifier for the profile.
        public let profileId: String

        public init(businessName: String, createdAt: Date, email: String? = nil, logging: Logging? = nil, logGroupName: String? = nil, modifiedAt: Date? = nil, name: String, phone: String, profileArn: String, profileId: String) {
            self.businessName = businessName
            self.createdAt = createdAt
            self.email = email
            self.logging = logging
            self.logGroupName = logGroupName
            self.modifiedAt = modifiedAt
            self.name = name
            self.phone = phone
            self.profileArn = profileArn
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case createdAt = "createdAt"
            case email = "email"
            case logging = "logging"
            case logGroupName = "logGroupName"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case phone = "phone"
            case profileArn = "profileArn"
            case profileId = "profileId"
        }
    }

    public struct GetTransformerJobRequest: AWSEncodableShape {
        /// Specifies the system-assigned unique identifier for the transformer.
        public let transformerId: String
        /// Specifies the unique, system-generated identifier for a transformer run.
        public let transformerJobId: String

        public init(transformerId: String, transformerJobId: String) {
            self.transformerId = transformerId
            self.transformerJobId = transformerJobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.transformerId, key: "transformerId")
            request.encodePath(self.transformerJobId, key: "transformerJobId")
        }

        public func validate(name: String) throws {
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.transformerJobId, name: "transformerJobId", parent: name, max: 25)
            try self.validate(self.transformerJobId, name: "transformerJobId", parent: name, min: 25)
            try self.validate(self.transformerJobId, name: "transformerJobId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransformerJobResponse: AWSDecodableShape {
        /// Returns an optional error message, which gets populated when the job is not run successfully.
        public let message: String?
        /// Returns the location for the output files. If the caller specified a directory for the output, then this contains the full path to the output file, including the file name generated by the service.
        public let outputFiles: [S3Location]?
        /// Returns the current state of the transformer job, either running, succeeded, or failed.
        public let status: TransformerJobStatus

        public init(message: String? = nil, outputFiles: [S3Location]? = nil, status: TransformerJobStatus) {
            self.message = message
            self.outputFiles = outputFiles
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case outputFiles = "outputFiles"
            case status = "status"
        }
    }

    public struct GetTransformerRequest: AWSEncodableShape {
        /// Specifies the system-assigned unique identifier for the transformer.
        public let transformerId: String

        public init(transformerId: String) {
            self.transformerId = transformerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.transformerId, key: "transformerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransformerResponse: AWSDecodableShape {
        /// Returns a timestamp for creation date and time of the transformer.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat
        /// Returns the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
        public let mappingTemplate: String
        /// Returns a timestamp for last time the transformer was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the transformer, used to identify it.
        public let name: String
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        public let status: TransformerStatus
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let transformerArn: String
        /// Returns the system-assigned unique identifier for the transformer.
        public let transformerId: String

        public init(createdAt: Date, ediType: EdiType, fileFormat: FileFormat, mappingTemplate: String, modifiedAt: Date? = nil, name: String, sampleDocument: String? = nil, status: TransformerStatus, transformerArn: String, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.mappingTemplate = mappingTemplate
            self.modifiedAt = modifiedAt
            self.name = name
            self.sampleDocument = sampleDocument
            self.status = status
            self.transformerArn = transformerArn
            self.transformerId = transformerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case mappingTemplate = "mappingTemplate"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case sampleDocument = "sampleDocument"
            case status = "status"
            case transformerArn = "transformerArn"
            case transformerId = "transformerId"
        }
    }

    public struct ListCapabilitiesRequest: AWSEncodableShape {
        /// Specifies the maximum number of capabilities to return.
        public let maxResults: Int?
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCapabilitiesResponse: AWSDecodableShape {
        /// Returns one or more capabilities associated with this partnership.
        public let capabilities: [CapabilitySummary]
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?

        public init(capabilities: [CapabilitySummary], nextToken: String? = nil) {
            self.capabilities = capabilities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case nextToken = "nextToken"
        }
    }

    public struct ListPartnershipsRequest: AWSEncodableShape {
        /// Specifies the maximum number of capabilities to return.
        public let maxResults: Int?
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?
        /// Specifies the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, profileId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.profileId, key: "profileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, max: 64)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPartnershipsResponse: AWSDecodableShape {
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?
        /// Specifies a list of your partnerships.
        public let partnerships: [PartnershipSummary]

        public init(nextToken: String? = nil, partnerships: [PartnershipSummary]) {
            self.nextToken = nextToken
            self.partnerships = partnerships
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case partnerships = "partnerships"
        }
    }

    public struct ListProfilesRequest: AWSEncodableShape {
        /// Specifies the maximum number of profiles to return.
        public let maxResults: Int?
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfilesResponse: AWSDecodableShape {
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?
        /// Returns an array of ProfileSummary objects.
        public let profiles: [ProfileSummary]

        public init(nextToken: String? = nil, profiles: [ProfileSummary]) {
            self.nextToken = nextToken
            self.profiles = profiles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case profiles = "profiles"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an identifier for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "ResourceARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Returns the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListTransformersRequest: AWSEncodableShape {
        /// Specifies the number of items to return for the API response.
        public let maxResults: Int?
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTransformersResponse: AWSDecodableShape {
        /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
        public let nextToken: String?
        /// Returns an array of one or more transformer objects. For each transformer, a TransformerSummary object is returned. The TransformerSummary contains all the details for a specific transformer.
        public let transformers: [TransformerSummary]

        public init(nextToken: String? = nil, transformers: [TransformerSummary]) {
            self.nextToken = nextToken
            self.transformers = transformers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case transformers = "transformers"
        }
    }

    public struct PartnershipSummary: AWSDecodableShape {
        /// Returns one or more capabilities associated with this partnership.
        public let capabilities: [String]?
        /// Returns a timestamp for creation date and time of the partnership.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the partnership.
        public let name: String?
        /// Returns the unique, system-generated identifier for a partnership.
        public let partnershipId: String
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String
        /// Returns the unique, system-generated identifier for a trading partner.
        public let tradingPartnerId: String?

        public init(capabilities: [String]? = nil, createdAt: Date, modifiedAt: Date? = nil, name: String? = nil, partnershipId: String, profileId: String, tradingPartnerId: String? = nil) {
            self.capabilities = capabilities
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.partnershipId = partnershipId
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case createdAt = "createdAt"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case partnershipId = "partnershipId"
            case profileId = "profileId"
            case tradingPartnerId = "tradingPartnerId"
        }
    }

    public struct ProfileSummary: AWSDecodableShape {
        /// Returns the name for the business associated with this profile.
        public let businessName: String
        /// Returns the timestamp for creation date and time of the profile.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Specifies whether or not logging is enabled for this profile.
        public let logging: Logging?
        /// Returns the name of the logging group.
        public let logGroupName: String?
        /// Returns the timestamp that identifies the most recent date and time that the profile was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the display name for profile.
        public let name: String
        /// Returns the unique, system-generated identifier for the profile.
        public let profileId: String

        public init(businessName: String, createdAt: Date, logging: Logging? = nil, logGroupName: String? = nil, modifiedAt: Date? = nil, name: String, profileId: String) {
            self.businessName = businessName
            self.createdAt = createdAt
            self.logging = logging
            self.logGroupName = logGroupName
            self.modifiedAt = modifiedAt
            self.name = name
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case createdAt = "createdAt"
            case logging = "logging"
            case logGroupName = "logGroupName"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case profileId = "profileId"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the name of the Amazon S3 bucket.
        public let bucketName: String?
        /// Specifies the Amazon S3 key for the file location.
        public let key: String?

        public init(bucketName: String? = nil, key: String? = nil) {
            self.bucketName = bucketName
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.key, name: "key", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case key = "key"
        }
    }

    public struct StartTransformerJobRequest: AWSEncodableShape {
        /// Reserved for future use.
        public let clientToken: String?
        /// Specifies the location of the input file for the transformation. The location consists of an Amazon S3 bucket and prefix.
        public let inputFile: S3Location
        /// Specifies the location of the output file for the transformation. The location consists of an Amazon S3 bucket and prefix.
        public let outputLocation: S3Location
        /// Specifies the system-assigned unique identifier for the transformer.
        public let transformerId: String

        public init(clientToken: String? = StartTransformerJobRequest.idempotencyToken(), inputFile: S3Location, outputLocation: S3Location, transformerId: String) {
            self.clientToken = clientToken
            self.inputFile = inputFile
            self.outputLocation = outputLocation
            self.transformerId = transformerId
        }

        public func validate(name: String) throws {
            try self.inputFile.validate(name: "\(name).inputFile")
            try self.outputLocation.validate(name: "\(name).outputLocation")
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case inputFile = "inputFile"
            case outputLocation = "outputLocation"
            case transformerId = "transformerId"
        }
    }

    public struct StartTransformerJobResponse: AWSDecodableShape {
        /// Returns the unique, system-generated identifier for a transformer run.
        public let transformerJobId: String

        public init(transformerJobId: String) {
            self.transformerJobId = transformerJobId
        }

        private enum CodingKeys: String, CodingKey {
            case transformerJobId = "transformerJobId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the name assigned to the tag that you create.
        public let key: String
        /// Contains one or more values that you assigned to the key name that you create.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// Specifies an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let resourceARN: String
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "ResourceARN")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TestMappingRequest: AWSEncodableShape {
        /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat
        /// Specify the contents of the EDI (electronic data interchange) XML or JSON file that is used as input for the transform.
        public let inputFileContent: String
        /// Specifies the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
        public let mappingTemplate: String

        public init(fileFormat: FileFormat, inputFileContent: String, mappingTemplate: String) {
            self.fileFormat = fileFormat
            self.inputFileContent = inputFileContent
            self.mappingTemplate = mappingTemplate
        }

        public func validate(name: String) throws {
            try self.validate(self.inputFileContent, name: "inputFileContent", parent: name, max: 5000000)
            try self.validate(self.mappingTemplate, name: "mappingTemplate", parent: name, max: 350000)
        }

        private enum CodingKeys: String, CodingKey {
            case fileFormat = "fileFormat"
            case inputFileContent = "inputFileContent"
            case mappingTemplate = "mappingTemplate"
        }
    }

    public struct TestMappingResponse: AWSDecodableShape {
        /// Returns a string for the mapping that can be used to identify the mapping. Similar to a fingerprint
        public let mappedFileContent: String

        public init(mappedFileContent: String) {
            self.mappedFileContent = mappedFileContent
        }

        private enum CodingKeys: String, CodingKey {
            case mappedFileContent = "mappedFileContent"
        }
    }

    public struct TestParsingRequest: AWSEncodableShape {
        /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType
        /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat
        /// Specifies an S3Location object, which contains the Amazon S3 bucket and prefix for the location of the input file.
        public let inputFile: S3Location

        public init(ediType: EdiType, fileFormat: FileFormat, inputFile: S3Location) {
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.inputFile = inputFile
        }

        public func validate(name: String) throws {
            try self.inputFile.validate(name: "\(name).inputFile")
        }

        private enum CodingKeys: String, CodingKey {
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case inputFile = "inputFile"
        }
    }

    public struct TestParsingResponse: AWSDecodableShape {
        /// Returns the contents of the input file being tested, parsed according to the specified EDI (electronic data interchange) type.
        public let parsedFileContent: String

        public init(parsedFileContent: String) {
            self.parsedFileContent = parsedFileContent
        }

        private enum CodingKeys: String, CodingKey {
            case parsedFileContent = "parsedFileContent"
        }
    }

    public struct TransformerSummary: AWSDecodableShape {
        /// Returns a timestamp indicating when the transformer was created. For example, 2023-07-20T19:58:44.624Z.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat
        /// Returns the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
        public let mappingTemplate: String
        /// Returns a timestamp representing the date and time for the most recent change for the transformer object.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the descriptive name for the transformer.
        public let name: String
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        public let status: TransformerStatus
        /// Returns the system-assigned unique identifier for the transformer.
        public let transformerId: String

        public init(createdAt: Date, ediType: EdiType, fileFormat: FileFormat, mappingTemplate: String, modifiedAt: Date? = nil, name: String, sampleDocument: String? = nil, status: TransformerStatus, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.mappingTemplate = mappingTemplate
            self.modifiedAt = modifiedAt
            self.name = name
            self.sampleDocument = sampleDocument
            self.status = status
            self.transformerId = transformerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case mappingTemplate = "mappingTemplate"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case sampleDocument = "sampleDocument"
            case status = "status"
            case transformerId = "transformerId"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Specifies an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let resourceARN: String
        /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "ResourceARN")
            request.encodeQuery(self.tagKeys, key: "TagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateCapabilityRequest: AWSEncodableShape {
        /// Specifies a system-assigned unique identifier for the capability.
        public let capabilityId: String
        /// Specifies a structure that contains the details for a capability.
        public let configuration: CapabilityConfiguration?
        /// Specifies one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
        public let instructionsDocuments: [S3Location]?
        /// Specifies a new name for the capability, to replace the existing name.
        public let name: String?

        public init(capabilityId: String, configuration: CapabilityConfiguration? = nil, instructionsDocuments: [S3Location]? = nil, name: String? = nil) {
            self.capabilityId = capabilityId
            self.configuration = configuration
            self.instructionsDocuments = instructionsDocuments
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capabilityId, key: "capabilityId")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.instructionsDocuments, forKey: .instructionsDocuments)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, max: 64)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, min: 1)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.instructionsDocuments?.forEach {
                try $0.validate(name: "\(name).instructionsDocuments[]")
            }
            try self.validate(self.instructionsDocuments, name: "instructionsDocuments", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case instructionsDocuments = "instructionsDocuments"
            case name = "name"
        }
    }

    public struct UpdateCapabilityResponse: AWSDecodableShape {
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let capabilityArn: String
        /// Returns a system-assigned unique identifier for the capability.
        public let capabilityId: String
        /// Returns a structure that contains the details for a capability.
        public let configuration: CapabilityConfiguration
        /// Returns a timestamp for creation date and time of the capability.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
        public let instructionsDocuments: [S3Location]?
        /// Returns a timestamp for last time the capability was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the capability, used to identify it.
        public let name: String
        /// Returns the type of the capability. Currently, only edi is supported.
        public let type: CapabilityType

        public init(capabilityArn: String, capabilityId: String, configuration: CapabilityConfiguration, createdAt: Date, instructionsDocuments: [S3Location]? = nil, modifiedAt: Date? = nil, name: String, type: CapabilityType) {
            self.capabilityArn = capabilityArn
            self.capabilityId = capabilityId
            self.configuration = configuration
            self.createdAt = createdAt
            self.instructionsDocuments = instructionsDocuments
            self.modifiedAt = modifiedAt
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityArn = "capabilityArn"
            case capabilityId = "capabilityId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case instructionsDocuments = "instructionsDocuments"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case type = "type"
        }
    }

    public struct UpdatePartnershipRequest: AWSEncodableShape {
        /// List of the capabilities associated with this partnership.
        public let capabilities: [String]?
        /// The name of the partnership, used to identify it.
        public let name: String?
        /// Specifies the unique, system-generated identifier for a partnership.
        public let partnershipId: String

        public init(capabilities: [String]? = nil, name: String? = nil, partnershipId: String) {
            self.capabilities = capabilities
            self.name = name
            self.partnershipId = partnershipId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.capabilities, forKey: .capabilities)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.partnershipId, key: "partnershipId")
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, max: 64)
                try validate($0, name: "capabilities[]", parent: name, min: 1)
                try validate($0, name: "capabilities[]", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, max: 64)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, min: 1)
            try self.validate(self.partnershipId, name: "partnershipId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case name = "name"
        }
    }

    public struct UpdatePartnershipResponse: AWSDecodableShape {
        /// Returns one or more capabilities associated with this partnership.
        public let capabilities: [String]?
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this trading partner.
        public let email: String?
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// The name of the partnership, used to identify it.
        public let name: String?
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let partnershipArn: String
        /// Returns the unique, system-generated identifier for a partnership.
        public let partnershipId: String
        /// Returns the phone number associated with the partnership.
        public let phone: String?
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        public let profileId: String
        /// Returns the unique, system-generated identifier for a trading partner.
        public let tradingPartnerId: String?

        public init(capabilities: [String]? = nil, createdAt: Date, email: String? = nil, modifiedAt: Date? = nil, name: String? = nil, partnershipArn: String, partnershipId: String, phone: String? = nil, profileId: String, tradingPartnerId: String? = nil) {
            self.capabilities = capabilities
            self.createdAt = createdAt
            self.email = email
            self.modifiedAt = modifiedAt
            self.name = name
            self.partnershipArn = partnershipArn
            self.partnershipId = partnershipId
            self.phone = phone
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case createdAt = "createdAt"
            case email = "email"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case partnershipArn = "partnershipArn"
            case partnershipId = "partnershipId"
            case phone = "phone"
            case profileId = "profileId"
            case tradingPartnerId = "tradingPartnerId"
        }
    }

    public struct UpdateProfileRequest: AWSEncodableShape {
        /// Specifies the name for the business associated with this profile.
        public let businessName: String?
        /// Specifies the email address associated with this customer profile.
        public let email: String?
        /// The name of the profile, used to identify it.
        public let name: String?
        /// Specifies the phone number associated with the profile.
        public let phone: String?
        /// Specifies the unique, system-generated identifier for the profile.
        public let profileId: String

        public init(businessName: String? = nil, email: String? = nil, name: String? = nil, phone: String? = nil, profileId: String) {
            self.businessName = businessName
            self.email = email
            self.name = name
            self.phone = phone
            self.profileId = profileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.businessName, forKey: .businessName)
            try container.encodeIfPresent(self.email, forKey: .email)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.phone, forKey: .phone)
            request.encodePath(self.profileId, key: "profileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.businessName, name: "businessName", parent: name, max: 254)
            try self.validate(self.businessName, name: "businessName", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, max: 254)
            try self.validate(self.email, name: "email", parent: name, min: 5)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[\\w\\.\\-]+@[\\w\\.\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.phone, name: "phone", parent: name, max: 22)
            try self.validate(self.phone, name: "phone", parent: name, min: 7)
            try self.validate(self.phone, name: "phone", parent: name, pattern: "^\\+?([0-9 \\t\\-()\\/]{7,})(?:\\s*(?:#|x\\.?|ext\\.?|extension) \\t*(\\d+))?$")
            try self.validate(self.profileId, name: "profileId", parent: name, max: 64)
            try self.validate(self.profileId, name: "profileId", parent: name, min: 1)
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case email = "email"
            case name = "name"
            case phone = "phone"
        }
    }

    public struct UpdateProfileResponse: AWSDecodableShape {
        /// Returns the name for the business associated with this profile.
        public let businessName: String
        /// Returns a timestamp for creation date and time of the profile.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the email address associated with this customer profile.
        public let email: String?
        /// Specifies whether or not logging is enabled for this profile.
        public let logging: Logging?
        /// Returns the name of the logging group.
        public let logGroupName: String?
        /// Returns a timestamp for last time the profile was modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date?
        /// Returns the name of the profile.
        public let name: String
        /// Returns the phone number associated with the profile.
        public let phone: String
        /// Returns an Amazon Resource Name (ARN) for the profile.
        public let profileArn: String
        /// Returns the unique, system-generated identifier for the profile.
        public let profileId: String

        public init(businessName: String, createdAt: Date, email: String? = nil, logging: Logging? = nil, logGroupName: String? = nil, modifiedAt: Date? = nil, name: String, phone: String, profileArn: String, profileId: String) {
            self.businessName = businessName
            self.createdAt = createdAt
            self.email = email
            self.logging = logging
            self.logGroupName = logGroupName
            self.modifiedAt = modifiedAt
            self.name = name
            self.phone = phone
            self.profileArn = profileArn
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case businessName = "businessName"
            case createdAt = "createdAt"
            case email = "email"
            case logging = "logging"
            case logGroupName = "logGroupName"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case phone = "phone"
            case profileArn = "profileArn"
            case profileId = "profileId"
        }
    }

    public struct UpdateTransformerRequest: AWSEncodableShape {
        /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType?
        /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat?
        /// Specifies the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
        public let mappingTemplate: String?
        /// Specify a new name for the transformer, if you want to update it.
        public let name: String?
        /// Specifies a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Specifies the transformer's status. You can update the state of the transformer, from active to inactive, or inactive to active.
        public let status: TransformerStatus?
        /// Specifies the system-assigned unique identifier for the transformer.
        public let transformerId: String

        public init(ediType: EdiType? = nil, fileFormat: FileFormat? = nil, mappingTemplate: String? = nil, name: String? = nil, sampleDocument: String? = nil, status: TransformerStatus? = nil, transformerId: String) {
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.mappingTemplate = mappingTemplate
            self.name = name
            self.sampleDocument = sampleDocument
            self.status = status
            self.transformerId = transformerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.ediType, forKey: .ediType)
            try container.encodeIfPresent(self.fileFormat, forKey: .fileFormat)
            try container.encodeIfPresent(self.mappingTemplate, forKey: .mappingTemplate)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.sampleDocument, forKey: .sampleDocument)
            try container.encodeIfPresent(self.status, forKey: .status)
            request.encodePath(self.transformerId, key: "transformerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.mappingTemplate, name: "mappingTemplate", parent: name, max: 350000)
            try self.validate(self.name, name: "name", parent: name, max: 254)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.sampleDocument, name: "sampleDocument", parent: name, max: 1024)
            try self.validate(self.transformerId, name: "transformerId", parent: name, max: 64)
            try self.validate(self.transformerId, name: "transformerId", parent: name, min: 1)
            try self.validate(self.transformerId, name: "transformerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case mappingTemplate = "mappingTemplate"
            case name = "name"
            case sampleDocument = "sampleDocument"
            case status = "status"
        }
    }

    public struct UpdateTransformerResponse: AWSDecodableShape {
        /// Returns a timestamp for creation date and time of the transformer.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let ediType: EdiType
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        public let fileFormat: FileFormat
        /// Returns the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
        public let mappingTemplate: String
        /// Returns a timestamp for last time the transformer was modified.
        @CustomCoding<ISO8601DateCoder>
        public var modifiedAt: Date
        /// Returns the name of the transformer.
        public let name: String
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public let sampleDocument: String?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        public let status: TransformerStatus
        /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
        public let transformerArn: String
        /// Returns the system-assigned unique identifier for the transformer.
        public let transformerId: String

        public init(createdAt: Date, ediType: EdiType, fileFormat: FileFormat, mappingTemplate: String, modifiedAt: Date, name: String, sampleDocument: String? = nil, status: TransformerStatus, transformerArn: String, transformerId: String) {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.mappingTemplate = mappingTemplate
            self.modifiedAt = modifiedAt
            self.name = name
            self.sampleDocument = sampleDocument
            self.status = status
            self.transformerArn = transformerArn
            self.transformerId = transformerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case ediType = "ediType"
            case fileFormat = "fileFormat"
            case mappingTemplate = "mappingTemplate"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case sampleDocument = "sampleDocument"
            case status = "status"
            case transformerArn = "transformerArn"
            case transformerId = "transformerId"
        }
    }

    public struct X12Details: AWSEncodableShape & AWSDecodableShape {
        /// Returns an enumerated type where each value identifies an X12 transaction set. Transaction sets are maintained by the X12 Accredited Standards Committee.
        public let transactionSet: X12TransactionSet?
        /// Returns the version to use for the specified X12 transaction set.
        public let version: X12Version?

        public init(transactionSet: X12TransactionSet? = nil, version: X12Version? = nil) {
            self.transactionSet = transactionSet
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case transactionSet = "transactionSet"
            case version = "version"
        }
    }

    public struct CapabilityConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An EDI (electronic data interchange) configuration object.
        public let edi: EdiConfiguration?

        public init(edi: EdiConfiguration? = nil) {
            self.edi = edi
        }

        public func validate(name: String) throws {
            try self.edi?.validate(name: "\(name).edi")
        }

        private enum CodingKeys: String, CodingKey {
            case edi = "edi"
        }
    }

    public struct EdiType: AWSEncodableShape & AWSDecodableShape {
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        public let x12Details: X12Details?

        public init(x12Details: X12Details? = nil) {
            self.x12Details = x12Details
        }

        private enum CodingKeys: String, CodingKey {
            case x12Details = "x12Details"
        }
    }
}

// MARK: - Errors

/// Error enum for B2bi
public struct B2biErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize B2bi
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A conflict exception is thrown when you attempt to delete a resource (such as a profile or a capability) that is being used by other resources.
    public static var conflictException: Self { .init(.conflictException) }
    /// This exception is thrown when an error occurs in the Amazon Web Services B2B Data Interchange service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Occurs when the requested resource does not exist, or cannot be found. In some cases, the resource exists in a region other than the region specified in the API call.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Occurs when the calling command attempts to exceed one of the service quotas, for example trying to create a capability when you already have the maximum number of capabilities allowed.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to throttling: the data speed and rendering may be limited depending on various parameters and conditions.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Occurs when a B2BI object cannot be validated against a request from another object.
    public static var validationException: Self { .init(.validationException) }
}

extension B2biErrorType: Equatable {
    public static func == (lhs: B2biErrorType, rhs: B2biErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension B2biErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
