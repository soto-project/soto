//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Wisdom {
    // MARK: Enums

    public enum AssistantStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AssistantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        public var description: String { return self.rawValue }
    }

    public enum AssociationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum ContentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ExternalSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonConnect = "AMAZON_CONNECT"
        public var description: String { return self.rawValue }
    }

    public enum FilterField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum ImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case failed = "FAILED"
        case startInProgress = "START_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ImportJobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case quickResponses = "QUICK_RESPONSES"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case external = "EXTERNAL"
        case quickResponses = "QUICK_RESPONSES"
        public var description: String { return self.rawValue }
    }

    public enum Order: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum Priority: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum QuickResponseFilterOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case prefix = "PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum QuickResponseQueryOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case containsAndPrefix = "CONTAINS_AND_PREFIX"
        public var description: String { return self.rawValue }
    }

    public enum QuickResponseStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case issueDetection = "ISSUE_DETECTION"
        case other = "OTHER"
        case ruleEvaluation = "RULE_EVALUATION"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationTriggerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case query = "QUERY"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case knowledgeContent = "KNOWLEDGE_CONTENT"
        public var description: String { return self.rawValue }
    }

    public enum RelevanceLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AppIntegrationsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AppIntegrations DataIntegration to use for ingesting content.   For  Salesforce, your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted as source fields.    For  ServiceNow, your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least number, short_description, sys_mod_count, workflow_state, and active as source fields.    For  Zendesk, your AppIntegrations DataIntegration must have an ObjectConfiguration if objectFields is not provided, including at least id, title, updated_at, and draft as source fields.    For SharePoint, your AppIntegrations DataIntegration must have a FileConfiguration, including only file extensions that are among docx, pdf, html, htm, and txt.    For Amazon S3, the ObjectConfiguration and FileConfiguration of your AppIntegrations DataIntegration must be null. The SourceURI of your DataIntegration must use the following format: s3://your_s3_bucket_name.  The bucket policy of the corresponding S3 bucket must allow the Amazon Web Services principal app-integrations.amazonaws.com to perform s3:ListBucket, s3:GetObject, and s3:GetBucketLocation against the bucket.
        public let appIntegrationArn: String
        /// The fields from the source that are made available to your agents in Wisdom. Optional if ObjectConfiguration is included in the provided DataIntegration.    For  Salesforce, you must include at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted.    For  ServiceNow, you must include at least number, short_description, sys_mod_count, workflow_state, and active.    For  Zendesk, you must include at least id, title, updated_at, and draft.    Make sure to include additional fields. These fields are indexed and used to source recommendations.
        public let objectFields: [String]?

        public init(appIntegrationArn: String, objectFields: [String]? = nil) {
            self.appIntegrationArn = appIntegrationArn
            self.objectFields = objectFields
        }

        public func validate(name: String) throws {
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, max: 2048)
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, min: 1)
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, pattern: "^arn:[a-z-]+?:[a-z-]+?:[a-z0-9-]*?:([0-9]{12})?:[a-zA-Z0-9-:/]+$")
            try self.objectFields?.forEach {
                try validate($0, name: "objectFields[]", parent: name, max: 4096)
                try validate($0, name: "objectFields[]", parent: name, min: 1)
            }
            try self.validate(self.objectFields, name: "objectFields", parent: name, max: 100)
            try self.validate(self.objectFields, name: "objectFields", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appIntegrationArn = "appIntegrationArn"
            case objectFields = "objectFields"
        }
    }

    public struct AssistantAssociationData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        public let assistantArn: String
        /// The Amazon Resource Name (ARN) of the assistant association.
        public let assistantAssociationArn: String
        /// The identifier of the assistant association.
        public let assistantAssociationId: String
        /// The identifier of the Wisdom assistant.
        public let assistantId: String
        /// A union type that currently has a single argument, the knowledge base ID.
        public let associationData: AssistantAssociationOutputData
        /// The type of association.
        public let associationType: AssociationType
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(assistantArn: String, assistantAssociationArn: String, assistantAssociationId: String, assistantId: String, associationData: AssistantAssociationOutputData, associationType: AssociationType, tags: [String: String]? = nil) {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantAssociationArn = "assistantAssociationArn"
            case assistantAssociationId = "assistantAssociationId"
            case assistantId = "assistantId"
            case associationData = "associationData"
            case associationType = "associationType"
            case tags = "tags"
        }
    }

    public struct AssistantAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        public let assistantArn: String
        /// The Amazon Resource Name (ARN) of the assistant association.
        public let assistantAssociationArn: String
        /// The identifier of the assistant association.
        public let assistantAssociationId: String
        /// The identifier of the Wisdom assistant.
        public let assistantId: String
        /// The association data.
        public let associationData: AssistantAssociationOutputData
        /// The type of association.
        public let associationType: AssociationType
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(assistantArn: String, assistantAssociationArn: String, assistantAssociationId: String, assistantId: String, associationData: AssistantAssociationOutputData, associationType: AssociationType, tags: [String: String]? = nil) {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantAssociationArn = "assistantAssociationArn"
            case assistantAssociationId = "assistantAssociationId"
            case assistantId = "assistantId"
            case associationData = "associationData"
            case associationType = "associationType"
            case tags = "tags"
        }
    }

    public struct AssistantData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        public let assistantArn: String
        /// The identifier of the Wisdom assistant.
        public let assistantId: String
        /// The description.
        public let description: String?
        /// The configuration information for the Wisdom assistant integration.
        public let integrationConfiguration: AssistantIntegrationConfiguration?
        /// The name.
        public let name: String
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, and kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom. To use Wisdom with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey  permissions to the connect.amazonaws.com service principal.  For more information about setting up a customer managed key for Wisdom, see Enable Amazon Connect Wisdom for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        public let status: AssistantStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of assistant.
        public let type: AssistantType

        public init(assistantArn: String, assistantId: String, description: String? = nil, integrationConfiguration: AssistantIntegrationConfiguration? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: AssistantStatus, tags: [String: String]? = nil, type: AssistantType) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case description = "description"
            case integrationConfiguration = "integrationConfiguration"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case status = "status"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct AssistantIntegrationConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public let topicIntegrationArn: String?

        public init(topicIntegrationArn: String? = nil) {
            self.topicIntegrationArn = topicIntegrationArn
        }

        private enum CodingKeys: String, CodingKey {
            case topicIntegrationArn = "topicIntegrationArn"
        }
    }

    public struct AssistantSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        public let assistantArn: String
        /// The identifier of the Wisdom assistant.
        public let assistantId: String
        /// The description of the assistant.
        public let description: String?
        /// The configuration information for the Wisdom assistant integration.
        public let integrationConfiguration: AssistantIntegrationConfiguration?
        /// The name of the assistant.
        public let name: String
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, and kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom. To use Wisdom with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal.  For more information about setting up a customer managed key for Wisdom, see Enable Amazon Connect Wisdom for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        public let status: AssistantStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the assistant.
        public let type: AssistantType

        public init(assistantArn: String, assistantId: String, description: String? = nil, integrationConfiguration: AssistantIntegrationConfiguration? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: AssistantStatus, tags: [String: String]? = nil, type: AssistantType) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case description = "description"
            case integrationConfiguration = "integrationConfiguration"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case status = "status"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct ConnectConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String?

        public init(instanceId: String? = nil) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 4096)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "instanceId"
        }
    }

    public struct ContentData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The identifier of the content.
        public let contentId: String
        /// The media type of the content.
        public let contentType: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String
        /// The URI of the content.
        public let linkOutUri: String?
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]
        /// The name of the content.
        public let name: String
        /// The identifier of the content revision.
        public let revisionId: String
        /// The status of the content.
        public let status: ContentStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content.
        public let title: String
        /// The URL of the content.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        public init(contentArn: String, contentId: String, contentType: String, knowledgeBaseArn: String, knowledgeBaseId: String, linkOutUri: String? = nil, metadata: [String: String], name: String, revisionId: String, status: ContentStatus, tags: [String: String]? = nil, title: String, url: String, urlExpiry: Date) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.linkOutUri = linkOutUri
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn = "contentArn"
            case contentId = "contentId"
            case contentType = "contentType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case linkOutUri = "linkOutUri"
            case metadata = "metadata"
            case name = "name"
            case revisionId = "revisionId"
            case status = "status"
            case tags = "tags"
            case title = "title"
            case url = "url"
            case urlExpiry = "urlExpiry"
        }
    }

    public struct ContentReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String?
        /// The identifier of the content.
        public let contentId: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String?

        public init(contentArn: String? = nil, contentId: String? = nil, knowledgeBaseArn: String? = nil, knowledgeBaseId: String? = nil) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn = "contentArn"
            case contentId = "contentId"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
        }
    }

    public struct ContentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The identifier of the content.
        public let contentId: String
        /// The media type of the content.
        public let contentType: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]
        /// The name of the content.
        public let name: String
        /// The identifier of the revision of the content.
        public let revisionId: String
        /// The status of the content.
        public let status: ContentStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content.
        public let title: String

        public init(contentArn: String, contentId: String, contentType: String, knowledgeBaseArn: String, knowledgeBaseId: String, metadata: [String: String], name: String, revisionId: String, status: ContentStatus, tags: [String: String]? = nil, title: String) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn = "contentArn"
            case contentId = "contentId"
            case contentType = "contentType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case metadata = "metadata"
            case name = "name"
            case revisionId = "revisionId"
            case status = "status"
            case tags = "tags"
            case title = "title"
        }
    }

    public struct CreateAssistantAssociationRequest: AWSEncodableShape {
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifier of the associated resource.
        public let association: AssistantAssociationInputData
        /// The type of association.
        public let associationType: AssociationType
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(assistantId: String, association: AssistantAssociationInputData, associationType: AssociationType, clientToken: String? = CreateAssistantAssociationRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assistantId = assistantId
            self.association = association
            self.associationType = associationType
            self.clientToken = clientToken
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.association, forKey: .association)
            try container.encode(self.associationType, forKey: .associationType)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.association.validate(name: "\(name).association")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case association = "association"
            case associationType = "associationType"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAssistantAssociationResponse: AWSDecodableShape {
        /// The assistant association.
        public let assistantAssociation: AssistantAssociationData?

        public init(assistantAssociation: AssistantAssociationData? = nil) {
            self.assistantAssociation = assistantAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociation = "assistantAssociation"
        }
    }

    public struct CreateAssistantRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the assistant.
        public let description: String?
        /// The name of the assistant.
        public let name: String
        /// The configuration information for the customer managed key used for encryption.  The customer managed key must have a policy that allows kms:CreateGrant, kms:DescribeKey, and kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom. To use Wisdom with chat, the key policy must also allow kms:Decrypt, kms:GenerateDataKey*, and kms:DescribeKey permissions to the connect.amazonaws.com service principal.  For more information about setting up a customer managed key for Wisdom, see Enable Amazon Connect Wisdom for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of assistant.
        public let type: AssistantType

        public init(clientToken: String? = CreateAssistantRequest.idempotencyToken(), description: String? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, tags: [String: String]? = nil, type: AssistantType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateAssistantResponse: AWSDecodableShape {
        /// Information about the assistant.
        public let assistant: AssistantData?

        public init(assistant: AssistantData? = nil) {
            self.assistant = assistant
        }

        private enum CodingKeys: String, CodingKey {
            case assistant = "assistant"
        }
    }

    public struct CreateContentRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]?
        /// The name of the content. Each piece of content in a knowledge base must have a unique name. You can retrieve a piece of content using only its knowledge base and its name with the SearchContent API.
        public let name: String
        /// The URI you want to use for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content.
        public let overrideLinkOutUri: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content. If not set, the title is equal to the name.
        public let title: String?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String

        public init(clientToken: String? = CreateContentRequest.idempotencyToken(), knowledgeBaseId: String, metadata: [String: String]? = nil, name: String, overrideLinkOutUri: String? = nil, tags: [String: String]? = nil, title: String? = nil, uploadId: String) {
            self.clientToken = clientToken
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.overrideLinkOutUri = overrideLinkOutUri
            self.tags = tags
            self.title = title
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.overrideLinkOutUri, forKey: .overrideLinkOutUri)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.title, forKey: .title)
            try container.encode(self.uploadId, forKey: .uploadId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, max: 4096)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.title, name: "title", parent: name, max: 255)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 1200)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case metadata = "metadata"
            case name = "name"
            case overrideLinkOutUri = "overrideLinkOutUri"
            case tags = "tags"
            case title = "title"
            case uploadId = "uploadId"
        }
    }

    public struct CreateContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct CreateKnowledgeBaseRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The type of knowledge base. Only CUSTOM knowledge bases allow you to upload your own content. EXTERNAL knowledge bases support integrations with third-party systems whose content is synchronized automatically.
        public let knowledgeBaseType: KnowledgeBaseType
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant, kms:DescribeKey, and kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom. For more information about setting up a customer managed key for Wisdom, see Enable Amazon Connect Wisdom for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The source of the knowledge base content. Only set this argument for EXTERNAL knowledge bases.
        public let sourceConfiguration: SourceConfiguration?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateKnowledgeBaseRequest.idempotencyToken(), description: String? = nil, knowledgeBaseType: KnowledgeBaseType, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.renderingConfiguration?.validate(name: "\(name).renderingConfiguration")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.sourceConfiguration?.validate(name: "\(name).sourceConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case knowledgeBaseType = "knowledgeBaseType"
            case name = "name"
            case renderingConfiguration = "renderingConfiguration"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case sourceConfiguration = "sourceConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateKnowledgeBaseResponse: AWSDecodableShape {
        /// The knowledge base.
        public let knowledgeBase: KnowledgeBaseData?

        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct CreateQuickResponseRequest: AWSEncodableShape {
        /// The Amazon Connect channels this quick response applies to.
        public let channels: [String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The content of the quick response.
        public let content: QuickResponseDataProvider
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for a quick response written in plain text.   Use application/x.quickresponse;format=markdown for a quick response written in richtext.
        public let contentType: String?
        /// The description of the quick response.
        public let description: String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written.  The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The name of the quick response.
        public let name: String
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(channels: [String]? = nil, clientToken: String? = CreateQuickResponseRequest.idempotencyToken(), content: QuickResponseDataProvider, contentType: String? = nil, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseId: String, language: String? = nil, name: String, shortcutKey: String? = nil, tags: [String: String]? = nil) {
            self.channels = channels
            self.clientToken = clientToken
            self.content = content
            self.contentType = contentType
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.name = name
            self.shortcutKey = shortcutKey
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.channels, forKey: .channels)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.content, forKey: .content)
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.groupingConfiguration, forKey: .groupingConfiguration)
            try container.encodeIfPresent(self.isActive, forKey: .isActive)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.shortcutKey, forKey: .shortcutKey)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.channels?.forEach {
                try validate($0, name: "channels[]", parent: name, max: 10)
                try validate($0, name: "channels[]", parent: name, min: 1)
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.content.validate(name: "\(name).content")
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^(application/x\\.quickresponse;format=(plain|markdown))$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.groupingConfiguration?.validate(name: "\(name).groupingConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.language, name: "language", parent: name, max: 5)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, max: 10)
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case clientToken = "clientToken"
            case content = "content"
            case contentType = "contentType"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case language = "language"
            case name = "name"
            case shortcutKey = "shortcutKey"
            case tags = "tags"
        }
    }

    public struct CreateQuickResponseResponse: AWSDecodableShape {
        /// The quick response.
        public let quickResponse: QuickResponseData?

        public init(quickResponse: QuickResponseData? = nil) {
            self.quickResponse = quickResponse
        }

        private enum CodingKeys: String, CodingKey {
            case quickResponse = "quickResponse"
        }
    }

    public struct CreateSessionRequest: AWSEncodableShape {
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The name of the session.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(assistantId: String, clientToken: String? = CreateSessionRequest.idempotencyToken(), description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: SessionData?

        public init(session: SessionData? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct DeleteAssistantAssociationRequest: AWSEncodableShape {
        /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantAssociationId: String
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        public init(assistantAssociationId: String, assistantId: String) {
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantAssociationId, key: "assistantAssociationId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantAssociationId, name: "assistantAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssistantAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssistantRequest: AWSEncodableShape {
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        public init(assistantId: String) {
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssistantResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContentRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteImportJobRequest: AWSEncodableShape {
        /// The identifier of the import job to be deleted.
        public let importJobId: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String

        public init(importJobId: String, knowledgeBaseId: String) {
            self.importJobId = importJobId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.importJobId, key: "importJobId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.importJobId, name: "importJobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImportJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKnowledgeBaseRequest: AWSEncodableShape {
        /// The knowledge base to delete content from. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKnowledgeBaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteQuickResponseRequest: AWSEncodableShape {
        /// The knowledge base from which the quick response is deleted. The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String
        /// The identifier of the quick response to delete.
        public let quickResponseId: String

        public init(knowledgeBaseId: String, quickResponseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.quickResponseId = quickResponseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.quickResponseId, key: "quickResponseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.quickResponseId, name: "quickResponseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteQuickResponseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Document: AWSDecodableShape {
        /// A reference to the content resource.
        public let contentReference: ContentReference
        /// The excerpt from the document.
        public let excerpt: DocumentText?
        /// The title of the document.
        public let title: DocumentText?

        public init(contentReference: ContentReference, excerpt: DocumentText? = nil, title: DocumentText? = nil) {
            self.contentReference = contentReference
            self.excerpt = excerpt
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case contentReference = "contentReference"
            case excerpt = "excerpt"
            case title = "title"
        }
    }

    public struct DocumentText: AWSDecodableShape {
        /// Highlights in the document text.
        public let highlights: [Highlight]?
        /// Text in the document.
        public let text: String?

        public init(highlights: [Highlight]? = nil, text: String? = nil) {
            self.highlights = highlights
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case highlights = "highlights"
            case text = "text"
        }
    }

    public struct ExternalSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration information of the external data source.
        public let configuration: Configuration
        /// The type of the external data source.
        public let source: ExternalSource

        public init(configuration: Configuration, source: ExternalSource) {
            self.configuration = configuration
            self.source = source
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case source = "source"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The field on which to filter.
        public let field: FilterField
        /// The operator to use for comparing the field’s value with the provided value.
        public let `operator`: FilterOperator
        /// The desired field value on which to filter.
        public let value: String

        public init(field: FilterField, operator: FilterOperator, value: String) {
            self.field = field
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 4096)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case field = "field"
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct GetAssistantAssociationRequest: AWSEncodableShape {
        /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantAssociationId: String
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        public init(assistantAssociationId: String, assistantId: String) {
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantAssociationId, key: "assistantAssociationId")
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantAssociationId, name: "assistantAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssistantAssociationResponse: AWSDecodableShape {
        /// The assistant association.
        public let assistantAssociation: AssistantAssociationData?

        public init(assistantAssociation: AssistantAssociationData? = nil) {
            self.assistantAssociation = assistantAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociation = "assistantAssociation"
        }
    }

    public struct GetAssistantRequest: AWSEncodableShape {
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        public init(assistantId: String) {
            self.assistantId = assistantId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssistantResponse: AWSDecodableShape {
        /// Information about the assistant.
        public let assistant: AssistantData?

        public init(assistant: AssistantData? = nil) {
            self.assistant = assistant
        }

        private enum CodingKeys: String, CodingKey {
            case assistant = "assistant"
        }
    }

    public struct GetContentRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct GetContentSummaryRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContentSummaryResponse: AWSDecodableShape {
        /// The content summary.
        public let contentSummary: ContentSummary?

        public init(contentSummary: ContentSummary? = nil) {
            self.contentSummary = contentSummary
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummary = "contentSummary"
        }
    }

    public struct GetImportJobRequest: AWSEncodableShape {
        /// The identifier of the import job to retrieve.
        public let importJobId: String
        /// The identifier of the knowledge base that the import job belongs to.
        public let knowledgeBaseId: String

        public init(importJobId: String, knowledgeBaseId: String) {
            self.importJobId = importJobId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.importJobId, key: "importJobId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.importJobId, name: "importJobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImportJobResponse: AWSDecodableShape {
        /// The import job.
        public let importJob: ImportJobData?

        public init(importJob: ImportJobData? = nil) {
            self.importJob = importJob
        }

        private enum CodingKeys: String, CodingKey {
            case importJob = "importJob"
        }
    }

    public struct GetKnowledgeBaseRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKnowledgeBaseResponse: AWSDecodableShape {
        /// The knowledge base.
        public let knowledgeBase: KnowledgeBaseData?

        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct GetQuickResponseRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String
        /// The identifier of the quick response.
        public let quickResponseId: String

        public init(knowledgeBaseId: String, quickResponseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.quickResponseId = quickResponseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodePath(self.quickResponseId, key: "quickResponseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.quickResponseId, name: "quickResponseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQuickResponseResponse: AWSDecodableShape {
        /// The quick response.
        public let quickResponse: QuickResponseData?

        public init(quickResponse: QuickResponseData? = nil) {
            self.quickResponse = quickResponse
        }

        private enum CodingKeys: String, CodingKey {
            case quickResponse = "quickResponse"
        }
    }

    public struct GetRecommendationsRequest: AWSEncodableShape {
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String
        /// The duration (in seconds) for which the call waits for a recommendation to be made available before returning. If a recommendation is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call returns successfully with an empty list.
        public let waitTimeSeconds: Int?

        public init(assistantId: String, maxResults: Int? = nil, sessionId: String, waitTimeSeconds: Int? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.sessionId = sessionId
            self.waitTimeSeconds = waitTimeSeconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.sessionId, key: "sessionId")
            request.encodeQuery(self.waitTimeSeconds, key: "waitTimeSeconds")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.waitTimeSeconds, name: "waitTimeSeconds", parent: name, max: 20)
            try self.validate(self.waitTimeSeconds, name: "waitTimeSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecommendationsResponse: AWSDecodableShape {
        /// The recommendations.
        public let recommendations: [RecommendationData]
        /// The triggers corresponding to recommendations.
        public let triggers: [RecommendationTrigger]?

        public init(recommendations: [RecommendationData], triggers: [RecommendationTrigger]? = nil) {
            self.recommendations = recommendations
            self.triggers = triggers
        }

        private enum CodingKeys: String, CodingKey {
            case recommendations = "recommendations"
            case triggers = "triggers"
        }
    }

    public struct GetSessionRequest: AWSEncodableShape {
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String

        public init(assistantId: String, sessionId: String) {
            self.assistantId = assistantId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: SessionData?

        public init(session: SessionData? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct GroupingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The criteria used for grouping Wisdom users. The following is the list of supported criteria values.    RoutingProfileArn: Grouping the users by their Amazon Connect routing profile ARN. User should have SearchRoutingProfile and DescribeRoutingProfile permissions when setting criteria to this value.
        public let criteria: String?
        /// The list of values that define different groups of Wisdom users.   When setting criteria to RoutingProfileArn, you need to provide a list of ARNs of Amazon Connect routing profiles as values of this parameter.
        public let values: [String]?

        public init(criteria: String? = nil, values: [String]? = nil) {
            self.criteria = criteria
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.criteria, name: "criteria", parent: name, max: 100)
            try self.validate(self.criteria, name: "criteria", parent: name, min: 1)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 2048)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case criteria = "criteria"
            case values = "values"
        }
    }

    public struct Highlight: AWSDecodableShape {
        /// The offset for the start of the highlight.
        public let beginOffsetInclusive: Int?
        /// The offset for the end of the highlight.
        public let endOffsetExclusive: Int?

        public init(beginOffsetInclusive: Int? = nil, endOffsetExclusive: Int? = nil) {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffsetInclusive = "beginOffsetInclusive"
            case endOffsetExclusive = "endOffsetExclusive"
        }
    }

    public struct ImportJobData: AWSDecodableShape {
        /// The timestamp when the import job was created.
        public let createdTime: Date
        public let externalSourceConfiguration: ExternalSourceConfiguration?
        /// The link to donwload the information of resource data that failed to be imported.
        public let failedRecordReport: String?
        /// The identifier of the import job.
        public let importJobId: String
        /// The type of the import job.
        public let importJobType: ImportJobType
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String
        /// The timestamp when the import job data was last modified.
        public let lastModifiedTime: Date
        /// The metadata fields of the imported Wisdom resources.
        public let metadata: [String: String]?
        /// The status of the import job.
        public let status: ImportJobStatus
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String
        /// The download link to the resource file that is uploaded to the import job.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        public init(createdTime: Date, externalSourceConfiguration: ExternalSourceConfiguration? = nil, failedRecordReport: String? = nil, importJobId: String, importJobType: ImportJobType, knowledgeBaseArn: String, knowledgeBaseId: String, lastModifiedTime: Date, metadata: [String: String]? = nil, status: ImportJobStatus, uploadId: String, url: String, urlExpiry: Date) {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.failedRecordReport = failedRecordReport
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case externalSourceConfiguration = "externalSourceConfiguration"
            case failedRecordReport = "failedRecordReport"
            case importJobId = "importJobId"
            case importJobType = "importJobType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case lastModifiedTime = "lastModifiedTime"
            case metadata = "metadata"
            case status = "status"
            case uploadId = "uploadId"
            case url = "url"
            case urlExpiry = "urlExpiry"
        }
    }

    public struct ImportJobSummary: AWSDecodableShape {
        /// The timestamp when the import job was created.
        public let createdTime: Date
        /// The configuration information of the external source that the resource data are imported from.
        public let externalSourceConfiguration: ExternalSourceConfiguration?
        /// The identifier of the import job.
        public let importJobId: String
        /// The type of import job.
        public let importJobType: ImportJobType
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String
        /// The timestamp when the import job was last modified.
        public let lastModifiedTime: Date
        /// The metadata fields of the imported Wisdom resources.
        public let metadata: [String: String]?
        /// The status of the import job.
        public let status: ImportJobStatus
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String

        public init(createdTime: Date, externalSourceConfiguration: ExternalSourceConfiguration? = nil, importJobId: String, importJobType: ImportJobType, knowledgeBaseArn: String, knowledgeBaseId: String, lastModifiedTime: Date, metadata: [String: String]? = nil, status: ImportJobStatus, uploadId: String) {
            self.createdTime = createdTime
            self.externalSourceConfiguration = externalSourceConfiguration
            self.importJobId = importJobId
            self.importJobType = importJobType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.status = status
            self.uploadId = uploadId
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "createdTime"
            case externalSourceConfiguration = "externalSourceConfiguration"
            case importJobId = "importJobId"
            case importJobType = "importJobType"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case lastModifiedTime = "lastModifiedTime"
            case metadata = "metadata"
            case status = "status"
            case uploadId = "uploadId"
        }
    }

    public struct KnowledgeBaseAssociationData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String?

        public init(knowledgeBaseArn: String? = nil, knowledgeBaseId: String? = nil) {
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
        }
    }

    public struct KnowledgeBaseData: AWSDecodableShape {
        /// The description.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String
        /// The type of knowledge base.
        public let knowledgeBaseType: KnowledgeBaseType
        /// An epoch timestamp indicating the most recent content modification inside the knowledge base. If no content exists in a knowledge base, this value is unset.
        public let lastContentModificationTime: Date?
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant,  kms:DescribeKey, and kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom.  For more information about setting up a customer managed key for Wisdom, see Enable Amazon Connect Wisdom for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Source configuration information about the knowledge base.
        public let sourceConfiguration: SourceConfiguration?
        /// The status of the knowledge base.
        public let status: KnowledgeBaseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(description: String? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, knowledgeBaseType: KnowledgeBaseType, lastContentModificationTime: Date? = nil, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, status: KnowledgeBaseStatus, tags: [String: String]? = nil) {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.lastContentModificationTime = lastContentModificationTime
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseType = "knowledgeBaseType"
            case lastContentModificationTime = "lastContentModificationTime"
            case name = "name"
            case renderingConfiguration = "renderingConfiguration"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case sourceConfiguration = "sourceConfiguration"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct KnowledgeBaseSummary: AWSDecodableShape {
        /// The description of the knowledge base.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String
        /// The type of knowledge base.
        public let knowledgeBaseType: KnowledgeBaseType
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The configuration information for the customer managed key used for encryption.  This KMS key must have a policy that allows kms:CreateGrant,  kms:DescribeKey, kms:Decrypt/kms:GenerateDataKey permissions to the IAM identity using the key to invoke Wisdom.  For more information about setting up a customer managed key for Wisdom, see Enable Amazon Connect Wisdom for your instance.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Configuration information about the external data source.
        public let sourceConfiguration: SourceConfiguration?
        /// The status of the knowledge base summary.
        public let status: KnowledgeBaseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(description: String? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, knowledgeBaseType: KnowledgeBaseType, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, status: KnowledgeBaseStatus, tags: [String: String]? = nil) {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseType = "knowledgeBaseType"
            case name = "name"
            case renderingConfiguration = "renderingConfiguration"
            case serverSideEncryptionConfiguration = "serverSideEncryptionConfiguration"
            case sourceConfiguration = "sourceConfiguration"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct ListAssistantAssociationsRequest: AWSEncodableShape {
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssistantAssociationsResponse: AWSDecodableShape {
        /// Summary information about assistant associations.
        public let assistantAssociationSummaries: [AssistantAssociationSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(assistantAssociationSummaries: [AssistantAssociationSummary], nextToken: String? = nil) {
            self.assistantAssociationSummaries = assistantAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociationSummaries = "assistantAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssistantsRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssistantsResponse: AWSDecodableShape {
        /// Information about the assistants.
        public let assistantSummaries: [AssistantSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(assistantSummaries: [AssistantSummary], nextToken: String? = nil) {
            self.assistantSummaries = assistantSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assistantSummaries = "assistantSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListContentsRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContentsResponse: AWSDecodableShape {
        /// Information about the content.
        public let contentSummaries: [ContentSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(contentSummaries: [ContentSummary], nextToken: String? = nil) {
            self.contentSummaries = contentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummaries = "contentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportJobsRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListImportJobsResponse: AWSDecodableShape {
        /// Summary information about the import jobs.
        public let importJobSummaries: [ImportJobSummary]
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(importJobSummaries: [ImportJobSummary], nextToken: String? = nil) {
            self.importJobSummaries = importJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case importJobSummaries = "importJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListKnowledgeBasesRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKnowledgeBasesResponse: AWSDecodableShape {
        /// Information about the knowledge bases.
        public let knowledgeBaseSummaries: [KnowledgeBaseSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(knowledgeBaseSummaries: [KnowledgeBaseSummary], nextToken: String? = nil) {
            self.knowledgeBaseSummaries = knowledgeBaseSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseSummaries = "knowledgeBaseSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListQuickResponsesRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQuickResponsesResponse: AWSDecodableShape {
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// Summary information about the quick responses.
        public let quickResponseSummaries: [QuickResponseSummary]

        public init(nextToken: String? = nil, quickResponseSummaries: [QuickResponseSummary]) {
            self.nextToken = nextToken
            self.quickResponseSummaries = quickResponseSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case quickResponseSummaries = "quickResponseSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct NotifyRecommendationsReceivedError: AWSDecodableShape {
        /// A recommendation is causing an error.
        public let message: String?
        /// The identifier of the recommendation that is in error.
        public let recommendationId: String?

        public init(message: String? = nil, recommendationId: String? = nil) {
            self.message = message
            self.recommendationId = recommendationId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case recommendationId = "recommendationId"
        }
    }

    public struct NotifyRecommendationsReceivedRequest: AWSEncodableShape {
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String

        public init(assistantId: String, recommendationIds: [String], sessionId: String) {
            self.assistantId = assistantId
            self.recommendationIds = recommendationIds
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encode(self.recommendationIds, forKey: .recommendationIds)
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.recommendationIds, name: "recommendationIds", parent: name, max: 25)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case recommendationIds = "recommendationIds"
        }
    }

    public struct NotifyRecommendationsReceivedResponse: AWSDecodableShape {
        /// The identifiers of recommendations that are causing errors.
        public let errors: [NotifyRecommendationsReceivedError]?
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]?

        public init(errors: [NotifyRecommendationsReceivedError]? = nil, recommendationIds: [String]? = nil) {
            self.errors = errors
            self.recommendationIds = recommendationIds
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case recommendationIds = "recommendationIds"
        }
    }

    public struct QueryAssistantRequest: AWSEncodableShape {
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The text to search for.
        public let queryText: String

        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, queryText: String) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryText = queryText
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.queryText, forKey: .queryText)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case queryText = "queryText"
        }
    }

    public struct QueryAssistantResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The results of the query.
        public let results: [ResultData]

        public init(nextToken: String? = nil, results: [ResultData]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct QueryRecommendationTriggerData: AWSDecodableShape {
        /// The text associated with the recommendation trigger.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct QuickResponseContents: AWSDecodableShape {
        public let markdown: QuickResponseContentProvider?
        public let plainText: QuickResponseContentProvider?

        public init(markdown: QuickResponseContentProvider? = nil, plainText: QuickResponseContentProvider? = nil) {
            self.markdown = markdown
            self.plainText = plainText
        }

        private enum CodingKeys: String, CodingKey {
            case markdown = "markdown"
            case plainText = "plainText"
        }
    }

    public struct QuickResponseData: AWSDecodableShape {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The contents of the quick response.
        public let contents: QuickResponseContents?
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String
        /// The timestamp when the quick response was created.
        public let createdTime: Date
        /// The description of the quick response.
        public let description: String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written.
        public let language: String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public let lastModifiedBy: String?
        /// The timestamp when the quick response data was last modified.
        public let lastModifiedTime: Date
        /// The name of the quick response.
        public let name: String
        /// The Amazon Resource Name (ARN) of the quick response.
        public let quickResponseArn: String
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?
        /// The status of the quick response data.
        public let status: QuickResponseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(channels: [String]? = nil, contents: QuickResponseContents? = nil, contentType: String, createdTime: Date, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, language: String? = nil, lastModifiedBy: String? = nil, lastModifiedTime: Date, name: String, quickResponseArn: String, quickResponseId: String, shortcutKey: String? = nil, status: QuickResponseStatus, tags: [String: String]? = nil) {
            self.channels = channels
            self.contents = contents
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case contents = "contents"
            case contentType = "contentType"
            case createdTime = "createdTime"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case language = "language"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case quickResponseArn = "quickResponseArn"
            case quickResponseId = "quickResponseId"
            case shortcutKey = "shortcutKey"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct QuickResponseFilterField: AWSEncodableShape {
        /// Whether to treat null value as a match for the attribute field.
        public let includeNoExistence: Bool?
        /// The name of the attribute field to filter the quick responses by.
        public let name: String
        /// The operator to use for filtering.
        public let `operator`: QuickResponseFilterOperator
        /// The values of attribute field to filter the quick response by.
        public let values: [String]?

        public init(includeNoExistence: Bool? = nil, name: String, operator: QuickResponseFilterOperator, values: [String]? = nil) {
            self.includeNoExistence = includeNoExistence
            self.name = name
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 2048)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case includeNoExistence = "includeNoExistence"
            case name = "name"
            case `operator` = "operator"
            case values = "values"
        }
    }

    public struct QuickResponseOrderField: AWSEncodableShape {
        /// The name of the attribute to order the quick response query results by.
        public let name: String
        /// The order at which the quick responses are sorted by.
        public let order: Order?

        public init(name: String, order: Order? = nil) {
            self.name = name
            self.order = order
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case order = "order"
        }
    }

    public struct QuickResponseQueryField: AWSEncodableShape {
        /// Whether the query expects only exact matches on the attribute field values. The results of the query will only include exact matches if this parameter is set to false.
        public let allowFuzziness: Bool?
        /// The name of the attribute to query the quick responses by.
        public let name: String
        /// The operator to use for matching attribute field values in the query.
        public let `operator`: QuickResponseQueryOperator
        /// The importance of the attribute field when calculating query result relevancy scores. The value set for this parameter affects the ordering of search results.
        public let priority: Priority?
        /// The values of the attribute to query the quick responses by.
        public let values: [String]

        public init(allowFuzziness: Bool? = nil, name: String, operator: QuickResponseQueryOperator, priority: Priority? = nil, values: [String]) {
            self.allowFuzziness = allowFuzziness
            self.name = name
            self.`operator` = `operator`
            self.priority = priority
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 5)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowFuzziness = "allowFuzziness"
            case name = "name"
            case `operator` = "operator"
            case priority = "priority"
            case values = "values"
        }
    }

    public struct QuickResponseSearchExpression: AWSEncodableShape {
        /// The configuration of filtering rules applied to quick response query results.
        public let filters: [QuickResponseFilterField]?
        /// The quick response attribute fields on which the query results are ordered.
        public let orderOnField: QuickResponseOrderField?
        /// The quick response query expressions.
        public let queries: [QuickResponseQueryField]?

        public init(filters: [QuickResponseFilterField]? = nil, orderOnField: QuickResponseOrderField? = nil, queries: [QuickResponseQueryField]? = nil) {
            self.filters = filters
            self.orderOnField = orderOnField
            self.queries = queries
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 10)
            try self.orderOnField?.validate(name: "\(name).orderOnField")
            try self.queries?.forEach {
                try $0.validate(name: "\(name).queries[]")
            }
            try self.validate(self.queries, name: "queries", parent: name, max: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case orderOnField = "orderOnField"
            case queries = "queries"
        }
    }

    public struct QuickResponseSearchResultData: AWSDecodableShape {
        /// The user defined contact attributes that are resolved when the search result is returned.
        public let attributesInterpolated: [String]?
        /// The user defined contact attributes that are not resolved when the search result is returned.
        public let attributesNotInterpolated: [String]?
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The contents of the quick response.
        public let contents: QuickResponseContents
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String
        /// The timestamp when the quick response was created.
        public let createdTime: Date
        /// The description of the quick response.
        public let description: String?
        /// The configuration information of the user groups that the quick response is accessible to.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written.
        public let language: String?
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response search result data.
        public let lastModifiedBy: String?
        /// The timestamp when the quick response search result data was last modified.
        public let lastModifiedTime: Date
        /// The name of the quick response.
        public let name: String
        /// The Amazon Resource Name (ARN) of the quick response.
        public let quickResponseArn: String
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?
        /// The resource status of the quick response.
        public let status: QuickResponseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(attributesInterpolated: [String]? = nil, attributesNotInterpolated: [String]? = nil, channels: [String]? = nil, contents: QuickResponseContents, contentType: String, createdTime: Date, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool, knowledgeBaseArn: String, knowledgeBaseId: String, language: String? = nil, lastModifiedBy: String? = nil, lastModifiedTime: Date, name: String, quickResponseArn: String, quickResponseId: String, shortcutKey: String? = nil, status: QuickResponseStatus, tags: [String: String]? = nil) {
            self.attributesInterpolated = attributesInterpolated
            self.attributesNotInterpolated = attributesNotInterpolated
            self.channels = channels
            self.contents = contents
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.shortcutKey = shortcutKey
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attributesInterpolated = "attributesInterpolated"
            case attributesNotInterpolated = "attributesNotInterpolated"
            case channels = "channels"
            case contents = "contents"
            case contentType = "contentType"
            case createdTime = "createdTime"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case language = "language"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case quickResponseArn = "quickResponseArn"
            case quickResponseId = "quickResponseId"
            case shortcutKey = "shortcutKey"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct QuickResponseSummary: AWSDecodableShape {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String
        /// The timestamp when the quick response was created.
        public let createdTime: Date
        /// The description of the quick response.
        public let description: String?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String
        /// The Amazon Resource Name (ARN) of the user who last updated the quick response data.
        public let lastModifiedBy: String?
        /// The timestamp when the quick response summary was last modified.
        public let lastModifiedTime: Date
        /// The name of the quick response.
        public let name: String
        /// The Amazon Resource Name (ARN) of the quick response.
        public let quickResponseArn: String
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// The resource status of the quick response.
        public let status: QuickResponseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(channels: [String]? = nil, contentType: String, createdTime: Date, description: String? = nil, isActive: Bool? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, lastModifiedBy: String? = nil, lastModifiedTime: Date, name: String, quickResponseArn: String, quickResponseId: String, status: QuickResponseStatus, tags: [String: String]? = nil) {
            self.channels = channels
            self.contentType = contentType
            self.createdTime = createdTime
            self.description = description
            self.isActive = isActive
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickResponseArn = quickResponseArn
            self.quickResponseId = quickResponseId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case contentType = "contentType"
            case createdTime = "createdTime"
            case description = "description"
            case isActive = "isActive"
            case knowledgeBaseArn = "knowledgeBaseArn"
            case knowledgeBaseId = "knowledgeBaseId"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case name = "name"
            case quickResponseArn = "quickResponseArn"
            case quickResponseId = "quickResponseId"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct RecommendationData: AWSDecodableShape {
        /// The recommended document.
        public let document: Document
        /// The identifier of the recommendation.
        public let recommendationId: String
        /// The relevance level of the recommendation.
        public let relevanceLevel: RelevanceLevel?
        /// The relevance score of the recommendation.
        public let relevanceScore: Double?
        /// The type of recommendation.
        public let type: RecommendationType?

        public init(document: Document, recommendationId: String, relevanceLevel: RelevanceLevel? = nil, relevanceScore: Double? = nil, type: RecommendationType? = nil) {
            self.document = document
            self.recommendationId = recommendationId
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
            case recommendationId = "recommendationId"
            case relevanceLevel = "relevanceLevel"
            case relevanceScore = "relevanceScore"
            case type = "type"
        }
    }

    public struct RecommendationTrigger: AWSDecodableShape {
        /// A union type containing information related to the trigger.
        public let data: RecommendationTriggerData
        /// The identifier of the recommendation trigger.
        public let id: String
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]
        /// The source of the recommendation trigger.   ISSUE_DETECTION: The corresponding recommendations were triggered by a Contact Lens issue.   RULE_EVALUATION: The corresponding recommendations were triggered by a Contact Lens rule.
        public let source: RecommendationSourceType
        /// The type of recommendation trigger.
        public let type: RecommendationTriggerType

        public init(data: RecommendationTriggerData, id: String, recommendationIds: [String], source: RecommendationSourceType, type: RecommendationTriggerType) {
            self.data = data
            self.id = id
            self.recommendationIds = recommendationIds
            self.source = source
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case id = "id"
            case recommendationIds = "recommendationIds"
            case source = "source"
            case type = "type"
        }
    }

    public struct RemoveKnowledgeBaseTemplateUriRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveKnowledgeBaseTemplateUriResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RenderingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A URI template containing exactly one variable in ${variableName} format. This can only be set for EXTERNAL knowledge bases. For Salesforce, ServiceNow, and Zendesk, the variable must be one of the following:   Salesforce: Id, ArticleNumber, VersionNumber, Title, PublishStatus, or IsDeleted    ServiceNow: number, short_description, sys_mod_count, workflow_state, or active    Zendesk: id, title, updated_at, or draft    The variable is replaced with the actual value for a piece of content when calling GetContent.
        public let templateUri: String?

        public init(templateUri: String? = nil) {
            self.templateUri = templateUri
        }

        public func validate(name: String) throws {
            try self.validate(self.templateUri, name: "templateUri", parent: name, max: 4096)
            try self.validate(self.templateUri, name: "templateUri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateUri = "templateUri"
        }
    }

    public struct ResultData: AWSDecodableShape {
        /// The document.
        public let document: Document
        /// The relevance score of the results.
        public let relevanceScore: Double?
        /// The identifier of the result data.
        public let resultId: String

        public init(document: Document, relevanceScore: Double? = nil, resultId: String) {
            self.document = document
            self.relevanceScore = relevanceScore
            self.resultId = resultId
        }

        private enum CodingKeys: String, CodingKey {
            case document = "document"
            case relevanceScore = "relevanceScore"
            case resultId = "resultId"
        }
    }

    public struct SearchContentRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression to filter results.
        public let searchExpression: SearchExpression

        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: SearchExpression) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchExpression, forKey: .searchExpression)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case searchExpression = "searchExpression"
        }
    }

    public struct SearchContentResponse: AWSDecodableShape {
        /// Summary information about the content.
        public let contentSummaries: [ContentSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(contentSummaries: [ContentSummary], nextToken: String? = nil) {
            self.contentSummaries = contentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummaries = "contentSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct SearchExpression: AWSEncodableShape {
        /// The search expression filters.
        public let filters: [Filter]

        public init(filters: [Filter]) {
            self.filters = filters
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct SearchQuickResponsesRequest: AWSEncodableShape {
        /// The user-defined Amazon Connect contact attributes to be resolved when search results are returned.
        public let attributes: [String: String]?
        /// The identifier of the knowledge base. This should be a QUICK_RESPONSES type knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression for querying the quick response.
        public let searchExpression: QuickResponseSearchExpression

        public init(attributes: [String: String]? = nil, knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: QuickResponseSearchExpression) {
            self.attributes = attributes
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchExpression, forKey: .searchExpression)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case searchExpression = "searchExpression"
        }
    }

    public struct SearchQuickResponsesResponse: AWSDecodableShape {
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The results of the quick response search.
        public let results: [QuickResponseSearchResultData]

        public init(nextToken: String? = nil, results: [QuickResponseSearchResultData]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case results = "results"
        }
    }

    public struct SearchSessionsRequest: AWSEncodableShape {
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression to filter results.
        public let searchExpression: SearchExpression

        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: SearchExpression) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assistantId, key: "assistantId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.searchExpression, forKey: .searchExpression)
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case searchExpression = "searchExpression"
        }
    }

    public struct SearchSessionsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Summary information about the sessions.
        public let sessionSummaries: [SessionSummary]

        public init(nextToken: String? = nil, sessionSummaries: [SessionSummary]) {
            self.nextToken = nextToken
            self.sessionSummaries = sessionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessionSummaries = "sessionSummaries"
        }
    }

    public struct ServerSideEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The customer managed key used for encryption. For more information about setting up a customer managed key for Wisdom, see Enable Amazon Connect Wisdom for your instance. For information about valid ID values, see Key identifiers (KeyId).
        public let kmsKeyId: String?

        public init(kmsKeyId: String? = nil) {
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 4096)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct SessionData: AWSDecodableShape {
        /// The description of the session.
        public let description: String?
        /// The configuration information for the session integration.
        public let integrationConfiguration: SessionIntegrationConfiguration?
        /// The name of the session.
        public let name: String
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The identifier of the session.
        public let sessionId: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(description: String? = nil, integrationConfiguration: SessionIntegrationConfiguration? = nil, name: String, sessionArn: String, sessionId: String, tags: [String: String]? = nil) {
            self.description = description
            self.integrationConfiguration = integrationConfiguration
            self.name = name
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case integrationConfiguration = "integrationConfiguration"
            case name = "name"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
            case tags = "tags"
        }
    }

    public struct SessionIntegrationConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the integrated Amazon SNS topic used for streaming chat messages.
        public let topicIntegrationArn: String?

        public init(topicIntegrationArn: String? = nil) {
            self.topicIntegrationArn = topicIntegrationArn
        }

        private enum CodingKeys: String, CodingKey {
            case topicIntegrationArn = "topicIntegrationArn"
        }
    }

    public struct SessionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        public let assistantArn: String
        /// The identifier of the Wisdom assistant.
        public let assistantId: String
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The identifier of the session.
        public let sessionId: String

        public init(assistantArn: String, assistantId: String, sessionArn: String, sessionId: String) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn = "assistantArn"
            case assistantId = "assistantId"
            case sessionArn = "sessionArn"
            case sessionId = "sessionId"
        }
    }

    public struct StartContentUploadRequest: AWSEncodableShape {
        /// The type of content to upload.
        public let contentType: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The expected expiration time of the generated presigned URL, specified in minutes.
        public let presignedUrlTimeToLive: Int?

        public init(contentType: String, knowledgeBaseId: String, presignedUrlTimeToLive: Int? = nil) {
            self.contentType = contentType
            self.knowledgeBaseId = knowledgeBaseId
            self.presignedUrlTimeToLive = presignedUrlTimeToLive
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.contentType, forKey: .contentType)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.presignedUrlTimeToLive, forKey: .presignedUrlTimeToLive)
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^(text/(plain|html|csv))|(application/(pdf|vnd\\.openxmlformats-officedocument\\.wordprocessingml\\.document))|(application/x\\.wisdom-json;source=(salesforce|servicenow|zendesk))$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.presignedUrlTimeToLive, name: "presignedUrlTimeToLive", parent: name, max: 60)
            try self.validate(self.presignedUrlTimeToLive, name: "presignedUrlTimeToLive", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case presignedUrlTimeToLive = "presignedUrlTimeToLive"
        }
    }

    public struct StartContentUploadResponse: AWSDecodableShape {
        /// The headers to include in the upload.
        public let headersToInclude: [String: String]
        /// The identifier of the upload.
        public let uploadId: String
        /// The URL of the upload.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        public init(headersToInclude: [String: String], uploadId: String, url: String, urlExpiry: Date) {
            self.headersToInclude = headersToInclude
            self.uploadId = uploadId
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case headersToInclude = "headersToInclude"
            case uploadId = "uploadId"
            case url = "url"
            case urlExpiry = "urlExpiry"
        }
    }

    public struct StartImportJobRequest: AWSEncodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let clientToken: String?
        /// The configuration information of the external source that the resource data are imported from.
        public let externalSourceConfiguration: ExternalSourceConfiguration?
        /// The type of the import job.   For importing quick response resource, set the value to QUICK_RESPONSES.
        public let importJobType: ImportJobType
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.   For importing Wisdom quick responses, this should be a QUICK_RESPONSES type knowledge base.
        public let knowledgeBaseId: String
        /// The metadata fields of the imported Wisdom resources.
        public let metadata: [String: String]?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String

        public init(clientToken: String? = StartImportJobRequest.idempotencyToken(), externalSourceConfiguration: ExternalSourceConfiguration? = nil, importJobType: ImportJobType, knowledgeBaseId: String, metadata: [String: String]? = nil, uploadId: String) {
            self.clientToken = clientToken
            self.externalSourceConfiguration = externalSourceConfiguration
            self.importJobType = importJobType
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.externalSourceConfiguration, forKey: .externalSourceConfiguration)
            try container.encode(self.importJobType, forKey: .importJobType)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encode(self.uploadId, forKey: .uploadId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.externalSourceConfiguration?.validate(name: "\(name).externalSourceConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 1200)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case externalSourceConfiguration = "externalSourceConfiguration"
            case importJobType = "importJobType"
            case metadata = "metadata"
            case uploadId = "uploadId"
        }
    }

    public struct StartImportJobResponse: AWSDecodableShape {
        /// The import job.
        public let importJob: ImportJobData?

        public init(importJob: ImportJobData? = nil) {
            self.importJob = importJob
        }

        private enum CodingKeys: String, CodingKey {
            case importJob = "importJob"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContentRequest: AWSEncodableShape {
        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]?
        /// The URI for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content. To remove an existing overrideLinkOurUri, exclude this argument and set removeOverrideLinkOutUri to true.
        public let overrideLinkOutUri: String?
        /// Unset the existing overrideLinkOutUri if it exists.
        public let removeOverrideLinkOutUri: Bool?
        /// The revisionId of the content resource to update, taken from an earlier call to GetContent, GetContentSummary, SearchContent, or ListContents. If included, this argument acts as an optimistic lock to ensure content was not modified since it was last read. If it has been modified, this API throws a PreconditionFailedException.
        public let revisionId: String?
        /// The title of the content.
        public let title: String?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String?

        public init(contentId: String, knowledgeBaseId: String, metadata: [String: String]? = nil, overrideLinkOutUri: String? = nil, removeOverrideLinkOutUri: Bool? = nil, revisionId: String? = nil, title: String? = nil, uploadId: String? = nil) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.overrideLinkOutUri = overrideLinkOutUri
            self.removeOverrideLinkOutUri = removeOverrideLinkOutUri
            self.revisionId = revisionId
            self.title = title
            self.uploadId = uploadId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contentId, key: "contentId")
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encodeIfPresent(self.overrideLinkOutUri, forKey: .overrideLinkOutUri)
            try container.encodeIfPresent(self.removeOverrideLinkOutUri, forKey: .removeOverrideLinkOutUri)
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
            try container.encodeIfPresent(self.title, forKey: .title)
            try container.encodeIfPresent(self.uploadId, forKey: .uploadId)
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, max: 4096)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, min: 1)
            try self.validate(self.revisionId, name: "revisionId", parent: name, max: 4096)
            try self.validate(self.revisionId, name: "revisionId", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 255)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 1200)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case overrideLinkOutUri = "overrideLinkOutUri"
            case removeOverrideLinkOutUri = "removeOverrideLinkOutUri"
            case revisionId = "revisionId"
            case title = "title"
            case uploadId = "uploadId"
        }
    }

    public struct UpdateContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct UpdateKnowledgeBaseTemplateUriRequest: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The template URI to update.
        public let templateUri: String

        public init(knowledgeBaseId: String, templateUri: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.templateUri = templateUri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encode(self.templateUri, forKey: .templateUri)
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.templateUri, name: "templateUri", parent: name, max: 4096)
            try self.validate(self.templateUri, name: "templateUri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateUri = "templateUri"
        }
    }

    public struct UpdateKnowledgeBaseTemplateUriResponse: AWSDecodableShape {
        /// The knowledge base to update.
        public let knowledgeBase: KnowledgeBaseData?

        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase = "knowledgeBase"
        }
    }

    public struct UpdateQuickResponseRequest: AWSEncodableShape {
        /// The Amazon Connect contact channels this quick response applies to. The supported contact channel types include Chat.
        public let channels: [String]?
        /// The updated content of the quick response.
        public let content: QuickResponseDataProvider?
        /// The media type of the quick response content.   Use application/x.quickresponse;format=plain for quick response written in plain text.   Use application/x.quickresponse;format=markdown for quick response written in richtext.
        public let contentType: String?
        /// The updated description of the quick response.
        public let description: String?
        /// The updated grouping configuration of the quick response.
        public let groupingConfiguration: GroupingConfiguration?
        /// Whether the quick response is active.
        public let isActive: Bool?
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The language code value for the language in which the quick response is written. The supported language codes include de_DE, en_US, es_ES, fr_FR, id_ID, it_IT, ja_JP, ko_KR, pt_BR, zh_CN, zh_TW
        public let language: String?
        /// The name of the quick response.
        public let name: String?
        /// The identifier of the quick response.
        public let quickResponseId: String
        /// Whether to remove the description from the quick response.
        public let removeDescription: Bool?
        /// Whether to remove the grouping configuration of the quick response.
        public let removeGroupingConfiguration: Bool?
        /// Whether to remove the shortcut key of the quick response.
        public let removeShortcutKey: Bool?
        /// The shortcut key of the quick response. The value should be unique across the knowledge base.
        public let shortcutKey: String?

        public init(channels: [String]? = nil, content: QuickResponseDataProvider? = nil, contentType: String? = nil, description: String? = nil, groupingConfiguration: GroupingConfiguration? = nil, isActive: Bool? = nil, knowledgeBaseId: String, language: String? = nil, name: String? = nil, quickResponseId: String, removeDescription: Bool? = nil, removeGroupingConfiguration: Bool? = nil, removeShortcutKey: Bool? = nil, shortcutKey: String? = nil) {
            self.channels = channels
            self.content = content
            self.contentType = contentType
            self.description = description
            self.groupingConfiguration = groupingConfiguration
            self.isActive = isActive
            self.knowledgeBaseId = knowledgeBaseId
            self.language = language
            self.name = name
            self.quickResponseId = quickResponseId
            self.removeDescription = removeDescription
            self.removeGroupingConfiguration = removeGroupingConfiguration
            self.removeShortcutKey = removeShortcutKey
            self.shortcutKey = shortcutKey
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.channels, forKey: .channels)
            try container.encodeIfPresent(self.content, forKey: .content)
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.groupingConfiguration, forKey: .groupingConfiguration)
            try container.encodeIfPresent(self.isActive, forKey: .isActive)
            request.encodePath(self.knowledgeBaseId, key: "knowledgeBaseId")
            try container.encodeIfPresent(self.language, forKey: .language)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.quickResponseId, key: "quickResponseId")
            try container.encodeIfPresent(self.removeDescription, forKey: .removeDescription)
            try container.encodeIfPresent(self.removeGroupingConfiguration, forKey: .removeGroupingConfiguration)
            try container.encodeIfPresent(self.removeShortcutKey, forKey: .removeShortcutKey)
            try container.encodeIfPresent(self.shortcutKey, forKey: .shortcutKey)
        }

        public func validate(name: String) throws {
            try self.channels?.forEach {
                try validate($0, name: "channels[]", parent: name, max: 10)
                try validate($0, name: "channels[]", parent: name, min: 1)
            }
            try self.content?.validate(name: "\(name).content")
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^(application/x\\.quickresponse;format=(plain|markdown))$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.groupingConfiguration?.validate(name: "\(name).groupingConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.language, name: "language", parent: name, max: 5)
            try self.validate(self.language, name: "language", parent: name, min: 2)
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.quickResponseId, name: "quickResponseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, max: 10)
            try self.validate(self.shortcutKey, name: "shortcutKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case content = "content"
            case contentType = "contentType"
            case description = "description"
            case groupingConfiguration = "groupingConfiguration"
            case isActive = "isActive"
            case language = "language"
            case name = "name"
            case removeDescription = "removeDescription"
            case removeGroupingConfiguration = "removeGroupingConfiguration"
            case removeShortcutKey = "removeShortcutKey"
            case shortcutKey = "shortcutKey"
        }
    }

    public struct UpdateQuickResponseResponse: AWSDecodableShape {
        /// The quick response.
        public let quickResponse: QuickResponseData?

        public init(quickResponse: QuickResponseData? = nil) {
            self.quickResponse = quickResponse
        }

        private enum CodingKeys: String, CodingKey {
            case quickResponse = "quickResponse"
        }
    }

    public struct AssistantAssociationInputData: AWSEncodableShape {
        /// The identifier of the knowledge base. This should not be a QUICK_RESPONSES type knowledge
        /// base if you're storing Wisdom Content resource to it.
        public let knowledgeBaseId: String?

        public init(knowledgeBaseId: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
        }
    }

    public struct AssistantAssociationOutputData: AWSDecodableShape {
        /// The knowledge base where output data is sent.
        public let knowledgeBaseAssociation: KnowledgeBaseAssociationData?

        public init(knowledgeBaseAssociation: KnowledgeBaseAssociationData? = nil) {
            self.knowledgeBaseAssociation = knowledgeBaseAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseAssociation = "knowledgeBaseAssociation"
        }
    }

    public struct Configuration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration information of the Amazon Connect data source.
        public let connectConfiguration: ConnectConfiguration?

        public init(connectConfiguration: ConnectConfiguration? = nil) {
            self.connectConfiguration = connectConfiguration
        }

        public func validate(name: String) throws {
            try self.connectConfiguration?.validate(name: "\(name).connectConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case connectConfiguration = "connectConfiguration"
        }
    }

    public struct QuickResponseContentProvider: AWSDecodableShape {
        /// The content of the quick response.
        public let content: String?

        public init(content: String? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct QuickResponseDataProvider: AWSEncodableShape {
        /// The content of the quick response.
        public let content: String?

        public init(content: String? = nil) {
            self.content = content
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 1024)
            try self.validate(self.content, name: "content", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
        }
    }

    public struct RecommendationTriggerData: AWSDecodableShape {
        /// Data associated with the QUERY RecommendationTriggerType.
        public let query: QueryRecommendationTriggerData?

        public init(query: QueryRecommendationTriggerData? = nil) {
            self.query = query
        }

        private enum CodingKeys: String, CodingKey {
            case query = "query"
        }
    }

    public struct SourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration information for Amazon AppIntegrations to automatically ingest content.
        public let appIntegrations: AppIntegrationsConfiguration?

        public init(appIntegrations: AppIntegrationsConfiguration? = nil) {
            self.appIntegrations = appIntegrations
        }

        public func validate(name: String) throws {
            try self.appIntegrations?.validate(name: "\(name).appIntegrations")
        }

        private enum CodingKeys: String, CodingKey {
            case appIntegrations = "appIntegrations"
        }
    }
}

// MARK: - Errors

/// Error enum for Wisdom
public struct WisdomErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case preconditionFailedException = "PreconditionFailedException"
        case requestTimeoutException = "RequestTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Wisdom
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be processed because of conflict in the current state of the resource. For example, if you're using a Create API (such as CreateAssistant) that accepts name, a conflicting resource (usually with the same name) is being created or mutated.
    public static var conflictException: Self { .init(.conflictException) }
    /// The provided revisionId does not match, indicating the content has been modified since it was last read.
    public static var preconditionFailedException: Self { .init(.preconditionFailedException) }
    /// The request reached the service more than 15 minutes after the date stamp on the request or more than 15 minutes after the request expiration date (such as for pre-signed URLs), or the date stamp on the request is more than 15 minutes in the future.
    public static var requestTimeoutException: Self { .init(.requestTimeoutException) }
    /// The specified resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You've exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use service quotas to request a service quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Amazon Connect Wisdom throws this exception if you have too many tags in your tag set.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The input fails to satisfy the constraints specified by a service.
    public static var validationException: Self { .init(.validationException) }
}

extension WisdomErrorType: Equatable {
    public static func == (lhs: WisdomErrorType, rhs: WisdomErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension WisdomErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
