//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Wisdom {
    // MARK: Enums

    public enum AssistantStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AssistantType: String, CustomStringConvertible, Codable, _SotoSendable {
        case agent = "AGENT"
        public var description: String { return self.rawValue }
    }

    public enum AssociationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum ContentStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum FilterField: String, CustomStringConvertible, Codable, _SotoSendable {
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum FilterOperator: String, CustomStringConvertible, Codable, _SotoSendable {
        case equals = "EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum KnowledgeBaseType: String, CustomStringConvertible, Codable, _SotoSendable {
        case custom = "CUSTOM"
        case external = "EXTERNAL"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationSourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case issueDetection = "ISSUE_DETECTION"
        case other = "OTHER"
        case ruleEvaluation = "RULE_EVALUATION"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationTriggerType: String, CustomStringConvertible, Codable, _SotoSendable {
        case query = "QUERY"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case knowledgeContent = "KNOWLEDGE_CONTENT"
        public var description: String { return self.rawValue }
    }

    public enum RelevanceLevel: String, CustomStringConvertible, Codable, _SotoSendable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AppIntegrationsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AppIntegrations DataIntegration to use for ingesting content.
        public let appIntegrationArn: String
        /// The fields from the source that are made available to your agents in Wisdom.    For  Salesforce, you must include at least Id, ArticleNumber, VersionNumber, Title, PublishStatus, and IsDeleted.    For  ServiceNow, you must include at least number, short_description, sys_mod_count, workflow_state, and active.    Make sure to include additional fields. These fields are indexed and used to source recommendations.
        public let objectFields: [String]

        public init(appIntegrationArn: String, objectFields: [String]) {
            self.appIntegrationArn = appIntegrationArn
            self.objectFields = objectFields
        }

        public func validate(name: String) throws {
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, max: 2048)
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, min: 1)
            try self.validate(self.appIntegrationArn, name: "appIntegrationArn", parent: name, pattern: "^arn:[a-z-]+?:[a-z-]+?:[a-z0-9-]*?:([0-9]{12})?:[a-zA-Z0-9-:/]+$")
            try self.objectFields.forEach {
                try validate($0, name: "objectFields[]", parent: name, max: 4096)
                try validate($0, name: "objectFields[]", parent: name, min: 1)
            }
            try self.validate(self.objectFields, name: "objectFields", parent: name, max: 100)
            try self.validate(self.objectFields, name: "objectFields", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appIntegrationArn
            case objectFields
        }
    }

    public struct AssistantAssociationData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        public let assistantArn: String
        /// The Amazon Resource Name (ARN) of the assistant association.
        public let assistantAssociationArn: String
        /// The identifier of the assistant association.
        public let assistantAssociationId: String
        /// The identifier of the Wisdom assistant.
        public let assistantId: String
        /// A union type that currently has a single argument, the knowledge base ID.
        public let associationData: AssistantAssociationOutputData
        /// The type of association.
        public let associationType: AssociationType
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(assistantArn: String, assistantAssociationArn: String, assistantAssociationId: String, assistantId: String, associationData: AssistantAssociationOutputData, associationType: AssociationType, tags: [String: String]? = nil) {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn
            case assistantAssociationArn
            case assistantAssociationId
            case assistantId
            case associationData
            case associationType
            case tags
        }
    }

    public struct AssistantAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        public let assistantArn: String
        /// The Amazon Resource Name (ARN) of the assistant association.
        public let assistantAssociationArn: String
        /// The identifier of the assistant association.
        public let assistantAssociationId: String
        /// The identifier of the Wisdom assistant.
        public let assistantId: String
        /// The association data.
        public let associationData: AssistantAssociationOutputData
        /// The type of association.
        public let associationType: AssociationType
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(assistantArn: String, assistantAssociationArn: String, assistantAssociationId: String, assistantId: String, associationData: AssistantAssociationOutputData, associationType: AssociationType, tags: [String: String]? = nil) {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn
            case assistantAssociationArn
            case assistantAssociationId
            case assistantId
            case associationData
            case associationType
            case tags
        }
    }

    public struct AssistantData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        public let assistantArn: String
        /// The identifier of the Wisdom assistant.
        public let assistantId: String
        /// The description.
        public let description: String?
        /// The name.
        public let name: String
        /// The KMS key used for encryption.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        public let status: AssistantStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of assistant.
        public let type: AssistantType

        public init(assistantArn: String, assistantId: String, description: String? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: AssistantStatus, tags: [String: String]? = nil, type: AssistantType) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn
            case assistantId
            case description
            case name
            case serverSideEncryptionConfiguration
            case status
            case tags
            case type
        }
    }

    public struct AssistantSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        public let assistantArn: String
        /// The identifier of the Wisdom assistant.
        public let assistantId: String
        /// The description of the assistant.
        public let description: String?
        /// The name of the assistant.
        public let name: String
        /// The KMS key used for encryption.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        public let status: AssistantStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of the assistant.
        public let type: AssistantType

        public init(assistantArn: String, assistantId: String, description: String? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, status: AssistantStatus, tags: [String: String]? = nil, type: AssistantType) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn
            case assistantId
            case description
            case name
            case serverSideEncryptionConfiguration
            case status
            case tags
            case type
        }
    }

    public struct ContentData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The identifier of the content.
        public let contentId: String
        /// The media type of the content.
        public let contentType: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The URI of the content.
        public let linkOutUri: String?
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]
        /// The name of the content.
        public let name: String
        /// The identifier of the content revision.
        public let revisionId: String
        /// The status of the content.
        public let status: ContentStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content.
        public let title: String
        /// The URL of the content.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        public init(contentArn: String, contentId: String, contentType: String, knowledgeBaseArn: String, knowledgeBaseId: String, linkOutUri: String? = nil, metadata: [String: String], name: String, revisionId: String, status: ContentStatus, tags: [String: String]? = nil, title: String, url: String, urlExpiry: Date) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.linkOutUri = linkOutUri
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn
            case contentId
            case contentType
            case knowledgeBaseArn
            case knowledgeBaseId
            case linkOutUri
            case metadata
            case name
            case revisionId
            case status
            case tags
            case title
            case url
            case urlExpiry
        }
    }

    public struct ContentReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String?
        /// The identifier of the content.
        public let contentId: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String?
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String?

        public init(contentArn: String? = nil, contentId: String? = nil, knowledgeBaseArn: String? = nil, knowledgeBaseId: String? = nil) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn
            case contentId
            case knowledgeBaseArn
            case knowledgeBaseId
        }
    }

    public struct ContentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the content.
        public let contentArn: String
        /// The identifier of the content.
        public let contentId: String
        /// The media type of the content.
        public let contentType: String
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]
        /// The name of the content.
        public let name: String
        /// The identifier of the revision of the content.
        public let revisionId: String
        /// The status of the content.
        public let status: ContentStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content.
        public let title: String

        public init(contentArn: String, contentId: String, contentType: String, knowledgeBaseArn: String, knowledgeBaseId: String, metadata: [String: String], name: String, revisionId: String, status: ContentStatus, tags: [String: String]? = nil, title: String) {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case contentArn
            case contentId
            case contentType
            case knowledgeBaseArn
            case knowledgeBaseId
            case metadata
            case name
            case revisionId
            case status
            case tags
            case title
        }
    }

    public struct CreateAssistantAssociationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId"))
        ]

        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifier of the associated resource.
        public let association: AssistantAssociationInputData
        /// The type of association.
        public let associationType: AssociationType
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(assistantId: String, association: AssistantAssociationInputData, associationType: AssociationType, clientToken: String? = CreateAssistantAssociationRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assistantId = assistantId
            self.association = association
            self.associationType = associationType
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.association.validate(name: "\(name).association")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case association
            case associationType
            case clientToken
            case tags
        }
    }

    public struct CreateAssistantAssociationResponse: AWSDecodableShape {
        /// The assistant association.
        public let assistantAssociation: AssistantAssociationData?

        public init(assistantAssociation: AssistantAssociationData? = nil) {
            self.assistantAssociation = assistantAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociation
        }
    }

    public struct CreateAssistantRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of the assistant.
        public let description: String?
        /// The name of the assistant.
        public let name: String
        /// The KMS key used for encryption.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The type of assistant.
        public let type: AssistantType

        public init(clientToken: String? = CreateAssistantRequest.idempotencyToken(), description: String? = nil, name: String, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, tags: [String: String]? = nil, type: AssistantType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case name
            case serverSideEncryptionConfiguration
            case tags
            case type
        }
    }

    public struct CreateAssistantResponse: AWSDecodableShape {
        /// Information about the assistant.
        public let assistant: AssistantData?

        public init(assistant: AssistantData? = nil) {
            self.assistant = assistant
        }

        private enum CodingKeys: String, CodingKey {
            case assistant
        }
    }

    public struct CreateContentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]?
        /// The name of the content. Each piece of content in a knowledge base must have a unique name. You can retrieve a piece of content using only its knowledge base and its name with the SearchContent API.
        public let name: String
        /// The URI you want to use for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content.
        public let overrideLinkOutUri: String?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The title of the content. If not set, the title is equal to the name.
        public let title: String?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String

        public init(clientToken: String? = CreateContentRequest.idempotencyToken(), knowledgeBaseId: String, metadata: [String: String]? = nil, name: String, overrideLinkOutUri: String? = nil, tags: [String: String]? = nil, title: String? = nil, uploadId: String) {
            self.clientToken = clientToken
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.overrideLinkOutUri = overrideLinkOutUri
            self.tags = tags
            self.title = title
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, max: 4096)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.title, name: "title", parent: name, max: 255)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 4096)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case metadata
            case name
            case overrideLinkOutUri
            case tags
            case title
            case uploadId
        }
    }

    public struct CreateContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content
        }
    }

    public struct CreateKnowledgeBaseRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The type of knowledge base. Only CUSTOM knowledge bases allow you to upload your own content. EXTERNAL knowledge bases support integrations with third-party systems whose content is synchronized automatically.
        public let knowledgeBaseType: KnowledgeBaseType
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The KMS key used for encryption.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// The source of the knowledge base content. Only set this argument for EXTERNAL knowledge bases.
        public let sourceConfiguration: SourceConfiguration?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateKnowledgeBaseRequest.idempotencyToken(), description: String? = nil, knowledgeBaseType: KnowledgeBaseType, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.renderingConfiguration?.validate(name: "\(name).renderingConfiguration")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
            try self.sourceConfiguration?.validate(name: "\(name).sourceConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case knowledgeBaseType
            case name
            case renderingConfiguration
            case serverSideEncryptionConfiguration
            case sourceConfiguration
            case tags
        }
    }

    public struct CreateKnowledgeBaseResponse: AWSDecodableShape {
        /// The knowledge base.
        public let knowledgeBase: KnowledgeBaseData?

        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase
        }
    }

    public struct CreateSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId"))
        ]

        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The name of the session.
        public let name: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(assistantId: String, clientToken: String? = CreateSessionRequest.idempotencyToken(), description: String? = nil, name: String, tags: [String: String]? = nil) {
            self.assistantId = assistantId
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 4096)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\s_.,-]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case name
            case tags
        }
    }

    public struct CreateSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: SessionData?

        public init(session: SessionData? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct DeleteAssistantAssociationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantAssociationId", location: .uri("assistantAssociationId")),
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId"))
        ]

        /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantAssociationId: String
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        public init(assistantAssociationId: String, assistantId: String) {
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantAssociationId, name: "assistantAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssistantAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssistantRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId"))
        ]

        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        public init(assistantId: String) {
            self.assistantId = assistantId
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssistantResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contentId", location: .uri("contentId")),
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId"))
        ]

        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteKnowledgeBaseRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId"))
        ]

        /// The knowledge base to delete content from. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteKnowledgeBaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Document: AWSDecodableShape {
        /// A reference to the content resource.
        public let contentReference: ContentReference
        /// The excerpt from the document.
        public let excerpt: DocumentText?
        /// The title of the document.
        public let title: DocumentText?

        public init(contentReference: ContentReference, excerpt: DocumentText? = nil, title: DocumentText? = nil) {
            self.contentReference = contentReference
            self.excerpt = excerpt
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case contentReference
            case excerpt
            case title
        }
    }

    public struct DocumentText: AWSDecodableShape {
        /// Highlights in the document text.
        public let highlights: [Highlight]?
        /// Text in the document.
        public let text: String?

        public init(highlights: [Highlight]? = nil, text: String? = nil) {
            self.highlights = highlights
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case highlights
            case text
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The field on which to filter.
        public let field: FilterField
        /// The operator to use for comparing the fieldâ€™s value with the provided value.
        public let `operator`: FilterOperator
        /// The desired field value on which to filter.
        public let value: String

        public init(field: FilterField, operator: FilterOperator, value: String) {
            self.field = field
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 4096)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case field
            case `operator`
            case value
        }
    }

    public struct GetAssistantAssociationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantAssociationId", location: .uri("assistantAssociationId")),
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId"))
        ]

        /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantAssociationId: String
        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        public init(assistantAssociationId: String, assistantId: String) {
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantAssociationId, name: "assistantAssociationId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssistantAssociationResponse: AWSDecodableShape {
        /// The assistant association.
        public let assistantAssociation: AssistantAssociationData?

        public init(assistantAssociation: AssistantAssociationData? = nil) {
            self.assistantAssociation = assistantAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociation
        }
    }

    public struct GetAssistantRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId"))
        ]

        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String

        public init(assistantId: String) {
            self.assistantId = assistantId
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssistantResponse: AWSDecodableShape {
        /// Information about the assistant.
        public let assistant: AssistantData?

        public init(assistant: AssistantData? = nil) {
            self.assistant = assistant
        }

        private enum CodingKeys: String, CodingKey {
            case assistant
        }
    }

    public struct GetContentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contentId", location: .uri("contentId")),
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId"))
        ]

        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content
        }
    }

    public struct GetContentSummaryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contentId", location: .uri("contentId")),
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId"))
        ]

        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(contentId: String, knowledgeBaseId: String) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContentSummaryResponse: AWSDecodableShape {
        /// The content summary.
        public let contentSummary: ContentSummary?

        public init(contentSummary: ContentSummary? = nil) {
            self.contentSummary = contentSummary
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummary
        }
    }

    public struct GetKnowledgeBaseRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId"))
        ]

        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetKnowledgeBaseResponse: AWSDecodableShape {
        /// The knowledge base.
        public let knowledgeBase: KnowledgeBaseData?

        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase
        }
    }

    public struct GetRecommendationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "waitTimeSeconds", location: .querystring("waitTimeSeconds"))
        ]

        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String
        /// The duration (in seconds) for which the call waits for a recommendation to be made available before returning. If a recommendation is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call returns successfully with an empty list.
        public let waitTimeSeconds: Int?

        public init(assistantId: String, maxResults: Int? = nil, sessionId: String, waitTimeSeconds: Int? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.sessionId = sessionId
            self.waitTimeSeconds = waitTimeSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.waitTimeSeconds, name: "waitTimeSeconds", parent: name, max: 20)
            try self.validate(self.waitTimeSeconds, name: "waitTimeSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecommendationsResponse: AWSDecodableShape {
        /// The recommendations.
        public let recommendations: [RecommendationData]
        /// The triggers corresponding to recommendations.
        public let triggers: [RecommendationTrigger]?

        public init(recommendations: [RecommendationData], triggers: [RecommendationTrigger]? = nil) {
            self.recommendations = recommendations
            self.triggers = triggers
        }

        private enum CodingKeys: String, CodingKey {
            case recommendations
            case triggers
        }
    }

    public struct GetSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId"))
        ]

        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String

        public init(assistantId: String, sessionId: String) {
            self.assistantId = assistantId
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: SessionData?

        public init(session: SessionData? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct Highlight: AWSDecodableShape {
        /// The offset for the start of the highlight.
        public let beginOffsetInclusive: Int?
        /// The offset for the end of the highlight.
        public let endOffsetExclusive: Int?

        public init(beginOffsetInclusive: Int? = nil, endOffsetExclusive: Int? = nil) {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffsetInclusive
            case endOffsetExclusive
        }
    }

    public struct KnowledgeBaseAssociationData: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String?
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String?

        public init(knowledgeBaseArn: String? = nil, knowledgeBaseId: String? = nil) {
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseArn
            case knowledgeBaseId
        }
    }

    public struct KnowledgeBaseData: AWSDecodableShape {
        /// The description.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The type of knowledge base.
        public let knowledgeBaseType: KnowledgeBaseType
        /// An epoch timestamp indicating the most recent content modification inside the knowledge base. If no content exists in a knowledge base, this value is unset.
        public let lastContentModificationTime: Date?
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The KMS key used for encryption.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Source configuration information about the knowledge base.
        public let sourceConfiguration: SourceConfiguration?
        /// The status of the knowledge base.
        public let status: KnowledgeBaseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(description: String? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, knowledgeBaseType: KnowledgeBaseType, lastContentModificationTime: Date? = nil, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, status: KnowledgeBaseStatus, tags: [String: String]? = nil) {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.lastContentModificationTime = lastContentModificationTime
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case knowledgeBaseArn
            case knowledgeBaseId
            case knowledgeBaseType
            case lastContentModificationTime
            case name
            case renderingConfiguration
            case serverSideEncryptionConfiguration
            case sourceConfiguration
            case status
            case tags
        }
    }

    public struct KnowledgeBaseSummary: AWSDecodableShape {
        /// The description of the knowledge base.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public let knowledgeBaseArn: String
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The type of knowledge base.
        public let knowledgeBaseType: KnowledgeBaseType
        /// The name of the knowledge base.
        public let name: String
        /// Information about how to render the content.
        public let renderingConfiguration: RenderingConfiguration?
        /// The KMS key used for encryption.
        public let serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration?
        /// Configuration information about the external data source.
        public let sourceConfiguration: SourceConfiguration?
        /// The status of the knowledge base summary.
        public let status: KnowledgeBaseStatus
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(description: String? = nil, knowledgeBaseArn: String, knowledgeBaseId: String, knowledgeBaseType: KnowledgeBaseType, name: String, renderingConfiguration: RenderingConfiguration? = nil, serverSideEncryptionConfiguration: ServerSideEncryptionConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil, status: KnowledgeBaseStatus, tags: [String: String]? = nil) {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case knowledgeBaseArn
            case knowledgeBaseId
            case knowledgeBaseType
            case name
            case renderingConfiguration
            case serverSideEncryptionConfiguration
            case sourceConfiguration
            case status
            case tags
        }
    }

    public struct ListAssistantAssociationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssistantAssociationsResponse: AWSDecodableShape {
        /// Summary information about assistant associations.
        public let assistantAssociationSummaries: [AssistantAssociationSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(assistantAssociationSummaries: [AssistantAssociationSummary], nextToken: String? = nil) {
            self.assistantAssociationSummaries = assistantAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assistantAssociationSummaries
            case nextToken
        }
    }

    public struct ListAssistantsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssistantsResponse: AWSDecodableShape {
        /// Information about the assistants.
        public let assistantSummaries: [AssistantSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(assistantSummaries: [AssistantSummary], nextToken: String? = nil) {
            self.assistantSummaries = assistantSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assistantSummaries
            case nextToken
        }
    }

    public struct ListContentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContentsResponse: AWSDecodableShape {
        /// Information about the content.
        public let contentSummaries: [ContentSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(contentSummaries: [ContentSummary], nextToken: String? = nil) {
            self.contentSummaries = contentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummaries
            case nextToken
        }
    }

    public struct ListKnowledgeBasesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKnowledgeBasesResponse: AWSDecodableShape {
        /// Information about the knowledge bases.
        public let knowledgeBaseSummaries: [KnowledgeBaseSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(knowledgeBaseSummaries: [KnowledgeBaseSummary], nextToken: String? = nil) {
            self.knowledgeBaseSummaries = knowledgeBaseSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseSummaries
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct NotifyRecommendationsReceivedError: AWSDecodableShape {
        /// A recommendation is causing an error.
        public let message: String?
        /// The identifier of the recommendation that is in error.
        public let recommendationId: String?

        public init(message: String? = nil, recommendationId: String? = nil) {
            self.message = message
            self.recommendationId = recommendationId
        }

        private enum CodingKeys: String, CodingKey {
            case message
            case recommendationId
        }
    }

    public struct NotifyRecommendationsReceivedRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId"))
        ]

        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]
        /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let sessionId: String

        public init(assistantId: String, recommendationIds: [String], sessionId: String) {
            self.assistantId = assistantId
            self.recommendationIds = recommendationIds
            self.sessionId = sessionId
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case recommendationIds
        }
    }

    public struct NotifyRecommendationsReceivedResponse: AWSDecodableShape {
        /// The identifiers of recommendations that are causing errors.
        public let errors: [NotifyRecommendationsReceivedError]?
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]?

        public init(errors: [NotifyRecommendationsReceivedError]? = nil, recommendationIds: [String]? = nil) {
            self.errors = errors
            self.recommendationIds = recommendationIds
        }

        private enum CodingKeys: String, CodingKey {
            case errors
            case recommendationIds
        }
    }

    public struct QueryAssistantRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId"))
        ]

        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The text to search for.
        public let queryText: String

        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, queryText: String) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryText = queryText
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case queryText
        }
    }

    public struct QueryAssistantResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The results of the query.
        public let results: [ResultData]

        public init(nextToken: String? = nil, results: [ResultData]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case results
        }
    }

    public struct QueryRecommendationTriggerData: AWSDecodableShape {
        /// The text associated with the recommendation trigger.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text
        }
    }

    public struct RecommendationData: AWSDecodableShape {
        /// The recommended document.
        public let document: Document
        /// The identifier of the recommendation.
        public let recommendationId: String
        /// The relevance level of the recommendation.
        public let relevanceLevel: RelevanceLevel?
        /// The relevance score of the recommendation.
        public let relevanceScore: Double?
        /// The type of recommendation.
        public let type: RecommendationType?

        public init(document: Document, recommendationId: String, relevanceLevel: RelevanceLevel? = nil, relevanceScore: Double? = nil, type: RecommendationType? = nil) {
            self.document = document
            self.recommendationId = recommendationId
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case document
            case recommendationId
            case relevanceLevel
            case relevanceScore
            case type
        }
    }

    public struct RecommendationTrigger: AWSDecodableShape {
        /// A union type containing information related to the trigger.
        public let data: RecommendationTriggerData
        /// The identifier of the recommendation trigger.
        public let id: String
        /// The identifiers of the recommendations.
        public let recommendationIds: [String]
        /// The source of the recommendation trigger.   ISSUE_DETECTION: The corresponding recommendations were triggered by a Contact Lens issue.   RULE_EVALUATION: The corresponding recommendations were triggered by a Contact Lens rule.
        public let source: RecommendationSourceType
        /// The type of recommendation trigger.
        public let type: RecommendationTriggerType

        public init(data: RecommendationTriggerData, id: String, recommendationIds: [String], source: RecommendationSourceType, type: RecommendationTriggerType) {
            self.data = data
            self.id = id
            self.recommendationIds = recommendationIds
            self.source = source
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case data
            case id
            case recommendationIds
            case source
            case type
        }
    }

    public struct RemoveKnowledgeBaseTemplateUriRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId"))
        ]

        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(knowledgeBaseId: String) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveKnowledgeBaseTemplateUriResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RenderingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A URI template containing exactly one variable in ${variableName} format. This can only be set for EXTERNAL knowledge bases. For Salesforce and ServiceNow, the variable must be one of the following:   Salesforce: Id, ArticleNumber, VersionNumber, Title, PublishStatus, or IsDeleted    ServiceNow: number, short_description, sys_mod_count, workflow_state, or active
        ///  The variable is replaced with the actual value for a piece of content when calling GetContent.
        public let templateUri: String?

        public init(templateUri: String? = nil) {
            self.templateUri = templateUri
        }

        public func validate(name: String) throws {
            try self.validate(self.templateUri, name: "templateUri", parent: name, max: 4096)
            try self.validate(self.templateUri, name: "templateUri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateUri
        }
    }

    public struct ResultData: AWSDecodableShape {
        /// The document.
        public let document: Document
        /// The relevance score of the results.
        public let relevanceScore: Double?
        /// The identifier of the result data.
        public let resultId: String

        public init(document: Document, relevanceScore: Double? = nil, resultId: String) {
            self.document = document
            self.relevanceScore = relevanceScore
            self.resultId = resultId
        }

        private enum CodingKeys: String, CodingKey {
            case document
            case relevanceScore
            case resultId
        }
    }

    public struct SearchContentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression to filter results.
        public let searchExpression: SearchExpression

        public init(knowledgeBaseId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: SearchExpression) {
            self.knowledgeBaseId = knowledgeBaseId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case searchExpression
        }
    }

    public struct SearchContentResponse: AWSDecodableShape {
        /// Summary information about the content.
        public let contentSummaries: [ContentSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(contentSummaries: [ContentSummary], nextToken: String? = nil) {
            self.contentSummaries = contentSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummaries
            case nextToken
        }
    }

    public struct SearchExpression: AWSEncodableShape {
        /// The search expression filters.
        public let filters: [Filter]

        public init(filters: [Filter]) {
            self.filters = filters
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters
        }
    }

    public struct SearchSessionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assistantId", location: .uri("assistantId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let assistantId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search expression to filter results.
        public let searchExpression: SearchExpression

        public init(assistantId: String, maxResults: Int? = nil, nextToken: String? = nil, searchExpression: SearchExpression) {
            self.assistantId = assistantId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchExpression = searchExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.assistantId, name: "assistantId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchExpression.validate(name: "\(name).searchExpression")
        }

        private enum CodingKeys: String, CodingKey {
            case searchExpression
        }
    }

    public struct SearchSessionsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Summary information about the sessions.
        public let sessionSummaries: [SessionSummary]

        public init(nextToken: String? = nil, sessionSummaries: [SessionSummary]) {
            self.nextToken = nextToken
            self.sessionSummaries = sessionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case sessionSummaries
        }
    }

    public struct ServerSideEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The KMS key. For information about valid ID values, see Key identifiers (KeyId).
        public let kmsKeyId: String?

        public init(kmsKeyId: String? = nil) {
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 4096)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId
        }
    }

    public struct SessionData: AWSDecodableShape {
        /// The description of the session.
        public let description: String?
        /// The name of the session.
        public let name: String
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The identifier of the session.
        public let sessionId: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String, sessionArn: String, sessionId: String, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case sessionArn
            case sessionId
            case tags
        }
    }

    public struct SessionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant.
        public let assistantArn: String
        /// The identifier of the Wisdom assistant.
        public let assistantId: String
        /// The Amazon Resource Name (ARN) of the session.
        public let sessionArn: String
        /// The identifier of the session.
        public let sessionId: String

        public init(assistantArn: String, assistantId: String, sessionArn: String, sessionId: String) {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case assistantArn
            case assistantId
            case sessionArn
            case sessionId
        }
    }

    public struct StartContentUploadRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId"))
        ]

        /// The type of content to upload.
        public let contentType: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String

        public init(contentType: String, knowledgeBaseId: String) {
            self.contentType = contentType
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^(text/(plain|html))|(application/x\\.wisdom-json;source=(salesforce|servicenow|zendesk))$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case contentType
        }
    }

    public struct StartContentUploadResponse: AWSDecodableShape {
        /// The headers to include in the upload.
        public let headersToInclude: [String: String]
        /// The identifier of the upload.
        public let uploadId: String
        /// The URL of the upload.
        public let url: String
        /// The expiration time of the URL as an epoch timestamp.
        public let urlExpiry: Date

        public init(headersToInclude: [String: String], uploadId: String, url: String, urlExpiry: Date) {
            self.headersToInclude = headersToInclude
            self.uploadId = uploadId
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case headersToInclude
            case uploadId
            case url
            case urlExpiry
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contentId", location: .uri("contentId")),
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId"))
        ]

        /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let contentId: String
        /// The identifier of the knowledge base. Can be either the ID or the ARN
        public let knowledgeBaseId: String
        /// A key/value map to store attributes without affecting tagging or recommendations. For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        public let metadata: [String: String]?
        /// The URI for the article. If the knowledge base has a templateUri, setting this argument overrides it for this piece of content. To remove an existing overrideLinkOurUri, exclude this argument and set removeOverrideLinkOutUri to true.
        public let overrideLinkOutUri: String?
        /// Unset the existing overrideLinkOutUri if it exists.
        public let removeOverrideLinkOutUri: Bool?
        /// The revisionId of the content resource to update, taken from an earlier call to GetContent, GetContentSummary, SearchContent, or ListContents. If included, this argument acts as an optimistic lock to ensure content was not modified since it was last read. If it has been modified, this API throws a PreconditionFailedException.
        public let revisionId: String?
        /// The title of the content.
        public let title: String?
        /// A pointer to the uploaded asset. This value is returned by StartContentUpload.
        public let uploadId: String?

        public init(contentId: String, knowledgeBaseId: String, metadata: [String: String]? = nil, overrideLinkOutUri: String? = nil, removeOverrideLinkOutUri: Bool? = nil, revisionId: String? = nil, title: String? = nil, uploadId: String? = nil) {
            self.contentId = contentId
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.overrideLinkOutUri = overrideLinkOutUri
            self.removeOverrideLinkOutUri = removeOverrideLinkOutUri
            self.revisionId = revisionId
            self.title = title
            self.uploadId = uploadId
        }

        public func validate(name: String) throws {
            try self.validate(self.contentId, name: "contentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 4096)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, max: 4096)
            try self.validate(self.overrideLinkOutUri, name: "overrideLinkOutUri", parent: name, min: 1)
            try self.validate(self.revisionId, name: "revisionId", parent: name, max: 4096)
            try self.validate(self.revisionId, name: "revisionId", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 255)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.uploadId, name: "uploadId", parent: name, max: 4096)
            try self.validate(self.uploadId, name: "uploadId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadata
            case overrideLinkOutUri
            case removeOverrideLinkOutUri
            case revisionId
            case title
            case uploadId
        }
    }

    public struct UpdateContentResponse: AWSDecodableShape {
        /// The content.
        public let content: ContentData?

        public init(content: ContentData? = nil) {
            self.content = content
        }

        private enum CodingKeys: String, CodingKey {
            case content
        }
    }

    public struct UpdateKnowledgeBaseTemplateUriRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "knowledgeBaseId", location: .uri("knowledgeBaseId"))
        ]

        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The template URI to update.
        public let templateUri: String

        public init(knowledgeBaseId: String, templateUri: String) {
            self.knowledgeBaseId = knowledgeBaseId
            self.templateUri = templateUri
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$|^arn:[a-z-]*?:wisdom:[a-z0-9-]*?:[0-9]{12}:[a-z-]*?/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})?$")
            try self.validate(self.templateUri, name: "templateUri", parent: name, max: 4096)
            try self.validate(self.templateUri, name: "templateUri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case templateUri
        }
    }

    public struct UpdateKnowledgeBaseTemplateUriResponse: AWSDecodableShape {
        /// The knowledge base to update.
        public let knowledgeBase: KnowledgeBaseData?

        public init(knowledgeBase: KnowledgeBaseData? = nil) {
            self.knowledgeBase = knowledgeBase
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBase
        }
    }

    public struct AssistantAssociationInputData: AWSEncodableShape {
        /// The identifier of the knowledge base.
        public let knowledgeBaseId: String?

        public init(knowledgeBaseId: String? = nil) {
            self.knowledgeBaseId = knowledgeBaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId
        }
    }

    public struct AssistantAssociationOutputData: AWSDecodableShape {
        /// The knowledge base where output data is sent.
        public let knowledgeBaseAssociation: KnowledgeBaseAssociationData?

        public init(knowledgeBaseAssociation: KnowledgeBaseAssociationData? = nil) {
            self.knowledgeBaseAssociation = knowledgeBaseAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseAssociation
        }
    }

    public struct RecommendationTriggerData: AWSDecodableShape {
        /// Data associated with the QUERY RecommendationTriggerType.
        public let query: QueryRecommendationTriggerData?

        public init(query: QueryRecommendationTriggerData? = nil) {
            self.query = query
        }

        private enum CodingKeys: String, CodingKey {
            case query
        }
    }

    public struct SourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration information for Amazon AppIntegrations to automatically ingest content.
        public let appIntegrations: AppIntegrationsConfiguration?

        public init(appIntegrations: AppIntegrationsConfiguration? = nil) {
            self.appIntegrations = appIntegrations
        }

        public func validate(name: String) throws {
            try self.appIntegrations?.validate(name: "\(name).appIntegrations")
        }

        private enum CodingKeys: String, CodingKey {
            case appIntegrations
        }
    }
}

// MARK: - Errors

/// Error enum for Wisdom
public struct WisdomErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case preconditionFailedException = "PreconditionFailedException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Wisdom
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be processed because of conflict in the current state of the resource. For example, if you&#39;re using a Create API (such as CreateAssistant) that accepts name, a conflicting resource (usually with the same name) is being created or mutated.
    public static var conflictException: Self { .init(.conflictException) }
    /// The provided revisionId does not match, indicating the content has been modified since it was last read.
    public static var preconditionFailedException: Self { .init(.preconditionFailedException) }
    /// The specified resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You&#39;ve exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use service quotas to request a service quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Amazon Connect Wisdom throws this exception if you have too many tags in your tag set.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The input fails to satisfy the constraints specified by a service.
    public static var validationException: Self { .init(.validationException) }
}

extension WisdomErrorType: Equatable {
    public static func == (lhs: WisdomErrorType, rhs: WisdomErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension WisdomErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
