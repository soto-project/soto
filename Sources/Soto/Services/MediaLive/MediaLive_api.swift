//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS MediaLive service.
///
/// API for AWS Elemental MediaLive
public struct MediaLive: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the MediaLive client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "MediaLive",
            serviceIdentifier: "medialive",
            serviceProtocol: .restjson,
            apiVersion: "2017-10-14",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: MediaLiveErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-east-1": "medialive-fips.us-east-1.amazonaws.com",
            "us-east-2": "medialive-fips.us-east-2.amazonaws.com",
            "us-iso-east-1": "medialive-fips.us-iso-east-1.c2s.ic.gov",
            "us-isob-east-1": "medialive-fips.us-isob-east-1.sc2s.sgov.gov",
            "us-west-2": "medialive-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Accept an incoming input device transfer. The ownership of the device will transfer to your AWS account.
    @Sendable
    @inlinable
    public func acceptInputDeviceTransfer(_ input: AcceptInputDeviceTransferRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AcceptInputDeviceTransferResponse {
        try await self.client.execute(
            operation: "AcceptInputDeviceTransfer", 
            path: "/prod/inputDevices/{InputDeviceId}/accept", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Accept an incoming input device transfer. The ownership of the device will transfer to your AWS account.
    ///
    /// Parameters:
    ///   - inputDeviceId: The unique ID of the input device to accept. For example, hd-123456789abcdef.
    ///   - logger: Logger use during operation
    @inlinable
    public func acceptInputDeviceTransfer(
        inputDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AcceptInputDeviceTransferResponse {
        let input = AcceptInputDeviceTransferRequest(
            inputDeviceId: inputDeviceId
        )
        return try await self.acceptInputDeviceTransfer(input, logger: logger)
    }

    /// Starts delete of resources.
    @Sendable
    @inlinable
    public func batchDelete(_ input: BatchDeleteRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteResponse {
        try await self.client.execute(
            operation: "BatchDelete", 
            path: "/prod/batch/delete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts delete of resources.
    ///
    /// Parameters:
    ///   - channelIds: List of channel IDs
    ///   - inputIds: List of input IDs
    ///   - inputSecurityGroupIds: List of input security group IDs
    ///   - multiplexIds: List of multiplex IDs
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDelete(
        channelIds: [String]? = nil,
        inputIds: [String]? = nil,
        inputSecurityGroupIds: [String]? = nil,
        multiplexIds: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteResponse {
        let input = BatchDeleteRequest(
            channelIds: channelIds, 
            inputIds: inputIds, 
            inputSecurityGroupIds: inputSecurityGroupIds, 
            multiplexIds: multiplexIds
        )
        return try await self.batchDelete(input, logger: logger)
    }

    /// Starts existing resources
    @Sendable
    @inlinable
    public func batchStart(_ input: BatchStartRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchStartResponse {
        try await self.client.execute(
            operation: "BatchStart", 
            path: "/prod/batch/start", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts existing resources
    ///
    /// Parameters:
    ///   - channelIds: List of channel IDs
    ///   - multiplexIds: List of multiplex IDs
    ///   - logger: Logger use during operation
    @inlinable
    public func batchStart(
        channelIds: [String]? = nil,
        multiplexIds: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchStartResponse {
        let input = BatchStartRequest(
            channelIds: channelIds, 
            multiplexIds: multiplexIds
        )
        return try await self.batchStart(input, logger: logger)
    }

    /// Stops running resources
    @Sendable
    @inlinable
    public func batchStop(_ input: BatchStopRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchStopResponse {
        try await self.client.execute(
            operation: "BatchStop", 
            path: "/prod/batch/stop", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops running resources
    ///
    /// Parameters:
    ///   - channelIds: List of channel IDs
    ///   - multiplexIds: List of multiplex IDs
    ///   - logger: Logger use during operation
    @inlinable
    public func batchStop(
        channelIds: [String]? = nil,
        multiplexIds: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchStopResponse {
        let input = BatchStopRequest(
            channelIds: channelIds, 
            multiplexIds: multiplexIds
        )
        return try await self.batchStop(input, logger: logger)
    }

    /// Update a channel schedule
    @Sendable
    @inlinable
    public func batchUpdateSchedule(_ input: BatchUpdateScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateScheduleResponse {
        try await self.client.execute(
            operation: "BatchUpdateSchedule", 
            path: "/prod/channels/{ChannelId}/schedule", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a channel schedule
    ///
    /// Parameters:
    ///   - channelId: Id of the channel whose schedule is being updated.
    ///   - creates: Schedule actions to create in the schedule.
    ///   - deletes: Schedule actions to delete from the schedule.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdateSchedule(
        channelId: String,
        creates: BatchScheduleActionCreateRequest? = nil,
        deletes: BatchScheduleActionDeleteRequest? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdateScheduleResponse {
        let input = BatchUpdateScheduleRequest(
            channelId: channelId, 
            creates: creates, 
            deletes: deletes
        )
        return try await self.batchUpdateSchedule(input, logger: logger)
    }

    /// Cancel an input device transfer that you have requested.
    @Sendable
    @inlinable
    public func cancelInputDeviceTransfer(_ input: CancelInputDeviceTransferRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelInputDeviceTransferResponse {
        try await self.client.execute(
            operation: "CancelInputDeviceTransfer", 
            path: "/prod/inputDevices/{InputDeviceId}/cancel", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancel an input device transfer that you have requested.
    ///
    /// Parameters:
    ///   - inputDeviceId: The unique ID of the input device to cancel. For example, hd-123456789abcdef.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelInputDeviceTransfer(
        inputDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelInputDeviceTransferResponse {
        let input = CancelInputDeviceTransferRequest(
            inputDeviceId: inputDeviceId
        )
        return try await self.cancelInputDeviceTransfer(input, logger: logger)
    }

    /// Send a request to claim an AWS Elemental device that you have purchased from a third-party vendor. After the request succeeds, you will own the device.
    @Sendable
    @inlinable
    public func claimDevice(_ input: ClaimDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ClaimDeviceResponse {
        try await self.client.execute(
            operation: "ClaimDevice", 
            path: "/prod/claimDevice", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Send a request to claim an AWS Elemental device that you have purchased from a third-party vendor. After the request succeeds, you will own the device.
    ///
    /// Parameters:
    ///   - id: The id of the device you want to claim.
    ///   - logger: Logger use during operation
    @inlinable
    public func claimDevice(
        id: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ClaimDeviceResponse {
        let input = ClaimDeviceRequest(
            id: id
        )
        return try await self.claimDevice(input, logger: logger)
    }

    /// Creates a new channel
    @Sendable
    @inlinable
    public func createChannel(_ input: CreateChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateChannelResponse {
        try await self.client.execute(
            operation: "CreateChannel", 
            path: "/prod/channels", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new channel
    ///
    /// Parameters:
    ///   - anywhereSettings: The Elemental Anywhere settings for this channel.
    ///   - cdiInputSpecification: Specification of CDI inputs for this channel
    ///   - channelClass: The class for this channel. STANDARD for a channel with two pipelines or SINGLE_PIPELINE for a channel with one pipeline.
    ///   - channelEngineVersion: The desired engine version for this channel.
    ///   - destinations: 
    ///   - dryRun: 
    ///   - encoderSettings: 
    ///   - inputAttachments: List of input attachments for channel.
    ///   - inputSpecification: Specification of network and file inputs for this channel
    ///   - logLevel: The log level to write to CloudWatch Logs.
    ///   - maintenance: Maintenance settings for this channel.
    ///   - name: Name of channel.
    ///   - requestId: Unique request ID to be specified. This is needed to prevent retries from
    ///   - roleArn: An optional Amazon Resource Name (ARN) of the role to assume when running the Channel.
    ///   - tags: A collection of key-value pairs.
    ///   - vpc: Settings for the VPC outputs
    ///   - logger: Logger use during operation
    @inlinable
    public func createChannel(
        anywhereSettings: AnywhereSettings? = nil,
        cdiInputSpecification: CdiInputSpecification? = nil,
        channelClass: ChannelClass? = nil,
        channelEngineVersion: ChannelEngineVersionRequest? = nil,
        destinations: [OutputDestination]? = nil,
        dryRun: Bool? = nil,
        encoderSettings: EncoderSettings? = nil,
        inputAttachments: [InputAttachment]? = nil,
        inputSpecification: InputSpecification? = nil,
        logLevel: LogLevel? = nil,
        maintenance: MaintenanceCreateSettings? = nil,
        name: String? = nil,
        requestId: String? = CreateChannelRequest.idempotencyToken(),
        roleArn: String? = nil,
        tags: [String: String]? = nil,
        vpc: VpcOutputSettings? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateChannelResponse {
        let input = CreateChannelRequest(
            anywhereSettings: anywhereSettings, 
            cdiInputSpecification: cdiInputSpecification, 
            channelClass: channelClass, 
            channelEngineVersion: channelEngineVersion, 
            destinations: destinations, 
            dryRun: dryRun, 
            encoderSettings: encoderSettings, 
            inputAttachments: inputAttachments, 
            inputSpecification: inputSpecification, 
            logLevel: logLevel, 
            maintenance: maintenance, 
            name: name, 
            requestId: requestId, 
            roleArn: roleArn, 
            tags: tags, 
            vpc: vpc
        )
        return try await self.createChannel(input, logger: logger)
    }

    /// Create a ChannelPlacementGroup in the specified Cluster. As part of the create operation, you specify the Nodes to attach the group to.After you create a ChannelPlacementGroup, you add Channels to the group (you do this by modifying the Channels to add them to a specific group). You now have an association of Channels to ChannelPlacementGroup, and ChannelPlacementGroup to Nodes. This association means that all the Channels in the group are able to run on any of the Nodes associated with the group.
    @Sendable
    @inlinable
    public func createChannelPlacementGroup(_ input: CreateChannelPlacementGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateChannelPlacementGroupResponse {
        try await self.client.execute(
            operation: "CreateChannelPlacementGroup", 
            path: "/prod/clusters/{ClusterId}/channelplacementgroups", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a ChannelPlacementGroup in the specified Cluster. As part of the create operation, you specify the Nodes to attach the group to.After you create a ChannelPlacementGroup, you add Channels to the group (you do this by modifying the Channels to add them to a specific group). You now have an association of Channels to ChannelPlacementGroup, and ChannelPlacementGroup to Nodes. This association means that all the Channels in the group are able to run on any of the Nodes associated with the group.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster.
    ///   - name: Specify a name that is unique in the Cluster. You can't change the name. Names are case-sensitive.
    ///   - nodes: An array of one ID for the Node that you want to associate with the ChannelPlacementGroup. (You can't associate more than one Node with the ChannelPlacementGroup.) The Node and the ChannelPlacementGroup must be in the same Cluster.
    ///   - requestId: An ID that you assign to a create request. This ID ensures idempotency when creating resources. the request.
    ///   - tags: A collection of key-value pairs.
    ///   - logger: Logger use during operation
    @inlinable
    public func createChannelPlacementGroup(
        clusterId: String,
        name: String? = nil,
        nodes: [String]? = nil,
        requestId: String? = CreateChannelPlacementGroupRequest.idempotencyToken(),
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateChannelPlacementGroupResponse {
        let input = CreateChannelPlacementGroupRequest(
            clusterId: clusterId, 
            name: name, 
            nodes: nodes, 
            requestId: requestId, 
            tags: tags
        )
        return try await self.createChannelPlacementGroup(input, logger: logger)
    }

    /// Creates a cloudwatch alarm template to dynamically generate cloudwatch metric alarms on targeted resource types.
    @Sendable
    @inlinable
    public func createCloudWatchAlarmTemplate(_ input: CreateCloudWatchAlarmTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCloudWatchAlarmTemplateResponse {
        try await self.client.execute(
            operation: "CreateCloudWatchAlarmTemplate", 
            path: "/prod/cloudwatch-alarm-templates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a cloudwatch alarm template to dynamically generate cloudwatch metric alarms on targeted resource types.
    ///
    /// Parameters:
    ///   - comparisonOperator: 
    ///   - datapointsToAlarm: The number of datapoints within the evaluation period that must be breaching to trigger the alarm.
    ///   - description: A resource's optional description.
    ///   - evaluationPeriods: The number of periods over which data is compared to the specified threshold.
    ///   - groupIdentifier: A cloudwatch alarm template group's identifier. Can be either be its id or current name.
    ///   - metricName: The name of the metric associated with the alarm. Must be compatible with targetResourceType.
    ///   - name: A resource's name. Names must be unique within the scope of a resource type in a specific region.
    ///   - period: The period, in seconds, over which the specified statistic is applied.
    ///   - requestId: An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    ///   - statistic: 
    ///   - tags: 
    ///   - targetResourceType: 
    ///   - threshold: The threshold value to compare with the specified statistic.
    ///   - treatMissingData: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createCloudWatchAlarmTemplate(
        comparisonOperator: CloudWatchAlarmTemplateComparisonOperator? = nil,
        datapointsToAlarm: Int? = nil,
        description: String? = nil,
        evaluationPeriods: Int? = nil,
        groupIdentifier: String? = nil,
        metricName: String? = nil,
        name: String? = nil,
        period: Int? = nil,
        requestId: String? = CreateCloudWatchAlarmTemplateRequest.idempotencyToken(),
        statistic: CloudWatchAlarmTemplateStatistic? = nil,
        tags: [String: String]? = nil,
        targetResourceType: CloudWatchAlarmTemplateTargetResourceType? = nil,
        threshold: Double? = nil,
        treatMissingData: CloudWatchAlarmTemplateTreatMissingData? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCloudWatchAlarmTemplateResponse {
        let input = CreateCloudWatchAlarmTemplateRequest(
            comparisonOperator: comparisonOperator, 
            datapointsToAlarm: datapointsToAlarm, 
            description: description, 
            evaluationPeriods: evaluationPeriods, 
            groupIdentifier: groupIdentifier, 
            metricName: metricName, 
            name: name, 
            period: period, 
            requestId: requestId, 
            statistic: statistic, 
            tags: tags, 
            targetResourceType: targetResourceType, 
            threshold: threshold, 
            treatMissingData: treatMissingData
        )
        return try await self.createCloudWatchAlarmTemplate(input, logger: logger)
    }

    /// Creates a cloudwatch alarm template group to group your cloudwatch alarm templates and to attach to signal maps for dynamically creating alarms.
    @Sendable
    @inlinable
    public func createCloudWatchAlarmTemplateGroup(_ input: CreateCloudWatchAlarmTemplateGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCloudWatchAlarmTemplateGroupResponse {
        try await self.client.execute(
            operation: "CreateCloudWatchAlarmTemplateGroup", 
            path: "/prod/cloudwatch-alarm-template-groups", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a cloudwatch alarm template group to group your cloudwatch alarm templates and to attach to signal maps for dynamically creating alarms.
    ///
    /// Parameters:
    ///   - description: A resource's optional description.
    ///   - name: A resource's name. Names must be unique within the scope of a resource type in a specific region.
    ///   - requestId: An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    ///   - tags: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createCloudWatchAlarmTemplateGroup(
        description: String? = nil,
        name: String? = nil,
        requestId: String? = CreateCloudWatchAlarmTemplateGroupRequest.idempotencyToken(),
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCloudWatchAlarmTemplateGroupResponse {
        let input = CreateCloudWatchAlarmTemplateGroupRequest(
            description: description, 
            name: name, 
            requestId: requestId, 
            tags: tags
        )
        return try await self.createCloudWatchAlarmTemplateGroup(input, logger: logger)
    }

    /// Create a new Cluster.
    @Sendable
    @inlinable
    public func createCluster(_ input: CreateClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateClusterResponse {
        try await self.client.execute(
            operation: "CreateCluster", 
            path: "/prod/clusters", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new Cluster.
    ///
    /// Parameters:
    ///   - clusterType: Specify a type. All the Nodes that you later add to this Cluster must be this type of hardware. One Cluster instance can't contain different hardware types. You won't be able to change this parameter after you create the Cluster.
    ///   - instanceRoleArn: The ARN of the IAM role for the Node in this Cluster. The role must include all the operations that you expect these Node to perform. If necessary, create a role in IAM, then attach it here.
    ///   - name: Specify a name that is unique in the AWS account. We recommend that you assign a name that hints at the types of Nodes in the Cluster. Names are case-sensitive.
    ///   - networkSettings: Network settings that connect the Nodes in the Cluster to one or more of the Networks that the Cluster is associated with.
    ///   - requestId: The unique ID of the request.
    ///   - tags: A collection of key-value pairs.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCluster(
        clusterType: ClusterType? = nil,
        instanceRoleArn: String? = nil,
        name: String? = nil,
        networkSettings: ClusterNetworkSettingsCreateRequest? = nil,
        requestId: String? = CreateClusterRequest.idempotencyToken(),
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateClusterResponse {
        let input = CreateClusterRequest(
            clusterType: clusterType, 
            instanceRoleArn: instanceRoleArn, 
            name: name, 
            networkSettings: networkSettings, 
            requestId: requestId, 
            tags: tags
        )
        return try await self.createCluster(input, logger: logger)
    }

    /// Creates an eventbridge rule template to monitor events and send notifications to your targeted resources.
    @Sendable
    @inlinable
    public func createEventBridgeRuleTemplate(_ input: CreateEventBridgeRuleTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateEventBridgeRuleTemplateResponse {
        try await self.client.execute(
            operation: "CreateEventBridgeRuleTemplate", 
            path: "/prod/eventbridge-rule-templates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an eventbridge rule template to monitor events and send notifications to your targeted resources.
    ///
    /// Parameters:
    ///   - description: A resource's optional description.
    ///   - eventTargets: 
    ///   - eventType: 
    ///   - groupIdentifier: An eventbridge rule template group's identifier. Can be either be its id or current name.
    ///   - name: A resource's name. Names must be unique within the scope of a resource type in a specific region.
    ///   - requestId: An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    ///   - tags: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createEventBridgeRuleTemplate(
        description: String? = nil,
        eventTargets: [EventBridgeRuleTemplateTarget]? = nil,
        eventType: EventBridgeRuleTemplateEventType? = nil,
        groupIdentifier: String? = nil,
        name: String? = nil,
        requestId: String? = CreateEventBridgeRuleTemplateRequest.idempotencyToken(),
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateEventBridgeRuleTemplateResponse {
        let input = CreateEventBridgeRuleTemplateRequest(
            description: description, 
            eventTargets: eventTargets, 
            eventType: eventType, 
            groupIdentifier: groupIdentifier, 
            name: name, 
            requestId: requestId, 
            tags: tags
        )
        return try await self.createEventBridgeRuleTemplate(input, logger: logger)
    }

    /// Creates an eventbridge rule template group to group your eventbridge rule templates and to attach to signal maps for dynamically creating notification rules.
    @Sendable
    @inlinable
    public func createEventBridgeRuleTemplateGroup(_ input: CreateEventBridgeRuleTemplateGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateEventBridgeRuleTemplateGroupResponse {
        try await self.client.execute(
            operation: "CreateEventBridgeRuleTemplateGroup", 
            path: "/prod/eventbridge-rule-template-groups", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an eventbridge rule template group to group your eventbridge rule templates and to attach to signal maps for dynamically creating notification rules.
    ///
    /// Parameters:
    ///   - description: A resource's optional description.
    ///   - name: A resource's name. Names must be unique within the scope of a resource type in a specific region.
    ///   - requestId: An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    ///   - tags: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createEventBridgeRuleTemplateGroup(
        description: String? = nil,
        name: String? = nil,
        requestId: String? = CreateEventBridgeRuleTemplateGroupRequest.idempotencyToken(),
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateEventBridgeRuleTemplateGroupResponse {
        let input = CreateEventBridgeRuleTemplateGroupRequest(
            description: description, 
            name: name, 
            requestId: requestId, 
            tags: tags
        )
        return try await self.createEventBridgeRuleTemplateGroup(input, logger: logger)
    }

    /// Create an input
    @Sendable
    @inlinable
    public func createInput(_ input: CreateInputRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateInputResponse {
        try await self.client.execute(
            operation: "CreateInput", 
            path: "/prod/inputs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create an input
    ///
    /// Parameters:
    ///   - destinations: Destination settings for PUSH type inputs.
    ///   - inputDevices: Settings for the devices.
    ///   - inputNetworkLocation: The location of this input. AWS, for an input existing in the AWS Cloud, On-Prem for
    ///   - inputSecurityGroups: A list of security groups referenced by IDs to attach to the input.
    ///   - mediaConnectFlows: A list of the MediaConnect Flows that you want to use in this input. You can specify as few as one
    ///   - multicastSettings: Multicast Input settings.
    ///   - name: Name of the input.
    ///   - requestId: Unique identifier of the request to ensure the request is handled
    ///   - roleArn: The Amazon Resource Name (ARN) of the role this input assumes during and after creation.
    ///   - sdiSources: 
    ///   - smpte2110ReceiverGroupSettings: Include this parameter if the input is a SMPTE 2110 input, to identify the stream sources for this input.
    ///   - sources: The source URLs for a PULL-type input. Every PULL type input needs
    ///   - srtSettings: The settings associated with an SRT input.
    ///   - tags: A collection of key-value pairs.
    ///   - type: 
    ///   - vpc: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createInput(
        destinations: [InputDestinationRequest]? = nil,
        inputDevices: [InputDeviceSettings]? = nil,
        inputNetworkLocation: InputNetworkLocation? = nil,
        inputSecurityGroups: [String]? = nil,
        mediaConnectFlows: [MediaConnectFlowRequest]? = nil,
        multicastSettings: MulticastSettingsCreateRequest? = nil,
        name: String? = nil,
        requestId: String? = CreateInputRequest.idempotencyToken(),
        roleArn: String? = nil,
        sdiSources: [String]? = nil,
        smpte2110ReceiverGroupSettings: Smpte2110ReceiverGroupSettings? = nil,
        sources: [InputSourceRequest]? = nil,
        srtSettings: SrtSettingsRequest? = nil,
        tags: [String: String]? = nil,
        type: InputType? = nil,
        vpc: InputVpcRequest? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateInputResponse {
        let input = CreateInputRequest(
            destinations: destinations, 
            inputDevices: inputDevices, 
            inputNetworkLocation: inputNetworkLocation, 
            inputSecurityGroups: inputSecurityGroups, 
            mediaConnectFlows: mediaConnectFlows, 
            multicastSettings: multicastSettings, 
            name: name, 
            requestId: requestId, 
            roleArn: roleArn, 
            sdiSources: sdiSources, 
            smpte2110ReceiverGroupSettings: smpte2110ReceiverGroupSettings, 
            sources: sources, 
            srtSettings: srtSettings, 
            tags: tags, 
            type: type, 
            vpc: vpc
        )
        return try await self.createInput(input, logger: logger)
    }

    /// Creates a Input Security Group
    @Sendable
    @inlinable
    public func createInputSecurityGroup(_ input: CreateInputSecurityGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateInputSecurityGroupResponse {
        try await self.client.execute(
            operation: "CreateInputSecurityGroup", 
            path: "/prod/inputSecurityGroups", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a Input Security Group
    ///
    /// Parameters:
    ///   - tags: A collection of key-value pairs.
    ///   - whitelistRules: List of IPv4 CIDR addresses to whitelist
    ///   - logger: Logger use during operation
    @inlinable
    public func createInputSecurityGroup(
        tags: [String: String]? = nil,
        whitelistRules: [InputWhitelistRuleCidr]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateInputSecurityGroupResponse {
        let input = CreateInputSecurityGroupRequest(
            tags: tags, 
            whitelistRules: whitelistRules
        )
        return try await self.createInputSecurityGroup(input, logger: logger)
    }

    /// Create a new multiplex.
    @Sendable
    @inlinable
    public func createMultiplex(_ input: CreateMultiplexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMultiplexResponse {
        try await self.client.execute(
            operation: "CreateMultiplex", 
            path: "/prod/multiplexes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new multiplex.
    ///
    /// Parameters:
    ///   - availabilityZones: A list of availability zones for the multiplex. You must specify exactly two.
    ///   - multiplexSettings: Configuration for a multiplex event.
    ///   - name: Name of multiplex.
    ///   - requestId: Unique request ID. This prevents retries from creating multiple
    ///   - tags: A collection of key-value pairs.
    ///   - logger: Logger use during operation
    @inlinable
    public func createMultiplex(
        availabilityZones: [String]? = nil,
        multiplexSettings: MultiplexSettings? = nil,
        name: String? = nil,
        requestId: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMultiplexResponse {
        let input = CreateMultiplexRequest(
            availabilityZones: availabilityZones, 
            multiplexSettings: multiplexSettings, 
            name: name, 
            requestId: requestId, 
            tags: tags
        )
        return try await self.createMultiplex(input, logger: logger)
    }

    /// Create a new program in the multiplex.
    @Sendable
    @inlinable
    public func createMultiplexProgram(_ input: CreateMultiplexProgramRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMultiplexProgramResponse {
        try await self.client.execute(
            operation: "CreateMultiplexProgram", 
            path: "/prod/multiplexes/{MultiplexId}/programs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new program in the multiplex.
    ///
    /// Parameters:
    ///   - multiplexId: ID of the multiplex where the program is to be created.
    ///   - multiplexProgramSettings: The settings for this multiplex program.
    ///   - programName: Name of multiplex program.
    ///   - requestId: Unique request ID. This prevents retries from creating multiple
    ///   - logger: Logger use during operation
    @inlinable
    public func createMultiplexProgram(
        multiplexId: String,
        multiplexProgramSettings: MultiplexProgramSettings? = nil,
        programName: String? = nil,
        requestId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMultiplexProgramResponse {
        let input = CreateMultiplexProgramRequest(
            multiplexId: multiplexId, 
            multiplexProgramSettings: multiplexProgramSettings, 
            programName: programName, 
            requestId: requestId
        )
        return try await self.createMultiplexProgram(input, logger: logger)
    }

    /// Create as many Networks as you need. You will associate one or more Clusters with each Network.Each Network provides MediaLive Anywhere with required information about the network in your organization that you are using for video encoding using MediaLive.
    @Sendable
    @inlinable
    public func createNetwork(_ input: CreateNetworkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateNetworkResponse {
        try await self.client.execute(
            operation: "CreateNetwork", 
            path: "/prod/networks", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create as many Networks as you need. You will associate one or more Clusters with each Network.Each Network provides MediaLive Anywhere with required information about the network in your organization that you are using for video encoding using MediaLive.
    ///
    /// Parameters:
    ///   - ipPools: An array of IpPoolCreateRequests that identify a collection of IP addresses in your network that you want to reserve for use in MediaLive Anywhere. MediaLiveAnywhere uses these IP addresses for Push inputs (in both Bridge and NATnetworks) and for output destinations (only in Bridge networks). EachIpPoolUpdateRequest specifies one CIDR block.
    ///   - name: Specify a name that is unique in the AWS account. We recommend that you assign a name that hints at the type of traffic on the network. Names are case-sensitive.
    ///   - requestId: An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    ///   - routes: An array of routes that MediaLive Anywhere needs to know about in order to route encoding traffic.
    ///   - tags: A collection of key-value pairs.
    ///   - logger: Logger use during operation
    @inlinable
    public func createNetwork(
        ipPools: [IpPoolCreateRequest]? = nil,
        name: String? = nil,
        requestId: String? = CreateNetworkRequest.idempotencyToken(),
        routes: [RouteCreateRequest]? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateNetworkResponse {
        let input = CreateNetworkRequest(
            ipPools: ipPools, 
            name: name, 
            requestId: requestId, 
            routes: routes, 
            tags: tags
        )
        return try await self.createNetwork(input, logger: logger)
    }

    /// Create a Node in the specified Cluster. You can also create Nodes using the CreateNodeRegistrationScript. Note that you can't move a Node to another Cluster.
    @Sendable
    @inlinable
    public func createNode(_ input: CreateNodeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateNodeResponse {
        try await self.client.execute(
            operation: "CreateNode", 
            path: "/prod/clusters/{ClusterId}/nodes", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a Node in the specified Cluster. You can also create Nodes using the CreateNodeRegistrationScript. Note that you can't move a Node to another Cluster.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster.
    ///   - name: The user-specified name of the Node to be created.
    ///   - nodeInterfaceMappings: Documentation update needed
    ///   - requestId: An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    ///   - role: The initial role of the Node in the Cluster. ACTIVE means the Node is available for encoding. BACKUP means the Node is a redundant Node and might get used if an ACTIVE Node fails.
    ///   - tags: A collection of key-value pairs.
    ///   - logger: Logger use during operation
    @inlinable
    public func createNode(
        clusterId: String,
        name: String? = nil,
        nodeInterfaceMappings: [NodeInterfaceMappingCreateRequest]? = nil,
        requestId: String? = CreateNodeRequest.idempotencyToken(),
        role: NodeRole? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateNodeResponse {
        let input = CreateNodeRequest(
            clusterId: clusterId, 
            name: name, 
            nodeInterfaceMappings: nodeInterfaceMappings, 
            requestId: requestId, 
            role: role, 
            tags: tags
        )
        return try await self.createNode(input, logger: logger)
    }

    /// Create the Register Node script for all the nodes intended for a specific Cluster. You will then run the script on each hardware unit that is intended for that Cluster. The script creates a Node in the specified Cluster. It then binds the Node to this hardware unit, and activates the node hardware for use with MediaLive Anywhere.
    @Sendable
    @inlinable
    public func createNodeRegistrationScript(_ input: CreateNodeRegistrationScriptRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateNodeRegistrationScriptResponse {
        try await self.client.execute(
            operation: "CreateNodeRegistrationScript", 
            path: "/prod/clusters/{ClusterId}/nodeRegistrationScript", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create the Register Node script for all the nodes intended for a specific Cluster. You will then run the script on each hardware unit that is intended for that Cluster. The script creates a Node in the specified Cluster. It then binds the Node to this hardware unit, and activates the node hardware for use with MediaLive Anywhere.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - id: If you're generating a re-registration script for an already existing node, this is where you provide the id.
    ///   - name: Specify a pattern for MediaLive Anywhere to use to assign a name to each Node in the Cluster. The pattern can include the variables $hn (hostname of the node hardware) and $ts for the date and time that the Node is created, in UTC (for example, 2024-08-20T23:35:12Z).
    ///   - nodeInterfaceMappings: Documentation update needed
    ///   - requestId: An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    ///   - role: The initial role of the Node in the Cluster. ACTIVE means the Node is available for encoding. BACKUP means the Node is a redundant Node and might get used if an ACTIVE Node fails.
    ///   - logger: Logger use during operation
    @inlinable
    public func createNodeRegistrationScript(
        clusterId: String,
        id: String? = nil,
        name: String? = nil,
        nodeInterfaceMappings: [NodeInterfaceMapping]? = nil,
        requestId: String? = CreateNodeRegistrationScriptRequest.idempotencyToken(),
        role: NodeRole? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateNodeRegistrationScriptResponse {
        let input = CreateNodeRegistrationScriptRequest(
            clusterId: clusterId, 
            id: id, 
            name: name, 
            nodeInterfaceMappings: nodeInterfaceMappings, 
            requestId: requestId, 
            role: role
        )
        return try await self.createNodeRegistrationScript(input, logger: logger)
    }

    /// Create a partner input
    @Sendable
    @inlinable
    public func createPartnerInput(_ input: CreatePartnerInputRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePartnerInputResponse {
        try await self.client.execute(
            operation: "CreatePartnerInput", 
            path: "/prod/inputs/{InputId}/partners", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a partner input
    ///
    /// Parameters:
    ///   - inputId: Unique ID of the input.
    ///   - requestId: Unique identifier of the request to ensure the request is handled
    ///   - tags: A collection of key-value pairs.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPartnerInput(
        inputId: String,
        requestId: String? = CreatePartnerInputRequest.idempotencyToken(),
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePartnerInputResponse {
        let input = CreatePartnerInputRequest(
            inputId: inputId, 
            requestId: requestId, 
            tags: tags
        )
        return try await self.createPartnerInput(input, logger: logger)
    }

    /// Create an SdiSource for each video source that uses the SDI protocol. You will reference the SdiSource when you create an SDI input in MediaLive. You will also reference it in an SdiSourceMapping, in order to create a connection between the logical SdiSource and the physical SDI card and port that the physical SDI source uses.
    @Sendable
    @inlinable
    public func createSdiSource(_ input: CreateSdiSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSdiSourceResponse {
        try await self.client.execute(
            operation: "CreateSdiSource", 
            path: "/prod/sdiSources", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create an SdiSource for each video source that uses the SDI protocol. You will reference the SdiSource when you create an SDI input in MediaLive. You will also reference it in an SdiSourceMapping, in order to create a connection between the logical SdiSource and the physical SDI card and port that the physical SDI source uses.
    ///
    /// Parameters:
    ///   - mode: Applies only if the type is QUAD. Specify the mode for handling the quad-link signal: QUADRANT or INTERLEAVE.
    ///   - name: Specify a name that is unique in the AWS account. We recommend you assign a name that describes the source, for example curling-cameraA. Names are case-sensitive.
    ///   - requestId: An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    ///   - tags: A collection of key-value pairs.
    ///   - type: Specify the  type of the SDI source: SINGLE: The source  is a single-link source. QUAD: The source  is one part of a quad-link source.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSdiSource(
        mode: SdiSourceMode? = nil,
        name: String? = nil,
        requestId: String? = CreateSdiSourceRequest.idempotencyToken(),
        tags: [String: String]? = nil,
        type: SdiSourceType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSdiSourceResponse {
        let input = CreateSdiSourceRequest(
            mode: mode, 
            name: name, 
            requestId: requestId, 
            tags: tags, 
            type: type
        )
        return try await self.createSdiSource(input, logger: logger)
    }

    /// Initiates the creation of a new signal map. Will discover a new mediaResourceMap based on the provided discoveryEntryPointArn.
    @Sendable
    @inlinable
    public func createSignalMap(_ input: CreateSignalMapRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSignalMapResponse {
        try await self.client.execute(
            operation: "CreateSignalMap", 
            path: "/prod/signal-maps", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initiates the creation of a new signal map. Will discover a new mediaResourceMap based on the provided discoveryEntryPointArn.
    ///
    /// Parameters:
    ///   - cloudWatchAlarmTemplateGroupIdentifiers: 
    ///   - description: A resource's optional description.
    ///   - discoveryEntryPointArn: A top-level supported AWS resource ARN to discovery a signal map from.
    ///   - eventBridgeRuleTemplateGroupIdentifiers: 
    ///   - name: A resource's name. Names must be unique within the scope of a resource type in a specific region.
    ///   - requestId: An ID that you assign to a create request. This ID ensures idempotency when creating resources.
    ///   - tags: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createSignalMap(
        cloudWatchAlarmTemplateGroupIdentifiers: [String]? = nil,
        description: String? = nil,
        discoveryEntryPointArn: String? = nil,
        eventBridgeRuleTemplateGroupIdentifiers: [String]? = nil,
        name: String? = nil,
        requestId: String? = CreateSignalMapRequest.idempotencyToken(),
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSignalMapResponse {
        let input = CreateSignalMapRequest(
            cloudWatchAlarmTemplateGroupIdentifiers: cloudWatchAlarmTemplateGroupIdentifiers, 
            description: description, 
            discoveryEntryPointArn: discoveryEntryPointArn, 
            eventBridgeRuleTemplateGroupIdentifiers: eventBridgeRuleTemplateGroupIdentifiers, 
            name: name, 
            requestId: requestId, 
            tags: tags
        )
        return try await self.createSignalMap(input, logger: logger)
    }

    /// Create tags for a resource
    @Sendable
    @inlinable
    public func createTags(_ input: CreateTagsRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "CreateTags", 
            path: "/prod/tags/{ResourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create tags for a resource
    ///
    /// Parameters:
    ///   - resourceArn: 
    ///   - tags: 
    ///   - logger: Logger use during operation
    @inlinable
    public func createTags(
        resourceArn: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = CreateTagsRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.createTags(input, logger: logger)
    }

    /// Starts deletion of channel. The associated outputs are also deleted.
    @Sendable
    @inlinable
    public func deleteChannel(_ input: DeleteChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteChannelResponse {
        try await self.client.execute(
            operation: "DeleteChannel", 
            path: "/prod/channels/{ChannelId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts deletion of channel. The associated outputs are also deleted.
    ///
    /// Parameters:
    ///   - channelId: Unique ID of the channel.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteChannel(
        channelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteChannelResponse {
        let input = DeleteChannelRequest(
            channelId: channelId
        )
        return try await self.deleteChannel(input, logger: logger)
    }

    /// Delete the specified ChannelPlacementGroup that exists in the specified Cluster.
    @Sendable
    @inlinable
    public func deleteChannelPlacementGroup(_ input: DeleteChannelPlacementGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteChannelPlacementGroupResponse {
        try await self.client.execute(
            operation: "DeleteChannelPlacementGroup", 
            path: "/prod/clusters/{ClusterId}/channelplacementgroups/{ChannelPlacementGroupId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete the specified ChannelPlacementGroup that exists in the specified Cluster.
    ///
    /// Parameters:
    ///   - channelPlacementGroupId: The ID of the channel placement group.
    ///   - clusterId: The ID of the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteChannelPlacementGroup(
        channelPlacementGroupId: String,
        clusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteChannelPlacementGroupResponse {
        let input = DeleteChannelPlacementGroupRequest(
            channelPlacementGroupId: channelPlacementGroupId, 
            clusterId: clusterId
        )
        return try await self.deleteChannelPlacementGroup(input, logger: logger)
    }

    /// Deletes a cloudwatch alarm template.
    @Sendable
    @inlinable
    public func deleteCloudWatchAlarmTemplate(_ input: DeleteCloudWatchAlarmTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteCloudWatchAlarmTemplate", 
            path: "/prod/cloudwatch-alarm-templates/{Identifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a cloudwatch alarm template.
    ///
    /// Parameters:
    ///   - identifier: A cloudwatch alarm template's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCloudWatchAlarmTemplate(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteCloudWatchAlarmTemplateRequest(
            identifier: identifier
        )
        return try await self.deleteCloudWatchAlarmTemplate(input, logger: logger)
    }

    /// Deletes a cloudwatch alarm template group. You must detach this group from all signal maps and ensure its existing templates are moved to another group or deleted.
    @Sendable
    @inlinable
    public func deleteCloudWatchAlarmTemplateGroup(_ input: DeleteCloudWatchAlarmTemplateGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteCloudWatchAlarmTemplateGroup", 
            path: "/prod/cloudwatch-alarm-template-groups/{Identifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a cloudwatch alarm template group. You must detach this group from all signal maps and ensure its existing templates are moved to another group or deleted.
    ///
    /// Parameters:
    ///   - identifier: A cloudwatch alarm template group's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCloudWatchAlarmTemplateGroup(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteCloudWatchAlarmTemplateGroupRequest(
            identifier: identifier
        )
        return try await self.deleteCloudWatchAlarmTemplateGroup(input, logger: logger)
    }

    /// Delete a Cluster. The Cluster must be idle.
    @Sendable
    @inlinable
    public func deleteCluster(_ input: DeleteClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteClusterResponse {
        try await self.client.execute(
            operation: "DeleteCluster", 
            path: "/prod/clusters/{ClusterId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a Cluster. The Cluster must be idle.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCluster(
        clusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteClusterResponse {
        let input = DeleteClusterRequest(
            clusterId: clusterId
        )
        return try await self.deleteCluster(input, logger: logger)
    }

    /// Deletes an eventbridge rule template.
    @Sendable
    @inlinable
    public func deleteEventBridgeRuleTemplate(_ input: DeleteEventBridgeRuleTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteEventBridgeRuleTemplate", 
            path: "/prod/eventbridge-rule-templates/{Identifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an eventbridge rule template.
    ///
    /// Parameters:
    ///   - identifier: An eventbridge rule template's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteEventBridgeRuleTemplate(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteEventBridgeRuleTemplateRequest(
            identifier: identifier
        )
        return try await self.deleteEventBridgeRuleTemplate(input, logger: logger)
    }

    /// Deletes an eventbridge rule template group. You must detach this group from all signal maps and ensure its existing templates are moved to another group or deleted.
    @Sendable
    @inlinable
    public func deleteEventBridgeRuleTemplateGroup(_ input: DeleteEventBridgeRuleTemplateGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteEventBridgeRuleTemplateGroup", 
            path: "/prod/eventbridge-rule-template-groups/{Identifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an eventbridge rule template group. You must detach this group from all signal maps and ensure its existing templates are moved to another group or deleted.
    ///
    /// Parameters:
    ///   - identifier: An eventbridge rule template group's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteEventBridgeRuleTemplateGroup(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteEventBridgeRuleTemplateGroupRequest(
            identifier: identifier
        )
        return try await self.deleteEventBridgeRuleTemplateGroup(input, logger: logger)
    }

    /// Deletes the input end point
    @Sendable
    @inlinable
    public func deleteInput(_ input: DeleteInputRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteInputResponse {
        try await self.client.execute(
            operation: "DeleteInput", 
            path: "/prod/inputs/{InputId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the input end point
    ///
    /// Parameters:
    ///   - inputId: Unique ID of the input
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteInput(
        inputId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteInputResponse {
        let input = DeleteInputRequest(
            inputId: inputId
        )
        return try await self.deleteInput(input, logger: logger)
    }

    /// Deletes an Input Security Group
    @Sendable
    @inlinable
    public func deleteInputSecurityGroup(_ input: DeleteInputSecurityGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteInputSecurityGroupResponse {
        try await self.client.execute(
            operation: "DeleteInputSecurityGroup", 
            path: "/prod/inputSecurityGroups/{InputSecurityGroupId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an Input Security Group
    ///
    /// Parameters:
    ///   - inputSecurityGroupId: The Input Security Group to delete
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteInputSecurityGroup(
        inputSecurityGroupId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteInputSecurityGroupResponse {
        let input = DeleteInputSecurityGroupRequest(
            inputSecurityGroupId: inputSecurityGroupId
        )
        return try await self.deleteInputSecurityGroup(input, logger: logger)
    }

    /// Delete a multiplex. The multiplex must be idle.
    @Sendable
    @inlinable
    public func deleteMultiplex(_ input: DeleteMultiplexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMultiplexResponse {
        try await self.client.execute(
            operation: "DeleteMultiplex", 
            path: "/prod/multiplexes/{MultiplexId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a multiplex. The multiplex must be idle.
    ///
    /// Parameters:
    ///   - multiplexId: The ID of the multiplex.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMultiplex(
        multiplexId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMultiplexResponse {
        let input = DeleteMultiplexRequest(
            multiplexId: multiplexId
        )
        return try await self.deleteMultiplex(input, logger: logger)
    }

    /// Delete a program from a multiplex.
    @Sendable
    @inlinable
    public func deleteMultiplexProgram(_ input: DeleteMultiplexProgramRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMultiplexProgramResponse {
        try await self.client.execute(
            operation: "DeleteMultiplexProgram", 
            path: "/prod/multiplexes/{MultiplexId}/programs/{ProgramName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a program from a multiplex.
    ///
    /// Parameters:
    ///   - multiplexId: The ID of the multiplex that the program belongs to.
    ///   - programName: The multiplex program name.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMultiplexProgram(
        multiplexId: String,
        programName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMultiplexProgramResponse {
        let input = DeleteMultiplexProgramRequest(
            multiplexId: multiplexId, 
            programName: programName
        )
        return try await self.deleteMultiplexProgram(input, logger: logger)
    }

    /// Delete a Network. The Network must have no resources associated with it.
    @Sendable
    @inlinable
    public func deleteNetwork(_ input: DeleteNetworkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteNetworkResponse {
        try await self.client.execute(
            operation: "DeleteNetwork", 
            path: "/prod/networks/{NetworkId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a Network. The Network must have no resources associated with it.
    ///
    /// Parameters:
    ///   - networkId: The ID of the network.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteNetwork(
        networkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteNetworkResponse {
        let input = DeleteNetworkRequest(
            networkId: networkId
        )
        return try await self.deleteNetwork(input, logger: logger)
    }

    /// Delete a Node. The Node must be IDLE.
    @Sendable
    @inlinable
    public func deleteNode(_ input: DeleteNodeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteNodeResponse {
        try await self.client.execute(
            operation: "DeleteNode", 
            path: "/prod/clusters/{ClusterId}/nodes/{NodeId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a Node. The Node must be IDLE.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - nodeId: The ID of the node.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteNode(
        clusterId: String,
        nodeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteNodeResponse {
        let input = DeleteNodeRequest(
            clusterId: clusterId, 
            nodeId: nodeId
        )
        return try await self.deleteNode(input, logger: logger)
    }

    /// Delete an expired reservation.
    @Sendable
    @inlinable
    public func deleteReservation(_ input: DeleteReservationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReservationResponse {
        try await self.client.execute(
            operation: "DeleteReservation", 
            path: "/prod/reservations/{ReservationId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete an expired reservation.
    ///
    /// Parameters:
    ///   - reservationId: Unique reservation ID, e.g. '1234567'
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteReservation(
        reservationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteReservationResponse {
        let input = DeleteReservationRequest(
            reservationId: reservationId
        )
        return try await self.deleteReservation(input, logger: logger)
    }

    /// Delete all schedule actions on a channel.
    @Sendable
    @inlinable
    public func deleteSchedule(_ input: DeleteScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteScheduleResponse {
        try await self.client.execute(
            operation: "DeleteSchedule", 
            path: "/prod/channels/{ChannelId}/schedule", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete all schedule actions on a channel.
    ///
    /// Parameters:
    ///   - channelId: Id of the channel whose schedule is being deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSchedule(
        channelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteScheduleResponse {
        let input = DeleteScheduleRequest(
            channelId: channelId
        )
        return try await self.deleteSchedule(input, logger: logger)
    }

    /// Delete an SdiSource. The SdiSource must not be part of any SidSourceMapping and must not be attached to any input.
    @Sendable
    @inlinable
    public func deleteSdiSource(_ input: DeleteSdiSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSdiSourceResponse {
        try await self.client.execute(
            operation: "DeleteSdiSource", 
            path: "/prod/sdiSources/{SdiSourceId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete an SdiSource. The SdiSource must not be part of any SidSourceMapping and must not be attached to any input.
    ///
    /// Parameters:
    ///   - sdiSourceId: The ID of the SdiSource.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSdiSource(
        sdiSourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSdiSourceResponse {
        let input = DeleteSdiSourceRequest(
            sdiSourceId: sdiSourceId
        )
        return try await self.deleteSdiSource(input, logger: logger)
    }

    /// Deletes the specified signal map.
    @Sendable
    @inlinable
    public func deleteSignalMap(_ input: DeleteSignalMapRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteSignalMap", 
            path: "/prod/signal-maps/{Identifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified signal map.
    ///
    /// Parameters:
    ///   - identifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSignalMap(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteSignalMapRequest(
            identifier: identifier
        )
        return try await self.deleteSignalMap(input, logger: logger)
    }

    /// Removes tags for a resource
    @Sendable
    @inlinable
    public func deleteTags(_ input: DeleteTagsRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteTags", 
            path: "/prod/tags/{ResourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes tags for a resource
    ///
    /// Parameters:
    ///   - resourceArn: 
    ///   - tagKeys: An array of tag keys to delete
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTags(
        resourceArn: String,
        tagKeys: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteTagsRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.deleteTags(input, logger: logger)
    }

    /// Describe account configuration
    @Sendable
    @inlinable
    public func describeAccountConfiguration(_ input: DescribeAccountConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeAccountConfigurationResponse {
        try await self.client.execute(
            operation: "DescribeAccountConfiguration", 
            path: "/prod/accountConfiguration", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describe account configuration
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func describeAccountConfiguration(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeAccountConfigurationResponse {
        let input = DescribeAccountConfigurationRequest(
        )
        return try await self.describeAccountConfiguration(input, logger: logger)
    }

    /// Gets details about a channel
    @Sendable
    @inlinable
    public func describeChannel(_ input: DescribeChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeChannelResponse {
        try await self.client.execute(
            operation: "DescribeChannel", 
            path: "/prod/channels/{ChannelId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets details about a channel
    ///
    /// Parameters:
    ///   - channelId: channel ID
    ///   - logger: Logger use during operation
    @inlinable
    public func describeChannel(
        channelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeChannelResponse {
        let input = DescribeChannelRequest(
            channelId: channelId
        )
        return try await self.describeChannel(input, logger: logger)
    }

    /// Get details about a ChannelPlacementGroup.
    @Sendable
    @inlinable
    public func describeChannelPlacementGroup(_ input: DescribeChannelPlacementGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeChannelPlacementGroupResponse {
        try await self.client.execute(
            operation: "DescribeChannelPlacementGroup", 
            path: "/prod/clusters/{ClusterId}/channelplacementgroups/{ChannelPlacementGroupId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get details about a ChannelPlacementGroup.
    ///
    /// Parameters:
    ///   - channelPlacementGroupId: The ID of the channel placement group.
    ///   - clusterId: The ID of the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeChannelPlacementGroup(
        channelPlacementGroupId: String,
        clusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeChannelPlacementGroupResponse {
        let input = DescribeChannelPlacementGroupRequest(
            channelPlacementGroupId: channelPlacementGroupId, 
            clusterId: clusterId
        )
        return try await self.describeChannelPlacementGroup(input, logger: logger)
    }

    /// Get details about a Cluster.
    @Sendable
    @inlinable
    public func describeCluster(_ input: DescribeClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeClusterResponse {
        try await self.client.execute(
            operation: "DescribeCluster", 
            path: "/prod/clusters/{ClusterId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get details about a Cluster.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeCluster(
        clusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeClusterResponse {
        let input = DescribeClusterRequest(
            clusterId: clusterId
        )
        return try await self.describeCluster(input, logger: logger)
    }

    /// Produces details about an input
    @Sendable
    @inlinable
    public func describeInput(_ input: DescribeInputRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeInputResponse {
        try await self.client.execute(
            operation: "DescribeInput", 
            path: "/prod/inputs/{InputId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Produces details about an input
    ///
    /// Parameters:
    ///   - inputId: Unique ID of the input
    ///   - logger: Logger use during operation
    @inlinable
    public func describeInput(
        inputId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeInputResponse {
        let input = DescribeInputRequest(
            inputId: inputId
        )
        return try await self.describeInput(input, logger: logger)
    }

    /// Gets the details for the input device
    @Sendable
    @inlinable
    public func describeInputDevice(_ input: DescribeInputDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeInputDeviceResponse {
        try await self.client.execute(
            operation: "DescribeInputDevice", 
            path: "/prod/inputDevices/{InputDeviceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the details for the input device
    ///
    /// Parameters:
    ///   - inputDeviceId: The unique ID of this input device. For example, hd-123456789abcdef.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeInputDevice(
        inputDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeInputDeviceResponse {
        let input = DescribeInputDeviceRequest(
            inputDeviceId: inputDeviceId
        )
        return try await self.describeInputDevice(input, logger: logger)
    }

    /// Get the latest thumbnail data for the input device.
    @Sendable
    @inlinable
    public func describeInputDeviceThumbnail(_ input: DescribeInputDeviceThumbnailRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeInputDeviceThumbnailResponse {
        try await self.client.execute(
            operation: "DescribeInputDeviceThumbnail", 
            path: "/prod/inputDevices/{InputDeviceId}/thumbnailData", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get the latest thumbnail data for the input device.
    ///
    /// Parameters:
    ///   - accept: The HTTP Accept header. Indicates the requested type for the thumbnail.
    ///   - inputDeviceId: The unique ID of this input device. For example, hd-123456789abcdef.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeInputDeviceThumbnail(
        accept: AcceptHeader? = nil,
        inputDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeInputDeviceThumbnailResponse {
        let input = DescribeInputDeviceThumbnailRequest(
            accept: accept, 
            inputDeviceId: inputDeviceId
        )
        return try await self.describeInputDeviceThumbnail(input, logger: logger)
    }

    /// Produces a summary of an Input Security Group
    @Sendable
    @inlinable
    public func describeInputSecurityGroup(_ input: DescribeInputSecurityGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeInputSecurityGroupResponse {
        try await self.client.execute(
            operation: "DescribeInputSecurityGroup", 
            path: "/prod/inputSecurityGroups/{InputSecurityGroupId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Produces a summary of an Input Security Group
    ///
    /// Parameters:
    ///   - inputSecurityGroupId: The id of the Input Security Group to describe
    ///   - logger: Logger use during operation
    @inlinable
    public func describeInputSecurityGroup(
        inputSecurityGroupId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeInputSecurityGroupResponse {
        let input = DescribeInputSecurityGroupRequest(
            inputSecurityGroupId: inputSecurityGroupId
        )
        return try await self.describeInputSecurityGroup(input, logger: logger)
    }

    /// Gets details about a multiplex.
    @Sendable
    @inlinable
    public func describeMultiplex(_ input: DescribeMultiplexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMultiplexResponse {
        try await self.client.execute(
            operation: "DescribeMultiplex", 
            path: "/prod/multiplexes/{MultiplexId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets details about a multiplex.
    ///
    /// Parameters:
    ///   - multiplexId: The ID of the multiplex.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeMultiplex(
        multiplexId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeMultiplexResponse {
        let input = DescribeMultiplexRequest(
            multiplexId: multiplexId
        )
        return try await self.describeMultiplex(input, logger: logger)
    }

    /// Get the details for a program in a multiplex.
    @Sendable
    @inlinable
    public func describeMultiplexProgram(_ input: DescribeMultiplexProgramRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMultiplexProgramResponse {
        try await self.client.execute(
            operation: "DescribeMultiplexProgram", 
            path: "/prod/multiplexes/{MultiplexId}/programs/{ProgramName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get the details for a program in a multiplex.
    ///
    /// Parameters:
    ///   - multiplexId: The ID of the multiplex that the program belongs to.
    ///   - programName: The name of the program.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeMultiplexProgram(
        multiplexId: String,
        programName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeMultiplexProgramResponse {
        let input = DescribeMultiplexProgramRequest(
            multiplexId: multiplexId, 
            programName: programName
        )
        return try await self.describeMultiplexProgram(input, logger: logger)
    }

    /// Get details about a Network.
    @Sendable
    @inlinable
    public func describeNetwork(_ input: DescribeNetworkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeNetworkResponse {
        try await self.client.execute(
            operation: "DescribeNetwork", 
            path: "/prod/networks/{NetworkId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get details about a Network.
    ///
    /// Parameters:
    ///   - networkId: The ID of the network.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeNetwork(
        networkId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeNetworkResponse {
        let input = DescribeNetworkRequest(
            networkId: networkId
        )
        return try await self.describeNetwork(input, logger: logger)
    }

    /// Get details about a Node in the specified Cluster.
    @Sendable
    @inlinable
    public func describeNode(_ input: DescribeNodeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeNodeResponse {
        try await self.client.execute(
            operation: "DescribeNode", 
            path: "/prod/clusters/{ClusterId}/nodes/{NodeId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get details about a Node in the specified Cluster.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - nodeId: The ID of the node.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeNode(
        clusterId: String,
        nodeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeNodeResponse {
        let input = DescribeNodeRequest(
            clusterId: clusterId, 
            nodeId: nodeId
        )
        return try await self.describeNode(input, logger: logger)
    }

    /// Get details for an offering.
    @Sendable
    @inlinable
    public func describeOffering(_ input: DescribeOfferingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeOfferingResponse {
        try await self.client.execute(
            operation: "DescribeOffering", 
            path: "/prod/offerings/{OfferingId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get details for an offering.
    ///
    /// Parameters:
    ///   - offeringId: Unique offering ID, e.g. '87654321'
    ///   - logger: Logger use during operation
    @inlinable
    public func describeOffering(
        offeringId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeOfferingResponse {
        let input = DescribeOfferingRequest(
            offeringId: offeringId
        )
        return try await self.describeOffering(input, logger: logger)
    }

    /// Get details for a reservation.
    @Sendable
    @inlinable
    public func describeReservation(_ input: DescribeReservationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReservationResponse {
        try await self.client.execute(
            operation: "DescribeReservation", 
            path: "/prod/reservations/{ReservationId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get details for a reservation.
    ///
    /// Parameters:
    ///   - reservationId: Unique reservation ID, e.g. '1234567'
    ///   - logger: Logger use during operation
    @inlinable
    public func describeReservation(
        reservationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeReservationResponse {
        let input = DescribeReservationRequest(
            reservationId: reservationId
        )
        return try await self.describeReservation(input, logger: logger)
    }

    /// Get a channel schedule
    @Sendable
    @inlinable
    public func describeSchedule(_ input: DescribeScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeScheduleResponse {
        try await self.client.execute(
            operation: "DescribeSchedule", 
            path: "/prod/channels/{ChannelId}/schedule", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a channel schedule
    ///
    /// Parameters:
    ///   - channelId: Id of the channel whose schedule is being updated.
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSchedule(
        channelId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeScheduleResponse {
        let input = DescribeScheduleRequest(
            channelId: channelId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.describeSchedule(input, logger: logger)
    }

    /// Gets details about a SdiSource.
    @Sendable
    @inlinable
    public func describeSdiSource(_ input: DescribeSdiSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSdiSourceResponse {
        try await self.client.execute(
            operation: "DescribeSdiSource", 
            path: "/prod/sdiSources/{SdiSourceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets details about a SdiSource.
    ///
    /// Parameters:
    ///   - sdiSourceId: Get details about an SdiSource.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSdiSource(
        sdiSourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSdiSourceResponse {
        let input = DescribeSdiSourceRequest(
            sdiSourceId: sdiSourceId
        )
        return try await self.describeSdiSource(input, logger: logger)
    }

    /// Describe the latest thumbnails data.
    @Sendable
    @inlinable
    public func describeThumbnails(_ input: DescribeThumbnailsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeThumbnailsResponse {
        try await self.client.execute(
            operation: "DescribeThumbnails", 
            path: "/prod/channels/{ChannelId}/thumbnails", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describe the latest thumbnails data.
    ///
    /// Parameters:
    ///   - channelId: Unique ID of the channel
    ///   - pipelineId: Pipeline ID ("0" or "1")
    ///   - thumbnailType: thumbnail type
    ///   - logger: Logger use during operation
    @inlinable
    public func describeThumbnails(
        channelId: String,
        pipelineId: String? = nil,
        thumbnailType: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeThumbnailsResponse {
        let input = DescribeThumbnailsRequest(
            channelId: channelId, 
            pipelineId: pipelineId, 
            thumbnailType: thumbnailType
        )
        return try await self.describeThumbnails(input, logger: logger)
    }

    /// Retrieves the specified cloudwatch alarm template.
    @Sendable
    @inlinable
    public func getCloudWatchAlarmTemplate(_ input: GetCloudWatchAlarmTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCloudWatchAlarmTemplateResponse {
        try await self.client.execute(
            operation: "GetCloudWatchAlarmTemplate", 
            path: "/prod/cloudwatch-alarm-templates/{Identifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the specified cloudwatch alarm template.
    ///
    /// Parameters:
    ///   - identifier: A cloudwatch alarm template's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCloudWatchAlarmTemplate(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCloudWatchAlarmTemplateResponse {
        let input = GetCloudWatchAlarmTemplateRequest(
            identifier: identifier
        )
        return try await self.getCloudWatchAlarmTemplate(input, logger: logger)
    }

    /// Retrieves the specified cloudwatch alarm template group.
    @Sendable
    @inlinable
    public func getCloudWatchAlarmTemplateGroup(_ input: GetCloudWatchAlarmTemplateGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCloudWatchAlarmTemplateGroupResponse {
        try await self.client.execute(
            operation: "GetCloudWatchAlarmTemplateGroup", 
            path: "/prod/cloudwatch-alarm-template-groups/{Identifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the specified cloudwatch alarm template group.
    ///
    /// Parameters:
    ///   - identifier: A cloudwatch alarm template group's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCloudWatchAlarmTemplateGroup(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCloudWatchAlarmTemplateGroupResponse {
        let input = GetCloudWatchAlarmTemplateGroupRequest(
            identifier: identifier
        )
        return try await self.getCloudWatchAlarmTemplateGroup(input, logger: logger)
    }

    /// Retrieves the specified eventbridge rule template.
    @Sendable
    @inlinable
    public func getEventBridgeRuleTemplate(_ input: GetEventBridgeRuleTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEventBridgeRuleTemplateResponse {
        try await self.client.execute(
            operation: "GetEventBridgeRuleTemplate", 
            path: "/prod/eventbridge-rule-templates/{Identifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the specified eventbridge rule template.
    ///
    /// Parameters:
    ///   - identifier: An eventbridge rule template's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func getEventBridgeRuleTemplate(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEventBridgeRuleTemplateResponse {
        let input = GetEventBridgeRuleTemplateRequest(
            identifier: identifier
        )
        return try await self.getEventBridgeRuleTemplate(input, logger: logger)
    }

    /// Retrieves the specified eventbridge rule template group.
    @Sendable
    @inlinable
    public func getEventBridgeRuleTemplateGroup(_ input: GetEventBridgeRuleTemplateGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEventBridgeRuleTemplateGroupResponse {
        try await self.client.execute(
            operation: "GetEventBridgeRuleTemplateGroup", 
            path: "/prod/eventbridge-rule-template-groups/{Identifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the specified eventbridge rule template group.
    ///
    /// Parameters:
    ///   - identifier: An eventbridge rule template group's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func getEventBridgeRuleTemplateGroup(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEventBridgeRuleTemplateGroupResponse {
        let input = GetEventBridgeRuleTemplateGroupRequest(
            identifier: identifier
        )
        return try await self.getEventBridgeRuleTemplateGroup(input, logger: logger)
    }

    /// Retrieves the specified signal map.
    @Sendable
    @inlinable
    public func getSignalMap(_ input: GetSignalMapRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSignalMapResponse {
        try await self.client.execute(
            operation: "GetSignalMap", 
            path: "/prod/signal-maps/{Identifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the specified signal map.
    ///
    /// Parameters:
    ///   - identifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSignalMap(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSignalMapResponse {
        let input = GetSignalMapRequest(
            identifier: identifier
        )
        return try await self.getSignalMap(input, logger: logger)
    }

    /// Retrieve the list of ChannelPlacementGroups in the specified Cluster.
    @Sendable
    @inlinable
    public func listChannelPlacementGroups(_ input: ListChannelPlacementGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListChannelPlacementGroupsResponse {
        try await self.client.execute(
            operation: "ListChannelPlacementGroups", 
            path: "/prod/clusters/{ClusterId}/channelplacementgroups", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the list of ChannelPlacementGroups in the specified Cluster.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - maxResults: The maximum number of items to return.
    ///   - nextToken: The token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listChannelPlacementGroups(
        clusterId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListChannelPlacementGroupsResponse {
        let input = ListChannelPlacementGroupsRequest(
            clusterId: clusterId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listChannelPlacementGroups(input, logger: logger)
    }

    /// Produces list of channels that have been created
    @Sendable
    @inlinable
    public func listChannels(_ input: ListChannelsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListChannelsResponse {
        try await self.client.execute(
            operation: "ListChannels", 
            path: "/prod/channels", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Produces list of channels that have been created
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listChannels(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListChannelsResponse {
        let input = ListChannelsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listChannels(input, logger: logger)
    }

    /// Lists cloudwatch alarm template groups.
    @Sendable
    @inlinable
    public func listCloudWatchAlarmTemplateGroups(_ input: ListCloudWatchAlarmTemplateGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCloudWatchAlarmTemplateGroupsResponse {
        try await self.client.execute(
            operation: "ListCloudWatchAlarmTemplateGroups", 
            path: "/prod/cloudwatch-alarm-template-groups", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists cloudwatch alarm template groups.
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: A token used to retrieve the next set of results in paginated list responses.
    ///   - scope: Represents the scope of a resource, with options for all scopes, AWS provided resources, or local resources.
    ///   - signalMapIdentifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCloudWatchAlarmTemplateGroups(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        scope: String? = nil,
        signalMapIdentifier: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCloudWatchAlarmTemplateGroupsResponse {
        let input = ListCloudWatchAlarmTemplateGroupsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            scope: scope, 
            signalMapIdentifier: signalMapIdentifier
        )
        return try await self.listCloudWatchAlarmTemplateGroups(input, logger: logger)
    }

    /// Lists cloudwatch alarm templates.
    @Sendable
    @inlinable
    public func listCloudWatchAlarmTemplates(_ input: ListCloudWatchAlarmTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCloudWatchAlarmTemplatesResponse {
        try await self.client.execute(
            operation: "ListCloudWatchAlarmTemplates", 
            path: "/prod/cloudwatch-alarm-templates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists cloudwatch alarm templates.
    ///
    /// Parameters:
    ///   - groupIdentifier: A cloudwatch alarm template group's identifier. Can be either be its id or current name.
    ///   - maxResults: 
    ///   - nextToken: A token used to retrieve the next set of results in paginated list responses.
    ///   - scope: Represents the scope of a resource, with options for all scopes, AWS provided resources, or local resources.
    ///   - signalMapIdentifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCloudWatchAlarmTemplates(
        groupIdentifier: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        scope: String? = nil,
        signalMapIdentifier: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCloudWatchAlarmTemplatesResponse {
        let input = ListCloudWatchAlarmTemplatesRequest(
            groupIdentifier: groupIdentifier, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            scope: scope, 
            signalMapIdentifier: signalMapIdentifier
        )
        return try await self.listCloudWatchAlarmTemplates(input, logger: logger)
    }

    /// Retrieve the list of Clusters.
    @Sendable
    @inlinable
    public func listClusters(_ input: ListClustersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListClustersResponse {
        try await self.client.execute(
            operation: "ListClusters", 
            path: "/prod/clusters", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the list of Clusters.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return.
    ///   - nextToken: The token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listClusters(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListClustersResponse {
        let input = ListClustersRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listClusters(input, logger: logger)
    }

    /// Lists eventbridge rule template groups.
    @Sendable
    @inlinable
    public func listEventBridgeRuleTemplateGroups(_ input: ListEventBridgeRuleTemplateGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEventBridgeRuleTemplateGroupsResponse {
        try await self.client.execute(
            operation: "ListEventBridgeRuleTemplateGroups", 
            path: "/prod/eventbridge-rule-template-groups", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists eventbridge rule template groups.
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: A token used to retrieve the next set of results in paginated list responses.
    ///   - signalMapIdentifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEventBridgeRuleTemplateGroups(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        signalMapIdentifier: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEventBridgeRuleTemplateGroupsResponse {
        let input = ListEventBridgeRuleTemplateGroupsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            signalMapIdentifier: signalMapIdentifier
        )
        return try await self.listEventBridgeRuleTemplateGroups(input, logger: logger)
    }

    /// Lists eventbridge rule templates.
    @Sendable
    @inlinable
    public func listEventBridgeRuleTemplates(_ input: ListEventBridgeRuleTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEventBridgeRuleTemplatesResponse {
        try await self.client.execute(
            operation: "ListEventBridgeRuleTemplates", 
            path: "/prod/eventbridge-rule-templates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists eventbridge rule templates.
    ///
    /// Parameters:
    ///   - groupIdentifier: An eventbridge rule template group's identifier. Can be either be its id or current name.
    ///   - maxResults: 
    ///   - nextToken: A token used to retrieve the next set of results in paginated list responses.
    ///   - signalMapIdentifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEventBridgeRuleTemplates(
        groupIdentifier: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        signalMapIdentifier: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEventBridgeRuleTemplatesResponse {
        let input = ListEventBridgeRuleTemplatesRequest(
            groupIdentifier: groupIdentifier, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            signalMapIdentifier: signalMapIdentifier
        )
        return try await self.listEventBridgeRuleTemplates(input, logger: logger)
    }

    /// List input devices that are currently being transferred. List input devices that you are transferring from your AWS account or input devices that another AWS account is transferring to you.
    @Sendable
    @inlinable
    public func listInputDeviceTransfers(_ input: ListInputDeviceTransfersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListInputDeviceTransfersResponse {
        try await self.client.execute(
            operation: "ListInputDeviceTransfers", 
            path: "/prod/inputDeviceTransfers", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List input devices that are currently being transferred. List input devices that you are transferring from your AWS account or input devices that another AWS account is transferring to you.
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - transferType: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listInputDeviceTransfers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        transferType: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListInputDeviceTransfersResponse {
        let input = ListInputDeviceTransfersRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            transferType: transferType
        )
        return try await self.listInputDeviceTransfers(input, logger: logger)
    }

    /// List input devices
    @Sendable
    @inlinable
    public func listInputDevices(_ input: ListInputDevicesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListInputDevicesResponse {
        try await self.client.execute(
            operation: "ListInputDevices", 
            path: "/prod/inputDevices", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List input devices
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listInputDevices(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListInputDevicesResponse {
        let input = ListInputDevicesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listInputDevices(input, logger: logger)
    }

    /// Produces a list of Input Security Groups for an account
    @Sendable
    @inlinable
    public func listInputSecurityGroups(_ input: ListInputSecurityGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListInputSecurityGroupsResponse {
        try await self.client.execute(
            operation: "ListInputSecurityGroups", 
            path: "/prod/inputSecurityGroups", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Produces a list of Input Security Groups for an account
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listInputSecurityGroups(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListInputSecurityGroupsResponse {
        let input = ListInputSecurityGroupsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listInputSecurityGroups(input, logger: logger)
    }

    /// Produces list of inputs that have been created
    @Sendable
    @inlinable
    public func listInputs(_ input: ListInputsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListInputsResponse {
        try await self.client.execute(
            operation: "ListInputs", 
            path: "/prod/inputs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Produces list of inputs that have been created
    ///
    /// Parameters:
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listInputs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListInputsResponse {
        let input = ListInputsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listInputs(input, logger: logger)
    }

    /// List the programs that currently exist for a specific multiplex.
    @Sendable
    @inlinable
    public func listMultiplexPrograms(_ input: ListMultiplexProgramsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMultiplexProgramsResponse {
        try await self.client.execute(
            operation: "ListMultiplexPrograms", 
            path: "/prod/multiplexes/{MultiplexId}/programs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the programs that currently exist for a specific multiplex.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return.
    ///   - multiplexId: The ID of the multiplex that the programs belong to.
    ///   - nextToken: The token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMultiplexPrograms(
        maxResults: Int? = nil,
        multiplexId: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMultiplexProgramsResponse {
        let input = ListMultiplexProgramsRequest(
            maxResults: maxResults, 
            multiplexId: multiplexId, 
            nextToken: nextToken
        )
        return try await self.listMultiplexPrograms(input, logger: logger)
    }

    /// Retrieve a list of the existing multiplexes.
    @Sendable
    @inlinable
    public func listMultiplexes(_ input: ListMultiplexesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMultiplexesResponse {
        try await self.client.execute(
            operation: "ListMultiplexes", 
            path: "/prod/multiplexes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a list of the existing multiplexes.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return.
    ///   - nextToken: The token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMultiplexes(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMultiplexesResponse {
        let input = ListMultiplexesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listMultiplexes(input, logger: logger)
    }

    /// Retrieve the list of Networks.
    @Sendable
    @inlinable
    public func listNetworks(_ input: ListNetworksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListNetworksResponse {
        try await self.client.execute(
            operation: "ListNetworks", 
            path: "/prod/networks", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the list of Networks.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return.
    ///   - nextToken: The token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listNetworks(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListNetworksResponse {
        let input = ListNetworksRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listNetworks(input, logger: logger)
    }

    /// Retrieve the list of Nodes.
    @Sendable
    @inlinable
    public func listNodes(_ input: ListNodesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListNodesResponse {
        try await self.client.execute(
            operation: "ListNodes", 
            path: "/prod/clusters/{ClusterId}/nodes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the list of Nodes.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - maxResults: The maximum number of items to return.
    ///   - nextToken: The token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listNodes(
        clusterId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListNodesResponse {
        let input = ListNodesRequest(
            clusterId: clusterId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listNodes(input, logger: logger)
    }

    /// List offerings available for purchase.
    @Sendable
    @inlinable
    public func listOfferings(_ input: ListOfferingsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListOfferingsResponse {
        try await self.client.execute(
            operation: "ListOfferings", 
            path: "/prod/offerings", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List offerings available for purchase.
    ///
    /// Parameters:
    ///   - channelClass: Filter by channel class, 'STANDARD' or 'SINGLE_PIPELINE'
    ///   - channelConfiguration: Filter to offerings that match the configuration of an existing channel, e.g. '2345678' (a channel ID)
    ///   - codec: Filter by codec, 'AVC', 'HEVC', 'MPEG2', 'AUDIO', 'LINK', or 'AV1'
    ///   - duration: Filter by offering duration, e.g. '12'
    ///   - maximumBitrate: Filter by bitrate, 'MAX_10_MBPS', 'MAX_20_MBPS', or 'MAX_50_MBPS'
    ///   - maximumFramerate: Filter by framerate, 'MAX_30_FPS' or 'MAX_60_FPS'
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - resolution: Filter by resolution, 'SD', 'HD', 'FHD', or 'UHD'
    ///   - resourceType: Filter by resource type, 'INPUT', 'OUTPUT', 'MULTIPLEX', or 'CHANNEL'
    ///   - specialFeature: Filter by special feature, 'ADVANCED_AUDIO' or 'AUDIO_NORMALIZATION'
    ///   - videoQuality: Filter by video quality, 'STANDARD', 'ENHANCED', or 'PREMIUM'
    ///   - logger: Logger use during operation
    @inlinable
    public func listOfferings(
        channelClass: String? = nil,
        channelConfiguration: String? = nil,
        codec: String? = nil,
        duration: String? = nil,
        maximumBitrate: String? = nil,
        maximumFramerate: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resolution: String? = nil,
        resourceType: String? = nil,
        specialFeature: String? = nil,
        videoQuality: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListOfferingsResponse {
        let input = ListOfferingsRequest(
            channelClass: channelClass, 
            channelConfiguration: channelConfiguration, 
            codec: codec, 
            duration: duration, 
            maximumBitrate: maximumBitrate, 
            maximumFramerate: maximumFramerate, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            resolution: resolution, 
            resourceType: resourceType, 
            specialFeature: specialFeature, 
            videoQuality: videoQuality
        )
        return try await self.listOfferings(input, logger: logger)
    }

    /// List purchased reservations.
    @Sendable
    @inlinable
    public func listReservations(_ input: ListReservationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReservationsResponse {
        try await self.client.execute(
            operation: "ListReservations", 
            path: "/prod/reservations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List purchased reservations.
    ///
    /// Parameters:
    ///   - channelClass: Filter by channel class, 'STANDARD' or 'SINGLE_PIPELINE'
    ///   - codec: Filter by codec, 'AVC', 'HEVC', 'MPEG2', 'AUDIO', 'LINK', or 'AV1'
    ///   - maximumBitrate: Filter by bitrate, 'MAX_10_MBPS', 'MAX_20_MBPS', or 'MAX_50_MBPS'
    ///   - maximumFramerate: Filter by framerate, 'MAX_30_FPS' or 'MAX_60_FPS'
    ///   - maxResults: 
    ///   - nextToken: 
    ///   - resolution: Filter by resolution, 'SD', 'HD', 'FHD', or 'UHD'
    ///   - resourceType: Filter by resource type, 'INPUT', 'OUTPUT', 'MULTIPLEX', or 'CHANNEL'
    ///   - specialFeature: Filter by special feature, 'ADVANCED_AUDIO' or 'AUDIO_NORMALIZATION'
    ///   - videoQuality: Filter by video quality, 'STANDARD', 'ENHANCED', or 'PREMIUM'
    ///   - logger: Logger use during operation
    @inlinable
    public func listReservations(
        channelClass: String? = nil,
        codec: String? = nil,
        maximumBitrate: String? = nil,
        maximumFramerate: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resolution: String? = nil,
        resourceType: String? = nil,
        specialFeature: String? = nil,
        videoQuality: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReservationsResponse {
        let input = ListReservationsRequest(
            channelClass: channelClass, 
            codec: codec, 
            maximumBitrate: maximumBitrate, 
            maximumFramerate: maximumFramerate, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            resolution: resolution, 
            resourceType: resourceType, 
            specialFeature: specialFeature, 
            videoQuality: videoQuality
        )
        return try await self.listReservations(input, logger: logger)
    }

    /// List all the SdiSources in the AWS account.
    @Sendable
    @inlinable
    public func listSdiSources(_ input: ListSdiSourcesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSdiSourcesResponse {
        try await self.client.execute(
            operation: "ListSdiSources", 
            path: "/prod/sdiSources", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all the SdiSources in the AWS account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return.
    ///   - nextToken: The token to retrieve the next page of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSdiSources(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSdiSourcesResponse {
        let input = ListSdiSourcesRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listSdiSources(input, logger: logger)
    }

    /// Lists signal maps.
    @Sendable
    @inlinable
    public func listSignalMaps(_ input: ListSignalMapsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSignalMapsResponse {
        try await self.client.execute(
            operation: "ListSignalMaps", 
            path: "/prod/signal-maps", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists signal maps.
    ///
    /// Parameters:
    ///   - cloudWatchAlarmTemplateGroupIdentifier: A cloudwatch alarm template group's identifier. Can be either be its id or current name.
    ///   - eventBridgeRuleTemplateGroupIdentifier: An eventbridge rule template group's identifier. Can be either be its id or current name.
    ///   - maxResults: 
    ///   - nextToken: A token used to retrieve the next set of results in paginated list responses.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSignalMaps(
        cloudWatchAlarmTemplateGroupIdentifier: String? = nil,
        eventBridgeRuleTemplateGroupIdentifier: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSignalMapsResponse {
        let input = ListSignalMapsRequest(
            cloudWatchAlarmTemplateGroupIdentifier: cloudWatchAlarmTemplateGroupIdentifier, 
            eventBridgeRuleTemplateGroupIdentifier: eventBridgeRuleTemplateGroupIdentifier, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listSignalMaps(input, logger: logger)
    }

    /// Produces list of tags that have been created for a resource
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/prod/tags/{ResourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Produces list of tags that have been created for a resource
    ///
    /// Parameters:
    ///   - resourceArn: 
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Retrieves an array of all the encoder engine versions that are available in this AWS account.
    @Sendable
    @inlinable
    public func listVersions(_ input: ListVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVersionsResponse {
        try await self.client.execute(
            operation: "ListVersions", 
            path: "/prod/versions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves an array of all the encoder engine versions that are available in this AWS account.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func listVersions(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVersionsResponse {
        let input = ListVersionsRequest(
        )
        return try await self.listVersions(input, logger: logger)
    }

    /// Purchase an offering and create a reservation.
    @Sendable
    @inlinable
    public func purchaseOffering(_ input: PurchaseOfferingRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PurchaseOfferingResponse {
        try await self.client.execute(
            operation: "PurchaseOffering", 
            path: "/prod/offerings/{OfferingId}/purchase", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Purchase an offering and create a reservation.
    ///
    /// Parameters:
    ///   - count: Number of resources
    ///   - name: Name for the new reservation
    ///   - offeringId: Offering to purchase, e.g. '87654321'
    ///   - renewalSettings: Renewal settings for the reservation
    ///   - requestId: Unique request ID to be specified. This is needed to prevent retries from creating multiple resources.
    ///   - start: Requested reservation start time (UTC) in ISO-8601 format. The specified time must be between the first day of the current month and one year from now. If no value is given, the default is now.
    ///   - tags: A collection of key-value pairs
    ///   - logger: Logger use during operation
    @inlinable
    public func purchaseOffering(
        count: Int? = nil,
        name: String? = nil,
        offeringId: String,
        renewalSettings: RenewalSettings? = nil,
        requestId: String? = PurchaseOfferingRequest.idempotencyToken(),
        start: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PurchaseOfferingResponse {
        let input = PurchaseOfferingRequest(
            count: count, 
            name: name, 
            offeringId: offeringId, 
            renewalSettings: renewalSettings, 
            requestId: requestId, 
            start: start, 
            tags: tags
        )
        return try await self.purchaseOffering(input, logger: logger)
    }

    /// Send a reboot command to the specified input device. The device will begin rebooting within a few seconds of sending the command. When the reboot is complete, the devices connection status will change to connected.
    @Sendable
    @inlinable
    public func rebootInputDevice(_ input: RebootInputDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RebootInputDeviceResponse {
        try await self.client.execute(
            operation: "RebootInputDevice", 
            path: "/prod/inputDevices/{InputDeviceId}/reboot", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Send a reboot command to the specified input device. The device will begin rebooting within a few seconds of sending the command. When the reboot is complete, the devices connection status will change to connected.
    ///
    /// Parameters:
    ///   - force: Force a reboot of an input device. If the device is streaming, it will stop streaming and begin rebooting within a few seconds of sending the command. If the device was streaming prior to the reboot, the device will resume streaming when the reboot completes.
    ///   - inputDeviceId: The unique ID of the input device to reboot. For example, hd-123456789abcdef.
    ///   - logger: Logger use during operation
    @inlinable
    public func rebootInputDevice(
        force: RebootInputDeviceForce? = nil,
        inputDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RebootInputDeviceResponse {
        let input = RebootInputDeviceRequest(
            force: force, 
            inputDeviceId: inputDeviceId
        )
        return try await self.rebootInputDevice(input, logger: logger)
    }

    /// Reject the transfer of the specified input device to your AWS account.
    @Sendable
    @inlinable
    public func rejectInputDeviceTransfer(_ input: RejectInputDeviceTransferRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RejectInputDeviceTransferResponse {
        try await self.client.execute(
            operation: "RejectInputDeviceTransfer", 
            path: "/prod/inputDevices/{InputDeviceId}/reject", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Reject the transfer of the specified input device to your AWS account.
    ///
    /// Parameters:
    ///   - inputDeviceId: The unique ID of the input device to reject. For example, hd-123456789abcdef.
    ///   - logger: Logger use during operation
    @inlinable
    public func rejectInputDeviceTransfer(
        inputDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RejectInputDeviceTransferResponse {
        let input = RejectInputDeviceTransferRequest(
            inputDeviceId: inputDeviceId
        )
        return try await self.rejectInputDeviceTransfer(input, logger: logger)
    }

    /// Restart pipelines in one channel that is currently running.
    @Sendable
    @inlinable
    public func restartChannelPipelines(_ input: RestartChannelPipelinesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RestartChannelPipelinesResponse {
        try await self.client.execute(
            operation: "RestartChannelPipelines", 
            path: "/prod/channels/{ChannelId}/restartChannelPipelines", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Restart pipelines in one channel that is currently running.
    ///
    /// Parameters:
    ///   - channelId: ID of channel
    ///   - pipelineIds: An array of pipelines to restart in this channel. Format PIPELINE_0 or PIPELINE_1.
    ///   - logger: Logger use during operation
    @inlinable
    public func restartChannelPipelines(
        channelId: String,
        pipelineIds: [ChannelPipelineIdToRestart]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RestartChannelPipelinesResponse {
        let input = RestartChannelPipelinesRequest(
            channelId: channelId, 
            pipelineIds: pipelineIds
        )
        return try await self.restartChannelPipelines(input, logger: logger)
    }

    /// Starts an existing channel
    @Sendable
    @inlinable
    public func startChannel(_ input: StartChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartChannelResponse {
        try await self.client.execute(
            operation: "StartChannel", 
            path: "/prod/channels/{ChannelId}/start", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts an existing channel
    ///
    /// Parameters:
    ///   - channelId: A request to start a channel
    ///   - logger: Logger use during operation
    @inlinable
    public func startChannel(
        channelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartChannelResponse {
        let input = StartChannelRequest(
            channelId: channelId
        )
        return try await self.startChannel(input, logger: logger)
    }

    /// Initiates a deployment to delete the monitor of the specified signal map.
    @Sendable
    @inlinable
    public func startDeleteMonitorDeployment(_ input: StartDeleteMonitorDeploymentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartDeleteMonitorDeploymentResponse {
        try await self.client.execute(
            operation: "StartDeleteMonitorDeployment", 
            path: "/prod/signal-maps/{Identifier}/monitor-deployment", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initiates a deployment to delete the monitor of the specified signal map.
    ///
    /// Parameters:
    ///   - identifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func startDeleteMonitorDeployment(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartDeleteMonitorDeploymentResponse {
        let input = StartDeleteMonitorDeploymentRequest(
            identifier: identifier
        )
        return try await self.startDeleteMonitorDeployment(input, logger: logger)
    }

    /// Start an input device that is attached to a MediaConnect flow. (There is no need to start a device that is attached to a MediaLive input; MediaLive starts the device when the channel starts.)
    @Sendable
    @inlinable
    public func startInputDevice(_ input: StartInputDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartInputDeviceResponse {
        try await self.client.execute(
            operation: "StartInputDevice", 
            path: "/prod/inputDevices/{InputDeviceId}/start", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Start an input device that is attached to a MediaConnect flow. (There is no need to start a device that is attached to a MediaLive input; MediaLive starts the device when the channel starts.)
    ///
    /// Parameters:
    ///   - inputDeviceId: The unique ID of the input device to start. For example, hd-123456789abcdef.
    ///   - logger: Logger use during operation
    @inlinable
    public func startInputDevice(
        inputDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartInputDeviceResponse {
        let input = StartInputDeviceRequest(
            inputDeviceId: inputDeviceId
        )
        return try await self.startInputDevice(input, logger: logger)
    }

    /// Start a maintenance window for the specified input device. Starting a maintenance window will give the device up to two hours to install software. If the device was streaming prior to the maintenance, it will resume streaming when the software is fully installed. Devices automatically install updates while they are powered on and their MediaLive channels are stopped. A maintenance window allows you to update a device without having to stop MediaLive channels that use the device. The device must remain powered on and connected to the internet for the duration of the maintenance.
    @Sendable
    @inlinable
    public func startInputDeviceMaintenanceWindow(_ input: StartInputDeviceMaintenanceWindowRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartInputDeviceMaintenanceWindowResponse {
        try await self.client.execute(
            operation: "StartInputDeviceMaintenanceWindow", 
            path: "/prod/inputDevices/{InputDeviceId}/startInputDeviceMaintenanceWindow", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Start a maintenance window for the specified input device. Starting a maintenance window will give the device up to two hours to install software. If the device was streaming prior to the maintenance, it will resume streaming when the software is fully installed. Devices automatically install updates while they are powered on and their MediaLive channels are stopped. A maintenance window allows you to update a device without having to stop MediaLive channels that use the device. The device must remain powered on and connected to the internet for the duration of the maintenance.
    ///
    /// Parameters:
    ///   - inputDeviceId: The unique ID of the input device to start a maintenance window for. For example, hd-123456789abcdef.
    ///   - logger: Logger use during operation
    @inlinable
    public func startInputDeviceMaintenanceWindow(
        inputDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartInputDeviceMaintenanceWindowResponse {
        let input = StartInputDeviceMaintenanceWindowRequest(
            inputDeviceId: inputDeviceId
        )
        return try await self.startInputDeviceMaintenanceWindow(input, logger: logger)
    }

    /// Initiates a deployment to deploy the latest monitor of the specified signal map.
    @Sendable
    @inlinable
    public func startMonitorDeployment(_ input: StartMonitorDeploymentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartMonitorDeploymentResponse {
        try await self.client.execute(
            operation: "StartMonitorDeployment", 
            path: "/prod/signal-maps/{Identifier}/monitor-deployment", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initiates a deployment to deploy the latest monitor of the specified signal map.
    ///
    /// Parameters:
    ///   - dryRun: 
    ///   - identifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func startMonitorDeployment(
        dryRun: Bool? = nil,
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartMonitorDeploymentResponse {
        let input = StartMonitorDeploymentRequest(
            dryRun: dryRun, 
            identifier: identifier
        )
        return try await self.startMonitorDeployment(input, logger: logger)
    }

    /// Start (run) the multiplex. Starting the multiplex does not start the channels. You must explicitly start each channel.
    @Sendable
    @inlinable
    public func startMultiplex(_ input: StartMultiplexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartMultiplexResponse {
        try await self.client.execute(
            operation: "StartMultiplex", 
            path: "/prod/multiplexes/{MultiplexId}/start", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Start (run) the multiplex. Starting the multiplex does not start the channels. You must explicitly start each channel.
    ///
    /// Parameters:
    ///   - multiplexId: The ID of the multiplex.
    ///   - logger: Logger use during operation
    @inlinable
    public func startMultiplex(
        multiplexId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartMultiplexResponse {
        let input = StartMultiplexRequest(
            multiplexId: multiplexId
        )
        return try await self.startMultiplex(input, logger: logger)
    }

    /// Initiates an update for the specified signal map. Will discover a new signal map if a changed discoveryEntryPointArn is provided.
    @Sendable
    @inlinable
    public func startUpdateSignalMap(_ input: StartUpdateSignalMapRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartUpdateSignalMapResponse {
        try await self.client.execute(
            operation: "StartUpdateSignalMap", 
            path: "/prod/signal-maps/{Identifier}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Initiates an update for the specified signal map. Will discover a new signal map if a changed discoveryEntryPointArn is provided.
    ///
    /// Parameters:
    ///   - cloudWatchAlarmTemplateGroupIdentifiers: 
    ///   - description: A resource's optional description.
    ///   - discoveryEntryPointArn: A top-level supported AWS resource ARN to discovery a signal map from.
    ///   - eventBridgeRuleTemplateGroupIdentifiers: 
    ///   - forceRediscovery: If true, will force a rediscovery of a signal map if an unchanged discoveryEntryPointArn is provided.
    ///   - identifier: A signal map's identifier. Can be either be its id or current name.
    ///   - name: A resource's name. Names must be unique within the scope of a resource type in a specific region.
    ///   - logger: Logger use during operation
    @inlinable
    public func startUpdateSignalMap(
        cloudWatchAlarmTemplateGroupIdentifiers: [String]? = nil,
        description: String? = nil,
        discoveryEntryPointArn: String? = nil,
        eventBridgeRuleTemplateGroupIdentifiers: [String]? = nil,
        forceRediscovery: Bool? = nil,
        identifier: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartUpdateSignalMapResponse {
        let input = StartUpdateSignalMapRequest(
            cloudWatchAlarmTemplateGroupIdentifiers: cloudWatchAlarmTemplateGroupIdentifiers, 
            description: description, 
            discoveryEntryPointArn: discoveryEntryPointArn, 
            eventBridgeRuleTemplateGroupIdentifiers: eventBridgeRuleTemplateGroupIdentifiers, 
            forceRediscovery: forceRediscovery, 
            identifier: identifier, 
            name: name
        )
        return try await self.startUpdateSignalMap(input, logger: logger)
    }

    /// Stops a running channel
    @Sendable
    @inlinable
    public func stopChannel(_ input: StopChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopChannelResponse {
        try await self.client.execute(
            operation: "StopChannel", 
            path: "/prod/channels/{ChannelId}/stop", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops a running channel
    ///
    /// Parameters:
    ///   - channelId: A request to stop a running channel
    ///   - logger: Logger use during operation
    @inlinable
    public func stopChannel(
        channelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopChannelResponse {
        let input = StopChannelRequest(
            channelId: channelId
        )
        return try await self.stopChannel(input, logger: logger)
    }

    /// Stop an input device that is attached to a MediaConnect flow. (There is no need to stop a device that is attached to a MediaLive input; MediaLive automatically stops the device when the channel stops.)
    @Sendable
    @inlinable
    public func stopInputDevice(_ input: StopInputDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopInputDeviceResponse {
        try await self.client.execute(
            operation: "StopInputDevice", 
            path: "/prod/inputDevices/{InputDeviceId}/stop", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stop an input device that is attached to a MediaConnect flow. (There is no need to stop a device that is attached to a MediaLive input; MediaLive automatically stops the device when the channel stops.)
    ///
    /// Parameters:
    ///   - inputDeviceId: The unique ID of the input device to stop. For example, hd-123456789abcdef.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopInputDevice(
        inputDeviceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopInputDeviceResponse {
        let input = StopInputDeviceRequest(
            inputDeviceId: inputDeviceId
        )
        return try await self.stopInputDevice(input, logger: logger)
    }

    /// Stops a running multiplex. If the multiplex isn't running, this action has no effect.
    @Sendable
    @inlinable
    public func stopMultiplex(_ input: StopMultiplexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopMultiplexResponse {
        try await self.client.execute(
            operation: "StopMultiplex", 
            path: "/prod/multiplexes/{MultiplexId}/stop", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops a running multiplex. If the multiplex isn't running, this action has no effect.
    ///
    /// Parameters:
    ///   - multiplexId: The ID of the multiplex.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopMultiplex(
        multiplexId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopMultiplexResponse {
        let input = StopMultiplexRequest(
            multiplexId: multiplexId
        )
        return try await self.stopMultiplex(input, logger: logger)
    }

    /// Start an input device transfer to another AWS account. After you make the request, the other account must accept or reject the transfer.
    @Sendable
    @inlinable
    public func transferInputDevice(_ input: TransferInputDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TransferInputDeviceResponse {
        try await self.client.execute(
            operation: "TransferInputDevice", 
            path: "/prod/inputDevices/{InputDeviceId}/transfer", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Start an input device transfer to another AWS account. After you make the request, the other account must accept or reject the transfer.
    ///
    /// Parameters:
    ///   - inputDeviceId: The unique ID of this input device. For example, hd-123456789abcdef.
    ///   - targetCustomerId: The AWS account ID (12 digits) for the recipient of the device transfer.
    ///   - targetRegion: The target AWS region to transfer the device.
    ///   - transferMessage: An optional message for the recipient. Maximum 280 characters.
    ///   - logger: Logger use during operation
    @inlinable
    public func transferInputDevice(
        inputDeviceId: String,
        targetCustomerId: String? = nil,
        targetRegion: String? = nil,
        transferMessage: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TransferInputDeviceResponse {
        let input = TransferInputDeviceRequest(
            inputDeviceId: inputDeviceId, 
            targetCustomerId: targetCustomerId, 
            targetRegion: targetRegion, 
            transferMessage: transferMessage
        )
        return try await self.transferInputDevice(input, logger: logger)
    }

    /// Update account configuration
    @Sendable
    @inlinable
    public func updateAccountConfiguration(_ input: UpdateAccountConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAccountConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateAccountConfiguration", 
            path: "/prod/accountConfiguration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update account configuration
    ///
    /// Parameters:
    ///   - accountConfiguration: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAccountConfiguration(
        accountConfiguration: AccountConfiguration? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAccountConfigurationResponse {
        let input = UpdateAccountConfigurationRequest(
            accountConfiguration: accountConfiguration
        )
        return try await self.updateAccountConfiguration(input, logger: logger)
    }

    /// Updates a channel.
    @Sendable
    @inlinable
    public func updateChannel(_ input: UpdateChannelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateChannelResponse {
        try await self.client.execute(
            operation: "UpdateChannel", 
            path: "/prod/channels/{ChannelId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a channel.
    ///
    /// Parameters:
    ///   - cdiInputSpecification: Specification of CDI inputs for this channel
    ///   - channelEngineVersion: Channel engine version for this channel
    ///   - channelId: channel ID
    ///   - destinations: A list of output destinations for this channel.
    ///   - dryRun: 
    ///   - encoderSettings: The encoder settings for this channel.
    ///   - inputAttachments: 
    ///   - inputSpecification: Specification of network and file inputs for this channel
    ///   - logLevel: The log level to write to CloudWatch Logs.
    ///   - maintenance: Maintenance settings for this channel.
    ///   - name: The name of the channel.
    ///   - roleArn: An optional Amazon Resource Name (ARN) of the role to assume when running the Channel. If you do not specify this on an update call but the role was previously set that role will be removed.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateChannel(
        cdiInputSpecification: CdiInputSpecification? = nil,
        channelEngineVersion: ChannelEngineVersionRequest? = nil,
        channelId: String,
        destinations: [OutputDestination]? = nil,
        dryRun: Bool? = nil,
        encoderSettings: EncoderSettings? = nil,
        inputAttachments: [InputAttachment]? = nil,
        inputSpecification: InputSpecification? = nil,
        logLevel: LogLevel? = nil,
        maintenance: MaintenanceUpdateSettings? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateChannelResponse {
        let input = UpdateChannelRequest(
            cdiInputSpecification: cdiInputSpecification, 
            channelEngineVersion: channelEngineVersion, 
            channelId: channelId, 
            destinations: destinations, 
            dryRun: dryRun, 
            encoderSettings: encoderSettings, 
            inputAttachments: inputAttachments, 
            inputSpecification: inputSpecification, 
            logLevel: logLevel, 
            maintenance: maintenance, 
            name: name, 
            roleArn: roleArn
        )
        return try await self.updateChannel(input, logger: logger)
    }

    /// Changes the class of the channel.
    @Sendable
    @inlinable
    public func updateChannelClass(_ input: UpdateChannelClassRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateChannelClassResponse {
        try await self.client.execute(
            operation: "UpdateChannelClass", 
            path: "/prod/channels/{ChannelId}/channelClass", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Changes the class of the channel.
    ///
    /// Parameters:
    ///   - channelClass: The channel class that you wish to update this channel to use.
    ///   - channelId: Channel Id of the channel whose class should be updated.
    ///   - destinations: A list of output destinations for this channel.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateChannelClass(
        channelClass: ChannelClass? = nil,
        channelId: String,
        destinations: [OutputDestination]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateChannelClassResponse {
        let input = UpdateChannelClassRequest(
            channelClass: channelClass, 
            channelId: channelId, 
            destinations: destinations
        )
        return try await self.updateChannelClass(input, logger: logger)
    }

    /// Change the settings for a ChannelPlacementGroup.
    @Sendable
    @inlinable
    public func updateChannelPlacementGroup(_ input: UpdateChannelPlacementGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateChannelPlacementGroupResponse {
        try await self.client.execute(
            operation: "UpdateChannelPlacementGroup", 
            path: "/prod/clusters/{ClusterId}/channelplacementgroups/{ChannelPlacementGroupId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Change the settings for a ChannelPlacementGroup.
    ///
    /// Parameters:
    ///   - channelPlacementGroupId: The ID of the channel placement group.
    ///   - clusterId: The ID of the cluster.
    ///   - name: Include this parameter only if you want to change the current name of the ChannelPlacementGroup. Specify a name that is unique in the Cluster. You can't change the name. Names are case-sensitive.
    ///   - nodes: Include this parameter only if you want to change the list of Nodes that are associated with the ChannelPlacementGroup.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateChannelPlacementGroup(
        channelPlacementGroupId: String,
        clusterId: String,
        name: String? = nil,
        nodes: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateChannelPlacementGroupResponse {
        let input = UpdateChannelPlacementGroupRequest(
            channelPlacementGroupId: channelPlacementGroupId, 
            clusterId: clusterId, 
            name: name, 
            nodes: nodes
        )
        return try await self.updateChannelPlacementGroup(input, logger: logger)
    }

    /// Updates the specified cloudwatch alarm template.
    @Sendable
    @inlinable
    public func updateCloudWatchAlarmTemplate(_ input: UpdateCloudWatchAlarmTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCloudWatchAlarmTemplateResponse {
        try await self.client.execute(
            operation: "UpdateCloudWatchAlarmTemplate", 
            path: "/prod/cloudwatch-alarm-templates/{Identifier}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified cloudwatch alarm template.
    ///
    /// Parameters:
    ///   - comparisonOperator: 
    ///   - datapointsToAlarm: The number of datapoints within the evaluation period that must be breaching to trigger the alarm.
    ///   - description: A resource's optional description.
    ///   - evaluationPeriods: The number of periods over which data is compared to the specified threshold.
    ///   - groupIdentifier: A cloudwatch alarm template group's identifier. Can be either be its id or current name.
    ///   - identifier: A cloudwatch alarm template's identifier. Can be either be its id or current name.
    ///   - metricName: The name of the metric associated with the alarm. Must be compatible with targetResourceType.
    ///   - name: A resource's name. Names must be unique within the scope of a resource type in a specific region.
    ///   - period: The period, in seconds, over which the specified statistic is applied.
    ///   - statistic: 
    ///   - targetResourceType: 
    ///   - threshold: The threshold value to compare with the specified statistic.
    ///   - treatMissingData: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCloudWatchAlarmTemplate(
        comparisonOperator: CloudWatchAlarmTemplateComparisonOperator? = nil,
        datapointsToAlarm: Int? = nil,
        description: String? = nil,
        evaluationPeriods: Int? = nil,
        groupIdentifier: String? = nil,
        identifier: String,
        metricName: String? = nil,
        name: String? = nil,
        period: Int? = nil,
        statistic: CloudWatchAlarmTemplateStatistic? = nil,
        targetResourceType: CloudWatchAlarmTemplateTargetResourceType? = nil,
        threshold: Double? = nil,
        treatMissingData: CloudWatchAlarmTemplateTreatMissingData? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCloudWatchAlarmTemplateResponse {
        let input = UpdateCloudWatchAlarmTemplateRequest(
            comparisonOperator: comparisonOperator, 
            datapointsToAlarm: datapointsToAlarm, 
            description: description, 
            evaluationPeriods: evaluationPeriods, 
            groupIdentifier: groupIdentifier, 
            identifier: identifier, 
            metricName: metricName, 
            name: name, 
            period: period, 
            statistic: statistic, 
            targetResourceType: targetResourceType, 
            threshold: threshold, 
            treatMissingData: treatMissingData
        )
        return try await self.updateCloudWatchAlarmTemplate(input, logger: logger)
    }

    /// Updates the specified cloudwatch alarm template group.
    @Sendable
    @inlinable
    public func updateCloudWatchAlarmTemplateGroup(_ input: UpdateCloudWatchAlarmTemplateGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCloudWatchAlarmTemplateGroupResponse {
        try await self.client.execute(
            operation: "UpdateCloudWatchAlarmTemplateGroup", 
            path: "/prod/cloudwatch-alarm-template-groups/{Identifier}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified cloudwatch alarm template group.
    ///
    /// Parameters:
    ///   - description: A resource's optional description.
    ///   - identifier: A cloudwatch alarm template group's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCloudWatchAlarmTemplateGroup(
        description: String? = nil,
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCloudWatchAlarmTemplateGroupResponse {
        let input = UpdateCloudWatchAlarmTemplateGroupRequest(
            description: description, 
            identifier: identifier
        )
        return try await self.updateCloudWatchAlarmTemplateGroup(input, logger: logger)
    }

    /// Change the settings for a Cluster.
    @Sendable
    @inlinable
    public func updateCluster(_ input: UpdateClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateClusterResponse {
        try await self.client.execute(
            operation: "UpdateCluster", 
            path: "/prod/clusters/{ClusterId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Change the settings for a Cluster.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - name: Include this parameter only if you want to change the current name of the Cluster. Specify a name that is unique in the AWS account. You can't change the name. Names are case-sensitive.
    ///   - networkSettings: Include this property only if you want to change the current connections between the Nodes in the Cluster and the Networks the Cluster is associated with.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCluster(
        clusterId: String,
        name: String? = nil,
        networkSettings: ClusterNetworkSettingsUpdateRequest? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateClusterResponse {
        let input = UpdateClusterRequest(
            clusterId: clusterId, 
            name: name, 
            networkSettings: networkSettings
        )
        return try await self.updateCluster(input, logger: logger)
    }

    /// Updates the specified eventbridge rule template.
    @Sendable
    @inlinable
    public func updateEventBridgeRuleTemplate(_ input: UpdateEventBridgeRuleTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateEventBridgeRuleTemplateResponse {
        try await self.client.execute(
            operation: "UpdateEventBridgeRuleTemplate", 
            path: "/prod/eventbridge-rule-templates/{Identifier}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified eventbridge rule template.
    ///
    /// Parameters:
    ///   - description: A resource's optional description.
    ///   - eventTargets: 
    ///   - eventType: 
    ///   - groupIdentifier: An eventbridge rule template group's identifier. Can be either be its id or current name.
    ///   - identifier: An eventbridge rule template's identifier. Can be either be its id or current name.
    ///   - name: A resource's name. Names must be unique within the scope of a resource type in a specific region.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateEventBridgeRuleTemplate(
        description: String? = nil,
        eventTargets: [EventBridgeRuleTemplateTarget]? = nil,
        eventType: EventBridgeRuleTemplateEventType? = nil,
        groupIdentifier: String? = nil,
        identifier: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateEventBridgeRuleTemplateResponse {
        let input = UpdateEventBridgeRuleTemplateRequest(
            description: description, 
            eventTargets: eventTargets, 
            eventType: eventType, 
            groupIdentifier: groupIdentifier, 
            identifier: identifier, 
            name: name
        )
        return try await self.updateEventBridgeRuleTemplate(input, logger: logger)
    }

    /// Updates the specified eventbridge rule template group.
    @Sendable
    @inlinable
    public func updateEventBridgeRuleTemplateGroup(_ input: UpdateEventBridgeRuleTemplateGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateEventBridgeRuleTemplateGroupResponse {
        try await self.client.execute(
            operation: "UpdateEventBridgeRuleTemplateGroup", 
            path: "/prod/eventbridge-rule-template-groups/{Identifier}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified eventbridge rule template group.
    ///
    /// Parameters:
    ///   - description: A resource's optional description.
    ///   - identifier: An eventbridge rule template group's identifier. Can be either be its id or current name.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateEventBridgeRuleTemplateGroup(
        description: String? = nil,
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateEventBridgeRuleTemplateGroupResponse {
        let input = UpdateEventBridgeRuleTemplateGroupRequest(
            description: description, 
            identifier: identifier
        )
        return try await self.updateEventBridgeRuleTemplateGroup(input, logger: logger)
    }

    /// Updates an input.
    @Sendable
    @inlinable
    public func updateInput(_ input: UpdateInputRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateInputResponse {
        try await self.client.execute(
            operation: "UpdateInput", 
            path: "/prod/inputs/{InputId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an input.
    ///
    /// Parameters:
    ///   - destinations: Destination settings for PUSH type inputs.
    ///   - inputDevices: Settings for the devices.
    ///   - inputId: Unique ID of the input.
    ///   - inputSecurityGroups: A list of security groups referenced by IDs to attach to the input.
    ///   - mediaConnectFlows: A list of the MediaConnect Flow ARNs that you want to use as the source of the input. You can specify as few as one
    ///   - multicastSettings: Multicast Input settings.
    ///   - name: Name of the input.
    ///   - roleArn: The Amazon Resource Name (ARN) of the role this input assumes during and after creation.
    ///   - sdiSources: 
    ///   - smpte2110ReceiverGroupSettings: Include this parameter if the input is a SMPTE 2110 input, to identify the stream sources for this input.
    ///   - sources: The source URLs for a PULL-type input. Every PULL type input needs
    ///   - srtSettings: The settings associated with an SRT input.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateInput(
        destinations: [InputDestinationRequest]? = nil,
        inputDevices: [InputDeviceRequest]? = nil,
        inputId: String,
        inputSecurityGroups: [String]? = nil,
        mediaConnectFlows: [MediaConnectFlowRequest]? = nil,
        multicastSettings: MulticastSettingsUpdateRequest? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        sdiSources: [String]? = nil,
        smpte2110ReceiverGroupSettings: Smpte2110ReceiverGroupSettings? = nil,
        sources: [InputSourceRequest]? = nil,
        srtSettings: SrtSettingsRequest? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateInputResponse {
        let input = UpdateInputRequest(
            destinations: destinations, 
            inputDevices: inputDevices, 
            inputId: inputId, 
            inputSecurityGroups: inputSecurityGroups, 
            mediaConnectFlows: mediaConnectFlows, 
            multicastSettings: multicastSettings, 
            name: name, 
            roleArn: roleArn, 
            sdiSources: sdiSources, 
            smpte2110ReceiverGroupSettings: smpte2110ReceiverGroupSettings, 
            sources: sources, 
            srtSettings: srtSettings
        )
        return try await self.updateInput(input, logger: logger)
    }

    /// Updates the parameters for the input device.
    @Sendable
    @inlinable
    public func updateInputDevice(_ input: UpdateInputDeviceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateInputDeviceResponse {
        try await self.client.execute(
            operation: "UpdateInputDevice", 
            path: "/prod/inputDevices/{InputDeviceId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the parameters for the input device.
    ///
    /// Parameters:
    ///   - availabilityZone: The Availability Zone you want associated with this input device.
    ///   - hdDeviceSettings: The settings that you want to apply to the HD input device.
    ///   - inputDeviceId: The unique ID of the input device. For example, hd-123456789abcdef.
    ///   - name: The name that you assigned to this input device (not the unique ID).
    ///   - uhdDeviceSettings: The settings that you want to apply to the UHD input device.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateInputDevice(
        availabilityZone: String? = nil,
        hdDeviceSettings: InputDeviceConfigurableSettings? = nil,
        inputDeviceId: String,
        name: String? = nil,
        uhdDeviceSettings: InputDeviceConfigurableSettings? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateInputDeviceResponse {
        let input = UpdateInputDeviceRequest(
            availabilityZone: availabilityZone, 
            hdDeviceSettings: hdDeviceSettings, 
            inputDeviceId: inputDeviceId, 
            name: name, 
            uhdDeviceSettings: uhdDeviceSettings
        )
        return try await self.updateInputDevice(input, logger: logger)
    }

    /// Update an Input Security Group's Whilelists.
    @Sendable
    @inlinable
    public func updateInputSecurityGroup(_ input: UpdateInputSecurityGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateInputSecurityGroupResponse {
        try await self.client.execute(
            operation: "UpdateInputSecurityGroup", 
            path: "/prod/inputSecurityGroups/{InputSecurityGroupId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update an Input Security Group's Whilelists.
    ///
    /// Parameters:
    ///   - inputSecurityGroupId: The id of the Input Security Group to update.
    ///   - whitelistRules: List of IPv4 CIDR addresses to whitelist
    ///   - logger: Logger use during operation
    @inlinable
    public func updateInputSecurityGroup(
        inputSecurityGroupId: String,
        whitelistRules: [InputWhitelistRuleCidr]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateInputSecurityGroupResponse {
        let input = UpdateInputSecurityGroupRequest(
            inputSecurityGroupId: inputSecurityGroupId, 
            whitelistRules: whitelistRules
        )
        return try await self.updateInputSecurityGroup(input, logger: logger)
    }

    /// Updates a multiplex.
    @Sendable
    @inlinable
    public func updateMultiplex(_ input: UpdateMultiplexRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateMultiplexResponse {
        try await self.client.execute(
            operation: "UpdateMultiplex", 
            path: "/prod/multiplexes/{MultiplexId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a multiplex.
    ///
    /// Parameters:
    ///   - multiplexId: ID of the multiplex to update.
    ///   - multiplexSettings: The new settings for a multiplex.
    ///   - name: Name of the multiplex.
    ///   - packetIdentifiersMapping: 
    ///   - logger: Logger use during operation
    @inlinable
    public func updateMultiplex(
        multiplexId: String,
        multiplexSettings: MultiplexSettings? = nil,
        name: String? = nil,
        packetIdentifiersMapping: [String: MultiplexProgramPacketIdentifiersMap]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateMultiplexResponse {
        let input = UpdateMultiplexRequest(
            multiplexId: multiplexId, 
            multiplexSettings: multiplexSettings, 
            name: name, 
            packetIdentifiersMapping: packetIdentifiersMapping
        )
        return try await self.updateMultiplex(input, logger: logger)
    }

    /// Update a program in a multiplex.
    @Sendable
    @inlinable
    public func updateMultiplexProgram(_ input: UpdateMultiplexProgramRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateMultiplexProgramResponse {
        try await self.client.execute(
            operation: "UpdateMultiplexProgram", 
            path: "/prod/multiplexes/{MultiplexId}/programs/{ProgramName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a program in a multiplex.
    ///
    /// Parameters:
    ///   - multiplexId: The ID of the multiplex of the program to update.
    ///   - multiplexProgramSettings: The new settings for a multiplex program.
    ///   - programName: The name of the program to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateMultiplexProgram(
        multiplexId: String,
        multiplexProgramSettings: MultiplexProgramSettings? = nil,
        programName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateMultiplexProgramResponse {
        let input = UpdateMultiplexProgramRequest(
            multiplexId: multiplexId, 
            multiplexProgramSettings: multiplexProgramSettings, 
            programName: programName
        )
        return try await self.updateMultiplexProgram(input, logger: logger)
    }

    /// Change the settings for a Network.
    @Sendable
    @inlinable
    public func updateNetwork(_ input: UpdateNetworkRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateNetworkResponse {
        try await self.client.execute(
            operation: "UpdateNetwork", 
            path: "/prod/networks/{NetworkId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Change the settings for a Network.
    ///
    /// Parameters:
    ///   - ipPools: Include this parameter only if you want to change the pool of IP addresses in the network. An array of IpPoolCreateRequests that identify a collection of IP addresses in this network that you want to reserve for use in MediaLive Anywhere. MediaLive Anywhere uses these IP addresses for Push inputs (in both Bridge and NAT networks) and for output destinations (only in Bridge networks). Each IpPoolUpdateRequest specifies one CIDR block.
    ///   - name: Include this parameter only if you want to change the name of the Network. Specify a name that is unique in the AWS account. Names are case-sensitive.
    ///   - networkId: The ID of the network
    ///   - routes: Include this parameter only if you want to change or add routes in the Network. An array of Routes that MediaLive Anywhere needs to know about in order to route encoding traffic.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateNetwork(
        ipPools: [IpPoolUpdateRequest]? = nil,
        name: String? = nil,
        networkId: String,
        routes: [RouteUpdateRequest]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateNetworkResponse {
        let input = UpdateNetworkRequest(
            ipPools: ipPools, 
            name: name, 
            networkId: networkId, 
            routes: routes
        )
        return try await self.updateNetwork(input, logger: logger)
    }

    /// Change the settings for a Node.
    @Sendable
    @inlinable
    public func updateNode(_ input: UpdateNodeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateNodeResponse {
        try await self.client.execute(
            operation: "UpdateNode", 
            path: "/prod/clusters/{ClusterId}/nodes/{NodeId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Change the settings for a Node.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - name: Include this parameter only if you want to change the current name of the Node. Specify a name that is unique in the Cluster. You can't change the name. Names are case-sensitive.
    ///   - nodeId: The ID of the node.
    ///   - role: The initial role of the Node in the Cluster. ACTIVE means the Node is available for encoding. BACKUP means the Node is a redundant Node and might get used if an ACTIVE Node fails.
    ///   - sdiSourceMappings: The mappings of a SDI capture card port to a logical SDI data stream
    ///   - logger: Logger use during operation
    @inlinable
    public func updateNode(
        clusterId: String,
        name: String? = nil,
        nodeId: String,
        role: NodeRole? = nil,
        sdiSourceMappings: [SdiSourceMappingUpdateRequest]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateNodeResponse {
        let input = UpdateNodeRequest(
            clusterId: clusterId, 
            name: name, 
            nodeId: nodeId, 
            role: role, 
            sdiSourceMappings: sdiSourceMappings
        )
        return try await self.updateNode(input, logger: logger)
    }

    /// Update the state of a node.
    @Sendable
    @inlinable
    public func updateNodeState(_ input: UpdateNodeStateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateNodeStateResponse {
        try await self.client.execute(
            operation: "UpdateNodeState", 
            path: "/prod/clusters/{ClusterId}/nodes/{NodeId}/state", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update the state of a node.
    ///
    /// Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - nodeId: The ID of the node.
    ///   - state: The state to apply to the Node. Set to ACTIVE (COMMISSIONED) to indicate that the Node is deployable. MediaLive Anywhere will consider this node it needs a Node to run a Channel on, or when it needs a Node to promote from a backup node to an active node. Set to DRAINING to isolate the Node so that MediaLive Anywhere won't use it.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateNodeState(
        clusterId: String,
        nodeId: String,
        state: UpdateNodeStateShape? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateNodeStateResponse {
        let input = UpdateNodeStateRequest(
            clusterId: clusterId, 
            nodeId: nodeId, 
            state: state
        )
        return try await self.updateNodeState(input, logger: logger)
    }

    /// Update reservation.
    @Sendable
    @inlinable
    public func updateReservation(_ input: UpdateReservationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateReservationResponse {
        try await self.client.execute(
            operation: "UpdateReservation", 
            path: "/prod/reservations/{ReservationId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update reservation.
    ///
    /// Parameters:
    ///   - name: Name of the reservation
    ///   - renewalSettings: Renewal settings for the reservation
    ///   - reservationId: Unique reservation ID, e.g. '1234567'
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReservation(
        name: String? = nil,
        renewalSettings: RenewalSettings? = nil,
        reservationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateReservationResponse {
        let input = UpdateReservationRequest(
            name: name, 
            renewalSettings: renewalSettings, 
            reservationId: reservationId
        )
        return try await self.updateReservation(input, logger: logger)
    }

    /// Change some of the settings in an SdiSource.
    @Sendable
    @inlinable
    public func updateSdiSource(_ input: UpdateSdiSourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSdiSourceResponse {
        try await self.client.execute(
            operation: "UpdateSdiSource", 
            path: "/prod/sdiSources/{SdiSourceId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Change some of the settings in an SdiSource.
    ///
    /// Parameters:
    ///   - mode: Include this parameter only if you want to change the name of the SdiSource. Specify a name that is unique in the AWS account. We recommend you assign a name that describes the source, for example curling-cameraA. Names are case-sensitive.
    ///   - name: Include this parameter only if you want to change the name of the SdiSource. Specify a name that is unique in the AWS account. We recommend you assign a name that describes the source, for example curling-cameraA. Names are case-sensitive.
    ///   - sdiSourceId: The ID of the SdiSource
    ///   - type: Include this parameter only if you want to change the mode. Specify the type of the SDI source: SINGLE: The source is a single-link source. QUAD: The source is one part of a quad-link source.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSdiSource(
        mode: SdiSourceMode? = nil,
        name: String? = nil,
        sdiSourceId: String,
        type: SdiSourceType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSdiSourceResponse {
        let input = UpdateSdiSourceRequest(
            mode: mode, 
            name: name, 
            sdiSourceId: sdiSourceId, 
            type: type
        )
        return try await self.updateSdiSource(input, logger: logger)
    }
}

extension MediaLive {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: MediaLive, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension MediaLive {
    /// Return PaginatorSequence for operation ``describeSchedule(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSchedulePaginator(
        _ input: DescribeScheduleRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeScheduleRequest, DescribeScheduleResponse> {
        return .init(
            input: input,
            command: self.describeSchedule,
            inputKey: \DescribeScheduleRequest.nextToken,
            outputKey: \DescribeScheduleResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeSchedule(_:logger:)``.
    ///
    /// - Parameters:
    ///   - channelId: Id of the channel whose schedule is being updated.
    ///   - maxResults: 
    ///   - logger: Logger used for logging
    @inlinable
    public func describeSchedulePaginator(
        channelId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeScheduleRequest, DescribeScheduleResponse> {
        let input = DescribeScheduleRequest(
            channelId: channelId, 
            maxResults: maxResults
        )
        return self.describeSchedulePaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listChannelPlacementGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listChannelPlacementGroupsPaginator(
        _ input: ListChannelPlacementGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListChannelPlacementGroupsRequest, ListChannelPlacementGroupsResponse> {
        return .init(
            input: input,
            command: self.listChannelPlacementGroups,
            inputKey: \ListChannelPlacementGroupsRequest.nextToken,
            outputKey: \ListChannelPlacementGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listChannelPlacementGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - maxResults: The maximum number of items to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listChannelPlacementGroupsPaginator(
        clusterId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListChannelPlacementGroupsRequest, ListChannelPlacementGroupsResponse> {
        let input = ListChannelPlacementGroupsRequest(
            clusterId: clusterId, 
            maxResults: maxResults
        )
        return self.listChannelPlacementGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listChannels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listChannelsPaginator(
        _ input: ListChannelsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListChannelsRequest, ListChannelsResponse> {
        return .init(
            input: input,
            command: self.listChannels,
            inputKey: \ListChannelsRequest.nextToken,
            outputKey: \ListChannelsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listChannels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listChannelsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListChannelsRequest, ListChannelsResponse> {
        let input = ListChannelsRequest(
            maxResults: maxResults
        )
        return self.listChannelsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCloudWatchAlarmTemplateGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCloudWatchAlarmTemplateGroupsPaginator(
        _ input: ListCloudWatchAlarmTemplateGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCloudWatchAlarmTemplateGroupsRequest, ListCloudWatchAlarmTemplateGroupsResponse> {
        return .init(
            input: input,
            command: self.listCloudWatchAlarmTemplateGroups,
            inputKey: \ListCloudWatchAlarmTemplateGroupsRequest.nextToken,
            outputKey: \ListCloudWatchAlarmTemplateGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCloudWatchAlarmTemplateGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - scope: Represents the scope of a resource, with options for all scopes, AWS provided resources, or local resources.
    ///   - signalMapIdentifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCloudWatchAlarmTemplateGroupsPaginator(
        maxResults: Int? = nil,
        scope: String? = nil,
        signalMapIdentifier: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCloudWatchAlarmTemplateGroupsRequest, ListCloudWatchAlarmTemplateGroupsResponse> {
        let input = ListCloudWatchAlarmTemplateGroupsRequest(
            maxResults: maxResults, 
            scope: scope, 
            signalMapIdentifier: signalMapIdentifier
        )
        return self.listCloudWatchAlarmTemplateGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCloudWatchAlarmTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCloudWatchAlarmTemplatesPaginator(
        _ input: ListCloudWatchAlarmTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCloudWatchAlarmTemplatesRequest, ListCloudWatchAlarmTemplatesResponse> {
        return .init(
            input: input,
            command: self.listCloudWatchAlarmTemplates,
            inputKey: \ListCloudWatchAlarmTemplatesRequest.nextToken,
            outputKey: \ListCloudWatchAlarmTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCloudWatchAlarmTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - groupIdentifier: A cloudwatch alarm template group's identifier. Can be either be its id or current name.
    ///   - maxResults: 
    ///   - scope: Represents the scope of a resource, with options for all scopes, AWS provided resources, or local resources.
    ///   - signalMapIdentifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCloudWatchAlarmTemplatesPaginator(
        groupIdentifier: String? = nil,
        maxResults: Int? = nil,
        scope: String? = nil,
        signalMapIdentifier: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCloudWatchAlarmTemplatesRequest, ListCloudWatchAlarmTemplatesResponse> {
        let input = ListCloudWatchAlarmTemplatesRequest(
            groupIdentifier: groupIdentifier, 
            maxResults: maxResults, 
            scope: scope, 
            signalMapIdentifier: signalMapIdentifier
        )
        return self.listCloudWatchAlarmTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listClusters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listClustersPaginator(
        _ input: ListClustersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListClustersRequest, ListClustersResponse> {
        return .init(
            input: input,
            command: self.listClusters,
            inputKey: \ListClustersRequest.nextToken,
            outputKey: \ListClustersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listClusters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listClustersPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListClustersRequest, ListClustersResponse> {
        let input = ListClustersRequest(
            maxResults: maxResults
        )
        return self.listClustersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listEventBridgeRuleTemplateGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEventBridgeRuleTemplateGroupsPaginator(
        _ input: ListEventBridgeRuleTemplateGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEventBridgeRuleTemplateGroupsRequest, ListEventBridgeRuleTemplateGroupsResponse> {
        return .init(
            input: input,
            command: self.listEventBridgeRuleTemplateGroups,
            inputKey: \ListEventBridgeRuleTemplateGroupsRequest.nextToken,
            outputKey: \ListEventBridgeRuleTemplateGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEventBridgeRuleTemplateGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - signalMapIdentifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listEventBridgeRuleTemplateGroupsPaginator(
        maxResults: Int? = nil,
        signalMapIdentifier: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEventBridgeRuleTemplateGroupsRequest, ListEventBridgeRuleTemplateGroupsResponse> {
        let input = ListEventBridgeRuleTemplateGroupsRequest(
            maxResults: maxResults, 
            signalMapIdentifier: signalMapIdentifier
        )
        return self.listEventBridgeRuleTemplateGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listEventBridgeRuleTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEventBridgeRuleTemplatesPaginator(
        _ input: ListEventBridgeRuleTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEventBridgeRuleTemplatesRequest, ListEventBridgeRuleTemplatesResponse> {
        return .init(
            input: input,
            command: self.listEventBridgeRuleTemplates,
            inputKey: \ListEventBridgeRuleTemplatesRequest.nextToken,
            outputKey: \ListEventBridgeRuleTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEventBridgeRuleTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - groupIdentifier: An eventbridge rule template group's identifier. Can be either be its id or current name.
    ///   - maxResults: 
    ///   - signalMapIdentifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listEventBridgeRuleTemplatesPaginator(
        groupIdentifier: String? = nil,
        maxResults: Int? = nil,
        signalMapIdentifier: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEventBridgeRuleTemplatesRequest, ListEventBridgeRuleTemplatesResponse> {
        let input = ListEventBridgeRuleTemplatesRequest(
            groupIdentifier: groupIdentifier, 
            maxResults: maxResults, 
            signalMapIdentifier: signalMapIdentifier
        )
        return self.listEventBridgeRuleTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listInputDeviceTransfers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listInputDeviceTransfersPaginator(
        _ input: ListInputDeviceTransfersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListInputDeviceTransfersRequest, ListInputDeviceTransfersResponse> {
        return .init(
            input: input,
            command: self.listInputDeviceTransfers,
            inputKey: \ListInputDeviceTransfersRequest.nextToken,
            outputKey: \ListInputDeviceTransfersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listInputDeviceTransfers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - transferType: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listInputDeviceTransfersPaginator(
        maxResults: Int? = nil,
        transferType: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListInputDeviceTransfersRequest, ListInputDeviceTransfersResponse> {
        let input = ListInputDeviceTransfersRequest(
            maxResults: maxResults, 
            transferType: transferType
        )
        return self.listInputDeviceTransfersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listInputDevices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listInputDevicesPaginator(
        _ input: ListInputDevicesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListInputDevicesRequest, ListInputDevicesResponse> {
        return .init(
            input: input,
            command: self.listInputDevices,
            inputKey: \ListInputDevicesRequest.nextToken,
            outputKey: \ListInputDevicesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listInputDevices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listInputDevicesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListInputDevicesRequest, ListInputDevicesResponse> {
        let input = ListInputDevicesRequest(
            maxResults: maxResults
        )
        return self.listInputDevicesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listInputSecurityGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listInputSecurityGroupsPaginator(
        _ input: ListInputSecurityGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListInputSecurityGroupsRequest, ListInputSecurityGroupsResponse> {
        return .init(
            input: input,
            command: self.listInputSecurityGroups,
            inputKey: \ListInputSecurityGroupsRequest.nextToken,
            outputKey: \ListInputSecurityGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listInputSecurityGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listInputSecurityGroupsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListInputSecurityGroupsRequest, ListInputSecurityGroupsResponse> {
        let input = ListInputSecurityGroupsRequest(
            maxResults: maxResults
        )
        return self.listInputSecurityGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listInputs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listInputsPaginator(
        _ input: ListInputsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListInputsRequest, ListInputsResponse> {
        return .init(
            input: input,
            command: self.listInputs,
            inputKey: \ListInputsRequest.nextToken,
            outputKey: \ListInputsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listInputs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listInputsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListInputsRequest, ListInputsResponse> {
        let input = ListInputsRequest(
            maxResults: maxResults
        )
        return self.listInputsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMultiplexPrograms(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMultiplexProgramsPaginator(
        _ input: ListMultiplexProgramsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMultiplexProgramsRequest, ListMultiplexProgramsResponse> {
        return .init(
            input: input,
            command: self.listMultiplexPrograms,
            inputKey: \ListMultiplexProgramsRequest.nextToken,
            outputKey: \ListMultiplexProgramsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMultiplexPrograms(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return.
    ///   - multiplexId: The ID of the multiplex that the programs belong to.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMultiplexProgramsPaginator(
        maxResults: Int? = nil,
        multiplexId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMultiplexProgramsRequest, ListMultiplexProgramsResponse> {
        let input = ListMultiplexProgramsRequest(
            maxResults: maxResults, 
            multiplexId: multiplexId
        )
        return self.listMultiplexProgramsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMultiplexes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMultiplexesPaginator(
        _ input: ListMultiplexesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMultiplexesRequest, ListMultiplexesResponse> {
        return .init(
            input: input,
            command: self.listMultiplexes,
            inputKey: \ListMultiplexesRequest.nextToken,
            outputKey: \ListMultiplexesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMultiplexes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMultiplexesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMultiplexesRequest, ListMultiplexesResponse> {
        let input = ListMultiplexesRequest(
            maxResults: maxResults
        )
        return self.listMultiplexesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listNetworks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listNetworksPaginator(
        _ input: ListNetworksRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListNetworksRequest, ListNetworksResponse> {
        return .init(
            input: input,
            command: self.listNetworks,
            inputKey: \ListNetworksRequest.nextToken,
            outputKey: \ListNetworksResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listNetworks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listNetworksPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListNetworksRequest, ListNetworksResponse> {
        let input = ListNetworksRequest(
            maxResults: maxResults
        )
        return self.listNetworksPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listNodesPaginator(
        _ input: ListNodesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListNodesRequest, ListNodesResponse> {
        return .init(
            input: input,
            command: self.listNodes,
            inputKey: \ListNodesRequest.nextToken,
            outputKey: \ListNodesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - maxResults: The maximum number of items to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listNodesPaginator(
        clusterId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListNodesRequest, ListNodesResponse> {
        let input = ListNodesRequest(
            clusterId: clusterId, 
            maxResults: maxResults
        )
        return self.listNodesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listOfferings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listOfferingsPaginator(
        _ input: ListOfferingsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListOfferingsRequest, ListOfferingsResponse> {
        return .init(
            input: input,
            command: self.listOfferings,
            inputKey: \ListOfferingsRequest.nextToken,
            outputKey: \ListOfferingsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listOfferings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - channelClass: Filter by channel class, 'STANDARD' or 'SINGLE_PIPELINE'
    ///   - channelConfiguration: Filter to offerings that match the configuration of an existing channel, e.g. '2345678' (a channel ID)
    ///   - codec: Filter by codec, 'AVC', 'HEVC', 'MPEG2', 'AUDIO', 'LINK', or 'AV1'
    ///   - duration: Filter by offering duration, e.g. '12'
    ///   - maximumBitrate: Filter by bitrate, 'MAX_10_MBPS', 'MAX_20_MBPS', or 'MAX_50_MBPS'
    ///   - maximumFramerate: Filter by framerate, 'MAX_30_FPS' or 'MAX_60_FPS'
    ///   - maxResults: 
    ///   - resolution: Filter by resolution, 'SD', 'HD', 'FHD', or 'UHD'
    ///   - resourceType: Filter by resource type, 'INPUT', 'OUTPUT', 'MULTIPLEX', or 'CHANNEL'
    ///   - specialFeature: Filter by special feature, 'ADVANCED_AUDIO' or 'AUDIO_NORMALIZATION'
    ///   - videoQuality: Filter by video quality, 'STANDARD', 'ENHANCED', or 'PREMIUM'
    ///   - logger: Logger used for logging
    @inlinable
    public func listOfferingsPaginator(
        channelClass: String? = nil,
        channelConfiguration: String? = nil,
        codec: String? = nil,
        duration: String? = nil,
        maximumBitrate: String? = nil,
        maximumFramerate: String? = nil,
        maxResults: Int? = nil,
        resolution: String? = nil,
        resourceType: String? = nil,
        specialFeature: String? = nil,
        videoQuality: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListOfferingsRequest, ListOfferingsResponse> {
        let input = ListOfferingsRequest(
            channelClass: channelClass, 
            channelConfiguration: channelConfiguration, 
            codec: codec, 
            duration: duration, 
            maximumBitrate: maximumBitrate, 
            maximumFramerate: maximumFramerate, 
            maxResults: maxResults, 
            resolution: resolution, 
            resourceType: resourceType, 
            specialFeature: specialFeature, 
            videoQuality: videoQuality
        )
        return self.listOfferingsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReservations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReservationsPaginator(
        _ input: ListReservationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReservationsRequest, ListReservationsResponse> {
        return .init(
            input: input,
            command: self.listReservations,
            inputKey: \ListReservationsRequest.nextToken,
            outputKey: \ListReservationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReservations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - channelClass: Filter by channel class, 'STANDARD' or 'SINGLE_PIPELINE'
    ///   - codec: Filter by codec, 'AVC', 'HEVC', 'MPEG2', 'AUDIO', 'LINK', or 'AV1'
    ///   - maximumBitrate: Filter by bitrate, 'MAX_10_MBPS', 'MAX_20_MBPS', or 'MAX_50_MBPS'
    ///   - maximumFramerate: Filter by framerate, 'MAX_30_FPS' or 'MAX_60_FPS'
    ///   - maxResults: 
    ///   - resolution: Filter by resolution, 'SD', 'HD', 'FHD', or 'UHD'
    ///   - resourceType: Filter by resource type, 'INPUT', 'OUTPUT', 'MULTIPLEX', or 'CHANNEL'
    ///   - specialFeature: Filter by special feature, 'ADVANCED_AUDIO' or 'AUDIO_NORMALIZATION'
    ///   - videoQuality: Filter by video quality, 'STANDARD', 'ENHANCED', or 'PREMIUM'
    ///   - logger: Logger used for logging
    @inlinable
    public func listReservationsPaginator(
        channelClass: String? = nil,
        codec: String? = nil,
        maximumBitrate: String? = nil,
        maximumFramerate: String? = nil,
        maxResults: Int? = nil,
        resolution: String? = nil,
        resourceType: String? = nil,
        specialFeature: String? = nil,
        videoQuality: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReservationsRequest, ListReservationsResponse> {
        let input = ListReservationsRequest(
            channelClass: channelClass, 
            codec: codec, 
            maximumBitrate: maximumBitrate, 
            maximumFramerate: maximumFramerate, 
            maxResults: maxResults, 
            resolution: resolution, 
            resourceType: resourceType, 
            specialFeature: specialFeature, 
            videoQuality: videoQuality
        )
        return self.listReservationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSdiSources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSdiSourcesPaginator(
        _ input: ListSdiSourcesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSdiSourcesRequest, ListSdiSourcesResponse> {
        return .init(
            input: input,
            command: self.listSdiSources,
            inputKey: \ListSdiSourcesRequest.nextToken,
            outputKey: \ListSdiSourcesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSdiSources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSdiSourcesPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSdiSourcesRequest, ListSdiSourcesResponse> {
        let input = ListSdiSourcesRequest(
            maxResults: maxResults
        )
        return self.listSdiSourcesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSignalMaps(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSignalMapsPaginator(
        _ input: ListSignalMapsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSignalMapsRequest, ListSignalMapsResponse> {
        return .init(
            input: input,
            command: self.listSignalMaps,
            inputKey: \ListSignalMapsRequest.nextToken,
            outputKey: \ListSignalMapsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSignalMaps(_:logger:)``.
    ///
    /// - Parameters:
    ///   - cloudWatchAlarmTemplateGroupIdentifier: A cloudwatch alarm template group's identifier. Can be either be its id or current name.
    ///   - eventBridgeRuleTemplateGroupIdentifier: An eventbridge rule template group's identifier. Can be either be its id or current name.
    ///   - maxResults: 
    ///   - logger: Logger used for logging
    @inlinable
    public func listSignalMapsPaginator(
        cloudWatchAlarmTemplateGroupIdentifier: String? = nil,
        eventBridgeRuleTemplateGroupIdentifier: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSignalMapsRequest, ListSignalMapsResponse> {
        let input = ListSignalMapsRequest(
            cloudWatchAlarmTemplateGroupIdentifier: cloudWatchAlarmTemplateGroupIdentifier, 
            eventBridgeRuleTemplateGroupIdentifier: eventBridgeRuleTemplateGroupIdentifier, 
            maxResults: maxResults
        )
        return self.listSignalMapsPaginator(input, logger: logger)
    }
}

extension MediaLive.DescribeScheduleRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.DescribeScheduleRequest {
        return .init(
            channelId: self.channelId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListChannelPlacementGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListChannelPlacementGroupsRequest {
        return .init(
            clusterId: self.clusterId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListChannelsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListChannelsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListCloudWatchAlarmTemplateGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListCloudWatchAlarmTemplateGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            scope: self.scope,
            signalMapIdentifier: self.signalMapIdentifier
        )
    }
}

extension MediaLive.ListCloudWatchAlarmTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListCloudWatchAlarmTemplatesRequest {
        return .init(
            groupIdentifier: self.groupIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            scope: self.scope,
            signalMapIdentifier: self.signalMapIdentifier
        )
    }
}

extension MediaLive.ListClustersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListClustersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListEventBridgeRuleTemplateGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListEventBridgeRuleTemplateGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            signalMapIdentifier: self.signalMapIdentifier
        )
    }
}

extension MediaLive.ListEventBridgeRuleTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListEventBridgeRuleTemplatesRequest {
        return .init(
            groupIdentifier: self.groupIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            signalMapIdentifier: self.signalMapIdentifier
        )
    }
}

extension MediaLive.ListInputDeviceTransfersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListInputDeviceTransfersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            transferType: self.transferType
        )
    }
}

extension MediaLive.ListInputDevicesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListInputDevicesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListInputSecurityGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListInputSecurityGroupsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListInputsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListInputsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListMultiplexProgramsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListMultiplexProgramsRequest {
        return .init(
            maxResults: self.maxResults,
            multiplexId: self.multiplexId,
            nextToken: token
        )
    }
}

extension MediaLive.ListMultiplexesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListMultiplexesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListNetworksRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListNetworksRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListNodesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListNodesRequest {
        return .init(
            clusterId: self.clusterId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListOfferingsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListOfferingsRequest {
        return .init(
            channelClass: self.channelClass,
            channelConfiguration: self.channelConfiguration,
            codec: self.codec,
            duration: self.duration,
            maximumBitrate: self.maximumBitrate,
            maximumFramerate: self.maximumFramerate,
            maxResults: self.maxResults,
            nextToken: token,
            resolution: self.resolution,
            resourceType: self.resourceType,
            specialFeature: self.specialFeature,
            videoQuality: self.videoQuality
        )
    }
}

extension MediaLive.ListReservationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListReservationsRequest {
        return .init(
            channelClass: self.channelClass,
            codec: self.codec,
            maximumBitrate: self.maximumBitrate,
            maximumFramerate: self.maximumFramerate,
            maxResults: self.maxResults,
            nextToken: token,
            resolution: self.resolution,
            resourceType: self.resourceType,
            specialFeature: self.specialFeature,
            videoQuality: self.videoQuality
        )
    }
}

extension MediaLive.ListSdiSourcesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListSdiSourcesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaLive.ListSignalMapsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaLive.ListSignalMapsRequest {
        return .init(
            cloudWatchAlarmTemplateGroupIdentifier: self.cloudWatchAlarmTemplateGroupIdentifier,
            eventBridgeRuleTemplateGroupIdentifier: self.eventBridgeRuleTemplateGroupIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension MediaLive {
    /// Waiter for operation ``describeChannel(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelCreated(
        _ input: DescribeChannelRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeChannelRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "IDLE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "CREATING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
                .init(state: .failure, matcher: try! JMESPathMatcher("state", expected: "CREATE_FAILED")),
            ],
            minDelayTime: .seconds(3),
            command: self.describeChannel
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeChannel(_:logger:)``.
    ///
    /// - Parameters:
    ///   - channelId: channel ID
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelCreated(
        channelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeChannelRequest(
            channelId: channelId
        )
        try await self.waitUntilChannelCreated(input, logger: logger)
    }

    /// Waiter for operation ``describeChannel(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelDeleted(
        _ input: DescribeChannelRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeChannelRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "DELETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "DELETING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeChannel
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeChannel(_:logger:)``.
    ///
    /// - Parameters:
    ///   - channelId: channel ID
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelDeleted(
        channelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeChannelRequest(
            channelId: channelId
        )
        try await self.waitUntilChannelDeleted(input, logger: logger)
    }

    /// Waiter for operation ``describeChannelPlacementGroup(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelPlacementGroupAssigned(
        _ input: DescribeChannelPlacementGroupRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeChannelPlacementGroupRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "ASSIGNED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "ASSIGNING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(3),
            command: self.describeChannelPlacementGroup
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeChannelPlacementGroup(_:logger:)``.
    ///
    /// - Parameters:
    ///   - channelPlacementGroupId: The ID of the channel placement group.
    ///   - clusterId: The ID of the cluster.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelPlacementGroupAssigned(
        channelPlacementGroupId: String,
        clusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeChannelPlacementGroupRequest(
            channelPlacementGroupId: channelPlacementGroupId, 
            clusterId: clusterId
        )
        try await self.waitUntilChannelPlacementGroupAssigned(input, logger: logger)
    }

    /// Waiter for operation ``describeChannelPlacementGroup(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelPlacementGroupDeleted(
        _ input: DescribeChannelPlacementGroupRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeChannelPlacementGroupRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "DELETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "DELETING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeChannelPlacementGroup
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeChannelPlacementGroup(_:logger:)``.
    ///
    /// - Parameters:
    ///   - channelPlacementGroupId: The ID of the channel placement group.
    ///   - clusterId: The ID of the cluster.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelPlacementGroupDeleted(
        channelPlacementGroupId: String,
        clusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeChannelPlacementGroupRequest(
            channelPlacementGroupId: channelPlacementGroupId, 
            clusterId: clusterId
        )
        try await self.waitUntilChannelPlacementGroupDeleted(input, logger: logger)
    }

    /// Waiter for operation ``describeChannelPlacementGroup(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelPlacementGroupUnassigned(
        _ input: DescribeChannelPlacementGroupRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeChannelPlacementGroupRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "UNASSIGNED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "UNASSIGNING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeChannelPlacementGroup
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeChannelPlacementGroup(_:logger:)``.
    ///
    /// - Parameters:
    ///   - channelPlacementGroupId: The ID of the channel placement group.
    ///   - clusterId: The ID of the cluster.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelPlacementGroupUnassigned(
        channelPlacementGroupId: String,
        clusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeChannelPlacementGroupRequest(
            channelPlacementGroupId: channelPlacementGroupId, 
            clusterId: clusterId
        )
        try await self.waitUntilChannelPlacementGroupUnassigned(input, logger: logger)
    }

    /// Waiter for operation ``describeChannel(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelRunning(
        _ input: DescribeChannelRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeChannelRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "STARTING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeChannel
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeChannel(_:logger:)``.
    ///
    /// - Parameters:
    ///   - channelId: channel ID
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelRunning(
        channelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeChannelRequest(
            channelId: channelId
        )
        try await self.waitUntilChannelRunning(input, logger: logger)
    }

    /// Waiter for operation ``describeChannel(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelStopped(
        _ input: DescribeChannelRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeChannelRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "IDLE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "STOPPING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeChannel
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeChannel(_:logger:)``.
    ///
    /// - Parameters:
    ///   - channelId: channel ID
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilChannelStopped(
        channelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeChannelRequest(
            channelId: channelId
        )
        try await self.waitUntilChannelStopped(input, logger: logger)
    }

    /// Waiter for operation ``describeCluster(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilClusterCreated(
        _ input: DescribeClusterRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeClusterRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "CREATING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
                .init(state: .failure, matcher: try! JMESPathMatcher("state", expected: "CREATE_FAILED")),
            ],
            minDelayTime: .seconds(3),
            command: self.describeCluster
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeCluster(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterId: The ID of the cluster.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilClusterCreated(
        clusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeClusterRequest(
            clusterId: clusterId
        )
        try await self.waitUntilClusterCreated(input, logger: logger)
    }

    /// Waiter for operation ``describeCluster(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilClusterDeleted(
        _ input: DescribeClusterRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeClusterRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "DELETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "DELETING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeCluster
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeCluster(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterId: The ID of the cluster.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilClusterDeleted(
        clusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeClusterRequest(
            clusterId: clusterId
        )
        try await self.waitUntilClusterDeleted(input, logger: logger)
    }

    /// Waiter for operation ``describeInput(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilInputAttached(
        _ input: DescribeInputRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeInputRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "ATTACHED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "DETACHED")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeInput
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeInput(_:logger:)``.
    ///
    /// - Parameters:
    ///   - inputId: Unique ID of the input
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilInputAttached(
        inputId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeInputRequest(
            inputId: inputId
        )
        try await self.waitUntilInputAttached(input, logger: logger)
    }

    /// Waiter for operation ``describeInput(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilInputDeleted(
        _ input: DescribeInputRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeInputRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "DELETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "DELETING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeInput
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeInput(_:logger:)``.
    ///
    /// - Parameters:
    ///   - inputId: Unique ID of the input
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilInputDeleted(
        inputId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeInputRequest(
            inputId: inputId
        )
        try await self.waitUntilInputDeleted(input, logger: logger)
    }

    /// Waiter for operation ``describeInput(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilInputDetached(
        _ input: DescribeInputRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeInputRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "DETACHED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "ATTACHED")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeInput
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeInput(_:logger:)``.
    ///
    /// - Parameters:
    ///   - inputId: Unique ID of the input
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilInputDetached(
        inputId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeInputRequest(
            inputId: inputId
        )
        try await self.waitUntilInputDetached(input, logger: logger)
    }

    /// Waiter for operation ``describeMultiplex(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilMultiplexCreated(
        _ input: DescribeMultiplexRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeMultiplexRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "IDLE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "CREATING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
                .init(state: .failure, matcher: try! JMESPathMatcher("state", expected: "CREATE_FAILED")),
            ],
            minDelayTime: .seconds(3),
            command: self.describeMultiplex
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeMultiplex(_:logger:)``.
    ///
    /// - Parameters:
    ///   - multiplexId: The ID of the multiplex.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilMultiplexCreated(
        multiplexId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeMultiplexRequest(
            multiplexId: multiplexId
        )
        try await self.waitUntilMultiplexCreated(input, logger: logger)
    }

    /// Waiter for operation ``describeMultiplex(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilMultiplexDeleted(
        _ input: DescribeMultiplexRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeMultiplexRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "DELETED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "DELETING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeMultiplex
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeMultiplex(_:logger:)``.
    ///
    /// - Parameters:
    ///   - multiplexId: The ID of the multiplex.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilMultiplexDeleted(
        multiplexId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeMultiplexRequest(
            multiplexId: multiplexId
        )
        try await self.waitUntilMultiplexDeleted(input, logger: logger)
    }

    /// Waiter for operation ``describeMultiplex(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilMultiplexRunning(
        _ input: DescribeMultiplexRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeMultiplexRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "RUNNING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "STARTING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeMultiplex
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeMultiplex(_:logger:)``.
    ///
    /// - Parameters:
    ///   - multiplexId: The ID of the multiplex.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilMultiplexRunning(
        multiplexId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeMultiplexRequest(
            multiplexId: multiplexId
        )
        try await self.waitUntilMultiplexRunning(input, logger: logger)
    }

    /// Waiter for operation ``describeMultiplex(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilMultiplexStopped(
        _ input: DescribeMultiplexRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeMultiplexRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "IDLE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "STOPPING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeMultiplex
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeMultiplex(_:logger:)``.
    ///
    /// - Parameters:
    ///   - multiplexId: The ID of the multiplex.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilMultiplexStopped(
        multiplexId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeMultiplexRequest(
            multiplexId: multiplexId
        )
        try await self.waitUntilMultiplexStopped(input, logger: logger)
    }

    /// Waiter for operation ``describeNode(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilNodeDeregistered(
        _ input: DescribeNodeRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeNodeRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "DEREGISTERED")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "DEREGISTERING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "DRAINING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeNode
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeNode(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - nodeId: The ID of the node.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilNodeDeregistered(
        clusterId: String,
        nodeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeNodeRequest(
            clusterId: clusterId, 
            nodeId: nodeId
        )
        try await self.waitUntilNodeDeregistered(input, logger: logger)
    }

    /// Waiter for operation ``describeNode(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilNodeRegistered(
        _ input: DescribeNodeRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeNodeRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("state", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("state", expected: "REGISTERING")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("NotFoundException")),
                .init(state: .failure, matcher: try! JMESPathMatcher("state", expected: "REGISTRATION_FAILED")),
                .init(state: .retry, matcher: AWSErrorCodeMatcher("InternalServerErrorException")),
            ],
            minDelayTime: .seconds(3),
            command: self.describeNode
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeNode(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterId: The ID of the cluster
    ///   - nodeId: The ID of the node.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilNodeRegistered(
        clusterId: String,
        nodeId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeNodeRequest(
            clusterId: clusterId, 
            nodeId: nodeId
        )
        try await self.waitUntilNodeRegistered(input, logger: logger)
    }

    /// Waiter for operation ``getSignalMap(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilSignalMapCreated(
        _ input: GetSignalMapRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetSignalMapRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "CREATE_COMPLETE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "CREATE_IN_PROGRESS")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CREATE_FAILED")),
            ],
            minDelayTime: .seconds(5),
            command: self.getSignalMap
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getSignalMap(_:logger:)``.
    ///
    /// - Parameters:
    ///   - identifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilSignalMapCreated(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetSignalMapRequest(
            identifier: identifier
        )
        try await self.waitUntilSignalMapCreated(input, logger: logger)
    }

    /// Waiter for operation ``getSignalMap(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilSignalMapMonitorDeleted(
        _ input: GetSignalMapRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetSignalMapRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("monitorDeployment.status", expected: "DELETE_COMPLETE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("monitorDeployment.status", expected: "DELETE_IN_PROGRESS")),
                .init(state: .failure, matcher: try! JMESPathMatcher("monitorDeployment.status", expected: "DELETE_FAILED")),
            ],
            minDelayTime: .seconds(5),
            command: self.getSignalMap
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getSignalMap(_:logger:)``.
    ///
    /// - Parameters:
    ///   - identifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilSignalMapMonitorDeleted(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetSignalMapRequest(
            identifier: identifier
        )
        try await self.waitUntilSignalMapMonitorDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getSignalMap(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilSignalMapMonitorDeployed(
        _ input: GetSignalMapRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetSignalMapRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("monitorDeployment.status", expected: "DRY_RUN_DEPLOYMENT_COMPLETE")),
                .init(state: .success, matcher: try! JMESPathMatcher("monitorDeployment.status", expected: "DEPLOYMENT_COMPLETE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("monitorDeployment.status", expected: "DRY_RUN_DEPLOYMENT_IN_PROGRESS")),
                .init(state: .retry, matcher: try! JMESPathMatcher("monitorDeployment.status", expected: "DEPLOYMENT_IN_PROGRESS")),
                .init(state: .failure, matcher: try! JMESPathMatcher("monitorDeployment.status", expected: "DRY_RUN_DEPLOYMENT_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("monitorDeployment.status", expected: "DEPLOYMENT_FAILED")),
            ],
            minDelayTime: .seconds(5),
            command: self.getSignalMap
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getSignalMap(_:logger:)``.
    ///
    /// - Parameters:
    ///   - identifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilSignalMapMonitorDeployed(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetSignalMapRequest(
            identifier: identifier
        )
        try await self.waitUntilSignalMapMonitorDeployed(input, logger: logger)
    }

    /// Waiter for operation ``getSignalMap(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilSignalMapUpdated(
        _ input: GetSignalMapRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetSignalMapRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "UPDATE_COMPLETE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("status", expected: "UPDATE_IN_PROGRESS")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "UPDATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "UPDATE_REVERTED")),
            ],
            minDelayTime: .seconds(5),
            command: self.getSignalMap
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getSignalMap(_:logger:)``.
    ///
    /// - Parameters:
    ///   - identifier: A signal map's identifier. Can be either be its id or current name.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilSignalMapUpdated(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetSignalMapRequest(
            identifier: identifier
        )
        try await self.waitUntilSignalMapUpdated(input, logger: logger)
    }
}
