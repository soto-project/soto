//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension MigrationHubStrategy {
    // MARK: Enums

    public enum AntipatternReportStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum AppType: String, CustomStringConvertible, Codable, _SotoSendable {
        case cassandra = "Cassandra"
        case db2 = "DB2"
        case dotNetFramework = "DotNetFramework"
        case dotnet = "Dotnet"
        case dotnetCore = "DotnetCore"
        case ibmWebsphere = "IBM WebSphere"
        case iis = "IIS"
        case jBoss = "JBoss"
        case java = "Java"
        case mariaDB = "Maria DB"
        case mongoDB = "Mongo DB"
        case mySQL = "MySQL"
        case oracle = "Oracle"
        case oracleWeblogic = "Oracle WebLogic"
        case other = "Other"
        case postgreSQLServer = "PostgreSQLServer"
        case sqlServer = "SQLServer"
        case spring = "Spring"
        case sybase = "Sybase"
        case tomcat = "Tomcat"
        case unknown = "Unknown"
        case visualBasic = "Visual Basic"
        public var description: String { return self.rawValue }
    }

    public enum AppUnitErrorCategory: String, CustomStringConvertible, Codable, _SotoSendable {
        case connectivityError = "CONNECTIVITY_ERROR"
        case credentialError = "CREDENTIAL_ERROR"
        case otherError = "OTHER_ERROR"
        case permissionError = "PERMISSION_ERROR"
        case unsupportedError = "UNSUPPORTED_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationComponentCriteria: String, CustomStringConvertible, Codable, _SotoSendable {
        case analysisStatus = "ANALYSIS_STATUS"
        case appName = "APP_NAME"
        case appType = "APP_TYPE"
        case destination = "DESTINATION"
        case errorCategory = "ERROR_CATEGORY"
        case notDefined = "NOT_DEFINED"
        case serverId = "SERVER_ID"
        case strategy = "STRATEGY"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case known = "KNOWN"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum AssessmentStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum AuthType: String, CustomStringConvertible, Codable, _SotoSendable {
        case cert = "CERT"
        case ntlm = "NTLM"
        case ssh = "SSH"
        public var description: String { return self.rawValue }
    }

    public enum AwsManagedTargetDestination: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsElasticBeanstalk = "AWS Elastic BeanStalk"
        case awsFargate = "AWS Fargate"
        case noneSpecified = "None specified"
        public var description: String { return self.rawValue }
    }

    public enum CollectorHealth: String, CustomStringConvertible, Codable, _SotoSendable {
        case collectorHealthy = "COLLECTOR_HEALTHY"
        case collectorUnhealthy = "COLLECTOR_UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum Condition: String, CustomStringConvertible, Codable, _SotoSendable {
        case contains = "CONTAINS"
        case equals = "EQUALS"
        case notContains = "NOT_CONTAINS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case applicationDiscoveryService = "ApplicationDiscoveryService"
        case mpa = "MPA"
        public var description: String { return self.rawValue }
    }

    public enum DatabaseManagementPreference: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsManaged = "AWS-managed"
        case noPreference = "No preference"
        case selfManage = "Self-manage"
        public var description: String { return self.rawValue }
    }

    public enum GroupName: String, CustomStringConvertible, Codable, _SotoSendable {
        case externalId = "ExternalId"
        public var description: String { return self.rawValue }
    }

    public enum HeterogeneousTargetDatabaseEngine: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsPostgresql = "AWS PostgreSQL"
        case amazonAurora = "Amazon Aurora"
        case db2LUW = "Db2 LUW"
        case mariaDB = "MariaDB"
        case microsoftSQLServer = "Microsoft SQL Server"
        case mongoDB = "MongoDB"
        case mySQL = "MySQL"
        case noneSpecified = "None specified"
        case oracleDatabase = "Oracle Database"
        case sap = "SAP"
        public var description: String { return self.rawValue }
    }

    public enum HomogeneousTargetDatabaseEngine: String, CustomStringConvertible, Codable, _SotoSendable {
        case noneSpecified = "None specified"
        public var description: String { return self.rawValue }
    }

    public enum ImportFileTaskStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case deleteFailed = "DeleteFailed"
        case deleteInProgress = "DeleteInProgress"
        case deletePartialSuccess = "DeletePartialSuccess"
        case deleteSuccess = "DeleteSuccess"
        case importFailed = "ImportFailed"
        case importInProgress = "ImportInProgress"
        case importPartialSuccess = "ImportPartialSuccess"
        case importSuccess = "ImportSuccess"
        public var description: String { return self.rawValue }
    }

    public enum InclusionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case excludeFromAssessment
        case includeInAssessment
        public var description: String { return self.rawValue }
    }

    public enum NoPreferenceTargetDestination: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsElasticBeanstalk = "AWS Elastic BeanStalk"
        case awsFargate = "AWS Fargate"
        case amazonElasticCloudComputeEC2 = "Amazon Elastic Cloud Compute (EC2)"
        case amazonElasticContainerServiceECS = "Amazon Elastic Container Service (ECS)"
        case amazonElasticKubernetesServiceEKS = "Amazon Elastic Kubernetes Service (EKS)"
        case noneSpecified = "None specified"
        public var description: String { return self.rawValue }
    }

    public enum OSType: String, CustomStringConvertible, Codable, _SotoSendable {
        case linux = "LINUX"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum OutputFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case excel = "Excel"
        case json = "Json"
        public var description: String { return self.rawValue }
    }

    public enum PipelineType: String, CustomStringConvertible, Codable, _SotoSendable {
        case azureDevops = "AZURE_DEVOPS"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationReportStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceSubType: String, CustomStringConvertible, Codable, _SotoSendable {
        case database = "Database"
        case databaseProcess = "DatabaseProcess"
        case process = "Process"
        public var description: String { return self.rawValue }
    }

    public enum RunTimeAssessmentStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case dataCollectionTaskFailed
        case dataCollectionTaskPartialSuccess
        case dataCollectionTaskScheduled
        case dataCollectionTaskStarted
        case dataCollectionTaskStopped
        case dataCollectionTaskSuccess
        case dataCollectionTaskToBeScheduled
        public var description: String { return self.rawValue }
    }

    public enum RuntimeAnalysisStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case analysisFailed = "ANALYSIS_FAILED"
        case analysisStarted = "ANALYSIS_STARTED"
        case analysisSuccess = "ANALYSIS_SUCCESS"
        case analysisToBeScheduled = "ANALYSIS_TO_BE_SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum SelfManageTargetDestination: String, CustomStringConvertible, Codable, _SotoSendable {
        case amazonElasticCloudComputeEC2 = "Amazon Elastic Cloud Compute (EC2)"
        case amazonElasticContainerServiceECS = "Amazon Elastic Container Service (ECS)"
        case amazonElasticKubernetesServiceEKS = "Amazon Elastic Kubernetes Service (EKS)"
        case noneSpecified = "None specified"
        public var description: String { return self.rawValue }
    }

    public enum ServerCriteria: String, CustomStringConvertible, Codable, _SotoSendable {
        case analysisStatus = "ANALYSIS_STATUS"
        case destination = "DESTINATION"
        case errorCategory = "ERROR_CATEGORY"
        case notDefined = "NOT_DEFINED"
        case osName = "OS_NAME"
        case serverId = "SERVER_ID"
        case strategy = "STRATEGY"
        public var description: String { return self.rawValue }
    }

    public enum ServerErrorCategory: String, CustomStringConvertible, Codable, _SotoSendable {
        case architectureError = "ARCHITECTURE_ERROR"
        case connectivityError = "CONNECTIVITY_ERROR"
        case credentialError = "CREDENTIAL_ERROR"
        case otherError = "OTHER_ERROR"
        case permissionError = "PERMISSION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ServerOsType: String, CustomStringConvertible, Codable, _SotoSendable {
        case amazonLinux = "AmazonLinux"
        case endOfSupportWindowsServer = "EndOfSupportWindowsServer"
        case other = "Other"
        case redhat = "Redhat"
        case windowsServer = "WindowsServer"
        public var description: String { return self.rawValue }
    }

    public enum Severity: String, CustomStringConvertible, Codable, _SotoSendable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum SrcCodeOrDbAnalysisStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case analysisFailed = "ANALYSIS_FAILED"
        case analysisPartialSuccess = "ANALYSIS_PARTIAL_SUCCESS"
        case analysisStarted = "ANALYSIS_STARTED"
        case analysisSuccess = "ANALYSIS_SUCCESS"
        case analysisToBeScheduled = "ANALYSIS_TO_BE_SCHEDULED"
        case configured = "CONFIGURED"
        case unconfigured = "UNCONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum Strategy: String, CustomStringConvertible, Codable, _SotoSendable {
        case refactor = "Refactor"
        case rehost = "Rehost"
        case relocate = "Relocate"
        case replatform = "Replatform"
        case repurchase = "Repurchase"
        case retain = "Retain"
        case retirement = "Retirement"
        public var description: String { return self.rawValue }
    }

    public enum StrategyRecommendation: String, CustomStringConvertible, Codable, _SotoSendable {
        case notRecommended
        case potential
        case recommended
        case viableOption
        public var description: String { return self.rawValue }
    }

    public enum TargetDatabaseEngine: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsPostgresql = "AWS PostgreSQL"
        case amazonAurora = "Amazon Aurora"
        case db2LUW = "Db2 LUW"
        case mariaDB = "MariaDB"
        case microsoftSQLServer = "Microsoft SQL Server"
        case mongoDB = "MongoDB"
        case mySQL = "MySQL"
        case noneSpecified = "None specified"
        case oracleDatabase = "Oracle Database"
        case sap = "SAP"
        public var description: String { return self.rawValue }
    }

    public enum TargetDestination: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsElasticBeanstalk = "AWS Elastic BeanStalk"
        case awsFargate = "AWS Fargate"
        case amazonDocumentdb = "Amazon DocumentDB"
        case amazonDynamodb = "Amazon DynamoDB"
        case amazonElasticCloudComputeEC2 = "Amazon Elastic Cloud Compute (EC2)"
        case amazonElasticContainerServiceECS = "Amazon Elastic Container Service (ECS)"
        case amazonElasticKubernetesServiceEKS = "Amazon Elastic Kubernetes Service (EKS)"
        case amazonRelationalDatabaseService = "Amazon Relational Database Service"
        case amazonRelationalDatabaseServiceOnMysql = "Amazon Relational Database Service on MySQL"
        case amazonRelationalDatabaseServiceOnPostgresql = "Amazon Relational Database Service on PostgreSQL"
        case auroraMysql = "Aurora MySQL"
        case auroraPostgresql = "Aurora PostgreSQL"
        case babelfishForAuroraPostgresql = "Babelfish for Aurora PostgreSQL"
        case noneSpecified = "None specified"
        public var description: String { return self.rawValue }
    }

    public enum TransformationToolName: String, CustomStringConvertible, Codable, _SotoSendable {
        case app2Container = "App2Container"
        case applicationMigrationService = "Application Migration Service"
        case databaseMigrationService = "Database Migration Service"
        case endOfSupportMigration = "End of Support Migration"
        case inPlaceOperatingSystemUpgrade = "In Place Operating System Upgrade"
        case nativeSQLServerBackupRestore = "Native SQL Server Backup/Restore"
        case portingAssistantForNET = "Porting Assistant For .NET"
        case schemaConversionTool = "Schema Conversion Tool"
        case strategyRecommendationSupport = "Strategy Recommendation Support"
        case windowsWebApplicationMigrationAssistant = "Windows Web Application Migration Assistant"
        public var description: String { return self.rawValue }
    }

    public enum VersionControl: String, CustomStringConvertible, Codable, _SotoSendable {
        case azureDevopsGit = "AZURE_DEVOPS_GIT"
        case github = "GITHUB"
        case githubEnterprise = "GITHUB_ENTERPRISE"
        public var description: String { return self.rawValue }
    }

    public enum VersionControlType: String, CustomStringConvertible, Codable, _SotoSendable {
        case azureDevopsGit = "AZURE_DEVOPS_GIT"
        case github = "GITHUB"
        case githubEnterprise = "GITHUB_ENTERPRISE"
        public var description: String { return self.rawValue }
    }

    public enum DatabaseMigrationPreference: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        ///  Indicates whether you are interested in moving from one type of database to another. For example, from SQL Server to Amazon Aurora MySQL-Compatible Edition.
        case heterogeneous(Heterogeneous)
        ///  Indicates whether you are interested in moving to the same type of database into AWS. For example, from SQL Server in your environment to SQL Server on AWS.
        case homogeneous(Homogeneous)
        ///  Indicated that you do not prefer heterogeneous or homogeneous.
        case noPreference(NoDatabaseMigrationPreference)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .heterogeneous:
                let value = try container.decode(Heterogeneous.self, forKey: .heterogeneous)
                self = .heterogeneous(value)
            case .homogeneous:
                let value = try container.decode(Homogeneous.self, forKey: .homogeneous)
                self = .homogeneous(value)
            case .noPreference:
                let value = try container.decode(NoDatabaseMigrationPreference.self, forKey: .noPreference)
                self = .noPreference(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .heterogeneous(let value):
                try container.encode(value, forKey: .heterogeneous)
            case .homogeneous(let value):
                try container.encode(value, forKey: .homogeneous)
            case .noPreference(let value):
                try container.encode(value, forKey: .noPreference)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .heterogeneous(let value):
                try value.validate(name: "\(name).heterogeneous")
            case .homogeneous(let value):
                try value.validate(name: "\(name).homogeneous")
            case .noPreference(let value):
                try value.validate(name: "\(name).noPreference")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case heterogeneous
            case homogeneous
            case noPreference
        }
    }

    public enum ManagementPreference: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        ///  Indicates interest in solutions that are managed by AWS.
        case awsManagedResources(AwsManagedResources)
        ///  No specific preference.
        case noPreference(NoManagementPreference)
        ///  Indicates interest in managing your own resources on AWS.
        case selfManageResources(SelfManageResources)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .awsManagedResources:
                let value = try container.decode(AwsManagedResources.self, forKey: .awsManagedResources)
                self = .awsManagedResources(value)
            case .noPreference:
                let value = try container.decode(NoManagementPreference.self, forKey: .noPreference)
                self = .noPreference(value)
            case .selfManageResources:
                let value = try container.decode(SelfManageResources.self, forKey: .selfManageResources)
                self = .selfManageResources(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .awsManagedResources(let value):
                try container.encode(value, forKey: .awsManagedResources)
            case .noPreference(let value):
                try container.encode(value, forKey: .noPreference)
            case .selfManageResources(let value):
                try container.encode(value, forKey: .selfManageResources)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .awsManagedResources(let value):
                try value.validate(name: "\(name).awsManagedResources")
            case .noPreference(let value):
                try value.validate(name: "\(name).noPreference")
            case .selfManageResources(let value):
                try value.validate(name: "\(name).selfManageResources")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsManagedResources
            case noPreference
            case selfManageResources
        }
    }

    // MARK: Shapes

    public struct AntipatternSeveritySummary: AWSDecodableShape {
        ///  Contains the count of anti-patterns.
        public let count: Int?
        ///  Contains the severity of anti-patterns.
        public let severity: Severity?

        public init(count: Int? = nil, severity: Severity? = nil) {
            self.count = count
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case count
            case severity
        }
    }

    public struct AppUnitError: AWSDecodableShape {
        /// The category of the error.
        public let appUnitErrorCategory: AppUnitErrorCategory?

        public init(appUnitErrorCategory: AppUnitErrorCategory? = nil) {
            self.appUnitErrorCategory = appUnitErrorCategory
        }

        private enum CodingKeys: String, CodingKey {
            case appUnitErrorCategory
        }
    }

    public struct ApplicationComponentDetail: AWSDecodableShape {
        ///  The status of analysis, if the application component has source code or an associated database.
        public let analysisStatus: SrcCodeOrDbAnalysisStatus?
        ///  The S3 bucket name and the Amazon S3 key name for the anti-pattern report.
        public let antipatternReportS3Object: S3Object?
        ///  The status of the anti-pattern report generation.
        public let antipatternReportStatus: AntipatternReportStatus?
        ///  The status message for the anti-pattern.
        public let antipatternReportStatusMessage: String?
        ///  The type of application component.
        public let appType: AppType?
        /// The error in the analysis of the source code or database.
        public let appUnitError: AppUnitError?
        ///  The ID of the server that the application component is running on.
        public let associatedServerId: String?
        ///  Configuration details for the database associated with the application component.
        public let databaseConfigDetail: DatabaseConfigDetail?
        ///  The ID of the application component.
        public let id: String?
        ///  Indicates whether the application component has been included for server recommendation or not.
        public let inclusionStatus: InclusionStatus?
        ///  The timestamp of when the application component was assessed.
        public let lastAnalyzedTimestamp: Date?
        ///  A list of anti-pattern severity summaries.
        public let listAntipatternSeveritySummary: [AntipatternSeveritySummary]?
        ///  Set to true if the application component is running on multiple servers.
        public let moreServerAssociationExists: Bool?
        ///  The name of application component.
        public let name: String?
        ///  OS driver.
        public let osDriver: String?
        ///  OS version.
        public let osVersion: String?
        ///  The top recommendation set for the application component.
        public let recommendationSet: RecommendationSet?
        ///  The application component subtype.
        public let resourceSubType: ResourceSubType?
        /// The status of the application unit.
        public let runtimeStatus: RuntimeAnalysisStatus?
        /// The status message for the application unit.
        public let runtimeStatusMessage: String?
        ///  Details about the source code repository associated with the application component.
        public let sourceCodeRepositories: [SourceCodeRepository]?
        ///  A detailed description of the analysis status and any failure message.
        public let statusMessage: String?

        public init(analysisStatus: SrcCodeOrDbAnalysisStatus? = nil, antipatternReportS3Object: S3Object? = nil, antipatternReportStatus: AntipatternReportStatus? = nil, antipatternReportStatusMessage: String? = nil, appType: AppType? = nil, appUnitError: AppUnitError? = nil, associatedServerId: String? = nil, databaseConfigDetail: DatabaseConfigDetail? = nil, id: String? = nil, inclusionStatus: InclusionStatus? = nil, lastAnalyzedTimestamp: Date? = nil, listAntipatternSeveritySummary: [AntipatternSeveritySummary]? = nil, moreServerAssociationExists: Bool? = nil, name: String? = nil, osDriver: String? = nil, osVersion: String? = nil, recommendationSet: RecommendationSet? = nil, resourceSubType: ResourceSubType? = nil, runtimeStatus: RuntimeAnalysisStatus? = nil, runtimeStatusMessage: String? = nil, sourceCodeRepositories: [SourceCodeRepository]? = nil, statusMessage: String? = nil) {
            self.analysisStatus = analysisStatus
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.appType = appType
            self.appUnitError = appUnitError
            self.associatedServerId = associatedServerId
            self.databaseConfigDetail = databaseConfigDetail
            self.id = id
            self.inclusionStatus = inclusionStatus
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.moreServerAssociationExists = moreServerAssociationExists
            self.name = name
            self.osDriver = osDriver
            self.osVersion = osVersion
            self.recommendationSet = recommendationSet
            self.resourceSubType = resourceSubType
            self.runtimeStatus = runtimeStatus
            self.runtimeStatusMessage = runtimeStatusMessage
            self.sourceCodeRepositories = sourceCodeRepositories
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case analysisStatus
            case antipatternReportS3Object
            case antipatternReportStatus
            case antipatternReportStatusMessage
            case appType
            case appUnitError
            case associatedServerId
            case databaseConfigDetail
            case id
            case inclusionStatus
            case lastAnalyzedTimestamp
            case listAntipatternSeveritySummary
            case moreServerAssociationExists
            case name
            case osDriver
            case osVersion
            case recommendationSet
            case resourceSubType
            case runtimeStatus
            case runtimeStatusMessage
            case sourceCodeRepositories
            case statusMessage
        }
    }

    public struct ApplicationComponentStatusSummary: AWSDecodableShape {
        /// The number of application components successfully analyzed, partially successful or failed analysis.
        public let count: Int?
        /// The status of database analysis.
        public let srcCodeOrDbAnalysisStatus: SrcCodeOrDbAnalysisStatus?

        public init(count: Int? = nil, srcCodeOrDbAnalysisStatus: SrcCodeOrDbAnalysisStatus? = nil) {
            self.count = count
            self.srcCodeOrDbAnalysisStatus = srcCodeOrDbAnalysisStatus
        }

        private enum CodingKeys: String, CodingKey {
            case count
            case srcCodeOrDbAnalysisStatus
        }
    }

    public struct ApplicationComponentStrategy: AWSDecodableShape {
        ///  Set to true if the recommendation is set as preferred.
        public let isPreferred: Bool?
        ///  Strategy recommendation for the application component.
        public let recommendation: RecommendationSet?
        ///  The recommendation status of a strategy for an application component.
        public let status: StrategyRecommendation?

        public init(isPreferred: Bool? = nil, recommendation: RecommendationSet? = nil, status: StrategyRecommendation? = nil) {
            self.isPreferred = isPreferred
            self.recommendation = recommendation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case isPreferred
            case recommendation
            case status
        }
    }

    public struct ApplicationComponentSummary: AWSDecodableShape {
        ///  Contains the name of application types.
        public let appType: AppType?
        ///  Contains the count of application type.
        public let count: Int?

        public init(appType: AppType? = nil, count: Int? = nil) {
            self.appType = appType
            self.count = count
        }

        private enum CodingKeys: String, CodingKey {
            case appType
            case count
        }
    }

    public struct ApplicationPreferences: AWSEncodableShape & AWSDecodableShape {
        ///  Application preferences that you specify to prefer managed environment.
        public let managementPreference: ManagementPreference?

        public init(managementPreference: ManagementPreference? = nil) {
            self.managementPreference = managementPreference
        }

        public func validate(name: String) throws {
            try self.managementPreference?.validate(name: "\(name).managementPreference")
        }

        private enum CodingKeys: String, CodingKey {
            case managementPreference
        }
    }

    public struct AssessmentSummary: AWSDecodableShape {
        ///  The Amazon S3 object containing the anti-pattern report.
        public let antipatternReportS3Object: S3Object?
        ///  The status of the anti-pattern report.
        public let antipatternReportStatus: AntipatternReportStatus?
        ///  The status message of the anti-pattern report.
        public let antipatternReportStatusMessage: String?
        ///  The time the assessment was performed.
        public let lastAnalyzedTimestamp: Date?
        ///  List of AntipatternSeveritySummary.
        public let listAntipatternSeveritySummary: [AntipatternSeveritySummary]?
        /// List of status summaries of the analyzed application components.
        public let listApplicationComponentStatusSummary: [ApplicationComponentStatusSummary]?
        ///  List of ApplicationComponentStrategySummary.
        public let listApplicationComponentStrategySummary: [StrategySummary]?
        ///  List of ApplicationComponentSummary.
        public let listApplicationComponentSummary: [ApplicationComponentSummary]?
        /// List of status summaries of the analyzed servers.
        public let listServerStatusSummary: [ServerStatusSummary]?
        ///  List of ServerStrategySummary.
        public let listServerStrategySummary: [StrategySummary]?
        ///  List of ServerSummary.
        public let listServerSummary: [ServerSummary]?

        public init(antipatternReportS3Object: S3Object? = nil, antipatternReportStatus: AntipatternReportStatus? = nil, antipatternReportStatusMessage: String? = nil, lastAnalyzedTimestamp: Date? = nil, listAntipatternSeveritySummary: [AntipatternSeveritySummary]? = nil, listApplicationComponentStatusSummary: [ApplicationComponentStatusSummary]? = nil, listApplicationComponentStrategySummary: [StrategySummary]? = nil, listApplicationComponentSummary: [ApplicationComponentSummary]? = nil, listServerStatusSummary: [ServerStatusSummary]? = nil, listServerStrategySummary: [StrategySummary]? = nil, listServerSummary: [ServerSummary]? = nil) {
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.listApplicationComponentStatusSummary = listApplicationComponentStatusSummary
            self.listApplicationComponentStrategySummary = listApplicationComponentStrategySummary
            self.listApplicationComponentSummary = listApplicationComponentSummary
            self.listServerStatusSummary = listServerStatusSummary
            self.listServerStrategySummary = listServerStrategySummary
            self.listServerSummary = listServerSummary
        }

        private enum CodingKeys: String, CodingKey {
            case antipatternReportS3Object
            case antipatternReportStatus
            case antipatternReportStatusMessage
            case lastAnalyzedTimestamp
            case listAntipatternSeveritySummary
            case listApplicationComponentStatusSummary
            case listApplicationComponentStrategySummary
            case listApplicationComponentSummary
            case listServerStatusSummary
            case listServerStrategySummary
            case listServerSummary
        }
    }

    public struct AssessmentTarget: AWSEncodableShape & AWSDecodableShape {
        /// Condition of an assessment.
        public let condition: Condition
        /// Name of an assessment.
        public let name: String
        /// Values of an assessment.
        public let values: [String]

        public init(condition: Condition, name: String, values: [String]) {
            self.condition = condition
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case condition
            case name
            case values
        }
    }

    public struct AssociatedApplication: AWSDecodableShape {
        ///  ID of the application as defined in Application Discovery Service.
        public let id: String?
        ///  Name of the application as defined in Application Discovery Service.
        public let name: String?

        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case name
        }
    }

    public struct AwsManagedResources: AWSEncodableShape & AWSDecodableShape {
        ///  The choice of application destination that you specify.
        public let targetDestination: [AwsManagedTargetDestination]

        public init(targetDestination: [AwsManagedTargetDestination]) {
            self.targetDestination = targetDestination
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, max: 1)
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDestination
        }
    }

    public struct BusinessGoals: AWSEncodableShape & AWSDecodableShape {
        ///  Business goal to reduce license costs.
        public let licenseCostReduction: Int?
        ///  Business goal to modernize infrastructure by moving to cloud native technologies.
        public let modernizeInfrastructureWithCloudNativeTechnologies: Int?
        ///  Business goal to reduce the operational overhead on the team by moving into managed services.
        public let reduceOperationalOverheadWithManagedServices: Int?
        ///  Business goal to achieve migration at a fast pace.
        public let speedOfMigration: Int?

        public init(licenseCostReduction: Int? = nil, modernizeInfrastructureWithCloudNativeTechnologies: Int? = nil, reduceOperationalOverheadWithManagedServices: Int? = nil, speedOfMigration: Int? = nil) {
            self.licenseCostReduction = licenseCostReduction
            self.modernizeInfrastructureWithCloudNativeTechnologies = modernizeInfrastructureWithCloudNativeTechnologies
            self.reduceOperationalOverheadWithManagedServices = reduceOperationalOverheadWithManagedServices
            self.speedOfMigration = speedOfMigration
        }

        public func validate(name: String) throws {
            try self.validate(self.licenseCostReduction, name: "licenseCostReduction", parent: name, max: 5)
            try self.validate(self.licenseCostReduction, name: "licenseCostReduction", parent: name, min: 1)
            try self.validate(self.modernizeInfrastructureWithCloudNativeTechnologies, name: "modernizeInfrastructureWithCloudNativeTechnologies", parent: name, max: 5)
            try self.validate(self.modernizeInfrastructureWithCloudNativeTechnologies, name: "modernizeInfrastructureWithCloudNativeTechnologies", parent: name, min: 1)
            try self.validate(self.reduceOperationalOverheadWithManagedServices, name: "reduceOperationalOverheadWithManagedServices", parent: name, max: 5)
            try self.validate(self.reduceOperationalOverheadWithManagedServices, name: "reduceOperationalOverheadWithManagedServices", parent: name, min: 1)
            try self.validate(self.speedOfMigration, name: "speedOfMigration", parent: name, max: 5)
            try self.validate(self.speedOfMigration, name: "speedOfMigration", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case licenseCostReduction
            case modernizeInfrastructureWithCloudNativeTechnologies
            case reduceOperationalOverheadWithManagedServices
            case speedOfMigration
        }
    }

    public struct Collector: AWSDecodableShape {
        ///  Indicates the health of a collector.
        public let collectorHealth: CollectorHealth?
        ///  The ID of the collector.
        public let collectorId: String?
        ///  Current version of the collector that is running in the environment that you specify.
        public let collectorVersion: String?
        /// Summary of the collector configuration.
        public let configurationSummary: ConfigurationSummary?
        ///  Hostname of the server that is hosting the collector.
        public let hostName: String?
        ///  IP address of the server that is hosting the collector.
        public let ipAddress: String?
        ///  Time when the collector last pinged the service.
        public let lastActivityTimeStamp: String?
        ///  Time when the collector registered with the service.
        public let registeredTimeStamp: String?

        public init(collectorHealth: CollectorHealth? = nil, collectorId: String? = nil, collectorVersion: String? = nil, configurationSummary: ConfigurationSummary? = nil, hostName: String? = nil, ipAddress: String? = nil, lastActivityTimeStamp: String? = nil, registeredTimeStamp: String? = nil) {
            self.collectorHealth = collectorHealth
            self.collectorId = collectorId
            self.collectorVersion = collectorVersion
            self.configurationSummary = configurationSummary
            self.hostName = hostName
            self.ipAddress = ipAddress
            self.lastActivityTimeStamp = lastActivityTimeStamp
            self.registeredTimeStamp = registeredTimeStamp
        }

        private enum CodingKeys: String, CodingKey {
            case collectorHealth
            case collectorId
            case collectorVersion
            case configurationSummary
            case hostName
            case ipAddress
            case lastActivityTimeStamp
            case registeredTimeStamp
        }
    }

    public struct ConfigurationSummary: AWSDecodableShape {
        /// IP address based configurations.
        public let ipAddressBasedRemoteInfoList: [IPAddressBasedRemoteInfo]?
        /// The list of pipeline info configurations.
        public let pipelineInfoList: [PipelineInfo]?
        /// Info about the remote server source code configuration.
        public let remoteSourceCodeAnalysisServerInfo: RemoteSourceCodeAnalysisServerInfo?
        /// The list of vCenter configurations.
        public let vcenterBasedRemoteInfoList: [VcenterBasedRemoteInfo]?
        /// The list of the version control configurations.
        public let versionControlInfoList: [VersionControlInfo]?

        public init(ipAddressBasedRemoteInfoList: [IPAddressBasedRemoteInfo]? = nil, pipelineInfoList: [PipelineInfo]? = nil, remoteSourceCodeAnalysisServerInfo: RemoteSourceCodeAnalysisServerInfo? = nil, vcenterBasedRemoteInfoList: [VcenterBasedRemoteInfo]? = nil, versionControlInfoList: [VersionControlInfo]? = nil) {
            self.ipAddressBasedRemoteInfoList = ipAddressBasedRemoteInfoList
            self.pipelineInfoList = pipelineInfoList
            self.remoteSourceCodeAnalysisServerInfo = remoteSourceCodeAnalysisServerInfo
            self.vcenterBasedRemoteInfoList = vcenterBasedRemoteInfoList
            self.versionControlInfoList = versionControlInfoList
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddressBasedRemoteInfoList
            case pipelineInfoList
            case remoteSourceCodeAnalysisServerInfo
            case vcenterBasedRemoteInfoList
            case versionControlInfoList
        }
    }

    public struct DataCollectionDetails: AWSDecodableShape {
        ///  The time the assessment completes.
        public let completionTime: Date?
        ///  The number of failed servers in the assessment.
        public let failed: Int?
        ///  The number of servers with the assessment status IN_PROGESS.
        public let inProgress: Int?
        ///  The total number of servers in the assessment.
        public let servers: Int?
        ///  The start time of assessment.
        public let startTime: Date?
        ///  The status of the assessment.
        public let status: AssessmentStatus?
        /// The status message of the assessment.
        public let statusMessage: String?
        ///  The number of successful servers in the assessment.
        public let success: Int?

        public init(completionTime: Date? = nil, failed: Int? = nil, inProgress: Int? = nil, servers: Int? = nil, startTime: Date? = nil, status: AssessmentStatus? = nil, statusMessage: String? = nil, success: Int? = nil) {
            self.completionTime = completionTime
            self.failed = failed
            self.inProgress = inProgress
            self.servers = servers
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.success = success
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case failed
            case inProgress
            case servers
            case startTime
            case status
            case statusMessage
            case success
        }
    }

    public struct DatabaseConfigDetail: AWSDecodableShape {
        ///  AWS Secrets Manager key that holds the credentials that you use to connect to a database.
        public let secretName: String?

        public init(secretName: String? = nil) {
            self.secretName = secretName
        }

        private enum CodingKeys: String, CodingKey {
            case secretName
        }
    }

    public struct DatabasePreferences: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies whether you're interested in self-managed databases or databases managed by AWS.
        public let databaseManagementPreference: DatabaseManagementPreference?
        ///  Specifies your preferred migration path.
        public let databaseMigrationPreference: DatabaseMigrationPreference?

        public init(databaseManagementPreference: DatabaseManagementPreference? = nil, databaseMigrationPreference: DatabaseMigrationPreference? = nil) {
            self.databaseManagementPreference = databaseManagementPreference
            self.databaseMigrationPreference = databaseMigrationPreference
        }

        public func validate(name: String) throws {
            try self.databaseMigrationPreference?.validate(name: "\(name).databaseMigrationPreference")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseManagementPreference
            case databaseMigrationPreference
        }
    }

    public struct GetApplicationComponentDetailsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationComponentId", location: .uri("applicationComponentId"))
        ]

        ///  The ID of the application component. The ID is unique within an AWS account.
        public let applicationComponentId: String

        public init(applicationComponentId: String) {
            self.applicationComponentId = applicationComponentId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, max: 44)
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, pattern: "[0-9a-zA-Z-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationComponentDetailsResponse: AWSDecodableShape {
        ///  Detailed information about an application component.
        public let applicationComponentDetail: ApplicationComponentDetail?
        ///  The associated application group as defined in AWS Application Discovery Service.
        public let associatedApplications: [AssociatedApplication]?
        ///  A list of the IDs of the servers on which the application component is running.
        public let associatedServerIds: [String]?
        ///  Set to true if the application component belongs to more than one application group.
        public let moreApplicationResource: Bool?

        public init(applicationComponentDetail: ApplicationComponentDetail? = nil, associatedApplications: [AssociatedApplication]? = nil, associatedServerIds: [String]? = nil, moreApplicationResource: Bool? = nil) {
            self.applicationComponentDetail = applicationComponentDetail
            self.associatedApplications = associatedApplications
            self.associatedServerIds = associatedServerIds
            self.moreApplicationResource = moreApplicationResource
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentDetail
            case associatedApplications
            case associatedServerIds
            case moreApplicationResource
        }
    }

    public struct GetApplicationComponentStrategiesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "applicationComponentId", location: .uri("applicationComponentId"))
        ]

        ///  The ID of the application component. The ID is unique within an AWS account.
        public let applicationComponentId: String

        public init(applicationComponentId: String) {
            self.applicationComponentId = applicationComponentId
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, max: 44)
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, pattern: "[0-9a-zA-Z-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationComponentStrategiesResponse: AWSDecodableShape {
        ///  A list of application component strategy recommendations.
        public let applicationComponentStrategies: [ApplicationComponentStrategy]?

        public init(applicationComponentStrategies: [ApplicationComponentStrategy]? = nil) {
            self.applicationComponentStrategies = applicationComponentStrategies
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentStrategies
        }
    }

    public struct GetAssessmentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        ///  The assessmentid returned by StartAssessment.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 52)
            try self.validate(self.id, name: "id", parent: name, pattern: "[0-9a-z-:]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssessmentResponse: AWSDecodableShape {
        /// List of criteria for assessment.
        public let assessmentTargets: [AssessmentTarget]?
        ///  Detailed information about the assessment.
        public let dataCollectionDetails: DataCollectionDetails?
        ///  The ID for the specific assessment task.
        public let id: String?

        public init(assessmentTargets: [AssessmentTarget]? = nil, dataCollectionDetails: DataCollectionDetails? = nil, id: String? = nil) {
            self.assessmentTargets = assessmentTargets
            self.dataCollectionDetails = dataCollectionDetails
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentTargets
            case dataCollectionDetails
            case id
        }
    }

    public struct GetImportFileTaskRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        ///  The ID of the import file task. This ID is returned in the response of StartImportFileTask.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 1024)
            try self.validate(self.id, name: "id", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImportFileTaskResponse: AWSDecodableShape {
        ///  The time that the import task completed.
        public let completionTime: Date?
        ///  The import file task id returned in the response of StartImportFileTask.
        public let id: String?
        ///  The name of the import task given in StartImportFileTask.
        public let importName: String?
        ///  The S3 bucket where import file is located.
        public let inputS3Bucket: String?
        ///  The Amazon S3 key name of the import file.
        public let inputS3Key: String?
        ///  The number of records that failed to be imported.
        public let numberOfRecordsFailed: Int?
        ///  The number of records successfully imported.
        public let numberOfRecordsSuccess: Int?
        ///  Start time of the import task.
        public let startTime: Date?
        ///  Status of import file task.
        public let status: ImportFileTaskStatus?
        ///  The S3 bucket name for status report of import task.
        public let statusReportS3Bucket: String?
        ///  The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not.
        public let statusReportS3Key: String?

        public init(completionTime: Date? = nil, id: String? = nil, importName: String? = nil, inputS3Bucket: String? = nil, inputS3Key: String? = nil, numberOfRecordsFailed: Int? = nil, numberOfRecordsSuccess: Int? = nil, startTime: Date? = nil, status: ImportFileTaskStatus? = nil, statusReportS3Bucket: String? = nil, statusReportS3Key: String? = nil) {
            self.completionTime = completionTime
            self.id = id
            self.importName = importName
            self.inputS3Bucket = inputS3Bucket
            self.inputS3Key = inputS3Key
            self.numberOfRecordsFailed = numberOfRecordsFailed
            self.numberOfRecordsSuccess = numberOfRecordsSuccess
            self.startTime = startTime
            self.status = status
            self.statusReportS3Bucket = statusReportS3Bucket
            self.statusReportS3Key = statusReportS3Key
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case id
            case importName
            case inputS3Bucket
            case inputS3Key
            case numberOfRecordsFailed
            case numberOfRecordsSuccess
            case startTime
            case status
            case statusReportS3Bucket
            case statusReportS3Key
        }
    }

    public struct GetLatestAssessmentIdRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetLatestAssessmentIdResponse: AWSDecodableShape {
        /// The latest ID for the specific assessment task.
        public let id: String?

        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct GetPortfolioPreferencesRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetPortfolioPreferencesResponse: AWSDecodableShape {
        /// The classification for application component types.
        public let applicationMode: ApplicationMode?
        ///  The transformation preferences for non-database applications.
        public let applicationPreferences: ApplicationPreferences?
        ///  The transformation preferences for database applications.
        public let databasePreferences: DatabasePreferences?
        ///  The rank of business goals based on priority.
        public let prioritizeBusinessGoals: PrioritizeBusinessGoals?

        public init(applicationMode: ApplicationMode? = nil, applicationPreferences: ApplicationPreferences? = nil, databasePreferences: DatabasePreferences? = nil, prioritizeBusinessGoals: PrioritizeBusinessGoals? = nil) {
            self.applicationMode = applicationMode
            self.applicationPreferences = applicationPreferences
            self.databasePreferences = databasePreferences
            self.prioritizeBusinessGoals = prioritizeBusinessGoals
        }

        private enum CodingKeys: String, CodingKey {
            case applicationMode
            case applicationPreferences
            case databasePreferences
            case prioritizeBusinessGoals
        }
    }

    public struct GetPortfolioSummaryRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetPortfolioSummaryResponse: AWSDecodableShape {
        ///  An assessment summary for the portfolio including the number of servers to rehost and the overall number of anti-patterns.
        public let assessmentSummary: AssessmentSummary?

        public init(assessmentSummary: AssessmentSummary? = nil) {
            self.assessmentSummary = assessmentSummary
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentSummary
        }
    }

    public struct GetRecommendationReportDetailsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("id"))
        ]

        ///  The recommendation report generation task id returned by StartRecommendationReportGeneration.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 52)
            try self.validate(self.id, name: "id", parent: name, pattern: "[0-9a-z-:]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecommendationReportDetailsResponse: AWSDecodableShape {
        ///  The ID of the recommendation report generation task. See the response of StartRecommendationReportGeneration.
        public let id: String?
        ///  Detailed information about the recommendation report.
        public let recommendationReportDetails: RecommendationReportDetails?

        public init(id: String? = nil, recommendationReportDetails: RecommendationReportDetails? = nil) {
            self.id = id
            self.recommendationReportDetails = recommendationReportDetails
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case recommendationReportDetails
        }
    }

    public struct GetServerDetailsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "serverId", location: .uri("serverId"))
        ]

        ///  The maximum number of items to include in the response. The maximum value is 100.
        public let maxResults: Int?
        ///  The token from a previous call that you use to retrieve the next set of results. For example,
        /// if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?
        ///  The ID of the server.
        public let serverId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, serverId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serverId = serverId
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
            try self.validate(self.serverId, name: "serverId", parent: name, max: 27)
            try self.validate(self.serverId, name: "serverId", parent: name, min: 1)
            try self.validate(self.serverId, name: "serverId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServerDetailsResponse: AWSDecodableShape {
        ///  The associated application group the server belongs to, as defined in AWS Application Discovery Service.
        public let associatedApplications: [AssociatedApplication]?
        ///  The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  Detailed information about the server.
        public let serverDetail: ServerDetail?

        public init(associatedApplications: [AssociatedApplication]? = nil, nextToken: String? = nil, serverDetail: ServerDetail? = nil) {
            self.associatedApplications = associatedApplications
            self.nextToken = nextToken
            self.serverDetail = serverDetail
        }

        private enum CodingKeys: String, CodingKey {
            case associatedApplications
            case nextToken
            case serverDetail
        }
    }

    public struct GetServerStrategiesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "serverId", location: .uri("serverId"))
        ]

        ///  The ID of the server.
        public let serverId: String

        public init(serverId: String) {
            self.serverId = serverId
        }

        public func validate(name: String) throws {
            try self.validate(self.serverId, name: "serverId", parent: name, max: 27)
            try self.validate(self.serverId, name: "serverId", parent: name, min: 1)
            try self.validate(self.serverId, name: "serverId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServerStrategiesResponse: AWSDecodableShape {
        ///  A list of strategy recommendations for the server.
        public let serverStrategies: [ServerStrategy]?

        public init(serverStrategies: [ServerStrategy]? = nil) {
            self.serverStrategies = serverStrategies
        }

        private enum CodingKeys: String, CodingKey {
            case serverStrategies
        }
    }

    public struct Group: AWSEncodableShape {
        ///  The key of the specific import group.
        public let name: GroupName?
        ///  The value of the specific import group.
        public let value: String?

        public init(name: GroupName? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case value
        }
    }

    public struct Heterogeneous: AWSEncodableShape & AWSDecodableShape {
        ///  The target database engine for heterogeneous database migration preference.
        public let targetDatabaseEngine: [HeterogeneousTargetDatabaseEngine]

        public init(targetDatabaseEngine: [HeterogeneousTargetDatabaseEngine]) {
            self.targetDatabaseEngine = targetDatabaseEngine
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDatabaseEngine, name: "targetDatabaseEngine", parent: name, max: 1)
            try self.validate(self.targetDatabaseEngine, name: "targetDatabaseEngine", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDatabaseEngine
        }
    }

    public struct Homogeneous: AWSEncodableShape & AWSDecodableShape {
        ///  The target database engine for homogeneous database migration preferences.
        public let targetDatabaseEngine: [HomogeneousTargetDatabaseEngine]?

        public init(targetDatabaseEngine: [HomogeneousTargetDatabaseEngine]? = nil) {
            self.targetDatabaseEngine = targetDatabaseEngine
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDatabaseEngine, name: "targetDatabaseEngine", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDatabaseEngine
        }
    }

    public struct IPAddressBasedRemoteInfo: AWSDecodableShape {
        /// The type of authorization.
        public let authType: AuthType?
        /// The time stamp of the configuration.
        public let ipAddressConfigurationTimeStamp: String?
        /// The type of the operating system.
        public let osType: OSType?

        public init(authType: AuthType? = nil, ipAddressConfigurationTimeStamp: String? = nil, osType: OSType? = nil) {
            self.authType = authType
            self.ipAddressConfigurationTimeStamp = ipAddressConfigurationTimeStamp
            self.osType = osType
        }

        private enum CodingKeys: String, CodingKey {
            case authType
            case ipAddressConfigurationTimeStamp
            case osType
        }
    }

    public struct ImportFileTaskInformation: AWSDecodableShape {
        ///  The time that the import task completes.
        public let completionTime: Date?
        ///  The ID of the import file task.
        public let id: String?
        ///  The name of the import task given in StartImportFileTask.
        public let importName: String?
        ///  The S3 bucket where the import file is located.
        public let inputS3Bucket: String?
        ///  The Amazon S3 key name of the import file.
        public let inputS3Key: String?
        ///  The number of records that failed to be imported.
        public let numberOfRecordsFailed: Int?
        ///  The number of records successfully imported.
        public let numberOfRecordsSuccess: Int?
        ///  Start time of the import task.
        public let startTime: Date?
        ///  Status of import file task.
        public let status: ImportFileTaskStatus?
        ///  The S3 bucket name for status report of import task.
        public let statusReportS3Bucket: String?
        ///  The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not.
        public let statusReportS3Key: String?

        public init(completionTime: Date? = nil, id: String? = nil, importName: String? = nil, inputS3Bucket: String? = nil, inputS3Key: String? = nil, numberOfRecordsFailed: Int? = nil, numberOfRecordsSuccess: Int? = nil, startTime: Date? = nil, status: ImportFileTaskStatus? = nil, statusReportS3Bucket: String? = nil, statusReportS3Key: String? = nil) {
            self.completionTime = completionTime
            self.id = id
            self.importName = importName
            self.inputS3Bucket = inputS3Bucket
            self.inputS3Key = inputS3Key
            self.numberOfRecordsFailed = numberOfRecordsFailed
            self.numberOfRecordsSuccess = numberOfRecordsSuccess
            self.startTime = startTime
            self.status = status
            self.statusReportS3Bucket = statusReportS3Bucket
            self.statusReportS3Key = statusReportS3Key
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case id
            case importName
            case inputS3Bucket
            case inputS3Key
            case numberOfRecordsFailed
            case numberOfRecordsSuccess
            case startTime
            case status
            case statusReportS3Bucket
            case statusReportS3Key
        }
    }

    public struct ListApplicationComponentsRequest: AWSEncodableShape {
        ///  Criteria for filtering the list of application components.
        public let applicationComponentCriteria: ApplicationComponentCriteria?
        ///  Specify the value based on the application component criteria type. For example, if applicationComponentCriteria is set to SERVER_ID and filterValue is set to server1, then ListApplicationComponents returns all the application components running on server1.
        public let filterValue: String?
        ///  The group ID specified in to filter on.
        public let groupIdFilter: [Group]?
        ///  The maximum number of items to include in the response. The maximum value is 100.
        public let maxResults: Int?
        ///  The token from a previous call that you use to retrieve the next set of results. For example,
        /// if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?
        ///  Specifies whether to sort by ascending (ASC) or descending (DESC) order.
        public let sort: SortOrder?

        public init(applicationComponentCriteria: ApplicationComponentCriteria? = nil, filterValue: String? = nil, groupIdFilter: [Group]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: SortOrder? = nil) {
            self.applicationComponentCriteria = applicationComponentCriteria
            self.filterValue = filterValue
            self.groupIdFilter = groupIdFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.filterValue, name: "filterValue", parent: name, max: 1024)
            try self.validate(self.filterValue, name: "filterValue", parent: name, pattern: ".*\\S.*")
            try self.groupIdFilter?.forEach {
                try $0.validate(name: "\(name).groupIdFilter[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentCriteria
            case filterValue
            case groupIdFilter
            case maxResults
            case nextToken
            case sort
        }
    }

    public struct ListApplicationComponentsResponse: AWSDecodableShape {
        ///  The list of application components with detailed information about each component.
        public let applicationComponentInfos: [ApplicationComponentDetail]?
        ///  The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(applicationComponentInfos: [ApplicationComponentDetail]? = nil, nextToken: String? = nil) {
            self.applicationComponentInfos = applicationComponentInfos
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentInfos
            case nextToken
        }
    }

    public struct ListCollectorsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        ///  The maximum number of items to include in the response. The maximum value is 100.
        public let maxResults: Int?
        ///  The token from a previous call that you use to retrieve the next set of results. For example,
        /// if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollectorsResponse: AWSDecodableShape {
        ///  The list of all the installed collectors.
        public let collectors: [Collector]?
        ///  The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(collectors: [Collector]? = nil, nextToken: String? = nil) {
            self.collectors = collectors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collectors = "Collectors"
            case nextToken
        }
    }

    public struct ListImportFileTaskRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        ///  The total number of items to return. The maximum value is 100.
        public let maxResults: Int?
        ///  The token from a previous call that you use to retrieve the next set of results. For example,
        /// if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListImportFileTaskResponse: AWSDecodableShape {
        ///  The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  Lists information about the files you import.
        public let taskInfos: [ImportFileTaskInformation]?

        public init(nextToken: String? = nil, taskInfos: [ImportFileTaskInformation]? = nil) {
            self.nextToken = nextToken
            self.taskInfos = taskInfos
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case taskInfos
        }
    }

    public struct ListServersRequest: AWSEncodableShape {
        ///  Specifies the filter value, which is based on the type of server criteria. For example, if serverCriteria is OS_NAME, and the filterValue is equal to WindowsServer, then ListServers returns all of the servers matching the OS name WindowsServer.
        public let filterValue: String?
        ///  Specifies the group ID to filter on.
        public let groupIdFilter: [Group]?
        ///  The maximum number of items to include in the response. The maximum value is 100.
        public let maxResults: Int?
        ///  The token from a previous call that you use to retrieve the next set of results. For example,
        /// if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?
        ///  Criteria for filtering servers.
        public let serverCriteria: ServerCriteria?
        ///  Specifies whether to sort by ascending (ASC) or descending (DESC) order.
        public let sort: SortOrder?

        public init(filterValue: String? = nil, groupIdFilter: [Group]? = nil, maxResults: Int? = nil, nextToken: String? = nil, serverCriteria: ServerCriteria? = nil, sort: SortOrder? = nil) {
            self.filterValue = filterValue
            self.groupIdFilter = groupIdFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serverCriteria = serverCriteria
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.filterValue, name: "filterValue", parent: name, max: 1024)
            try self.validate(self.filterValue, name: "filterValue", parent: name, pattern: ".*\\S.*")
            try self.groupIdFilter?.forEach {
                try $0.validate(name: "\(name).groupIdFilter[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case filterValue
            case groupIdFilter
            case maxResults
            case nextToken
            case serverCriteria
            case sort
        }
    }

    public struct ListServersResponse: AWSDecodableShape {
        ///  The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  The list of servers with detailed information about each server.
        public let serverInfos: [ServerDetail]?

        public init(nextToken: String? = nil, serverInfos: [ServerDetail]? = nil) {
            self.nextToken = nextToken
            self.serverInfos = serverInfos
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case serverInfos
        }
    }

    public struct NetworkInfo: AWSDecodableShape {
        ///  Information about the name of the interface of the server for which the assessment was run.
        public let interfaceName: String
        ///  Information about the IP address of the server for which the assessment was run.
        public let ipAddress: String
        ///  Information about the MAC address of the server for which the assessment was run.
        public let macAddress: String
        ///  Information about the subnet mask of the server for which the assessment was run.
        public let netMask: String

        public init(interfaceName: String, ipAddress: String, macAddress: String, netMask: String) {
            self.interfaceName = interfaceName
            self.ipAddress = ipAddress
            self.macAddress = macAddress
            self.netMask = netMask
        }

        private enum CodingKeys: String, CodingKey {
            case interfaceName
            case ipAddress
            case macAddress
            case netMask
        }
    }

    public struct NoDatabaseMigrationPreference: AWSEncodableShape & AWSDecodableShape {
        ///  The target database engine for database migration preference that you specify.
        public let targetDatabaseEngine: [TargetDatabaseEngine]

        public init(targetDatabaseEngine: [TargetDatabaseEngine]) {
            self.targetDatabaseEngine = targetDatabaseEngine
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDatabaseEngine, name: "targetDatabaseEngine", parent: name, max: 1)
            try self.validate(self.targetDatabaseEngine, name: "targetDatabaseEngine", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDatabaseEngine
        }
    }

    public struct NoManagementPreference: AWSEncodableShape & AWSDecodableShape {
        ///  The choice of application destination that you specify.
        public let targetDestination: [NoPreferenceTargetDestination]

        public init(targetDestination: [NoPreferenceTargetDestination]) {
            self.targetDestination = targetDestination
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, max: 1)
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDestination
        }
    }

    public struct OSInfo: AWSDecodableShape {
        ///  Information about the type of operating system.
        public let type: OSType?
        ///  Information about the version of operating system.
        public let version: String?

        public init(type: OSType? = nil, version: String? = nil) {
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case version
        }
    }

    public struct PipelineInfo: AWSDecodableShape {
        /// The time when the pipeline info was configured.
        public let pipelineConfigurationTimeStamp: String?
        /// The type of pipeline.
        public let pipelineType: PipelineType?

        public init(pipelineConfigurationTimeStamp: String? = nil, pipelineType: PipelineType? = nil) {
            self.pipelineConfigurationTimeStamp = pipelineConfigurationTimeStamp
            self.pipelineType = pipelineType
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineConfigurationTimeStamp
            case pipelineType
        }
    }

    public struct PrioritizeBusinessGoals: AWSEncodableShape & AWSDecodableShape {
        ///  Rank of business goals based on priority.
        public let businessGoals: BusinessGoals?

        public init(businessGoals: BusinessGoals? = nil) {
            self.businessGoals = businessGoals
        }

        public func validate(name: String) throws {
            try self.businessGoals?.validate(name: "\(name).businessGoals")
        }

        private enum CodingKeys: String, CodingKey {
            case businessGoals
        }
    }

    public struct PutPortfolioPreferencesRequest: AWSEncodableShape {
        /// The classification for application component types.
        public let applicationMode: ApplicationMode?
        ///  The transformation preferences for non-database applications.
        public let applicationPreferences: ApplicationPreferences?
        ///  The transformation preferences for database applications.
        public let databasePreferences: DatabasePreferences?
        ///  The rank of the business goals based on priority.
        public let prioritizeBusinessGoals: PrioritizeBusinessGoals?

        public init(applicationMode: ApplicationMode? = nil, applicationPreferences: ApplicationPreferences? = nil, databasePreferences: DatabasePreferences? = nil, prioritizeBusinessGoals: PrioritizeBusinessGoals? = nil) {
            self.applicationMode = applicationMode
            self.applicationPreferences = applicationPreferences
            self.databasePreferences = databasePreferences
            self.prioritizeBusinessGoals = prioritizeBusinessGoals
        }

        public func validate(name: String) throws {
            try self.applicationPreferences?.validate(name: "\(name).applicationPreferences")
            try self.databasePreferences?.validate(name: "\(name).databasePreferences")
            try self.prioritizeBusinessGoals?.validate(name: "\(name).prioritizeBusinessGoals")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationMode
            case applicationPreferences
            case databasePreferences
            case prioritizeBusinessGoals
        }
    }

    public struct PutPortfolioPreferencesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RecommendationReportDetails: AWSDecodableShape {
        ///  The time that the recommendation report generation task completes.
        public let completionTime: Date?
        ///  The S3 bucket where the report file is located.
        public let s3Bucket: String?
        ///  The Amazon S3 key name of the report file.
        public let s3Keys: [String]?
        ///  The time that the recommendation report generation task starts.
        public let startTime: Date?
        ///  The status of the recommendation report generation task.
        public let status: RecommendationReportStatus?
        ///  The status message for recommendation report generation.
        public let statusMessage: String?

        public init(completionTime: Date? = nil, s3Bucket: String? = nil, s3Keys: [String]? = nil, startTime: Date? = nil, status: RecommendationReportStatus? = nil, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime
            case s3Bucket
            case s3Keys
            case startTime
            case status
            case statusMessage
        }
    }

    public struct RecommendationSet: AWSDecodableShape {
        ///  The recommended strategy.
        public let strategy: Strategy?
        ///  The recommended target destination.
        public let targetDestination: TargetDestination?
        ///  The target destination for the recommendation set.
        public let transformationTool: TransformationTool?

        public init(strategy: Strategy? = nil, targetDestination: TargetDestination? = nil, transformationTool: TransformationTool? = nil) {
            self.strategy = strategy
            self.targetDestination = targetDestination
            self.transformationTool = transformationTool
        }

        private enum CodingKeys: String, CodingKey {
            case strategy
            case targetDestination
            case transformationTool
        }
    }

    public struct RemoteSourceCodeAnalysisServerInfo: AWSDecodableShape {
        /// The time when the remote source code server was configured.
        public let remoteSourceCodeAnalysisServerConfigurationTimestamp: String?

        public init(remoteSourceCodeAnalysisServerConfigurationTimestamp: String? = nil) {
            self.remoteSourceCodeAnalysisServerConfigurationTimestamp = remoteSourceCodeAnalysisServerConfigurationTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case remoteSourceCodeAnalysisServerConfigurationTimestamp
        }
    }

    public struct S3Object: AWSDecodableShape {
        ///  The S3 bucket name.
        public let s3Bucket: String?
        ///  The Amazon S3 key name.
        public let s3key: String?

        public init(s3Bucket: String? = nil, s3key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3key = s3key
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket
            case s3key
        }
    }

    public struct SelfManageResources: AWSEncodableShape & AWSDecodableShape {
        ///  Self-managed resources target destination.
        public let targetDestination: [SelfManageTargetDestination]

        public init(targetDestination: [SelfManageTargetDestination]) {
            self.targetDestination = targetDestination
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, max: 1)
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDestination
        }
    }

    public struct ServerDetail: AWSDecodableShape {
        ///  The S3 bucket name and Amazon S3 key name for anti-pattern report.
        public let antipatternReportS3Object: S3Object?
        ///  The status of the anti-pattern report generation.
        public let antipatternReportStatus: AntipatternReportStatus?
        ///  A message about the status of the anti-pattern report generation.
        public let antipatternReportStatusMessage: String?
        ///  A list of strategy summaries.
        public let applicationComponentStrategySummary: [StrategySummary]?
        ///  The status of assessment for the server.
        public let dataCollectionStatus: RunTimeAssessmentStatus?
        ///  The server ID.
        public let id: String?
        ///  The timestamp of when the server was assessed.
        public let lastAnalyzedTimestamp: Date?
        ///  A list of anti-pattern severity summaries.
        public let listAntipatternSeveritySummary: [AntipatternSeveritySummary]?
        ///  The name of the server.
        public let name: String?
        ///  A set of recommendations.
        public let recommendationSet: RecommendationSet?
        /// The error in server analysis.
        public let serverError: ServerError?
        ///  The type of server.
        public let serverType: String?
        ///  A message about the status of data collection, which contains detailed descriptions of any error messages.
        public let statusMessage: String?
        ///  System information about the server.
        public let systemInfo: SystemInfo?

        public init(antipatternReportS3Object: S3Object? = nil, antipatternReportStatus: AntipatternReportStatus? = nil, antipatternReportStatusMessage: String? = nil, applicationComponentStrategySummary: [StrategySummary]? = nil, dataCollectionStatus: RunTimeAssessmentStatus? = nil, id: String? = nil, lastAnalyzedTimestamp: Date? = nil, listAntipatternSeveritySummary: [AntipatternSeveritySummary]? = nil, name: String? = nil, recommendationSet: RecommendationSet? = nil, serverError: ServerError? = nil, serverType: String? = nil, statusMessage: String? = nil, systemInfo: SystemInfo? = nil) {
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.applicationComponentStrategySummary = applicationComponentStrategySummary
            self.dataCollectionStatus = dataCollectionStatus
            self.id = id
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.name = name
            self.recommendationSet = recommendationSet
            self.serverError = serverError
            self.serverType = serverType
            self.statusMessage = statusMessage
            self.systemInfo = systemInfo
        }

        private enum CodingKeys: String, CodingKey {
            case antipatternReportS3Object
            case antipatternReportStatus
            case antipatternReportStatusMessage
            case applicationComponentStrategySummary
            case dataCollectionStatus
            case id
            case lastAnalyzedTimestamp
            case listAntipatternSeveritySummary
            case name
            case recommendationSet
            case serverError
            case serverType
            case statusMessage
            case systemInfo
        }
    }

    public struct ServerError: AWSDecodableShape {
        /// The error category of server analysis.
        public let serverErrorCategory: ServerErrorCategory?

        public init(serverErrorCategory: ServerErrorCategory? = nil) {
            self.serverErrorCategory = serverErrorCategory
        }

        private enum CodingKeys: String, CodingKey {
            case serverErrorCategory
        }
    }

    public struct ServerStatusSummary: AWSDecodableShape {
        /// The number of servers successfully analyzed, partially successful or failed analysis.
        public let count: Int?
        /// The status of the run time.
        public let runTimeAssessmentStatus: RunTimeAssessmentStatus?

        public init(count: Int? = nil, runTimeAssessmentStatus: RunTimeAssessmentStatus? = nil) {
            self.count = count
            self.runTimeAssessmentStatus = runTimeAssessmentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case count
            case runTimeAssessmentStatus
        }
    }

    public struct ServerStrategy: AWSDecodableShape {
        ///  Set to true if the recommendation is set as preferred.
        public let isPreferred: Bool?
        ///  The number of application components with this strategy recommendation running on the server.
        public let numberOfApplicationComponents: Int?
        ///  Strategy recommendation for the server.
        public let recommendation: RecommendationSet?
        ///  The recommendation status of the strategy for the server.
        public let status: StrategyRecommendation?

        public init(isPreferred: Bool? = nil, numberOfApplicationComponents: Int? = nil, recommendation: RecommendationSet? = nil, status: StrategyRecommendation? = nil) {
            self.isPreferred = isPreferred
            self.numberOfApplicationComponents = numberOfApplicationComponents
            self.recommendation = recommendation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case isPreferred
            case numberOfApplicationComponents
            case recommendation
            case status
        }
    }

    public struct ServerSummary: AWSDecodableShape {
        ///  Number of servers.
        public let count: Int?
        ///  Type of operating system for the servers.
        public let serverOsType: ServerOsType?

        public init(count: Int? = nil, serverOsType: ServerOsType? = nil) {
            self.count = count
            self.serverOsType = serverOsType
        }

        private enum CodingKeys: String, CodingKey {
            case count
            case serverOsType = "ServerOsType"
        }
    }

    public struct SourceCode: AWSEncodableShape {
        ///  The repository name for the source code.
        public let location: String?
        /// The name of the project.
        public let projectName: String?
        ///  The branch of the source code.
        public let sourceVersion: String?
        ///  The type of repository to use for the source code.
        public let versionControl: VersionControl?

        public init(location: String? = nil, projectName: String? = nil, sourceVersion: String? = nil, versionControl: VersionControl? = nil) {
            self.location = location
            self.projectName = projectName
            self.sourceVersion = sourceVersion
            self.versionControl = versionControl
        }

        public func validate(name: String) throws {
            try self.validate(self.location, name: "location", parent: name, max: 128)
            try self.validate(self.location, name: "location", parent: name, min: 1)
            try self.validate(self.location, name: "location", parent: name, pattern: ".*\\S.*")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 128)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: ".*\\S.*")
            try self.validate(self.sourceVersion, name: "sourceVersion", parent: name, max: 40)
            try self.validate(self.sourceVersion, name: "sourceVersion", parent: name, min: 1)
            try self.validate(self.sourceVersion, name: "sourceVersion", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case location
            case projectName
            case sourceVersion
            case versionControl
        }
    }

    public struct SourceCodeRepository: AWSDecodableShape {
        ///  The branch of the source code.
        public let branch: String?
        /// The name of the project.
        public let projectName: String?
        ///  The repository name for the source code.
        public let repository: String?
        ///  The type of repository to use for the source code.
        public let versionControlType: String?

        public init(branch: String? = nil, projectName: String? = nil, repository: String? = nil, versionControlType: String? = nil) {
            self.branch = branch
            self.projectName = projectName
            self.repository = repository
            self.versionControlType = versionControlType
        }

        private enum CodingKeys: String, CodingKey {
            case branch
            case projectName
            case repository
            case versionControlType
        }
    }

    public struct StartAssessmentRequest: AWSEncodableShape {
        /// List of criteria for assessment.
        public let assessmentTargets: [AssessmentTarget]?
        ///  The S3 bucket used by the collectors to send analysis data to the service. The bucket name must begin with migrationhub-strategy-.
        public let s3bucketForAnalysisData: String?
        ///  The S3 bucket where all the reports generated by the service are stored. The bucket name must begin with migrationhub-strategy-.
        public let s3bucketForReportData: String?

        public init(assessmentTargets: [AssessmentTarget]? = nil, s3bucketForAnalysisData: String? = nil, s3bucketForReportData: String? = nil) {
            self.assessmentTargets = assessmentTargets
            self.s3bucketForAnalysisData = s3bucketForAnalysisData
            self.s3bucketForReportData = s3bucketForReportData
        }

        public func validate(name: String) throws {
            try self.assessmentTargets?.forEach {
                try $0.validate(name: "\(name).assessmentTargets[]")
            }
            try self.validate(self.assessmentTargets, name: "assessmentTargets", parent: name, max: 10)
            try self.validate(self.s3bucketForAnalysisData, name: "s3bucketForAnalysisData", parent: name, max: 1024)
            try self.validate(self.s3bucketForAnalysisData, name: "s3bucketForAnalysisData", parent: name, pattern: ".*\\S.*")
            try self.validate(self.s3bucketForReportData, name: "s3bucketForReportData", parent: name, max: 1024)
            try self.validate(self.s3bucketForReportData, name: "s3bucketForReportData", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentTargets
            case s3bucketForAnalysisData
            case s3bucketForReportData
        }
    }

    public struct StartAssessmentResponse: AWSDecodableShape {
        ///  The ID of the assessment.
        public let assessmentId: String?

        public init(assessmentId: String? = nil) {
            self.assessmentId = assessmentId
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId
        }
    }

    public struct StartImportFileTaskRequest: AWSEncodableShape {
        /// Specifies the source that the servers are coming from. By default, Strategy Recommendations assumes that the servers specified in the import file are available in AWS Application Discovery Service.
        public let dataSourceType: DataSourceType?
        /// Groups the resources in the import file together with a unique name. This ID can be as filter in ListApplicationComponents and ListServers.
        public let groupId: [Group]?
        ///  A descriptive name for the request.
        public let name: String
        ///  The S3 bucket where the import file is located. The bucket name is required to begin with migrationhub-strategy-.
        public let s3Bucket: String
        ///  The S3 bucket where Strategy Recommendations uploads import results. The bucket name is required to begin with migrationhub-strategy-.
        public let s3bucketForReportData: String?
        ///  The Amazon S3 key name of the import file.
        public let s3key: String

        public init(dataSourceType: DataSourceType? = nil, groupId: [Group]? = nil, name: String, s3Bucket: String, s3bucketForReportData: String? = nil, s3key: String) {
            self.dataSourceType = dataSourceType
            self.groupId = groupId
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3bucketForReportData = s3bucketForReportData
            self.s3key = s3key
        }

        public func validate(name: String) throws {
            try self.groupId?.forEach {
                try $0.validate(name: "\(name).groupId[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "[0-9a-z]+[0-9a-z\\.\\-]*[0-9a-z]+")
            try self.validate(self.s3bucketForReportData, name: "s3bucketForReportData", parent: name, max: 1024)
            try self.validate(self.s3bucketForReportData, name: "s3bucketForReportData", parent: name, pattern: ".*\\S.*")
            try self.validate(self.s3key, name: "s3key", parent: name, max: 1024)
            try self.validate(self.s3key, name: "s3key", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceType
            case groupId
            case name
            case s3Bucket = "S3Bucket"
            case s3bucketForReportData
            case s3key
        }
    }

    public struct StartImportFileTaskResponse: AWSDecodableShape {
        ///  The ID for a specific import task. The ID is unique within an AWS account.
        public let id: String?

        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct StartRecommendationReportGenerationRequest: AWSEncodableShape {
        ///  Groups the resources in the recommendation report with a unique name.
        public let groupIdFilter: [Group]?
        ///  The output format for the recommendation report file. The default format is Microsoft Excel.
        public let outputFormat: OutputFormat?

        public init(groupIdFilter: [Group]? = nil, outputFormat: OutputFormat? = nil) {
            self.groupIdFilter = groupIdFilter
            self.outputFormat = outputFormat
        }

        public func validate(name: String) throws {
            try self.groupIdFilter?.forEach {
                try $0.validate(name: "\(name).groupIdFilter[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case groupIdFilter
            case outputFormat
        }
    }

    public struct StartRecommendationReportGenerationResponse: AWSDecodableShape {
        ///  The ID of the recommendation report generation task.
        public let id: String?

        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id
        }
    }

    public struct StopAssessmentRequest: AWSEncodableShape {
        ///  The assessmentId returned by StartAssessment.
        public let assessmentId: String

        public init(assessmentId: String) {
            self.assessmentId = assessmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 52)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "[0-9a-z-:]+")
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId
        }
    }

    public struct StopAssessmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StrategyOption: AWSEncodableShape {
        ///  Indicates if a specific strategy is preferred for the application component.
        public let isPreferred: Bool?
        ///  Type of transformation. For example, Rehost, Replatform, and so on.
        public let strategy: Strategy?
        ///  Destination information about where the application component can migrate to. For example, EC2, ECS, and so on.
        public let targetDestination: TargetDestination?
        ///  The name of the tool that can be used to transform an application component using this strategy.
        public let toolName: TransformationToolName?

        public init(isPreferred: Bool? = nil, strategy: Strategy? = nil, targetDestination: TargetDestination? = nil, toolName: TransformationToolName? = nil) {
            self.isPreferred = isPreferred
            self.strategy = strategy
            self.targetDestination = targetDestination
            self.toolName = toolName
        }

        private enum CodingKeys: String, CodingKey {
            case isPreferred
            case strategy
            case targetDestination
            case toolName
        }
    }

    public struct StrategySummary: AWSDecodableShape {
        ///  The count of recommendations per strategy.
        public let count: Int?
        ///  The name of recommended strategy.
        public let strategy: Strategy?

        public init(count: Int? = nil, strategy: Strategy? = nil) {
            self.count = count
            self.strategy = strategy
        }

        private enum CodingKeys: String, CodingKey {
            case count
            case strategy
        }
    }

    public struct SystemInfo: AWSDecodableShape {
        ///  CPU architecture type for the server.
        public let cpuArchitecture: String?
        ///  File system type for the server.
        public let fileSystemType: String?
        ///  Networking information related to a server.
        public let networkInfoList: [NetworkInfo]?
        ///  Operating system corresponding to a server.
        public let osInfo: OSInfo?

        public init(cpuArchitecture: String? = nil, fileSystemType: String? = nil, networkInfoList: [NetworkInfo]? = nil, osInfo: OSInfo? = nil) {
            self.cpuArchitecture = cpuArchitecture
            self.fileSystemType = fileSystemType
            self.networkInfoList = networkInfoList
            self.osInfo = osInfo
        }

        private enum CodingKeys: String, CodingKey {
            case cpuArchitecture
            case fileSystemType
            case networkInfoList
            case osInfo
        }
    }

    public struct TransformationTool: AWSDecodableShape {
        ///  Description of the tool.
        public let description: String?
        ///  Name of the tool.
        public let name: TransformationToolName?
        ///  URL for installing the tool.
        public let tranformationToolInstallationLink: String?

        public init(description: String? = nil, name: TransformationToolName? = nil, tranformationToolInstallationLink: String? = nil) {
            self.description = description
            self.name = name
            self.tranformationToolInstallationLink = tranformationToolInstallationLink
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
            case tranformationToolInstallationLink
        }
    }

    public struct UpdateApplicationComponentConfigRequest: AWSEncodableShape {
        ///  The ID of the application component. The ID is unique within an AWS account.
        public let applicationComponentId: String
        /// The type of known component.
        public let appType: AppType?
        /// Update the configuration request of an application component. If it is set to true, the source code and/or database credentials are updated. If it is set to false, the source code and/or database credentials are updated and an analysis is initiated.
        public let configureOnly: Bool?
        ///  Indicates whether the application component has been included for server recommendation or not.
        public let inclusionStatus: InclusionStatus?
        ///  Database credentials.
        public let secretsManagerKey: String?
        ///  The list of source code configurations to update for the application component.
        public let sourceCodeList: [SourceCode]?
        ///  The preferred strategy options for the application component. Use values from the GetApplicationComponentStrategies response.
        public let strategyOption: StrategyOption?

        public init(applicationComponentId: String, appType: AppType? = nil, configureOnly: Bool? = nil, inclusionStatus: InclusionStatus? = nil, secretsManagerKey: String? = nil, sourceCodeList: [SourceCode]? = nil, strategyOption: StrategyOption? = nil) {
            self.applicationComponentId = applicationComponentId
            self.appType = appType
            self.configureOnly = configureOnly
            self.inclusionStatus = inclusionStatus
            self.secretsManagerKey = secretsManagerKey
            self.sourceCodeList = sourceCodeList
            self.strategyOption = strategyOption
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, max: 44)
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, pattern: "[0-9a-zA-Z-]+")
            try self.validate(self.secretsManagerKey, name: "secretsManagerKey", parent: name, max: 512)
            try self.validate(self.secretsManagerKey, name: "secretsManagerKey", parent: name, min: 1)
            try self.validate(self.secretsManagerKey, name: "secretsManagerKey", parent: name, pattern: ".*")
            try self.sourceCodeList?.forEach {
                try $0.validate(name: "\(name).sourceCodeList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentId
            case appType
            case configureOnly
            case inclusionStatus
            case secretsManagerKey
            case sourceCodeList
            case strategyOption
        }
    }

    public struct UpdateApplicationComponentConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateServerConfigRequest: AWSEncodableShape {
        ///  The ID of the server.
        public let serverId: String
        ///  The preferred strategy options for the application component. See the response from GetServerStrategies.
        public let strategyOption: StrategyOption?

        public init(serverId: String, strategyOption: StrategyOption? = nil) {
            self.serverId = serverId
            self.strategyOption = strategyOption
        }

        public func validate(name: String) throws {
            try self.validate(self.serverId, name: "serverId", parent: name, max: 27)
            try self.validate(self.serverId, name: "serverId", parent: name, min: 1)
            try self.validate(self.serverId, name: "serverId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case serverId
            case strategyOption
        }
    }

    public struct UpdateServerConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct VcenterBasedRemoteInfo: AWSDecodableShape {
        /// The type of the operating system.
        public let osType: OSType?
        /// The time when the remote server based on vCenter was last configured.
        public let vcenterConfigurationTimeStamp: String?

        public init(osType: OSType? = nil, vcenterConfigurationTimeStamp: String? = nil) {
            self.osType = osType
            self.vcenterConfigurationTimeStamp = vcenterConfigurationTimeStamp
        }

        private enum CodingKeys: String, CodingKey {
            case osType
            case vcenterConfigurationTimeStamp
        }
    }

    public struct VersionControlInfo: AWSDecodableShape {
        /// The time when the version control system was last configured.
        public let versionControlConfigurationTimeStamp: String?
        /// The type of version control.
        public let versionControlType: VersionControlType?

        public init(versionControlConfigurationTimeStamp: String? = nil, versionControlType: VersionControlType? = nil) {
            self.versionControlConfigurationTimeStamp = versionControlConfigurationTimeStamp
            self.versionControlType = versionControlType
        }

        private enum CodingKeys: String, CodingKey {
            case versionControlConfigurationTimeStamp
            case versionControlType
        }
    }
}

// MARK: - Errors

/// Error enum for MigrationHubStrategy
public struct MigrationHubStrategyErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case dependencyException = "DependencyException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceLinkedRoleLockClientException = "ServiceLinkedRoleLockClientException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MigrationHubStrategy
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  The AWS user account does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this account.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  Exception to indicate that there is an ongoing task when a new task is created. Return when once the existing tasks are complete.
    public static var conflictException: Self { .init(.conflictException) }
    /// Dependency encountered an error.
    public static var dependencyException: Self { .init(.dependencyException) }
    ///  The server experienced an internal error. Try again.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The specified ID in the request is not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  Exception to indicate that the service-linked role (SLR) is locked.
    public static var serviceLinkedRoleLockClientException: Self { .init(.serviceLinkedRoleLockClientException) }
    ///  The AWS account has reached its quota of imports. Contact AWS Support to increase the quota for this account.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    ///  The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  The request body isn&#39;t valid.
    public static var validationException: Self { .init(.validationException) }
}

extension MigrationHubStrategyErrorType: Equatable {
    public static func == (lhs: MigrationHubStrategyErrorType, rhs: MigrationHubStrategyErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MigrationHubStrategyErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
