//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MigrationHubStrategy {
    // MARK: Enums

    public enum AnalysisType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case binaryAnalysis = "BINARY_ANALYSIS"
        case databaseAnalysis = "DATABASE_ANALYSIS"
        case runtimeAnalysis = "RUNTIME_ANALYSIS"
        case sourceCodeAnalysis = "SOURCE_CODE_ANALYSIS"
        public var description: String { return self.rawValue }
    }

    public enum AntipatternReportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum AppType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cassandra = "Cassandra"
        case db2 = "DB2"
        case dotNetFramework = "DotNetFramework"
        case dotnet = "Dotnet"
        case dotnetCore = "DotnetCore"
        case ibmWebsphere = "IBM WebSphere"
        case iis = "IIS"
        case jBoss = "JBoss"
        case java = "Java"
        case mariaDB = "Maria DB"
        case mongoDB = "Mongo DB"
        case mySQL = "MySQL"
        case oracle = "Oracle"
        case oracleWeblogic = "Oracle WebLogic"
        case other = "Other"
        case postgreSQLServer = "PostgreSQLServer"
        case sqlServer = "SQLServer"
        case spring = "Spring"
        case sybase = "Sybase"
        case tomcat = "Tomcat"
        case unknown = "Unknown"
        case visualBasic = "Visual Basic"
        public var description: String { return self.rawValue }
    }

    public enum AppUnitErrorCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectivityError = "CONNECTIVITY_ERROR"
        case credentialError = "CREDENTIAL_ERROR"
        case otherError = "OTHER_ERROR"
        case permissionError = "PERMISSION_ERROR"
        case unsupportedError = "UNSUPPORTED_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationComponentCriteria: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analysisStatus = "ANALYSIS_STATUS"
        case appName = "APP_NAME"
        case appType = "APP_TYPE"
        case destination = "DESTINATION"
        case errorCategory = "ERROR_CATEGORY"
        case notDefined = "NOT_DEFINED"
        case serverId = "SERVER_ID"
        case strategy = "STRATEGY"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case known = "KNOWN"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum AssessmentDataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case applicationDiscoveryService = "ApplicationDiscoveryService"
        case manualImport = "ManualImport"
        case strategyRecommendationsApplicationDataCollector = "StrategyRecommendationsApplicationDataCollector"
        public var description: String { return self.rawValue }
    }

    public enum AssessmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum AuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cert = "CERT"
        case ntlm = "NTLM"
        case ssh = "SSH"
        public var description: String { return self.rawValue }
    }

    public enum AwsManagedTargetDestination: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsElasticBeanstalk = "AWS Elastic BeanStalk"
        case awsFargate = "AWS Fargate"
        case noneSpecified = "None specified"
        public var description: String { return self.rawValue }
    }

    public enum BinaryAnalyzerName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bytecodeAnalyzer = "BYTECODE_ANALYZER"
        case dllAnalyzer = "DLL_ANALYZER"
        public var description: String { return self.rawValue }
    }

    public enum CollectorHealth: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case collectorHealthy = "COLLECTOR_HEALTHY"
        case collectorUnhealthy = "COLLECTOR_UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum Condition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case equals = "EQUALS"
        case notContains = "NOT_CONTAINS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case applicationDiscoveryService = "ApplicationDiscoveryService"
        case `import` = "Import"
        case mpa = "MPA"
        case strategyRecommendationsApplicationDataCollector = "StrategyRecommendationsApplicationDataCollector"
        public var description: String { return self.rawValue }
    }

    public enum DatabaseManagementPreference: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsManaged = "AWS-managed"
        case noPreference = "No preference"
        case selfManage = "Self-manage"
        public var description: String { return self.rawValue }
    }

    public enum GroupName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case externalId = "ExternalId"
        case externalSourceType = "ExternalSourceType"
        public var description: String { return self.rawValue }
    }

    public enum HeterogeneousTargetDatabaseEngine: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsPostgresql = "AWS PostgreSQL"
        case amazonAurora = "Amazon Aurora"
        case db2LUW = "Db2 LUW"
        case mariaDB = "MariaDB"
        case microsoftSQLServer = "Microsoft SQL Server"
        case mongoDB = "MongoDB"
        case mySQL = "MySQL"
        case noneSpecified = "None specified"
        case oracleDatabase = "Oracle Database"
        case sap = "SAP"
        public var description: String { return self.rawValue }
    }

    public enum HomogeneousTargetDatabaseEngine: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case noneSpecified = "None specified"
        public var description: String { return self.rawValue }
    }

    public enum ImportFileTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleteFailed = "DeleteFailed"
        case deleteInProgress = "DeleteInProgress"
        case deletePartialSuccess = "DeletePartialSuccess"
        case deleteSuccess = "DeleteSuccess"
        case importFailed = "ImportFailed"
        case importInProgress = "ImportInProgress"
        case importPartialSuccess = "ImportPartialSuccess"
        case importSuccess = "ImportSuccess"
        public var description: String { return self.rawValue }
    }

    public enum InclusionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case excludeFromAssessment = "excludeFromAssessment"
        case includeInAssessment = "includeInAssessment"
        public var description: String { return self.rawValue }
    }

    public enum NoPreferenceTargetDestination: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsElasticBeanstalk = "AWS Elastic BeanStalk"
        case awsFargate = "AWS Fargate"
        case amazonElasticCloudComputeEC2 = "Amazon Elastic Cloud Compute (EC2)"
        case amazonElasticContainerServiceECS = "Amazon Elastic Container Service (ECS)"
        case amazonElasticKubernetesServiceEKS = "Amazon Elastic Kubernetes Service (EKS)"
        case noneSpecified = "None specified"
        public var description: String { return self.rawValue }
    }

    public enum OSType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linux = "LINUX"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum OutputFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case excel = "Excel"
        case json = "Json"
        public var description: String { return self.rawValue }
    }

    public enum PipelineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case azureDevops = "AZURE_DEVOPS"
        public var description: String { return self.rawValue }
    }

    public enum RecommendationReportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceSubType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case database = "Database"
        case databaseProcess = "DatabaseProcess"
        case process = "Process"
        public var description: String { return self.rawValue }
    }

    public enum RunTimeAnalyzerName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case a2cAnalyzer = "A2C_ANALYZER"
        case databaseAnalyzer = "DATABASE_ANALYZER"
        case empPaAnalyzer = "EMP_PA_ANALYZER"
        case rehostAnalyzer = "REHOST_ANALYZER"
        case sctAnalyzer = "SCT_ANALYZER"
        public var description: String { return self.rawValue }
    }

    public enum RunTimeAssessmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dataCollectionTaskFailed = "dataCollectionTaskFailed"
        case dataCollectionTaskPartialSuccess = "dataCollectionTaskPartialSuccess"
        case dataCollectionTaskScheduled = "dataCollectionTaskScheduled"
        case dataCollectionTaskStarted = "dataCollectionTaskStarted"
        case dataCollectionTaskStopped = "dataCollectionTaskStopped"
        case dataCollectionTaskSuccess = "dataCollectionTaskSuccess"
        case dataCollectionTaskToBeScheduled = "dataCollectionTaskToBeScheduled"
        public var description: String { return self.rawValue }
    }

    public enum RuntimeAnalysisStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analysisFailed = "ANALYSIS_FAILED"
        case analysisStarted = "ANALYSIS_STARTED"
        case analysisSuccess = "ANALYSIS_SUCCESS"
        case analysisToBeScheduled = "ANALYSIS_TO_BE_SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum SelfManageTargetDestination: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonElasticCloudComputeEC2 = "Amazon Elastic Cloud Compute (EC2)"
        case amazonElasticContainerServiceECS = "Amazon Elastic Container Service (ECS)"
        case amazonElasticKubernetesServiceEKS = "Amazon Elastic Kubernetes Service (EKS)"
        case noneSpecified = "None specified"
        public var description: String { return self.rawValue }
    }

    public enum ServerCriteria: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analysisStatus = "ANALYSIS_STATUS"
        case destination = "DESTINATION"
        case errorCategory = "ERROR_CATEGORY"
        case notDefined = "NOT_DEFINED"
        case osName = "OS_NAME"
        case serverId = "SERVER_ID"
        case strategy = "STRATEGY"
        public var description: String { return self.rawValue }
    }

    public enum ServerErrorCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case architectureError = "ARCHITECTURE_ERROR"
        case connectivityError = "CONNECTIVITY_ERROR"
        case credentialError = "CREDENTIAL_ERROR"
        case otherError = "OTHER_ERROR"
        case permissionError = "PERMISSION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ServerOsType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonLinux = "AmazonLinux"
        case endOfSupportWindowsServer = "EndOfSupportWindowsServer"
        case other = "Other"
        case redhat = "Redhat"
        case windowsServer = "WindowsServer"
        public var description: String { return self.rawValue }
    }

    public enum Severity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum SourceCodeAnalyzerName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bytecodeAnalyzer = "BYTECODE_ANALYZER"
        case csharpAnalyzer = "CSHARP_ANALYZER"
        case javaAnalyzer = "JAVA_ANALYZER"
        case portingAssistant = "PORTING_ASSISTANT"
        public var description: String { return self.rawValue }
    }

    public enum SrcCodeOrDbAnalysisStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analysisFailed = "ANALYSIS_FAILED"
        case analysisPartialSuccess = "ANALYSIS_PARTIAL_SUCCESS"
        case analysisStarted = "ANALYSIS_STARTED"
        case analysisSuccess = "ANALYSIS_SUCCESS"
        case analysisToBeScheduled = "ANALYSIS_TO_BE_SCHEDULED"
        case configured = "CONFIGURED"
        case unconfigured = "UNCONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum Strategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case refactor = "Refactor"
        case rehost = "Rehost"
        case relocate = "Relocate"
        case replatform = "Replatform"
        case repurchase = "Repurchase"
        case retain = "Retain"
        case retirement = "Retirement"
        public var description: String { return self.rawValue }
    }

    public enum StrategyRecommendation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notRecommended = "notRecommended"
        case potential = "potential"
        case recommended = "recommended"
        case viableOption = "viableOption"
        public var description: String { return self.rawValue }
    }

    public enum TargetDatabaseEngine: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsPostgresql = "AWS PostgreSQL"
        case amazonAurora = "Amazon Aurora"
        case db2LUW = "Db2 LUW"
        case mariaDB = "MariaDB"
        case microsoftSQLServer = "Microsoft SQL Server"
        case mongoDB = "MongoDB"
        case mySQL = "MySQL"
        case noneSpecified = "None specified"
        case oracleDatabase = "Oracle Database"
        case sap = "SAP"
        public var description: String { return self.rawValue }
    }

    public enum TargetDestination: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsElasticBeanstalk = "AWS Elastic BeanStalk"
        case awsFargate = "AWS Fargate"
        case amazonDocumentdb = "Amazon DocumentDB"
        case amazonDynamodb = "Amazon DynamoDB"
        case amazonElasticCloudComputeEC2 = "Amazon Elastic Cloud Compute (EC2)"
        case amazonElasticContainerServiceECS = "Amazon Elastic Container Service (ECS)"
        case amazonElasticKubernetesServiceEKS = "Amazon Elastic Kubernetes Service (EKS)"
        case amazonRelationalDatabaseService = "Amazon Relational Database Service"
        case amazonRelationalDatabaseServiceOnMysql = "Amazon Relational Database Service on MySQL"
        case amazonRelationalDatabaseServiceOnPostgresql = "Amazon Relational Database Service on PostgreSQL"
        case auroraMysql = "Aurora MySQL"
        case auroraPostgresql = "Aurora PostgreSQL"
        case babelfishForAuroraPostgresql = "Babelfish for Aurora PostgreSQL"
        case noneSpecified = "None specified"
        public var description: String { return self.rawValue }
    }

    public enum TransformationToolName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case app2Container = "App2Container"
        case applicationMigrationService = "Application Migration Service"
        case databaseMigrationService = "Database Migration Service"
        case endOfSupportMigration = "End of Support Migration"
        case inPlaceOperatingSystemUpgrade = "In Place Operating System Upgrade"
        case nativeSQLServerBackupRestore = "Native SQL Server Backup/Restore"
        case portingAssistantForNET = "Porting Assistant For .NET"
        case schemaConversionTool = "Schema Conversion Tool"
        case strategyRecommendationSupport = "Strategy Recommendation Support"
        case windowsWebApplicationMigrationAssistant = "Windows Web Application Migration Assistant"
        public var description: String { return self.rawValue }
    }

    public enum VersionControl: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case azureDevopsGit = "AZURE_DEVOPS_GIT"
        case github = "GITHUB"
        case githubEnterprise = "GITHUB_ENTERPRISE"
        public var description: String { return self.rawValue }
    }

    public enum VersionControlType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case azureDevopsGit = "AZURE_DEVOPS_GIT"
        case github = "GITHUB"
        case githubEnterprise = "GITHUB_ENTERPRISE"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisStatusUnion: AWSDecodableShape, Sendable {
        /// The status of the analysis.
        case runtimeAnalysisStatus(RuntimeAnalysisStatus)
        /// The status of the source code or database analysis.
        case srcCodeOrDbAnalysisStatus(SrcCodeOrDbAnalysisStatus)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .runtimeAnalysisStatus:
                let value = try container.decode(RuntimeAnalysisStatus.self, forKey: .runtimeAnalysisStatus)
                self = .runtimeAnalysisStatus(value)
            case .srcCodeOrDbAnalysisStatus:
                let value = try container.decode(SrcCodeOrDbAnalysisStatus.self, forKey: .srcCodeOrDbAnalysisStatus)
                self = .srcCodeOrDbAnalysisStatus(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case runtimeAnalysisStatus = "runtimeAnalysisStatus"
            case srcCodeOrDbAnalysisStatus = "srcCodeOrDbAnalysisStatus"
        }
    }

    public enum AnalyzerNameUnion: AWSDecodableShape, Sendable {
        /// The binary analyzer names.
        case binaryAnalyzerName(BinaryAnalyzerName)
        /// The assessment analyzer names.
        case runTimeAnalyzerName(RunTimeAnalyzerName)
        /// The source code analyzer names.
        case sourceCodeAnalyzerName(SourceCodeAnalyzerName)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .binaryAnalyzerName:
                let value = try container.decode(BinaryAnalyzerName.self, forKey: .binaryAnalyzerName)
                self = .binaryAnalyzerName(value)
            case .runTimeAnalyzerName:
                let value = try container.decode(RunTimeAnalyzerName.self, forKey: .runTimeAnalyzerName)
                self = .runTimeAnalyzerName(value)
            case .sourceCodeAnalyzerName:
                let value = try container.decode(SourceCodeAnalyzerName.self, forKey: .sourceCodeAnalyzerName)
                self = .sourceCodeAnalyzerName(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case binaryAnalyzerName = "binaryAnalyzerName"
            case runTimeAnalyzerName = "runTimeAnalyzerName"
            case sourceCodeAnalyzerName = "sourceCodeAnalyzerName"
        }
    }

    public enum DatabaseMigrationPreference: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  Indicates whether you are interested in moving from one type of database to another. For example, from SQL Server to Amazon Aurora MySQL-Compatible Edition.
        case heterogeneous(Heterogeneous)
        ///  Indicates whether you are interested in moving to the same type of database into AWS. For example, from SQL Server in your environment to SQL Server on AWS.
        case homogeneous(Homogeneous)
        ///  Indicated that you do not prefer heterogeneous or homogeneous.
        case noPreference(NoDatabaseMigrationPreference)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .heterogeneous:
                let value = try container.decode(Heterogeneous.self, forKey: .heterogeneous)
                self = .heterogeneous(value)
            case .homogeneous:
                let value = try container.decode(Homogeneous.self, forKey: .homogeneous)
                self = .homogeneous(value)
            case .noPreference:
                let value = try container.decode(NoDatabaseMigrationPreference.self, forKey: .noPreference)
                self = .noPreference(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .heterogeneous(let value):
                try container.encode(value, forKey: .heterogeneous)
            case .homogeneous(let value):
                try container.encode(value, forKey: .homogeneous)
            case .noPreference(let value):
                try container.encode(value, forKey: .noPreference)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .heterogeneous(let value):
                try value.validate(name: "\(name).heterogeneous")
            case .homogeneous(let value):
                try value.validate(name: "\(name).homogeneous")
            case .noPreference(let value):
                try value.validate(name: "\(name).noPreference")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case heterogeneous = "heterogeneous"
            case homogeneous = "homogeneous"
            case noPreference = "noPreference"
        }
    }

    public enum ManagementPreference: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  Indicates interest in solutions that are managed by AWS.
        case awsManagedResources(AwsManagedResources)
        ///  No specific preference.
        case noPreference(NoManagementPreference)
        ///  Indicates interest in managing your own resources on AWS.
        case selfManageResources(SelfManageResources)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .awsManagedResources:
                let value = try container.decode(AwsManagedResources.self, forKey: .awsManagedResources)
                self = .awsManagedResources(value)
            case .noPreference:
                let value = try container.decode(NoManagementPreference.self, forKey: .noPreference)
                self = .noPreference(value)
            case .selfManageResources:
                let value = try container.decode(SelfManageResources.self, forKey: .selfManageResources)
                self = .selfManageResources(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .awsManagedResources(let value):
                try container.encode(value, forKey: .awsManagedResources)
            case .noPreference(let value):
                try container.encode(value, forKey: .noPreference)
            case .selfManageResources(let value):
                try container.encode(value, forKey: .selfManageResources)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .awsManagedResources(let value):
                try value.validate(name: "\(name).awsManagedResources")
            case .noPreference(let value):
                try value.validate(name: "\(name).noPreference")
            case .selfManageResources(let value):
                try value.validate(name: "\(name).selfManageResources")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsManagedResources = "awsManagedResources"
            case noPreference = "noPreference"
            case selfManageResources = "selfManageResources"
        }
    }

    // MARK: Shapes

    public struct AnalyzableServerSummary: AWSDecodableShape {
        /// The host name of the analyzable server.
        public let hostname: String?
        /// The ip address of the analyzable server.
        public let ipAddress: String?
        /// The data source of the analyzable server.
        public let source: String?
        /// The virtual machine id of the analyzable server.
        public let vmId: String?

        @inlinable
        public init(hostname: String? = nil, ipAddress: String? = nil, source: String? = nil, vmId: String? = nil) {
            self.hostname = hostname
            self.ipAddress = ipAddress
            self.source = source
            self.vmId = vmId
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "hostname"
            case ipAddress = "ipAddress"
            case source = "source"
            case vmId = "vmId"
        }
    }

    public struct AntipatternReportResult: AWSDecodableShape {
        /// The analyzer name.
        public let analyzerName: AnalyzerNameUnion?
        public let antiPatternReportS3Object: S3Object?
        /// The status of the anti-pattern report generation.
        public let antipatternReportStatus: AntipatternReportStatus?
        /// The status message for the anti-pattern.
        public let antipatternReportStatusMessage: String?

        @inlinable
        public init(analyzerName: AnalyzerNameUnion? = nil, antiPatternReportS3Object: S3Object? = nil, antipatternReportStatus: AntipatternReportStatus? = nil, antipatternReportStatusMessage: String? = nil) {
            self.analyzerName = analyzerName
            self.antiPatternReportS3Object = antiPatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case analyzerName = "analyzerName"
            case antiPatternReportS3Object = "antiPatternReportS3Object"
            case antipatternReportStatus = "antipatternReportStatus"
            case antipatternReportStatusMessage = "antipatternReportStatusMessage"
        }
    }

    public struct AntipatternSeveritySummary: AWSDecodableShape {
        ///  Contains the count of anti-patterns.
        public let count: Int?
        ///  Contains the severity of anti-patterns.
        public let severity: Severity?

        @inlinable
        public init(count: Int? = nil, severity: Severity? = nil) {
            self.count = count
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case severity = "severity"
        }
    }

    public struct AppUnitError: AWSDecodableShape {
        /// The category of the error.
        public let appUnitErrorCategory: AppUnitErrorCategory?

        @inlinable
        public init(appUnitErrorCategory: AppUnitErrorCategory? = nil) {
            self.appUnitErrorCategory = appUnitErrorCategory
        }

        private enum CodingKeys: String, CodingKey {
            case appUnitErrorCategory = "appUnitErrorCategory"
        }
    }

    public struct ApplicationComponentDetail: AWSDecodableShape {
        ///  The status of analysis, if the application component has source code or an associated database.
        public let analysisStatus: SrcCodeOrDbAnalysisStatus?
        ///  The S3 bucket name and the Amazon S3 key name for the anti-pattern report.
        public let antipatternReportS3Object: S3Object?
        ///  The status of the anti-pattern report generation.
        public let antipatternReportStatus: AntipatternReportStatus?
        ///  The status message for the anti-pattern.
        public let antipatternReportStatusMessage: String?
        ///  The type of application component.
        public let appType: AppType?
        /// The error in the analysis of the source code or database.
        public let appUnitError: AppUnitError?
        ///  The ID of the server that the application component is running on.
        public let associatedServerId: String?
        ///  Configuration details for the database associated with the application component.
        public let databaseConfigDetail: DatabaseConfigDetail?
        ///  The ID of the application component.
        public let id: String?
        ///  Indicates whether the application component has been included for server recommendation or not.
        public let inclusionStatus: InclusionStatus?
        ///  The timestamp of when the application component was assessed.
        public let lastAnalyzedTimestamp: Date?
        ///  A list of anti-pattern severity summaries.
        public let listAntipatternSeveritySummary: [AntipatternSeveritySummary]?
        ///  Set to true if the application component is running on multiple servers.
        public let moreServerAssociationExists: Bool?
        ///  The name of application component.
        public let name: String?
        ///  OS driver.
        public let osDriver: String?
        ///  OS version.
        public let osVersion: String?
        ///  The top recommendation set for the application component.
        public let recommendationSet: RecommendationSet?
        ///  The application component subtype.
        public let resourceSubType: ResourceSubType?
        /// A list of the analysis results.
        public let resultList: [Result]?
        /// The status of the application unit.
        public let runtimeStatus: RuntimeAnalysisStatus?
        /// The status message for the application unit.
        public let runtimeStatusMessage: String?
        ///  Details about the source code repository associated with the application component.
        public let sourceCodeRepositories: [SourceCodeRepository]?
        ///  A detailed description of the analysis status and any failure message.
        public let statusMessage: String?

        @inlinable
        public init(analysisStatus: SrcCodeOrDbAnalysisStatus? = nil, antipatternReportS3Object: S3Object? = nil, antipatternReportStatus: AntipatternReportStatus? = nil, antipatternReportStatusMessage: String? = nil, appType: AppType? = nil, appUnitError: AppUnitError? = nil, associatedServerId: String? = nil, databaseConfigDetail: DatabaseConfigDetail? = nil, id: String? = nil, inclusionStatus: InclusionStatus? = nil, lastAnalyzedTimestamp: Date? = nil, listAntipatternSeveritySummary: [AntipatternSeveritySummary]? = nil, moreServerAssociationExists: Bool? = nil, name: String? = nil, osDriver: String? = nil, osVersion: String? = nil, recommendationSet: RecommendationSet? = nil, resourceSubType: ResourceSubType? = nil, resultList: [Result]? = nil, runtimeStatus: RuntimeAnalysisStatus? = nil, runtimeStatusMessage: String? = nil, sourceCodeRepositories: [SourceCodeRepository]? = nil, statusMessage: String? = nil) {
            self.analysisStatus = analysisStatus
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.appType = appType
            self.appUnitError = appUnitError
            self.associatedServerId = associatedServerId
            self.databaseConfigDetail = databaseConfigDetail
            self.id = id
            self.inclusionStatus = inclusionStatus
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.moreServerAssociationExists = moreServerAssociationExists
            self.name = name
            self.osDriver = osDriver
            self.osVersion = osVersion
            self.recommendationSet = recommendationSet
            self.resourceSubType = resourceSubType
            self.resultList = resultList
            self.runtimeStatus = runtimeStatus
            self.runtimeStatusMessage = runtimeStatusMessage
            self.sourceCodeRepositories = sourceCodeRepositories
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case analysisStatus = "analysisStatus"
            case antipatternReportS3Object = "antipatternReportS3Object"
            case antipatternReportStatus = "antipatternReportStatus"
            case antipatternReportStatusMessage = "antipatternReportStatusMessage"
            case appType = "appType"
            case appUnitError = "appUnitError"
            case associatedServerId = "associatedServerId"
            case databaseConfigDetail = "databaseConfigDetail"
            case id = "id"
            case inclusionStatus = "inclusionStatus"
            case lastAnalyzedTimestamp = "lastAnalyzedTimestamp"
            case listAntipatternSeveritySummary = "listAntipatternSeveritySummary"
            case moreServerAssociationExists = "moreServerAssociationExists"
            case name = "name"
            case osDriver = "osDriver"
            case osVersion = "osVersion"
            case recommendationSet = "recommendationSet"
            case resourceSubType = "resourceSubType"
            case resultList = "resultList"
            case runtimeStatus = "runtimeStatus"
            case runtimeStatusMessage = "runtimeStatusMessage"
            case sourceCodeRepositories = "sourceCodeRepositories"
            case statusMessage = "statusMessage"
        }
    }

    public struct ApplicationComponentStatusSummary: AWSDecodableShape {
        /// The number of application components successfully analyzed, partially successful or failed analysis.
        public let count: Int?
        /// The status of database analysis.
        public let srcCodeOrDbAnalysisStatus: SrcCodeOrDbAnalysisStatus?

        @inlinable
        public init(count: Int? = nil, srcCodeOrDbAnalysisStatus: SrcCodeOrDbAnalysisStatus? = nil) {
            self.count = count
            self.srcCodeOrDbAnalysisStatus = srcCodeOrDbAnalysisStatus
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case srcCodeOrDbAnalysisStatus = "srcCodeOrDbAnalysisStatus"
        }
    }

    public struct ApplicationComponentStrategy: AWSDecodableShape {
        ///  Set to true if the recommendation is set as preferred.
        public let isPreferred: Bool?
        ///  Strategy recommendation for the application component.
        public let recommendation: RecommendationSet?
        ///  The recommendation status of a strategy for an application component.
        public let status: StrategyRecommendation?

        @inlinable
        public init(isPreferred: Bool? = nil, recommendation: RecommendationSet? = nil, status: StrategyRecommendation? = nil) {
            self.isPreferred = isPreferred
            self.recommendation = recommendation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case isPreferred = "isPreferred"
            case recommendation = "recommendation"
            case status = "status"
        }
    }

    public struct ApplicationComponentSummary: AWSDecodableShape {
        ///  Contains the name of application types.
        public let appType: AppType?
        ///  Contains the count of application type.
        public let count: Int?

        @inlinable
        public init(appType: AppType? = nil, count: Int? = nil) {
            self.appType = appType
            self.count = count
        }

        private enum CodingKeys: String, CodingKey {
            case appType = "appType"
            case count = "count"
        }
    }

    public struct ApplicationPreferences: AWSEncodableShape & AWSDecodableShape {
        ///  Application preferences that you specify to prefer managed environment.
        public let managementPreference: ManagementPreference?

        @inlinable
        public init(managementPreference: ManagementPreference? = nil) {
            self.managementPreference = managementPreference
        }

        public func validate(name: String) throws {
            try self.managementPreference?.validate(name: "\(name).managementPreference")
        }

        private enum CodingKeys: String, CodingKey {
            case managementPreference = "managementPreference"
        }
    }

    public struct AssessmentSummary: AWSDecodableShape {
        ///  The Amazon S3 object containing the anti-pattern report.
        public let antipatternReportS3Object: S3Object?
        ///  The status of the anti-pattern report.
        public let antipatternReportStatus: AntipatternReportStatus?
        ///  The status message of the anti-pattern report.
        public let antipatternReportStatusMessage: String?
        ///  The time the assessment was performed.
        public let lastAnalyzedTimestamp: Date?
        ///  List of AntipatternSeveritySummary.
        public let listAntipatternSeveritySummary: [AntipatternSeveritySummary]?
        /// List of status summaries of the analyzed application components.
        public let listApplicationComponentStatusSummary: [ApplicationComponentStatusSummary]?
        ///  List of ApplicationComponentStrategySummary.
        public let listApplicationComponentStrategySummary: [StrategySummary]?
        ///  List of ApplicationComponentSummary.
        public let listApplicationComponentSummary: [ApplicationComponentSummary]?
        /// List of status summaries of the analyzed servers.
        public let listServerStatusSummary: [ServerStatusSummary]?
        ///  List of ServerStrategySummary.
        public let listServerStrategySummary: [StrategySummary]?
        ///  List of ServerSummary.
        public let listServerSummary: [ServerSummary]?

        @inlinable
        public init(antipatternReportS3Object: S3Object? = nil, antipatternReportStatus: AntipatternReportStatus? = nil, antipatternReportStatusMessage: String? = nil, lastAnalyzedTimestamp: Date? = nil, listAntipatternSeveritySummary: [AntipatternSeveritySummary]? = nil, listApplicationComponentStatusSummary: [ApplicationComponentStatusSummary]? = nil, listApplicationComponentStrategySummary: [StrategySummary]? = nil, listApplicationComponentSummary: [ApplicationComponentSummary]? = nil, listServerStatusSummary: [ServerStatusSummary]? = nil, listServerStrategySummary: [StrategySummary]? = nil, listServerSummary: [ServerSummary]? = nil) {
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.listApplicationComponentStatusSummary = listApplicationComponentStatusSummary
            self.listApplicationComponentStrategySummary = listApplicationComponentStrategySummary
            self.listApplicationComponentSummary = listApplicationComponentSummary
            self.listServerStatusSummary = listServerStatusSummary
            self.listServerStrategySummary = listServerStrategySummary
            self.listServerSummary = listServerSummary
        }

        private enum CodingKeys: String, CodingKey {
            case antipatternReportS3Object = "antipatternReportS3Object"
            case antipatternReportStatus = "antipatternReportStatus"
            case antipatternReportStatusMessage = "antipatternReportStatusMessage"
            case lastAnalyzedTimestamp = "lastAnalyzedTimestamp"
            case listAntipatternSeveritySummary = "listAntipatternSeveritySummary"
            case listApplicationComponentStatusSummary = "listApplicationComponentStatusSummary"
            case listApplicationComponentStrategySummary = "listApplicationComponentStrategySummary"
            case listApplicationComponentSummary = "listApplicationComponentSummary"
            case listServerStatusSummary = "listServerStatusSummary"
            case listServerStrategySummary = "listServerStrategySummary"
            case listServerSummary = "listServerSummary"
        }
    }

    public struct AssessmentTarget: AWSEncodableShape & AWSDecodableShape {
        /// Condition of an assessment.
        public let condition: Condition
        /// Name of an assessment.
        public let name: String
        /// Values of an assessment.
        public let values: [String]

        @inlinable
        public init(condition: Condition, name: String, values: [String]) {
            self.condition = condition
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1024)
                try validate($0, name: "values[]", parent: name, pattern: ".*\\S.*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "condition"
            case name = "name"
            case values = "values"
        }
    }

    public struct AssociatedApplication: AWSDecodableShape {
        ///  ID of the application as defined in Application Discovery Service.
        public let id: String?
        ///  Name of the application as defined in Application Discovery Service.
        public let name: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct AwsManagedResources: AWSEncodableShape & AWSDecodableShape {
        ///  The choice of application destination that you specify.
        public let targetDestination: [AwsManagedTargetDestination]

        @inlinable
        public init(targetDestination: [AwsManagedTargetDestination]) {
            self.targetDestination = targetDestination
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, max: 1)
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDestination = "targetDestination"
        }
    }

    public struct BusinessGoals: AWSEncodableShape & AWSDecodableShape {
        ///  Business goal to reduce license costs.
        public let licenseCostReduction: Int?
        ///  Business goal to modernize infrastructure by moving to cloud native technologies.
        public let modernizeInfrastructureWithCloudNativeTechnologies: Int?
        ///  Business goal to reduce the operational overhead on the team by moving into managed services.
        public let reduceOperationalOverheadWithManagedServices: Int?
        ///  Business goal to achieve migration at a fast pace.
        public let speedOfMigration: Int?

        @inlinable
        public init(licenseCostReduction: Int? = nil, modernizeInfrastructureWithCloudNativeTechnologies: Int? = nil, reduceOperationalOverheadWithManagedServices: Int? = nil, speedOfMigration: Int? = nil) {
            self.licenseCostReduction = licenseCostReduction
            self.modernizeInfrastructureWithCloudNativeTechnologies = modernizeInfrastructureWithCloudNativeTechnologies
            self.reduceOperationalOverheadWithManagedServices = reduceOperationalOverheadWithManagedServices
            self.speedOfMigration = speedOfMigration
        }

        public func validate(name: String) throws {
            try self.validate(self.licenseCostReduction, name: "licenseCostReduction", parent: name, max: 5)
            try self.validate(self.licenseCostReduction, name: "licenseCostReduction", parent: name, min: 1)
            try self.validate(self.modernizeInfrastructureWithCloudNativeTechnologies, name: "modernizeInfrastructureWithCloudNativeTechnologies", parent: name, max: 5)
            try self.validate(self.modernizeInfrastructureWithCloudNativeTechnologies, name: "modernizeInfrastructureWithCloudNativeTechnologies", parent: name, min: 1)
            try self.validate(self.reduceOperationalOverheadWithManagedServices, name: "reduceOperationalOverheadWithManagedServices", parent: name, max: 5)
            try self.validate(self.reduceOperationalOverheadWithManagedServices, name: "reduceOperationalOverheadWithManagedServices", parent: name, min: 1)
            try self.validate(self.speedOfMigration, name: "speedOfMigration", parent: name, max: 5)
            try self.validate(self.speedOfMigration, name: "speedOfMigration", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case licenseCostReduction = "licenseCostReduction"
            case modernizeInfrastructureWithCloudNativeTechnologies = "modernizeInfrastructureWithCloudNativeTechnologies"
            case reduceOperationalOverheadWithManagedServices = "reduceOperationalOverheadWithManagedServices"
            case speedOfMigration = "speedOfMigration"
        }
    }

    public struct Collector: AWSDecodableShape {
        ///  Indicates the health of a collector.
        public let collectorHealth: CollectorHealth?
        ///  The ID of the collector.
        public let collectorId: String?
        ///  Current version of the collector that is running in the environment that you specify.
        public let collectorVersion: String?
        /// Summary of the collector configuration.
        public let configurationSummary: ConfigurationSummary?
        ///  Hostname of the server that is hosting the collector.
        public let hostName: String?
        ///  IP address of the server that is hosting the collector.
        public let ipAddress: String?
        ///  Time when the collector last pinged the service.
        public let lastActivityTimeStamp: String?
        ///  Time when the collector registered with the service.
        public let registeredTimeStamp: String?

        @inlinable
        public init(collectorHealth: CollectorHealth? = nil, collectorId: String? = nil, collectorVersion: String? = nil, configurationSummary: ConfigurationSummary? = nil, hostName: String? = nil, ipAddress: String? = nil, lastActivityTimeStamp: String? = nil, registeredTimeStamp: String? = nil) {
            self.collectorHealth = collectorHealth
            self.collectorId = collectorId
            self.collectorVersion = collectorVersion
            self.configurationSummary = configurationSummary
            self.hostName = hostName
            self.ipAddress = ipAddress
            self.lastActivityTimeStamp = lastActivityTimeStamp
            self.registeredTimeStamp = registeredTimeStamp
        }

        private enum CodingKeys: String, CodingKey {
            case collectorHealth = "collectorHealth"
            case collectorId = "collectorId"
            case collectorVersion = "collectorVersion"
            case configurationSummary = "configurationSummary"
            case hostName = "hostName"
            case ipAddress = "ipAddress"
            case lastActivityTimeStamp = "lastActivityTimeStamp"
            case registeredTimeStamp = "registeredTimeStamp"
        }
    }

    public struct ConfigurationSummary: AWSDecodableShape {
        /// IP address based configurations.
        public let ipAddressBasedRemoteInfoList: [IPAddressBasedRemoteInfo]?
        /// The list of pipeline info configurations.
        public let pipelineInfoList: [PipelineInfo]?
        /// Info about the remote server source code configuration.
        public let remoteSourceCodeAnalysisServerInfo: RemoteSourceCodeAnalysisServerInfo?
        /// The list of vCenter configurations.
        public let vcenterBasedRemoteInfoList: [VcenterBasedRemoteInfo]?
        /// The list of the version control configurations.
        public let versionControlInfoList: [VersionControlInfo]?

        @inlinable
        public init(ipAddressBasedRemoteInfoList: [IPAddressBasedRemoteInfo]? = nil, pipelineInfoList: [PipelineInfo]? = nil, remoteSourceCodeAnalysisServerInfo: RemoteSourceCodeAnalysisServerInfo? = nil, vcenterBasedRemoteInfoList: [VcenterBasedRemoteInfo]? = nil, versionControlInfoList: [VersionControlInfo]? = nil) {
            self.ipAddressBasedRemoteInfoList = ipAddressBasedRemoteInfoList
            self.pipelineInfoList = pipelineInfoList
            self.remoteSourceCodeAnalysisServerInfo = remoteSourceCodeAnalysisServerInfo
            self.vcenterBasedRemoteInfoList = vcenterBasedRemoteInfoList
            self.versionControlInfoList = versionControlInfoList
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddressBasedRemoteInfoList = "ipAddressBasedRemoteInfoList"
            case pipelineInfoList = "pipelineInfoList"
            case remoteSourceCodeAnalysisServerInfo = "remoteSourceCodeAnalysisServerInfo"
            case vcenterBasedRemoteInfoList = "vcenterBasedRemoteInfoList"
            case versionControlInfoList = "versionControlInfoList"
        }
    }

    public struct DataCollectionDetails: AWSDecodableShape {
        ///  The time the assessment completes.
        public let completionTime: Date?
        ///  The number of failed servers in the assessment.
        public let failed: Int?
        ///  The number of servers with the assessment status IN_PROGESS.
        public let inProgress: Int?
        ///  The total number of servers in the assessment.
        public let servers: Int?
        ///  The start time of assessment.
        public let startTime: Date?
        ///  The status of the assessment.
        public let status: AssessmentStatus?
        /// The status message of the assessment.
        public let statusMessage: String?
        ///  The number of successful servers in the assessment.
        public let success: Int?

        @inlinable
        public init(completionTime: Date? = nil, failed: Int? = nil, inProgress: Int? = nil, servers: Int? = nil, startTime: Date? = nil, status: AssessmentStatus? = nil, statusMessage: String? = nil, success: Int? = nil) {
            self.completionTime = completionTime
            self.failed = failed
            self.inProgress = inProgress
            self.servers = servers
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.success = success
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case failed = "failed"
            case inProgress = "inProgress"
            case servers = "servers"
            case startTime = "startTime"
            case status = "status"
            case statusMessage = "statusMessage"
            case success = "success"
        }
    }

    public struct DatabaseConfigDetail: AWSDecodableShape {
        ///  AWS Secrets Manager key that holds the credentials that you use to connect to a database.
        public let secretName: String?

        @inlinable
        public init(secretName: String? = nil) {
            self.secretName = secretName
        }

        private enum CodingKeys: String, CodingKey {
            case secretName = "secretName"
        }
    }

    public struct DatabasePreferences: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies whether you're interested in self-managed databases or databases managed by AWS.
        public let databaseManagementPreference: DatabaseManagementPreference?
        ///  Specifies your preferred migration path.
        public let databaseMigrationPreference: DatabaseMigrationPreference?

        @inlinable
        public init(databaseManagementPreference: DatabaseManagementPreference? = nil, databaseMigrationPreference: DatabaseMigrationPreference? = nil) {
            self.databaseManagementPreference = databaseManagementPreference
            self.databaseMigrationPreference = databaseMigrationPreference
        }

        public func validate(name: String) throws {
            try self.databaseMigrationPreference?.validate(name: "\(name).databaseMigrationPreference")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseManagementPreference = "databaseManagementPreference"
            case databaseMigrationPreference = "databaseMigrationPreference"
        }
    }

    public struct GetApplicationComponentDetailsRequest: AWSEncodableShape {
        ///  The ID of the application component. The ID is unique within an AWS account.
        public let applicationComponentId: String

        @inlinable
        public init(applicationComponentId: String) {
            self.applicationComponentId = applicationComponentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationComponentId, key: "applicationComponentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, max: 44)
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, pattern: "[0-9a-zA-Z-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationComponentDetailsResponse: AWSDecodableShape {
        ///  Detailed information about an application component.
        public let applicationComponentDetail: ApplicationComponentDetail?
        ///  The associated application group as defined in AWS Application Discovery Service.
        public let associatedApplications: [AssociatedApplication]?
        ///  A list of the IDs of the servers on which the application component is running.
        public let associatedServerIds: [String]?
        ///  Set to true if the application component belongs to more than one application group.
        public let moreApplicationResource: Bool?

        @inlinable
        public init(applicationComponentDetail: ApplicationComponentDetail? = nil, associatedApplications: [AssociatedApplication]? = nil, associatedServerIds: [String]? = nil, moreApplicationResource: Bool? = nil) {
            self.applicationComponentDetail = applicationComponentDetail
            self.associatedApplications = associatedApplications
            self.associatedServerIds = associatedServerIds
            self.moreApplicationResource = moreApplicationResource
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentDetail = "applicationComponentDetail"
            case associatedApplications = "associatedApplications"
            case associatedServerIds = "associatedServerIds"
            case moreApplicationResource = "moreApplicationResource"
        }
    }

    public struct GetApplicationComponentStrategiesRequest: AWSEncodableShape {
        ///  The ID of the application component. The ID is unique within an AWS account.
        public let applicationComponentId: String

        @inlinable
        public init(applicationComponentId: String) {
            self.applicationComponentId = applicationComponentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationComponentId, key: "applicationComponentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, max: 44)
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, pattern: "[0-9a-zA-Z-]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationComponentStrategiesResponse: AWSDecodableShape {
        ///  A list of application component strategy recommendations.
        public let applicationComponentStrategies: [ApplicationComponentStrategy]?

        @inlinable
        public init(applicationComponentStrategies: [ApplicationComponentStrategy]? = nil) {
            self.applicationComponentStrategies = applicationComponentStrategies
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentStrategies = "applicationComponentStrategies"
        }
    }

    public struct GetAssessmentRequest: AWSEncodableShape {
        ///  The assessmentid returned by StartAssessment.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 52)
            try self.validate(self.id, name: "id", parent: name, pattern: "[0-9a-z-:]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssessmentResponse: AWSDecodableShape {
        /// List of criteria for assessment.
        public let assessmentTargets: [AssessmentTarget]?
        ///  Detailed information about the assessment.
        public let dataCollectionDetails: DataCollectionDetails?
        ///  The ID for the specific assessment task.
        public let id: String?

        @inlinable
        public init(assessmentTargets: [AssessmentTarget]? = nil, dataCollectionDetails: DataCollectionDetails? = nil, id: String? = nil) {
            self.assessmentTargets = assessmentTargets
            self.dataCollectionDetails = dataCollectionDetails
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentTargets = "assessmentTargets"
            case dataCollectionDetails = "dataCollectionDetails"
            case id = "id"
        }
    }

    public struct GetImportFileTaskRequest: AWSEncodableShape {
        ///  The ID of the import file task. This ID is returned in the response of StartImportFileTask.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 1024)
            try self.validate(self.id, name: "id", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImportFileTaskResponse: AWSDecodableShape {
        ///  The time that the import task completed.
        public let completionTime: Date?
        ///  The import file task id returned in the response of StartImportFileTask.
        public let id: String?
        ///  The name of the import task given in StartImportFileTask.
        public let importName: String?
        ///  The S3 bucket where import file is located.
        public let inputS3Bucket: String?
        ///  The Amazon S3 key name of the import file.
        public let inputS3Key: String?
        ///  The number of records that failed to be imported.
        public let numberOfRecordsFailed: Int?
        ///  The number of records successfully imported.
        public let numberOfRecordsSuccess: Int?
        ///  Start time of the import task.
        public let startTime: Date?
        ///  Status of import file task.
        public let status: ImportFileTaskStatus?
        ///  The S3 bucket name for status report of import task.
        public let statusReportS3Bucket: String?
        ///  The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not.
        public let statusReportS3Key: String?

        @inlinable
        public init(completionTime: Date? = nil, id: String? = nil, importName: String? = nil, inputS3Bucket: String? = nil, inputS3Key: String? = nil, numberOfRecordsFailed: Int? = nil, numberOfRecordsSuccess: Int? = nil, startTime: Date? = nil, status: ImportFileTaskStatus? = nil, statusReportS3Bucket: String? = nil, statusReportS3Key: String? = nil) {
            self.completionTime = completionTime
            self.id = id
            self.importName = importName
            self.inputS3Bucket = inputS3Bucket
            self.inputS3Key = inputS3Key
            self.numberOfRecordsFailed = numberOfRecordsFailed
            self.numberOfRecordsSuccess = numberOfRecordsSuccess
            self.startTime = startTime
            self.status = status
            self.statusReportS3Bucket = statusReportS3Bucket
            self.statusReportS3Key = statusReportS3Key
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case id = "id"
            case importName = "importName"
            case inputS3Bucket = "inputS3Bucket"
            case inputS3Key = "inputS3Key"
            case numberOfRecordsFailed = "numberOfRecordsFailed"
            case numberOfRecordsSuccess = "numberOfRecordsSuccess"
            case startTime = "startTime"
            case status = "status"
            case statusReportS3Bucket = "statusReportS3Bucket"
            case statusReportS3Key = "statusReportS3Key"
        }
    }

    public struct GetLatestAssessmentIdRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetLatestAssessmentIdResponse: AWSDecodableShape {
        /// The latest ID for the specific assessment task.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct GetPortfolioPreferencesRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetPortfolioPreferencesResponse: AWSDecodableShape {
        /// The classification for application component types.
        public let applicationMode: ApplicationMode?
        ///  The transformation preferences for non-database applications.
        public let applicationPreferences: ApplicationPreferences?
        ///  The transformation preferences for database applications.
        public let databasePreferences: DatabasePreferences?
        ///  The rank of business goals based on priority.
        public let prioritizeBusinessGoals: PrioritizeBusinessGoals?

        @inlinable
        public init(applicationMode: ApplicationMode? = nil, applicationPreferences: ApplicationPreferences? = nil, databasePreferences: DatabasePreferences? = nil, prioritizeBusinessGoals: PrioritizeBusinessGoals? = nil) {
            self.applicationMode = applicationMode
            self.applicationPreferences = applicationPreferences
            self.databasePreferences = databasePreferences
            self.prioritizeBusinessGoals = prioritizeBusinessGoals
        }

        private enum CodingKeys: String, CodingKey {
            case applicationMode = "applicationMode"
            case applicationPreferences = "applicationPreferences"
            case databasePreferences = "databasePreferences"
            case prioritizeBusinessGoals = "prioritizeBusinessGoals"
        }
    }

    public struct GetPortfolioSummaryRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetPortfolioSummaryResponse: AWSDecodableShape {
        ///  An assessment summary for the portfolio including the number of servers to rehost and the overall number of anti-patterns.
        public let assessmentSummary: AssessmentSummary?

        @inlinable
        public init(assessmentSummary: AssessmentSummary? = nil) {
            self.assessmentSummary = assessmentSummary
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentSummary = "assessmentSummary"
        }
    }

    public struct GetRecommendationReportDetailsRequest: AWSEncodableShape {
        ///  The recommendation report generation task id returned by StartRecommendationReportGeneration.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 52)
            try self.validate(self.id, name: "id", parent: name, pattern: "[0-9a-z-:]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecommendationReportDetailsResponse: AWSDecodableShape {
        ///  The ID of the recommendation report generation task. See the response of StartRecommendationReportGeneration.
        public let id: String?
        ///  Detailed information about the recommendation report.
        public let recommendationReportDetails: RecommendationReportDetails?

        @inlinable
        public init(id: String? = nil, recommendationReportDetails: RecommendationReportDetails? = nil) {
            self.id = id
            self.recommendationReportDetails = recommendationReportDetails
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case recommendationReportDetails = "recommendationReportDetails"
        }
    }

    public struct GetServerDetailsRequest: AWSEncodableShape {
        ///  The maximum number of items to include in the response. The maximum value is 100.
        public let maxResults: Int?
        ///  The token from a previous call that you use to retrieve the next set of results. For example,
        /// if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?
        ///  The ID of the server.
        public let serverId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, serverId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serverId = serverId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.serverId, key: "serverId")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
            try self.validate(self.serverId, name: "serverId", parent: name, max: 27)
            try self.validate(self.serverId, name: "serverId", parent: name, min: 1)
            try self.validate(self.serverId, name: "serverId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServerDetailsResponse: AWSDecodableShape {
        ///  The associated application group the server belongs to, as defined in AWS Application Discovery Service.
        public let associatedApplications: [AssociatedApplication]?
        ///  The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  Detailed information about the server.
        public let serverDetail: ServerDetail?

        @inlinable
        public init(associatedApplications: [AssociatedApplication]? = nil, nextToken: String? = nil, serverDetail: ServerDetail? = nil) {
            self.associatedApplications = associatedApplications
            self.nextToken = nextToken
            self.serverDetail = serverDetail
        }

        private enum CodingKeys: String, CodingKey {
            case associatedApplications = "associatedApplications"
            case nextToken = "nextToken"
            case serverDetail = "serverDetail"
        }
    }

    public struct GetServerStrategiesRequest: AWSEncodableShape {
        ///  The ID of the server.
        public let serverId: String

        @inlinable
        public init(serverId: String) {
            self.serverId = serverId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serverId, key: "serverId")
        }

        public func validate(name: String) throws {
            try self.validate(self.serverId, name: "serverId", parent: name, max: 27)
            try self.validate(self.serverId, name: "serverId", parent: name, min: 1)
            try self.validate(self.serverId, name: "serverId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServerStrategiesResponse: AWSDecodableShape {
        ///  A list of strategy recommendations for the server.
        public let serverStrategies: [ServerStrategy]?

        @inlinable
        public init(serverStrategies: [ServerStrategy]? = nil) {
            self.serverStrategies = serverStrategies
        }

        private enum CodingKeys: String, CodingKey {
            case serverStrategies = "serverStrategies"
        }
    }

    public struct Group: AWSEncodableShape {
        ///  The key of the specific import group.
        public let name: GroupName?
        ///  The value of the specific import group.
        public let value: String?

        @inlinable
        public init(name: GroupName? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct Heterogeneous: AWSEncodableShape & AWSDecodableShape {
        ///  The target database engine for heterogeneous database migration preference.
        public let targetDatabaseEngine: [HeterogeneousTargetDatabaseEngine]

        @inlinable
        public init(targetDatabaseEngine: [HeterogeneousTargetDatabaseEngine]) {
            self.targetDatabaseEngine = targetDatabaseEngine
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDatabaseEngine, name: "targetDatabaseEngine", parent: name, max: 1)
            try self.validate(self.targetDatabaseEngine, name: "targetDatabaseEngine", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDatabaseEngine = "targetDatabaseEngine"
        }
    }

    public struct Homogeneous: AWSEncodableShape & AWSDecodableShape {
        ///  The target database engine for homogeneous database migration preferences.
        public let targetDatabaseEngine: [HomogeneousTargetDatabaseEngine]?

        @inlinable
        public init(targetDatabaseEngine: [HomogeneousTargetDatabaseEngine]? = nil) {
            self.targetDatabaseEngine = targetDatabaseEngine
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDatabaseEngine, name: "targetDatabaseEngine", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDatabaseEngine = "targetDatabaseEngine"
        }
    }

    public struct IPAddressBasedRemoteInfo: AWSDecodableShape {
        /// The type of authorization.
        public let authType: AuthType?
        /// The time stamp of the configuration.
        public let ipAddressConfigurationTimeStamp: String?
        /// The type of the operating system.
        public let osType: OSType?

        @inlinable
        public init(authType: AuthType? = nil, ipAddressConfigurationTimeStamp: String? = nil, osType: OSType? = nil) {
            self.authType = authType
            self.ipAddressConfigurationTimeStamp = ipAddressConfigurationTimeStamp
            self.osType = osType
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case ipAddressConfigurationTimeStamp = "ipAddressConfigurationTimeStamp"
            case osType = "osType"
        }
    }

    public struct ImportFileTaskInformation: AWSDecodableShape {
        ///  The time that the import task completes.
        public let completionTime: Date?
        ///  The ID of the import file task.
        public let id: String?
        ///  The name of the import task given in StartImportFileTask.
        public let importName: String?
        ///  The S3 bucket where the import file is located.
        public let inputS3Bucket: String?
        ///  The Amazon S3 key name of the import file.
        public let inputS3Key: String?
        ///  The number of records that failed to be imported.
        public let numberOfRecordsFailed: Int?
        ///  The number of records successfully imported.
        public let numberOfRecordsSuccess: Int?
        ///  Start time of the import task.
        public let startTime: Date?
        ///  Status of import file task.
        public let status: ImportFileTaskStatus?
        ///  The S3 bucket name for status report of import task.
        public let statusReportS3Bucket: String?
        ///  The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not.
        public let statusReportS3Key: String?

        @inlinable
        public init(completionTime: Date? = nil, id: String? = nil, importName: String? = nil, inputS3Bucket: String? = nil, inputS3Key: String? = nil, numberOfRecordsFailed: Int? = nil, numberOfRecordsSuccess: Int? = nil, startTime: Date? = nil, status: ImportFileTaskStatus? = nil, statusReportS3Bucket: String? = nil, statusReportS3Key: String? = nil) {
            self.completionTime = completionTime
            self.id = id
            self.importName = importName
            self.inputS3Bucket = inputS3Bucket
            self.inputS3Key = inputS3Key
            self.numberOfRecordsFailed = numberOfRecordsFailed
            self.numberOfRecordsSuccess = numberOfRecordsSuccess
            self.startTime = startTime
            self.status = status
            self.statusReportS3Bucket = statusReportS3Bucket
            self.statusReportS3Key = statusReportS3Key
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case id = "id"
            case importName = "importName"
            case inputS3Bucket = "inputS3Bucket"
            case inputS3Key = "inputS3Key"
            case numberOfRecordsFailed = "numberOfRecordsFailed"
            case numberOfRecordsSuccess = "numberOfRecordsSuccess"
            case startTime = "startTime"
            case status = "status"
            case statusReportS3Bucket = "statusReportS3Bucket"
            case statusReportS3Key = "statusReportS3Key"
        }
    }

    public struct ListAnalyzableServersRequest: AWSEncodableShape {
        /// The maximum number of items to include in the response. The maximum value is 100.
        public let maxResults: Int?
        /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?
        /// Specifies whether to sort by ascending (ASC) or descending (DESC) order.
        public let sort: SortOrder?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sort: SortOrder? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sort = "sort"
        }
    }

    public struct ListAnalyzableServersResponse: AWSDecodableShape {
        /// The list of analyzable servers with summary information about each server.
        public let analyzableServers: [AnalyzableServerSummary]?
        /// The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        @inlinable
        public init(analyzableServers: [AnalyzableServerSummary]? = nil, nextToken: String? = nil) {
            self.analyzableServers = analyzableServers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case analyzableServers = "analyzableServers"
            case nextToken = "nextToken"
        }
    }

    public struct ListApplicationComponentsRequest: AWSEncodableShape {
        ///  Criteria for filtering the list of application components.
        public let applicationComponentCriteria: ApplicationComponentCriteria?
        ///  Specify the value based on the application component criteria type. For example, if applicationComponentCriteria is set to SERVER_ID and filterValue is set to server1, then ListApplicationComponents returns all the application components running on server1.
        public let filterValue: String?
        ///  The group ID specified in to filter on.
        public let groupIdFilter: [Group]?
        ///  The maximum number of items to include in the response. The maximum value is 100.
        public let maxResults: Int?
        ///  The token from a previous call that you use to retrieve the next set of results. For example,
        /// if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?
        ///  Specifies whether to sort by ascending (ASC) or descending (DESC) order.
        public let sort: SortOrder?

        @inlinable
        public init(applicationComponentCriteria: ApplicationComponentCriteria? = nil, filterValue: String? = nil, groupIdFilter: [Group]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sort: SortOrder? = nil) {
            self.applicationComponentCriteria = applicationComponentCriteria
            self.filterValue = filterValue
            self.groupIdFilter = groupIdFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.filterValue, name: "filterValue", parent: name, max: 1024)
            try self.validate(self.filterValue, name: "filterValue", parent: name, pattern: ".*\\S.*")
            try self.groupIdFilter?.forEach {
                try $0.validate(name: "\(name).groupIdFilter[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentCriteria = "applicationComponentCriteria"
            case filterValue = "filterValue"
            case groupIdFilter = "groupIdFilter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sort = "sort"
        }
    }

    public struct ListApplicationComponentsResponse: AWSDecodableShape {
        ///  The list of application components with detailed information about each component.
        public let applicationComponentInfos: [ApplicationComponentDetail]?
        ///  The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        @inlinable
        public init(applicationComponentInfos: [ApplicationComponentDetail]? = nil, nextToken: String? = nil) {
            self.applicationComponentInfos = applicationComponentInfos
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentInfos = "applicationComponentInfos"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollectorsRequest: AWSEncodableShape {
        ///  The maximum number of items to include in the response. The maximum value is 100.
        public let maxResults: Int?
        ///  The token from a previous call that you use to retrieve the next set of results. For example,
        /// if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollectorsResponse: AWSDecodableShape {
        ///  The list of all the installed collectors.
        public let collectors: [Collector]?
        ///  The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        @inlinable
        public init(collectors: [Collector]? = nil, nextToken: String? = nil) {
            self.collectors = collectors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collectors = "Collectors"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportFileTaskRequest: AWSEncodableShape {
        ///  The total number of items to return. The maximum value is 100.
        public let maxResults: Int?
        ///  The token from a previous call that you use to retrieve the next set of results. For example,
        /// if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListImportFileTaskResponse: AWSDecodableShape {
        ///  The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  Lists information about the files you import.
        public let taskInfos: [ImportFileTaskInformation]?

        @inlinable
        public init(nextToken: String? = nil, taskInfos: [ImportFileTaskInformation]? = nil) {
            self.nextToken = nextToken
            self.taskInfos = taskInfos
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case taskInfos = "taskInfos"
        }
    }

    public struct ListServersRequest: AWSEncodableShape {
        ///  Specifies the filter value, which is based on the type of server criteria. For example, if serverCriteria is OS_NAME, and the filterValue is equal to WindowsServer, then ListServers returns all of the servers matching the OS name WindowsServer.
        public let filterValue: String?
        ///  Specifies the group ID to filter on.
        public let groupIdFilter: [Group]?
        ///  The maximum number of items to include in the response. The maximum value is 100.
        public let maxResults: Int?
        ///  The token from a previous call that you use to retrieve the next set of results. For example,
        /// if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
        public let nextToken: String?
        ///  Criteria for filtering servers.
        public let serverCriteria: ServerCriteria?
        ///  Specifies whether to sort by ascending (ASC) or descending (DESC) order.
        public let sort: SortOrder?

        @inlinable
        public init(filterValue: String? = nil, groupIdFilter: [Group]? = nil, maxResults: Int? = nil, nextToken: String? = nil, serverCriteria: ServerCriteria? = nil, sort: SortOrder? = nil) {
            self.filterValue = filterValue
            self.groupIdFilter = groupIdFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serverCriteria = serverCriteria
            self.sort = sort
        }

        public func validate(name: String) throws {
            try self.validate(self.filterValue, name: "filterValue", parent: name, max: 1024)
            try self.validate(self.filterValue, name: "filterValue", parent: name, pattern: ".*\\S.*")
            try self.groupIdFilter?.forEach {
                try $0.validate(name: "\(name).groupIdFilter[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case filterValue = "filterValue"
            case groupIdFilter = "groupIdFilter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case serverCriteria = "serverCriteria"
            case sort = "sort"
        }
    }

    public struct ListServersResponse: AWSDecodableShape {
        ///  The token you use to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  The list of servers with detailed information about each server.
        public let serverInfos: [ServerDetail]?

        @inlinable
        public init(nextToken: String? = nil, serverInfos: [ServerDetail]? = nil) {
            self.nextToken = nextToken
            self.serverInfos = serverInfos
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case serverInfos = "serverInfos"
        }
    }

    public struct NetworkInfo: AWSDecodableShape {
        ///  Information about the name of the interface of the server for which the assessment was run.
        public let interfaceName: String
        ///  Information about the IP address of the server for which the assessment was run.
        public let ipAddress: String
        ///  Information about the MAC address of the server for which the assessment was run.
        public let macAddress: String
        ///  Information about the subnet mask of the server for which the assessment was run.
        public let netMask: String

        @inlinable
        public init(interfaceName: String, ipAddress: String, macAddress: String, netMask: String) {
            self.interfaceName = interfaceName
            self.ipAddress = ipAddress
            self.macAddress = macAddress
            self.netMask = netMask
        }

        private enum CodingKeys: String, CodingKey {
            case interfaceName = "interfaceName"
            case ipAddress = "ipAddress"
            case macAddress = "macAddress"
            case netMask = "netMask"
        }
    }

    public struct NoDatabaseMigrationPreference: AWSEncodableShape & AWSDecodableShape {
        ///  The target database engine for database migration preference that you specify.
        public let targetDatabaseEngine: [TargetDatabaseEngine]

        @inlinable
        public init(targetDatabaseEngine: [TargetDatabaseEngine]) {
            self.targetDatabaseEngine = targetDatabaseEngine
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDatabaseEngine, name: "targetDatabaseEngine", parent: name, max: 1)
            try self.validate(self.targetDatabaseEngine, name: "targetDatabaseEngine", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDatabaseEngine = "targetDatabaseEngine"
        }
    }

    public struct NoManagementPreference: AWSEncodableShape & AWSDecodableShape {
        ///  The choice of application destination that you specify.
        public let targetDestination: [NoPreferenceTargetDestination]

        @inlinable
        public init(targetDestination: [NoPreferenceTargetDestination]) {
            self.targetDestination = targetDestination
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, max: 1)
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDestination = "targetDestination"
        }
    }

    public struct OSInfo: AWSDecodableShape {
        ///  Information about the type of operating system.
        public let type: OSType?
        ///  Information about the version of operating system.
        public let version: String?

        @inlinable
        public init(type: OSType? = nil, version: String? = nil) {
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case version = "version"
        }
    }

    public struct PipelineInfo: AWSDecodableShape {
        /// The time when the pipeline info was configured.
        public let pipelineConfigurationTimeStamp: String?
        /// The type of pipeline.
        public let pipelineType: PipelineType?

        @inlinable
        public init(pipelineConfigurationTimeStamp: String? = nil, pipelineType: PipelineType? = nil) {
            self.pipelineConfigurationTimeStamp = pipelineConfigurationTimeStamp
            self.pipelineType = pipelineType
        }

        private enum CodingKeys: String, CodingKey {
            case pipelineConfigurationTimeStamp = "pipelineConfigurationTimeStamp"
            case pipelineType = "pipelineType"
        }
    }

    public struct PrioritizeBusinessGoals: AWSEncodableShape & AWSDecodableShape {
        ///  Rank of business goals based on priority.
        public let businessGoals: BusinessGoals?

        @inlinable
        public init(businessGoals: BusinessGoals? = nil) {
            self.businessGoals = businessGoals
        }

        public func validate(name: String) throws {
            try self.businessGoals?.validate(name: "\(name).businessGoals")
        }

        private enum CodingKeys: String, CodingKey {
            case businessGoals = "businessGoals"
        }
    }

    public struct PutPortfolioPreferencesRequest: AWSEncodableShape {
        /// The classification for application component types.
        public let applicationMode: ApplicationMode?
        ///  The transformation preferences for non-database applications.
        public let applicationPreferences: ApplicationPreferences?
        ///  The transformation preferences for database applications.
        public let databasePreferences: DatabasePreferences?
        ///  The rank of the business goals based on priority.
        public let prioritizeBusinessGoals: PrioritizeBusinessGoals?

        @inlinable
        public init(applicationMode: ApplicationMode? = nil, applicationPreferences: ApplicationPreferences? = nil, databasePreferences: DatabasePreferences? = nil, prioritizeBusinessGoals: PrioritizeBusinessGoals? = nil) {
            self.applicationMode = applicationMode
            self.applicationPreferences = applicationPreferences
            self.databasePreferences = databasePreferences
            self.prioritizeBusinessGoals = prioritizeBusinessGoals
        }

        public func validate(name: String) throws {
            try self.applicationPreferences?.validate(name: "\(name).applicationPreferences")
            try self.databasePreferences?.validate(name: "\(name).databasePreferences")
            try self.prioritizeBusinessGoals?.validate(name: "\(name).prioritizeBusinessGoals")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationMode = "applicationMode"
            case applicationPreferences = "applicationPreferences"
            case databasePreferences = "databasePreferences"
            case prioritizeBusinessGoals = "prioritizeBusinessGoals"
        }
    }

    public struct PutPortfolioPreferencesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RecommendationReportDetails: AWSDecodableShape {
        ///  The time that the recommendation report generation task completes.
        public let completionTime: Date?
        ///  The S3 bucket where the report file is located.
        public let s3Bucket: String?
        ///  The Amazon S3 key name of the report file.
        public let s3Keys: [String]?
        ///  The time that the recommendation report generation task starts.
        public let startTime: Date?
        ///  The status of the recommendation report generation task.
        public let status: RecommendationReportStatus?
        ///  The status message for recommendation report generation.
        public let statusMessage: String?

        @inlinable
        public init(completionTime: Date? = nil, s3Bucket: String? = nil, s3Keys: [String]? = nil, startTime: Date? = nil, status: RecommendationReportStatus? = nil, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "completionTime"
            case s3Bucket = "s3Bucket"
            case s3Keys = "s3Keys"
            case startTime = "startTime"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct RecommendationSet: AWSDecodableShape {
        ///  The recommended strategy.
        public let strategy: Strategy?
        ///  The recommended target destination.
        public let targetDestination: TargetDestination?
        ///  The target destination for the recommendation set.
        public let transformationTool: TransformationTool?

        @inlinable
        public init(strategy: Strategy? = nil, targetDestination: TargetDestination? = nil, transformationTool: TransformationTool? = nil) {
            self.strategy = strategy
            self.targetDestination = targetDestination
            self.transformationTool = transformationTool
        }

        private enum CodingKeys: String, CodingKey {
            case strategy = "strategy"
            case targetDestination = "targetDestination"
            case transformationTool = "transformationTool"
        }
    }

    public struct RemoteSourceCodeAnalysisServerInfo: AWSDecodableShape {
        /// The time when the remote source code server was configured.
        public let remoteSourceCodeAnalysisServerConfigurationTimestamp: String?

        @inlinable
        public init(remoteSourceCodeAnalysisServerConfigurationTimestamp: String? = nil) {
            self.remoteSourceCodeAnalysisServerConfigurationTimestamp = remoteSourceCodeAnalysisServerConfigurationTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case remoteSourceCodeAnalysisServerConfigurationTimestamp = "remoteSourceCodeAnalysisServerConfigurationTimestamp"
        }
    }

    public struct Result: AWSDecodableShape {
        /// The error in server analysis.
        public let analysisStatus: AnalysisStatusUnion?
        /// The error in server analysis.
        public let analysisType: AnalysisType?
        /// The error in server analysis.
        public let antipatternReportResultList: [AntipatternReportResult]?
        /// The error in server analysis.
        public let statusMessage: String?

        @inlinable
        public init(analysisStatus: AnalysisStatusUnion? = nil, analysisType: AnalysisType? = nil, antipatternReportResultList: [AntipatternReportResult]? = nil, statusMessage: String? = nil) {
            self.analysisStatus = analysisStatus
            self.analysisType = analysisType
            self.antipatternReportResultList = antipatternReportResultList
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case analysisStatus = "analysisStatus"
            case analysisType = "analysisType"
            case antipatternReportResultList = "antipatternReportResultList"
            case statusMessage = "statusMessage"
        }
    }

    public struct S3Object: AWSDecodableShape {
        ///  The S3 bucket name.
        public let s3Bucket: String?
        ///  The Amazon S3 key name.
        public let s3key: String?

        @inlinable
        public init(s3Bucket: String? = nil, s3key: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3key = s3key
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "s3Bucket"
            case s3key = "s3key"
        }
    }

    public struct SelfManageResources: AWSEncodableShape & AWSDecodableShape {
        ///  Self-managed resources target destination.
        public let targetDestination: [SelfManageTargetDestination]

        @inlinable
        public init(targetDestination: [SelfManageTargetDestination]) {
            self.targetDestination = targetDestination
        }

        public func validate(name: String) throws {
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, max: 1)
            try self.validate(self.targetDestination, name: "targetDestination", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetDestination = "targetDestination"
        }
    }

    public struct ServerDetail: AWSDecodableShape {
        ///  The S3 bucket name and Amazon S3 key name for anti-pattern report.
        public let antipatternReportS3Object: S3Object?
        ///  The status of the anti-pattern report generation.
        public let antipatternReportStatus: AntipatternReportStatus?
        ///  A message about the status of the anti-pattern report generation.
        public let antipatternReportStatusMessage: String?
        ///  A list of strategy summaries.
        public let applicationComponentStrategySummary: [StrategySummary]?
        ///  The status of assessment for the server.
        public let dataCollectionStatus: RunTimeAssessmentStatus?
        ///  The server ID.
        public let id: String?
        ///  The timestamp of when the server was assessed.
        public let lastAnalyzedTimestamp: Date?
        ///  A list of anti-pattern severity summaries.
        public let listAntipatternSeveritySummary: [AntipatternSeveritySummary]?
        ///  The name of the server.
        public let name: String?
        ///  A set of recommendations.
        public let recommendationSet: RecommendationSet?
        /// The error in server analysis.
        public let serverError: ServerError?
        ///  The type of server.
        public let serverType: String?
        ///  A message about the status of data collection, which contains detailed descriptions of any error messages.
        public let statusMessage: String?
        ///  System information about the server.
        public let systemInfo: SystemInfo?

        @inlinable
        public init(antipatternReportS3Object: S3Object? = nil, antipatternReportStatus: AntipatternReportStatus? = nil, antipatternReportStatusMessage: String? = nil, applicationComponentStrategySummary: [StrategySummary]? = nil, dataCollectionStatus: RunTimeAssessmentStatus? = nil, id: String? = nil, lastAnalyzedTimestamp: Date? = nil, listAntipatternSeveritySummary: [AntipatternSeveritySummary]? = nil, name: String? = nil, recommendationSet: RecommendationSet? = nil, serverError: ServerError? = nil, serverType: String? = nil, statusMessage: String? = nil, systemInfo: SystemInfo? = nil) {
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.applicationComponentStrategySummary = applicationComponentStrategySummary
            self.dataCollectionStatus = dataCollectionStatus
            self.id = id
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.name = name
            self.recommendationSet = recommendationSet
            self.serverError = serverError
            self.serverType = serverType
            self.statusMessage = statusMessage
            self.systemInfo = systemInfo
        }

        private enum CodingKeys: String, CodingKey {
            case antipatternReportS3Object = "antipatternReportS3Object"
            case antipatternReportStatus = "antipatternReportStatus"
            case antipatternReportStatusMessage = "antipatternReportStatusMessage"
            case applicationComponentStrategySummary = "applicationComponentStrategySummary"
            case dataCollectionStatus = "dataCollectionStatus"
            case id = "id"
            case lastAnalyzedTimestamp = "lastAnalyzedTimestamp"
            case listAntipatternSeveritySummary = "listAntipatternSeveritySummary"
            case name = "name"
            case recommendationSet = "recommendationSet"
            case serverError = "serverError"
            case serverType = "serverType"
            case statusMessage = "statusMessage"
            case systemInfo = "systemInfo"
        }
    }

    public struct ServerError: AWSDecodableShape {
        /// The error category of server analysis.
        public let serverErrorCategory: ServerErrorCategory?

        @inlinable
        public init(serverErrorCategory: ServerErrorCategory? = nil) {
            self.serverErrorCategory = serverErrorCategory
        }

        private enum CodingKeys: String, CodingKey {
            case serverErrorCategory = "serverErrorCategory"
        }
    }

    public struct ServerStatusSummary: AWSDecodableShape {
        /// The number of servers successfully analyzed, partially successful or failed analysis.
        public let count: Int?
        /// The status of the run time.
        public let runTimeAssessmentStatus: RunTimeAssessmentStatus?

        @inlinable
        public init(count: Int? = nil, runTimeAssessmentStatus: RunTimeAssessmentStatus? = nil) {
            self.count = count
            self.runTimeAssessmentStatus = runTimeAssessmentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case runTimeAssessmentStatus = "runTimeAssessmentStatus"
        }
    }

    public struct ServerStrategy: AWSDecodableShape {
        ///  Set to true if the recommendation is set as preferred.
        public let isPreferred: Bool?
        ///  The number of application components with this strategy recommendation running on the server.
        public let numberOfApplicationComponents: Int?
        ///  Strategy recommendation for the server.
        public let recommendation: RecommendationSet?
        ///  The recommendation status of the strategy for the server.
        public let status: StrategyRecommendation?

        @inlinable
        public init(isPreferred: Bool? = nil, numberOfApplicationComponents: Int? = nil, recommendation: RecommendationSet? = nil, status: StrategyRecommendation? = nil) {
            self.isPreferred = isPreferred
            self.numberOfApplicationComponents = numberOfApplicationComponents
            self.recommendation = recommendation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case isPreferred = "isPreferred"
            case numberOfApplicationComponents = "numberOfApplicationComponents"
            case recommendation = "recommendation"
            case status = "status"
        }
    }

    public struct ServerSummary: AWSDecodableShape {
        ///  Number of servers.
        public let count: Int?
        ///  Type of operating system for the servers.
        public let serverOsType: ServerOsType?

        @inlinable
        public init(count: Int? = nil, serverOsType: ServerOsType? = nil) {
            self.count = count
            self.serverOsType = serverOsType
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case serverOsType = "ServerOsType"
        }
    }

    public struct SourceCode: AWSEncodableShape {
        ///  The repository name for the source code.
        public let location: String?
        /// The name of the project.
        public let projectName: String?
        ///  The branch of the source code.
        public let sourceVersion: String?
        ///  The type of repository to use for the source code.
        public let versionControl: VersionControl?

        @inlinable
        public init(location: String? = nil, projectName: String? = nil, sourceVersion: String? = nil, versionControl: VersionControl? = nil) {
            self.location = location
            self.projectName = projectName
            self.sourceVersion = sourceVersion
            self.versionControl = versionControl
        }

        public func validate(name: String) throws {
            try self.validate(self.location, name: "location", parent: name, max: 128)
            try self.validate(self.location, name: "location", parent: name, min: 1)
            try self.validate(self.location, name: "location", parent: name, pattern: ".*\\S.*")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 128)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: ".*\\S.*")
            try self.validate(self.sourceVersion, name: "sourceVersion", parent: name, max: 40)
            try self.validate(self.sourceVersion, name: "sourceVersion", parent: name, min: 1)
            try self.validate(self.sourceVersion, name: "sourceVersion", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
            case projectName = "projectName"
            case sourceVersion = "sourceVersion"
            case versionControl = "versionControl"
        }
    }

    public struct SourceCodeRepository: AWSDecodableShape {
        ///  The branch of the source code.
        public let branch: String?
        /// The name of the project.
        public let projectName: String?
        ///  The repository name for the source code.
        public let repository: String?
        ///  The type of repository to use for the source code.
        public let versionControlType: String?

        @inlinable
        public init(branch: String? = nil, projectName: String? = nil, repository: String? = nil, versionControlType: String? = nil) {
            self.branch = branch
            self.projectName = projectName
            self.repository = repository
            self.versionControlType = versionControlType
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case projectName = "projectName"
            case repository = "repository"
            case versionControlType = "versionControlType"
        }
    }

    public struct StartAssessmentRequest: AWSEncodableShape {
        /// The data source type of an assessment to be started.
        public let assessmentDataSourceType: AssessmentDataSourceType?
        /// List of criteria for assessment.
        public let assessmentTargets: [AssessmentTarget]?
        ///  The S3 bucket used by the collectors to send analysis data to the service. The bucket name must begin with migrationhub-strategy-.
        public let s3bucketForAnalysisData: String?
        ///  The S3 bucket where all the reports generated by the service are stored. The bucket name must begin with migrationhub-strategy-.
        public let s3bucketForReportData: String?

        @inlinable
        public init(assessmentDataSourceType: AssessmentDataSourceType? = nil, assessmentTargets: [AssessmentTarget]? = nil, s3bucketForAnalysisData: String? = nil, s3bucketForReportData: String? = nil) {
            self.assessmentDataSourceType = assessmentDataSourceType
            self.assessmentTargets = assessmentTargets
            self.s3bucketForAnalysisData = s3bucketForAnalysisData
            self.s3bucketForReportData = s3bucketForReportData
        }

        public func validate(name: String) throws {
            try self.assessmentTargets?.forEach {
                try $0.validate(name: "\(name).assessmentTargets[]")
            }
            try self.validate(self.assessmentTargets, name: "assessmentTargets", parent: name, max: 10)
            try self.validate(self.s3bucketForAnalysisData, name: "s3bucketForAnalysisData", parent: name, max: 1024)
            try self.validate(self.s3bucketForAnalysisData, name: "s3bucketForAnalysisData", parent: name, pattern: ".*\\S.*")
            try self.validate(self.s3bucketForReportData, name: "s3bucketForReportData", parent: name, max: 1024)
            try self.validate(self.s3bucketForReportData, name: "s3bucketForReportData", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentDataSourceType = "assessmentDataSourceType"
            case assessmentTargets = "assessmentTargets"
            case s3bucketForAnalysisData = "s3bucketForAnalysisData"
            case s3bucketForReportData = "s3bucketForReportData"
        }
    }

    public struct StartAssessmentResponse: AWSDecodableShape {
        ///  The ID of the assessment.
        public let assessmentId: String?

        @inlinable
        public init(assessmentId: String? = nil) {
            self.assessmentId = assessmentId
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId = "assessmentId"
        }
    }

    public struct StartImportFileTaskRequest: AWSEncodableShape {
        /// Specifies the source that the servers are coming from. By default, Strategy Recommendations assumes that the servers specified in the import file are available in AWS Application Discovery Service.
        public let dataSourceType: DataSourceType?
        /// Groups the resources in the import file together with a unique name. This ID can be as filter in ListApplicationComponents and ListServers.
        public let groupId: [Group]?
        ///  A descriptive name for the request.
        public let name: String
        ///  The S3 bucket where the import file is located. The bucket name is required to begin with migrationhub-strategy-.
        public let s3Bucket: String
        ///  The S3 bucket where Strategy Recommendations uploads import results. The bucket name is required to begin with migrationhub-strategy-.
        public let s3bucketForReportData: String?
        ///  The Amazon S3 key name of the import file.
        public let s3key: String

        @inlinable
        public init(dataSourceType: DataSourceType? = nil, groupId: [Group]? = nil, name: String, s3Bucket: String, s3bucketForReportData: String? = nil, s3key: String) {
            self.dataSourceType = dataSourceType
            self.groupId = groupId
            self.name = name
            self.s3Bucket = s3Bucket
            self.s3bucketForReportData = s3bucketForReportData
            self.s3key = s3key
        }

        public func validate(name: String) throws {
            try self.groupId?.forEach {
                try $0.validate(name: "\(name).groupId[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, pattern: ".*\\S.*")
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, max: 63)
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "[0-9a-z]+[0-9a-z\\.\\-]*[0-9a-z]+")
            try self.validate(self.s3bucketForReportData, name: "s3bucketForReportData", parent: name, max: 1024)
            try self.validate(self.s3bucketForReportData, name: "s3bucketForReportData", parent: name, pattern: ".*\\S.*")
            try self.validate(self.s3key, name: "s3key", parent: name, max: 1024)
            try self.validate(self.s3key, name: "s3key", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceType = "dataSourceType"
            case groupId = "groupId"
            case name = "name"
            case s3Bucket = "S3Bucket"
            case s3bucketForReportData = "s3bucketForReportData"
            case s3key = "s3key"
        }
    }

    public struct StartImportFileTaskResponse: AWSDecodableShape {
        ///  The ID for a specific import task. The ID is unique within an AWS account.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct StartRecommendationReportGenerationRequest: AWSEncodableShape {
        ///  Groups the resources in the recommendation report with a unique name.
        public let groupIdFilter: [Group]?
        ///  The output format for the recommendation report file. The default format is Microsoft Excel.
        public let outputFormat: OutputFormat?

        @inlinable
        public init(groupIdFilter: [Group]? = nil, outputFormat: OutputFormat? = nil) {
            self.groupIdFilter = groupIdFilter
            self.outputFormat = outputFormat
        }

        public func validate(name: String) throws {
            try self.groupIdFilter?.forEach {
                try $0.validate(name: "\(name).groupIdFilter[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case groupIdFilter = "groupIdFilter"
            case outputFormat = "outputFormat"
        }
    }

    public struct StartRecommendationReportGenerationResponse: AWSDecodableShape {
        ///  The ID of the recommendation report generation task.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct StopAssessmentRequest: AWSEncodableShape {
        ///  The assessmentId returned by StartAssessment.
        public let assessmentId: String

        @inlinable
        public init(assessmentId: String) {
            self.assessmentId = assessmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, max: 52)
            try self.validate(self.assessmentId, name: "assessmentId", parent: name, pattern: "[0-9a-z-:]+")
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentId = "assessmentId"
        }
    }

    public struct StopAssessmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StrategyOption: AWSEncodableShape {
        ///  Indicates if a specific strategy is preferred for the application component.
        public let isPreferred: Bool?
        ///  Type of transformation. For example, Rehost, Replatform, and so on.
        public let strategy: Strategy?
        ///  Destination information about where the application component can migrate to. For example, EC2, ECS, and so on.
        public let targetDestination: TargetDestination?
        ///  The name of the tool that can be used to transform an application component using this strategy.
        public let toolName: TransformationToolName?

        @inlinable
        public init(isPreferred: Bool? = nil, strategy: Strategy? = nil, targetDestination: TargetDestination? = nil, toolName: TransformationToolName? = nil) {
            self.isPreferred = isPreferred
            self.strategy = strategy
            self.targetDestination = targetDestination
            self.toolName = toolName
        }

        private enum CodingKeys: String, CodingKey {
            case isPreferred = "isPreferred"
            case strategy = "strategy"
            case targetDestination = "targetDestination"
            case toolName = "toolName"
        }
    }

    public struct StrategySummary: AWSDecodableShape {
        ///  The count of recommendations per strategy.
        public let count: Int?
        ///  The name of recommended strategy.
        public let strategy: Strategy?

        @inlinable
        public init(count: Int? = nil, strategy: Strategy? = nil) {
            self.count = count
            self.strategy = strategy
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case strategy = "strategy"
        }
    }

    public struct SystemInfo: AWSDecodableShape {
        ///  CPU architecture type for the server.
        public let cpuArchitecture: String?
        ///  File system type for the server.
        public let fileSystemType: String?
        ///  Networking information related to a server.
        public let networkInfoList: [NetworkInfo]?
        ///  Operating system corresponding to a server.
        public let osInfo: OSInfo?

        @inlinable
        public init(cpuArchitecture: String? = nil, fileSystemType: String? = nil, networkInfoList: [NetworkInfo]? = nil, osInfo: OSInfo? = nil) {
            self.cpuArchitecture = cpuArchitecture
            self.fileSystemType = fileSystemType
            self.networkInfoList = networkInfoList
            self.osInfo = osInfo
        }

        private enum CodingKeys: String, CodingKey {
            case cpuArchitecture = "cpuArchitecture"
            case fileSystemType = "fileSystemType"
            case networkInfoList = "networkInfoList"
            case osInfo = "osInfo"
        }
    }

    public struct TransformationTool: AWSDecodableShape {
        ///  Description of the tool.
        public let description: String?
        ///  Name of the tool.
        public let name: TransformationToolName?
        ///  URL for installing the tool.
        public let tranformationToolInstallationLink: String?

        @inlinable
        public init(description: String? = nil, name: TransformationToolName? = nil, tranformationToolInstallationLink: String? = nil) {
            self.description = description
            self.name = name
            self.tranformationToolInstallationLink = tranformationToolInstallationLink
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case tranformationToolInstallationLink = "tranformationToolInstallationLink"
        }
    }

    public struct UpdateApplicationComponentConfigRequest: AWSEncodableShape {
        ///  The ID of the application component. The ID is unique within an AWS account.
        public let applicationComponentId: String
        /// The type of known component.
        public let appType: AppType?
        /// Update the configuration request of an application component. If it is set to true, the source code and/or database credentials are updated. If it is set to false, the source code and/or database credentials are updated and an analysis is initiated.
        public let configureOnly: Bool?
        ///  Indicates whether the application component has been included for server recommendation or not.
        public let inclusionStatus: InclusionStatus?
        ///  Database credentials.
        public let secretsManagerKey: String?
        ///  The list of source code configurations to update for the application component.
        public let sourceCodeList: [SourceCode]?
        ///  The preferred strategy options for the application component. Use values from the GetApplicationComponentStrategies response.
        public let strategyOption: StrategyOption?

        @inlinable
        public init(applicationComponentId: String, appType: AppType? = nil, configureOnly: Bool? = nil, inclusionStatus: InclusionStatus? = nil, secretsManagerKey: String? = nil, sourceCodeList: [SourceCode]? = nil, strategyOption: StrategyOption? = nil) {
            self.applicationComponentId = applicationComponentId
            self.appType = appType
            self.configureOnly = configureOnly
            self.inclusionStatus = inclusionStatus
            self.secretsManagerKey = secretsManagerKey
            self.sourceCodeList = sourceCodeList
            self.strategyOption = strategyOption
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, max: 44)
            try self.validate(self.applicationComponentId, name: "applicationComponentId", parent: name, pattern: "[0-9a-zA-Z-]+")
            try self.validate(self.secretsManagerKey, name: "secretsManagerKey", parent: name, max: 512)
            try self.validate(self.secretsManagerKey, name: "secretsManagerKey", parent: name, min: 1)
            try self.validate(self.secretsManagerKey, name: "secretsManagerKey", parent: name, pattern: ".*")
            try self.sourceCodeList?.forEach {
                try $0.validate(name: "\(name).sourceCodeList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicationComponentId = "applicationComponentId"
            case appType = "appType"
            case configureOnly = "configureOnly"
            case inclusionStatus = "inclusionStatus"
            case secretsManagerKey = "secretsManagerKey"
            case sourceCodeList = "sourceCodeList"
            case strategyOption = "strategyOption"
        }
    }

    public struct UpdateApplicationComponentConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateServerConfigRequest: AWSEncodableShape {
        ///  The ID of the server.
        public let serverId: String
        ///  The preferred strategy options for the application component. See the response from GetServerStrategies.
        public let strategyOption: StrategyOption?

        @inlinable
        public init(serverId: String, strategyOption: StrategyOption? = nil) {
            self.serverId = serverId
            self.strategyOption = strategyOption
        }

        public func validate(name: String) throws {
            try self.validate(self.serverId, name: "serverId", parent: name, max: 27)
            try self.validate(self.serverId, name: "serverId", parent: name, min: 1)
            try self.validate(self.serverId, name: "serverId", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: String, CodingKey {
            case serverId = "serverId"
            case strategyOption = "strategyOption"
        }
    }

    public struct UpdateServerConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct VcenterBasedRemoteInfo: AWSDecodableShape {
        /// The type of the operating system.
        public let osType: OSType?
        /// The time when the remote server based on vCenter was last configured.
        public let vcenterConfigurationTimeStamp: String?

        @inlinable
        public init(osType: OSType? = nil, vcenterConfigurationTimeStamp: String? = nil) {
            self.osType = osType
            self.vcenterConfigurationTimeStamp = vcenterConfigurationTimeStamp
        }

        private enum CodingKeys: String, CodingKey {
            case osType = "osType"
            case vcenterConfigurationTimeStamp = "vcenterConfigurationTimeStamp"
        }
    }

    public struct VersionControlInfo: AWSDecodableShape {
        /// The time when the version control system was last configured.
        public let versionControlConfigurationTimeStamp: String?
        /// The type of version control.
        public let versionControlType: VersionControlType?

        @inlinable
        public init(versionControlConfigurationTimeStamp: String? = nil, versionControlType: VersionControlType? = nil) {
            self.versionControlConfigurationTimeStamp = versionControlConfigurationTimeStamp
            self.versionControlType = versionControlType
        }

        private enum CodingKeys: String, CodingKey {
            case versionControlConfigurationTimeStamp = "versionControlConfigurationTimeStamp"
            case versionControlType = "versionControlType"
        }
    }
}

// MARK: - Errors

/// Error enum for MigrationHubStrategy
public struct MigrationHubStrategyErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case dependencyException = "DependencyException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceLinkedRoleLockClientException = "ServiceLinkedRoleLockClientException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MigrationHubStrategy
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  The user does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this user.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    ///  Exception to indicate that there is an ongoing task when a new task is created. Return when once the existing tasks are complete.
    public static var conflictException: Self { .init(.conflictException) }
    /// Dependency encountered an error.
    public static var dependencyException: Self { .init(.dependencyException) }
    ///  The server experienced an internal error. Try again.
    public static var internalServerException: Self { .init(.internalServerException) }
    ///  The specified ID in the request is not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    ///  Exception to indicate that the service-linked role (SLR) is locked.
    public static var serviceLinkedRoleLockClientException: Self { .init(.serviceLinkedRoleLockClientException) }
    ///  The AWS account has reached its quota of imports. Contact AWS Support to increase the quota for this account.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    ///  The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  The request body isn't valid.
    public static var validationException: Self { .init(.validationException) }
}

extension MigrationHubStrategyErrorType: Equatable {
    public static func == (lhs: MigrationHubStrategyErrorType, rhs: MigrationHubStrategyErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MigrationHubStrategyErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
