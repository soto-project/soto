//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension WorkSpacesWeb {
    // MARK: Enums

    public enum AuthenticationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iamIdentityCenter = "IAM_Identity_Center"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum BrowserType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chrome = "Chrome"
        public var description: String { return self.rawValue }
    }

    public enum EnabledType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum IdentityProviderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case facebook = "Facebook"
        case google = "Google"
        case loginWithAmazon = "LoginWithAmazon"
        case oidc = "OIDC"
        case saml = "SAML"
        case signInWithApple = "SignInWithApple"
        public var description: String { return self.rawValue }
    }

    public enum InstanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case standardLarge = "standard.large"
        case standardRegular = "standard.regular"
        case standardXlarge = "standard.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum MaxDisplayResolution: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case size1024X768 = "size1024X768"
        case size1280X720 = "size1280X720"
        case size1920X1080 = "size1920X1080"
        case size2560X1440 = "size2560X1440"
        case size3440X1440 = "size3440X1440"
        case size3840X2160 = "size3840X2160"
        case size4096X2160 = "size4096X2160"
        case size800X600 = "size800X600"
        public var description: String { return self.rawValue }
    }

    public enum PortalStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case incomplete = "Incomplete"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum RedactionPlaceHolderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customText = "CustomText"
        public var description: String { return self.rawValue }
    }

    public enum RendererType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case appStream = "AppStream"
        public var description: String { return self.rawValue }
    }

    public enum SessionSortBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case startTimeAscending = "StartTimeAscending"
        case startTimeDescending = "StartTimeDescending"
        public var description: String { return self.rawValue }
    }

    public enum SessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case terminated = "Terminated"
        public var description: String { return self.rawValue }
    }

    public enum ToolbarItem: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dualMonitor = "DualMonitor"
        case fullScreen = "FullScreen"
        case microphone = "Microphone"
        case webcam = "Webcam"
        case windows = "Windows"
        public var description: String { return self.rawValue }
    }

    public enum ToolbarType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case docked = "Docked"
        case floating = "Floating"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum VisualMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dark = "Dark"
        case light = "Light"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateBrowserSettingsRequest: AWSEncodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(browserSettingsArn: String, portalArn: String) {
            self.browserSettingsArn = browserSettingsArn
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.browserSettingsArn, key: "browserSettingsArn")
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, max: 2048)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, min: 20)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateBrowserSettingsResponse: AWSDecodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(browserSettingsArn: String, portalArn: String) {
            self.browserSettingsArn = browserSettingsArn
            self.portalArn = portalArn
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettingsArn = "browserSettingsArn"
            case portalArn = "portalArn"
        }
    }

    public struct AssociateDataProtectionSettingsRequest: AWSEncodableShape {
        /// The ARN of the data protection settings.
        public let dataProtectionSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(dataProtectionSettingsArn: String, portalArn: String) {
            self.dataProtectionSettingsArn = dataProtectionSettingsArn
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.dataProtectionSettingsArn, key: "dataProtectionSettingsArn")
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, max: 2048)
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, min: 20)
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateDataProtectionSettingsResponse: AWSDecodableShape {
        /// The ARN of the data protection settings resource.
        public let dataProtectionSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(dataProtectionSettingsArn: String, portalArn: String) {
            self.dataProtectionSettingsArn = dataProtectionSettingsArn
            self.portalArn = portalArn
        }

        private enum CodingKeys: String, CodingKey {
            case dataProtectionSettingsArn = "dataProtectionSettingsArn"
            case portalArn = "portalArn"
        }
    }

    public struct AssociateIpAccessSettingsRequest: AWSEncodableShape {
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(ipAccessSettingsArn: String, portalArn: String) {
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.ipAccessSettingsArn, key: "ipAccessSettingsArn")
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, max: 2048)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, min: 20)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateIpAccessSettingsResponse: AWSDecodableShape {
        /// The ARN of the IP access settings resource.
        public let ipAccessSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(ipAccessSettingsArn: String, portalArn: String) {
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.portalArn = portalArn
        }

        private enum CodingKeys: String, CodingKey {
            case ipAccessSettingsArn = "ipAccessSettingsArn"
            case portalArn = "portalArn"
        }
    }

    public struct AssociateNetworkSettingsRequest: AWSEncodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(networkSettingsArn: String, portalArn: String) {
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.networkSettingsArn, key: "networkSettingsArn")
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, max: 2048)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, min: 20)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateNetworkSettingsResponse: AWSDecodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(networkSettingsArn: String, portalArn: String) {
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettingsArn = "networkSettingsArn"
            case portalArn = "portalArn"
        }
    }

    public struct AssociateTrustStoreRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the trust store.
        public let trustStoreArn: String

        @inlinable
        public init(portalArn: String, trustStoreArn: String) {
            self.portalArn = portalArn
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
            request.encodeQuery(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateTrustStoreResponse: AWSDecodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the trust store.
        public let trustStoreArn: String

        @inlinable
        public init(portalArn: String, trustStoreArn: String) {
            self.portalArn = portalArn
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct AssociateUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        @inlinable
        public init(portalArn: String, userAccessLoggingSettingsArn: String) {
            self.portalArn = portalArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
            request.encodeQuery(self.userAccessLoggingSettingsArn, key: "userAccessLoggingSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, max: 2048)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, min: 20)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateUserAccessLoggingSettingsResponse: AWSDecodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        @inlinable
        public init(portalArn: String, userAccessLoggingSettingsArn: String) {
            self.portalArn = portalArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
        }
    }

    public struct AssociateUserSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the user settings.
        public let userSettingsArn: String

        @inlinable
        public init(portalArn: String, userSettingsArn: String) {
            self.portalArn = portalArn
            self.userSettingsArn = userSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
            request.encodeQuery(self.userSettingsArn, key: "userSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, max: 2048)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, min: 20)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateUserSettingsResponse: AWSDecodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the user settings.
        public let userSettingsArn: String

        @inlinable
        public init(portalArn: String, userSettingsArn: String) {
            self.portalArn = portalArn
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct BrowserSettings: AWSDecodableShape {
        /// The additional encryption context of the browser settings.
        public let additionalEncryptionContext: [String: String]?
        /// A list of web portal ARNs that this browser settings is associated with.
        public let associatedPortalArns: [String]?
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public let browserPolicy: String?
        /// The ARN of the browser settings.
        public let browserSettingsArn: String
        /// The customer managed key used to encrypt sensitive information in the browser settings.
        public let customerManagedKey: String?

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, associatedPortalArns: [String]? = nil, browserPolicy: String? = nil, browserSettingsArn: String, customerManagedKey: String? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.associatedPortalArns = associatedPortalArns
            self.browserPolicy = browserPolicy
            self.browserSettingsArn = browserSettingsArn
            self.customerManagedKey = customerManagedKey
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case associatedPortalArns = "associatedPortalArns"
            case browserPolicy = "browserPolicy"
            case browserSettingsArn = "browserSettingsArn"
            case customerManagedKey = "customerManagedKey"
        }
    }

    public struct BrowserSettingsSummary: AWSDecodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String

        @inlinable
        public init(browserSettingsArn: String) {
            self.browserSettingsArn = browserSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettingsArn = "browserSettingsArn"
        }
    }

    public struct Certificate: AWSDecodableShape {
        /// The body of the certificate.
        public let body: AWSBase64Data?
        /// The entity that issued the certificate.
        public let issuer: String?
        /// The certificate is not valid after this date.
        public let notValidAfter: Date?
        /// The certificate is not valid before this date.
        public let notValidBefore: Date?
        /// The entity the certificate belongs to.
        public let subject: String?
        /// A hexadecimal identifier for the certificate.
        public let thumbprint: String?

        @inlinable
        public init(body: AWSBase64Data? = nil, issuer: String? = nil, notValidAfter: Date? = nil, notValidBefore: Date? = nil, subject: String? = nil, thumbprint: String? = nil) {
            self.body = body
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
            case issuer = "issuer"
            case notValidAfter = "notValidAfter"
            case notValidBefore = "notValidBefore"
            case subject = "subject"
            case thumbprint = "thumbprint"
        }
    }

    public struct CertificateSummary: AWSDecodableShape {
        /// The entity that issued the certificate.
        public let issuer: String?
        /// The certificate is not valid after this date.
        public let notValidAfter: Date?
        /// The certificate is not valid before this date.
        public let notValidBefore: Date?
        /// The entity the certificate belongs to.
        public let subject: String?
        /// A hexadecimal identifier for the certificate.
        public let thumbprint: String?

        @inlinable
        public init(issuer: String? = nil, notValidAfter: Date? = nil, notValidBefore: Date? = nil, subject: String? = nil, thumbprint: String? = nil) {
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }

        private enum CodingKeys: String, CodingKey {
            case issuer = "issuer"
            case notValidAfter = "notValidAfter"
            case notValidBefore = "notValidBefore"
            case subject = "subject"
            case thumbprint = "thumbprint"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String?
        /// Identifier of the resource affected.
        public let resourceId: String?
        /// Type of the resource affected.
        public let resourceType: String?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CookieSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The domain of the cookie.
        public let domain: String
        /// The name of the cookie.
        public let name: String?
        /// The path of the cookie.
        public let path: String?

        @inlinable
        public init(domain: String, name: String? = nil, path: String? = nil) {
            self.domain = domain
            self.name = name
            self.path = path
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 253)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^(\\.?)(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\\.)*[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$")
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.path, name: "path", parent: name, max: 2000)
            try self.validate(self.path, name: "path", parent: name, pattern: "^/(\\S)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case name = "name"
            case path = "path"
        }
    }

    public struct CookieSynchronizationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The list of cookie specifications that are allowed to be synchronized to the remote browser.
        public let allowlist: [CookieSpecification]
        /// The list of cookie specifications that are blocked from being synchronized to the remote browser.
        public let blocklist: [CookieSpecification]?

        @inlinable
        public init(allowlist: [CookieSpecification], blocklist: [CookieSpecification]? = nil) {
            self.allowlist = allowlist
            self.blocklist = blocklist
        }

        public func validate(name: String) throws {
            try self.allowlist.forEach {
                try $0.validate(name: "\(name).allowlist[]")
            }
            try self.validate(self.allowlist, name: "allowlist", parent: name, max: 10)
            try self.blocklist?.forEach {
                try $0.validate(name: "\(name).blocklist[]")
            }
            try self.validate(self.blocklist, name: "blocklist", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case allowlist = "allowlist"
            case blocklist = "blocklist"
        }
    }

    public struct CreateBrowserSettingsRequest: AWSEncodableShape {
        /// Additional encryption context of the browser settings.
        public let additionalEncryptionContext: [String: String]?
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public let browserPolicy: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The custom managed key of the browser settings.
        public let customerManagedKey: String?
        /// The tags to add to the browser settings resource. A tag is a key-value pair.
        public let tags: [Tag]?

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, browserPolicy: String, clientToken: String? = CreateBrowserSettingsRequest.idempotencyToken(), customerManagedKey: String? = nil, tags: [Tag]? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.browserPolicy = browserPolicy
            self.clientToken = clientToken
            self.customerManagedKey = customerManagedKey
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.additionalEncryptionContext?.forEach {
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, max: 131072)
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, max: 131072)
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, min: 2)
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, pattern: "\\{[\\S\\s]*\\}\\s*")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, max: 2048)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, min: 20)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:kms:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:key\\/[a-zA-Z0-9-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case browserPolicy = "browserPolicy"
            case clientToken = "clientToken"
            case customerManagedKey = "customerManagedKey"
            case tags = "tags"
        }
    }

    public struct CreateBrowserSettingsResponse: AWSDecodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String

        @inlinable
        public init(browserSettingsArn: String) {
            self.browserSettingsArn = browserSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettingsArn = "browserSettingsArn"
        }
    }

    public struct CreateDataProtectionSettingsRequest: AWSEncodableShape {
        /// Additional encryption context of the data protection settings.
        public let additionalEncryptionContext: [String: String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The custom managed key of the data protection settings.
        public let customerManagedKey: String?
        /// The description of the data protection settings.
        public let description: String?
        /// The display name of the data protection settings.
        public let displayName: String?
        /// The inline redaction configuration of the data protection settings that will be applied to all sessions.
        public let inlineRedactionConfiguration: InlineRedactionConfiguration?
        /// The tags to add to the data protection settings resource. A tag is a key-value pair.
        public let tags: [Tag]?

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, clientToken: String? = CreateDataProtectionSettingsRequest.idempotencyToken(), customerManagedKey: String? = nil, description: String? = nil, displayName: String? = nil, inlineRedactionConfiguration: InlineRedactionConfiguration? = nil, tags: [Tag]? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.clientToken = clientToken
            self.customerManagedKey = customerManagedKey
            self.description = description
            self.displayName = displayName
            self.inlineRedactionConfiguration = inlineRedactionConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.additionalEncryptionContext?.forEach {
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, max: 131072)
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, max: 2048)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, min: 20)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:kms:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:key\\/[a-zA-Z0-9-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[ _\\-\\d\\w]+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[ _\\-\\d\\w]+$")
            try self.inlineRedactionConfiguration?.validate(name: "\(name).inlineRedactionConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case clientToken = "clientToken"
            case customerManagedKey = "customerManagedKey"
            case description = "description"
            case displayName = "displayName"
            case inlineRedactionConfiguration = "inlineRedactionConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateDataProtectionSettingsResponse: AWSDecodableShape {
        /// The ARN of the data protection settings resource.
        public let dataProtectionSettingsArn: String

        @inlinable
        public init(dataProtectionSettingsArn: String) {
            self.dataProtectionSettingsArn = dataProtectionSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case dataProtectionSettingsArn = "dataProtectionSettingsArn"
        }
    }

    public struct CreateIdentityProviderRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The identity provider details. The following list describes the provider detail keys for each identity provider type.    For Google and Login with Amazon:    client_id     client_secret     authorize_scopes      For Facebook:    client_id     client_secret     authorize_scopes     api_version      For Sign in with Apple:    client_id     team_id     key_id     private_key     authorize_scopes      For OIDC providers:    client_id     client_secret     attributes_request_method     oidc_issuer     authorize_scopes     authorize_url if not available from discovery URL specified by oidc_issuer key     token_url if not available from discovery URL specified by oidc_issuer key     attributes_url if not available from discovery URL specified by oidc_issuer key     jwks_uri if not available from discovery URL specified by oidc_issuer key      For SAML providers:    MetadataFile OR MetadataURL     IDPSignout (boolean) optional     IDPInit (boolean) optional     RequestSigningAlgorithm (string) optional - Only accepts rsa-sha256     EncryptedResponses (boolean) optional
        public let identityProviderDetails: [String: String]
        /// The identity provider name.
        public let identityProviderName: String
        /// The identity provider type.
        public let identityProviderType: IdentityProviderType
        /// The ARN of the web portal.
        public let portalArn: String
        /// The tags to add to the identity provider resource. A tag is a key-value pair.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateIdentityProviderRequest.idempotencyToken(), identityProviderDetails: [String: String], identityProviderName: String, identityProviderType: IdentityProviderType, portalArn: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
            self.portalArn = portalArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.identityProviderDetails.forEach {
                try validate($0.key, name: "identityProviderDetails.key", parent: name, max: 131072)
                try validate($0.key, name: "identityProviderDetails.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "identityProviderDetails[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "identityProviderDetails[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, max: 32)
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, min: 1)
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, pattern: "^[^_][\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}][^_]+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case identityProviderDetails = "identityProviderDetails"
            case identityProviderName = "identityProviderName"
            case identityProviderType = "identityProviderType"
            case portalArn = "portalArn"
            case tags = "tags"
        }
    }

    public struct CreateIdentityProviderResponse: AWSDecodableShape {
        /// The ARN of the identity provider.
        public let identityProviderArn: String

        @inlinable
        public init(identityProviderArn: String) {
            self.identityProviderArn = identityProviderArn
        }

        private enum CodingKeys: String, CodingKey {
            case identityProviderArn = "identityProviderArn"
        }
    }

    public struct CreateIpAccessSettingsRequest: AWSEncodableShape {
        /// Additional encryption context of the IP access settings.
        public let additionalEncryptionContext: [String: String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The custom managed key of the IP access settings.
        public let customerManagedKey: String?
        /// The description of the IP access settings.
        public let description: String?
        /// The display name of the IP access settings.
        public let displayName: String?
        /// The IP rules of the IP access settings.
        public let ipRules: [IpRule]
        /// The tags to add to the IP access settings resource. A tag is a key-value pair.
        public let tags: [Tag]?

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, clientToken: String? = CreateIpAccessSettingsRequest.idempotencyToken(), customerManagedKey: String? = nil, description: String? = nil, displayName: String? = nil, ipRules: [IpRule], tags: [Tag]? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.clientToken = clientToken
            self.customerManagedKey = customerManagedKey
            self.description = description
            self.displayName = displayName
            self.ipRules = ipRules
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.additionalEncryptionContext?.forEach {
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, max: 131072)
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, max: 2048)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, min: 20)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:kms:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:key\\/[a-zA-Z0-9-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^.+$")
            try self.ipRules.forEach {
                try $0.validate(name: "\(name).ipRules[]")
            }
            try self.validate(self.ipRules, name: "ipRules", parent: name, max: 100)
            try self.validate(self.ipRules, name: "ipRules", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case clientToken = "clientToken"
            case customerManagedKey = "customerManagedKey"
            case description = "description"
            case displayName = "displayName"
            case ipRules = "ipRules"
            case tags = "tags"
        }
    }

    public struct CreateIpAccessSettingsResponse: AWSDecodableShape {
        /// The ARN of the IP access settings resource.
        public let ipAccessSettingsArn: String

        @inlinable
        public init(ipAccessSettingsArn: String) {
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case ipAccessSettingsArn = "ipAccessSettingsArn"
        }
    }

    public struct CreateNetworkSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// One or more security groups used to control access from streaming instances to your VPC.
        public let securityGroupIds: [String]
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public let subnetIds: [String]
        /// The tags to add to the network settings resource. A tag is a key-value pair.
        public let tags: [Tag]?
        /// The VPC that streaming instances will connect to.
        public let vpcId: String

        @inlinable
        public init(clientToken: String? = CreateNetworkSettingsRequest.idempotencyToken(), securityGroupIds: [String], subnetIds: [String], tags: [Tag]? = nil, vpcId: String) {
            self.clientToken = clientToken
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 128)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[\\w+\\-]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 32)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-([0-9a-f]{8}|[0-9a-f]{17})$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 5)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 2)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 255)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[0-9a-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case vpcId = "vpcId"
        }
    }

    public struct CreateNetworkSettingsResponse: AWSDecodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String

        @inlinable
        public init(networkSettingsArn: String) {
            self.networkSettingsArn = networkSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettingsArn = "networkSettingsArn"
        }
    }

    public struct CreatePortalRequest: AWSEncodableShape {
        /// The additional encryption context of the portal.
        public let additionalEncryptionContext: [String: String]?
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard.  Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.  IAM Identity Center web portals are authenticated through IAM Identity Center. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public let authenticationType: AuthenticationType?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The customer managed key of the web portal.
        public let customerManagedKey: String?
        /// The name of the web portal. This is not visible to users who log into the web portal.
        public let displayName: String?
        /// The type and resources of the underlying instance.
        public let instanceType: InstanceType?
        /// The maximum number of concurrent sessions for the portal.
        public let maxConcurrentSessions: Int?
        /// The tags to add to the web portal. A tag is a key-value pair.
        public let tags: [Tag]?

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, authenticationType: AuthenticationType? = nil, clientToken: String? = CreatePortalRequest.idempotencyToken(), customerManagedKey: String? = nil, displayName: String? = nil, instanceType: InstanceType? = nil, maxConcurrentSessions: Int? = nil, tags: [Tag]? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.authenticationType = authenticationType
            self.clientToken = clientToken
            self.customerManagedKey = customerManagedKey
            self.displayName = displayName
            self.instanceType = instanceType
            self.maxConcurrentSessions = maxConcurrentSessions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.additionalEncryptionContext?.forEach {
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, max: 131072)
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, max: 2048)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, min: 20)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:kms:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:key\\/[a-zA-Z0-9-]+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^.+$")
            try self.validate(self.maxConcurrentSessions, name: "maxConcurrentSessions", parent: name, max: 5000)
            try self.validate(self.maxConcurrentSessions, name: "maxConcurrentSessions", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case authenticationType = "authenticationType"
            case clientToken = "clientToken"
            case customerManagedKey = "customerManagedKey"
            case displayName = "displayName"
            case instanceType = "instanceType"
            case maxConcurrentSessions = "maxConcurrentSessions"
            case tags = "tags"
        }
    }

    public struct CreatePortalResponse: AWSDecodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public let portalEndpoint: String

        @inlinable
        public init(portalArn: String, portalEndpoint: String) {
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case portalEndpoint = "portalEndpoint"
        }
    }

    public struct CreateTrustStoreRequest: AWSEncodableShape {
        /// A list of CA certificates to be added to the trust store.
        public let certificateList: [AWSBase64Data]
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The tags to add to the trust store. A tag is a key-value pair.
        public let tags: [Tag]?

        @inlinable
        public init(certificateList: [AWSBase64Data], clientToken: String? = CreateTrustStoreRequest.idempotencyToken(), tags: [Tag]? = nil) {
            self.certificateList = certificateList
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateList = "certificateList"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateTrustStoreResponse: AWSDecodableShape {
        /// The ARN of the trust store.
        public let trustStoreArn: String

        @inlinable
        public init(trustStoreArn: String) {
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct CreateUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The ARN of the Kinesis stream.
        public let kinesisStreamArn: String
        /// The tags to add to the user settings resource. A tag is a key-value pair.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateUserAccessLoggingSettingsRequest.idempotencyToken(), kinesisStreamArn: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.kinesisStreamArn = kinesisStreamArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, max: 2048)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, min: 20)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, pattern: "arn:[\\w+=/,.@-]+:kinesis:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:stream/.+")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case kinesisStreamArn = "kinesisStreamArn"
            case tags = "tags"
        }
    }

    public struct CreateUserAccessLoggingSettingsResponse: AWSDecodableShape {
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        @inlinable
        public init(userAccessLoggingSettingsArn: String) {
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
        }
    }

    public struct CreateUserSettingsRequest: AWSEncodableShape {
        /// The additional encryption context of the user settings.
        public let additionalEncryptionContext: [String: String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public let cookieSynchronizationConfiguration: CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public let copyAllowed: EnabledType
        /// The customer managed key used to encrypt sensitive information in the user settings.
        public let customerManagedKey: String?
        /// Specifies whether the user can use deep links that open automatically when connecting to a session.
        public let deepLinkAllowed: EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public let disconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public let downloadAllowed: EnabledType
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public let idleDisconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public let pasteAllowed: EnabledType
        /// Specifies whether the user can print to the local device.
        public let printAllowed: EnabledType
        /// The tags to add to the user settings resource. A tag is a key-value pair.
        public let tags: [Tag]?
        /// The configuration of the toolbar. This allows administrators to select the toolbar type and visual mode, set maximum display resolution for sessions, and choose which items are visible to end users during their sessions. If administrators do not modify these settings, end users retain control over their toolbar preferences.
        public let toolbarConfiguration: ToolbarConfiguration?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public let uploadAllowed: EnabledType

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, clientToken: String? = CreateUserSettingsRequest.idempotencyToken(), cookieSynchronizationConfiguration: CookieSynchronizationConfiguration? = nil, copyAllowed: EnabledType, customerManagedKey: String? = nil, deepLinkAllowed: EnabledType? = nil, disconnectTimeoutInMinutes: Int? = nil, downloadAllowed: EnabledType, idleDisconnectTimeoutInMinutes: Int? = nil, pasteAllowed: EnabledType, printAllowed: EnabledType, tags: [Tag]? = nil, toolbarConfiguration: ToolbarConfiguration? = nil, uploadAllowed: EnabledType) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.clientToken = clientToken
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.customerManagedKey = customerManagedKey
            self.deepLinkAllowed = deepLinkAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.tags = tags
            self.toolbarConfiguration = toolbarConfiguration
            self.uploadAllowed = uploadAllowed
        }

        public func validate(name: String) throws {
            try self.additionalEncryptionContext?.forEach {
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, max: 131072)
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.cookieSynchronizationConfiguration?.validate(name: "\(name).cookieSynchronizationConfiguration")
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, max: 2048)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, min: 20)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:kms:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:key\\/[a-zA-Z0-9-]+$")
            try self.validate(self.disconnectTimeoutInMinutes, name: "disconnectTimeoutInMinutes", parent: name, max: 600)
            try self.validate(self.disconnectTimeoutInMinutes, name: "disconnectTimeoutInMinutes", parent: name, min: 1)
            try self.validate(self.idleDisconnectTimeoutInMinutes, name: "idleDisconnectTimeoutInMinutes", parent: name, max: 60)
            try self.validate(self.idleDisconnectTimeoutInMinutes, name: "idleDisconnectTimeoutInMinutes", parent: name, min: 0)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case clientToken = "clientToken"
            case cookieSynchronizationConfiguration = "cookieSynchronizationConfiguration"
            case copyAllowed = "copyAllowed"
            case customerManagedKey = "customerManagedKey"
            case deepLinkAllowed = "deepLinkAllowed"
            case disconnectTimeoutInMinutes = "disconnectTimeoutInMinutes"
            case downloadAllowed = "downloadAllowed"
            case idleDisconnectTimeoutInMinutes = "idleDisconnectTimeoutInMinutes"
            case pasteAllowed = "pasteAllowed"
            case printAllowed = "printAllowed"
            case tags = "tags"
            case toolbarConfiguration = "toolbarConfiguration"
            case uploadAllowed = "uploadAllowed"
        }
    }

    public struct CreateUserSettingsResponse: AWSDecodableShape {
        /// The ARN of the user settings.
        public let userSettingsArn: String

        @inlinable
        public init(userSettingsArn: String) {
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct CustomPattern: AWSEncodableShape & AWSDecodableShape {
        /// The keyword regex for the customer pattern. After there is a match to the pattern regex, the keyword regex is used to search within the proximity of the match. If there is a keyword match, then the match is confirmed. If no keyword regex is provided, the pattern regex match will automatically be confirmed. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example, /ab+c/gi
        public let keywordRegex: String?
        /// The pattern description for the customer pattern.
        public let patternDescription: String?
        /// The pattern name for the custom pattern.
        public let patternName: String
        /// The pattern regex for the customer pattern. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example: /ab+c/gi.
        public let patternRegex: String

        @inlinable
        public init(keywordRegex: String? = nil, patternDescription: String? = nil, patternName: String, patternRegex: String) {
            self.keywordRegex = keywordRegex
            self.patternDescription = patternDescription
            self.patternName = patternName
            self.patternRegex = patternRegex
        }

        public func validate(name: String) throws {
            try self.validate(self.keywordRegex, name: "keywordRegex", parent: name, max: 300)
            try self.validate(self.keywordRegex, name: "keywordRegex", parent: name, pattern: "^\\/((?:[^\\n])+)\\/([gimsuyvd]{0,8})$")
            try self.validate(self.patternDescription, name: "patternDescription", parent: name, max: 256)
            try self.validate(self.patternDescription, name: "patternDescription", parent: name, min: 1)
            try self.validate(self.patternDescription, name: "patternDescription", parent: name, pattern: "^[ _\\-\\d\\w]+$")
            try self.validate(self.patternName, name: "patternName", parent: name, max: 20)
            try self.validate(self.patternName, name: "patternName", parent: name, min: 1)
            try self.validate(self.patternName, name: "patternName", parent: name, pattern: "^[_\\-\\d\\w]+$")
            try self.validate(self.patternRegex, name: "patternRegex", parent: name, max: 300)
            try self.validate(self.patternRegex, name: "patternRegex", parent: name, pattern: "^\\/((?:[^\\n])+)\\/([gimsuyvd]{0,8})$")
        }

        private enum CodingKeys: String, CodingKey {
            case keywordRegex = "keywordRegex"
            case patternDescription = "patternDescription"
            case patternName = "patternName"
            case patternRegex = "patternRegex"
        }
    }

    public struct DataProtectionSettings: AWSDecodableShape {
        /// The additional encryption context of the data protection settings.
        public let additionalEncryptionContext: [String: String]?
        /// A list of web portal ARNs that this data protection settings resource is associated with.
        public let associatedPortalArns: [String]?
        /// The creation date timestamp of the data protection settings.
        public let creationDate: Date?
        /// The customer managed key used to encrypt sensitive information in the data protection settings.
        public let customerManagedKey: String?
        /// The ARN of the data protection settings resource.
        public let dataProtectionSettingsArn: String
        /// The description of the data protection settings.
        public let description: String?
        /// The display name of the data protection settings.
        public let displayName: String?
        /// The inline redaction configuration for the data protection settings.
        public let inlineRedactionConfiguration: InlineRedactionConfiguration?

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, associatedPortalArns: [String]? = nil, creationDate: Date? = nil, customerManagedKey: String? = nil, dataProtectionSettingsArn: String, description: String? = nil, displayName: String? = nil, inlineRedactionConfiguration: InlineRedactionConfiguration? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.associatedPortalArns = associatedPortalArns
            self.creationDate = creationDate
            self.customerManagedKey = customerManagedKey
            self.dataProtectionSettingsArn = dataProtectionSettingsArn
            self.description = description
            self.displayName = displayName
            self.inlineRedactionConfiguration = inlineRedactionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case associatedPortalArns = "associatedPortalArns"
            case creationDate = "creationDate"
            case customerManagedKey = "customerManagedKey"
            case dataProtectionSettingsArn = "dataProtectionSettingsArn"
            case description = "description"
            case displayName = "displayName"
            case inlineRedactionConfiguration = "inlineRedactionConfiguration"
        }
    }

    public struct DataProtectionSettingsSummary: AWSDecodableShape {
        /// The creation date timestamp of the data protection settings.
        public let creationDate: Date?
        /// The ARN of the data protection settings.
        public let dataProtectionSettingsArn: String
        /// The description of the data protection settings.
        public let description: String?
        /// The display name of the data protection settings.
        public let displayName: String?

        @inlinable
        public init(creationDate: Date? = nil, dataProtectionSettingsArn: String, description: String? = nil, displayName: String? = nil) {
            self.creationDate = creationDate
            self.dataProtectionSettingsArn = dataProtectionSettingsArn
            self.description = description
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case dataProtectionSettingsArn = "dataProtectionSettingsArn"
            case description = "description"
            case displayName = "displayName"
        }
    }

    public struct DeleteBrowserSettingsRequest: AWSEncodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String

        @inlinable
        public init(browserSettingsArn: String) {
            self.browserSettingsArn = browserSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserSettingsArn, key: "browserSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, max: 2048)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, min: 20)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBrowserSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDataProtectionSettingsRequest: AWSEncodableShape {
        /// The ARN of the data protection settings.
        public let dataProtectionSettingsArn: String

        @inlinable
        public init(dataProtectionSettingsArn: String) {
            self.dataProtectionSettingsArn = dataProtectionSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataProtectionSettingsArn, key: "dataProtectionSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, max: 2048)
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, min: 20)
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataProtectionSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIdentityProviderRequest: AWSEncodableShape {
        /// The ARN of the identity provider.
        public let identityProviderArn: String

        @inlinable
        public init(identityProviderArn: String) {
            self.identityProviderArn = identityProviderArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identityProviderArn, key: "identityProviderArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, max: 2048)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, min: 20)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36}){2,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIdentityProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIpAccessSettingsRequest: AWSEncodableShape {
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String

        @inlinable
        public init(ipAccessSettingsArn: String) {
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.ipAccessSettingsArn, key: "ipAccessSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, max: 2048)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, min: 20)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIpAccessSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteNetworkSettingsRequest: AWSEncodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String

        @inlinable
        public init(networkSettingsArn: String) {
            self.networkSettingsArn = networkSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkSettingsArn, key: "networkSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, max: 2048)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, min: 20)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNetworkSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePortalRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTrustStoreRequest: AWSEncodableShape {
        /// The ARN of the trust store.
        public let trustStoreArn: String

        @inlinable
        public init(trustStoreArn: String) {
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTrustStoreResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        @inlinable
        public init(userAccessLoggingSettingsArn: String) {
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.userAccessLoggingSettingsArn, key: "userAccessLoggingSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, max: 2048)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, min: 20)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserAccessLoggingSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUserSettingsRequest: AWSEncodableShape {
        /// The ARN of the user settings.
        public let userSettingsArn: String

        @inlinable
        public init(userSettingsArn: String) {
            self.userSettingsArn = userSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.userSettingsArn, key: "userSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, max: 2048)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, min: 20)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateBrowserSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateBrowserSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateDataProtectionSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateDataProtectionSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateIpAccessSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateIpAccessSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateNetworkSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateNetworkSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateTrustStoreRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateTrustStoreResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateUserAccessLoggingSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateUserSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateUserSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ExpireSessionRequest: AWSEncodableShape {
        /// The ID of the web portal for the session.
        public let portalId: String
        /// The ID of the session to expire.
        public let sessionId: String

        @inlinable
        public init(portalId: String, sessionId: String) {
            self.portalId = portalId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalId, key: "portalId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 36)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 36)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExpireSessionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GetBrowserSettingsRequest: AWSEncodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String

        @inlinable
        public init(browserSettingsArn: String) {
            self.browserSettingsArn = browserSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserSettingsArn, key: "browserSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, max: 2048)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, min: 20)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBrowserSettingsResponse: AWSDecodableShape {
        /// The browser settings.
        public let browserSettings: BrowserSettings?

        @inlinable
        public init(browserSettings: BrowserSettings? = nil) {
            self.browserSettings = browserSettings
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettings = "browserSettings"
        }
    }

    public struct GetDataProtectionSettingsRequest: AWSEncodableShape {
        /// The ARN of the data protection settings.
        public let dataProtectionSettingsArn: String

        @inlinable
        public init(dataProtectionSettingsArn: String) {
            self.dataProtectionSettingsArn = dataProtectionSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataProtectionSettingsArn, key: "dataProtectionSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, max: 2048)
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, min: 20)
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataProtectionSettingsResponse: AWSDecodableShape {
        /// The data protection settings.
        public let dataProtectionSettings: DataProtectionSettings?

        @inlinable
        public init(dataProtectionSettings: DataProtectionSettings? = nil) {
            self.dataProtectionSettings = dataProtectionSettings
        }

        private enum CodingKeys: String, CodingKey {
            case dataProtectionSettings = "dataProtectionSettings"
        }
    }

    public struct GetIdentityProviderRequest: AWSEncodableShape {
        /// The ARN of the identity provider.
        public let identityProviderArn: String

        @inlinable
        public init(identityProviderArn: String) {
            self.identityProviderArn = identityProviderArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identityProviderArn, key: "identityProviderArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, max: 2048)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, min: 20)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36}){2,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdentityProviderResponse: AWSDecodableShape {
        /// The identity provider.
        public let identityProvider: IdentityProvider?

        @inlinable
        public init(identityProvider: IdentityProvider? = nil) {
            self.identityProvider = identityProvider
        }

        private enum CodingKeys: String, CodingKey {
            case identityProvider = "identityProvider"
        }
    }

    public struct GetIpAccessSettingsRequest: AWSEncodableShape {
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String

        @inlinable
        public init(ipAccessSettingsArn: String) {
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.ipAccessSettingsArn, key: "ipAccessSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, max: 2048)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, min: 20)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIpAccessSettingsResponse: AWSDecodableShape {
        /// The IP access settings.
        public let ipAccessSettings: IpAccessSettings?

        @inlinable
        public init(ipAccessSettings: IpAccessSettings? = nil) {
            self.ipAccessSettings = ipAccessSettings
        }

        private enum CodingKeys: String, CodingKey {
            case ipAccessSettings = "ipAccessSettings"
        }
    }

    public struct GetNetworkSettingsRequest: AWSEncodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String

        @inlinable
        public init(networkSettingsArn: String) {
            self.networkSettingsArn = networkSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkSettingsArn, key: "networkSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, max: 2048)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, min: 20)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkSettingsResponse: AWSDecodableShape {
        /// The network settings.
        public let networkSettings: NetworkSettings?

        @inlinable
        public init(networkSettings: NetworkSettings? = nil) {
            self.networkSettings = networkSettings
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettings = "networkSettings"
        }
    }

    public struct GetPortalRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPortalResponse: AWSDecodableShape {
        /// The web portal.
        public let portal: Portal?

        @inlinable
        public init(portal: Portal? = nil) {
            self.portal = portal
        }

        private enum CodingKeys: String, CodingKey {
            case portal = "portal"
        }
    }

    public struct GetPortalServiceProviderMetadataRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPortalServiceProviderMetadataResponse: AWSDecodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The service provider SAML metadata.
        public let serviceProviderSamlMetadata: String?

        @inlinable
        public init(portalArn: String, serviceProviderSamlMetadata: String? = nil) {
            self.portalArn = portalArn
            self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case serviceProviderSamlMetadata = "serviceProviderSamlMetadata"
        }
    }

    public struct GetSessionRequest: AWSEncodableShape {
        /// The ID of the web portal for the session.
        public let portalId: String
        /// The ID of the session.
        public let sessionId: String

        @inlinable
        public init(portalId: String, sessionId: String) {
            self.portalId = portalId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalId, key: "portalId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 36)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 36)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionResponse: AWSDecodableShape {
        /// The sessions in a list.
        public let session: Session?

        @inlinable
        public init(session: Session? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct GetTrustStoreCertificateRequest: AWSEncodableShape {
        /// The thumbprint of the trust store certificate.
        public let thumbprint: String
        /// The ARN of the trust store certificate.
        public let trustStoreArn: String

        @inlinable
        public init(thumbprint: String, trustStoreArn: String) {
            self.thumbprint = thumbprint
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.thumbprint, key: "thumbprint")
            request.encodePath(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.thumbprint, name: "thumbprint", parent: name, max: 64)
            try self.validate(self.thumbprint, name: "thumbprint", parent: name, min: 64)
            try self.validate(self.thumbprint, name: "thumbprint", parent: name, pattern: "^[A-Fa-f0-9]{64}$")
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTrustStoreCertificateResponse: AWSDecodableShape {
        /// The certificate of the trust store certificate.
        public let certificate: Certificate?
        /// The ARN of the trust store certificate.
        public let trustStoreArn: String

        @inlinable
        public init(certificate: Certificate? = nil, trustStoreArn: String) {
            self.certificate = certificate
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "certificate"
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct GetTrustStoreRequest: AWSEncodableShape {
        /// The ARN of the trust store.
        public let trustStoreArn: String

        @inlinable
        public init(trustStoreArn: String) {
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTrustStoreResponse: AWSDecodableShape {
        /// The trust store.
        public let trustStore: TrustStore?

        @inlinable
        public init(trustStore: TrustStore? = nil) {
            self.trustStore = trustStore
        }

        private enum CodingKeys: String, CodingKey {
            case trustStore = "trustStore"
        }
    }

    public struct GetUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        @inlinable
        public init(userAccessLoggingSettingsArn: String) {
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.userAccessLoggingSettingsArn, key: "userAccessLoggingSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, max: 2048)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, min: 20)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUserAccessLoggingSettingsResponse: AWSDecodableShape {
        /// The user access logging settings.
        public let userAccessLoggingSettings: UserAccessLoggingSettings?

        @inlinable
        public init(userAccessLoggingSettings: UserAccessLoggingSettings? = nil) {
            self.userAccessLoggingSettings = userAccessLoggingSettings
        }

        private enum CodingKeys: String, CodingKey {
            case userAccessLoggingSettings = "userAccessLoggingSettings"
        }
    }

    public struct GetUserSettingsRequest: AWSEncodableShape {
        /// The ARN of the user settings.
        public let userSettingsArn: String

        @inlinable
        public init(userSettingsArn: String) {
            self.userSettingsArn = userSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.userSettingsArn, key: "userSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, max: 2048)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, min: 20)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUserSettingsResponse: AWSDecodableShape {
        /// The user settings.
        public let userSettings: UserSettings?

        @inlinable
        public init(userSettings: UserSettings? = nil) {
            self.userSettings = userSettings
        }

        private enum CodingKeys: String, CodingKey {
            case userSettings = "userSettings"
        }
    }

    public struct IdentityProvider: AWSDecodableShape {
        /// The ARN of the identity provider.
        public let identityProviderArn: String
        /// The identity provider details. The following list describes the provider detail keys for each identity provider type.    For Google and Login with Amazon:    client_id     client_secret     authorize_scopes      For Facebook:    client_id     client_secret     authorize_scopes     api_version      For Sign in with Apple:    client_id     team_id     key_id     private_key     authorize_scopes      For OIDC providers:    client_id     client_secret     attributes_request_method     oidc_issuer     authorize_scopes     authorize_url if not available from discovery URL specified by oidc_issuer key     token_url if not available from discovery URL specified by oidc_issuer key     attributes_url if not available from discovery URL specified by oidc_issuer key     jwks_uri if not available from discovery URL specified by oidc_issuer key      For SAML providers:    MetadataFile OR MetadataURL     IDPSignout (boolean) optional     IDPInit (boolean) optional     RequestSigningAlgorithm (string) optional - Only accepts rsa-sha256     EncryptedResponses (boolean) optional
        public let identityProviderDetails: [String: String]?
        /// The identity provider name.
        public let identityProviderName: String?
        /// The identity provider type.
        public let identityProviderType: IdentityProviderType?

        @inlinable
        public init(identityProviderArn: String, identityProviderDetails: [String: String]? = nil, identityProviderName: String? = nil, identityProviderType: IdentityProviderType? = nil) {
            self.identityProviderArn = identityProviderArn
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }

        private enum CodingKeys: String, CodingKey {
            case identityProviderArn = "identityProviderArn"
            case identityProviderDetails = "identityProviderDetails"
            case identityProviderName = "identityProviderName"
            case identityProviderType = "identityProviderType"
        }
    }

    public struct IdentityProviderSummary: AWSDecodableShape {
        /// The ARN of the identity provider.
        public let identityProviderArn: String
        /// The identity provider name.
        public let identityProviderName: String?
        /// The identity provider type.
        public let identityProviderType: IdentityProviderType?

        @inlinable
        public init(identityProviderArn: String, identityProviderName: String? = nil, identityProviderType: IdentityProviderType? = nil) {
            self.identityProviderArn = identityProviderArn
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }

        private enum CodingKeys: String, CodingKey {
            case identityProviderArn = "identityProviderArn"
            case identityProviderName = "identityProviderName"
            case identityProviderType = "identityProviderType"
        }
    }

    public struct InlineRedactionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The global confidence level for the inline redaction configuration. This indicates the certainty of data type matches in the redaction process. Confidence level 3 means high confidence, and requires a formatted text pattern match in order for content to be redacted. Confidence level 2 means medium confidence, and redaction considers both formatted and unformatted text, and adds keyword associate to the logic. Confidence level 1 means low confidence, and redaction is enforced for both formatted pattern + unformatted pattern without keyword. This is applied to patterns that do not have a pattern-level confidence level. Defaults to confidence level 2.
        public let globalConfidenceLevel: Int?
        /// The global enforced URL configuration for the inline redaction configuration. This is applied to patterns that do not have a pattern-level enforced URL list.
        public let globalEnforcedUrls: [String]?
        /// The global exempt URL configuration for the inline redaction configuration. This is applied to patterns that do not have a pattern-level exempt URL list.
        public let globalExemptUrls: [String]?
        /// The inline redaction patterns to be enabled for the inline redaction configuration.
        public let inlineRedactionPatterns: [InlineRedactionPattern]

        @inlinable
        public init(globalConfidenceLevel: Int? = nil, globalEnforcedUrls: [String]? = nil, globalExemptUrls: [String]? = nil, inlineRedactionPatterns: [InlineRedactionPattern]) {
            self.globalConfidenceLevel = globalConfidenceLevel
            self.globalEnforcedUrls = globalEnforcedUrls
            self.globalExemptUrls = globalExemptUrls
            self.inlineRedactionPatterns = inlineRedactionPatterns
        }

        public func validate(name: String) throws {
            try self.validate(self.globalConfidenceLevel, name: "globalConfidenceLevel", parent: name, max: 3)
            try self.validate(self.globalConfidenceLevel, name: "globalConfidenceLevel", parent: name, min: 1)
            try self.globalEnforcedUrls?.forEach {
                try validate($0, name: "globalEnforcedUrls[]", parent: name, pattern: "^((([a-zA-Z][a-zA-Z0-9+.-]*):\\/\\/(\\*|[\\w%._\\-\\+~#=@]+)?(\\/[^@\\s]*)?(?:\\?([^*\\s]+(?:\\*?)))?)|(\\*|[\\w%._\\-\\+~#=@]+\\.[\\w%._\\-\\+~#=@]+)(?::(\\d{1,5}))?(\\/[^@\\s]*)?(?:\\?([^*\\s]+(?:\\*?)))?|(([a-zA-Z][a-zA-Z0-9+.-]*):(\\/\\/)?\\*))$")
            }
            try self.validate(self.globalEnforcedUrls, name: "globalEnforcedUrls", parent: name, max: 100)
            try self.validate(self.globalEnforcedUrls, name: "globalEnforcedUrls", parent: name, min: 1)
            try self.globalExemptUrls?.forEach {
                try validate($0, name: "globalExemptUrls[]", parent: name, pattern: "^((([a-zA-Z][a-zA-Z0-9+.-]*):\\/\\/(\\*|[\\w%._\\-\\+~#=@]+)?(\\/[^@\\s]*)?(?:\\?([^*\\s]+(?:\\*?)))?)|(\\*|[\\w%._\\-\\+~#=@]+\\.[\\w%._\\-\\+~#=@]+)(?::(\\d{1,5}))?(\\/[^@\\s]*)?(?:\\?([^*\\s]+(?:\\*?)))?|(([a-zA-Z][a-zA-Z0-9+.-]*):(\\/\\/)?\\*))$")
            }
            try self.validate(self.globalExemptUrls, name: "globalExemptUrls", parent: name, max: 100)
            try self.validate(self.globalExemptUrls, name: "globalExemptUrls", parent: name, min: 1)
            try self.inlineRedactionPatterns.forEach {
                try $0.validate(name: "\(name).inlineRedactionPatterns[]")
            }
            try self.validate(self.inlineRedactionPatterns, name: "inlineRedactionPatterns", parent: name, max: 150)
        }

        private enum CodingKeys: String, CodingKey {
            case globalConfidenceLevel = "globalConfidenceLevel"
            case globalEnforcedUrls = "globalEnforcedUrls"
            case globalExemptUrls = "globalExemptUrls"
            case inlineRedactionPatterns = "inlineRedactionPatterns"
        }
    }

    public struct InlineRedactionPattern: AWSEncodableShape & AWSDecodableShape {
        /// The built-in pattern from the list of preconfigured patterns. Either a customPattern or builtInPatternId is required.
        public let builtInPatternId: String?
        /// The confidence level for inline redaction pattern. This indicates the certainty of data type matches in the redaction process. Confidence level 3 means high confidence, and requires a formatted text pattern match in order for content to be redacted. Confidence level 2 means medium confidence, and redaction considers both formatted and unformatted text, and adds keyword associate to the logic. Confidence level 1 means low confidence, and redaction is enforced for both formatted pattern + unformatted pattern without keyword. This overrides the global confidence level.
        public let confidenceLevel: Int?
        /// &gt;The configuration for a custom pattern. Either a customPattern or builtInPatternId is required.
        public let customPattern: CustomPattern?
        /// The enforced URL configuration for the inline redaction pattern. This will override the global enforced URL configuration.
        public let enforcedUrls: [String]?
        /// The exempt URL configuration for the inline redaction pattern. This will override the global exempt URL configuration for the inline redaction pattern.
        public let exemptUrls: [String]?
        /// The redaction placeholder that will replace the redacted text in session for the inline redaction pattern.
        public let redactionPlaceHolder: RedactionPlaceHolder

        @inlinable
        public init(builtInPatternId: String? = nil, confidenceLevel: Int? = nil, customPattern: CustomPattern? = nil, enforcedUrls: [String]? = nil, exemptUrls: [String]? = nil, redactionPlaceHolder: RedactionPlaceHolder) {
            self.builtInPatternId = builtInPatternId
            self.confidenceLevel = confidenceLevel
            self.customPattern = customPattern
            self.enforcedUrls = enforcedUrls
            self.exemptUrls = exemptUrls
            self.redactionPlaceHolder = redactionPlaceHolder
        }

        public func validate(name: String) throws {
            try self.validate(self.builtInPatternId, name: "builtInPatternId", parent: name, max: 50)
            try self.validate(self.builtInPatternId, name: "builtInPatternId", parent: name, min: 1)
            try self.validate(self.builtInPatternId, name: "builtInPatternId", parent: name, pattern: "^[_\\-\\d\\w]+$")
            try self.validate(self.confidenceLevel, name: "confidenceLevel", parent: name, max: 3)
            try self.validate(self.confidenceLevel, name: "confidenceLevel", parent: name, min: 1)
            try self.customPattern?.validate(name: "\(name).customPattern")
            try self.enforcedUrls?.forEach {
                try validate($0, name: "enforcedUrls[]", parent: name, pattern: "^((([a-zA-Z][a-zA-Z0-9+.-]*):\\/\\/(\\*|[\\w%._\\-\\+~#=@]+)?(\\/[^@\\s]*)?(?:\\?([^*\\s]+(?:\\*?)))?)|(\\*|[\\w%._\\-\\+~#=@]+\\.[\\w%._\\-\\+~#=@]+)(?::(\\d{1,5}))?(\\/[^@\\s]*)?(?:\\?([^*\\s]+(?:\\*?)))?|(([a-zA-Z][a-zA-Z0-9+.-]*):(\\/\\/)?\\*))$")
            }
            try self.validate(self.enforcedUrls, name: "enforcedUrls", parent: name, max: 20)
            try self.validate(self.enforcedUrls, name: "enforcedUrls", parent: name, min: 1)
            try self.exemptUrls?.forEach {
                try validate($0, name: "exemptUrls[]", parent: name, pattern: "^((([a-zA-Z][a-zA-Z0-9+.-]*):\\/\\/(\\*|[\\w%._\\-\\+~#=@]+)?(\\/[^@\\s]*)?(?:\\?([^*\\s]+(?:\\*?)))?)|(\\*|[\\w%._\\-\\+~#=@]+\\.[\\w%._\\-\\+~#=@]+)(?::(\\d{1,5}))?(\\/[^@\\s]*)?(?:\\?([^*\\s]+(?:\\*?)))?|(([a-zA-Z][a-zA-Z0-9+.-]*):(\\/\\/)?\\*))$")
            }
            try self.validate(self.exemptUrls, name: "exemptUrls", parent: name, max: 20)
            try self.validate(self.exemptUrls, name: "exemptUrls", parent: name, min: 1)
            try self.redactionPlaceHolder.validate(name: "\(name).redactionPlaceHolder")
        }

        private enum CodingKeys: String, CodingKey {
            case builtInPatternId = "builtInPatternId"
            case confidenceLevel = "confidenceLevel"
            case customPattern = "customPattern"
            case enforcedUrls = "enforcedUrls"
            case exemptUrls = "exemptUrls"
            case redactionPlaceHolder = "redactionPlaceHolder"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String?
        /// Advice to clients on when the call can be safely retried.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String? = nil, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct IpAccessSettings: AWSDecodableShape {
        /// The additional encryption context of the IP access settings.
        public let additionalEncryptionContext: [String: String]?
        /// A list of web portal ARNs that this IP access settings resource is associated with.
        public let associatedPortalArns: [String]?
        /// The creation date timestamp of the IP access settings.
        public let creationDate: Date?
        /// The customer managed key used to encrypt sensitive information in the IP access settings.
        public let customerManagedKey: String?
        /// The description of the IP access settings.
        public let description: String?
        ///  The display name of the IP access settings.
        public let displayName: String?
        /// The ARN of the IP access settings resource.
        public let ipAccessSettingsArn: String
        /// The IP rules of the IP access settings.
        public let ipRules: [IpRule]?

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, associatedPortalArns: [String]? = nil, creationDate: Date? = nil, customerManagedKey: String? = nil, description: String? = nil, displayName: String? = nil, ipAccessSettingsArn: String, ipRules: [IpRule]? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.associatedPortalArns = associatedPortalArns
            self.creationDate = creationDate
            self.customerManagedKey = customerManagedKey
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.ipRules = ipRules
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case associatedPortalArns = "associatedPortalArns"
            case creationDate = "creationDate"
            case customerManagedKey = "customerManagedKey"
            case description = "description"
            case displayName = "displayName"
            case ipAccessSettingsArn = "ipAccessSettingsArn"
            case ipRules = "ipRules"
        }
    }

    public struct IpAccessSettingsSummary: AWSDecodableShape {
        /// The creation date timestamp of the IP access settings.
        public let creationDate: Date?
        /// The description of the IP access settings.
        public let description: String?
        /// The display name of the IP access settings.
        public let displayName: String?
        /// The ARN of IP access settings.
        public let ipAccessSettingsArn: String

        @inlinable
        public init(creationDate: Date? = nil, description: String? = nil, displayName: String? = nil, ipAccessSettingsArn: String) {
            self.creationDate = creationDate
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case displayName = "displayName"
            case ipAccessSettingsArn = "ipAccessSettingsArn"
        }
    }

    public struct IpRule: AWSEncodableShape & AWSDecodableShape {
        /// The description of the IP rule.
        public let description: String?
        /// The IP range of the IP rule.
        public let ipRange: String

        @inlinable
        public init(description: String? = nil, ipRange: String) {
            self.description = description
            self.ipRange = ipRange
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.validate(self.ipRange, name: "ipRange", parent: name, pattern: "^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(?:/([0-9]|[12][0-9]|3[0-2])|)$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case ipRange = "ipRange"
        }
    }

    public struct ListBrowserSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBrowserSettingsResponse: AWSDecodableShape {
        /// The browser settings.
        public let browserSettings: [BrowserSettingsSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(browserSettings: [BrowserSettingsSummary]? = nil, nextToken: String? = nil) {
            self.browserSettings = browserSettings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettings = "browserSettings"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataProtectionSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataProtectionSettingsResponse: AWSDecodableShape {
        /// The data protection settings.
        public let dataProtectionSettings: [DataProtectionSettingsSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(dataProtectionSettings: [DataProtectionSettingsSummary]? = nil, nextToken: String? = nil) {
            self.dataProtectionSettings = dataProtectionSettings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataProtectionSettings = "dataProtectionSettings"
            case nextToken = "nextToken"
        }
    }

    public struct ListIdentityProvidersRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, portalArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdentityProvidersResponse: AWSDecodableShape {
        /// The identity providers.
        public let identityProviders: [IdentityProviderSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(identityProviders: [IdentityProviderSummary]? = nil, nextToken: String? = nil) {
            self.identityProviders = identityProviders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case identityProviders = "identityProviders"
            case nextToken = "nextToken"
        }
    }

    public struct ListIpAccessSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIpAccessSettingsResponse: AWSDecodableShape {
        /// The IP access settings.
        public let ipAccessSettings: [IpAccessSettingsSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(ipAccessSettings: [IpAccessSettingsSummary]? = nil, nextToken: String? = nil) {
            self.ipAccessSettings = ipAccessSettings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ipAccessSettings = "ipAccessSettings"
            case nextToken = "nextToken"
        }
    }

    public struct ListNetworkSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNetworkSettingsResponse: AWSDecodableShape {
        /// The network settings.
        public let networkSettings: [NetworkSettingsSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(networkSettings: [NetworkSettingsSummary]? = nil, nextToken: String? = nil) {
            self.networkSettings = networkSettings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettings = "networkSettings"
            case nextToken = "nextToken"
        }
    }

    public struct ListPortalsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPortalsResponse: AWSDecodableShape {
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The portals in the list.
        public let portals: [PortalSummary]?

        @inlinable
        public init(nextToken: String? = nil, portals: [PortalSummary]? = nil) {
            self.nextToken = nextToken
            self.portals = portals
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case portals = "portals"
        }
    }

    public struct ListSessionsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The ID of the web portal for the sessions.
        public let portalId: String
        /// The ID of the session.
        public let sessionId: String?
        /// The method in which the returned sessions should be sorted.
        public let sortBy: SessionSortBy?
        /// The status of the session.
        public let status: SessionStatus?
        /// The username of the session.
        public let username: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, portalId: String, sessionId: String? = nil, sortBy: SessionSortBy? = nil, status: SessionStatus? = nil, username: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.portalId = portalId
            self.sessionId = sessionId
            self.sortBy = sortBy
            self.status = status
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.portalId, key: "portalId")
            request.encodeQuery(self.sessionId, key: "sessionId")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.username, key: "username")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 36)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 36)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9\\-]+$")
            try self.validate(self.username, name: "username", parent: name, max: 256)
            try self.validate(self.username, name: "username", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSessionsResponse: AWSDecodableShape {
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The sessions in a list.
        public let sessions: [SessionSummary]

        @inlinable
        public init(nextToken: String? = nil, sessions: [SessionSummary]) {
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessions = "sessions"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags of the resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTrustStoreCertificatesRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The ARN of the trust store
        public let trustStoreArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, trustStoreArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTrustStoreCertificatesResponse: AWSDecodableShape {
        /// The certificate list.
        public let certificateList: [CertificateSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.&gt;
        public let nextToken: String?
        /// The ARN of the trust store.
        public let trustStoreArn: String

        @inlinable
        public init(certificateList: [CertificateSummary]? = nil, nextToken: String? = nil, trustStoreArn: String) {
            self.certificateList = certificateList
            self.nextToken = nextToken
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateList = "certificateList"
            case nextToken = "nextToken"
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct ListTrustStoresRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTrustStoresResponse: AWSDecodableShape {
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The trust stores.
        public let trustStores: [TrustStoreSummary]?

        @inlinable
        public init(nextToken: String? = nil, trustStores: [TrustStoreSummary]? = nil) {
            self.nextToken = nextToken
            self.trustStores = trustStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case trustStores = "trustStores"
        }
    }

    public struct ListUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUserAccessLoggingSettingsResponse: AWSDecodableShape {
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The user access logging settings.
        public let userAccessLoggingSettings: [UserAccessLoggingSettingsSummary]?

        @inlinable
        public init(nextToken: String? = nil, userAccessLoggingSettings: [UserAccessLoggingSettingsSummary]? = nil) {
            self.nextToken = nextToken
            self.userAccessLoggingSettings = userAccessLoggingSettings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case userAccessLoggingSettings = "userAccessLoggingSettings"
        }
    }

    public struct ListUserSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUserSettingsResponse: AWSDecodableShape {
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The user settings.
        public let userSettings: [UserSettingsSummary]?

        @inlinable
        public init(nextToken: String? = nil, userSettings: [UserSettingsSummary]? = nil) {
            self.nextToken = nextToken
            self.userSettings = userSettings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case userSettings = "userSettings"
        }
    }

    public struct NetworkSettings: AWSDecodableShape {
        /// A list of web portal ARNs that this network settings is associated with.
        public let associatedPortalArns: [String]?
        /// The ARN of the network settings.
        public let networkSettingsArn: String
        /// One or more security groups used to control access from streaming instances to your VPC.
        public let securityGroupIds: [String]?
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public let subnetIds: [String]?
        /// The VPC that streaming instances will connect to.
        public let vpcId: String?

        @inlinable
        public init(associatedPortalArns: [String]? = nil, networkSettingsArn: String, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.associatedPortalArns = associatedPortalArns
            self.networkSettingsArn = networkSettingsArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case associatedPortalArns = "associatedPortalArns"
            case networkSettingsArn = "networkSettingsArn"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct NetworkSettingsSummary: AWSDecodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String
        /// The VPC ID of the network settings.
        public let vpcId: String?

        @inlinable
        public init(networkSettingsArn: String, vpcId: String? = nil) {
            self.networkSettingsArn = networkSettingsArn
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettingsArn = "networkSettingsArn"
            case vpcId = "vpcId"
        }
    }

    public struct Portal: AWSDecodableShape {
        /// The additional encryption context of the portal.
        public let additionalEncryptionContext: [String: String]?
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard.  Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.  IAM Identity Center web portals are authenticated through IAM Identity Center. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public let authenticationType: AuthenticationType?
        /// The ARN of the browser settings that is associated with this web portal.
        public let browserSettingsArn: String?
        /// The browser that users see when using a streaming session.
        public let browserType: BrowserType?
        /// The creation date of the web portal.
        public let creationDate: Date?
        /// The customer managed key used to encrypt sensitive information in the portal.
        public let customerManagedKey: String?
        /// The ARN of the data protection settings.
        public let dataProtectionSettingsArn: String?
        /// The name of the web portal.
        public let displayName: String?
        /// The type and resources of the underlying instance.
        public let instanceType: InstanceType?
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String?
        /// The maximum number of concurrent sessions for the portal.
        public let maxConcurrentSessions: Int?
        /// The ARN of the network settings that is associated with the web portal.
        public let networkSettingsArn: String?
        /// The ARN of the web portal.
        public let portalArn: String
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public let portalEndpoint: String?
        /// The status of the web portal.
        public let portalStatus: PortalStatus?
        /// The renderer that is used in streaming sessions.
        public let rendererType: RendererType?
        /// A message that explains why the web portal is in its current status.
        public let statusReason: String?
        /// The ARN of the trust store that is associated with the web portal.
        public let trustStoreArn: String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public let userAccessLoggingSettingsArn: String?
        /// The ARN of the user settings that is associated with the web portal.
        public let userSettingsArn: String?

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, authenticationType: AuthenticationType? = nil, browserSettingsArn: String? = nil, browserType: BrowserType? = nil, creationDate: Date? = nil, customerManagedKey: String? = nil, dataProtectionSettingsArn: String? = nil, displayName: String? = nil, instanceType: InstanceType? = nil, ipAccessSettingsArn: String? = nil, maxConcurrentSessions: Int? = nil, networkSettingsArn: String? = nil, portalArn: String, portalEndpoint: String? = nil, portalStatus: PortalStatus? = nil, rendererType: RendererType? = nil, statusReason: String? = nil, trustStoreArn: String? = nil, userAccessLoggingSettingsArn: String? = nil, userSettingsArn: String? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.authenticationType = authenticationType
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.customerManagedKey = customerManagedKey
            self.dataProtectionSettingsArn = dataProtectionSettingsArn
            self.displayName = displayName
            self.instanceType = instanceType
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.maxConcurrentSessions = maxConcurrentSessions
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.statusReason = statusReason
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case authenticationType = "authenticationType"
            case browserSettingsArn = "browserSettingsArn"
            case browserType = "browserType"
            case creationDate = "creationDate"
            case customerManagedKey = "customerManagedKey"
            case dataProtectionSettingsArn = "dataProtectionSettingsArn"
            case displayName = "displayName"
            case instanceType = "instanceType"
            case ipAccessSettingsArn = "ipAccessSettingsArn"
            case maxConcurrentSessions = "maxConcurrentSessions"
            case networkSettingsArn = "networkSettingsArn"
            case portalArn = "portalArn"
            case portalEndpoint = "portalEndpoint"
            case portalStatus = "portalStatus"
            case rendererType = "rendererType"
            case statusReason = "statusReason"
            case trustStoreArn = "trustStoreArn"
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct PortalSummary: AWSDecodableShape {
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard.  Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.  IAM Identity Center web portals are authenticated through IAM Identity Center. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public let authenticationType: AuthenticationType?
        /// The ARN of the browser settings that is associated with the web portal.
        public let browserSettingsArn: String?
        /// The browser type of the web portal.
        public let browserType: BrowserType?
        /// The creation date of the web portal.
        public let creationDate: Date?
        /// The ARN of the data protection settings.
        public let dataProtectionSettingsArn: String?
        /// The name of the web portal.
        public let displayName: String?
        /// The type and resources of the underlying instance.
        public let instanceType: InstanceType?
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String?
        /// The maximum number of concurrent sessions for the portal.
        public let maxConcurrentSessions: Int?
        /// The ARN of the network settings that is associated with the web portal.
        public let networkSettingsArn: String?
        /// The ARN of the web portal.
        public let portalArn: String
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public let portalEndpoint: String?
        /// The status of the web portal.
        public let portalStatus: PortalStatus?
        /// The renderer that is used in streaming sessions.
        public let rendererType: RendererType?
        /// The ARN of the trust that is associated with this web portal.
        public let trustStoreArn: String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public let userAccessLoggingSettingsArn: String?
        /// The ARN of the user settings that is associated with the web portal.
        public let userSettingsArn: String?

        @inlinable
        public init(authenticationType: AuthenticationType? = nil, browserSettingsArn: String? = nil, browserType: BrowserType? = nil, creationDate: Date? = nil, dataProtectionSettingsArn: String? = nil, displayName: String? = nil, instanceType: InstanceType? = nil, ipAccessSettingsArn: String? = nil, maxConcurrentSessions: Int? = nil, networkSettingsArn: String? = nil, portalArn: String, portalEndpoint: String? = nil, portalStatus: PortalStatus? = nil, rendererType: RendererType? = nil, trustStoreArn: String? = nil, userAccessLoggingSettingsArn: String? = nil, userSettingsArn: String? = nil) {
            self.authenticationType = authenticationType
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.dataProtectionSettingsArn = dataProtectionSettingsArn
            self.displayName = displayName
            self.instanceType = instanceType
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.maxConcurrentSessions = maxConcurrentSessions
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
            case browserSettingsArn = "browserSettingsArn"
            case browserType = "browserType"
            case creationDate = "creationDate"
            case dataProtectionSettingsArn = "dataProtectionSettingsArn"
            case displayName = "displayName"
            case instanceType = "instanceType"
            case ipAccessSettingsArn = "ipAccessSettingsArn"
            case maxConcurrentSessions = "maxConcurrentSessions"
            case networkSettingsArn = "networkSettingsArn"
            case portalArn = "portalArn"
            case portalEndpoint = "portalEndpoint"
            case portalStatus = "portalStatus"
            case rendererType = "rendererType"
            case trustStoreArn = "trustStoreArn"
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct RedactionPlaceHolder: AWSEncodableShape & AWSDecodableShape {
        /// The redaction placeholder text that will replace the redacted text in session for the custom text redaction placeholder type.
        public let redactionPlaceHolderText: String?
        /// The redaction placeholder type that will replace the redacted text in session.
        public let redactionPlaceHolderType: RedactionPlaceHolderType

        @inlinable
        public init(redactionPlaceHolderText: String? = nil, redactionPlaceHolderType: RedactionPlaceHolderType) {
            self.redactionPlaceHolderText = redactionPlaceHolderText
            self.redactionPlaceHolderType = redactionPlaceHolderType
        }

        public func validate(name: String) throws {
            try self.validate(self.redactionPlaceHolderText, name: "redactionPlaceHolderText", parent: name, max: 20)
            try self.validate(self.redactionPlaceHolderText, name: "redactionPlaceHolderText", parent: name, min: 1)
            try self.validate(self.redactionPlaceHolderText, name: "redactionPlaceHolderText", parent: name, pattern: "^[*_\\-\\d\\w]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case redactionPlaceHolderText = "redactionPlaceHolderText"
            case redactionPlaceHolderType = "redactionPlaceHolderType"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// Hypothetical identifier of the resource affected.
        public let resourceId: String?
        /// Hypothetical type of the resource affected.
        public let resourceType: String?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String?
        /// The originating quota.
        public let quotaCode: String?
        /// Identifier of the resource affected.
        public let resourceId: String?
        ///  Type of the resource affected.
        public let resourceType: String?
        /// The originating service.
        public let serviceCode: String?

        @inlinable
        public init(message: String? = nil, quotaCode: String? = nil, resourceId: String? = nil, resourceType: String? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct Session: AWSDecodableShape {
        /// The IP address of the client.
        public let clientIpAddresses: [String]?
        /// The end time of the session.
        public let endTime: Date?
        /// The ARN of the web portal.
        public let portalArn: String?
        /// The ID of the session.
        public let sessionId: String?
        /// The start time of the session.
        public let startTime: Date?
        /// The status of the session.
        public let status: SessionStatus?
        /// The username of the session.
        public let username: String?

        @inlinable
        public init(clientIpAddresses: [String]? = nil, endTime: Date? = nil, portalArn: String? = nil, sessionId: String? = nil, startTime: Date? = nil, status: SessionStatus? = nil, username: String? = nil) {
            self.clientIpAddresses = clientIpAddresses
            self.endTime = endTime
            self.portalArn = portalArn
            self.sessionId = sessionId
            self.startTime = startTime
            self.status = status
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case clientIpAddresses = "clientIpAddresses"
            case endTime = "endTime"
            case portalArn = "portalArn"
            case sessionId = "sessionId"
            case startTime = "startTime"
            case status = "status"
            case username = "username"
        }
    }

    public struct SessionSummary: AWSDecodableShape {
        /// The end time of the session.
        public let endTime: Date?
        /// The ARN of the web portal.
        public let portalArn: String?
        /// The ID of the session.
        public let sessionId: String?
        /// The start time of the session.
        public let startTime: Date?
        /// The status of the session.
        public let status: SessionStatus?
        /// The username of the session.
        public let username: String?

        @inlinable
        public init(endTime: Date? = nil, portalArn: String? = nil, sessionId: String? = nil, startTime: Date? = nil, status: SessionStatus? = nil, username: String? = nil) {
            self.endTime = endTime
            self.portalArn = portalArn
            self.sessionId = sessionId
            self.startTime = startTime
            self.status = status
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case portalArn = "portalArn"
            case sessionId = "sessionId"
            case startTime = "startTime"
            case status = "status"
            case username = "username"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the tag.
        public let key: String
        /// The value of the tag
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The ARN of the resource.
        public let resourceArn: String
        /// The tags of the resource.
        public let tags: [Tag]

        @inlinable
        public init(clientToken: String? = TagResourceRequest.idempotencyToken(), resourceArn: String, tags: [Tag]) {
            self.clientToken = clientToken
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String?
        /// The originating quota.
        public let quotaCode: String?
        /// Advice to clients on when the call can be safely retried.
        public let retryAfterSeconds: Int?
        /// The originating service.
        public let serviceCode: String?

        @inlinable
        public init(message: String? = nil, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct TooManyTagsException: AWSErrorShape {
        public let message: String?
        /// Name of the resource affected.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct ToolbarConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The list of toolbar items to be hidden.
        public let hiddenToolbarItems: [ToolbarItem]?
        /// The maximum display resolution that is allowed for the session.
        public let maxDisplayResolution: MaxDisplayResolution?
        /// The type of toolbar displayed during the session.
        public let toolbarType: ToolbarType?
        /// The visual mode of the toolbar.
        public let visualMode: VisualMode?

        @inlinable
        public init(hiddenToolbarItems: [ToolbarItem]? = nil, maxDisplayResolution: MaxDisplayResolution? = nil, toolbarType: ToolbarType? = nil, visualMode: VisualMode? = nil) {
            self.hiddenToolbarItems = hiddenToolbarItems
            self.maxDisplayResolution = maxDisplayResolution
            self.toolbarType = toolbarType
            self.visualMode = visualMode
        }

        private enum CodingKeys: String, CodingKey {
            case hiddenToolbarItems = "hiddenToolbarItems"
            case maxDisplayResolution = "maxDisplayResolution"
            case toolbarType = "toolbarType"
            case visualMode = "visualMode"
        }
    }

    public struct TrustStore: AWSDecodableShape {
        /// A list of web portal ARNs that this trust store is associated with.
        public let associatedPortalArns: [String]?
        /// The ARN of the trust store.
        public let trustStoreArn: String

        @inlinable
        public init(associatedPortalArns: [String]? = nil, trustStoreArn: String) {
            self.associatedPortalArns = associatedPortalArns
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case associatedPortalArns = "associatedPortalArns"
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct TrustStoreSummary: AWSDecodableShape {
        /// The ARN of the trust store.
        public let trustStoreArn: String?

        @inlinable
        public init(trustStoreArn: String? = nil) {
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBrowserSettingsRequest: AWSEncodableShape {
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public let browserPolicy: String?
        /// The ARN of the browser settings.
        public let browserSettingsArn: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?

        @inlinable
        public init(browserPolicy: String? = nil, browserSettingsArn: String, clientToken: String? = UpdateBrowserSettingsRequest.idempotencyToken()) {
            self.browserPolicy = browserPolicy
            self.browserSettingsArn = browserSettingsArn
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.browserPolicy, forKey: .browserPolicy)
            request.encodePath(self.browserSettingsArn, key: "browserSettingsArn")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, max: 131072)
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, min: 2)
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, pattern: "\\{[\\S\\s]*\\}\\s*")
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, max: 2048)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, min: 20)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case browserPolicy = "browserPolicy"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateBrowserSettingsResponse: AWSDecodableShape {
        /// The browser settings.
        public let browserSettings: BrowserSettings

        @inlinable
        public init(browserSettings: BrowserSettings) {
            self.browserSettings = browserSettings
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettings = "browserSettings"
        }
    }

    public struct UpdateDataProtectionSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The ARN of the data protection settings.
        public let dataProtectionSettingsArn: String
        /// The description of the data protection settings.
        public let description: String?
        /// The display name of the data protection settings.
        public let displayName: String?
        /// The inline redaction configuration of the data protection settings that will be applied to all sessions.
        public let inlineRedactionConfiguration: InlineRedactionConfiguration?

        @inlinable
        public init(clientToken: String? = UpdateDataProtectionSettingsRequest.idempotencyToken(), dataProtectionSettingsArn: String, description: String? = nil, displayName: String? = nil, inlineRedactionConfiguration: InlineRedactionConfiguration? = nil) {
            self.clientToken = clientToken
            self.dataProtectionSettingsArn = dataProtectionSettingsArn
            self.description = description
            self.displayName = displayName
            self.inlineRedactionConfiguration = inlineRedactionConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.dataProtectionSettingsArn, key: "dataProtectionSettingsArn")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.inlineRedactionConfiguration, forKey: .inlineRedactionConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, max: 2048)
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, min: 20)
            try self.validate(self.dataProtectionSettingsArn, name: "dataProtectionSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[ _\\-\\d\\w]+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[ _\\-\\d\\w]+$")
            try self.inlineRedactionConfiguration?.validate(name: "\(name).inlineRedactionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case displayName = "displayName"
            case inlineRedactionConfiguration = "inlineRedactionConfiguration"
        }
    }

    public struct UpdateDataProtectionSettingsResponse: AWSDecodableShape {
        /// The data protection settings.
        public let dataProtectionSettings: DataProtectionSettings

        @inlinable
        public init(dataProtectionSettings: DataProtectionSettings) {
            self.dataProtectionSettings = dataProtectionSettings
        }

        private enum CodingKeys: String, CodingKey {
            case dataProtectionSettings = "dataProtectionSettings"
        }
    }

    public struct UpdateIdentityProviderRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The ARN of the identity provider.
        public let identityProviderArn: String
        /// The details of the identity provider. The following list describes the provider detail keys for each identity provider type.    For Google and Login with Amazon:    client_id     client_secret     authorize_scopes      For Facebook:    client_id     client_secret     authorize_scopes     api_version      For Sign in with Apple:    client_id     team_id     key_id     private_key     authorize_scopes      For OIDC providers:    client_id     client_secret     attributes_request_method     oidc_issuer     authorize_scopes     authorize_url if not available from discovery URL specified by oidc_issuer key     token_url if not available from discovery URL specified by oidc_issuer key     attributes_url if not available from discovery URL specified by oidc_issuer key     jwks_uri if not available from discovery URL specified by oidc_issuer key      For SAML providers:    MetadataFile OR MetadataURL     IDPSignout (boolean) optional     IDPInit (boolean) optional     RequestSigningAlgorithm (string) optional - Only accepts rsa-sha256     EncryptedResponses (boolean) optional
        public let identityProviderDetails: [String: String]?
        /// The name of the identity provider.
        public let identityProviderName: String?
        /// The type of the identity provider.
        public let identityProviderType: IdentityProviderType?

        @inlinable
        public init(clientToken: String? = UpdateIdentityProviderRequest.idempotencyToken(), identityProviderArn: String, identityProviderDetails: [String: String]? = nil, identityProviderName: String? = nil, identityProviderType: IdentityProviderType? = nil) {
            self.clientToken = clientToken
            self.identityProviderArn = identityProviderArn
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.identityProviderArn, key: "identityProviderArn")
            try container.encodeIfPresent(self.identityProviderDetails, forKey: .identityProviderDetails)
            try container.encodeIfPresent(self.identityProviderName, forKey: .identityProviderName)
            try container.encodeIfPresent(self.identityProviderType, forKey: .identityProviderType)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, max: 2048)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, min: 20)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36}){2,}$")
            try self.identityProviderDetails?.forEach {
                try validate($0.key, name: "identityProviderDetails.key", parent: name, max: 131072)
                try validate($0.key, name: "identityProviderDetails.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "identityProviderDetails[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "identityProviderDetails[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, max: 32)
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, min: 1)
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, pattern: "^[^_][\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}][^_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case identityProviderDetails = "identityProviderDetails"
            case identityProviderName = "identityProviderName"
            case identityProviderType = "identityProviderType"
        }
    }

    public struct UpdateIdentityProviderResponse: AWSDecodableShape {
        /// The identity provider.
        public let identityProvider: IdentityProvider

        @inlinable
        public init(identityProvider: IdentityProvider) {
            self.identityProvider = identityProvider
        }

        private enum CodingKeys: String, CodingKey {
            case identityProvider = "identityProvider"
        }
    }

    public struct UpdateIpAccessSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The description of the IP access settings.
        public let description: String?
        /// The display name of the IP access settings.
        public let displayName: String?
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String
        /// The updated IP rules of the IP access settings.
        public let ipRules: [IpRule]?

        @inlinable
        public init(clientToken: String? = UpdateIpAccessSettingsRequest.idempotencyToken(), description: String? = nil, displayName: String? = nil, ipAccessSettingsArn: String, ipRules: [IpRule]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.ipRules = ipRules
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.ipAccessSettingsArn, key: "ipAccessSettingsArn")
            try container.encodeIfPresent(self.ipRules, forKey: .ipRules)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^.+$")
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, max: 2048)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, min: 20)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.ipRules?.forEach {
                try $0.validate(name: "\(name).ipRules[]")
            }
            try self.validate(self.ipRules, name: "ipRules", parent: name, max: 100)
            try self.validate(self.ipRules, name: "ipRules", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case displayName = "displayName"
            case ipRules = "ipRules"
        }
    }

    public struct UpdateIpAccessSettingsResponse: AWSDecodableShape {
        /// The IP access settings.
        public let ipAccessSettings: IpAccessSettings

        @inlinable
        public init(ipAccessSettings: IpAccessSettings) {
            self.ipAccessSettings = ipAccessSettings
        }

        private enum CodingKeys: String, CodingKey {
            case ipAccessSettings = "ipAccessSettings"
        }
    }

    public struct UpdateNetworkSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The ARN of the network settings.
        public let networkSettingsArn: String
        /// One or more security groups used to control access from streaming instances to your VPC.
        public let securityGroupIds: [String]?
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public let subnetIds: [String]?
        /// The VPC that streaming instances will connect to.
        public let vpcId: String?

        @inlinable
        public init(clientToken: String? = UpdateNetworkSettingsRequest.idempotencyToken(), networkSettingsArn: String, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.clientToken = clientToken
            self.networkSettingsArn = networkSettingsArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.networkSettingsArn, key: "networkSettingsArn")
            try container.encodeIfPresent(self.securityGroupIds, forKey: .securityGroupIds)
            try container.encodeIfPresent(self.subnetIds, forKey: .subnetIds)
            try container.encodeIfPresent(self.vpcId, forKey: .vpcId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, max: 2048)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, min: 20)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 128)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[\\w+\\-]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 32)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-([0-9a-f]{8}|[0-9a-f]{17})$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 5)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 2)
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 255)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[0-9a-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct UpdateNetworkSettingsResponse: AWSDecodableShape {
        /// The network settings.
        public let networkSettings: NetworkSettings

        @inlinable
        public init(networkSettings: NetworkSettings) {
            self.networkSettings = networkSettings
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettings = "networkSettings"
        }
    }

    public struct UpdatePortalRequest: AWSEncodableShape {
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard.  Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.  IAM Identity Center web portals are authenticated through IAM Identity Center. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public let authenticationType: AuthenticationType?
        /// The name of the web portal. This is not visible to users who log into the web portal.
        public let displayName: String?
        /// The type and resources of the underlying instance.
        public let instanceType: InstanceType?
        /// The maximum number of concurrent sessions for the portal.
        public let maxConcurrentSessions: Int?
        /// The ARN of the web portal.
        public let portalArn: String

        @inlinable
        public init(authenticationType: AuthenticationType? = nil, displayName: String? = nil, instanceType: InstanceType? = nil, maxConcurrentSessions: Int? = nil, portalArn: String) {
            self.authenticationType = authenticationType
            self.displayName = displayName
            self.instanceType = instanceType
            self.maxConcurrentSessions = maxConcurrentSessions
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authenticationType, forKey: .authenticationType)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.instanceType, forKey: .instanceType)
            try container.encodeIfPresent(self.maxConcurrentSessions, forKey: .maxConcurrentSessions)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^.+$")
            try self.validate(self.maxConcurrentSessions, name: "maxConcurrentSessions", parent: name, max: 5000)
            try self.validate(self.maxConcurrentSessions, name: "maxConcurrentSessions", parent: name, min: 1)
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
            case displayName = "displayName"
            case instanceType = "instanceType"
            case maxConcurrentSessions = "maxConcurrentSessions"
        }
    }

    public struct UpdatePortalResponse: AWSDecodableShape {
        /// The web portal.
        public let portal: Portal?

        @inlinable
        public init(portal: Portal? = nil) {
            self.portal = portal
        }

        private enum CodingKeys: String, CodingKey {
            case portal = "portal"
        }
    }

    public struct UpdateTrustStoreRequest: AWSEncodableShape {
        /// A list of CA certificates to add to the trust store.
        public let certificatesToAdd: [AWSBase64Data]?
        /// A list of CA certificates to delete from a trust store.
        public let certificatesToDelete: [String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The ARN of the trust store.
        public let trustStoreArn: String

        @inlinable
        public init(certificatesToAdd: [AWSBase64Data]? = nil, certificatesToDelete: [String]? = nil, clientToken: String? = UpdateTrustStoreRequest.idempotencyToken(), trustStoreArn: String) {
            self.certificatesToAdd = certificatesToAdd
            self.certificatesToDelete = certificatesToDelete
            self.clientToken = clientToken
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.certificatesToAdd, forKey: .certificatesToAdd)
            try container.encodeIfPresent(self.certificatesToDelete, forKey: .certificatesToDelete)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.certificatesToDelete?.forEach {
                try validate($0, name: "certificatesToDelete[]", parent: name, max: 64)
                try validate($0, name: "certificatesToDelete[]", parent: name, min: 64)
                try validate($0, name: "certificatesToDelete[]", parent: name, pattern: "^[A-Fa-f0-9]{64}$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case certificatesToAdd = "certificatesToAdd"
            case certificatesToDelete = "certificatesToDelete"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateTrustStoreResponse: AWSDecodableShape {
        /// The ARN of the trust store.
        public let trustStoreArn: String

        @inlinable
        public init(trustStoreArn: String) {
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct UpdateUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The ARN of the Kinesis stream.
        public let kinesisStreamArn: String?
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        @inlinable
        public init(clientToken: String? = UpdateUserAccessLoggingSettingsRequest.idempotencyToken(), kinesisStreamArn: String? = nil, userAccessLoggingSettingsArn: String) {
            self.clientToken = clientToken
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.kinesisStreamArn, forKey: .kinesisStreamArn)
            request.encodePath(self.userAccessLoggingSettingsArn, key: "userAccessLoggingSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, max: 2048)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, min: 20)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, pattern: "arn:[\\w+=/,.@-]+:kinesis:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:stream/.+")
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, max: 2048)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, min: 20)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case kinesisStreamArn = "kinesisStreamArn"
        }
    }

    public struct UpdateUserAccessLoggingSettingsResponse: AWSDecodableShape {
        /// The user access logging settings.
        public let userAccessLoggingSettings: UserAccessLoggingSettings

        @inlinable
        public init(userAccessLoggingSettings: UserAccessLoggingSettings) {
            self.userAccessLoggingSettings = userAccessLoggingSettings
        }

        private enum CodingKeys: String, CodingKey {
            case userAccessLoggingSettings = "userAccessLoggingSettings"
        }
    }

    public struct UpdateUserSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
        public let clientToken: String?
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser. If the allowlist and blocklist are empty, the configuration becomes null.
        public let cookieSynchronizationConfiguration: CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public let copyAllowed: EnabledType?
        /// Specifies whether the user can use deep links that open automatically when connecting to a session.
        public let deepLinkAllowed: EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public let disconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public let downloadAllowed: EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public let idleDisconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public let pasteAllowed: EnabledType?
        /// Specifies whether the user can print to the local device.
        public let printAllowed: EnabledType?
        /// The configuration of the toolbar. This allows administrators to select the toolbar type and visual mode, set maximum display resolution for sessions, and choose which items are visible to end users during their sessions. If administrators do not modify these settings, end users retain control over their toolbar preferences.
        public let toolbarConfiguration: ToolbarConfiguration?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public let uploadAllowed: EnabledType?
        /// The ARN of the user settings.
        public let userSettingsArn: String

        @inlinable
        public init(clientToken: String? = UpdateUserSettingsRequest.idempotencyToken(), cookieSynchronizationConfiguration: CookieSynchronizationConfiguration? = nil, copyAllowed: EnabledType? = nil, deepLinkAllowed: EnabledType? = nil, disconnectTimeoutInMinutes: Int? = nil, downloadAllowed: EnabledType? = nil, idleDisconnectTimeoutInMinutes: Int? = nil, pasteAllowed: EnabledType? = nil, printAllowed: EnabledType? = nil, toolbarConfiguration: ToolbarConfiguration? = nil, uploadAllowed: EnabledType? = nil, userSettingsArn: String) {
            self.clientToken = clientToken
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.deepLinkAllowed = deepLinkAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.toolbarConfiguration = toolbarConfiguration
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.cookieSynchronizationConfiguration, forKey: .cookieSynchronizationConfiguration)
            try container.encodeIfPresent(self.copyAllowed, forKey: .copyAllowed)
            try container.encodeIfPresent(self.deepLinkAllowed, forKey: .deepLinkAllowed)
            try container.encodeIfPresent(self.disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
            try container.encodeIfPresent(self.downloadAllowed, forKey: .downloadAllowed)
            try container.encodeIfPresent(self.idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
            try container.encodeIfPresent(self.pasteAllowed, forKey: .pasteAllowed)
            try container.encodeIfPresent(self.printAllowed, forKey: .printAllowed)
            try container.encodeIfPresent(self.toolbarConfiguration, forKey: .toolbarConfiguration)
            try container.encodeIfPresent(self.uploadAllowed, forKey: .uploadAllowed)
            request.encodePath(self.userSettingsArn, key: "userSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.cookieSynchronizationConfiguration?.validate(name: "\(name).cookieSynchronizationConfiguration")
            try self.validate(self.disconnectTimeoutInMinutes, name: "disconnectTimeoutInMinutes", parent: name, max: 600)
            try self.validate(self.disconnectTimeoutInMinutes, name: "disconnectTimeoutInMinutes", parent: name, min: 1)
            try self.validate(self.idleDisconnectTimeoutInMinutes, name: "idleDisconnectTimeoutInMinutes", parent: name, max: 60)
            try self.validate(self.idleDisconnectTimeoutInMinutes, name: "idleDisconnectTimeoutInMinutes", parent: name, min: 0)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, max: 2048)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, min: 20)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case cookieSynchronizationConfiguration = "cookieSynchronizationConfiguration"
            case copyAllowed = "copyAllowed"
            case deepLinkAllowed = "deepLinkAllowed"
            case disconnectTimeoutInMinutes = "disconnectTimeoutInMinutes"
            case downloadAllowed = "downloadAllowed"
            case idleDisconnectTimeoutInMinutes = "idleDisconnectTimeoutInMinutes"
            case pasteAllowed = "pasteAllowed"
            case printAllowed = "printAllowed"
            case toolbarConfiguration = "toolbarConfiguration"
            case uploadAllowed = "uploadAllowed"
        }
    }

    public struct UpdateUserSettingsResponse: AWSDecodableShape {
        /// The user settings.
        public let userSettings: UserSettings

        @inlinable
        public init(userSettings: UserSettings) {
            self.userSettings = userSettings
        }

        private enum CodingKeys: String, CodingKey {
            case userSettings = "userSettings"
        }
    }

    public struct UserAccessLoggingSettings: AWSDecodableShape {
        /// A list of web portal ARNs that this user access logging settings is associated with.
        public let associatedPortalArns: [String]?
        /// The ARN of the Kinesis stream.
        public let kinesisStreamArn: String?
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        @inlinable
        public init(associatedPortalArns: [String]? = nil, kinesisStreamArn: String? = nil, userAccessLoggingSettingsArn: String) {
            self.associatedPortalArns = associatedPortalArns
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case associatedPortalArns = "associatedPortalArns"
            case kinesisStreamArn = "kinesisStreamArn"
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
        }
    }

    public struct UserAccessLoggingSettingsSummary: AWSDecodableShape {
        /// The ARN of the Kinesis stream.
        public let kinesisStreamArn: String?
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        @inlinable
        public init(kinesisStreamArn: String? = nil, userAccessLoggingSettingsArn: String) {
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisStreamArn = "kinesisStreamArn"
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
        }
    }

    public struct UserSettings: AWSDecodableShape {
        /// The additional encryption context of the user settings.
        public let additionalEncryptionContext: [String: String]?
        /// A list of web portal ARNs that this user settings is associated with.
        public let associatedPortalArns: [String]?
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public let cookieSynchronizationConfiguration: CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public let copyAllowed: EnabledType?
        /// The customer managed key used to encrypt sensitive information in the user settings.
        public let customerManagedKey: String?
        /// Specifies whether the user can use deep links that open automatically when connecting to a session.
        public let deepLinkAllowed: EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public let disconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public let downloadAllowed: EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public let idleDisconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public let pasteAllowed: EnabledType?
        /// Specifies whether the user can print to the local device.
        public let printAllowed: EnabledType?
        /// The configuration of the toolbar. This allows administrators to select the toolbar type and visual mode, set maximum display resolution for sessions, and choose which items are visible to end users during their sessions. If administrators do not modify these settings, end users retain control over their toolbar preferences.
        public let toolbarConfiguration: ToolbarConfiguration?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public let uploadAllowed: EnabledType?
        /// The ARN of the user settings.
        public let userSettingsArn: String

        @inlinable
        public init(additionalEncryptionContext: [String: String]? = nil, associatedPortalArns: [String]? = nil, cookieSynchronizationConfiguration: CookieSynchronizationConfiguration? = nil, copyAllowed: EnabledType? = nil, customerManagedKey: String? = nil, deepLinkAllowed: EnabledType? = nil, disconnectTimeoutInMinutes: Int? = nil, downloadAllowed: EnabledType? = nil, idleDisconnectTimeoutInMinutes: Int? = nil, pasteAllowed: EnabledType? = nil, printAllowed: EnabledType? = nil, toolbarConfiguration: ToolbarConfiguration? = nil, uploadAllowed: EnabledType? = nil, userSettingsArn: String) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.associatedPortalArns = associatedPortalArns
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.customerManagedKey = customerManagedKey
            self.deepLinkAllowed = deepLinkAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.toolbarConfiguration = toolbarConfiguration
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case associatedPortalArns = "associatedPortalArns"
            case cookieSynchronizationConfiguration = "cookieSynchronizationConfiguration"
            case copyAllowed = "copyAllowed"
            case customerManagedKey = "customerManagedKey"
            case deepLinkAllowed = "deepLinkAllowed"
            case disconnectTimeoutInMinutes = "disconnectTimeoutInMinutes"
            case downloadAllowed = "downloadAllowed"
            case idleDisconnectTimeoutInMinutes = "idleDisconnectTimeoutInMinutes"
            case pasteAllowed = "pasteAllowed"
            case printAllowed = "printAllowed"
            case toolbarConfiguration = "toolbarConfiguration"
            case uploadAllowed = "uploadAllowed"
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct UserSettingsSummary: AWSDecodableShape {
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public let cookieSynchronizationConfiguration: CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public let copyAllowed: EnabledType?
        /// Specifies whether the user can use deep links that open automatically when connecting to a session.
        public let deepLinkAllowed: EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public let disconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public let downloadAllowed: EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public let idleDisconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public let pasteAllowed: EnabledType?
        /// Specifies whether the user can print to the local device.
        public let printAllowed: EnabledType?
        /// The configuration of the toolbar. This allows administrators to select the toolbar type and visual mode, set maximum display resolution for sessions, and choose which items are visible to end users during their sessions. If administrators do not modify these settings, end users retain control over their toolbar preferences.
        public let toolbarConfiguration: ToolbarConfiguration?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public let uploadAllowed: EnabledType?
        /// The ARN of the user settings.
        public let userSettingsArn: String

        @inlinable
        public init(cookieSynchronizationConfiguration: CookieSynchronizationConfiguration? = nil, copyAllowed: EnabledType? = nil, deepLinkAllowed: EnabledType? = nil, disconnectTimeoutInMinutes: Int? = nil, downloadAllowed: EnabledType? = nil, idleDisconnectTimeoutInMinutes: Int? = nil, pasteAllowed: EnabledType? = nil, printAllowed: EnabledType? = nil, toolbarConfiguration: ToolbarConfiguration? = nil, uploadAllowed: EnabledType? = nil, userSettingsArn: String) {
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.deepLinkAllowed = deepLinkAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.toolbarConfiguration = toolbarConfiguration
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case cookieSynchronizationConfiguration = "cookieSynchronizationConfiguration"
            case copyAllowed = "copyAllowed"
            case deepLinkAllowed = "deepLinkAllowed"
            case disconnectTimeoutInMinutes = "disconnectTimeoutInMinutes"
            case downloadAllowed = "downloadAllowed"
            case idleDisconnectTimeoutInMinutes = "idleDisconnectTimeoutInMinutes"
            case pasteAllowed = "pasteAllowed"
            case printAllowed = "printAllowed"
            case toolbarConfiguration = "toolbarConfiguration"
            case uploadAllowed = "uploadAllowed"
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The field that caused the error.
        public let fieldList: [ValidationExceptionField]?
        public let message: String?
        /// Reason the request failed validation
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String? = nil, reason: ValidationExceptionReason? = nil) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The message describing why the field failed validation.
        public let message: String
        /// The name of the field that failed validation.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }
}

// MARK: - Errors

/// Error enum for WorkSpacesWeb
public struct WorkSpacesWebErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize WorkSpacesWeb
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access is denied.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There is a conflict.
    public static var conflictException: Self { .init(.conflictException) }
    /// There is an internal server error.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource cannot be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota has been exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// There is a throttling error.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// There are too many tags.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// There is a validation error.
    public static var validationException: Self { .init(.validationException) }
}

extension WorkSpacesWebErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": WorkSpacesWeb.ConflictException.self,
        "InternalServerException": WorkSpacesWeb.InternalServerException.self,
        "ResourceNotFoundException": WorkSpacesWeb.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": WorkSpacesWeb.ServiceQuotaExceededException.self,
        "ThrottlingException": WorkSpacesWeb.ThrottlingException.self,
        "TooManyTagsException": WorkSpacesWeb.TooManyTagsException.self,
        "ValidationException": WorkSpacesWeb.ValidationException.self
    ]
}

extension WorkSpacesWebErrorType: Equatable {
    public static func == (lhs: WorkSpacesWebErrorType, rhs: WorkSpacesWebErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension WorkSpacesWebErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
