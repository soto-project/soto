//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension WorkSpacesWeb {
    // MARK: Enums

    public enum AuthenticationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iamIdentityCenter = "IAM_Identity_Center"
        case standard = "Standard"
        public var description: String { return self.rawValue }
    }

    public enum BrowserType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chrome = "Chrome"
        public var description: String { return self.rawValue }
    }

    public enum EnabledType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum IdentityProviderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case facebook = "Facebook"
        case google = "Google"
        case loginWithAmazon = "LoginWithAmazon"
        case oidc = "OIDC"
        case saml = "SAML"
        case signInWithApple = "SignInWithApple"
        public var description: String { return self.rawValue }
    }

    public enum PortalStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case incomplete = "Incomplete"
        case pending = "Pending"
        public var description: String { return self.rawValue }
    }

    public enum RendererType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case appStream = "AppStream"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateBrowserSettingsRequest: AWSEncodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        public init(browserSettingsArn: String, portalArn: String) {
            self.browserSettingsArn = browserSettingsArn
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.browserSettingsArn, key: "browserSettingsArn")
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, max: 2048)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, min: 20)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateBrowserSettingsResponse: AWSDecodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        public init(browserSettingsArn: String, portalArn: String) {
            self.browserSettingsArn = browserSettingsArn
            self.portalArn = portalArn
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettingsArn = "browserSettingsArn"
            case portalArn = "portalArn"
        }
    }

    public struct AssociateIpAccessSettingsRequest: AWSEncodableShape {
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        public init(ipAccessSettingsArn: String, portalArn: String) {
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.ipAccessSettingsArn, key: "ipAccessSettingsArn")
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, max: 2048)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, min: 20)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateIpAccessSettingsResponse: AWSDecodableShape {
        /// The ARN of the IP access settings resource.
        public let ipAccessSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        public init(ipAccessSettingsArn: String, portalArn: String) {
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.portalArn = portalArn
        }

        private enum CodingKeys: String, CodingKey {
            case ipAccessSettingsArn = "ipAccessSettingsArn"
            case portalArn = "portalArn"
        }
    }

    public struct AssociateNetworkSettingsRequest: AWSEncodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        public init(networkSettingsArn: String, portalArn: String) {
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.networkSettingsArn, key: "networkSettingsArn")
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, max: 2048)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, min: 20)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateNetworkSettingsResponse: AWSDecodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String
        /// The ARN of the web portal.
        public let portalArn: String

        public init(networkSettingsArn: String, portalArn: String) {
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettingsArn = "networkSettingsArn"
            case portalArn = "portalArn"
        }
    }

    public struct AssociateTrustStoreRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the trust store.
        public let trustStoreArn: String

        public init(portalArn: String, trustStoreArn: String) {
            self.portalArn = portalArn
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
            request.encodeQuery(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateTrustStoreResponse: AWSDecodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the trust store.
        public let trustStoreArn: String

        public init(portalArn: String, trustStoreArn: String) {
            self.portalArn = portalArn
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct AssociateUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        public init(portalArn: String, userAccessLoggingSettingsArn: String) {
            self.portalArn = portalArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
            request.encodeQuery(self.userAccessLoggingSettingsArn, key: "userAccessLoggingSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, max: 2048)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, min: 20)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateUserAccessLoggingSettingsResponse: AWSDecodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        public init(portalArn: String, userAccessLoggingSettingsArn: String) {
            self.portalArn = portalArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
        }
    }

    public struct AssociateUserSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the user settings.
        public let userSettingsArn: String

        public init(portalArn: String, userSettingsArn: String) {
            self.portalArn = portalArn
            self.userSettingsArn = userSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
            request.encodeQuery(self.userSettingsArn, key: "userSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, max: 2048)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, min: 20)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateUserSettingsResponse: AWSDecodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The ARN of the user settings.
        public let userSettingsArn: String

        public init(portalArn: String, userSettingsArn: String) {
            self.portalArn = portalArn
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct BrowserSettings: AWSDecodableShape {
        /// A list of web portal ARNs that this browser settings is associated with.
        public let associatedPortalArns: [String]?
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public let browserPolicy: String?
        /// The ARN of the browser settings.
        public let browserSettingsArn: String

        public init(associatedPortalArns: [String]? = nil, browserPolicy: String? = nil, browserSettingsArn: String) {
            self.associatedPortalArns = associatedPortalArns
            self.browserPolicy = browserPolicy
            self.browserSettingsArn = browserSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case associatedPortalArns = "associatedPortalArns"
            case browserPolicy = "browserPolicy"
            case browserSettingsArn = "browserSettingsArn"
        }
    }

    public struct BrowserSettingsSummary: AWSDecodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String

        public init(browserSettingsArn: String) {
            self.browserSettingsArn = browserSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettingsArn = "browserSettingsArn"
        }
    }

    public struct Certificate: AWSDecodableShape {
        /// The body of the certificate.
        public let body: AWSBase64Data?
        /// The entity that issued the certificate.
        public let issuer: String?
        /// The certificate is not valid after this date.
        public let notValidAfter: Date?
        /// The certificate is not valid before this date.
        public let notValidBefore: Date?
        /// The entity the certificate belongs to.
        public let subject: String?
        /// A hexadecimal identifier for the certificate.
        public let thumbprint: String?

        public init(body: AWSBase64Data? = nil, issuer: String? = nil, notValidAfter: Date? = nil, notValidBefore: Date? = nil, subject: String? = nil, thumbprint: String? = nil) {
            self.body = body
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
            case issuer = "issuer"
            case notValidAfter = "notValidAfter"
            case notValidBefore = "notValidBefore"
            case subject = "subject"
            case thumbprint = "thumbprint"
        }
    }

    public struct CertificateSummary: AWSDecodableShape {
        /// The entity that issued the certificate.
        public let issuer: String?
        /// The certificate is not valid after this date.
        public let notValidAfter: Date?
        /// The certificate is not valid before this date.
        public let notValidBefore: Date?
        /// The entity the certificate belongs to.
        public let subject: String?
        /// A hexadecimal identifier for the certificate.
        public let thumbprint: String?

        public init(issuer: String? = nil, notValidAfter: Date? = nil, notValidBefore: Date? = nil, subject: String? = nil, thumbprint: String? = nil) {
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }

        private enum CodingKeys: String, CodingKey {
            case issuer = "issuer"
            case notValidAfter = "notValidAfter"
            case notValidBefore = "notValidBefore"
            case subject = "subject"
            case thumbprint = "thumbprint"
        }
    }

    public struct CookieSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The domain of the cookie.
        public let domain: String
        /// The name of the cookie.
        public let name: String?
        /// The path of the cookie.
        public let path: String?

        public init(domain: String, name: String? = nil, path: String? = nil) {
            self.domain = domain
            self.name = name
            self.path = path
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, max: 253)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^(\\.?)(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\\.)*[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$")
            try self.validate(self.name, name: "name", parent: name, max: 4096)
            try self.validate(self.path, name: "path", parent: name, max: 2000)
            try self.validate(self.path, name: "path", parent: name, pattern: "^/(\\S)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "domain"
            case name = "name"
            case path = "path"
        }
    }

    public struct CookieSynchronizationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The list of cookie specifications that are allowed to be synchronized to the remote browser.
        public let allowlist: [CookieSpecification]
        /// The list of cookie specifications that are blocked from being synchronized to the remote browser.
        public let blocklist: [CookieSpecification]?

        public init(allowlist: [CookieSpecification], blocklist: [CookieSpecification]? = nil) {
            self.allowlist = allowlist
            self.blocklist = blocklist
        }

        public func validate(name: String) throws {
            try self.allowlist.forEach {
                try $0.validate(name: "\(name).allowlist[]")
            }
            try self.validate(self.allowlist, name: "allowlist", parent: name, max: 10)
            try self.blocklist?.forEach {
                try $0.validate(name: "\(name).blocklist[]")
            }
            try self.validate(self.blocklist, name: "blocklist", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case allowlist = "allowlist"
            case blocklist = "blocklist"
        }
    }

    public struct CreateBrowserSettingsRequest: AWSEncodableShape {
        /// Additional encryption context of the browser settings.
        public let additionalEncryptionContext: [String: String]?
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public let browserPolicy: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The custom managed key of the browser settings.
        public let customerManagedKey: String?
        /// The tags to add to the browser settings resource. A tag is a key-value pair.
        public let tags: [Tag]?

        public init(additionalEncryptionContext: [String: String]? = nil, browserPolicy: String, clientToken: String? = CreateBrowserSettingsRequest.idempotencyToken(), customerManagedKey: String? = nil, tags: [Tag]? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.browserPolicy = browserPolicy
            self.clientToken = clientToken
            self.customerManagedKey = customerManagedKey
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.additionalEncryptionContext?.forEach {
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, max: 131072)
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, max: 131072)
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, min: 2)
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, pattern: "\\{[\\S\\s]*\\}\\s*")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, max: 2048)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, min: 20)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:kms:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:key\\/[a-zA-Z0-9-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case browserPolicy = "browserPolicy"
            case clientToken = "clientToken"
            case customerManagedKey = "customerManagedKey"
            case tags = "tags"
        }
    }

    public struct CreateBrowserSettingsResponse: AWSDecodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String

        public init(browserSettingsArn: String) {
            self.browserSettingsArn = browserSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettingsArn = "browserSettingsArn"
        }
    }

    public struct CreateIdentityProviderRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The identity provider details. The following list describes the provider detail keys for each identity provider type.    For Google and Login with Amazon:          client_id     client_secret     authorize_scopes      For Facebook:          client_id     client_secret     authorize_scopes     api_version      For Sign in with Apple:          client_id     team_id     key_id     private_key     authorize_scopes      For OIDC providers:          client_id     client_secret     attributes_request_method     oidc_issuer     authorize_scopes     authorize_url if not available from discovery URL specified by oidc_issuer key     token_url if not available from discovery URL specified by oidc_issuer key     attributes_url if not available from discovery URL specified by oidc_issuer key     jwks_uri if not available from discovery URL specified by oidc_issuer key      For SAML providers:          MetadataFile OR MetadataURL     IDPSignout (boolean)  optional
        public let identityProviderDetails: [String: String]
        /// The identity provider name.
        public let identityProviderName: String
        /// The identity provider type.
        public let identityProviderType: IdentityProviderType
        /// The ARN of the web portal.
        public let portalArn: String

        public init(clientToken: String? = CreateIdentityProviderRequest.idempotencyToken(), identityProviderDetails: [String: String], identityProviderName: String, identityProviderType: IdentityProviderType, portalArn: String) {
            self.clientToken = clientToken
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
            self.portalArn = portalArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.identityProviderDetails.forEach {
                try validate($0.key, name: "identityProviderDetails.key", parent: name, max: 131072)
                try validate($0.key, name: "identityProviderDetails.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "identityProviderDetails[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "identityProviderDetails[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, max: 32)
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, min: 1)
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, pattern: "^[^_][\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}][^_]+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case identityProviderDetails = "identityProviderDetails"
            case identityProviderName = "identityProviderName"
            case identityProviderType = "identityProviderType"
            case portalArn = "portalArn"
        }
    }

    public struct CreateIdentityProviderResponse: AWSDecodableShape {
        /// The ARN of the identity provider.
        public let identityProviderArn: String

        public init(identityProviderArn: String) {
            self.identityProviderArn = identityProviderArn
        }

        private enum CodingKeys: String, CodingKey {
            case identityProviderArn = "identityProviderArn"
        }
    }

    public struct CreateIpAccessSettingsRequest: AWSEncodableShape {
        /// Additional encryption context of the IP access settings.
        public let additionalEncryptionContext: [String: String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The custom managed key of the IP access settings.
        public let customerManagedKey: String?
        /// The description of the IP access settings.
        public let description: String?
        /// The display name of the IP access settings.
        public let displayName: String?
        /// The IP rules of the IP access settings.
        public let ipRules: [IpRule]
        /// The tags to add to the browser settings resource. A tag is a key-value pair.
        public let tags: [Tag]?

        public init(additionalEncryptionContext: [String: String]? = nil, clientToken: String? = CreateIpAccessSettingsRequest.idempotencyToken(), customerManagedKey: String? = nil, description: String? = nil, displayName: String? = nil, ipRules: [IpRule], tags: [Tag]? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.clientToken = clientToken
            self.customerManagedKey = customerManagedKey
            self.description = description
            self.displayName = displayName
            self.ipRules = ipRules
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.additionalEncryptionContext?.forEach {
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, max: 131072)
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, max: 2048)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, min: 20)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:kms:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:key\\/[a-zA-Z0-9-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^.+$")
            try self.ipRules.forEach {
                try $0.validate(name: "\(name).ipRules[]")
            }
            try self.validate(self.ipRules, name: "ipRules", parent: name, max: 100)
            try self.validate(self.ipRules, name: "ipRules", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case clientToken = "clientToken"
            case customerManagedKey = "customerManagedKey"
            case description = "description"
            case displayName = "displayName"
            case ipRules = "ipRules"
            case tags = "tags"
        }
    }

    public struct CreateIpAccessSettingsResponse: AWSDecodableShape {
        /// The ARN of the IP access settings resource.
        public let ipAccessSettingsArn: String

        public init(ipAccessSettingsArn: String) {
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case ipAccessSettingsArn = "ipAccessSettingsArn"
        }
    }

    public struct CreateNetworkSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// One or more security groups used to control access from streaming instances to your VPC.
        public let securityGroupIds: [String]
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public let subnetIds: [String]
        /// The tags to add to the network settings resource. A tag is a key-value pair.
        public let tags: [Tag]?
        /// The VPC that streaming instances will connect to.
        public let vpcId: String

        public init(clientToken: String? = CreateNetworkSettingsRequest.idempotencyToken(), securityGroupIds: [String], subnetIds: [String], tags: [Tag]? = nil, vpcId: String) {
            self.clientToken = clientToken
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 128)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[\\w+\\-]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 32)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-([0-9a-f]{8}|[0-9a-f]{17})$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 3)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 2)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 255)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[0-9a-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case vpcId = "vpcId"
        }
    }

    public struct CreateNetworkSettingsResponse: AWSDecodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String

        public init(networkSettingsArn: String) {
            self.networkSettingsArn = networkSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettingsArn = "networkSettingsArn"
        }
    }

    public struct CreatePortalRequest: AWSEncodableShape {
        /// The additional encryption context of the portal.
        public let additionalEncryptionContext: [String: String]?
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard.  Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.  IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public let authenticationType: AuthenticationType?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The customer managed key of the web portal.
        public let customerManagedKey: String?
        /// The name of the web portal. This is not visible to users who log into the web portal.
        public let displayName: String?
        /// The tags to add to the web portal. A tag is a key-value pair.
        public let tags: [Tag]?

        public init(additionalEncryptionContext: [String: String]? = nil, authenticationType: AuthenticationType? = nil, clientToken: String? = CreatePortalRequest.idempotencyToken(), customerManagedKey: String? = nil, displayName: String? = nil, tags: [Tag]? = nil) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.authenticationType = authenticationType
            self.clientToken = clientToken
            self.customerManagedKey = customerManagedKey
            self.displayName = displayName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.additionalEncryptionContext?.forEach {
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, max: 131072)
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, max: 2048)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, min: 20)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:kms:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:key\\/[a-zA-Z0-9-]+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case authenticationType = "authenticationType"
            case clientToken = "clientToken"
            case customerManagedKey = "customerManagedKey"
            case displayName = "displayName"
            case tags = "tags"
        }
    }

    public struct CreatePortalResponse: AWSDecodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public let portalEndpoint: String

        public init(portalArn: String, portalEndpoint: String) {
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case portalEndpoint = "portalEndpoint"
        }
    }

    public struct CreateTrustStoreRequest: AWSEncodableShape {
        /// A list of CA certificates to be added to the trust store.
        public let certificateList: [AWSBase64Data]
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The tags to add to the trust store. A tag is a key-value pair.
        public let tags: [Tag]?

        public init(certificateList: [AWSBase64Data], clientToken: String? = CreateTrustStoreRequest.idempotencyToken(), tags: [Tag]? = nil) {
            self.certificateList = certificateList
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateList = "certificateList"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateTrustStoreResponse: AWSDecodableShape {
        /// The ARN of the trust store.
        public let trustStoreArn: String

        public init(trustStoreArn: String) {
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct CreateUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The ARN of the Kinesis stream.
        public let kinesisStreamArn: String
        /// The tags to add to the user settings resource. A tag is a key-value pair.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateUserAccessLoggingSettingsRequest.idempotencyToken(), kinesisStreamArn: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.kinesisStreamArn = kinesisStreamArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, max: 2048)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, min: 20)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, pattern: "arn:[\\w+=/,.@-]+:kinesis:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:stream/.+")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case kinesisStreamArn = "kinesisStreamArn"
            case tags = "tags"
        }
    }

    public struct CreateUserAccessLoggingSettingsResponse: AWSDecodableShape {
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        public init(userAccessLoggingSettingsArn: String) {
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
        }
    }

    public struct CreateUserSettingsRequest: AWSEncodableShape {
        /// The additional encryption context of the user settings.
        public let additionalEncryptionContext: [String: String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public let cookieSynchronizationConfiguration: CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public let copyAllowed: EnabledType
        /// The customer managed key used to encrypt sensitive information in the user settings.
        public let customerManagedKey: String?
        /// The amount of time that a streaming session remains active after users disconnect.
        public let disconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public let downloadAllowed: EnabledType
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public let idleDisconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public let pasteAllowed: EnabledType
        /// Specifies whether the user can print to the local device.
        public let printAllowed: EnabledType
        /// The tags to add to the user settings resource. A tag is a key-value pair.
        public let tags: [Tag]?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public let uploadAllowed: EnabledType

        public init(additionalEncryptionContext: [String: String]? = nil, clientToken: String? = CreateUserSettingsRequest.idempotencyToken(), cookieSynchronizationConfiguration: CookieSynchronizationConfiguration? = nil, copyAllowed: EnabledType, customerManagedKey: String? = nil, disconnectTimeoutInMinutes: Int? = nil, downloadAllowed: EnabledType, idleDisconnectTimeoutInMinutes: Int? = nil, pasteAllowed: EnabledType, printAllowed: EnabledType, tags: [Tag]? = nil, uploadAllowed: EnabledType) {
            self.additionalEncryptionContext = additionalEncryptionContext
            self.clientToken = clientToken
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.customerManagedKey = customerManagedKey
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.tags = tags
            self.uploadAllowed = uploadAllowed
        }

        public func validate(name: String) throws {
            try self.additionalEncryptionContext?.forEach {
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, max: 131072)
                try validate($0.key, name: "additionalEncryptionContext.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "additionalEncryptionContext[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.cookieSynchronizationConfiguration?.validate(name: "\(name).cookieSynchronizationConfiguration")
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, max: 2048)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, min: 20)
            try self.validate(self.customerManagedKey, name: "customerManagedKey", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:kms:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:key\\/[a-zA-Z0-9-]+$")
            try self.validate(self.disconnectTimeoutInMinutes, name: "disconnectTimeoutInMinutes", parent: name, max: 600)
            try self.validate(self.disconnectTimeoutInMinutes, name: "disconnectTimeoutInMinutes", parent: name, min: 1)
            try self.validate(self.idleDisconnectTimeoutInMinutes, name: "idleDisconnectTimeoutInMinutes", parent: name, max: 60)
            try self.validate(self.idleDisconnectTimeoutInMinutes, name: "idleDisconnectTimeoutInMinutes", parent: name, min: 0)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEncryptionContext = "additionalEncryptionContext"
            case clientToken = "clientToken"
            case cookieSynchronizationConfiguration = "cookieSynchronizationConfiguration"
            case copyAllowed = "copyAllowed"
            case customerManagedKey = "customerManagedKey"
            case disconnectTimeoutInMinutes = "disconnectTimeoutInMinutes"
            case downloadAllowed = "downloadAllowed"
            case idleDisconnectTimeoutInMinutes = "idleDisconnectTimeoutInMinutes"
            case pasteAllowed = "pasteAllowed"
            case printAllowed = "printAllowed"
            case tags = "tags"
            case uploadAllowed = "uploadAllowed"
        }
    }

    public struct CreateUserSettingsResponse: AWSDecodableShape {
        /// The ARN of the user settings.
        public let userSettingsArn: String

        public init(userSettingsArn: String) {
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct DeleteBrowserSettingsRequest: AWSEncodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String

        public init(browserSettingsArn: String) {
            self.browserSettingsArn = browserSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserSettingsArn, key: "browserSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, max: 2048)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, min: 20)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBrowserSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIdentityProviderRequest: AWSEncodableShape {
        /// The ARN of the identity provider.
        public let identityProviderArn: String

        public init(identityProviderArn: String) {
            self.identityProviderArn = identityProviderArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identityProviderArn, key: "identityProviderArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, max: 2048)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, min: 20)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36}){2,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIdentityProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIpAccessSettingsRequest: AWSEncodableShape {
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String

        public init(ipAccessSettingsArn: String) {
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.ipAccessSettingsArn, key: "ipAccessSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, max: 2048)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, min: 20)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIpAccessSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteNetworkSettingsRequest: AWSEncodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String

        public init(networkSettingsArn: String) {
            self.networkSettingsArn = networkSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkSettingsArn, key: "networkSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, max: 2048)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, min: 20)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNetworkSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePortalRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTrustStoreRequest: AWSEncodableShape {
        /// The ARN of the trust store.
        public let trustStoreArn: String

        public init(trustStoreArn: String) {
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTrustStoreResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        public init(userAccessLoggingSettingsArn: String) {
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.userAccessLoggingSettingsArn, key: "userAccessLoggingSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, max: 2048)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, min: 20)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserAccessLoggingSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUserSettingsRequest: AWSEncodableShape {
        /// The ARN of the user settings.
        public let userSettingsArn: String

        public init(userSettingsArn: String) {
            self.userSettingsArn = userSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.userSettingsArn, key: "userSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, max: 2048)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, min: 20)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateBrowserSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateBrowserSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateIpAccessSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateIpAccessSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateNetworkSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateNetworkSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateTrustStoreRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateTrustStoreResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateUserAccessLoggingSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateUserSettingsRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateUserSettingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GetBrowserSettingsRequest: AWSEncodableShape {
        /// The ARN of the browser settings.
        public let browserSettingsArn: String

        public init(browserSettingsArn: String) {
            self.browserSettingsArn = browserSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserSettingsArn, key: "browserSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, max: 2048)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, min: 20)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBrowserSettingsResponse: AWSDecodableShape {
        /// The browser settings.
        public let browserSettings: BrowserSettings?

        public init(browserSettings: BrowserSettings? = nil) {
            self.browserSettings = browserSettings
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettings = "browserSettings"
        }
    }

    public struct GetIdentityProviderRequest: AWSEncodableShape {
        /// The ARN of the identity provider.
        public let identityProviderArn: String

        public init(identityProviderArn: String) {
            self.identityProviderArn = identityProviderArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identityProviderArn, key: "identityProviderArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, max: 2048)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, min: 20)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36}){2,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdentityProviderResponse: AWSDecodableShape {
        /// The identity provider.
        public let identityProvider: IdentityProvider?

        public init(identityProvider: IdentityProvider? = nil) {
            self.identityProvider = identityProvider
        }

        private enum CodingKeys: String, CodingKey {
            case identityProvider = "identityProvider"
        }
    }

    public struct GetIpAccessSettingsRequest: AWSEncodableShape {
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String

        public init(ipAccessSettingsArn: String) {
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.ipAccessSettingsArn, key: "ipAccessSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, max: 2048)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, min: 20)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIpAccessSettingsResponse: AWSDecodableShape {
        /// The IP access settings.
        public let ipAccessSettings: IpAccessSettings?

        public init(ipAccessSettings: IpAccessSettings? = nil) {
            self.ipAccessSettings = ipAccessSettings
        }

        private enum CodingKeys: String, CodingKey {
            case ipAccessSettings = "ipAccessSettings"
        }
    }

    public struct GetNetworkSettingsRequest: AWSEncodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String

        public init(networkSettingsArn: String) {
            self.networkSettingsArn = networkSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.networkSettingsArn, key: "networkSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, max: 2048)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, min: 20)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkSettingsResponse: AWSDecodableShape {
        /// The network settings.
        public let networkSettings: NetworkSettings?

        public init(networkSettings: NetworkSettings? = nil) {
            self.networkSettings = networkSettings
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettings = "networkSettings"
        }
    }

    public struct GetPortalRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPortalResponse: AWSDecodableShape {
        /// The web portal.
        public let portal: Portal?

        public init(portal: Portal? = nil) {
            self.portal = portal
        }

        private enum CodingKeys: String, CodingKey {
            case portal = "portal"
        }
    }

    public struct GetPortalServiceProviderMetadataRequest: AWSEncodableShape {
        /// The ARN of the web portal.
        public let portalArn: String

        public init(portalArn: String) {
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPortalServiceProviderMetadataResponse: AWSDecodableShape {
        /// The ARN of the web portal.
        public let portalArn: String
        /// The service provider SAML metadata.
        public let serviceProviderSamlMetadata: String?

        public init(portalArn: String, serviceProviderSamlMetadata: String? = nil) {
            self.portalArn = portalArn
            self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case serviceProviderSamlMetadata = "serviceProviderSamlMetadata"
        }
    }

    public struct GetTrustStoreCertificateRequest: AWSEncodableShape {
        /// The thumbprint of the trust store certificate.
        public let thumbprint: String
        /// The ARN of the trust store certificate.
        public let trustStoreArn: String

        public init(thumbprint: String, trustStoreArn: String) {
            self.thumbprint = thumbprint
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.thumbprint, key: "thumbprint")
            request.encodePath(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.thumbprint, name: "thumbprint", parent: name, max: 64)
            try self.validate(self.thumbprint, name: "thumbprint", parent: name, min: 64)
            try self.validate(self.thumbprint, name: "thumbprint", parent: name, pattern: "^[A-Fa-f0-9]{64}$")
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTrustStoreCertificateResponse: AWSDecodableShape {
        /// The certificate of the trust store certificate.
        public let certificate: Certificate?
        /// The ARN of the trust store certificate.
        public let trustStoreArn: String

        public init(certificate: Certificate? = nil, trustStoreArn: String) {
            self.certificate = certificate
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "certificate"
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct GetTrustStoreRequest: AWSEncodableShape {
        /// The ARN of the trust store.
        public let trustStoreArn: String

        public init(trustStoreArn: String) {
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTrustStoreResponse: AWSDecodableShape {
        /// The trust store.
        public let trustStore: TrustStore?

        public init(trustStore: TrustStore? = nil) {
            self.trustStore = trustStore
        }

        private enum CodingKeys: String, CodingKey {
            case trustStore = "trustStore"
        }
    }

    public struct GetUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        public init(userAccessLoggingSettingsArn: String) {
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.userAccessLoggingSettingsArn, key: "userAccessLoggingSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, max: 2048)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, min: 20)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUserAccessLoggingSettingsResponse: AWSDecodableShape {
        /// The user access logging settings.
        public let userAccessLoggingSettings: UserAccessLoggingSettings?

        public init(userAccessLoggingSettings: UserAccessLoggingSettings? = nil) {
            self.userAccessLoggingSettings = userAccessLoggingSettings
        }

        private enum CodingKeys: String, CodingKey {
            case userAccessLoggingSettings = "userAccessLoggingSettings"
        }
    }

    public struct GetUserSettingsRequest: AWSEncodableShape {
        /// The ARN of the user settings.
        public let userSettingsArn: String

        public init(userSettingsArn: String) {
            self.userSettingsArn = userSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.userSettingsArn, key: "userSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, max: 2048)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, min: 20)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUserSettingsResponse: AWSDecodableShape {
        /// The user settings.
        public let userSettings: UserSettings?

        public init(userSettings: UserSettings? = nil) {
            self.userSettings = userSettings
        }

        private enum CodingKeys: String, CodingKey {
            case userSettings = "userSettings"
        }
    }

    public struct IdentityProvider: AWSDecodableShape {
        /// The ARN of the identity provider.
        public let identityProviderArn: String
        /// The identity provider details. The following list describes the provider detail keys for each identity provider type.    For Google and Login with Amazon:          client_id     client_secret     authorize_scopes      For Facebook:          client_id     client_secret     authorize_scopes     api_version      For Sign in with Apple:          client_id     team_id     key_id     private_key     authorize_scopes      For OIDC providers:          client_id     client_secret     attributes_request_method     oidc_issuer     authorize_scopes     authorize_url if not available from discovery URL specified by oidc_issuer key     token_url if not available from discovery URL specified by oidc_issuer key     attributes_url if not available from discovery URL specified by oidc_issuer key     jwks_uri if not available from discovery URL specified by oidc_issuer key      For SAML providers:          MetadataFile OR MetadataURL     IDPSignout optional
        public let identityProviderDetails: [String: String]?
        /// The identity provider name.
        public let identityProviderName: String?
        /// The identity provider type.
        public let identityProviderType: IdentityProviderType?

        public init(identityProviderArn: String, identityProviderDetails: [String: String]? = nil, identityProviderName: String? = nil, identityProviderType: IdentityProviderType? = nil) {
            self.identityProviderArn = identityProviderArn
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }

        private enum CodingKeys: String, CodingKey {
            case identityProviderArn = "identityProviderArn"
            case identityProviderDetails = "identityProviderDetails"
            case identityProviderName = "identityProviderName"
            case identityProviderType = "identityProviderType"
        }
    }

    public struct IdentityProviderSummary: AWSDecodableShape {
        /// The ARN of the identity provider.
        public let identityProviderArn: String
        /// The identity provider name.
        public let identityProviderName: String?
        /// The identity provider type.
        public let identityProviderType: IdentityProviderType?

        public init(identityProviderArn: String, identityProviderName: String? = nil, identityProviderType: IdentityProviderType? = nil) {
            self.identityProviderArn = identityProviderArn
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }

        private enum CodingKeys: String, CodingKey {
            case identityProviderArn = "identityProviderArn"
            case identityProviderName = "identityProviderName"
            case identityProviderType = "identityProviderType"
        }
    }

    public struct IpAccessSettings: AWSDecodableShape {
        /// A list of web portal ARNs that this IP access settings resource is associated with.
        public let associatedPortalArns: [String]?
        /// The creation date timestamp of the IP access settings.
        public let creationDate: Date?
        /// The description of the IP access settings.
        public let description: String?
        ///  The display name of the IP access settings.
        public let displayName: String?
        /// The ARN of the IP access settings resource.
        public let ipAccessSettingsArn: String
        /// The IP rules of the IP access settings.
        public let ipRules: [IpRule]?

        public init(associatedPortalArns: [String]? = nil, creationDate: Date? = nil, description: String? = nil, displayName: String? = nil, ipAccessSettingsArn: String, ipRules: [IpRule]? = nil) {
            self.associatedPortalArns = associatedPortalArns
            self.creationDate = creationDate
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.ipRules = ipRules
        }

        private enum CodingKeys: String, CodingKey {
            case associatedPortalArns = "associatedPortalArns"
            case creationDate = "creationDate"
            case description = "description"
            case displayName = "displayName"
            case ipAccessSettingsArn = "ipAccessSettingsArn"
            case ipRules = "ipRules"
        }
    }

    public struct IpAccessSettingsSummary: AWSDecodableShape {
        /// The creation date timestamp of the IP access settings.
        public let creationDate: Date?
        /// The description of the IP access settings.
        public let description: String?
        /// The display name of the IP access settings.
        public let displayName: String?
        /// The ARN of IP access settings.
        public let ipAccessSettingsArn: String

        public init(creationDate: Date? = nil, description: String? = nil, displayName: String? = nil, ipAccessSettingsArn: String) {
            self.creationDate = creationDate
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case displayName = "displayName"
            case ipAccessSettingsArn = "ipAccessSettingsArn"
        }
    }

    public struct IpRule: AWSEncodableShape & AWSDecodableShape {
        /// The description of the IP rule.
        public let description: String?
        /// The IP range of the IP rule.
        public let ipRange: String

        public init(description: String? = nil, ipRange: String) {
            self.description = description
            self.ipRange = ipRange
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.validate(self.ipRange, name: "ipRange", parent: name, pattern: "^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(?:/([0-9]|[12][0-9]|3[0-2])|)$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case ipRange = "ipRange"
        }
    }

    public struct ListBrowserSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBrowserSettingsResponse: AWSDecodableShape {
        /// The browser settings.
        public let browserSettings: [BrowserSettingsSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(browserSettings: [BrowserSettingsSummary]? = nil, nextToken: String? = nil) {
            self.browserSettings = browserSettings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettings = "browserSettings"
            case nextToken = "nextToken"
        }
    }

    public struct ListIdentityProvidersRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The ARN of the web portal.
        public let portalArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, portalArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdentityProvidersResponse: AWSDecodableShape {
        /// The identity providers.
        public let identityProviders: [IdentityProviderSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(identityProviders: [IdentityProviderSummary]? = nil, nextToken: String? = nil) {
            self.identityProviders = identityProviders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case identityProviders = "identityProviders"
            case nextToken = "nextToken"
        }
    }

    public struct ListIpAccessSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIpAccessSettingsResponse: AWSDecodableShape {
        /// The IP access settings.
        public let ipAccessSettings: [IpAccessSettingsSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(ipAccessSettings: [IpAccessSettingsSummary]? = nil, nextToken: String? = nil) {
            self.ipAccessSettings = ipAccessSettings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ipAccessSettings = "ipAccessSettings"
            case nextToken = "nextToken"
        }
    }

    public struct ListNetworkSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNetworkSettingsResponse: AWSDecodableShape {
        /// The network settings.
        public let networkSettings: [NetworkSettingsSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(networkSettings: [NetworkSettingsSummary]? = nil, nextToken: String? = nil) {
            self.networkSettings = networkSettings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettings = "networkSettings"
            case nextToken = "nextToken"
        }
    }

    public struct ListPortalsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPortalsResponse: AWSDecodableShape {
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The portals in the list.
        public let portals: [PortalSummary]?

        public init(nextToken: String? = nil, portals: [PortalSummary]? = nil) {
            self.nextToken = nextToken
            self.portals = portals
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case portals = "portals"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags of the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTrustStoreCertificatesRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The ARN of the trust store
        public let trustStoreArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, trustStoreArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTrustStoreCertificatesResponse: AWSDecodableShape {
        /// The certificate list.
        public let certificateList: [CertificateSummary]?
        /// The pagination token used to retrieve the next page of results for this operation.&gt;
        public let nextToken: String?
        /// The ARN of the trust store.
        public let trustStoreArn: String

        public init(certificateList: [CertificateSummary]? = nil, nextToken: String? = nil, trustStoreArn: String) {
            self.certificateList = certificateList
            self.nextToken = nextToken
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateList = "certificateList"
            case nextToken = "nextToken"
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct ListTrustStoresRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTrustStoresResponse: AWSDecodableShape {
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The trust stores.
        public let trustStores: [TrustStoreSummary]?

        public init(nextToken: String? = nil, trustStores: [TrustStoreSummary]? = nil) {
            self.nextToken = nextToken
            self.trustStores = trustStores
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case trustStores = "trustStores"
        }
    }

    public struct ListUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUserAccessLoggingSettingsResponse: AWSDecodableShape {
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The user access logging settings.
        public let userAccessLoggingSettings: [UserAccessLoggingSettingsSummary]?

        public init(nextToken: String? = nil, userAccessLoggingSettings: [UserAccessLoggingSettingsSummary]? = nil) {
            self.nextToken = nextToken
            self.userAccessLoggingSettings = userAccessLoggingSettings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case userAccessLoggingSettings = "userAccessLoggingSettings"
        }
    }

    public struct ListUserSettingsRequest: AWSEncodableShape {
        /// The maximum number of results to be included in the next page.
        public let maxResults: Int?
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUserSettingsResponse: AWSDecodableShape {
        /// The pagination token used to retrieve the next page of results for this operation.
        public let nextToken: String?
        /// The user settings.
        public let userSettings: [UserSettingsSummary]?

        public init(nextToken: String? = nil, userSettings: [UserSettingsSummary]? = nil) {
            self.nextToken = nextToken
            self.userSettings = userSettings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case userSettings = "userSettings"
        }
    }

    public struct NetworkSettings: AWSDecodableShape {
        /// A list of web portal ARNs that this network settings is associated with.
        public let associatedPortalArns: [String]?
        /// The ARN of the network settings.
        public let networkSettingsArn: String
        /// One or more security groups used to control access from streaming instances to your VPC.
        public let securityGroupIds: [String]?
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public let subnetIds: [String]?
        /// The VPC that streaming instances will connect to.
        public let vpcId: String?

        public init(associatedPortalArns: [String]? = nil, networkSettingsArn: String, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.associatedPortalArns = associatedPortalArns
            self.networkSettingsArn = networkSettingsArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case associatedPortalArns = "associatedPortalArns"
            case networkSettingsArn = "networkSettingsArn"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct NetworkSettingsSummary: AWSDecodableShape {
        /// The ARN of the network settings.
        public let networkSettingsArn: String
        /// The VPC ID of the network settings.
        public let vpcId: String?

        public init(networkSettingsArn: String, vpcId: String? = nil) {
            self.networkSettingsArn = networkSettingsArn
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettingsArn = "networkSettingsArn"
            case vpcId = "vpcId"
        }
    }

    public struct Portal: AWSDecodableShape {
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard.  Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.  IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public let authenticationType: AuthenticationType?
        /// The ARN of the browser settings that is associated with this web portal.
        public let browserSettingsArn: String?
        /// The browser that users see when using a streaming session.
        public let browserType: BrowserType?
        /// The creation date of the web portal.
        public let creationDate: Date?
        /// The name of the web portal.
        public let displayName: String?
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String?
        /// The ARN of the network settings that is associated with the web portal.
        public let networkSettingsArn: String?
        /// The ARN of the web portal.
        public let portalArn: String
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public let portalEndpoint: String?
        /// The status of the web portal.
        public let portalStatus: PortalStatus?
        /// The renderer that is used in streaming sessions.
        public let rendererType: RendererType?
        /// A message that explains why the web portal is in its current status.
        public let statusReason: String?
        /// The ARN of the trust store that is associated with the web portal.
        public let trustStoreArn: String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public let userAccessLoggingSettingsArn: String?
        /// The ARN of the user settings that is associated with the web portal.
        public let userSettingsArn: String?

        public init(authenticationType: AuthenticationType? = nil, browserSettingsArn: String? = nil, browserType: BrowserType? = nil, creationDate: Date? = nil, displayName: String? = nil, ipAccessSettingsArn: String? = nil, networkSettingsArn: String? = nil, portalArn: String, portalEndpoint: String? = nil, portalStatus: PortalStatus? = nil, rendererType: RendererType? = nil, statusReason: String? = nil, trustStoreArn: String? = nil, userAccessLoggingSettingsArn: String? = nil, userSettingsArn: String? = nil) {
            self.authenticationType = authenticationType
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.statusReason = statusReason
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
            case browserSettingsArn = "browserSettingsArn"
            case browserType = "browserType"
            case creationDate = "creationDate"
            case displayName = "displayName"
            case ipAccessSettingsArn = "ipAccessSettingsArn"
            case networkSettingsArn = "networkSettingsArn"
            case portalArn = "portalArn"
            case portalEndpoint = "portalEndpoint"
            case portalStatus = "portalStatus"
            case rendererType = "rendererType"
            case statusReason = "statusReason"
            case trustStoreArn = "trustStoreArn"
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct PortalSummary: AWSDecodableShape {
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard.  Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.  IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public let authenticationType: AuthenticationType?
        /// The ARN of the browser settings that is associated with the web portal.
        public let browserSettingsArn: String?
        /// The browser type of the web portal.
        public let browserType: BrowserType?
        /// The creation date of the web portal.
        public let creationDate: Date?
        /// The name of the web portal.
        public let displayName: String?
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String?
        /// The ARN of the network settings that is associated with the web portal.
        public let networkSettingsArn: String?
        /// The ARN of the web portal.
        public let portalArn: String
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public let portalEndpoint: String?
        /// The status of the web portal.
        public let portalStatus: PortalStatus?
        /// The renderer that is used in streaming sessions.
        public let rendererType: RendererType?
        /// The ARN of the trust that is associated with this web portal.
        public let trustStoreArn: String?
        /// The ARN of the user access logging settings that is associated with the web portal.
        public let userAccessLoggingSettingsArn: String?
        /// The ARN of the user settings that is associated with the web portal.
        public let userSettingsArn: String?

        public init(authenticationType: AuthenticationType? = nil, browserSettingsArn: String? = nil, browserType: BrowserType? = nil, creationDate: Date? = nil, displayName: String? = nil, ipAccessSettingsArn: String? = nil, networkSettingsArn: String? = nil, portalArn: String, portalEndpoint: String? = nil, portalStatus: PortalStatus? = nil, rendererType: RendererType? = nil, trustStoreArn: String? = nil, userAccessLoggingSettingsArn: String? = nil, userSettingsArn: String? = nil) {
            self.authenticationType = authenticationType
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.trustStoreArn = trustStoreArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
            case browserSettingsArn = "browserSettingsArn"
            case browserType = "browserType"
            case creationDate = "creationDate"
            case displayName = "displayName"
            case ipAccessSettingsArn = "ipAccessSettingsArn"
            case networkSettingsArn = "networkSettingsArn"
            case portalArn = "portalArn"
            case portalEndpoint = "portalEndpoint"
            case portalStatus = "portalStatus"
            case rendererType = "rendererType"
            case trustStoreArn = "trustStoreArn"
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the tag.
        public let key: String
        /// The value of the tag
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The ARN of the resource.
        public let resourceArn: String
        /// The tags of the resource.
        public let tags: [Tag]

        public init(clientToken: String? = TagResourceRequest.idempotencyToken(), resourceArn: String, tags: [Tag]) {
            self.clientToken = clientToken
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TrustStore: AWSDecodableShape {
        /// A list of web portal ARNs that this trust store is associated with.
        public let associatedPortalArns: [String]?
        /// The ARN of the trust store.
        public let trustStoreArn: String

        public init(associatedPortalArns: [String]? = nil, trustStoreArn: String) {
            self.associatedPortalArns = associatedPortalArns
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case associatedPortalArns = "associatedPortalArns"
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct TrustStoreSummary: AWSDecodableShape {
        /// The ARN of the trust store.
        public let trustStoreArn: String?

        public init(trustStoreArn: String? = nil) {
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBrowserSettingsRequest: AWSEncodableShape {
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public let browserPolicy: String?
        /// The ARN of the browser settings.
        public let browserSettingsArn: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?

        public init(browserPolicy: String? = nil, browserSettingsArn: String, clientToken: String? = UpdateBrowserSettingsRequest.idempotencyToken()) {
            self.browserPolicy = browserPolicy
            self.browserSettingsArn = browserSettingsArn
            self.clientToken = clientToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.browserPolicy, forKey: .browserPolicy)
            request.encodePath(self.browserSettingsArn, key: "browserSettingsArn")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, max: 131072)
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, min: 2)
            try self.validate(self.browserPolicy, name: "browserPolicy", parent: name, pattern: "\\{[\\S\\s]*\\}\\s*")
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, max: 2048)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, min: 20)
            try self.validate(self.browserSettingsArn, name: "browserSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case browserPolicy = "browserPolicy"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateBrowserSettingsResponse: AWSDecodableShape {
        /// The browser settings.
        public let browserSettings: BrowserSettings

        public init(browserSettings: BrowserSettings) {
            self.browserSettings = browserSettings
        }

        private enum CodingKeys: String, CodingKey {
            case browserSettings = "browserSettings"
        }
    }

    public struct UpdateIdentityProviderRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The ARN of the identity provider.
        public let identityProviderArn: String
        /// The details of the identity provider. The following list describes the provider detail keys for each identity provider type.    For Google and Login with Amazon:          client_id     client_secret     authorize_scopes      For Facebook:          client_id     client_secret     authorize_scopes     api_version      For Sign in with Apple:          client_id     team_id     key_id     private_key     authorize_scopes      For OIDC providers:          client_id     client_secret     attributes_request_method     oidc_issuer     authorize_scopes     authorize_url if not available from discovery URL specified by oidc_issuer key     token_url if not available from discovery URL specified by oidc_issuer key     attributes_url if not available from discovery URL specified by oidc_issuer key     jwks_uri if not available from discovery URL specified by oidc_issuer key      For SAML providers:          MetadataFile OR MetadataURL     IDPSignout (boolean)  optional
        public let identityProviderDetails: [String: String]?
        /// The name of the identity provider.
        public let identityProviderName: String?
        /// The type of the identity provider.
        public let identityProviderType: IdentityProviderType?

        public init(clientToken: String? = UpdateIdentityProviderRequest.idempotencyToken(), identityProviderArn: String, identityProviderDetails: [String: String]? = nil, identityProviderName: String? = nil, identityProviderType: IdentityProviderType? = nil) {
            self.clientToken = clientToken
            self.identityProviderArn = identityProviderArn
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.identityProviderArn, key: "identityProviderArn")
            try container.encodeIfPresent(self.identityProviderDetails, forKey: .identityProviderDetails)
            try container.encodeIfPresent(self.identityProviderName, forKey: .identityProviderName)
            try container.encodeIfPresent(self.identityProviderType, forKey: .identityProviderType)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, max: 2048)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, min: 20)
            try self.validate(self.identityProviderArn, name: "identityProviderArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36}){2,}$")
            try self.identityProviderDetails?.forEach {
                try validate($0.key, name: "identityProviderDetails.key", parent: name, max: 131072)
                try validate($0.key, name: "identityProviderDetails.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "identityProviderDetails[\"\($0.key)\"]", parent: name, max: 131072)
                try validate($0.value, name: "identityProviderDetails[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, max: 32)
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, min: 1)
            try self.validate(self.identityProviderName, name: "identityProviderName", parent: name, pattern: "^[^_][\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}][^_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case identityProviderDetails = "identityProviderDetails"
            case identityProviderName = "identityProviderName"
            case identityProviderType = "identityProviderType"
        }
    }

    public struct UpdateIdentityProviderResponse: AWSDecodableShape {
        /// The identity provider.
        public let identityProvider: IdentityProvider

        public init(identityProvider: IdentityProvider) {
            self.identityProvider = identityProvider
        }

        private enum CodingKeys: String, CodingKey {
            case identityProvider = "identityProvider"
        }
    }

    public struct UpdateIpAccessSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The description of the IP access settings.
        public let description: String?
        /// The display name of the IP access settings.
        public let displayName: String?
        /// The ARN of the IP access settings.
        public let ipAccessSettingsArn: String
        /// The updated IP rules of the IP access settings.
        public let ipRules: [IpRule]?

        public init(clientToken: String? = UpdateIpAccessSettingsRequest.idempotencyToken(), description: String? = nil, displayName: String? = nil, ipAccessSettingsArn: String, ipRules: [IpRule]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.ipAccessSettingsArn = ipAccessSettingsArn
            self.ipRules = ipRules
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.ipAccessSettingsArn, key: "ipAccessSettingsArn")
            try container.encodeIfPresent(self.ipRules, forKey: .ipRules)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^.+$")
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, max: 2048)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, min: 20)
            try self.validate(self.ipAccessSettingsArn, name: "ipAccessSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.ipRules?.forEach {
                try $0.validate(name: "\(name).ipRules[]")
            }
            try self.validate(self.ipRules, name: "ipRules", parent: name, max: 100)
            try self.validate(self.ipRules, name: "ipRules", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case displayName = "displayName"
            case ipRules = "ipRules"
        }
    }

    public struct UpdateIpAccessSettingsResponse: AWSDecodableShape {
        /// The IP access settings.
        public let ipAccessSettings: IpAccessSettings

        public init(ipAccessSettings: IpAccessSettings) {
            self.ipAccessSettings = ipAccessSettings
        }

        private enum CodingKeys: String, CodingKey {
            case ipAccessSettings = "ipAccessSettings"
        }
    }

    public struct UpdateNetworkSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The ARN of the network settings.
        public let networkSettingsArn: String
        /// One or more security groups used to control access from streaming instances to your VPC.
        public let securityGroupIds: [String]?
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public let subnetIds: [String]?
        /// The VPC that streaming instances will connect to.
        public let vpcId: String?

        public init(clientToken: String? = UpdateNetworkSettingsRequest.idempotencyToken(), networkSettingsArn: String, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.clientToken = clientToken
            self.networkSettingsArn = networkSettingsArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.networkSettingsArn, key: "networkSettingsArn")
            try container.encodeIfPresent(self.securityGroupIds, forKey: .securityGroupIds)
            try container.encodeIfPresent(self.subnetIds, forKey: .subnetIds)
            try container.encodeIfPresent(self.vpcId, forKey: .vpcId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, max: 2048)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, min: 20)
            try self.validate(self.networkSettingsArn, name: "networkSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 128)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[\\w+\\-]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 32)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-([0-9a-f]{8}|[0-9a-f]{17})$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 3)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 2)
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 255)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[0-9a-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct UpdateNetworkSettingsResponse: AWSDecodableShape {
        /// The network settings.
        public let networkSettings: NetworkSettings

        public init(networkSettings: NetworkSettings) {
            self.networkSettings = networkSettings
        }

        private enum CodingKeys: String, CodingKey {
            case networkSettings = "networkSettings"
        }
    }

    public struct UpdatePortalRequest: AWSEncodableShape {
        /// The type of authentication integration points used when signing into the web portal. Defaults to Standard.  Standard web portals are authenticated directly through your identity provider. You need to call CreateIdentityProvider to integrate your identity provider with your web portal. User and group access to your web portal is controlled through your identity provider.  IAM_Identity_Center web portals are authenticated through AWS IAM Identity Center (successor to AWS Single Sign-On). They provide additional features, such as IdP-initiated authentication. Identity sources (including external identity provider integration), plus user and group access to your web portal, can be configured in the IAM Identity Center.
        public let authenticationType: AuthenticationType?
        /// The name of the web portal. This is not visible to users who log into the web portal.
        public let displayName: String?
        /// The ARN of the web portal.
        public let portalArn: String

        public init(authenticationType: AuthenticationType? = nil, displayName: String? = nil, portalArn: String) {
            self.authenticationType = authenticationType
            self.displayName = displayName
            self.portalArn = portalArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authenticationType, forKey: .authenticationType)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.portalArn, key: "portalArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^.+$")
            try self.validate(self.portalArn, name: "portalArn", parent: name, max: 2048)
            try self.validate(self.portalArn, name: "portalArn", parent: name, min: 20)
            try self.validate(self.portalArn, name: "portalArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
            case displayName = "displayName"
        }
    }

    public struct UpdatePortalResponse: AWSDecodableShape {
        /// The web portal.
        public let portal: Portal?

        public init(portal: Portal? = nil) {
            self.portal = portal
        }

        private enum CodingKeys: String, CodingKey {
            case portal = "portal"
        }
    }

    public struct UpdateTrustStoreRequest: AWSEncodableShape {
        /// A list of CA certificates to add to the trust store.
        public let certificatesToAdd: [AWSBase64Data]?
        /// A list of CA certificates to delete from a trust store.
        public let certificatesToDelete: [String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The ARN of the trust store.
        public let trustStoreArn: String

        public init(certificatesToAdd: [AWSBase64Data]? = nil, certificatesToDelete: [String]? = nil, clientToken: String? = UpdateTrustStoreRequest.idempotencyToken(), trustStoreArn: String) {
            self.certificatesToAdd = certificatesToAdd
            self.certificatesToDelete = certificatesToDelete
            self.clientToken = clientToken
            self.trustStoreArn = trustStoreArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.certificatesToAdd, forKey: .certificatesToAdd)
            try container.encodeIfPresent(self.certificatesToDelete, forKey: .certificatesToDelete)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.trustStoreArn, key: "trustStoreArn")
        }

        public func validate(name: String) throws {
            try self.certificatesToDelete?.forEach {
                try validate($0, name: "certificatesToDelete[]", parent: name, max: 64)
                try validate($0, name: "certificatesToDelete[]", parent: name, min: 64)
                try validate($0, name: "certificatesToDelete[]", parent: name, pattern: "^[A-Fa-f0-9]{64}$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, max: 2048)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, min: 20)
            try self.validate(self.trustStoreArn, name: "trustStoreArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case certificatesToAdd = "certificatesToAdd"
            case certificatesToDelete = "certificatesToDelete"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateTrustStoreResponse: AWSDecodableShape {
        /// The ARN of the trust store.
        public let trustStoreArn: String

        public init(trustStoreArn: String) {
            self.trustStoreArn = trustStoreArn
        }

        private enum CodingKeys: String, CodingKey {
            case trustStoreArn = "trustStoreArn"
        }
    }

    public struct UpdateUserAccessLoggingSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The ARN of the Kinesis stream.
        public let kinesisStreamArn: String?
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        public init(clientToken: String? = UpdateUserAccessLoggingSettingsRequest.idempotencyToken(), kinesisStreamArn: String? = nil, userAccessLoggingSettingsArn: String) {
            self.clientToken = clientToken
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.kinesisStreamArn, forKey: .kinesisStreamArn)
            request.encodePath(self.userAccessLoggingSettingsArn, key: "userAccessLoggingSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, max: 2048)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, min: 20)
            try self.validate(self.kinesisStreamArn, name: "kinesisStreamArn", parent: name, pattern: "arn:[\\w+=/,.@-]+:kinesis:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:stream/.+")
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, max: 2048)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, min: 20)
            try self.validate(self.userAccessLoggingSettingsArn, name: "userAccessLoggingSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case kinesisStreamArn = "kinesisStreamArn"
        }
    }

    public struct UpdateUserAccessLoggingSettingsResponse: AWSDecodableShape {
        /// The user access logging settings.
        public let userAccessLoggingSettings: UserAccessLoggingSettings

        public init(userAccessLoggingSettings: UserAccessLoggingSettings) {
            self.userAccessLoggingSettings = userAccessLoggingSettings
        }

        private enum CodingKeys: String, CodingKey {
            case userAccessLoggingSettings = "userAccessLoggingSettings"
        }
    }

    public struct UpdateUserSettingsRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request.  If you do not specify a client token, one is automatically generated by the AWS SDK.
        public let clientToken: String?
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser. If the allowlist and blocklist are empty, the configuration becomes null.
        public let cookieSynchronizationConfiguration: CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public let copyAllowed: EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public let disconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public let downloadAllowed: EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public let idleDisconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public let pasteAllowed: EnabledType?
        /// Specifies whether the user can print to the local device.
        public let printAllowed: EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public let uploadAllowed: EnabledType?
        /// The ARN of the user settings.
        public let userSettingsArn: String

        public init(clientToken: String? = UpdateUserSettingsRequest.idempotencyToken(), cookieSynchronizationConfiguration: CookieSynchronizationConfiguration? = nil, copyAllowed: EnabledType? = nil, disconnectTimeoutInMinutes: Int? = nil, downloadAllowed: EnabledType? = nil, idleDisconnectTimeoutInMinutes: Int? = nil, pasteAllowed: EnabledType? = nil, printAllowed: EnabledType? = nil, uploadAllowed: EnabledType? = nil, userSettingsArn: String) {
            self.clientToken = clientToken
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.cookieSynchronizationConfiguration, forKey: .cookieSynchronizationConfiguration)
            try container.encodeIfPresent(self.copyAllowed, forKey: .copyAllowed)
            try container.encodeIfPresent(self.disconnectTimeoutInMinutes, forKey: .disconnectTimeoutInMinutes)
            try container.encodeIfPresent(self.downloadAllowed, forKey: .downloadAllowed)
            try container.encodeIfPresent(self.idleDisconnectTimeoutInMinutes, forKey: .idleDisconnectTimeoutInMinutes)
            try container.encodeIfPresent(self.pasteAllowed, forKey: .pasteAllowed)
            try container.encodeIfPresent(self.printAllowed, forKey: .printAllowed)
            try container.encodeIfPresent(self.uploadAllowed, forKey: .uploadAllowed)
            request.encodePath(self.userSettingsArn, key: "userSettingsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.cookieSynchronizationConfiguration?.validate(name: "\(name).cookieSynchronizationConfiguration")
            try self.validate(self.disconnectTimeoutInMinutes, name: "disconnectTimeoutInMinutes", parent: name, max: 600)
            try self.validate(self.disconnectTimeoutInMinutes, name: "disconnectTimeoutInMinutes", parent: name, min: 1)
            try self.validate(self.idleDisconnectTimeoutInMinutes, name: "idleDisconnectTimeoutInMinutes", parent: name, max: 60)
            try self.validate(self.idleDisconnectTimeoutInMinutes, name: "idleDisconnectTimeoutInMinutes", parent: name, min: 0)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, max: 2048)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, min: 20)
            try self.validate(self.userSettingsArn, name: "userSettingsArn", parent: name, pattern: "^arn:[\\w+=\\/,.@-]+:[a-zA-Z0-9\\-]+:[a-zA-Z0-9\\-]*:[a-zA-Z0-9]{1,12}:[a-zA-Z]+(\\/[a-fA-F0-9\\-]{36})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case cookieSynchronizationConfiguration = "cookieSynchronizationConfiguration"
            case copyAllowed = "copyAllowed"
            case disconnectTimeoutInMinutes = "disconnectTimeoutInMinutes"
            case downloadAllowed = "downloadAllowed"
            case idleDisconnectTimeoutInMinutes = "idleDisconnectTimeoutInMinutes"
            case pasteAllowed = "pasteAllowed"
            case printAllowed = "printAllowed"
            case uploadAllowed = "uploadAllowed"
        }
    }

    public struct UpdateUserSettingsResponse: AWSDecodableShape {
        /// The user settings.
        public let userSettings: UserSettings

        public init(userSettings: UserSettings) {
            self.userSettings = userSettings
        }

        private enum CodingKeys: String, CodingKey {
            case userSettings = "userSettings"
        }
    }

    public struct UserAccessLoggingSettings: AWSDecodableShape {
        /// A list of web portal ARNs that this user access logging settings is associated with.
        public let associatedPortalArns: [String]?
        /// The ARN of the Kinesis stream.
        public let kinesisStreamArn: String?
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        public init(associatedPortalArns: [String]? = nil, kinesisStreamArn: String? = nil, userAccessLoggingSettingsArn: String) {
            self.associatedPortalArns = associatedPortalArns
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case associatedPortalArns = "associatedPortalArns"
            case kinesisStreamArn = "kinesisStreamArn"
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
        }
    }

    public struct UserAccessLoggingSettingsSummary: AWSDecodableShape {
        /// The ARN of the Kinesis stream.
        public let kinesisStreamArn: String?
        /// The ARN of the user access logging settings.
        public let userAccessLoggingSettingsArn: String

        public init(kinesisStreamArn: String? = nil, userAccessLoggingSettingsArn: String) {
            self.kinesisStreamArn = kinesisStreamArn
            self.userAccessLoggingSettingsArn = userAccessLoggingSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisStreamArn = "kinesisStreamArn"
            case userAccessLoggingSettingsArn = "userAccessLoggingSettingsArn"
        }
    }

    public struct UserSettings: AWSDecodableShape {
        /// A list of web portal ARNs that this user settings is associated with.
        public let associatedPortalArns: [String]?
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public let cookieSynchronizationConfiguration: CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public let copyAllowed: EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public let disconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public let downloadAllowed: EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public let idleDisconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public let pasteAllowed: EnabledType?
        /// Specifies whether the user can print to the local device.
        public let printAllowed: EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public let uploadAllowed: EnabledType?
        /// The ARN of the user settings.
        public let userSettingsArn: String

        public init(associatedPortalArns: [String]? = nil, cookieSynchronizationConfiguration: CookieSynchronizationConfiguration? = nil, copyAllowed: EnabledType? = nil, disconnectTimeoutInMinutes: Int? = nil, downloadAllowed: EnabledType? = nil, idleDisconnectTimeoutInMinutes: Int? = nil, pasteAllowed: EnabledType? = nil, printAllowed: EnabledType? = nil, uploadAllowed: EnabledType? = nil, userSettingsArn: String) {
            self.associatedPortalArns = associatedPortalArns
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case associatedPortalArns = "associatedPortalArns"
            case cookieSynchronizationConfiguration = "cookieSynchronizationConfiguration"
            case copyAllowed = "copyAllowed"
            case disconnectTimeoutInMinutes = "disconnectTimeoutInMinutes"
            case downloadAllowed = "downloadAllowed"
            case idleDisconnectTimeoutInMinutes = "idleDisconnectTimeoutInMinutes"
            case pasteAllowed = "pasteAllowed"
            case printAllowed = "printAllowed"
            case uploadAllowed = "uploadAllowed"
            case userSettingsArn = "userSettingsArn"
        }
    }

    public struct UserSettingsSummary: AWSDecodableShape {
        /// The configuration that specifies which cookies should be synchronized from the end user's local browser to the remote browser.
        public let cookieSynchronizationConfiguration: CookieSynchronizationConfiguration?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public let copyAllowed: EnabledType?
        /// The amount of time that a streaming session remains active after users disconnect.
        public let disconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public let downloadAllowed: EnabledType?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the disconnect timeout interval begins.
        public let idleDisconnectTimeoutInMinutes: Int?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public let pasteAllowed: EnabledType?
        /// Specifies whether the user can print to the local device.
        public let printAllowed: EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public let uploadAllowed: EnabledType?
        /// The ARN of the user settings.
        public let userSettingsArn: String

        public init(cookieSynchronizationConfiguration: CookieSynchronizationConfiguration? = nil, copyAllowed: EnabledType? = nil, disconnectTimeoutInMinutes: Int? = nil, downloadAllowed: EnabledType? = nil, idleDisconnectTimeoutInMinutes: Int? = nil, pasteAllowed: EnabledType? = nil, printAllowed: EnabledType? = nil, uploadAllowed: EnabledType? = nil, userSettingsArn: String) {
            self.cookieSynchronizationConfiguration = cookieSynchronizationConfiguration
            self.copyAllowed = copyAllowed
            self.disconnectTimeoutInMinutes = disconnectTimeoutInMinutes
            self.downloadAllowed = downloadAllowed
            self.idleDisconnectTimeoutInMinutes = idleDisconnectTimeoutInMinutes
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }

        private enum CodingKeys: String, CodingKey {
            case cookieSynchronizationConfiguration = "cookieSynchronizationConfiguration"
            case copyAllowed = "copyAllowed"
            case disconnectTimeoutInMinutes = "disconnectTimeoutInMinutes"
            case downloadAllowed = "downloadAllowed"
            case idleDisconnectTimeoutInMinutes = "idleDisconnectTimeoutInMinutes"
            case pasteAllowed = "pasteAllowed"
            case printAllowed = "printAllowed"
            case uploadAllowed = "uploadAllowed"
            case userSettingsArn = "userSettingsArn"
        }
    }
}

// MARK: - Errors

/// Error enum for WorkSpacesWeb
public struct WorkSpacesWebErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize WorkSpacesWeb
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Access is denied.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There is a conflict.
    public static var conflictException: Self { .init(.conflictException) }
    /// There is an internal server error.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource cannot be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota has been exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// There is a throttling error.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// There are too many tags.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// There is a validation error.
    public static var validationException: Self { .init(.validationException) }
}

extension WorkSpacesWebErrorType: Equatable {
    public static func == (lhs: WorkSpacesWebErrorType, rhs: WorkSpacesWebErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension WorkSpacesWebErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
