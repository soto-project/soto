//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension SMS {
    // MARK: Enums

    public enum AppLaunchConfigurationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configured = "CONFIGURED"
        case notConfigured = "NOT_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum AppLaunchStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configurationInProgress = "CONFIGURATION_IN_PROGRESS"
        case configurationInvalid = "CONFIGURATION_INVALID"
        case deltaLaunchFailed = "DELTA_LAUNCH_FAILED"
        case deltaLaunchInProgress = "DELTA_LAUNCH_IN_PROGRESS"
        case launchFailed = "LAUNCH_FAILED"
        case launchInProgress = "LAUNCH_IN_PROGRESS"
        case launchPending = "LAUNCH_PENDING"
        case launched = "LAUNCHED"
        case partiallyLaunched = "PARTIALLY_LAUNCHED"
        case readyForConfiguration = "READY_FOR_CONFIGURATION"
        case readyForLaunch = "READY_FOR_LAUNCH"
        case terminateFailed = "TERMINATE_FAILED"
        case terminateInProgress = "TERMINATE_IN_PROGRESS"
        case terminated = "TERMINATED"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AppReplicationConfigurationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configured = "CONFIGURED"
        case notConfigured = "NOT_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum AppReplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configurationInProgress = "CONFIGURATION_IN_PROGRESS"
        case configurationInvalid = "CONFIGURATION_INVALID"
        case deltaReplicated = "DELTA_REPLICATED"
        case deltaReplicationFailed = "DELTA_REPLICATION_FAILED"
        case deltaReplicationInProgress = "DELTA_REPLICATION_IN_PROGRESS"
        case partiallyReplicated = "PARTIALLY_REPLICATED"
        case readyForConfiguration = "READY_FOR_CONFIGURATION"
        case readyForReplication = "READY_FOR_REPLICATION"
        case replicated = "REPLICATED"
        case replicationFailed = "REPLICATION_FAILED"
        case replicationInProgress = "REPLICATION_IN_PROGRESS"
        case replicationPending = "REPLICATION_PENDING"
        case replicationStopFailed = "REPLICATION_STOP_FAILED"
        case replicationStopped = "REPLICATION_STOPPED"
        case replicationStopping = "REPLICATION_STOPPING"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AppStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AppValidationStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ssm = "SSM"
        public var description: String { return self.rawValue }
    }

    public enum ConnectorCapability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hyperVManager = "HYPERV-MANAGER"
        case scvmm = "SCVMM"
        case smsOptimized = "SMS_OPTIMIZED"
        case snapshotBatching = "SNAPSHOT_BATCHING"
        case vSphere = "VSPHERE"
        public var description: String { return self.rawValue }
    }

    public enum ConnectorStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum LicenseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "AWS"
        case byol = "BYOL"
        public var description: String { return self.rawValue }
    }

    public enum OutputFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case yaml = "YAML"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationJobState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case completed = "COMPLETED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case failing = "FAILING"
        case pausedOnFailure = "PAUSED_ON_FAILURE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationRunState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case completed = "COMPLETED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case missed = "MISSED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationRunType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automatic = "AUTOMATIC"
        case onDemand = "ON_DEMAND"
        public var description: String { return self.rawValue }
    }

    public enum ScriptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case powershellScript = "POWERSHELL_SCRIPT"
        case shellScript = "SHELL_SCRIPT"
        public var description: String { return self.rawValue }
    }

    public enum ServerCatalogStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case expired = "EXPIRED"
        case importing = "IMPORTING"
        case notImported = "NOT_IMPORTED"
        public var description: String { return self.rawValue }
    }

    public enum ServerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case virtualMachine = "VIRTUAL_MACHINE"
        public var description: String { return self.rawValue }
    }

    public enum ServerValidationStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case userdata = "USERDATA"
        public var description: String { return self.rawValue }
    }

    public enum ValidationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        case readyForValidation = "READY_FOR_VALIDATION"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum VmManagerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hyperVManager = "HYPERV-MANAGER"
        case scvmm = "SCVMM"
        case vSphere = "VSPHERE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AppSummary: AWSDecodableShape {
        /// The unique ID of the application.
        public let appId: String?
        /// The creation time of the application.
        public let creationTime: Date?
        /// The description of the application.
        public let description: String?
        /// The ID of the application.
        public let importedAppId: String?
        /// The last modified time of the application.
        public let lastModified: Date?
        /// The timestamp of the application's most recent successful replication.
        public let latestReplicationTime: Date?
        /// Status of the launch configuration.
        public let launchConfigurationStatus: AppLaunchConfigurationStatus?
        /// Details about the latest launch of the application.
        public let launchDetails: LaunchDetails?
        /// The launch status of the application.
        public let launchStatus: AppLaunchStatus?
        /// A message related to the launch status of the application.
        public let launchStatusMessage: String?
        /// The name of the application.
        public let name: String?
        /// Status of the replication configuration.
        public let replicationConfigurationStatus: AppReplicationConfigurationStatus?
        /// The replication status of the application.
        public let replicationStatus: AppReplicationStatus?
        /// A message related to the replication status of the application.
        public let replicationStatusMessage: String?
        /// The name of the service role in the customer's account used by Server Migration Service.
        public let roleName: String?
        /// Status of the application.
        public let status: AppStatus?
        /// A message related to the status of the application
        public let statusMessage: String?
        /// The number of server groups present in the application.
        public let totalServerGroups: Int?
        /// The number of servers present in the application.
        public let totalServers: Int?

        @inlinable
        public init(appId: String? = nil, creationTime: Date? = nil, description: String? = nil, importedAppId: String? = nil, lastModified: Date? = nil, latestReplicationTime: Date? = nil, launchConfigurationStatus: AppLaunchConfigurationStatus? = nil, launchDetails: LaunchDetails? = nil, launchStatus: AppLaunchStatus? = nil, launchStatusMessage: String? = nil, name: String? = nil, replicationConfigurationStatus: AppReplicationConfigurationStatus? = nil, replicationStatus: AppReplicationStatus? = nil, replicationStatusMessage: String? = nil, roleName: String? = nil, status: AppStatus? = nil, statusMessage: String? = nil, totalServerGroups: Int? = nil, totalServers: Int? = nil) {
            self.appId = appId
            self.creationTime = creationTime
            self.description = description
            self.importedAppId = importedAppId
            self.lastModified = lastModified
            self.latestReplicationTime = latestReplicationTime
            self.launchConfigurationStatus = launchConfigurationStatus
            self.launchDetails = launchDetails
            self.launchStatus = launchStatus
            self.launchStatusMessage = launchStatusMessage
            self.name = name
            self.replicationConfigurationStatus = replicationConfigurationStatus
            self.replicationStatus = replicationStatus
            self.replicationStatusMessage = replicationStatusMessage
            self.roleName = roleName
            self.status = status
            self.statusMessage = statusMessage
            self.totalServerGroups = totalServerGroups
            self.totalServers = totalServers
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case creationTime = "creationTime"
            case description = "description"
            case importedAppId = "importedAppId"
            case lastModified = "lastModified"
            case latestReplicationTime = "latestReplicationTime"
            case launchConfigurationStatus = "launchConfigurationStatus"
            case launchDetails = "launchDetails"
            case launchStatus = "launchStatus"
            case launchStatusMessage = "launchStatusMessage"
            case name = "name"
            case replicationConfigurationStatus = "replicationConfigurationStatus"
            case replicationStatus = "replicationStatus"
            case replicationStatusMessage = "replicationStatusMessage"
            case roleName = "roleName"
            case status = "status"
            case statusMessage = "statusMessage"
            case totalServerGroups = "totalServerGroups"
            case totalServers = "totalServers"
        }
    }

    public struct AppValidationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The validation strategy.
        public let appValidationStrategy: AppValidationStrategy?
        /// The name of the configuration.
        public let name: String?
        /// The validation parameters.
        public let ssmValidationParameters: SSMValidationParameters?
        /// The ID of the validation.
        public let validationId: String?

        @inlinable
        public init(appValidationStrategy: AppValidationStrategy? = nil, name: String? = nil, ssmValidationParameters: SSMValidationParameters? = nil, validationId: String? = nil) {
            self.appValidationStrategy = appValidationStrategy
            self.name = name
            self.ssmValidationParameters = ssmValidationParameters
            self.validationId = validationId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S]+$")
            try self.ssmValidationParameters?.validate(name: "\(name).ssmValidationParameters")
            try self.validate(self.validationId, name: "validationId", parent: name, pattern: "^val-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appValidationStrategy = "appValidationStrategy"
            case name = "name"
            case ssmValidationParameters = "ssmValidationParameters"
            case validationId = "validationId"
        }
    }

    public struct AppValidationOutput: AWSDecodableShape {
        /// Output from using SSM to validate the application.
        public let ssmOutput: SSMOutput?

        @inlinable
        public init(ssmOutput: SSMOutput? = nil) {
            self.ssmOutput = ssmOutput
        }

        private enum CodingKeys: String, CodingKey {
            case ssmOutput = "ssmOutput"
        }
    }

    public struct Connector: AWSDecodableShape {
        /// The time the connector was associated.
        public let associatedOn: Date?
        /// The capabilities of the connector.
        public let capabilityList: [ConnectorCapability]?
        /// The ID of the connector.
        public let connectorId: String?
        /// The IP address of the connector.
        public let ipAddress: String?
        /// The MAC address of the connector.
        public let macAddress: String?
        /// The status of the connector.
        public let status: ConnectorStatus?
        /// The connector version.
        public let version: String?
        /// The ID of the VM manager.
        public let vmManagerId: String?
        /// The name of the VM manager.
        public let vmManagerName: String?
        /// The VM management product.
        public let vmManagerType: VmManagerType?

        @inlinable
        public init(associatedOn: Date? = nil, capabilityList: [ConnectorCapability]? = nil, connectorId: String? = nil, ipAddress: String? = nil, macAddress: String? = nil, status: ConnectorStatus? = nil, version: String? = nil, vmManagerId: String? = nil, vmManagerName: String? = nil, vmManagerType: VmManagerType? = nil) {
            self.associatedOn = associatedOn
            self.capabilityList = capabilityList
            self.connectorId = connectorId
            self.ipAddress = ipAddress
            self.macAddress = macAddress
            self.status = status
            self.version = version
            self.vmManagerId = vmManagerId
            self.vmManagerName = vmManagerName
            self.vmManagerType = vmManagerType
        }

        private enum CodingKeys: String, CodingKey {
            case associatedOn = "associatedOn"
            case capabilityList = "capabilityList"
            case connectorId = "connectorId"
            case ipAddress = "ipAddress"
            case macAddress = "macAddress"
            case status = "status"
            case version = "version"
            case vmManagerId = "vmManagerId"
            case vmManagerName = "vmManagerName"
            case vmManagerType = "vmManagerType"
        }
    }

    public struct CreateAppRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of application creation.
        public let clientToken: String?
        /// The description of the new application
        public let description: String?
        /// The name of the new application.
        public let name: String?
        /// The name of the service role in the customer's account to be used by Server Migration Service.
        public let roleName: String?
        /// The server groups to include in the application.
        public let serverGroups: [ServerGroup]?
        /// The tags to be associated with the application.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = nil, description: String? = nil, name: String? = nil, roleName: String? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.roleName = roleName
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case roleName = "roleName"
            case serverGroups = "serverGroups"
            case tags = "tags"
        }
    }

    public struct CreateAppResponse: AWSDecodableShape {
        /// A summary description of the application.
        public let appSummary: AppSummary?
        /// The server groups included in the application.
        public let serverGroups: [ServerGroup]?
        /// The tags associated with the application.
        public let tags: [Tag]?

        @inlinable
        public init(appSummary: AppSummary? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appSummary = appSummary
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appSummary = "appSummary"
            case serverGroups = "serverGroups"
            case tags = "tags"
        }
    }

    public struct CreateReplicationJobRequest: AWSEncodableShape {
        /// The description of the replication job.
        public let description: String?
        /// Indicates whether the replication job produces encrypted AMIs.
        public let encrypted: Bool?
        /// The time between consecutive replication runs, in hours.
        public let frequency: Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:   KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is true but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public let kmsKeyId: String?
        /// The license type to be used for the AMI created by a successful replication run.
        public let licenseType: LicenseType?
        /// The maximum number of SMS-created AMIs to retain. The oldest is deleted after the maximum number is reached and a new AMI is created.
        public let numberOfRecentAmisToKeep: Int?
        /// The name of the IAM role to be used by the Server Migration Service.
        public let roleName: String?
        /// Indicates whether to run the replication job one time.
        public let runOnce: Bool?
        /// The seed replication time.
        public let seedReplicationTime: Date
        /// The ID of the server.
        public let serverId: String

        @inlinable
        public init(description: String? = nil, encrypted: Bool? = nil, frequency: Int? = nil, kmsKeyId: String? = nil, licenseType: LicenseType? = nil, numberOfRecentAmisToKeep: Int? = nil, roleName: String? = nil, runOnce: Bool? = nil, seedReplicationTime: Date, serverId: String) {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.roleName = roleName
            self.runOnce = runOnce
            self.seedReplicationTime = seedReplicationTime
            self.serverId = serverId
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case encrypted = "encrypted"
            case frequency = "frequency"
            case kmsKeyId = "kmsKeyId"
            case licenseType = "licenseType"
            case numberOfRecentAmisToKeep = "numberOfRecentAmisToKeep"
            case roleName = "roleName"
            case runOnce = "runOnce"
            case seedReplicationTime = "seedReplicationTime"
            case serverId = "serverId"
        }
    }

    public struct CreateReplicationJobResponse: AWSDecodableShape {
        /// The unique identifier of the replication job.
        public let replicationJobId: String?

        @inlinable
        public init(replicationJobId: String? = nil) {
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationJobId = "replicationJobId"
        }
    }

    public struct DeleteAppLaunchConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        @inlinable
        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct DeleteAppLaunchConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAppReplicationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        @inlinable
        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct DeleteAppReplicationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAppRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?
        /// Indicates whether to stop all replication jobs corresponding to the servers in the application while deleting the application.
        public let forceStopAppReplication: Bool?
        /// Indicates whether to terminate the stack corresponding to the application while deleting the application.
        public let forceTerminateApp: Bool?

        @inlinable
        public init(appId: String? = nil, forceStopAppReplication: Bool? = nil, forceTerminateApp: Bool? = nil) {
            self.appId = appId
            self.forceStopAppReplication = forceStopAppReplication
            self.forceTerminateApp = forceTerminateApp
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case forceStopAppReplication = "forceStopAppReplication"
            case forceTerminateApp = "forceTerminateApp"
        }
    }

    public struct DeleteAppResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAppValidationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String

        @inlinable
        public init(appId: String) {
            self.appId = appId
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^app-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct DeleteAppValidationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReplicationJobRequest: AWSEncodableShape {
        /// The ID of the replication job.
        public let replicationJobId: String

        @inlinable
        public init(replicationJobId: String) {
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationJobId = "replicationJobId"
        }
    }

    public struct DeleteReplicationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteServerCatalogRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteServerCatalogResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateConnectorRequest: AWSEncodableShape {
        /// The ID of the connector.
        public let connectorId: String

        @inlinable
        public init(connectorId: String) {
            self.connectorId = connectorId
        }

        private enum CodingKeys: String, CodingKey {
            case connectorId = "connectorId"
        }
    }

    public struct DisassociateConnectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GenerateChangeSetRequest: AWSEncodableShape {
        /// The ID of the application associated with the change set.
        public let appId: String?
        /// The format for the change set.
        public let changesetFormat: OutputFormat?

        @inlinable
        public init(appId: String? = nil, changesetFormat: OutputFormat? = nil) {
            self.appId = appId
            self.changesetFormat = changesetFormat
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case changesetFormat = "changesetFormat"
        }
    }

    public struct GenerateChangeSetResponse: AWSDecodableShape {
        /// The location of the Amazon S3 object.
        public let s3Location: S3Location?

        @inlinable
        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct GenerateTemplateRequest: AWSEncodableShape {
        /// The ID of the application associated with the CloudFormation template.
        public let appId: String?
        /// The format for generating the CloudFormation template.
        public let templateFormat: OutputFormat?

        @inlinable
        public init(appId: String? = nil, templateFormat: OutputFormat? = nil) {
            self.appId = appId
            self.templateFormat = templateFormat
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case templateFormat = "templateFormat"
        }
    }

    public struct GenerateTemplateResponse: AWSDecodableShape {
        /// The location of the Amazon S3 object.
        public let s3Location: S3Location?

        @inlinable
        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct GetAppLaunchConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        @inlinable
        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct GetAppLaunchConfigurationResponse: AWSDecodableShape {
        /// The ID of the application.
        public let appId: String?
        /// Indicates whether the application is configured to launch automatically after replication is complete.
        public let autoLaunch: Bool?
        /// The name of the service role in the customer's account that CloudFormation uses to launch the application.
        public let roleName: String?
        /// The launch configurations for server groups in this application.
        public let serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]?

        @inlinable
        public init(appId: String? = nil, autoLaunch: Bool? = nil, roleName: String? = nil, serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]? = nil) {
            self.appId = appId
            self.autoLaunch = autoLaunch
            self.roleName = roleName
            self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case autoLaunch = "autoLaunch"
            case roleName = "roleName"
            case serverGroupLaunchConfigurations = "serverGroupLaunchConfigurations"
        }
    }

    public struct GetAppReplicationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        @inlinable
        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct GetAppReplicationConfigurationResponse: AWSDecodableShape {
        /// The replication configurations associated with server groups in this application.
        public let serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]?

        @inlinable
        public init(serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]? = nil) {
            self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case serverGroupReplicationConfigurations = "serverGroupReplicationConfigurations"
        }
    }

    public struct GetAppRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        @inlinable
        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct GetAppResponse: AWSDecodableShape {
        /// Information about the application.
        public let appSummary: AppSummary?
        /// The server groups that belong to the application.
        public let serverGroups: [ServerGroup]?
        /// The tags associated with the application.
        public let tags: [Tag]?

        @inlinable
        public init(appSummary: AppSummary? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appSummary = appSummary
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appSummary = "appSummary"
            case serverGroups = "serverGroups"
            case tags = "tags"
        }
    }

    public struct GetAppValidationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String

        @inlinable
        public init(appId: String) {
            self.appId = appId
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^app-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct GetAppValidationConfigurationResponse: AWSDecodableShape {
        /// The configuration for application validation.
        public let appValidationConfigurations: [AppValidationConfiguration]?
        /// The configuration for instance validation.
        public let serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]?

        @inlinable
        public init(appValidationConfigurations: [AppValidationConfiguration]? = nil, serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]? = nil) {
            self.appValidationConfigurations = appValidationConfigurations
            self.serverGroupValidationConfigurations = serverGroupValidationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case appValidationConfigurations = "appValidationConfigurations"
            case serverGroupValidationConfigurations = "serverGroupValidationConfigurations"
        }
    }

    public struct GetAppValidationOutputRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String

        @inlinable
        public init(appId: String) {
            self.appId = appId
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^app-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct GetAppValidationOutputResponse: AWSDecodableShape {
        /// The validation output.
        public let validationOutputList: [ValidationOutput]?

        @inlinable
        public init(validationOutputList: [ValidationOutput]? = nil) {
            self.validationOutputList = validationOutputList
        }

        private enum CodingKeys: String, CodingKey {
            case validationOutputList = "validationOutputList"
        }
    }

    public struct GetConnectorsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetConnectorsResponse: AWSDecodableShape {
        /// Information about the registered connectors.
        public let connectorList: [Connector]?
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(connectorList: [Connector]? = nil, nextToken: String? = nil) {
            self.connectorList = connectorList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorList = "connectorList"
            case nextToken = "nextToken"
        }
    }

    public struct GetReplicationJobsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The ID of the replication job.
        public let replicationJobId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, replicationJobId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case replicationJobId = "replicationJobId"
        }
    }

    public struct GetReplicationJobsResponse: AWSDecodableShape {
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the replication jobs.
        public let replicationJobList: [ReplicationJob]?

        @inlinable
        public init(nextToken: String? = nil, replicationJobList: [ReplicationJob]? = nil) {
            self.nextToken = nextToken
            self.replicationJobList = replicationJobList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case replicationJobList = "replicationJobList"
        }
    }

    public struct GetReplicationRunsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The ID of the replication job.
        public let replicationJobId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, replicationJobId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case replicationJobId = "replicationJobId"
        }
    }

    public struct GetReplicationRunsResponse: AWSDecodableShape {
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the replication job.
        public let replicationJob: ReplicationJob?
        /// Information about the replication runs.
        public let replicationRunList: [ReplicationRun]?

        @inlinable
        public init(nextToken: String? = nil, replicationJob: ReplicationJob? = nil, replicationRunList: [ReplicationRun]? = nil) {
            self.nextToken = nextToken
            self.replicationJob = replicationJob
            self.replicationRunList = replicationRunList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case replicationJob = "replicationJob"
            case replicationRunList = "replicationRunList"
        }
    }

    public struct GetServersRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The server addresses.
        public let vmServerAddressList: [VmServerAddress]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, vmServerAddressList: [VmServerAddress]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.vmServerAddressList = vmServerAddressList
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case vmServerAddressList = "vmServerAddressList"
        }
    }

    public struct GetServersResponse: AWSDecodableShape {
        /// The time when the server was last modified.
        public let lastModifiedOn: Date?
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The status of the server catalog.
        public let serverCatalogStatus: ServerCatalogStatus?
        /// Information about the servers.
        public let serverList: [Server]?

        @inlinable
        public init(lastModifiedOn: Date? = nil, nextToken: String? = nil, serverCatalogStatus: ServerCatalogStatus? = nil, serverList: [Server]? = nil) {
            self.lastModifiedOn = lastModifiedOn
            self.nextToken = nextToken
            self.serverCatalogStatus = serverCatalogStatus
            self.serverList = serverList
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedOn = "lastModifiedOn"
            case nextToken = "nextToken"
            case serverCatalogStatus = "serverCatalogStatus"
            case serverList = "serverList"
        }
    }

    public struct ImportAppCatalogRequest: AWSEncodableShape {
        /// The name of the service role. If you omit this parameter, we create a service-linked role for Migration Hub in your account. Otherwise, the role that you provide must have the policy and trust policy described in the Migration Hub User Guide.
        public let roleName: String?

        @inlinable
        public init(roleName: String? = nil) {
            self.roleName = roleName
        }

        private enum CodingKeys: String, CodingKey {
            case roleName = "roleName"
        }
    }

    public struct ImportAppCatalogResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ImportServerCatalogRequest: AWSEncodableShape {
        public init() {}
    }

    public struct ImportServerCatalogResponse: AWSDecodableShape {
        public init() {}
    }

    public struct LaunchAppRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        @inlinable
        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct LaunchAppResponse: AWSDecodableShape {
        public init() {}
    }

    public struct LaunchDetails: AWSDecodableShape {
        /// The latest time that this application was launched successfully.
        public let latestLaunchTime: Date?
        /// The ID of the latest stack launched for this application.
        public let stackId: String?
        /// The name of the latest stack launched for this application.
        public let stackName: String?

        @inlinable
        public init(latestLaunchTime: Date? = nil, stackId: String? = nil, stackName: String? = nil) {
            self.latestLaunchTime = latestLaunchTime
            self.stackId = stackId
            self.stackName = stackName
        }

        private enum CodingKeys: String, CodingKey {
            case latestLaunchTime = "latestLaunchTime"
            case stackId = "stackId"
            case stackName = "stackName"
        }
    }

    public struct ListAppsRequest: AWSEncodableShape {
        /// The unique application IDs.
        public let appIds: [String]?
        /// The maximum number of results to return in a single call. The default value is 100. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(appIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appIds = appIds
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case appIds = "appIds"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListAppsResponse: AWSDecodableShape {
        /// The application summaries.
        public let apps: [AppSummary]?
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(apps: [AppSummary]? = nil, nextToken: String? = nil) {
            self.apps = apps
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case apps = "apps"
            case nextToken = "nextToken"
        }
    }

    public struct NotificationContext: AWSEncodableShape {
        /// The status of the validation.
        public let status: ValidationStatus?
        /// The status message.
        public let statusMessage: String?
        /// The ID of the validation.
        public let validationId: String?

        @inlinable
        public init(status: ValidationStatus? = nil, statusMessage: String? = nil, validationId: String? = nil) {
            self.status = status
            self.statusMessage = statusMessage
            self.validationId = validationId
        }

        public func validate(name: String) throws {
            try self.validate(self.statusMessage, name: "statusMessage", parent: name, max: 2500)
            try self.validate(self.validationId, name: "validationId", parent: name, pattern: "^val-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case statusMessage = "statusMessage"
            case validationId = "validationId"
        }
    }

    public struct NotifyAppValidationOutputRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String
        /// The notification information.
        public let notificationContext: NotificationContext?

        @inlinable
        public init(appId: String, notificationContext: NotificationContext? = nil) {
            self.appId = appId
            self.notificationContext = notificationContext
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^app-[0-9a-f]{17}$")
            try self.notificationContext?.validate(name: "\(name).notificationContext")
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case notificationContext = "notificationContext"
        }
    }

    public struct NotifyAppValidationOutputResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutAppLaunchConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?
        /// Indicates whether the application is configured to launch automatically after replication is complete.
        public let autoLaunch: Bool?
        /// The name of service role in the customer's account that CloudFormation uses to launch the application.
        public let roleName: String?
        /// Information about the launch configurations for server groups in the application.
        public let serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]?

        @inlinable
        public init(appId: String? = nil, autoLaunch: Bool? = nil, roleName: String? = nil, serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]? = nil) {
            self.appId = appId
            self.autoLaunch = autoLaunch
            self.roleName = roleName
            self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
        }

        public func validate(name: String) throws {
            try self.serverGroupLaunchConfigurations?.forEach {
                try $0.validate(name: "\(name).serverGroupLaunchConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case autoLaunch = "autoLaunch"
            case roleName = "roleName"
            case serverGroupLaunchConfigurations = "serverGroupLaunchConfigurations"
        }
    }

    public struct PutAppLaunchConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutAppReplicationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?
        /// Information about the replication configurations for server groups in the application.
        public let serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]?

        @inlinable
        public init(appId: String? = nil, serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]? = nil) {
            self.appId = appId
            self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case serverGroupReplicationConfigurations = "serverGroupReplicationConfigurations"
        }
    }

    public struct PutAppReplicationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutAppValidationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String
        /// The configuration for application validation.
        public let appValidationConfigurations: [AppValidationConfiguration]?
        /// The configuration for instance validation.
        public let serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]?

        @inlinable
        public init(appId: String, appValidationConfigurations: [AppValidationConfiguration]? = nil, serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]? = nil) {
            self.appId = appId
            self.appValidationConfigurations = appValidationConfigurations
            self.serverGroupValidationConfigurations = serverGroupValidationConfigurations
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^app-[0-9a-f]{17}$")
            try self.appValidationConfigurations?.forEach {
                try $0.validate(name: "\(name).appValidationConfigurations[]")
            }
            try self.serverGroupValidationConfigurations?.forEach {
                try $0.validate(name: "\(name).serverGroupValidationConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case appValidationConfigurations = "appValidationConfigurations"
            case serverGroupValidationConfigurations = "serverGroupValidationConfigurations"
        }
    }

    public struct PutAppValidationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ReplicationJob: AWSDecodableShape {
        /// The description of the replication job.
        public let description: String?
        /// Indicates whether the replication job should produce encrypted AMIs.
        public let encrypted: Bool?
        /// The time between consecutive replication runs, in hours.
        public let frequency: Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:    KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public let kmsKeyId: String?
        /// The ID of the latest Amazon Machine Image (AMI).
        public let latestAmiId: String?
        /// The license type to be used for the AMI created by a successful replication run.
        public let licenseType: LicenseType?
        /// The start time of the next replication run.
        public let nextReplicationRunStartTime: Date?
        /// The number of recent AMIs to keep in the customer's account for a replication job. By default, the value is set to zero, meaning that all AMIs are kept.
        public let numberOfRecentAmisToKeep: Int?
        /// The ID of the replication job.
        public let replicationJobId: String?
        /// Information about the replication runs.
        public let replicationRunList: [ReplicationRun]?
        /// The name of the IAM role to be used by Server Migration Service.
        public let roleName: String?
        /// Indicates whether to run the replication job one time.
        public let runOnce: Bool?
        /// The seed replication time.
        public let seedReplicationTime: Date?
        /// The ID of the server.
        public let serverId: String?
        /// The type of server.
        public let serverType: ServerType?
        /// The state of the replication job.
        public let state: ReplicationJobState?
        /// The description of the current status of the replication job.
        public let statusMessage: String?
        /// Information about the VM server.
        public let vmServer: VmServer?

        @inlinable
        public init(description: String? = nil, encrypted: Bool? = nil, frequency: Int? = nil, kmsKeyId: String? = nil, latestAmiId: String? = nil, licenseType: LicenseType? = nil, nextReplicationRunStartTime: Date? = nil, numberOfRecentAmisToKeep: Int? = nil, replicationJobId: String? = nil, replicationRunList: [ReplicationRun]? = nil, roleName: String? = nil, runOnce: Bool? = nil, seedReplicationTime: Date? = nil, serverId: String? = nil, serverType: ServerType? = nil, state: ReplicationJobState? = nil, statusMessage: String? = nil, vmServer: VmServer? = nil) {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.latestAmiId = latestAmiId
            self.licenseType = licenseType
            self.nextReplicationRunStartTime = nextReplicationRunStartTime
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.replicationJobId = replicationJobId
            self.replicationRunList = replicationRunList
            self.roleName = roleName
            self.runOnce = runOnce
            self.seedReplicationTime = seedReplicationTime
            self.serverId = serverId
            self.serverType = serverType
            self.state = state
            self.statusMessage = statusMessage
            self.vmServer = vmServer
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case encrypted = "encrypted"
            case frequency = "frequency"
            case kmsKeyId = "kmsKeyId"
            case latestAmiId = "latestAmiId"
            case licenseType = "licenseType"
            case nextReplicationRunStartTime = "nextReplicationRunStartTime"
            case numberOfRecentAmisToKeep = "numberOfRecentAmisToKeep"
            case replicationJobId = "replicationJobId"
            case replicationRunList = "replicationRunList"
            case roleName = "roleName"
            case runOnce = "runOnce"
            case seedReplicationTime = "seedReplicationTime"
            case serverId = "serverId"
            case serverType = "serverType"
            case state = "state"
            case statusMessage = "statusMessage"
            case vmServer = "vmServer"
        }
    }

    public struct ReplicationRun: AWSDecodableShape {
        /// The ID of the Amazon Machine Image (AMI) from the replication run.
        public let amiId: String?
        /// The completion time of the last replication run.
        public let completedTime: Date?
        /// The description of the replication run.
        public let description: String?
        /// Indicates whether the replication run should produce an encrypted AMI.
        public let encrypted: Bool?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:   KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is true but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public let kmsKeyId: String?
        /// The ID of the replication run.
        public let replicationRunId: String?
        /// The start time of the next replication run.
        public let scheduledStartTime: Date?
        /// Details about the current stage of the replication run.
        public let stageDetails: ReplicationRunStageDetails?
        /// The state of the replication run.
        public let state: ReplicationRunState?
        /// The description of the current status of the replication job.
        public let statusMessage: String?
        /// The type of replication run.
        public let type: ReplicationRunType?

        @inlinable
        public init(amiId: String? = nil, completedTime: Date? = nil, description: String? = nil, encrypted: Bool? = nil, kmsKeyId: String? = nil, replicationRunId: String? = nil, scheduledStartTime: Date? = nil, stageDetails: ReplicationRunStageDetails? = nil, state: ReplicationRunState? = nil, statusMessage: String? = nil, type: ReplicationRunType? = nil) {
            self.amiId = amiId
            self.completedTime = completedTime
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.replicationRunId = replicationRunId
            self.scheduledStartTime = scheduledStartTime
            self.stageDetails = stageDetails
            self.state = state
            self.statusMessage = statusMessage
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case amiId = "amiId"
            case completedTime = "completedTime"
            case description = "description"
            case encrypted = "encrypted"
            case kmsKeyId = "kmsKeyId"
            case replicationRunId = "replicationRunId"
            case scheduledStartTime = "scheduledStartTime"
            case stageDetails = "stageDetails"
            case state = "state"
            case statusMessage = "statusMessage"
            case type = "type"
        }
    }

    public struct ReplicationRunStageDetails: AWSDecodableShape {
        /// The current stage of a replication run.
        public let stage: String?
        /// The progress of the current stage of a replication run.
        public let stageProgress: String?

        @inlinable
        public init(stage: String? = nil, stageProgress: String? = nil) {
            self.stage = stage
            self.stageProgress = stageProgress
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "stage"
            case stageProgress = "stageProgress"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket name.
        public let bucket: String?
        /// The Amazon S3 bucket key.
        public let key: String?

        @inlinable
        public init(bucket: String? = nil, key: String? = nil) {
            self.bucket = bucket
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.key, name: "key", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case key = "key"
        }
    }

    public struct SSMOutput: AWSDecodableShape {
        public let s3Location: S3Location?

        @inlinable
        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct SSMValidationParameters: AWSEncodableShape & AWSDecodableShape {
        /// The command to run the validation script.
        public let command: String?
        /// The timeout interval, in seconds.
        public let executionTimeoutSeconds: Int?
        /// The ID of the instance. The instance must have the following tag: UserForSMSApplicationValidation=true.
        public let instanceId: String?
        /// The name of the S3 bucket for output.
        public let outputS3BucketName: String?
        /// The type of validation script.
        public let scriptType: ScriptType?
        /// The location of the validation script.
        public let source: Source?

        @inlinable
        public init(command: String? = nil, executionTimeoutSeconds: Int? = nil, instanceId: String? = nil, outputS3BucketName: String? = nil, scriptType: ScriptType? = nil, source: Source? = nil) {
            self.command = command
            self.executionTimeoutSeconds = executionTimeoutSeconds
            self.instanceId = instanceId
            self.outputS3BucketName = outputS3BucketName
            self.scriptType = scriptType
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.command, name: "command", parent: name, max: 64000)
            try self.validate(self.command, name: "command", parent: name, min: 1)
            try self.validate(self.executionTimeoutSeconds, name: "executionTimeoutSeconds", parent: name, max: 28800)
            try self.validate(self.executionTimeoutSeconds, name: "executionTimeoutSeconds", parent: name, min: 60)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^(^i-(\\w{8}|\\w{17})$)|(^mi-\\w{17}$)$")
            try self.source?.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case command = "command"
            case executionTimeoutSeconds = "executionTimeoutSeconds"
            case instanceId = "instanceId"
            case outputS3BucketName = "outputS3BucketName"
            case scriptType = "scriptType"
            case source = "source"
        }
    }

    public struct Server: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the replication job.
        public let replicationJobId: String?
        /// Indicates whether the replication job is deleted or failed.
        public let replicationJobTerminated: Bool?
        /// The ID of the server.
        public let serverId: String?
        /// The type of server.
        public let serverType: ServerType?
        /// Information about the VM server.
        public let vmServer: VmServer?

        @inlinable
        public init(replicationJobId: String? = nil, replicationJobTerminated: Bool? = nil, serverId: String? = nil, serverType: ServerType? = nil, vmServer: VmServer? = nil) {
            self.replicationJobId = replicationJobId
            self.replicationJobTerminated = replicationJobTerminated
            self.serverId = serverId
            self.serverType = serverType
            self.vmServer = vmServer
        }

        private enum CodingKeys: String, CodingKey {
            case replicationJobId = "replicationJobId"
            case replicationJobTerminated = "replicationJobTerminated"
            case serverId = "serverId"
            case serverType = "serverType"
            case vmServer = "vmServer"
        }
    }

    public struct ServerGroup: AWSEncodableShape & AWSDecodableShape {
        /// The name of a server group.
        public let name: String?
        /// The ID of a server group.
        public let serverGroupId: String?
        /// The servers that belong to a server group.
        public let serverList: [Server]?

        @inlinable
        public init(name: String? = nil, serverGroupId: String? = nil, serverList: [Server]? = nil) {
            self.name = name
            self.serverGroupId = serverGroupId
            self.serverList = serverList
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case serverGroupId = "serverGroupId"
            case serverList = "serverList"
        }
    }

    public struct ServerGroupLaunchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The launch order of servers in the server group.
        public let launchOrder: Int?
        /// The ID of the server group with which the launch configuration is associated.
        public let serverGroupId: String?
        /// The launch configuration for servers in the server group.
        public let serverLaunchConfigurations: [ServerLaunchConfiguration]?

        @inlinable
        public init(launchOrder: Int? = nil, serverGroupId: String? = nil, serverLaunchConfigurations: [ServerLaunchConfiguration]? = nil) {
            self.launchOrder = launchOrder
            self.serverGroupId = serverGroupId
            self.serverLaunchConfigurations = serverLaunchConfigurations
        }

        public func validate(name: String) throws {
            try self.serverLaunchConfigurations?.forEach {
                try $0.validate(name: "\(name).serverLaunchConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case launchOrder = "launchOrder"
            case serverGroupId = "serverGroupId"
            case serverLaunchConfigurations = "serverLaunchConfigurations"
        }
    }

    public struct ServerGroupReplicationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the server group with which this replication configuration is associated.
        public let serverGroupId: String?
        /// The replication configuration for servers in the server group.
        public let serverReplicationConfigurations: [ServerReplicationConfiguration]?

        @inlinable
        public init(serverGroupId: String? = nil, serverReplicationConfigurations: [ServerReplicationConfiguration]? = nil) {
            self.serverGroupId = serverGroupId
            self.serverReplicationConfigurations = serverReplicationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case serverGroupId = "serverGroupId"
            case serverReplicationConfigurations = "serverReplicationConfigurations"
        }
    }

    public struct ServerGroupValidationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the server group.
        public let serverGroupId: String?
        /// The validation configuration.
        public let serverValidationConfigurations: [ServerValidationConfiguration]?

        @inlinable
        public init(serverGroupId: String? = nil, serverValidationConfigurations: [ServerValidationConfiguration]? = nil) {
            self.serverGroupId = serverGroupId
            self.serverValidationConfigurations = serverValidationConfigurations
        }

        public func validate(name: String) throws {
            try self.serverValidationConfigurations?.forEach {
                try $0.validate(name: "\(name).serverValidationConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case serverGroupId = "serverGroupId"
            case serverValidationConfigurations = "serverValidationConfigurations"
        }
    }

    public struct ServerLaunchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether a publicly accessible IP address is created when launching the server.
        public let associatePublicIpAddress: Bool?
        public let configureScript: S3Location?
        /// The type of configuration script.
        public let configureScriptType: ScriptType?
        /// The name of the Amazon EC2 SSH key to be used for connecting to the launched server.
        public let ec2KeyName: String?
        /// The name of the IAM instance profile.
        public let iamInstanceProfileName: String?
        /// The instance type to use when launching the server.
        public let instanceType: String?
        /// The logical ID of the server in the CloudFormation template.
        public let logicalId: String?
        /// The ID of the security group that applies to the launched server.
        public let securityGroup: String?
        /// The ID of the server with which the launch configuration is associated.
        public let server: Server?
        /// The ID of the subnet the server should be launched into.
        public let subnet: String?
        /// Location of the user-data script to be executed when launching the server.
        public let userData: UserData?
        /// The ID of the VPC into which the server should be launched.
        public let vpc: String?

        @inlinable
        public init(associatePublicIpAddress: Bool? = nil, configureScript: S3Location? = nil, configureScriptType: ScriptType? = nil, ec2KeyName: String? = nil, iamInstanceProfileName: String? = nil, instanceType: String? = nil, logicalId: String? = nil, securityGroup: String? = nil, server: Server? = nil, subnet: String? = nil, userData: UserData? = nil, vpc: String? = nil) {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.configureScript = configureScript
            self.configureScriptType = configureScriptType
            self.ec2KeyName = ec2KeyName
            self.iamInstanceProfileName = iamInstanceProfileName
            self.instanceType = instanceType
            self.logicalId = logicalId
            self.securityGroup = securityGroup
            self.server = server
            self.subnet = subnet
            self.userData = userData
            self.vpc = vpc
        }

        public func validate(name: String) throws {
            try self.configureScript?.validate(name: "\(name).configureScript")
            try self.userData?.validate(name: "\(name).userData")
        }

        private enum CodingKeys: String, CodingKey {
            case associatePublicIpAddress = "associatePublicIpAddress"
            case configureScript = "configureScript"
            case configureScriptType = "configureScriptType"
            case ec2KeyName = "ec2KeyName"
            case iamInstanceProfileName = "iamInstanceProfileName"
            case instanceType = "instanceType"
            case logicalId = "logicalId"
            case securityGroup = "securityGroup"
            case server = "server"
            case subnet = "subnet"
            case userData = "userData"
            case vpc = "vpc"
        }
    }

    public struct ServerReplicationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the server with which this replication configuration is associated.
        public let server: Server?
        /// The parameters for replicating the server.
        public let serverReplicationParameters: ServerReplicationParameters?

        @inlinable
        public init(server: Server? = nil, serverReplicationParameters: ServerReplicationParameters? = nil) {
            self.server = server
            self.serverReplicationParameters = serverReplicationParameters
        }

        private enum CodingKeys: String, CodingKey {
            case server = "server"
            case serverReplicationParameters = "serverReplicationParameters"
        }
    }

    public struct ServerReplicationParameters: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the replication job produces encrypted AMIs.
        public let encrypted: Bool?
        /// The frequency of creating replication jobs for the server.
        public let frequency: Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:   KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public let kmsKeyId: String?
        /// The license type for creating a replication job for the server.
        public let licenseType: LicenseType?
        /// The number of recent AMIs to keep when creating a replication job for this server.
        public let numberOfRecentAmisToKeep: Int?
        /// Indicates whether to run the replication job one time.
        public let runOnce: Bool?
        /// The seed time for creating a replication job for the server.
        public let seedTime: Date?

        @inlinable
        public init(encrypted: Bool? = nil, frequency: Int? = nil, kmsKeyId: String? = nil, licenseType: LicenseType? = nil, numberOfRecentAmisToKeep: Int? = nil, runOnce: Bool? = nil, seedTime: Date? = nil) {
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.runOnce = runOnce
            self.seedTime = seedTime
        }

        private enum CodingKeys: String, CodingKey {
            case encrypted = "encrypted"
            case frequency = "frequency"
            case kmsKeyId = "kmsKeyId"
            case licenseType = "licenseType"
            case numberOfRecentAmisToKeep = "numberOfRecentAmisToKeep"
            case runOnce = "runOnce"
            case seedTime = "seedTime"
        }
    }

    public struct ServerValidationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the configuration.
        public let name: String?
        public let server: Server?
        /// The validation strategy.
        public let serverValidationStrategy: ServerValidationStrategy?
        /// The validation parameters.
        public let userDataValidationParameters: UserDataValidationParameters?
        /// The ID of the validation.
        public let validationId: String?

        @inlinable
        public init(name: String? = nil, server: Server? = nil, serverValidationStrategy: ServerValidationStrategy? = nil, userDataValidationParameters: UserDataValidationParameters? = nil, validationId: String? = nil) {
            self.name = name
            self.server = server
            self.serverValidationStrategy = serverValidationStrategy
            self.userDataValidationParameters = userDataValidationParameters
            self.validationId = validationId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S]+$")
            try self.userDataValidationParameters?.validate(name: "\(name).userDataValidationParameters")
            try self.validate(self.validationId, name: "validationId", parent: name, pattern: "^val-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case server = "server"
            case serverValidationStrategy = "serverValidationStrategy"
            case userDataValidationParameters = "userDataValidationParameters"
            case validationId = "validationId"
        }
    }

    public struct ServerValidationOutput: AWSDecodableShape {
        public let server: Server?

        @inlinable
        public init(server: Server? = nil) {
            self.server = server
        }

        private enum CodingKeys: String, CodingKey {
            case server = "server"
        }
    }

    public struct Source: AWSEncodableShape & AWSDecodableShape {
        public let s3Location: S3Location?

        @inlinable
        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct StartAppReplicationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        @inlinable
        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct StartAppReplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartOnDemandAppReplicationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String
        /// The description of the replication run.
        public let description: String?

        @inlinable
        public init(appId: String, description: String? = nil) {
            self.appId = appId
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case description = "description"
        }
    }

    public struct StartOnDemandAppReplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartOnDemandReplicationRunRequest: AWSEncodableShape {
        /// The description of the replication run.
        public let description: String?
        /// The ID of the replication job.
        public let replicationJobId: String

        @inlinable
        public init(description: String? = nil, replicationJobId: String) {
            self.description = description
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case replicationJobId = "replicationJobId"
        }
    }

    public struct StartOnDemandReplicationRunResponse: AWSDecodableShape {
        /// The ID of the replication run.
        public let replicationRunId: String?

        @inlinable
        public init(replicationRunId: String? = nil) {
            self.replicationRunId = replicationRunId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationRunId = "replicationRunId"
        }
    }

    public struct StopAppReplicationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        @inlinable
        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct StopAppReplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key.
        public let key: String?
        /// The tag value.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TerminateAppRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        @inlinable
        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
        }
    }

    public struct TerminateAppResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAppRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?
        /// The new description of the application.
        public let description: String?
        /// The new name of the application.
        public let name: String?
        /// The name of the service role in the customer's account used by Server Migration Service.
        public let roleName: String?
        /// The server groups in the application to update.
        public let serverGroups: [ServerGroup]?
        /// The tags to associate with the application.
        public let tags: [Tag]?

        @inlinable
        public init(appId: String? = nil, description: String? = nil, name: String? = nil, roleName: String? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appId = appId
            self.description = description
            self.name = name
            self.roleName = roleName
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appId = "appId"
            case description = "description"
            case name = "name"
            case roleName = "roleName"
            case serverGroups = "serverGroups"
            case tags = "tags"
        }
    }

    public struct UpdateAppResponse: AWSDecodableShape {
        /// A summary description of the application.
        public let appSummary: AppSummary?
        /// The updated server groups in the application.
        public let serverGroups: [ServerGroup]?
        /// The tags associated with the application.
        public let tags: [Tag]?

        @inlinable
        public init(appSummary: AppSummary? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appSummary = appSummary
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appSummary = "appSummary"
            case serverGroups = "serverGroups"
            case tags = "tags"
        }
    }

    public struct UpdateReplicationJobRequest: AWSEncodableShape {
        /// The description of the replication job.
        public let description: String?
        /// When true, the replication job produces encrypted AMIs. For more information, KmsKeyId.
        public let encrypted: Bool?
        /// The time between consecutive replication runs, in hours.
        public let frequency: Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:   KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public let kmsKeyId: String?
        /// The license type to be used for the AMI created by a successful replication run.
        public let licenseType: LicenseType?
        /// The start time of the next replication run.
        public let nextReplicationRunStartTime: Date?
        /// The maximum number of SMS-created AMIs to retain. The oldest is deleted after the maximum number is reached and a new AMI is created.
        public let numberOfRecentAmisToKeep: Int?
        /// The ID of the replication job.
        public let replicationJobId: String
        /// The name of the IAM role to be used by Server Migration Service.
        public let roleName: String?

        @inlinable
        public init(description: String? = nil, encrypted: Bool? = nil, frequency: Int? = nil, kmsKeyId: String? = nil, licenseType: LicenseType? = nil, nextReplicationRunStartTime: Date? = nil, numberOfRecentAmisToKeep: Int? = nil, replicationJobId: String, roleName: String? = nil) {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.nextReplicationRunStartTime = nextReplicationRunStartTime
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.replicationJobId = replicationJobId
            self.roleName = roleName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case encrypted = "encrypted"
            case frequency = "frequency"
            case kmsKeyId = "kmsKeyId"
            case licenseType = "licenseType"
            case nextReplicationRunStartTime = "nextReplicationRunStartTime"
            case numberOfRecentAmisToKeep = "numberOfRecentAmisToKeep"
            case replicationJobId = "replicationJobId"
            case roleName = "roleName"
        }
    }

    public struct UpdateReplicationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserData: AWSEncodableShape & AWSDecodableShape {
        /// Amazon S3 location of the user-data script.
        public let s3Location: S3Location?

        @inlinable
        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "s3Location"
        }
    }

    public struct UserDataValidationParameters: AWSEncodableShape & AWSDecodableShape {
        /// The type of validation script.
        public let scriptType: ScriptType?
        /// The location of the validation script.
        public let source: Source?

        @inlinable
        public init(scriptType: ScriptType? = nil, source: Source? = nil) {
            self.scriptType = scriptType
            self.source = source
        }

        public func validate(name: String) throws {
            try self.source?.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case scriptType = "scriptType"
            case source = "source"
        }
    }

    public struct ValidationOutput: AWSDecodableShape {
        /// The output from validating an application.
        public let appValidationOutput: AppValidationOutput?
        /// The latest time that the validation was performed.
        public let latestValidationTime: Date?
        /// The name of the validation.
        public let name: String?
        /// The output from validation an instance.
        public let serverValidationOutput: ServerValidationOutput?
        /// The status of the validation.
        public let status: ValidationStatus?
        /// The status message.
        public let statusMessage: String?
        /// The ID of the validation.
        public let validationId: String?

        @inlinable
        public init(appValidationOutput: AppValidationOutput? = nil, latestValidationTime: Date? = nil, name: String? = nil, serverValidationOutput: ServerValidationOutput? = nil, status: ValidationStatus? = nil, statusMessage: String? = nil, validationId: String? = nil) {
            self.appValidationOutput = appValidationOutput
            self.latestValidationTime = latestValidationTime
            self.name = name
            self.serverValidationOutput = serverValidationOutput
            self.status = status
            self.statusMessage = statusMessage
            self.validationId = validationId
        }

        private enum CodingKeys: String, CodingKey {
            case appValidationOutput = "appValidationOutput"
            case latestValidationTime = "latestValidationTime"
            case name = "name"
            case serverValidationOutput = "serverValidationOutput"
            case status = "status"
            case statusMessage = "statusMessage"
            case validationId = "validationId"
        }
    }

    public struct VmServer: AWSEncodableShape & AWSDecodableShape {
        /// The name of the VM manager.
        public let vmManagerName: String?
        /// The type of VM management product.
        public let vmManagerType: VmManagerType?
        /// The name of the VM.
        public let vmName: String?
        /// The VM folder path in the vCenter Server virtual machine inventory tree.
        public let vmPath: String?
        /// The VM server location.
        public let vmServerAddress: VmServerAddress?

        @inlinable
        public init(vmManagerName: String? = nil, vmManagerType: VmManagerType? = nil, vmName: String? = nil, vmPath: String? = nil, vmServerAddress: VmServerAddress? = nil) {
            self.vmManagerName = vmManagerName
            self.vmManagerType = vmManagerType
            self.vmName = vmName
            self.vmPath = vmPath
            self.vmServerAddress = vmServerAddress
        }

        private enum CodingKeys: String, CodingKey {
            case vmManagerName = "vmManagerName"
            case vmManagerType = "vmManagerType"
            case vmName = "vmName"
            case vmPath = "vmPath"
            case vmServerAddress = "vmServerAddress"
        }
    }

    public struct VmServerAddress: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the VM.
        public let vmId: String?
        /// The ID of the VM manager.
        public let vmManagerId: String?

        @inlinable
        public init(vmId: String? = nil, vmManagerId: String? = nil) {
            self.vmId = vmId
            self.vmManagerId = vmManagerId
        }

        private enum CodingKeys: String, CodingKey {
            case vmId = "vmId"
            case vmManagerId = "vmManagerId"
        }
    }
}

// MARK: - Errors

/// Error enum for SMS
public struct SMSErrorType: AWSErrorType {
    enum Code: String {
        case dryRunOperationException = "DryRunOperationException"
        case internalError = "InternalError"
        case invalidParameterException = "InvalidParameterException"
        case missingRequiredParameterException = "MissingRequiredParameterException"
        case noConnectorsAvailableException = "NoConnectorsAvailableException"
        case operationNotPermittedException = "OperationNotPermittedException"
        case replicationJobAlreadyExistsException = "ReplicationJobAlreadyExistsException"
        case replicationJobNotFoundException = "ReplicationJobNotFoundException"
        case replicationRunLimitExceededException = "ReplicationRunLimitExceededException"
        case serverCannotBeReplicatedException = "ServerCannotBeReplicatedException"
        case temporarilyUnavailableException = "TemporarilyUnavailableException"
        case unauthorizedOperationException = "UnauthorizedOperationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SMS
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The user has the required permissions, so the request would have succeeded,  but a dry run was performed.
    public static var dryRunOperationException: Self { .init(.dryRunOperationException) }
    /// An internal error occurred.
    public static var internalError: Self { .init(.internalError) }
    /// A specified parameter is not valid.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// A required parameter is missing.
    public static var missingRequiredParameterException: Self { .init(.missingRequiredParameterException) }
    /// There are no connectors available.
    public static var noConnectorsAvailableException: Self { .init(.noConnectorsAvailableException) }
    /// This operation is not allowed.
    public static var operationNotPermittedException: Self { .init(.operationNotPermittedException) }
    /// The specified replication job already exists.
    public static var replicationJobAlreadyExistsException: Self { .init(.replicationJobAlreadyExistsException) }
    /// The specified replication job does not exist.
    public static var replicationJobNotFoundException: Self { .init(.replicationJobNotFoundException) }
    /// You have exceeded the number of on-demand replication runs you can request in a 24-hour period.
    public static var replicationRunLimitExceededException: Self { .init(.replicationRunLimitExceededException) }
    /// The specified server cannot be replicated.
    public static var serverCannotBeReplicatedException: Self { .init(.serverCannotBeReplicatedException) }
    /// The service is temporarily unavailable.
    public static var temporarilyUnavailableException: Self { .init(.temporarilyUnavailableException) }
    /// You lack permissions needed to perform this operation. Check your IAM policies, and ensure that you are using the correct access keys.
    public static var unauthorizedOperationException: Self { .init(.unauthorizedOperationException) }
}

extension SMSErrorType: Equatable {
    public static func == (lhs: SMSErrorType, rhs: SMSErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SMSErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
