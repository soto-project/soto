//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS SMS service.
///
///   Product update  We recommend Amazon Web Services Application Migration Service (Amazon Web Services MGN) as the primary migration service for lift-and-shift migrations. If Amazon Web Services MGN is unavailable in a specific Amazon Web Services Region, you can use the Server Migration Service APIs through March 2023.  Server Migration Service (Server Migration Service) makes it easier and faster for you to migrate your on-premises workloads to Amazon Web Services. To learn more about Server Migration Service, see the following  resources:    Server Migration Service product page     Server Migration Service User Guide
public struct SMS: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the SMS client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "AWSServerMigrationService_V2016_10_24",
            serviceName: "SMS",
            serviceIdentifier: "sms",
            serviceProtocol: .json(version: "1.1"),
            apiVersion: "2016-10-24",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: SMSErrorType.self,
            xmlNamespace: "http://ec2.amazon.com/servermigration/2016-10-24/",
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-gov-west-1": "sms-fips.us-gov-west-1.amazonaws.com",
            "us-west-2": "sms-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Creates an application. An application consists of one or more server groups. Each server group contain one or more servers.
    @Sendable
    @inlinable
    public func createApp(_ input: CreateAppRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAppResponse {
        try await self.client.execute(
            operation: "CreateApp", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an application. An application consists of one or more server groups. Each server group contain one or more servers.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier that you provide to ensure the idempotency of application creation.
    ///   - description: The description of the new application
    ///   - name: The name of the new application.
    ///   - roleName: The name of the service role in the customer's account to be used by Server Migration Service.
    ///   - serverGroups: The server groups to include in the application.
    ///   - tags: The tags to be associated with the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func createApp(
        clientToken: String? = nil,
        description: String? = nil,
        name: String? = nil,
        roleName: String? = nil,
        serverGroups: [ServerGroup]? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAppResponse {
        let input = CreateAppRequest(
            clientToken: clientToken, 
            description: description, 
            name: name, 
            roleName: roleName, 
            serverGroups: serverGroups, 
            tags: tags
        )
        return try await self.createApp(input, logger: logger)
    }

    /// Creates a replication job. The replication job schedules periodic replication runs to replicate your server to Amazon Web Services. Each replication run creates an Amazon Machine Image (AMI).
    @Sendable
    @inlinable
    public func createReplicationJob(_ input: CreateReplicationJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateReplicationJobResponse {
        try await self.client.execute(
            operation: "CreateReplicationJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a replication job. The replication job schedules periodic replication runs to replicate your server to Amazon Web Services. Each replication run creates an Amazon Machine Image (AMI).
    ///
    /// Parameters:
    ///   - description: The description of the replication job.
    ///   - encrypted: Indicates whether the replication job produces encrypted AMIs.
    ///   - frequency: The time between consecutive replication runs, in hours.
    ///   - kmsKeyId: The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:   KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is true but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
    ///   - licenseType: The license type to be used for the AMI created by a successful replication run.
    ///   - numberOfRecentAmisToKeep: The maximum number of SMS-created AMIs to retain. The oldest is deleted after the maximum number is reached and a new AMI is created.
    ///   - roleName: The name of the IAM role to be used by the Server Migration Service.
    ///   - runOnce: Indicates whether to run the replication job one time.
    ///   - seedReplicationTime: The seed replication time.
    ///   - serverId: The ID of the server.
    ///   - logger: Logger use during operation
    @inlinable
    public func createReplicationJob(
        description: String? = nil,
        encrypted: Bool? = nil,
        frequency: Int? = nil,
        kmsKeyId: String? = nil,
        licenseType: LicenseType? = nil,
        numberOfRecentAmisToKeep: Int? = nil,
        roleName: String? = nil,
        runOnce: Bool? = nil,
        seedReplicationTime: Date,
        serverId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateReplicationJobResponse {
        let input = CreateReplicationJobRequest(
            description: description, 
            encrypted: encrypted, 
            frequency: frequency, 
            kmsKeyId: kmsKeyId, 
            licenseType: licenseType, 
            numberOfRecentAmisToKeep: numberOfRecentAmisToKeep, 
            roleName: roleName, 
            runOnce: runOnce, 
            seedReplicationTime: seedReplicationTime, 
            serverId: serverId
        )
        return try await self.createReplicationJob(input, logger: logger)
    }

    /// Deletes the specified application. Optionally deletes the launched stack associated with the application and all Server Migration Service replication jobs for servers in the application.
    @Sendable
    @inlinable
    public func deleteApp(_ input: DeleteAppRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAppResponse {
        try await self.client.execute(
            operation: "DeleteApp", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified application. Optionally deletes the launched stack associated with the application and all Server Migration Service replication jobs for servers in the application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - forceStopAppReplication: Indicates whether to stop all replication jobs corresponding to the servers in the application while deleting the application.
    ///   - forceTerminateApp: Indicates whether to terminate the stack corresponding to the application while deleting the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteApp(
        appId: String? = nil,
        forceStopAppReplication: Bool? = nil,
        forceTerminateApp: Bool? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAppResponse {
        let input = DeleteAppRequest(
            appId: appId, 
            forceStopAppReplication: forceStopAppReplication, 
            forceTerminateApp: forceTerminateApp
        )
        return try await self.deleteApp(input, logger: logger)
    }

    /// Deletes the launch configuration for the specified application.
    @Sendable
    @inlinable
    public func deleteAppLaunchConfiguration(_ input: DeleteAppLaunchConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAppLaunchConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteAppLaunchConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the launch configuration for the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAppLaunchConfiguration(
        appId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAppLaunchConfigurationResponse {
        let input = DeleteAppLaunchConfigurationRequest(
            appId: appId
        )
        return try await self.deleteAppLaunchConfiguration(input, logger: logger)
    }

    /// Deletes the replication configuration for the specified application.
    @Sendable
    @inlinable
    public func deleteAppReplicationConfiguration(_ input: DeleteAppReplicationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAppReplicationConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteAppReplicationConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the replication configuration for the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAppReplicationConfiguration(
        appId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAppReplicationConfigurationResponse {
        let input = DeleteAppReplicationConfigurationRequest(
            appId: appId
        )
        return try await self.deleteAppReplicationConfiguration(input, logger: logger)
    }

    /// Deletes the validation configuration for the specified application.
    @Sendable
    @inlinable
    public func deleteAppValidationConfiguration(_ input: DeleteAppValidationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAppValidationConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteAppValidationConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the validation configuration for the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAppValidationConfiguration(
        appId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAppValidationConfigurationResponse {
        let input = DeleteAppValidationConfigurationRequest(
            appId: appId
        )
        return try await self.deleteAppValidationConfiguration(input, logger: logger)
    }

    /// Deletes the specified replication job. After you delete a replication job, there are no further replication runs. Amazon Web Services deletes the contents of the Amazon S3 bucket used to store Server Migration Service artifacts. The AMIs created by the replication runs are not deleted.
    @Sendable
    @inlinable
    public func deleteReplicationJob(_ input: DeleteReplicationJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReplicationJobResponse {
        try await self.client.execute(
            operation: "DeleteReplicationJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified replication job. After you delete a replication job, there are no further replication runs. Amazon Web Services deletes the contents of the Amazon S3 bucket used to store Server Migration Service artifacts. The AMIs created by the replication runs are not deleted.
    ///
    /// Parameters:
    ///   - replicationJobId: The ID of the replication job.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteReplicationJob(
        replicationJobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteReplicationJobResponse {
        let input = DeleteReplicationJobRequest(
            replicationJobId: replicationJobId
        )
        return try await self.deleteReplicationJob(input, logger: logger)
    }

    /// Deletes all servers from your server catalog.
    @Sendable
    @inlinable
    public func deleteServerCatalog(_ input: DeleteServerCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteServerCatalogResponse {
        try await self.client.execute(
            operation: "DeleteServerCatalog", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes all servers from your server catalog.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteServerCatalog(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteServerCatalogResponse {
        let input = DeleteServerCatalogRequest(
        )
        return try await self.deleteServerCatalog(input, logger: logger)
    }

    /// Disassociates the specified connector from Server Migration Service. After you disassociate a connector, it is no longer available to support replication jobs.
    @Sendable
    @inlinable
    public func disassociateConnector(_ input: DisassociateConnectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateConnectorResponse {
        try await self.client.execute(
            operation: "DisassociateConnector", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociates the specified connector from Server Migration Service. After you disassociate a connector, it is no longer available to support replication jobs.
    ///
    /// Parameters:
    ///   - connectorId: The ID of the connector.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateConnector(
        connectorId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateConnectorResponse {
        let input = DisassociateConnectorRequest(
            connectorId: connectorId
        )
        return try await self.disassociateConnector(input, logger: logger)
    }

    /// Generates a target change set for a currently launched stack and writes it to an Amazon S3 object in the customer’s Amazon S3 bucket.
    @Sendable
    @inlinable
    public func generateChangeSet(_ input: GenerateChangeSetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GenerateChangeSetResponse {
        try await self.client.execute(
            operation: "GenerateChangeSet", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Generates a target change set for a currently launched stack and writes it to an Amazon S3 object in the customer’s Amazon S3 bucket.
    ///
    /// Parameters:
    ///   - appId: The ID of the application associated with the change set.
    ///   - changesetFormat: The format for the change set.
    ///   - logger: Logger use during operation
    @inlinable
    public func generateChangeSet(
        appId: String? = nil,
        changesetFormat: OutputFormat? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GenerateChangeSetResponse {
        let input = GenerateChangeSetRequest(
            appId: appId, 
            changesetFormat: changesetFormat
        )
        return try await self.generateChangeSet(input, logger: logger)
    }

    /// Generates an CloudFormation template based on the current launch configuration and writes it to an Amazon S3 object in the customer’s Amazon S3 bucket.
    @Sendable
    @inlinable
    public func generateTemplate(_ input: GenerateTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GenerateTemplateResponse {
        try await self.client.execute(
            operation: "GenerateTemplate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Generates an CloudFormation template based on the current launch configuration and writes it to an Amazon S3 object in the customer’s Amazon S3 bucket.
    ///
    /// Parameters:
    ///   - appId: The ID of the application associated with the CloudFormation template.
    ///   - templateFormat: The format for generating the CloudFormation template.
    ///   - logger: Logger use during operation
    @inlinable
    public func generateTemplate(
        appId: String? = nil,
        templateFormat: OutputFormat? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GenerateTemplateResponse {
        let input = GenerateTemplateRequest(
            appId: appId, 
            templateFormat: templateFormat
        )
        return try await self.generateTemplate(input, logger: logger)
    }

    /// Retrieve information about the specified application.
    @Sendable
    @inlinable
    public func getApp(_ input: GetAppRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAppResponse {
        try await self.client.execute(
            operation: "GetApp", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve information about the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func getApp(
        appId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAppResponse {
        let input = GetAppRequest(
            appId: appId
        )
        return try await self.getApp(input, logger: logger)
    }

    /// Retrieves the application launch configuration associated with the specified application.
    @Sendable
    @inlinable
    public func getAppLaunchConfiguration(_ input: GetAppLaunchConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAppLaunchConfigurationResponse {
        try await self.client.execute(
            operation: "GetAppLaunchConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the application launch configuration associated with the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAppLaunchConfiguration(
        appId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAppLaunchConfigurationResponse {
        let input = GetAppLaunchConfigurationRequest(
            appId: appId
        )
        return try await self.getAppLaunchConfiguration(input, logger: logger)
    }

    /// Retrieves the application replication configuration associated with the specified application.
    @Sendable
    @inlinable
    public func getAppReplicationConfiguration(_ input: GetAppReplicationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAppReplicationConfigurationResponse {
        try await self.client.execute(
            operation: "GetAppReplicationConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the application replication configuration associated with the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAppReplicationConfiguration(
        appId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAppReplicationConfigurationResponse {
        let input = GetAppReplicationConfigurationRequest(
            appId: appId
        )
        return try await self.getAppReplicationConfiguration(input, logger: logger)
    }

    /// Retrieves information about a configuration for validating an application.
    @Sendable
    @inlinable
    public func getAppValidationConfiguration(_ input: GetAppValidationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAppValidationConfigurationResponse {
        try await self.client.execute(
            operation: "GetAppValidationConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a configuration for validating an application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAppValidationConfiguration(
        appId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAppValidationConfigurationResponse {
        let input = GetAppValidationConfigurationRequest(
            appId: appId
        )
        return try await self.getAppValidationConfiguration(input, logger: logger)
    }

    /// Retrieves output from validating an application.
    @Sendable
    @inlinable
    public func getAppValidationOutput(_ input: GetAppValidationOutputRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAppValidationOutputResponse {
        try await self.client.execute(
            operation: "GetAppValidationOutput", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves output from validating an application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAppValidationOutput(
        appId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAppValidationOutputResponse {
        let input = GetAppValidationOutputRequest(
            appId: appId
        )
        return try await self.getAppValidationOutput(input, logger: logger)
    }

    /// Describes the connectors registered with the Server Migration Service.
    @Sendable
    @inlinable
    public func getConnectors(_ input: GetConnectorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetConnectorsResponse {
        try await self.client.execute(
            operation: "GetConnectors", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes the connectors registered with the Server Migration Service.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func getConnectors(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetConnectorsResponse {
        let input = GetConnectorsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getConnectors(input, logger: logger)
    }

    /// Describes the specified replication job or all of your replication jobs.
    @Sendable
    @inlinable
    public func getReplicationJobs(_ input: GetReplicationJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReplicationJobsResponse {
        try await self.client.execute(
            operation: "GetReplicationJobs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes the specified replication job or all of your replication jobs.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    ///   - nextToken: The token for the next set of results.
    ///   - replicationJobId: The ID of the replication job.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReplicationJobs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        replicationJobId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReplicationJobsResponse {
        let input = GetReplicationJobsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            replicationJobId: replicationJobId
        )
        return try await self.getReplicationJobs(input, logger: logger)
    }

    /// Describes the replication runs for the specified replication job.
    @Sendable
    @inlinable
    public func getReplicationRuns(_ input: GetReplicationRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReplicationRunsResponse {
        try await self.client.execute(
            operation: "GetReplicationRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes the replication runs for the specified replication job.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    ///   - nextToken: The token for the next set of results.
    ///   - replicationJobId: The ID of the replication job.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReplicationRuns(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        replicationJobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReplicationRunsResponse {
        let input = GetReplicationRunsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            replicationJobId: replicationJobId
        )
        return try await self.getReplicationRuns(input, logger: logger)
    }

    /// Describes the servers in your server catalog. Before you can describe your servers, you must import them using ImportServerCatalog.
    @Sendable
    @inlinable
    public func getServers(_ input: GetServersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetServersResponse {
        try await self.client.execute(
            operation: "GetServers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes the servers in your server catalog. Before you can describe your servers, you must import them using ImportServerCatalog.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    ///   - nextToken: The token for the next set of results.
    ///   - vmServerAddressList: The server addresses.
    ///   - logger: Logger use during operation
    @inlinable
    public func getServers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        vmServerAddressList: [VmServerAddress]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetServersResponse {
        let input = GetServersRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            vmServerAddressList: vmServerAddressList
        )
        return try await self.getServers(input, logger: logger)
    }

    /// Allows application import from Migration Hub.
    @Sendable
    @inlinable
    public func importAppCatalog(_ input: ImportAppCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportAppCatalogResponse {
        try await self.client.execute(
            operation: "ImportAppCatalog", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Allows application import from Migration Hub.
    ///
    /// Parameters:
    ///   - roleName: The name of the service role. If you omit this parameter, we create a service-linked role for Migration Hub in your account. Otherwise, the role that you provide must have the policy and trust policy described in the Migration Hub User Guide.
    ///   - logger: Logger use during operation
    @inlinable
    public func importAppCatalog(
        roleName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportAppCatalogResponse {
        let input = ImportAppCatalogRequest(
            roleName: roleName
        )
        return try await self.importAppCatalog(input, logger: logger)
    }

    /// Gathers a complete list of on-premises servers. Connectors must be installed and monitoring all servers to import. This call returns immediately, but might take additional time to retrieve all the servers.
    @Sendable
    @inlinable
    public func importServerCatalog(_ input: ImportServerCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportServerCatalogResponse {
        try await self.client.execute(
            operation: "ImportServerCatalog", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gathers a complete list of on-premises servers. Connectors must be installed and monitoring all servers to import. This call returns immediately, but might take additional time to retrieve all the servers.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func importServerCatalog(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportServerCatalogResponse {
        let input = ImportServerCatalogRequest(
        )
        return try await self.importServerCatalog(input, logger: logger)
    }

    /// Launches the specified application as a stack in CloudFormation.
    @Sendable
    @inlinable
    public func launchApp(_ input: LaunchAppRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> LaunchAppResponse {
        try await self.client.execute(
            operation: "LaunchApp", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Launches the specified application as a stack in CloudFormation.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func launchApp(
        appId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> LaunchAppResponse {
        let input = LaunchAppRequest(
            appId: appId
        )
        return try await self.launchApp(input, logger: logger)
    }

    /// Retrieves summaries for all applications.
    @Sendable
    @inlinable
    public func listApps(_ input: ListAppsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAppsResponse {
        try await self.client.execute(
            operation: "ListApps", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves summaries for all applications.
    ///
    /// Parameters:
    ///   - appIds: The unique application IDs.
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 100. To retrieve the remaining results, make another call with the returned NextToken value.
    ///   - nextToken: The token for the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listApps(
        appIds: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAppsResponse {
        let input = ListAppsRequest(
            appIds: appIds, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listApps(input, logger: logger)
    }

    /// Provides information to Server Migration Service about whether application validation is successful.
    @Sendable
    @inlinable
    public func notifyAppValidationOutput(_ input: NotifyAppValidationOutputRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> NotifyAppValidationOutputResponse {
        try await self.client.execute(
            operation: "NotifyAppValidationOutput", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides information to Server Migration Service about whether application validation is successful.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - notificationContext: The notification information.
    ///   - logger: Logger use during operation
    @inlinable
    public func notifyAppValidationOutput(
        appId: String,
        notificationContext: NotificationContext? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> NotifyAppValidationOutputResponse {
        let input = NotifyAppValidationOutputRequest(
            appId: appId, 
            notificationContext: notificationContext
        )
        return try await self.notifyAppValidationOutput(input, logger: logger)
    }

    /// Creates or updates the launch configuration for the specified application.
    @Sendable
    @inlinable
    public func putAppLaunchConfiguration(_ input: PutAppLaunchConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutAppLaunchConfigurationResponse {
        try await self.client.execute(
            operation: "PutAppLaunchConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates or updates the launch configuration for the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - autoLaunch: Indicates whether the application is configured to launch automatically after replication is complete.
    ///   - roleName: The name of service role in the customer's account that CloudFormation uses to launch the application.
    ///   - serverGroupLaunchConfigurations: Information about the launch configurations for server groups in the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func putAppLaunchConfiguration(
        appId: String? = nil,
        autoLaunch: Bool? = nil,
        roleName: String? = nil,
        serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutAppLaunchConfigurationResponse {
        let input = PutAppLaunchConfigurationRequest(
            appId: appId, 
            autoLaunch: autoLaunch, 
            roleName: roleName, 
            serverGroupLaunchConfigurations: serverGroupLaunchConfigurations
        )
        return try await self.putAppLaunchConfiguration(input, logger: logger)
    }

    /// Creates or updates the replication configuration for the specified application.
    @Sendable
    @inlinable
    public func putAppReplicationConfiguration(_ input: PutAppReplicationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutAppReplicationConfigurationResponse {
        try await self.client.execute(
            operation: "PutAppReplicationConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates or updates the replication configuration for the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - serverGroupReplicationConfigurations: Information about the replication configurations for server groups in the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func putAppReplicationConfiguration(
        appId: String? = nil,
        serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutAppReplicationConfigurationResponse {
        let input = PutAppReplicationConfigurationRequest(
            appId: appId, 
            serverGroupReplicationConfigurations: serverGroupReplicationConfigurations
        )
        return try await self.putAppReplicationConfiguration(input, logger: logger)
    }

    /// Creates or updates a validation configuration for the specified application.
    @Sendable
    @inlinable
    public func putAppValidationConfiguration(_ input: PutAppValidationConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutAppValidationConfigurationResponse {
        try await self.client.execute(
            operation: "PutAppValidationConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates or updates a validation configuration for the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - appValidationConfigurations: The configuration for application validation.
    ///   - serverGroupValidationConfigurations: The configuration for instance validation.
    ///   - logger: Logger use during operation
    @inlinable
    public func putAppValidationConfiguration(
        appId: String,
        appValidationConfigurations: [AppValidationConfiguration]? = nil,
        serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutAppValidationConfigurationResponse {
        let input = PutAppValidationConfigurationRequest(
            appId: appId, 
            appValidationConfigurations: appValidationConfigurations, 
            serverGroupValidationConfigurations: serverGroupValidationConfigurations
        )
        return try await self.putAppValidationConfiguration(input, logger: logger)
    }

    /// Starts replicating the specified application by creating replication jobs for each server in the application.
    @Sendable
    @inlinable
    public func startAppReplication(_ input: StartAppReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartAppReplicationResponse {
        try await self.client.execute(
            operation: "StartAppReplication", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts replicating the specified application by creating replication jobs for each server in the application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func startAppReplication(
        appId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartAppReplicationResponse {
        let input = StartAppReplicationRequest(
            appId: appId
        )
        return try await self.startAppReplication(input, logger: logger)
    }

    /// Starts an on-demand replication run for the specified application.
    @Sendable
    @inlinable
    public func startOnDemandAppReplication(_ input: StartOnDemandAppReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartOnDemandAppReplicationResponse {
        try await self.client.execute(
            operation: "StartOnDemandAppReplication", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts an on-demand replication run for the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - description: The description of the replication run.
    ///   - logger: Logger use during operation
    @inlinable
    public func startOnDemandAppReplication(
        appId: String,
        description: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartOnDemandAppReplicationResponse {
        let input = StartOnDemandAppReplicationRequest(
            appId: appId, 
            description: description
        )
        return try await self.startOnDemandAppReplication(input, logger: logger)
    }

    /// Starts an on-demand replication run for the specified replication job. This replication run starts immediately. This replication run is in addition to the ones already scheduled. There is a limit on the number of on-demand replications runs that you can request in a 24-hour period.
    @Sendable
    @inlinable
    public func startOnDemandReplicationRun(_ input: StartOnDemandReplicationRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartOnDemandReplicationRunResponse {
        try await self.client.execute(
            operation: "StartOnDemandReplicationRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts an on-demand replication run for the specified replication job. This replication run starts immediately. This replication run is in addition to the ones already scheduled. There is a limit on the number of on-demand replications runs that you can request in a 24-hour period.
    ///
    /// Parameters:
    ///   - description: The description of the replication run.
    ///   - replicationJobId: The ID of the replication job.
    ///   - logger: Logger use during operation
    @inlinable
    public func startOnDemandReplicationRun(
        description: String? = nil,
        replicationJobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartOnDemandReplicationRunResponse {
        let input = StartOnDemandReplicationRunRequest(
            description: description, 
            replicationJobId: replicationJobId
        )
        return try await self.startOnDemandReplicationRun(input, logger: logger)
    }

    /// Stops replicating the specified application by deleting the replication job for each server in the application.
    @Sendable
    @inlinable
    public func stopAppReplication(_ input: StopAppReplicationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopAppReplicationResponse {
        try await self.client.execute(
            operation: "StopAppReplication", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops replicating the specified application by deleting the replication job for each server in the application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopAppReplication(
        appId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopAppReplicationResponse {
        let input = StopAppReplicationRequest(
            appId: appId
        )
        return try await self.stopAppReplication(input, logger: logger)
    }

    /// Terminates the stack for the specified application.
    @Sendable
    @inlinable
    public func terminateApp(_ input: TerminateAppRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TerminateAppResponse {
        try await self.client.execute(
            operation: "TerminateApp", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Terminates the stack for the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func terminateApp(
        appId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TerminateAppResponse {
        let input = TerminateAppRequest(
            appId: appId
        )
        return try await self.terminateApp(input, logger: logger)
    }

    /// Updates the specified application.
    @Sendable
    @inlinable
    public func updateApp(_ input: UpdateAppRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAppResponse {
        try await self.client.execute(
            operation: "UpdateApp", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified application.
    ///
    /// Parameters:
    ///   - appId: The ID of the application.
    ///   - description: The new description of the application.
    ///   - name: The new name of the application.
    ///   - roleName: The name of the service role in the customer's account used by Server Migration Service.
    ///   - serverGroups: The server groups in the application to update.
    ///   - tags: The tags to associate with the application.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateApp(
        appId: String? = nil,
        description: String? = nil,
        name: String? = nil,
        roleName: String? = nil,
        serverGroups: [ServerGroup]? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAppResponse {
        let input = UpdateAppRequest(
            appId: appId, 
            description: description, 
            name: name, 
            roleName: roleName, 
            serverGroups: serverGroups, 
            tags: tags
        )
        return try await self.updateApp(input, logger: logger)
    }

    /// Updates the specified settings for the specified replication job.
    @Sendable
    @inlinable
    public func updateReplicationJob(_ input: UpdateReplicationJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateReplicationJobResponse {
        try await self.client.execute(
            operation: "UpdateReplicationJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified settings for the specified replication job.
    ///
    /// Parameters:
    ///   - description: The description of the replication job.
    ///   - encrypted: When true, the replication job produces encrypted AMIs. For more information, KmsKeyId.
    ///   - frequency: The time between consecutive replication runs, in hours.
    ///   - kmsKeyId: The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:   KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
    ///   - licenseType: The license type to be used for the AMI created by a successful replication run.
    ///   - nextReplicationRunStartTime: The start time of the next replication run.
    ///   - numberOfRecentAmisToKeep: The maximum number of SMS-created AMIs to retain. The oldest is deleted after the maximum number is reached and a new AMI is created.
    ///   - replicationJobId: The ID of the replication job.
    ///   - roleName: The name of the IAM role to be used by Server Migration Service.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReplicationJob(
        description: String? = nil,
        encrypted: Bool? = nil,
        frequency: Int? = nil,
        kmsKeyId: String? = nil,
        licenseType: LicenseType? = nil,
        nextReplicationRunStartTime: Date? = nil,
        numberOfRecentAmisToKeep: Int? = nil,
        replicationJobId: String,
        roleName: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateReplicationJobResponse {
        let input = UpdateReplicationJobRequest(
            description: description, 
            encrypted: encrypted, 
            frequency: frequency, 
            kmsKeyId: kmsKeyId, 
            licenseType: licenseType, 
            nextReplicationRunStartTime: nextReplicationRunStartTime, 
            numberOfRecentAmisToKeep: numberOfRecentAmisToKeep, 
            replicationJobId: replicationJobId, 
            roleName: roleName
        )
        return try await self.updateReplicationJob(input, logger: logger)
    }
}

extension SMS {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: SMS, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension SMS {
    /// Return PaginatorSequence for operation ``getConnectors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getConnectorsPaginator(
        _ input: GetConnectorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetConnectorsRequest, GetConnectorsResponse> {
        return .init(
            input: input,
            command: self.getConnectors,
            inputKey: \GetConnectorsRequest.nextToken,
            outputKey: \GetConnectorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getConnectors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    ///   - logger: Logger used for logging
    @inlinable
    public func getConnectorsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetConnectorsRequest, GetConnectorsResponse> {
        let input = GetConnectorsRequest(
            maxResults: maxResults
        )
        return self.getConnectorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getReplicationJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getReplicationJobsPaginator(
        _ input: GetReplicationJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetReplicationJobsRequest, GetReplicationJobsResponse> {
        return .init(
            input: input,
            command: self.getReplicationJobs,
            inputKey: \GetReplicationJobsRequest.nextToken,
            outputKey: \GetReplicationJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getReplicationJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    ///   - replicationJobId: The ID of the replication job.
    ///   - logger: Logger used for logging
    @inlinable
    public func getReplicationJobsPaginator(
        maxResults: Int? = nil,
        replicationJobId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetReplicationJobsRequest, GetReplicationJobsResponse> {
        let input = GetReplicationJobsRequest(
            maxResults: maxResults, 
            replicationJobId: replicationJobId
        )
        return self.getReplicationJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getReplicationRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getReplicationRunsPaginator(
        _ input: GetReplicationRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetReplicationRunsRequest, GetReplicationRunsResponse> {
        return .init(
            input: input,
            command: self.getReplicationRuns,
            inputKey: \GetReplicationRunsRequest.nextToken,
            outputKey: \GetReplicationRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getReplicationRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    ///   - replicationJobId: The ID of the replication job.
    ///   - logger: Logger used for logging
    @inlinable
    public func getReplicationRunsPaginator(
        maxResults: Int? = nil,
        replicationJobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetReplicationRunsRequest, GetReplicationRunsResponse> {
        let input = GetReplicationRunsRequest(
            maxResults: maxResults, 
            replicationJobId: replicationJobId
        )
        return self.getReplicationRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``getServers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getServersPaginator(
        _ input: GetServersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetServersRequest, GetServersResponse> {
        return .init(
            input: input,
            command: self.getServers,
            inputKey: \GetServersRequest.nextToken,
            outputKey: \GetServersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getServers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    ///   - vmServerAddressList: The server addresses.
    ///   - logger: Logger used for logging
    @inlinable
    public func getServersPaginator(
        maxResults: Int? = nil,
        vmServerAddressList: [VmServerAddress]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetServersRequest, GetServersResponse> {
        let input = GetServersRequest(
            maxResults: maxResults, 
            vmServerAddressList: vmServerAddressList
        )
        return self.getServersPaginator(input, logger: logger)
    }
}

extension SMS.GetConnectorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SMS.GetConnectorsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SMS.GetReplicationJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SMS.GetReplicationJobsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            replicationJobId: self.replicationJobId
        )
    }
}

extension SMS.GetReplicationRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SMS.GetReplicationRunsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            replicationJobId: self.replicationJobId
        )
    }
}

extension SMS.GetServersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SMS.GetServersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            vmServerAddressList: self.vmServerAddressList
        )
    }
}
