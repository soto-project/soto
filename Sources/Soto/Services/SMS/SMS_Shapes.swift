//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension SMS {
    // MARK: Enums

    public enum AppLaunchConfigurationStatus: String, CustomStringConvertible, Codable {
        case configured = "CONFIGURED"
        case notConfigured = "NOT_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum AppLaunchStatus: String, CustomStringConvertible, Codable {
        case configurationInvalid = "CONFIGURATION_INVALID"
        case configurationInProgress = "CONFIGURATION_IN_PROGRESS"
        case deltaLaunchFailed = "DELTA_LAUNCH_FAILED"
        case deltaLaunchInProgress = "DELTA_LAUNCH_IN_PROGRESS"
        case launched = "LAUNCHED"
        case launchFailed = "LAUNCH_FAILED"
        case launchInProgress = "LAUNCH_IN_PROGRESS"
        case launchPending = "LAUNCH_PENDING"
        case partiallyLaunched = "PARTIALLY_LAUNCHED"
        case readyForConfiguration = "READY_FOR_CONFIGURATION"
        case readyForLaunch = "READY_FOR_LAUNCH"
        case terminated = "TERMINATED"
        case terminateFailed = "TERMINATE_FAILED"
        case terminateInProgress = "TERMINATE_IN_PROGRESS"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AppReplicationConfigurationStatus: String, CustomStringConvertible, Codable {
        case configured = "CONFIGURED"
        case notConfigured = "NOT_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum AppReplicationStatus: String, CustomStringConvertible, Codable {
        case configurationInvalid = "CONFIGURATION_INVALID"
        case configurationInProgress = "CONFIGURATION_IN_PROGRESS"
        case deltaReplicated = "DELTA_REPLICATED"
        case deltaReplicationFailed = "DELTA_REPLICATION_FAILED"
        case deltaReplicationInProgress = "DELTA_REPLICATION_IN_PROGRESS"
        case partiallyReplicated = "PARTIALLY_REPLICATED"
        case readyForConfiguration = "READY_FOR_CONFIGURATION"
        case readyForReplication = "READY_FOR_REPLICATION"
        case replicated = "REPLICATED"
        case replicationFailed = "REPLICATION_FAILED"
        case replicationInProgress = "REPLICATION_IN_PROGRESS"
        case replicationPending = "REPLICATION_PENDING"
        case replicationStopped = "REPLICATION_STOPPED"
        case replicationStopping = "REPLICATION_STOPPING"
        case replicationStopFailed = "REPLICATION_STOP_FAILED"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum AppStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AppValidationStrategy: String, CustomStringConvertible, Codable {
        case ssm = "SSM"
        public var description: String { return self.rawValue }
    }

    public enum ConnectorCapability: String, CustomStringConvertible, Codable {
        case hypervManager = "HYPERV-MANAGER"
        case scvmm = "SCVMM"
        case smsOptimized = "SMS_OPTIMIZED"
        case snapshotBatching = "SNAPSHOT_BATCHING"
        case vsphere = "VSPHERE"
        public var description: String { return self.rawValue }
    }

    public enum ConnectorStatus: String, CustomStringConvertible, Codable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum LicenseType: String, CustomStringConvertible, Codable {
        case aws = "AWS"
        case byol = "BYOL"
        public var description: String { return self.rawValue }
    }

    public enum OutputFormat: String, CustomStringConvertible, Codable {
        case json = "JSON"
        case yaml = "YAML"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationJobState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case completed = "COMPLETED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case failing = "FAILING"
        case pausedOnFailure = "PAUSED_ON_FAILURE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationRunState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case completed = "COMPLETED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case missed = "MISSED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationRunType: String, CustomStringConvertible, Codable {
        case automatic = "AUTOMATIC"
        case onDemand = "ON_DEMAND"
        public var description: String { return self.rawValue }
    }

    public enum ScriptType: String, CustomStringConvertible, Codable {
        case powershellScript = "POWERSHELL_SCRIPT"
        case shellScript = "SHELL_SCRIPT"
        public var description: String { return self.rawValue }
    }

    public enum ServerCatalogStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case expired = "EXPIRED"
        case importing = "IMPORTING"
        case notImported = "NOT_IMPORTED"
        public var description: String { return self.rawValue }
    }

    public enum ServerType: String, CustomStringConvertible, Codable {
        case virtualMachine = "VIRTUAL_MACHINE"
        public var description: String { return self.rawValue }
    }

    public enum ServerValidationStrategy: String, CustomStringConvertible, Codable {
        case userdata = "USERDATA"
        public var description: String { return self.rawValue }
    }

    public enum ValidationStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        case readyForValidation = "READY_FOR_VALIDATION"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum VmManagerType: String, CustomStringConvertible, Codable {
        case hypervManager = "HYPERV-MANAGER"
        case scvmm = "SCVMM"
        case vsphere = "VSPHERE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AppSummary: AWSDecodableShape {
        /// The unique ID of the application.
        public let appId: String?
        /// The creation time of the application.
        public let creationTime: Date?
        /// The description of the application.
        public let description: String?
        /// The ID of the application.
        public let importedAppId: String?
        /// The last modified time of the application.
        public let lastModified: Date?
        /// The timestamp of the application's most recent successful replication.
        public let latestReplicationTime: Date?
        /// Status of the launch configuration.
        public let launchConfigurationStatus: AppLaunchConfigurationStatus?
        /// Details about the latest launch of the application.
        public let launchDetails: LaunchDetails?
        /// The launch status of the application.
        public let launchStatus: AppLaunchStatus?
        /// A message related to the launch status of the application.
        public let launchStatusMessage: String?
        /// The name of the application.
        public let name: String?
        /// Status of the replication configuration.
        public let replicationConfigurationStatus: AppReplicationConfigurationStatus?
        /// The replication status of the application.
        public let replicationStatus: AppReplicationStatus?
        /// A message related to the replication status of the application.
        public let replicationStatusMessage: String?
        /// The name of the service role in the customer's account used by AWS SMS.
        public let roleName: String?
        /// Status of the application.
        public let status: AppStatus?
        /// A message related to the status of the application
        public let statusMessage: String?
        /// The number of server groups present in the application.
        public let totalServerGroups: Int?
        /// The number of servers present in the application.
        public let totalServers: Int?

        public init(appId: String? = nil, creationTime: Date? = nil, description: String? = nil, importedAppId: String? = nil, lastModified: Date? = nil, latestReplicationTime: Date? = nil, launchConfigurationStatus: AppLaunchConfigurationStatus? = nil, launchDetails: LaunchDetails? = nil, launchStatus: AppLaunchStatus? = nil, launchStatusMessage: String? = nil, name: String? = nil, replicationConfigurationStatus: AppReplicationConfigurationStatus? = nil, replicationStatus: AppReplicationStatus? = nil, replicationStatusMessage: String? = nil, roleName: String? = nil, status: AppStatus? = nil, statusMessage: String? = nil, totalServerGroups: Int? = nil, totalServers: Int? = nil) {
            self.appId = appId
            self.creationTime = creationTime
            self.description = description
            self.importedAppId = importedAppId
            self.lastModified = lastModified
            self.latestReplicationTime = latestReplicationTime
            self.launchConfigurationStatus = launchConfigurationStatus
            self.launchDetails = launchDetails
            self.launchStatus = launchStatus
            self.launchStatusMessage = launchStatusMessage
            self.name = name
            self.replicationConfigurationStatus = replicationConfigurationStatus
            self.replicationStatus = replicationStatus
            self.replicationStatusMessage = replicationStatusMessage
            self.roleName = roleName
            self.status = status
            self.statusMessage = statusMessage
            self.totalServerGroups = totalServerGroups
            self.totalServers = totalServers
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case creationTime
            case description
            case importedAppId
            case lastModified
            case latestReplicationTime
            case launchConfigurationStatus
            case launchDetails
            case launchStatus
            case launchStatusMessage
            case name
            case replicationConfigurationStatus
            case replicationStatus
            case replicationStatusMessage
            case roleName
            case status
            case statusMessage
            case totalServerGroups
            case totalServers
        }
    }

    public struct AppValidationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The validation strategy.
        public let appValidationStrategy: AppValidationStrategy?
        /// The name of the configuration.
        public let name: String?
        /// The validation parameters.
        public let ssmValidationParameters: SSMValidationParameters?
        /// The ID of the validation.
        public let validationId: String?

        public init(appValidationStrategy: AppValidationStrategy? = nil, name: String? = nil, ssmValidationParameters: SSMValidationParameters? = nil, validationId: String? = nil) {
            self.appValidationStrategy = appValidationStrategy
            self.name = name
            self.ssmValidationParameters = ssmValidationParameters
            self.validationId = validationId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S]+$")
            try self.ssmValidationParameters?.validate(name: "\(name).ssmValidationParameters")
            try self.validate(self.validationId, name: "validationId", parent: name, pattern: "^val-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appValidationStrategy
            case name
            case ssmValidationParameters
            case validationId
        }
    }

    public struct AppValidationOutput: AWSDecodableShape {
        /// Output from using SSM to validate the application.
        public let ssmOutput: SSMOutput?

        public init(ssmOutput: SSMOutput? = nil) {
            self.ssmOutput = ssmOutput
        }

        private enum CodingKeys: String, CodingKey {
            case ssmOutput
        }
    }

    public struct Connector: AWSDecodableShape {
        /// The time the connector was associated.
        public let associatedOn: Date?
        /// The capabilities of the connector.
        public let capabilityList: [ConnectorCapability]?
        /// The ID of the connector.
        public let connectorId: String?
        /// The IP address of the connector.
        public let ipAddress: String?
        /// The MAC address of the connector.
        public let macAddress: String?
        /// The status of the connector.
        public let status: ConnectorStatus?
        /// The connector version.
        public let version: String?
        /// The ID of the VM manager.
        public let vmManagerId: String?
        /// The name of the VM manager.
        public let vmManagerName: String?
        /// The VM management product.
        public let vmManagerType: VmManagerType?

        public init(associatedOn: Date? = nil, capabilityList: [ConnectorCapability]? = nil, connectorId: String? = nil, ipAddress: String? = nil, macAddress: String? = nil, status: ConnectorStatus? = nil, version: String? = nil, vmManagerId: String? = nil, vmManagerName: String? = nil, vmManagerType: VmManagerType? = nil) {
            self.associatedOn = associatedOn
            self.capabilityList = capabilityList
            self.connectorId = connectorId
            self.ipAddress = ipAddress
            self.macAddress = macAddress
            self.status = status
            self.version = version
            self.vmManagerId = vmManagerId
            self.vmManagerName = vmManagerName
            self.vmManagerType = vmManagerType
        }

        private enum CodingKeys: String, CodingKey {
            case associatedOn
            case capabilityList
            case connectorId
            case ipAddress
            case macAddress
            case status
            case version
            case vmManagerId
            case vmManagerName
            case vmManagerType
        }
    }

    public struct CreateAppRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of application creation.
        public let clientToken: String?
        /// The description of the new application
        public let description: String?
        /// The name of the new application.
        public let name: String?
        /// The name of the service role in the customer's account to be used by AWS SMS.
        public let roleName: String?
        /// The server groups to include in the application.
        public let serverGroups: [ServerGroup]?
        /// The tags to be associated with the application.
        public let tags: [Tag]?

        public init(clientToken: String? = nil, description: String? = nil, name: String? = nil, roleName: String? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.roleName = roleName
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case name
            case roleName
            case serverGroups
            case tags
        }
    }

    public struct CreateAppResponse: AWSDecodableShape {
        /// A summary description of the application.
        public let appSummary: AppSummary?
        /// The server groups included in the application.
        public let serverGroups: [ServerGroup]?
        /// The tags associated with the application.
        public let tags: [Tag]?

        public init(appSummary: AppSummary? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appSummary = appSummary
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appSummary
            case serverGroups
            case tags
        }
    }

    public struct CreateReplicationJobRequest: AWSEncodableShape {
        /// The description of the replication job.
        public let description: String?
        /// Indicates whether the replication job produces encrypted AMIs.
        public let encrypted: Bool?
        /// The time between consecutive replication runs, in hours.
        public let frequency: Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:   KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is true but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public let kmsKeyId: String?
        /// The license type to be used for the AMI created by a successful replication run.
        public let licenseType: LicenseType?
        /// The maximum number of SMS-created AMIs to retain. The oldest is deleted after the maximum number is reached and a new AMI is created.
        public let numberOfRecentAmisToKeep: Int?
        /// The name of the IAM role to be used by the AWS SMS.
        public let roleName: String?
        /// Indicates whether to run the replication job one time.
        public let runOnce: Bool?
        /// The seed replication time.
        public let seedReplicationTime: Date
        /// The ID of the server.
        public let serverId: String

        public init(description: String? = nil, encrypted: Bool? = nil, frequency: Int? = nil, kmsKeyId: String? = nil, licenseType: LicenseType? = nil, numberOfRecentAmisToKeep: Int? = nil, roleName: String? = nil, runOnce: Bool? = nil, seedReplicationTime: Date, serverId: String) {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.roleName = roleName
            self.runOnce = runOnce
            self.seedReplicationTime = seedReplicationTime
            self.serverId = serverId
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case encrypted
            case frequency
            case kmsKeyId
            case licenseType
            case numberOfRecentAmisToKeep
            case roleName
            case runOnce
            case seedReplicationTime
            case serverId
        }
    }

    public struct CreateReplicationJobResponse: AWSDecodableShape {
        /// The unique identifier of the replication job.
        public let replicationJobId: String?

        public init(replicationJobId: String? = nil) {
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationJobId
        }
    }

    public struct DeleteAppLaunchConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct DeleteAppLaunchConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAppReplicationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct DeleteAppReplicationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAppRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?
        /// Indicates whether to stop all replication jobs corresponding to the servers in the application while deleting the application.
        public let forceStopAppReplication: Bool?
        /// Indicates whether to terminate the stack corresponding to the application while deleting the application.
        public let forceTerminateApp: Bool?

        public init(appId: String? = nil, forceStopAppReplication: Bool? = nil, forceTerminateApp: Bool? = nil) {
            self.appId = appId
            self.forceStopAppReplication = forceStopAppReplication
            self.forceTerminateApp = forceTerminateApp
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case forceStopAppReplication
            case forceTerminateApp
        }
    }

    public struct DeleteAppResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAppValidationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String

        public init(appId: String) {
            self.appId = appId
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^app-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct DeleteAppValidationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReplicationJobRequest: AWSEncodableShape {
        /// The ID of the replication job.
        public let replicationJobId: String

        public init(replicationJobId: String) {
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationJobId
        }
    }

    public struct DeleteReplicationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteServerCatalogRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteServerCatalogResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateConnectorRequest: AWSEncodableShape {
        /// The ID of the connector.
        public let connectorId: String

        public init(connectorId: String) {
            self.connectorId = connectorId
        }

        private enum CodingKeys: String, CodingKey {
            case connectorId
        }
    }

    public struct DisassociateConnectorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GenerateChangeSetRequest: AWSEncodableShape {
        /// The ID of the application associated with the change set.
        public let appId: String?
        /// The format for the change set.
        public let changesetFormat: OutputFormat?

        public init(appId: String? = nil, changesetFormat: OutputFormat? = nil) {
            self.appId = appId
            self.changesetFormat = changesetFormat
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case changesetFormat
        }
    }

    public struct GenerateChangeSetResponse: AWSDecodableShape {
        /// The location of the Amazon S3 object.
        public let s3Location: S3Location?

        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location
        }
    }

    public struct GenerateTemplateRequest: AWSEncodableShape {
        /// The ID of the application associated with the AWS CloudFormation template.
        public let appId: String?
        /// The format for generating the AWS CloudFormation template.
        public let templateFormat: OutputFormat?

        public init(appId: String? = nil, templateFormat: OutputFormat? = nil) {
            self.appId = appId
            self.templateFormat = templateFormat
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case templateFormat
        }
    }

    public struct GenerateTemplateResponse: AWSDecodableShape {
        /// The location of the Amazon S3 object.
        public let s3Location: S3Location?

        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location
        }
    }

    public struct GetAppLaunchConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct GetAppLaunchConfigurationResponse: AWSDecodableShape {
        /// The ID of the application.
        public let appId: String?
        /// Indicates whether the application is configured to launch automatically after replication is complete.
        public let autoLaunch: Bool?
        /// The name of the service role in the customer's account that AWS CloudFormation uses to launch the application.
        public let roleName: String?
        /// The launch configurations for server groups in this application.
        public let serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]?

        public init(appId: String? = nil, autoLaunch: Bool? = nil, roleName: String? = nil, serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]? = nil) {
            self.appId = appId
            self.autoLaunch = autoLaunch
            self.roleName = roleName
            self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case autoLaunch
            case roleName
            case serverGroupLaunchConfigurations
        }
    }

    public struct GetAppReplicationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct GetAppReplicationConfigurationResponse: AWSDecodableShape {
        /// The replication configurations associated with server groups in this application.
        public let serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]?

        public init(serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]? = nil) {
            self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case serverGroupReplicationConfigurations
        }
    }

    public struct GetAppRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct GetAppResponse: AWSDecodableShape {
        /// Information about the application.
        public let appSummary: AppSummary?
        /// The server groups that belong to the application.
        public let serverGroups: [ServerGroup]?
        /// The tags associated with the application.
        public let tags: [Tag]?

        public init(appSummary: AppSummary? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appSummary = appSummary
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appSummary
            case serverGroups
            case tags
        }
    }

    public struct GetAppValidationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String

        public init(appId: String) {
            self.appId = appId
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^app-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct GetAppValidationConfigurationResponse: AWSDecodableShape {
        /// The configuration for application validation.
        public let appValidationConfigurations: [AppValidationConfiguration]?
        /// The configuration for instance validation.
        public let serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]?

        public init(appValidationConfigurations: [AppValidationConfiguration]? = nil, serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]? = nil) {
            self.appValidationConfigurations = appValidationConfigurations
            self.serverGroupValidationConfigurations = serverGroupValidationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case appValidationConfigurations
            case serverGroupValidationConfigurations
        }
    }

    public struct GetAppValidationOutputRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String

        public init(appId: String) {
            self.appId = appId
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^app-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct GetAppValidationOutputResponse: AWSDecodableShape {
        /// The validation output.
        public let validationOutputList: [ValidationOutput]?

        public init(validationOutputList: [ValidationOutput]? = nil) {
            self.validationOutputList = validationOutputList
        }

        private enum CodingKeys: String, CodingKey {
            case validationOutputList
        }
    }

    public struct GetConnectorsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct GetConnectorsResponse: AWSDecodableShape {
        /// Information about the registered connectors.
        public let connectorList: [Connector]?
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(connectorList: [Connector]? = nil, nextToken: String? = nil) {
            self.connectorList = connectorList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorList
            case nextToken
        }
    }

    public struct GetReplicationJobsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The ID of the replication job.
        public let replicationJobId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, replicationJobId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case replicationJobId
        }
    }

    public struct GetReplicationJobsResponse: AWSDecodableShape {
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the replication jobs.
        public let replicationJobList: [ReplicationJob]?

        public init(nextToken: String? = nil, replicationJobList: [ReplicationJob]? = nil) {
            self.nextToken = nextToken
            self.replicationJobList = replicationJobList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case replicationJobList
        }
    }

    public struct GetReplicationRunsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The ID of the replication job.
        public let replicationJobId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, replicationJobId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case replicationJobId
        }
    }

    public struct GetReplicationRunsResponse: AWSDecodableShape {
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// Information about the replication job.
        public let replicationJob: ReplicationJob?
        /// Information about the replication runs.
        public let replicationRunList: [ReplicationRun]?

        public init(nextToken: String? = nil, replicationJob: ReplicationJob? = nil, replicationRunList: [ReplicationRun]? = nil) {
            self.nextToken = nextToken
            self.replicationJob = replicationJob
            self.replicationRunList = replicationRunList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case replicationJob
            case replicationRunList
        }
    }

    public struct GetServersRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?
        /// The server addresses.
        public let vmServerAddressList: [VmServerAddress]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, vmServerAddressList: [VmServerAddress]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.vmServerAddressList = vmServerAddressList
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
            case vmServerAddressList
        }
    }

    public struct GetServersResponse: AWSDecodableShape {
        /// The time when the server was last modified.
        public let lastModifiedOn: Date?
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The status of the server catalog.
        public let serverCatalogStatus: ServerCatalogStatus?
        /// Information about the servers.
        public let serverList: [Server]?

        public init(lastModifiedOn: Date? = nil, nextToken: String? = nil, serverCatalogStatus: ServerCatalogStatus? = nil, serverList: [Server]? = nil) {
            self.lastModifiedOn = lastModifiedOn
            self.nextToken = nextToken
            self.serverCatalogStatus = serverCatalogStatus
            self.serverList = serverList
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedOn
            case nextToken
            case serverCatalogStatus
            case serverList
        }
    }

    public struct ImportAppCatalogRequest: AWSEncodableShape {
        /// The name of the service role. If you omit this parameter, we create a service-linked role for AWS Migration Hub in your account. Otherwise, the role that you provide must have the policy and trust policy described in the AWS Migration Hub User Guide.
        public let roleName: String?

        public init(roleName: String? = nil) {
            self.roleName = roleName
        }

        private enum CodingKeys: String, CodingKey {
            case roleName
        }
    }

    public struct ImportAppCatalogResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ImportServerCatalogRequest: AWSEncodableShape {
        public init() {}
    }

    public struct ImportServerCatalogResponse: AWSDecodableShape {
        public init() {}
    }

    public struct LaunchAppRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct LaunchAppResponse: AWSDecodableShape {
        public init() {}
    }

    public struct LaunchDetails: AWSDecodableShape {
        /// The latest time that this application was launched successfully.
        public let latestLaunchTime: Date?
        /// The ID of the latest stack launched for this application.
        public let stackId: String?
        /// The name of the latest stack launched for this application.
        public let stackName: String?

        public init(latestLaunchTime: Date? = nil, stackId: String? = nil, stackName: String? = nil) {
            self.latestLaunchTime = latestLaunchTime
            self.stackId = stackId
            self.stackName = stackName
        }

        private enum CodingKeys: String, CodingKey {
            case latestLaunchTime
            case stackId
            case stackName
        }
    }

    public struct ListAppsRequest: AWSEncodableShape {
        /// The unique application IDs.
        public let appIds: [String]?
        /// The maximum number of results to return in a single call. The default value is 100. To retrieve the remaining results, make another call with the returned NextToken value.
        public let maxResults: Int?
        /// The token for the next set of results.
        public let nextToken: String?

        public init(appIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appIds = appIds
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case appIds
            case maxResults
            case nextToken
        }
    }

    public struct ListAppsResponse: AWSDecodableShape {
        /// The application summaries.
        public let apps: [AppSummary]?
        /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(apps: [AppSummary]? = nil, nextToken: String? = nil) {
            self.apps = apps
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case apps
            case nextToken
        }
    }

    public struct NotificationContext: AWSEncodableShape {
        /// The status of the validation.
        public let status: ValidationStatus?
        /// The status message.
        public let statusMessage: String?
        /// The ID of the validation.
        public let validationId: String?

        public init(status: ValidationStatus? = nil, statusMessage: String? = nil, validationId: String? = nil) {
            self.status = status
            self.statusMessage = statusMessage
            self.validationId = validationId
        }

        public func validate(name: String) throws {
            try self.validate(self.statusMessage, name: "statusMessage", parent: name, max: 2500)
            try self.validate(self.validationId, name: "validationId", parent: name, pattern: "^val-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case status
            case statusMessage
            case validationId
        }
    }

    public struct NotifyAppValidationOutputRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String
        /// The notification information.
        public let notificationContext: NotificationContext?

        public init(appId: String, notificationContext: NotificationContext? = nil) {
            self.appId = appId
            self.notificationContext = notificationContext
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^app-[0-9a-f]{17}$")
            try self.notificationContext?.validate(name: "\(name).notificationContext")
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case notificationContext
        }
    }

    public struct NotifyAppValidationOutputResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutAppLaunchConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?
        /// Indicates whether the application is configured to launch automatically after replication is complete.
        public let autoLaunch: Bool?
        /// The name of service role in the customer's account that AWS CloudFormation uses to launch the application.
        public let roleName: String?
        /// Information about the launch configurations for server groups in the application.
        public let serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]?

        public init(appId: String? = nil, autoLaunch: Bool? = nil, roleName: String? = nil, serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]? = nil) {
            self.appId = appId
            self.autoLaunch = autoLaunch
            self.roleName = roleName
            self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
        }

        public func validate(name: String) throws {
            try self.serverGroupLaunchConfigurations?.forEach {
                try $0.validate(name: "\(name).serverGroupLaunchConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case autoLaunch
            case roleName
            case serverGroupLaunchConfigurations
        }
    }

    public struct PutAppLaunchConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutAppReplicationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?
        /// Information about the replication configurations for server groups in the application.
        public let serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]?

        public init(appId: String? = nil, serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]? = nil) {
            self.appId = appId
            self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case serverGroupReplicationConfigurations
        }
    }

    public struct PutAppReplicationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutAppValidationConfigurationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String
        /// The configuration for application validation.
        public let appValidationConfigurations: [AppValidationConfiguration]?
        /// The configuration for instance validation.
        public let serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]?

        public init(appId: String, appValidationConfigurations: [AppValidationConfiguration]? = nil, serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]? = nil) {
            self.appId = appId
            self.appValidationConfigurations = appValidationConfigurations
            self.serverGroupValidationConfigurations = serverGroupValidationConfigurations
        }

        public func validate(name: String) throws {
            try self.validate(self.appId, name: "appId", parent: name, pattern: "^app-[0-9a-f]{17}$")
            try self.appValidationConfigurations?.forEach {
                try $0.validate(name: "\(name).appValidationConfigurations[]")
            }
            try self.serverGroupValidationConfigurations?.forEach {
                try $0.validate(name: "\(name).serverGroupValidationConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case appValidationConfigurations
            case serverGroupValidationConfigurations
        }
    }

    public struct PutAppValidationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ReplicationJob: AWSDecodableShape {
        /// The description of the replication job.
        public let description: String?
        /// Indicates whether the replication job should produce encrypted AMIs.
        public let encrypted: Bool?
        /// The time between consecutive replication runs, in hours.
        public let frequency: Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:    KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public let kmsKeyId: String?
        /// The ID of the latest Amazon Machine Image (AMI).
        public let latestAmiId: String?
        /// The license type to be used for the AMI created by a successful replication run.
        public let licenseType: LicenseType?
        /// The start time of the next replication run.
        public let nextReplicationRunStartTime: Date?
        /// The number of recent AMIs to keep in the customer's account for a replication job. By default, the value is set to zero, meaning that all AMIs are kept.
        public let numberOfRecentAmisToKeep: Int?
        /// The ID of the replication job.
        public let replicationJobId: String?
        /// Information about the replication runs.
        public let replicationRunList: [ReplicationRun]?
        /// The name of the IAM role to be used by AWS SMS.
        public let roleName: String?
        /// Indicates whether to run the replication job one time.
        public let runOnce: Bool?
        /// The seed replication time.
        public let seedReplicationTime: Date?
        /// The ID of the server.
        public let serverId: String?
        /// The type of server.
        public let serverType: ServerType?
        /// The state of the replication job.
        public let state: ReplicationJobState?
        /// The description of the current status of the replication job.
        public let statusMessage: String?
        /// Information about the VM server.
        public let vmServer: VmServer?

        public init(description: String? = nil, encrypted: Bool? = nil, frequency: Int? = nil, kmsKeyId: String? = nil, latestAmiId: String? = nil, licenseType: LicenseType? = nil, nextReplicationRunStartTime: Date? = nil, numberOfRecentAmisToKeep: Int? = nil, replicationJobId: String? = nil, replicationRunList: [ReplicationRun]? = nil, roleName: String? = nil, runOnce: Bool? = nil, seedReplicationTime: Date? = nil, serverId: String? = nil, serverType: ServerType? = nil, state: ReplicationJobState? = nil, statusMessage: String? = nil, vmServer: VmServer? = nil) {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.latestAmiId = latestAmiId
            self.licenseType = licenseType
            self.nextReplicationRunStartTime = nextReplicationRunStartTime
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.replicationJobId = replicationJobId
            self.replicationRunList = replicationRunList
            self.roleName = roleName
            self.runOnce = runOnce
            self.seedReplicationTime = seedReplicationTime
            self.serverId = serverId
            self.serverType = serverType
            self.state = state
            self.statusMessage = statusMessage
            self.vmServer = vmServer
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case encrypted
            case frequency
            case kmsKeyId
            case latestAmiId
            case licenseType
            case nextReplicationRunStartTime
            case numberOfRecentAmisToKeep
            case replicationJobId
            case replicationRunList
            case roleName
            case runOnce
            case seedReplicationTime
            case serverId
            case serverType
            case state
            case statusMessage
            case vmServer
        }
    }

    public struct ReplicationRun: AWSDecodableShape {
        /// The ID of the Amazon Machine Image (AMI) from the replication run.
        public let amiId: String?
        /// The completion time of the last replication run.
        public let completedTime: Date?
        /// The description of the replication run.
        public let description: String?
        /// Indicates whether the replication run should produce an encrypted AMI.
        public let encrypted: Bool?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:   KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is true but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public let kmsKeyId: String?
        /// The ID of the replication run.
        public let replicationRunId: String?
        /// The start time of the next replication run.
        public let scheduledStartTime: Date?
        /// Details about the current stage of the replication run.
        public let stageDetails: ReplicationRunStageDetails?
        /// The state of the replication run.
        public let state: ReplicationRunState?
        /// The description of the current status of the replication job.
        public let statusMessage: String?
        /// The type of replication run.
        public let type: ReplicationRunType?

        public init(amiId: String? = nil, completedTime: Date? = nil, description: String? = nil, encrypted: Bool? = nil, kmsKeyId: String? = nil, replicationRunId: String? = nil, scheduledStartTime: Date? = nil, stageDetails: ReplicationRunStageDetails? = nil, state: ReplicationRunState? = nil, statusMessage: String? = nil, type: ReplicationRunType? = nil) {
            self.amiId = amiId
            self.completedTime = completedTime
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.replicationRunId = replicationRunId
            self.scheduledStartTime = scheduledStartTime
            self.stageDetails = stageDetails
            self.state = state
            self.statusMessage = statusMessage
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case amiId
            case completedTime
            case description
            case encrypted
            case kmsKeyId
            case replicationRunId
            case scheduledStartTime
            case stageDetails
            case state
            case statusMessage
            case type
        }
    }

    public struct ReplicationRunStageDetails: AWSDecodableShape {
        /// The current stage of a replication run.
        public let stage: String?
        /// The progress of the current stage of a replication run.
        public let stageProgress: String?

        public init(stage: String? = nil, stageProgress: String? = nil) {
            self.stage = stage
            self.stageProgress = stageProgress
        }

        private enum CodingKeys: String, CodingKey {
            case stage
            case stageProgress
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket name.
        public let bucket: String?
        /// The Amazon S3 bucket key.
        public let key: String?

        public init(bucket: String? = nil, key: String? = nil) {
            self.bucket = bucket
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.key, name: "key", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket
            case key
        }
    }

    public struct SSMOutput: AWSDecodableShape {
        public let s3Location: S3Location?

        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location
        }
    }

    public struct SSMValidationParameters: AWSEncodableShape & AWSDecodableShape {
        /// The command to run the validation script
        public let command: String?
        /// The timeout interval, in seconds.
        public let executionTimeoutSeconds: Int?
        /// The ID of the instance. The instance must have the following tag: UserForSMSApplicationValidation=true.
        public let instanceId: String?
        /// The name of the S3 bucket for output.
        public let outputS3BucketName: String?
        /// The type of validation script.
        public let scriptType: ScriptType?
        /// The location of the validation script.
        public let source: Source?

        public init(command: String? = nil, executionTimeoutSeconds: Int? = nil, instanceId: String? = nil, outputS3BucketName: String? = nil, scriptType: ScriptType? = nil, source: Source? = nil) {
            self.command = command
            self.executionTimeoutSeconds = executionTimeoutSeconds
            self.instanceId = instanceId
            self.outputS3BucketName = outputS3BucketName
            self.scriptType = scriptType
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.command, name: "command", parent: name, max: 64000)
            try self.validate(self.command, name: "command", parent: name, min: 1)
            try self.validate(self.executionTimeoutSeconds, name: "executionTimeoutSeconds", parent: name, max: 28800)
            try self.validate(self.executionTimeoutSeconds, name: "executionTimeoutSeconds", parent: name, min: 60)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "(^i-(\\w{8}|\\w{17})$)|(^mi-\\w{17}$)")
            try self.source?.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case command
            case executionTimeoutSeconds
            case instanceId
            case outputS3BucketName
            case scriptType
            case source
        }
    }

    public struct Server: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the replication job.
        public let replicationJobId: String?
        /// Indicates whether the replication job is deleted or failed.
        public let replicationJobTerminated: Bool?
        /// The ID of the server.
        public let serverId: String?
        /// The type of server.
        public let serverType: ServerType?
        /// Information about the VM server.
        public let vmServer: VmServer?

        public init(replicationJobId: String? = nil, replicationJobTerminated: Bool? = nil, serverId: String? = nil, serverType: ServerType? = nil, vmServer: VmServer? = nil) {
            self.replicationJobId = replicationJobId
            self.replicationJobTerminated = replicationJobTerminated
            self.serverId = serverId
            self.serverType = serverType
            self.vmServer = vmServer
        }

        private enum CodingKeys: String, CodingKey {
            case replicationJobId
            case replicationJobTerminated
            case serverId
            case serverType
            case vmServer
        }
    }

    public struct ServerGroup: AWSEncodableShape & AWSDecodableShape {
        /// The name of a server group.
        public let name: String?
        /// The ID of a server group.
        public let serverGroupId: String?
        /// The servers that belong to a server group.
        public let serverList: [Server]?

        public init(name: String? = nil, serverGroupId: String? = nil, serverList: [Server]? = nil) {
            self.name = name
            self.serverGroupId = serverGroupId
            self.serverList = serverList
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case serverGroupId
            case serverList
        }
    }

    public struct ServerGroupLaunchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The launch order of servers in the server group.
        public let launchOrder: Int?
        /// The ID of the server group with which the launch configuration is associated.
        public let serverGroupId: String?
        /// The launch configuration for servers in the server group.
        public let serverLaunchConfigurations: [ServerLaunchConfiguration]?

        public init(launchOrder: Int? = nil, serverGroupId: String? = nil, serverLaunchConfigurations: [ServerLaunchConfiguration]? = nil) {
            self.launchOrder = launchOrder
            self.serverGroupId = serverGroupId
            self.serverLaunchConfigurations = serverLaunchConfigurations
        }

        public func validate(name: String) throws {
            try self.serverLaunchConfigurations?.forEach {
                try $0.validate(name: "\(name).serverLaunchConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case launchOrder
            case serverGroupId
            case serverLaunchConfigurations
        }
    }

    public struct ServerGroupReplicationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the server group with which this replication configuration is associated.
        public let serverGroupId: String?
        /// The replication configuration for servers in the server group.
        public let serverReplicationConfigurations: [ServerReplicationConfiguration]?

        public init(serverGroupId: String? = nil, serverReplicationConfigurations: [ServerReplicationConfiguration]? = nil) {
            self.serverGroupId = serverGroupId
            self.serverReplicationConfigurations = serverReplicationConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case serverGroupId
            case serverReplicationConfigurations
        }
    }

    public struct ServerGroupValidationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the server group.
        public let serverGroupId: String?
        /// The validation configuration.
        public let serverValidationConfigurations: [ServerValidationConfiguration]?

        public init(serverGroupId: String? = nil, serverValidationConfigurations: [ServerValidationConfiguration]? = nil) {
            self.serverGroupId = serverGroupId
            self.serverValidationConfigurations = serverValidationConfigurations
        }

        public func validate(name: String) throws {
            try self.serverValidationConfigurations?.forEach {
                try $0.validate(name: "\(name).serverValidationConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case serverGroupId
            case serverValidationConfigurations
        }
    }

    public struct ServerLaunchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether a publicly accessible IP address is created when launching the server.
        public let associatePublicIpAddress: Bool?
        public let configureScript: S3Location?
        /// The type of configuration script.
        public let configureScriptType: ScriptType?
        /// The name of the Amazon EC2 SSH key to be used for connecting to the launched server.
        public let ec2KeyName: String?
        /// The name of the IAM instance profile.
        public let iamInstanceProfileName: String?
        /// The instance type to use when launching the server.
        public let instanceType: String?
        /// The logical ID of the server in the AWS CloudFormation template.
        public let logicalId: String?
        /// The ID of the security group that applies to the launched server.
        public let securityGroup: String?
        /// The ID of the server with which the launch configuration is associated.
        public let server: Server?
        /// The ID of the subnet the server should be launched into.
        public let subnet: String?
        /// Location of the user-data script to be executed when launching the server.
        public let userData: UserData?
        /// The ID of the VPC into which the server should be launched.
        public let vpc: String?

        public init(associatePublicIpAddress: Bool? = nil, configureScript: S3Location? = nil, configureScriptType: ScriptType? = nil, ec2KeyName: String? = nil, iamInstanceProfileName: String? = nil, instanceType: String? = nil, logicalId: String? = nil, securityGroup: String? = nil, server: Server? = nil, subnet: String? = nil, userData: UserData? = nil, vpc: String? = nil) {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.configureScript = configureScript
            self.configureScriptType = configureScriptType
            self.ec2KeyName = ec2KeyName
            self.iamInstanceProfileName = iamInstanceProfileName
            self.instanceType = instanceType
            self.logicalId = logicalId
            self.securityGroup = securityGroup
            self.server = server
            self.subnet = subnet
            self.userData = userData
            self.vpc = vpc
        }

        public func validate(name: String) throws {
            try self.configureScript?.validate(name: "\(name).configureScript")
            try self.userData?.validate(name: "\(name).userData")
        }

        private enum CodingKeys: String, CodingKey {
            case associatePublicIpAddress
            case configureScript
            case configureScriptType
            case ec2KeyName
            case iamInstanceProfileName
            case instanceType
            case logicalId
            case securityGroup
            case server
            case subnet
            case userData
            case vpc
        }
    }

    public struct ServerReplicationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the server with which this replication configuration is associated.
        public let server: Server?
        /// The parameters for replicating the server.
        public let serverReplicationParameters: ServerReplicationParameters?

        public init(server: Server? = nil, serverReplicationParameters: ServerReplicationParameters? = nil) {
            self.server = server
            self.serverReplicationParameters = serverReplicationParameters
        }

        private enum CodingKeys: String, CodingKey {
            case server
            case serverReplicationParameters
        }
    }

    public struct ServerReplicationParameters: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the replication job produces encrypted AMIs.
        public let encrypted: Bool?
        /// The frequency of creating replication jobs for the server.
        public let frequency: Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:   KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public let kmsKeyId: String?
        /// The license type for creating a replication job for the server.
        public let licenseType: LicenseType?
        /// The number of recent AMIs to keep when creating a replication job for this server.
        public let numberOfRecentAmisToKeep: Int?
        /// Indicates whether to run the replication job one time.
        public let runOnce: Bool?
        /// The seed time for creating a replication job for the server.
        public let seedTime: Date?

        public init(encrypted: Bool? = nil, frequency: Int? = nil, kmsKeyId: String? = nil, licenseType: LicenseType? = nil, numberOfRecentAmisToKeep: Int? = nil, runOnce: Bool? = nil, seedTime: Date? = nil) {
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.runOnce = runOnce
            self.seedTime = seedTime
        }

        private enum CodingKeys: String, CodingKey {
            case encrypted
            case frequency
            case kmsKeyId
            case licenseType
            case numberOfRecentAmisToKeep
            case runOnce
            case seedTime
        }
    }

    public struct ServerValidationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the configuration.
        public let name: String?
        public let server: Server?
        /// The validation strategy.
        public let serverValidationStrategy: ServerValidationStrategy?
        /// The validation parameters.
        public let userDataValidationParameters: UserDataValidationParameters?
        /// The ID of the validation.
        public let validationId: String?

        public init(name: String? = nil, server: Server? = nil, serverValidationStrategy: ServerValidationStrategy? = nil, userDataValidationParameters: UserDataValidationParameters? = nil, validationId: String? = nil) {
            self.name = name
            self.server = server
            self.serverValidationStrategy = serverValidationStrategy
            self.userDataValidationParameters = userDataValidationParameters
            self.validationId = validationId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S]+$")
            try self.userDataValidationParameters?.validate(name: "\(name).userDataValidationParameters")
            try self.validate(self.validationId, name: "validationId", parent: name, pattern: "^val-[0-9a-f]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case server
            case serverValidationStrategy
            case userDataValidationParameters
            case validationId
        }
    }

    public struct ServerValidationOutput: AWSDecodableShape {
        public let server: Server?

        public init(server: Server? = nil) {
            self.server = server
        }

        private enum CodingKeys: String, CodingKey {
            case server
        }
    }

    public struct Source: AWSEncodableShape & AWSDecodableShape {
        public let s3Location: S3Location?

        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location
        }
    }

    public struct StartAppReplicationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct StartAppReplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartOnDemandAppReplicationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String
        /// The description of the replication run.
        public let description: String?

        public init(appId: String, description: String? = nil) {
            self.appId = appId
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case description
        }
    }

    public struct StartOnDemandAppReplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartOnDemandReplicationRunRequest: AWSEncodableShape {
        /// The description of the replication run.
        public let description: String?
        /// The ID of the replication job.
        public let replicationJobId: String

        public init(description: String? = nil, replicationJobId: String) {
            self.description = description
            self.replicationJobId = replicationJobId
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case replicationJobId
        }
    }

    public struct StartOnDemandReplicationRunResponse: AWSDecodableShape {
        /// The ID of the replication run.
        public let replicationRunId: String?

        public init(replicationRunId: String? = nil) {
            self.replicationRunId = replicationRunId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationRunId
        }
    }

    public struct StopAppReplicationRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct StopAppReplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key.
        public let key: String?
        /// The tag value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct TerminateAppRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?

        public init(appId: String? = nil) {
            self.appId = appId
        }

        private enum CodingKeys: String, CodingKey {
            case appId
        }
    }

    public struct TerminateAppResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAppRequest: AWSEncodableShape {
        /// The ID of the application.
        public let appId: String?
        /// The new description of the application.
        public let description: String?
        /// The new name of the application.
        public let name: String?
        /// The name of the service role in the customer's account used by AWS SMS.
        public let roleName: String?
        /// The server groups in the application to update.
        public let serverGroups: [ServerGroup]?
        /// The tags to associate with the application.
        public let tags: [Tag]?

        public init(appId: String? = nil, description: String? = nil, name: String? = nil, roleName: String? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appId = appId
            self.description = description
            self.name = name
            self.roleName = roleName
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appId
            case description
            case name
            case roleName
            case serverGroups
            case tags
        }
    }

    public struct UpdateAppResponse: AWSDecodableShape {
        /// A summary description of the application.
        public let appSummary: AppSummary?
        /// The updated server groups in the application.
        public let serverGroups: [ServerGroup]?
        /// The tags associated with the application.
        public let tags: [Tag]?

        public init(appSummary: AppSummary? = nil, serverGroups: [ServerGroup]? = nil, tags: [Tag]? = nil) {
            self.appSummary = appSummary
            self.serverGroups = serverGroups
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appSummary
            case serverGroups
            case tags
        }
    }

    public struct UpdateReplicationJobRequest: AWSEncodableShape {
        /// The description of the replication job.
        public let description: String?
        /// When true, the replication job produces encrypted AMIs. For more information, KmsKeyId.
        public let encrypted: Bool?
        /// The time between consecutive replication runs, in hours.
        public let frequency: Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs.  This value can be any of the following:   KMS key ID   KMS key alias   ARN referring to the KMS key ID   ARN referring to the KMS key alias   If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public let kmsKeyId: String?
        /// The license type to be used for the AMI created by a successful replication run.
        public let licenseType: LicenseType?
        /// The start time of the next replication run.
        public let nextReplicationRunStartTime: Date?
        /// The maximum number of SMS-created AMIs to retain. The oldest is deleted after the maximum number is reached and a new AMI is created.
        public let numberOfRecentAmisToKeep: Int?
        /// The ID of the replication job.
        public let replicationJobId: String
        /// The name of the IAM role to be used by AWS SMS.
        public let roleName: String?

        public init(description: String? = nil, encrypted: Bool? = nil, frequency: Int? = nil, kmsKeyId: String? = nil, licenseType: LicenseType? = nil, nextReplicationRunStartTime: Date? = nil, numberOfRecentAmisToKeep: Int? = nil, replicationJobId: String, roleName: String? = nil) {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.nextReplicationRunStartTime = nextReplicationRunStartTime
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.replicationJobId = replicationJobId
            self.roleName = roleName
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case encrypted
            case frequency
            case kmsKeyId
            case licenseType
            case nextReplicationRunStartTime
            case numberOfRecentAmisToKeep
            case replicationJobId
            case roleName
        }
    }

    public struct UpdateReplicationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserData: AWSEncodableShape & AWSDecodableShape {
        /// Amazon S3 location of the user-data script.
        public let s3Location: S3Location?

        public init(s3Location: S3Location? = nil) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location
        }
    }

    public struct UserDataValidationParameters: AWSEncodableShape & AWSDecodableShape {
        /// The type of validation script.
        public let scriptType: ScriptType?
        /// The location of the validation script.
        public let source: Source?

        public init(scriptType: ScriptType? = nil, source: Source? = nil) {
            self.scriptType = scriptType
            self.source = source
        }

        public func validate(name: String) throws {
            try self.source?.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case scriptType
            case source
        }
    }

    public struct ValidationOutput: AWSDecodableShape {
        /// The output from validating an application.
        public let appValidationOutput: AppValidationOutput?
        /// The latest time that the validation was performed.
        public let latestValidationTime: Date?
        /// The name of the validation.
        public let name: String?
        /// The output from validation an instance.
        public let serverValidationOutput: ServerValidationOutput?
        /// The status of the validation.
        public let status: ValidationStatus?
        /// The status message.
        public let statusMessage: String?
        /// The ID of the validation.
        public let validationId: String?

        public init(appValidationOutput: AppValidationOutput? = nil, latestValidationTime: Date? = nil, name: String? = nil, serverValidationOutput: ServerValidationOutput? = nil, status: ValidationStatus? = nil, statusMessage: String? = nil, validationId: String? = nil) {
            self.appValidationOutput = appValidationOutput
            self.latestValidationTime = latestValidationTime
            self.name = name
            self.serverValidationOutput = serverValidationOutput
            self.status = status
            self.statusMessage = statusMessage
            self.validationId = validationId
        }

        private enum CodingKeys: String, CodingKey {
            case appValidationOutput
            case latestValidationTime
            case name
            case serverValidationOutput
            case status
            case statusMessage
            case validationId
        }
    }

    public struct VmServer: AWSEncodableShape & AWSDecodableShape {
        /// The name of the VM manager.
        public let vmManagerName: String?
        /// The type of VM management product.
        public let vmManagerType: VmManagerType?
        /// The name of the VM.
        public let vmName: String?
        /// The VM folder path in the vCenter Server virtual machine inventory tree.
        public let vmPath: String?
        /// The VM server location.
        public let vmServerAddress: VmServerAddress?

        public init(vmManagerName: String? = nil, vmManagerType: VmManagerType? = nil, vmName: String? = nil, vmPath: String? = nil, vmServerAddress: VmServerAddress? = nil) {
            self.vmManagerName = vmManagerName
            self.vmManagerType = vmManagerType
            self.vmName = vmName
            self.vmPath = vmPath
            self.vmServerAddress = vmServerAddress
        }

        private enum CodingKeys: String, CodingKey {
            case vmManagerName
            case vmManagerType
            case vmName
            case vmPath
            case vmServerAddress
        }
    }

    public struct VmServerAddress: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the VM.
        public let vmId: String?
        /// The ID of the VM manager.
        public let vmManagerId: String?

        public init(vmId: String? = nil, vmManagerId: String? = nil) {
            self.vmId = vmId
            self.vmManagerId = vmManagerId
        }

        private enum CodingKeys: String, CodingKey {
            case vmId
            case vmManagerId
        }
    }
}
