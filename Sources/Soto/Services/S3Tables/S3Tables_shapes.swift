//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension S3Tables {
    // MARK: Enums

    public enum IcebergCompactionStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "auto"
        case binpack = "binpack"
        case sort = "sort"
        case zorder = "z-order"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case failed = "Failed"
        case notYetRun = "Not_Yet_Run"
        case successful = "Successful"
        public var description: String { return self.rawValue }
    }

    public enum MaintenanceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case enabled = "enabled"
        public var description: String { return self.rawValue }
    }

    public enum OpenTableFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iceberg = "ICEBERG"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "completed"
        case failed = "failed"
        case pending = "pending"
        public var description: String { return self.rawValue }
    }

    public enum SSEAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aes256 = "AES256"
        case awsKms = "aws:kms"
        public var description: String { return self.rawValue }
    }

    public enum StorageClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case intelligentTiering = "INTELLIGENT_TIERING"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum TableBucketMaintenanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case icebergUnreferencedFileRemoval = "icebergUnreferencedFileRemoval"
        public var description: String { return self.rawValue }
    }

    public enum TableBucketType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "aws"
        case customer = "customer"
        public var description: String { return self.rawValue }
    }

    public enum TableMaintenanceJobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case icebergCompaction = "icebergCompaction"
        case icebergSnapshotManagement = "icebergSnapshotManagement"
        case icebergUnreferencedFileRemoval = "icebergUnreferencedFileRemoval"
        public var description: String { return self.rawValue }
    }

    public enum TableMaintenanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case icebergCompaction = "icebergCompaction"
        case icebergSnapshotManagement = "icebergSnapshotManagement"
        public var description: String { return self.rawValue }
    }

    public enum TableRecordExpirationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case failed = "Failed"
        case notYetRun = "NotYetRun"
        case successful = "Successful"
        public var description: String { return self.rawValue }
    }

    public enum TableRecordExpirationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "disabled"
        case enabled = "enabled"
        public var description: String { return self.rawValue }
    }

    public enum TableType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "aws"
        case customer = "customer"
        public var description: String { return self.rawValue }
    }

    public enum TableMaintenanceSettings: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Contains details about the Iceberg compaction settings for the table.
        case icebergCompaction(IcebergCompactionSettings)
        /// Contains details about the Iceberg snapshot management settings for the table.
        case icebergSnapshotManagement(IcebergSnapshotManagementSettings)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .icebergCompaction:
                let value = try container.decode(IcebergCompactionSettings.self, forKey: .icebergCompaction)
                self = .icebergCompaction(value)
            case .icebergSnapshotManagement:
                let value = try container.decode(IcebergSnapshotManagementSettings.self, forKey: .icebergSnapshotManagement)
                self = .icebergSnapshotManagement(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .icebergCompaction(let value):
                try container.encode(value, forKey: .icebergCompaction)
            case .icebergSnapshotManagement(let value):
                try container.encode(value, forKey: .icebergSnapshotManagement)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .icebergCompaction(let value):
                try value.validate(name: "\(name).icebergCompaction")
            case .icebergSnapshotManagement(let value):
                try value.validate(name: "\(name).icebergSnapshotManagement")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case icebergCompaction = "icebergCompaction"
            case icebergSnapshotManagement = "icebergSnapshotManagement"
        }
    }

    // MARK: Shapes

    public struct CreateNamespaceRequest: AWSEncodableShape {
        /// A name for the namespace.
        public let namespace: [String]
        /// The Amazon Resource Name (ARN) of the table bucket to create the namespace in.
        public let tableBucketARN: String

        @inlinable
        public init(namespace: [String], tableBucketARN: String) {
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.namespace, forKey: .namespace)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.namespace.forEach {
                try validate($0, name: "namespace[]", parent: name, max: 255)
                try validate($0, name: "namespace[]", parent: name, min: 1)
                try validate($0, name: "namespace[]", parent: name, pattern: "^[0-9a-z_]*$")
            }
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "namespace"
        }
    }

    public struct CreateNamespaceResponse: AWSDecodableShape {
        /// The name of the namespace.
        public let namespace: [String]
        /// The Amazon Resource Name (ARN) of the table bucket the namespace was created in.
        public let tableBucketARN: String

        @inlinable
        public init(namespace: [String], tableBucketARN: String) {
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "namespace"
            case tableBucketARN = "tableBucketARN"
        }
    }

    public struct CreateTableBucketRequest: AWSEncodableShape {
        /// The encryption configuration to use for the table bucket. This configuration specifies the default encryption settings that will be applied to all tables created in this bucket unless overridden at the table level. The configuration includes the encryption algorithm and, if using SSE-KMS, the KMS key to use.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The name for the table bucket.
        public let name: String
        /// The default storage class configuration for the table bucket. This configuration will be applied to all new tables created in this bucket unless overridden at the table level. If not specified, the service default storage class will be used.
        public let storageClassConfiguration: StorageClassConfiguration?
        /// A map of user-defined tags that you would like to apply to the table bucket that you are creating. A tag is a key-value pair that you apply to your resources. Tags can help you organize and control access to resources. For more information, see Tagging for cost allocation or attribute-based access control (ABAC).  You must have the s3tables:TagResource permission in addition to s3tables:CreateTableBucket permisson to create a table bucket with tags.
        public let tags: [String: String]?

        @inlinable
        public init(encryptionConfiguration: EncryptionConfiguration? = nil, name: String, storageClassConfiguration: StorageClassConfiguration? = nil, tags: [String: String]? = nil) {
            self.encryptionConfiguration = encryptionConfiguration
            self.name = name
            self.storageClassConfiguration = storageClassConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "encryptionConfiguration"
            case name = "name"
            case storageClassConfiguration = "storageClassConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateTableBucketResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct CreateTableRequest: AWSEncodableShape {
        /// The encryption configuration to use for the table. This configuration specifies the encryption algorithm and, if using SSE-KMS, the KMS key to use for encrypting the table.   If you choose SSE-KMS encryption you must grant the S3 Tables maintenance principal access to your KMS key. For more information, see Permissions requirements for S3 Tables SSE-KMS encryption.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The format for the table.
        public let format: OpenTableFormat
        /// The metadata for the table.
        public let metadata: TableMetadata?
        /// The name for the table.
        public let name: String
        /// The namespace to associated with the table.
        public let namespace: String
        /// The storage class configuration for the table. If not specified, the table inherits the storage class configuration from its table bucket. Specify this parameter to override the bucket's default storage class for this table.
        public let storageClassConfiguration: StorageClassConfiguration?
        /// The Amazon Resource Name (ARN) of the table bucket to create the table in.
        public let tableBucketARN: String
        /// A map of user-defined tags that you would like to apply to the table that you are creating. A tag is a key-value pair that you apply to your resources. Tags can help you organize, track costs for, and control access to resources. For more information, see Tagging for cost allocation or attribute-based access control (ABAC).  You must have the s3tables:TagResource permission in addition to s3tables:CreateTable permission to create a table with tags.
        public let tags: [String: String]?

        @inlinable
        public init(encryptionConfiguration: EncryptionConfiguration? = nil, format: OpenTableFormat, metadata: TableMetadata? = nil, name: String, namespace: String, storageClassConfiguration: StorageClassConfiguration? = nil, tableBucketARN: String, tags: [String: String]? = nil) {
            self.encryptionConfiguration = encryptionConfiguration
            self.format = format
            self.metadata = metadata
            self.name = name
            self.namespace = namespace
            self.storageClassConfiguration = storageClassConfiguration
            self.tableBucketARN = tableBucketARN
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.encryptionConfiguration, forKey: .encryptionConfiguration)
            try container.encode(self.format, forKey: .format)
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encode(self.name, forKey: .name)
            request.encodePath(self.namespace, key: "namespace")
            try container.encodeIfPresent(self.storageClassConfiguration, forKey: .storageClassConfiguration)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "encryptionConfiguration"
            case format = "format"
            case metadata = "metadata"
            case name = "name"
            case storageClassConfiguration = "storageClassConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateTableResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the table.
        public let tableARN: String
        /// The version token of the table.
        public let versionToken: String

        @inlinable
        public init(tableARN: String, versionToken: String) {
            self.tableARN = tableARN
            self.versionToken = versionToken
        }

        private enum CodingKeys: String, CodingKey {
            case tableARN = "tableARN"
            case versionToken = "versionToken"
        }
    }

    public struct DeleteNamespaceRequest: AWSEncodableShape {
        /// The name of the namespace.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket associated with the namespace.
        public let tableBucketARN: String

        @inlinable
        public init(namespace: String, tableBucketARN: String) {
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTableBucketEncryptionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTableBucketMetricsConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTableBucketPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTableBucketReplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String
        /// A version token from a previous GetTableBucketReplication call. Use this token to ensure you're deleting the expected version of the configuration.
        public let versionToken: String?

        @inlinable
        public init(tableBucketARN: String, versionToken: String? = nil) {
            self.tableBucketARN = tableBucketARN
            self.versionToken = versionToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.tableBucketARN, key: "tableBucketARN")
            request.encodeQuery(self.versionToken, key: "versionToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
            try self.validate(self.versionToken, name: "versionToken", parent: name, max: 2048)
            try self.validate(self.versionToken, name: "versionToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTableBucketRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTablePolicyRequest: AWSEncodableShape {
        /// The table name.
        public let name: String
        /// The namespace associated with the table.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket that contains the table.
        public let tableBucketARN: String

        @inlinable
        public init(name: String, namespace: String, tableBucketARN: String) {
            self.name = name
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTableReplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table.
        public let tableArn: String
        /// A version token from a previous GetTableReplication call. Use this token to ensure you're deleting the expected version of the configuration.
        public let versionToken: String

        @inlinable
        public init(tableArn: String, versionToken: String) {
            self.tableArn = tableArn
            self.versionToken = versionToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.tableArn, key: "tableArn")
            request.encodeQuery(self.versionToken, key: "versionToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableArn, name: "tableArn", parent: name, max: 2048)
            try self.validate(self.tableArn, name: "tableArn", parent: name, min: 1)
            try self.validate(self.tableArn, name: "tableArn", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63}/table/[a-zA-Z0-9-_]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTableRequest: AWSEncodableShape {
        /// The name of the table.
        public let name: String
        /// The namespace associated with the table.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket that contains the table.
        public let tableBucketARN: String
        /// The version token of the table.
        public let versionToken: String?

        @inlinable
        public init(name: String, namespace: String, tableBucketARN: String, versionToken: String? = nil) {
            self.name = name
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
            self.versionToken = versionToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
            request.encodeQuery(self.versionToken, key: "versionToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
            try self.validate(self.versionToken, name: "versionToken", parent: name, max: 2048)
            try self.validate(self.versionToken, name: "versionToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct EncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key to use for encryption. This field is required only when sseAlgorithm is set to aws:kms.
        public let kmsKeyArn: String?
        /// The server-side encryption algorithm to use. Valid values are AES256 for S3-managed encryption keys, or aws:kms for Amazon Web Services KMS-managed encryption keys. If you choose SSE-KMS encryption you must grant the S3 Tables maintenance principal access to your KMS key. For more information, see Permissions requirements for S3 Tables SSE-KMS encryption.
        public let sseAlgorithm: SSEAlgorithm

        @inlinable
        public init(kmsKeyArn: String? = nil, sseAlgorithm: SSEAlgorithm) {
            self.kmsKeyArn = kmsKeyArn
            self.sseAlgorithm = sseAlgorithm
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
            case sseAlgorithm = "sseAlgorithm"
        }
    }

    public struct GetNamespaceRequest: AWSEncodableShape {
        /// The name of the namespace.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(namespace: String, tableBucketARN: String) {
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNamespaceResponse: AWSDecodableShape {
        /// The date and time the namespace was created at.
        public let createdAt: Date
        /// The ID of the account that created the namespace.
        public let createdBy: String
        /// The name of the namespace.
        public let namespace: [String]
        /// The unique identifier of the namespace.
        public let namespaceId: String?
        /// The ID of the account that owns the namespcace.
        public let ownerAccountId: String
        /// The unique identifier of the table bucket containing this namespace.
        public let tableBucketId: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, namespace: [String], namespaceId: String? = nil, ownerAccountId: String, tableBucketId: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.namespace = namespace
            self.namespaceId = namespaceId
            self.ownerAccountId = ownerAccountId
            self.tableBucketId = tableBucketId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case namespace = "namespace"
            case namespaceId = "namespaceId"
            case ownerAccountId = "ownerAccountId"
            case tableBucketId = "tableBucketId"
        }
    }

    public struct GetTableBucketEncryptionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableBucketEncryptionResponse: AWSDecodableShape {
        /// The encryption configuration for the table bucket.
        public let encryptionConfiguration: EncryptionConfiguration

        @inlinable
        public init(encryptionConfiguration: EncryptionConfiguration) {
            self.encryptionConfiguration = encryptionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "encryptionConfiguration"
        }
    }

    public struct GetTableBucketMaintenanceConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket associated with the maintenance configuration.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableBucketMaintenanceConfigurationResponse: AWSDecodableShape {
        /// Details about the maintenance configuration for the table bucket.
        public let configuration: [TableBucketMaintenanceType: TableBucketMaintenanceConfigurationValue]
        /// The Amazon Resource Name (ARN) of the table bucket associated with the maintenance configuration.
        public let tableBucketARN: String

        @inlinable
        public init(configuration: [TableBucketMaintenanceType: TableBucketMaintenanceConfigurationValue], tableBucketARN: String) {
            self.configuration = configuration
            self.tableBucketARN = tableBucketARN
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case tableBucketARN = "tableBucketARN"
        }
    }

    public struct GetTableBucketMetricsConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableBucketMetricsConfigurationResponse: AWSDecodableShape {
        /// The unique identifier of the metrics configuration.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(id: String? = nil, tableBucketARN: String) {
            self.id = id
            self.tableBucketARN = tableBucketARN
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case tableBucketARN = "tableBucketARN"
        }
    }

    public struct GetTableBucketPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableBucketPolicyResponse: AWSDecodableShape {
        /// The JSON that defines the policy.
        public let resourcePolicy: String

        @inlinable
        public init(resourcePolicy: String) {
            self.resourcePolicy = resourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePolicy = "resourcePolicy"
        }
    }

    public struct GetTableBucketReplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableBucketReplicationResponse: AWSDecodableShape {
        /// The replication configuration for the table bucket, including the IAM role and replication rules.
        public let configuration: TableBucketReplicationConfiguration
        /// A version token that represents the current state of the replication configuration. Use this token when updating the configuration to ensure consistency.
        public let versionToken: String

        @inlinable
        public init(configuration: TableBucketReplicationConfiguration, versionToken: String) {
            self.configuration = configuration
            self.versionToken = versionToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case versionToken = "versionToken"
        }
    }

    public struct GetTableBucketRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableBucketResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let arn: String
        /// The date and time the table bucket was created.
        public let createdAt: Date
        /// The name of the table bucket
        public let name: String
        /// The ID of the account that owns the table bucket.
        public let ownerAccountId: String
        /// The unique identifier of the table bucket.
        public let tableBucketId: String?
        /// The type of the table bucket.
        public let type: TableBucketType?

        @inlinable
        public init(arn: String, createdAt: Date, name: String, ownerAccountId: String, tableBucketId: String? = nil, type: TableBucketType? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.tableBucketId = tableBucketId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case name = "name"
            case ownerAccountId = "ownerAccountId"
            case tableBucketId = "tableBucketId"
            case type = "type"
        }
    }

    public struct GetTableBucketStorageClassRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableBucketStorageClassResponse: AWSDecodableShape {
        /// The storage class configuration for the table bucket.
        public let storageClassConfiguration: StorageClassConfiguration

        @inlinable
        public init(storageClassConfiguration: StorageClassConfiguration) {
            self.storageClassConfiguration = storageClassConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case storageClassConfiguration = "storageClassConfiguration"
        }
    }

    public struct GetTableEncryptionRequest: AWSEncodableShape {
        /// The name of the table.
        public let name: String
        /// The namespace associated with the table.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket containing the table.
        public let tableBucketARN: String

        @inlinable
        public init(name: String, namespace: String, tableBucketARN: String) {
            self.name = name
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableEncryptionResponse: AWSDecodableShape {
        /// The encryption configuration for the table.
        public let encryptionConfiguration: EncryptionConfiguration

        @inlinable
        public init(encryptionConfiguration: EncryptionConfiguration) {
            self.encryptionConfiguration = encryptionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "encryptionConfiguration"
        }
    }

    public struct GetTableMaintenanceConfigurationRequest: AWSEncodableShape {
        /// The name of the table.
        public let name: String
        /// The namespace associated with the table.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(name: String, namespace: String, tableBucketARN: String) {
            self.name = name
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableMaintenanceConfigurationResponse: AWSDecodableShape {
        /// Details about the maintenance configuration for the table bucket.
        public let configuration: [TableMaintenanceType: TableMaintenanceConfigurationValue]
        /// The Amazon Resource Name (ARN) of the table.
        public let tableARN: String

        @inlinable
        public init(configuration: [TableMaintenanceType: TableMaintenanceConfigurationValue], tableARN: String) {
            self.configuration = configuration
            self.tableARN = tableARN
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case tableARN = "tableARN"
        }
    }

    public struct GetTableMaintenanceJobStatusRequest: AWSEncodableShape {
        /// The name of the table containing the maintenance job status you want to check.
        public let name: String
        /// The name of the namespace the table is associated with.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(name: String, namespace: String, tableBucketARN: String) {
            self.name = name
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableMaintenanceJobStatusResponse: AWSDecodableShape {
        /// The status of the maintenance job.
        public let status: [TableMaintenanceJobType: TableMaintenanceJobStatusValue]
        /// The Amazon Resource Name (ARN) of the table.
        public let tableARN: String

        @inlinable
        public init(status: [TableMaintenanceJobType: TableMaintenanceJobStatusValue], tableARN: String) {
            self.status = status
            self.tableARN = tableARN
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case tableARN = "tableARN"
        }
    }

    public struct GetTableMetadataLocationRequest: AWSEncodableShape {
        /// The name of the table.
        public let name: String
        /// The namespace of the table.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(name: String, namespace: String, tableBucketARN: String) {
            self.name = name
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableMetadataLocationResponse: AWSDecodableShape {
        /// The metadata location.
        public let metadataLocation: String?
        /// The version token.
        public let versionToken: String
        /// The warehouse location.
        public let warehouseLocation: String

        @inlinable
        public init(metadataLocation: String? = nil, versionToken: String, warehouseLocation: String) {
            self.metadataLocation = metadataLocation
            self.versionToken = versionToken
            self.warehouseLocation = warehouseLocation
        }

        private enum CodingKeys: String, CodingKey {
            case metadataLocation = "metadataLocation"
            case versionToken = "versionToken"
            case warehouseLocation = "warehouseLocation"
        }
    }

    public struct GetTablePolicyRequest: AWSEncodableShape {
        /// The name of the table.
        public let name: String
        /// The namespace associated with the table.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket that contains the table.
        public let tableBucketARN: String

        @inlinable
        public init(name: String, namespace: String, tableBucketARN: String) {
            self.name = name
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTablePolicyResponse: AWSDecodableShape {
        /// The JSON that defines the policy.
        public let resourcePolicy: String

        @inlinable
        public init(resourcePolicy: String) {
            self.resourcePolicy = resourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePolicy = "resourcePolicy"
        }
    }

    public struct GetTableRecordExpirationConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table.
        public let tableArn: String

        @inlinable
        public init(tableArn: String) {
            self.tableArn = tableArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.tableArn, key: "tableArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableArn, name: "tableArn", parent: name, max: 2048)
            try self.validate(self.tableArn, name: "tableArn", parent: name, min: 1)
            try self.validate(self.tableArn, name: "tableArn", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63}/table/[a-zA-Z0-9-_]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableRecordExpirationConfigurationResponse: AWSDecodableShape {
        /// The record expiration configuration for the table, including the status and retention settings.
        public let configuration: TableRecordExpirationConfigurationValue

        @inlinable
        public init(configuration: TableRecordExpirationConfigurationValue) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
        }
    }

    public struct GetTableRecordExpirationJobStatusRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table.
        public let tableArn: String

        @inlinable
        public init(tableArn: String) {
            self.tableArn = tableArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.tableArn, key: "tableArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableArn, name: "tableArn", parent: name, max: 2048)
            try self.validate(self.tableArn, name: "tableArn", parent: name, min: 1)
            try self.validate(self.tableArn, name: "tableArn", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63}/table/[a-zA-Z0-9-_]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableRecordExpirationJobStatusResponse: AWSDecodableShape {
        /// If the job failed, this field contains an error message describing the failure reason.
        public let failureMessage: String?
        /// The timestamp when the expiration job was last executed.
        public let lastRunTimestamp: Date?
        /// Metrics about the most recent expiration job execution, including the number of records and files deleted.
        public let metrics: TableRecordExpirationJobMetrics?
        /// The current status of the most recent expiration job.
        public let status: TableRecordExpirationJobStatus

        @inlinable
        public init(failureMessage: String? = nil, lastRunTimestamp: Date? = nil, metrics: TableRecordExpirationJobMetrics? = nil, status: TableRecordExpirationJobStatus) {
            self.failureMessage = failureMessage
            self.lastRunTimestamp = lastRunTimestamp
            self.metrics = metrics
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case failureMessage = "failureMessage"
            case lastRunTimestamp = "lastRunTimestamp"
            case metrics = "metrics"
            case status = "status"
        }
    }

    public struct GetTableReplicationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table.
        public let tableArn: String

        @inlinable
        public init(tableArn: String) {
            self.tableArn = tableArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.tableArn, key: "tableArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableArn, name: "tableArn", parent: name, max: 2048)
            try self.validate(self.tableArn, name: "tableArn", parent: name, min: 1)
            try self.validate(self.tableArn, name: "tableArn", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63}/table/[a-zA-Z0-9-_]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableReplicationResponse: AWSDecodableShape {
        /// The replication configuration for the table, including the IAM role and replication rules.
        public let configuration: TableReplicationConfiguration
        /// A version token that represents the current state of the table's replication configuration. Use this token when updating the configuration to ensure consistency.
        public let versionToken: String

        @inlinable
        public init(configuration: TableReplicationConfiguration, versionToken: String) {
            self.configuration = configuration
            self.versionToken = versionToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case versionToken = "versionToken"
        }
    }

    public struct GetTableReplicationStatusRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table.
        public let tableArn: String

        @inlinable
        public init(tableArn: String) {
            self.tableArn = tableArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.tableArn, key: "tableArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableArn, name: "tableArn", parent: name, max: 2048)
            try self.validate(self.tableArn, name: "tableArn", parent: name, min: 1)
            try self.validate(self.tableArn, name: "tableArn", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63}/table/[a-zA-Z0-9-_]{1,255})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableReplicationStatusResponse: AWSDecodableShape {
        /// An array of status information for each replication destination, including the current state, last successful update, and any error messages.
        public let destinations: [ReplicationDestinationStatusModel]
        /// The Amazon Resource Name (ARN) of the source table being replicated.
        public let sourceTableArn: String

        @inlinable
        public init(destinations: [ReplicationDestinationStatusModel], sourceTableArn: String) {
            self.destinations = destinations
            self.sourceTableArn = sourceTableArn
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "destinations"
            case sourceTableArn = "sourceTableArn"
        }
    }

    public struct GetTableRequest: AWSEncodableShape {
        /// The name of the table.
        public let name: String?
        /// The name of the namespace the table is associated with.
        public let namespace: String?
        /// The Amazon Resource Name (ARN) of the table.
        public let tableArn: String?
        /// The Amazon Resource Name (ARN) of the table bucket associated with the table.
        public let tableBucketARN: String?

        @inlinable
        public init(name: String? = nil, namespace: String? = nil, tableArn: String? = nil, tableBucketARN: String? = nil) {
            self.name = name
            self.namespace = namespace
            self.tableArn = tableArn
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.tableArn, key: "tableArn")
            request.encodeQuery(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableArn, name: "tableArn", parent: name, max: 2048)
            try self.validate(self.tableArn, name: "tableArn", parent: name, min: 1)
            try self.validate(self.tableArn, name: "tableArn", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63}/table/[a-zA-Z0-9-_]{1,255})$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableResponse: AWSDecodableShape {
        /// The date and time the table bucket was created at.
        public let createdAt: Date
        /// The ID of the account that created the table.
        public let createdBy: String
        /// The format of the table.
        public let format: OpenTableFormat
        /// The service that manages the table.
        public let managedByService: String?
        /// If this table is managed by S3 Tables, contains additional information such as replication details.
        public let managedTableInformation: ManagedTableInformation?
        /// The metadata location of the table.
        public let metadataLocation: String?
        /// The date and time the table was last modified on.
        public let modifiedAt: Date
        /// The ID of the account that last modified the table.
        public let modifiedBy: String
        /// The name of the table.
        public let name: String
        /// The namespace associated with the table.
        public let namespace: [String]
        /// The unique identifier of the namespace containing this table.
        public let namespaceId: String?
        /// The ID of the account that owns the table.
        public let ownerAccountId: String
        /// The Amazon Resource Name (ARN) of the table.
        public let tableARN: String
        /// The unique identifier of the table bucket containing this table.
        public let tableBucketId: String?
        /// The type of the table.
        public let type: TableType
        /// The version token of the table.
        public let versionToken: String
        /// The warehouse location of the table.
        public let warehouseLocation: String

        @inlinable
        public init(createdAt: Date, createdBy: String, format: OpenTableFormat, managedByService: String? = nil, managedTableInformation: ManagedTableInformation? = nil, metadataLocation: String? = nil, modifiedAt: Date, modifiedBy: String, name: String, namespace: [String], namespaceId: String? = nil, ownerAccountId: String, tableARN: String, tableBucketId: String? = nil, type: TableType, versionToken: String, warehouseLocation: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.format = format
            self.managedByService = managedByService
            self.managedTableInformation = managedTableInformation
            self.metadataLocation = metadataLocation
            self.modifiedAt = modifiedAt
            self.modifiedBy = modifiedBy
            self.name = name
            self.namespace = namespace
            self.namespaceId = namespaceId
            self.ownerAccountId = ownerAccountId
            self.tableARN = tableARN
            self.tableBucketId = tableBucketId
            self.type = type
            self.versionToken = versionToken
            self.warehouseLocation = warehouseLocation
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case format = "format"
            case managedByService = "managedByService"
            case managedTableInformation = "managedTableInformation"
            case metadataLocation = "metadataLocation"
            case modifiedAt = "modifiedAt"
            case modifiedBy = "modifiedBy"
            case name = "name"
            case namespace = "namespace"
            case namespaceId = "namespaceId"
            case ownerAccountId = "ownerAccountId"
            case tableARN = "tableARN"
            case tableBucketId = "tableBucketId"
            case type = "type"
            case versionToken = "versionToken"
            case warehouseLocation = "warehouseLocation"
        }
    }

    public struct GetTableStorageClassRequest: AWSEncodableShape {
        /// The name of the table.
        public let name: String
        /// The namespace associated with the table.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket that contains the table.
        public let tableBucketARN: String

        @inlinable
        public init(name: String, namespace: String, tableBucketARN: String) {
            self.name = name
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTableStorageClassResponse: AWSDecodableShape {
        /// The storage class configuration for the table.
        public let storageClassConfiguration: StorageClassConfiguration

        @inlinable
        public init(storageClassConfiguration: StorageClassConfiguration) {
            self.storageClassConfiguration = storageClassConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case storageClassConfiguration = "storageClassConfiguration"
        }
    }

    public struct IcebergCompactionSettings: AWSEncodableShape & AWSDecodableShape {
        /// The compaction strategy to use for the table. This determines how files are selected and combined during compaction operations.
        public let strategy: IcebergCompactionStrategy?
        /// The target file size for the table in MB.
        public let targetFileSizeMB: Int?

        @inlinable
        public init(strategy: IcebergCompactionStrategy? = nil, targetFileSizeMB: Int? = nil) {
            self.strategy = strategy
            self.targetFileSizeMB = targetFileSizeMB
        }

        public func validate(name: String) throws {
            try self.validate(self.targetFileSizeMB, name: "targetFileSizeMB", parent: name, max: 2147483647)
            try self.validate(self.targetFileSizeMB, name: "targetFileSizeMB", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case strategy = "strategy"
            case targetFileSizeMB = "targetFileSizeMB"
        }
    }

    public struct IcebergMetadata: AWSEncodableShape {
        /// Contains configuration properties for an Iceberg table.
        public let properties: [String: String]?
        /// The schema for an Iceberg table.
        public let schema: IcebergSchema

        @inlinable
        public init(properties: [String: String]? = nil, schema: IcebergSchema) {
            self.properties = properties
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case properties = "properties"
            case schema = "schema"
        }
    }

    public struct IcebergSchema: AWSEncodableShape {
        /// The schema fields for the table
        public let fields: [SchemaField]

        @inlinable
        public init(fields: [SchemaField]) {
            self.fields = fields
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "fields"
        }
    }

    public struct IcebergSnapshotManagementSettings: AWSEncodableShape & AWSDecodableShape {
        /// The maximum age of a snapshot before it can be expired.
        public let maxSnapshotAgeHours: Int?
        /// The minimum number of snapshots to keep.
        public let minSnapshotsToKeep: Int?

        @inlinable
        public init(maxSnapshotAgeHours: Int? = nil, minSnapshotsToKeep: Int? = nil) {
            self.maxSnapshotAgeHours = maxSnapshotAgeHours
            self.minSnapshotsToKeep = minSnapshotsToKeep
        }

        public func validate(name: String) throws {
            try self.validate(self.maxSnapshotAgeHours, name: "maxSnapshotAgeHours", parent: name, max: 2147483647)
            try self.validate(self.maxSnapshotAgeHours, name: "maxSnapshotAgeHours", parent: name, min: 1)
            try self.validate(self.minSnapshotsToKeep, name: "minSnapshotsToKeep", parent: name, max: 2147483647)
            try self.validate(self.minSnapshotsToKeep, name: "minSnapshotsToKeep", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxSnapshotAgeHours = "maxSnapshotAgeHours"
            case minSnapshotsToKeep = "minSnapshotsToKeep"
        }
    }

    public struct IcebergUnreferencedFileRemovalSettings: AWSEncodableShape & AWSDecodableShape {
        /// The number of days an object has to be non-current before it is deleted.
        public let nonCurrentDays: Int?
        /// The number of days an object has to be unreferenced before it is marked as non-current.
        public let unreferencedDays: Int?

        @inlinable
        public init(nonCurrentDays: Int? = nil, unreferencedDays: Int? = nil) {
            self.nonCurrentDays = nonCurrentDays
            self.unreferencedDays = unreferencedDays
        }

        public func validate(name: String) throws {
            try self.validate(self.nonCurrentDays, name: "nonCurrentDays", parent: name, max: 2147483647)
            try self.validate(self.nonCurrentDays, name: "nonCurrentDays", parent: name, min: 1)
            try self.validate(self.unreferencedDays, name: "unreferencedDays", parent: name, max: 2147483647)
            try self.validate(self.unreferencedDays, name: "unreferencedDays", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nonCurrentDays = "nonCurrentDays"
            case unreferencedDays = "unreferencedDays"
        }
    }

    public struct LastSuccessfulReplicatedUpdate: AWSDecodableShape {
        /// The S3 location of the metadata that was successfully replicated.
        public let metadataLocation: String
        /// The timestamp when the replication update completed successfully.
        public let timestamp: Date

        @inlinable
        public init(metadataLocation: String, timestamp: Date) {
            self.metadataLocation = metadataLocation
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case metadataLocation = "metadataLocation"
            case timestamp = "timestamp"
        }
    }

    public struct ListNamespacesRequest: AWSEncodableShape {
        ///  ContinuationToken indicates to Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key. You can use this ContinuationToken for pagination of the list results.
        public let continuationToken: String?
        /// The maximum number of namespaces to return in the list.
        public let maxNamespaces: Int?
        /// The prefix of the namespaces.
        public let prefix: String?
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(continuationToken: String? = nil, maxNamespaces: Int? = nil, prefix: String? = nil, tableBucketARN: String) {
            self.continuationToken = continuationToken
            self.maxNamespaces = maxNamespaces
            self.prefix = prefix
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.continuationToken, key: "continuationToken")
            request.encodeQuery(self.maxNamespaces, key: "maxNamespaces")
            request.encodeQuery(self.prefix, key: "prefix")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.continuationToken, name: "continuationToken", parent: name, max: 2048)
            try self.validate(self.continuationToken, name: "continuationToken", parent: name, min: 1)
            try self.validate(self.maxNamespaces, name: "maxNamespaces", parent: name, max: 1000)
            try self.validate(self.maxNamespaces, name: "maxNamespaces", parent: name, min: 1)
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNamespacesResponse: AWSDecodableShape {
        /// The ContinuationToken for pagination of the list results.
        public let continuationToken: String?
        /// A list of namespaces.
        public let namespaces: [NamespaceSummary]

        @inlinable
        public init(continuationToken: String? = nil, namespaces: [NamespaceSummary]) {
            self.continuationToken = continuationToken
            self.namespaces = namespaces
        }

        private enum CodingKeys: String, CodingKey {
            case continuationToken = "continuationToken"
            case namespaces = "namespaces"
        }
    }

    public struct ListTableBucketsRequest: AWSEncodableShape {
        ///  ContinuationToken indicates to Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key. You can use this ContinuationToken for pagination of the list results.
        public let continuationToken: String?
        /// The maximum number of table buckets to return in the list.
        public let maxBuckets: Int?
        /// The prefix of the table buckets.
        public let prefix: String?
        /// The type of table buckets to filter by in the list.
        public let type: TableBucketType?

        @inlinable
        public init(continuationToken: String? = nil, maxBuckets: Int? = nil, prefix: String? = nil, type: TableBucketType? = nil) {
            self.continuationToken = continuationToken
            self.maxBuckets = maxBuckets
            self.prefix = prefix
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.continuationToken, key: "continuationToken")
            request.encodeQuery(self.maxBuckets, key: "maxBuckets")
            request.encodeQuery(self.prefix, key: "prefix")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.continuationToken, name: "continuationToken", parent: name, max: 2048)
            try self.validate(self.continuationToken, name: "continuationToken", parent: name, min: 1)
            try self.validate(self.maxBuckets, name: "maxBuckets", parent: name, max: 1000)
            try self.validate(self.maxBuckets, name: "maxBuckets", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTableBucketsResponse: AWSDecodableShape {
        /// You can use this ContinuationToken for pagination of the list results.
        public let continuationToken: String?
        /// A list of table buckets.
        public let tableBuckets: [TableBucketSummary]

        @inlinable
        public init(continuationToken: String? = nil, tableBuckets: [TableBucketSummary]) {
            self.continuationToken = continuationToken
            self.tableBuckets = tableBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case continuationToken = "continuationToken"
            case tableBuckets = "tableBuckets"
        }
    }

    public struct ListTablesRequest: AWSEncodableShape {
        ///  ContinuationToken indicates to Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key. You can use this ContinuationToken for pagination of the list results.
        public let continuationToken: String?
        /// The maximum number of tables to return.
        public let maxTables: Int?
        /// The namespace of the tables.
        public let namespace: String?
        /// The prefix of the tables.
        public let prefix: String?
        /// The Amazon resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(continuationToken: String? = nil, maxTables: Int? = nil, namespace: String? = nil, prefix: String? = nil, tableBucketARN: String) {
            self.continuationToken = continuationToken
            self.maxTables = maxTables
            self.namespace = namespace
            self.prefix = prefix
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.continuationToken, key: "continuationToken")
            request.encodeQuery(self.maxTables, key: "maxTables")
            request.encodeQuery(self.namespace, key: "namespace")
            request.encodeQuery(self.prefix, key: "prefix")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.continuationToken, name: "continuationToken", parent: name, max: 2048)
            try self.validate(self.continuationToken, name: "continuationToken", parent: name, min: 1)
            try self.validate(self.maxTables, name: "maxTables", parent: name, max: 1000)
            try self.validate(self.maxTables, name: "maxTables", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTablesResponse: AWSDecodableShape {
        /// You can use this ContinuationToken for pagination of the list results.
        public let continuationToken: String?
        /// A list of tables.
        public let tables: [TableSummary]

        @inlinable
        public init(continuationToken: String? = nil, tables: [TableSummary]) {
            self.continuationToken = continuationToken
            self.tables = tables
        }

        private enum CodingKeys: String, CodingKey {
            case continuationToken = "continuationToken"
            case tables = "tables"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon S3 Tables resource that you want to list tags for. The tagged resource can be a table bucket or a table. For a list of all S3 resources that support tagging, see Managing tags for Amazon S3 resources.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The user-defined tags that are applied to the resource. For more information, see Tagging for cost allocation or attribute-based access control (ABAC).
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ManagedTableInformation: AWSDecodableShape {
        /// If this table is a replica, contains information about the source table from which it is replicated.
        public let replicationInformation: ReplicationInformation?

        @inlinable
        public init(replicationInformation: ReplicationInformation? = nil) {
            self.replicationInformation = replicationInformation
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInformation = "replicationInformation"
        }
    }

    public struct NamespaceSummary: AWSDecodableShape {
        /// The date and time the namespace was created at.
        public let createdAt: Date
        /// The ID of the account that created the namespace.
        public let createdBy: String
        /// The name of the namespace.
        public let namespace: [String]
        /// The system-assigned unique identifier for the namespace.
        public let namespaceId: String?
        /// The ID of the account that owns the namespace.
        public let ownerAccountId: String
        /// The system-assigned unique identifier for the table bucket that contains this namespace.
        public let tableBucketId: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, namespace: [String], namespaceId: String? = nil, ownerAccountId: String, tableBucketId: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.namespace = namespace
            self.namespaceId = namespaceId
            self.ownerAccountId = ownerAccountId
            self.tableBucketId = tableBucketId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case namespace = "namespace"
            case namespaceId = "namespaceId"
            case ownerAccountId = "ownerAccountId"
            case tableBucketId = "tableBucketId"
        }
    }

    public struct PutTableBucketEncryptionRequest: AWSEncodableShape {
        /// The encryption configuration to apply to the table bucket.
        public let encryptionConfiguration: EncryptionConfiguration
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(encryptionConfiguration: EncryptionConfiguration, tableBucketARN: String) {
            self.encryptionConfiguration = encryptionConfiguration
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.encryptionConfiguration, forKey: .encryptionConfiguration)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "encryptionConfiguration"
        }
    }

    public struct PutTableBucketMaintenanceConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket associated with the maintenance configuration.
        public let tableBucketARN: String
        /// The type of the maintenance configuration.
        public let type: TableBucketMaintenanceType
        /// Defines the values of the maintenance configuration for the table bucket.
        public let value: TableBucketMaintenanceConfigurationValue

        @inlinable
        public init(tableBucketARN: String, type: TableBucketMaintenanceType, value: TableBucketMaintenanceConfigurationValue) {
            self.tableBucketARN = tableBucketARN
            self.type = type
            self.value = value
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
            request.encodePath(self.type, key: "type")
            try container.encode(self.value, forKey: .value)
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct PutTableBucketMetricsConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(tableBucketARN: String) {
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PutTableBucketPolicyRequest: AWSEncodableShape {
        /// The JSON that defines the policy.
        public let resourcePolicy: String
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(resourcePolicy: String, tableBucketARN: String) {
            self.resourcePolicy = resourcePolicy
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.resourcePolicy, forKey: .resourcePolicy)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourcePolicy, name: "resourcePolicy", parent: name, max: 20480)
            try self.validate(self.resourcePolicy, name: "resourcePolicy", parent: name, min: 1)
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePolicy = "resourcePolicy"
        }
    }

    public struct PutTableBucketReplicationRequest: AWSEncodableShape {
        /// The replication configuration to apply, including the IAM role and replication rules.
        public let configuration: TableBucketReplicationConfiguration
        /// The Amazon Resource Name (ARN) of the source table bucket.
        public let tableBucketARN: String
        /// A version token from a previous GetTableBucketReplication call. Use this token to ensure you're updating the expected version of the configuration.
        public let versionToken: String?

        @inlinable
        public init(configuration: TableBucketReplicationConfiguration, tableBucketARN: String, versionToken: String? = nil) {
            self.configuration = configuration
            self.tableBucketARN = tableBucketARN
            self.versionToken = versionToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.configuration, forKey: .configuration)
            request.encodeQuery(self.tableBucketARN, key: "tableBucketARN")
            request.encodeQuery(self.versionToken, key: "versionToken")
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
            try self.validate(self.versionToken, name: "versionToken", parent: name, max: 2048)
            try self.validate(self.versionToken, name: "versionToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
        }
    }

    public struct PutTableBucketReplicationResponse: AWSDecodableShape {
        /// The status of the replication configuration operation.
        public let status: String
        /// A new version token representing the updated replication configuration.
        public let versionToken: String

        @inlinable
        public init(status: String, versionToken: String) {
            self.status = status
            self.versionToken = versionToken
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case versionToken = "versionToken"
        }
    }

    public struct PutTableBucketStorageClassRequest: AWSEncodableShape {
        /// The storage class configuration to apply to the table bucket. This configuration will serve as the default for new tables created in this bucket.
        public let storageClassConfiguration: StorageClassConfiguration
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String

        @inlinable
        public init(storageClassConfiguration: StorageClassConfiguration, tableBucketARN: String) {
            self.storageClassConfiguration = storageClassConfiguration
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.storageClassConfiguration, forKey: .storageClassConfiguration)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: String, CodingKey {
            case storageClassConfiguration = "storageClassConfiguration"
        }
    }

    public struct PutTableMaintenanceConfigurationRequest: AWSEncodableShape {
        /// The name of the table.
        public let name: String
        /// The namespace of the table.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table associated with the maintenance configuration.
        public let tableBucketARN: String
        /// The type of the maintenance configuration.
        public let type: TableMaintenanceType
        /// Defines the values of the maintenance configuration for the table.
        public let value: TableMaintenanceConfigurationValue

        @inlinable
        public init(name: String, namespace: String, tableBucketARN: String, type: TableMaintenanceType, value: TableMaintenanceConfigurationValue) {
            self.name = name
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
            self.type = type
            self.value = value
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
            request.encodePath(self.type, key: "type")
            try container.encode(self.value, forKey: .value)
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct PutTablePolicyRequest: AWSEncodableShape {
        /// The name of the table.
        public let name: String
        /// The namespace associated with the table.
        public let namespace: String
        /// The JSON that defines the policy.
        public let resourcePolicy: String
        /// The Amazon Resource Name (ARN) of the table bucket that contains the table.
        public let tableBucketARN: String

        @inlinable
        public init(name: String, namespace: String, resourcePolicy: String, tableBucketARN: String) {
            self.name = name
            self.namespace = namespace
            self.resourcePolicy = resourcePolicy
            self.tableBucketARN = tableBucketARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            try container.encode(self.resourcePolicy, forKey: .resourcePolicy)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.resourcePolicy, name: "resourcePolicy", parent: name, max: 20480)
            try self.validate(self.resourcePolicy, name: "resourcePolicy", parent: name, min: 1)
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePolicy = "resourcePolicy"
        }
    }

    public struct PutTableRecordExpirationConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the table.
        public let tableArn: String
        /// The record expiration configuration to apply to the table, including the status (enabled or disabled) and retention period in days.
        public let value: TableRecordExpirationConfigurationValue

        @inlinable
        public init(tableArn: String, value: TableRecordExpirationConfigurationValue) {
            self.tableArn = tableArn
            self.value = value
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.tableArn, key: "tableArn")
            try container.encode(self.value, forKey: .value)
        }

        public func validate(name: String) throws {
            try self.validate(self.tableArn, name: "tableArn", parent: name, max: 2048)
            try self.validate(self.tableArn, name: "tableArn", parent: name, min: 1)
            try self.validate(self.tableArn, name: "tableArn", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63}/table/[a-zA-Z0-9-_]{1,255})$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct PutTableReplicationRequest: AWSEncodableShape {
        /// The replication configuration to apply to the table, including the IAM role and replication rules.
        public let configuration: TableReplicationConfiguration
        /// The Amazon Resource Name (ARN) of the source table.
        public let tableArn: String
        /// A version token from a previous GetTableReplication call. Use this token to ensure you're updating the expected version of the configuration.
        public let versionToken: String?

        @inlinable
        public init(configuration: TableReplicationConfiguration, tableArn: String, versionToken: String? = nil) {
            self.configuration = configuration
            self.tableArn = tableArn
            self.versionToken = versionToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.configuration, forKey: .configuration)
            request.encodeQuery(self.tableArn, key: "tableArn")
            request.encodeQuery(self.versionToken, key: "versionToken")
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.tableArn, name: "tableArn", parent: name, max: 2048)
            try self.validate(self.tableArn, name: "tableArn", parent: name, min: 1)
            try self.validate(self.tableArn, name: "tableArn", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63}/table/[a-zA-Z0-9-_]{1,255})$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
        }
    }

    public struct PutTableReplicationResponse: AWSDecodableShape {
        /// The status of the replication configuration operation.
        public let status: String
        /// A new version token representing the updated replication configuration.
        public let versionToken: String

        @inlinable
        public init(status: String, versionToken: String) {
            self.status = status
            self.versionToken = versionToken
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case versionToken = "versionToken"
        }
    }

    public struct RenameTableRequest: AWSEncodableShape {
        /// The current name of the table.
        public let name: String
        /// The namespace associated with the table.
        public let namespace: String
        /// The new name for the table.
        public let newName: String?
        /// The new name for the namespace.
        public let newNamespaceName: String?
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String
        /// The version token of the table.
        public let versionToken: String?

        @inlinable
        public init(name: String, namespace: String, newName: String? = nil, newNamespaceName: String? = nil, tableBucketARN: String, versionToken: String? = nil) {
            self.name = name
            self.namespace = namespace
            self.newName = newName
            self.newNamespaceName = newNamespaceName
            self.tableBucketARN = tableBucketARN
            self.versionToken = versionToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            try container.encodeIfPresent(self.newName, forKey: .newName)
            try container.encodeIfPresent(self.newNamespaceName, forKey: .newNamespaceName)
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
            try container.encodeIfPresent(self.versionToken, forKey: .versionToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.newName, name: "newName", parent: name, max: 255)
            try self.validate(self.newName, name: "newName", parent: name, min: 1)
            try self.validate(self.newName, name: "newName", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.newNamespaceName, name: "newNamespaceName", parent: name, max: 255)
            try self.validate(self.newNamespaceName, name: "newNamespaceName", parent: name, min: 1)
            try self.validate(self.newNamespaceName, name: "newNamespaceName", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
            try self.validate(self.versionToken, name: "versionToken", parent: name, max: 2048)
            try self.validate(self.versionToken, name: "versionToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case newName = "newName"
            case newNamespaceName = "newNamespaceName"
            case versionToken = "versionToken"
        }
    }

    public struct ReplicationDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination table bucket where tables will be replicated.
        public let destinationTableBucketARN: String

        @inlinable
        public init(destinationTableBucketARN: String) {
            self.destinationTableBucketARN = destinationTableBucketARN
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationTableBucketARN, name: "destinationTableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationTableBucketARN = "destinationTableBucketARN"
        }
    }

    public struct ReplicationDestinationStatusModel: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination table.
        public let destinationTableArn: String?
        /// The Amazon Resource Name (ARN) of the destination table bucket.
        public let destinationTableBucketArn: String
        /// If replication has failed, this field contains an error message describing the failure reason.
        public let failureMessage: String?
        /// Information about the most recent successful replication update to this destination.
        public let lastSuccessfulReplicatedUpdate: LastSuccessfulReplicatedUpdate?
        /// The current status of replication to this destination.
        public let replicationStatus: ReplicationStatus

        @inlinable
        public init(destinationTableArn: String? = nil, destinationTableBucketArn: String, failureMessage: String? = nil, lastSuccessfulReplicatedUpdate: LastSuccessfulReplicatedUpdate? = nil, replicationStatus: ReplicationStatus) {
            self.destinationTableArn = destinationTableArn
            self.destinationTableBucketArn = destinationTableBucketArn
            self.failureMessage = failureMessage
            self.lastSuccessfulReplicatedUpdate = lastSuccessfulReplicatedUpdate
            self.replicationStatus = replicationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case destinationTableArn = "destinationTableArn"
            case destinationTableBucketArn = "destinationTableBucketArn"
            case failureMessage = "failureMessage"
            case lastSuccessfulReplicatedUpdate = "lastSuccessfulReplicatedUpdate"
            case replicationStatus = "replicationStatus"
        }
    }

    public struct ReplicationInformation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the source table from which this table is replicated.
        public let sourceTableARN: String

        @inlinable
        public init(sourceTableARN: String) {
            self.sourceTableARN = sourceTableARN
        }

        private enum CodingKeys: String, CodingKey {
            case sourceTableARN = "sourceTableARN"
        }
    }

    public struct SchemaField: AWSEncodableShape {
        /// The name of the field.
        public let name: String
        /// A Boolean value that specifies whether values are required for each row in this field. By default, this is false and null values are allowed in the field. If this is true the field does not allow null values.
        public let required: Bool?
        /// The field type. S3 Tables supports all Apache Iceberg primitive types. For more information, see the Apache Iceberg documentation.
        public let type: String

        @inlinable
        public init(name: String, required: Bool? = nil, type: String) {
            self.name = name
            self.required = required
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case required = "required"
            case type = "type"
        }
    }

    public struct StorageClassConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The storage class for the table or table bucket. Valid values include storage classes optimized for different access patterns and cost profiles.
        public let storageClass: StorageClass

        @inlinable
        public init(storageClass: StorageClass) {
            self.storageClass = storageClass
        }

        private enum CodingKeys: String, CodingKey {
            case storageClass = "storageClass"
        }
    }

    public struct TableBucketMaintenanceConfigurationValue: AWSEncodableShape & AWSDecodableShape {
        /// Contains details about the settings of the maintenance configuration.
        public let settings: TableBucketMaintenanceSettings?
        /// The status of the maintenance configuration.
        public let status: MaintenanceStatus?

        @inlinable
        public init(settings: TableBucketMaintenanceSettings? = nil, status: MaintenanceStatus? = nil) {
            self.settings = settings
            self.status = status
        }

        public func validate(name: String) throws {
            try self.settings?.validate(name: "\(name).settings")
        }

        private enum CodingKeys: String, CodingKey {
            case settings = "settings"
            case status = "status"
        }
    }

    public struct TableBucketReplicationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the IAM role that S3 Tables assumes to replicate tables on your behalf.
        public let role: String
        /// An array of replication rules that define which tables to replicate and where to replicate them.
        public let rules: [TableBucketReplicationRule]

        @inlinable
        public init(role: String, rules: [TableBucketReplicationRule]) {
            self.role = role
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:.+:iam::[0-9]{12}:role/.+$")
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 1)
            try self.validate(self.rules, name: "rules", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case role = "role"
            case rules = "rules"
        }
    }

    public struct TableBucketReplicationRule: AWSEncodableShape & AWSDecodableShape {
        /// An array of destination table buckets where tables should be replicated.
        public let destinations: [ReplicationDestination]

        @inlinable
        public init(destinations: [ReplicationDestination]) {
            self.destinations = destinations
        }

        public func validate(name: String) throws {
            try self.destinations.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.validate(self.destinations, name: "destinations", parent: name, max: 5)
            try self.validate(self.destinations, name: "destinations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "destinations"
        }
    }

    public struct TableBucketSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let arn: String
        /// The date and time the table bucket was created at.
        public let createdAt: Date
        /// The name of the table bucket.
        public let name: String
        /// The ID of the account that owns the table bucket.
        public let ownerAccountId: String
        /// The system-assigned unique identifier for the table bucket.
        public let tableBucketId: String?
        /// The type of the table bucket.
        public let type: TableBucketType?

        @inlinable
        public init(arn: String, createdAt: Date, name: String, ownerAccountId: String, tableBucketId: String? = nil, type: TableBucketType? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.tableBucketId = tableBucketId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case name = "name"
            case ownerAccountId = "ownerAccountId"
            case tableBucketId = "tableBucketId"
            case type = "type"
        }
    }

    public struct TableMaintenanceConfigurationValue: AWSEncodableShape & AWSDecodableShape {
        /// Contains details about the settings for the maintenance configuration.
        public let settings: TableMaintenanceSettings?
        /// The status of the maintenance configuration.
        public let status: MaintenanceStatus?

        @inlinable
        public init(settings: TableMaintenanceSettings? = nil, status: MaintenanceStatus? = nil) {
            self.settings = settings
            self.status = status
        }

        public func validate(name: String) throws {
            try self.settings?.validate(name: "\(name).settings")
        }

        private enum CodingKeys: String, CodingKey {
            case settings = "settings"
            case status = "status"
        }
    }

    public struct TableMaintenanceJobStatusValue: AWSDecodableShape {
        /// The failure message of a failed job.
        public let failureMessage: String?
        /// The date and time that the maintenance job was last run.
        public let lastRunTimestamp: Date?
        /// The status of the job.
        public let status: JobStatus

        @inlinable
        public init(failureMessage: String? = nil, lastRunTimestamp: Date? = nil, status: JobStatus) {
            self.failureMessage = failureMessage
            self.lastRunTimestamp = lastRunTimestamp
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case failureMessage = "failureMessage"
            case lastRunTimestamp = "lastRunTimestamp"
            case status = "status"
        }
    }

    public struct TableRecordExpirationConfigurationValue: AWSEncodableShape & AWSDecodableShape {
        /// The expiration settings for records in the table.
        public let settings: TableRecordExpirationSettings?
        /// The status of the expiration settings for records in the table.
        public let status: TableRecordExpirationStatus?

        @inlinable
        public init(settings: TableRecordExpirationSettings? = nil, status: TableRecordExpirationStatus? = nil) {
            self.settings = settings
            self.status = status
        }

        public func validate(name: String) throws {
            try self.settings?.validate(name: "\(name).settings")
        }

        private enum CodingKeys: String, CodingKey {
            case settings = "settings"
            case status = "status"
        }
    }

    public struct TableRecordExpirationJobMetrics: AWSDecodableShape {
        /// The total number of data files that were removed when the job ran.
        public let deletedDataFiles: Int64?
        /// The total number of records that were removed when the job ran.
        public let deletedRecords: Int64?
        /// The total size (in bytes) of the data files that were removed when the job ran.
        public let removedFilesSize: Int64?

        @inlinable
        public init(deletedDataFiles: Int64? = nil, deletedRecords: Int64? = nil, removedFilesSize: Int64? = nil) {
            self.deletedDataFiles = deletedDataFiles
            self.deletedRecords = deletedRecords
            self.removedFilesSize = removedFilesSize
        }

        private enum CodingKeys: String, CodingKey {
            case deletedDataFiles = "deletedDataFiles"
            case deletedRecords = "deletedRecords"
            case removedFilesSize = "removedFilesSize"
        }
    }

    public struct TableRecordExpirationSettings: AWSEncodableShape & AWSDecodableShape {
        /// If you enable record expiration for a table, you can specify the number of days to retain your table records. For example, to retain your table records for one year, set this value to 365.
        public let days: Int?

        @inlinable
        public init(days: Int? = nil) {
            self.days = days
        }

        public func validate(name: String) throws {
            try self.validate(self.days, name: "days", parent: name, max: 2147483647)
            try self.validate(self.days, name: "days", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case days = "days"
        }
    }

    public struct TableReplicationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the IAM role that S3 Tables assumes to replicate the table on your behalf.
        public let role: String
        /// An array of replication rules that define where this table should be replicated.
        public let rules: [TableReplicationRule]

        @inlinable
        public init(role: String, rules: [TableReplicationRule]) {
            self.role = role
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:.+:iam::[0-9]{12}:role/.+$")
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 1)
            try self.validate(self.rules, name: "rules", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case role = "role"
            case rules = "rules"
        }
    }

    public struct TableReplicationRule: AWSEncodableShape & AWSDecodableShape {
        /// An array of destination table buckets where this table should be replicated.
        public let destinations: [ReplicationDestination]

        @inlinable
        public init(destinations: [ReplicationDestination]) {
            self.destinations = destinations
        }

        public func validate(name: String) throws {
            try self.destinations.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.validate(self.destinations, name: "destinations", parent: name, max: 5)
            try self.validate(self.destinations, name: "destinations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "destinations"
        }
    }

    public struct TableSummary: AWSDecodableShape {
        /// The date and time the table was created at.
        public let createdAt: Date
        /// The Amazon Web Services service managing this table, if applicable. For example, a replicated table is managed by the S3 Tables replication service.
        public let managedByService: String?
        /// The date and time the table was last modified at.
        public let modifiedAt: Date
        /// The name of the table.
        public let name: String
        /// The name of the namespace.
        public let namespace: [String]
        /// The unique identifier for the namespace that contains this table.
        public let namespaceId: String?
        /// The Amazon Resource Name (ARN) of the table.
        public let tableARN: String
        /// The unique identifier for the table bucket that contains this table.
        public let tableBucketId: String?
        /// The type of the table.
        public let type: TableType

        @inlinable
        public init(createdAt: Date, managedByService: String? = nil, modifiedAt: Date, name: String, namespace: [String], namespaceId: String? = nil, tableARN: String, tableBucketId: String? = nil, type: TableType) {
            self.createdAt = createdAt
            self.managedByService = managedByService
            self.modifiedAt = modifiedAt
            self.name = name
            self.namespace = namespace
            self.namespaceId = namespaceId
            self.tableARN = tableARN
            self.tableBucketId = tableBucketId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case managedByService = "managedByService"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case namespace = "namespace"
            case namespaceId = "namespaceId"
            case tableARN = "tableARN"
            case tableBucketId = "tableBucketId"
            case type = "type"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon S3 Tables resource that you're applying tags to. The tagged resource can be a table bucket or a table. For a list of all S3 resources that support tagging, see Managing tags for Amazon S3 resources.
        public let resourceArn: String
        /// The user-defined tag that you want to add to the specified S3 Tables resource. For more information, see Tagging for cost allocation or attribute-based access control (ABAC).
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/.+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon S3 Tables resource that you're removing tags from. The tagged resource can be a table bucket or a table. For a list of all S3 resources that support tagging, see Managing tags for Amazon S3 resources.
        public let resourceArn: String
        /// The array of tag keys that you're removing from the S3 Tables resource. For more information, see Tagging for cost allocation or attribute-based access control (ABAC).
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTableMetadataLocationRequest: AWSEncodableShape {
        /// The new metadata location for the table.
        public let metadataLocation: String
        /// The name of the table.
        public let name: String
        /// The namespace of the table.
        public let namespace: String
        /// The Amazon Resource Name (ARN) of the table bucket.
        public let tableBucketARN: String
        /// The version token of the table.
        public let versionToken: String

        @inlinable
        public init(metadataLocation: String, name: String, namespace: String, tableBucketARN: String, versionToken: String) {
            self.metadataLocation = metadataLocation
            self.name = name
            self.namespace = namespace
            self.tableBucketARN = tableBucketARN
            self.versionToken = versionToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.metadataLocation, forKey: .metadataLocation)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.namespace, key: "namespace")
            request.encodePath(self.tableBucketARN, key: "tableBucketARN")
            try container.encode(self.versionToken, forKey: .versionToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataLocation, name: "metadataLocation", parent: name, max: 2048)
            try self.validate(self.metadataLocation, name: "metadataLocation", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 255)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[0-9a-z_]*$")
            try self.validate(self.tableBucketARN, name: "tableBucketARN", parent: name, pattern: "^(arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:bucket/[a-z0-9_-]{3,63})$")
            try self.validate(self.versionToken, name: "versionToken", parent: name, max: 2048)
            try self.validate(self.versionToken, name: "versionToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadataLocation = "metadataLocation"
            case versionToken = "versionToken"
        }
    }

    public struct UpdateTableMetadataLocationResponse: AWSDecodableShape {
        /// The metadata location of the table.
        public let metadataLocation: String
        /// The name of the table.
        public let name: String
        /// The namespace the table is associated with.
        public let namespace: [String]
        /// The Amazon Resource Name (ARN) of the table.
        public let tableARN: String
        /// The version token of the table.
        public let versionToken: String

        @inlinable
        public init(metadataLocation: String, name: String, namespace: [String], tableARN: String, versionToken: String) {
            self.metadataLocation = metadataLocation
            self.name = name
            self.namespace = namespace
            self.tableARN = tableARN
            self.versionToken = versionToken
        }

        private enum CodingKeys: String, CodingKey {
            case metadataLocation = "metadataLocation"
            case name = "name"
            case namespace = "namespace"
            case tableARN = "tableARN"
            case versionToken = "versionToken"
        }
    }

    public struct TableBucketMaintenanceSettings: AWSEncodableShape & AWSDecodableShape {
        /// The unreferenced file removal settings for the table bucket.
        public let icebergUnreferencedFileRemoval: IcebergUnreferencedFileRemovalSettings?

        @inlinable
        public init(icebergUnreferencedFileRemoval: IcebergUnreferencedFileRemovalSettings? = nil) {
            self.icebergUnreferencedFileRemoval = icebergUnreferencedFileRemoval
        }

        public func validate(name: String) throws {
            try self.icebergUnreferencedFileRemoval?.validate(name: "\(name).icebergUnreferencedFileRemoval")
        }

        private enum CodingKeys: String, CodingKey {
            case icebergUnreferencedFileRemoval = "icebergUnreferencedFileRemoval"
        }
    }

    public struct TableMetadata: AWSEncodableShape {
        /// Contains details about the metadata of an Iceberg table.
        public let iceberg: IcebergMetadata?

        @inlinable
        public init(iceberg: IcebergMetadata? = nil) {
            self.iceberg = iceberg
        }

        private enum CodingKeys: String, CodingKey {
            case iceberg = "iceberg"
        }
    }
}

// MARK: - Errors

/// Error enum for S3Tables
public struct S3TablesErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case methodNotAllowedException = "MethodNotAllowedException"
        case notFoundException = "NotFoundException"
        case tooManyRequestsException = "TooManyRequestsException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize S3Tables
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The action cannot be performed because you do not have the required permission.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request is invalid or malformed.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The request failed because there is a conflict with a previous write. You can retry the request.
    public static var conflictException: Self { .init(.conflictException) }
    /// The caller isn't authorized to make the request.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// The request failed due to an internal server error.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// The requested operation is not allowed on this resource. This may occur when attempting to modify a resource that is managed by a service or has restrictions that prevent the operation.
    public static var methodNotAllowedException: Self { .init(.methodNotAllowedException) }
    /// The request was rejected because the specified resource could not be found.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// The limit on the number of requests per second was exceeded.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
}

extension S3TablesErrorType: Equatable {
    public static func == (lhs: S3TablesErrorType, rhs: S3TablesErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension S3TablesErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
