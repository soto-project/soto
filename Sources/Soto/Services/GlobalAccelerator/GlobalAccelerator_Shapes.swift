//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension GlobalAccelerator {
    // MARK: Enums

    public enum AcceleratorStatus: String, CustomStringConvertible, Codable {
        case deployed = "DEPLOYED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ByoipCidrState: String, CustomStringConvertible, Codable {
        case advertising = "ADVERTISING"
        case deprovisioned = "DEPROVISIONED"
        case failedAdvertising = "FAILED_ADVERTISING"
        case failedDeprovision = "FAILED_DEPROVISION"
        case failedProvision = "FAILED_PROVISION"
        case failedWithdraw = "FAILED_WITHDRAW"
        case pendingAdvertising = "PENDING_ADVERTISING"
        case pendingDeprovisioning = "PENDING_DEPROVISIONING"
        case pendingProvisioning = "PENDING_PROVISIONING"
        case pendingWithdrawing = "PENDING_WITHDRAWING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum ClientAffinity: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case sourceIp = "SOURCE_IP"
        public var description: String { return self.rawValue }
    }

    public enum CustomRoutingAcceleratorStatus: String, CustomStringConvertible, Codable {
        case deployed = "DEPLOYED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum CustomRoutingDestinationTrafficState: String, CustomStringConvertible, Codable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum CustomRoutingProtocol: String, CustomStringConvertible, Codable {
        case tcp = "TCP"
        case udp = "UDP"
        public var description: String { return self.rawValue }
    }

    public enum HealthCheckProtocol: String, CustomStringConvertible, Codable {
        case http = "HTTP"
        case https = "HTTPS"
        case tcp = "TCP"
        public var description: String { return self.rawValue }
    }

    public enum HealthState: String, CustomStringConvertible, Codable {
        case healthy = "HEALTHY"
        case initial = "INITIAL"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum IpAddressType: String, CustomStringConvertible, Codable {
        case ipv4 = "IPV4"
        public var description: String { return self.rawValue }
    }

    public enum `Protocol`: String, CustomStringConvertible, Codable {
        case tcp = "TCP"
        case udp = "UDP"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Accelerator: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator.
        public let acceleratorArn: String?
        /// The date and time that the accelerator was created.
        public let createdTime: Date?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to your accelerator's static IP addresses.
        /// 		       The naming convention for the DNS name is the following: A lowercase letter a,
        /// 			followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example:
        /// 			a1234567890abcdef.awsglobalaccelerator.com.
        /// 		       For more information about the default DNS name, see
        /// 			Support for DNS Addressing in Global Accelerator in the AWS Global Accelerator Developer Guide.
        public let dnsName: String?
        /// Indicates whether the accelerator is enabled. The value is true or false. The default value is true.
        /// 		       If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.
        public let enabled: Bool?
        /// The value for the address type must be IPv4.
        ///
        public let ipAddressType: IpAddressType?
        /// The static IP addresses that Global Accelerator associates with the accelerator.
        public let ipSets: [IpSet]?
        /// The date and time that the accelerator was last modified.
        public let lastModifiedTime: Date?
        /// The name of the accelerator. The name must contain only alphanumeric characters or
        /// 			hyphens (-), and must not begin or end with a hyphen.
        public let name: String?
        /// Describes the deployment status of the accelerator.
        public let status: AcceleratorStatus?

        public init(acceleratorArn: String? = nil, createdTime: Date? = nil, dnsName: String? = nil, enabled: Bool? = nil, ipAddressType: IpAddressType? = nil, ipSets: [IpSet]? = nil, lastModifiedTime: Date? = nil, name: String? = nil, status: AcceleratorStatus? = nil) {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case createdTime = "CreatedTime"
            case dnsName = "DnsName"
            case enabled = "Enabled"
            case ipAddressType = "IpAddressType"
            case ipSets = "IpSets"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct AcceleratorAttributes: AWSDecodableShape {
        /// Indicates whether flow logs are enabled. The default value is false. If the value is true,
        /// 				FlowLogsS3Bucket and FlowLogsS3Prefix must be specified.
        /// 		       For more information, see Flow Logs in
        /// 			the AWS Global Accelerator Developer Guide.
        public let flowLogsEnabled: Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is
        /// 				true. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
        /// 			bucket.
        public let flowLogsS3Bucket: String?
        /// The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
        /// 				FlowLogsEnabled is true.
        /// 		       If you donâ€™t specify a prefix, the flow logs are stored in the
        /// 			root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:
        /// 		       s3-bucket_name//AWSLogs/aws_account_id
        public let flowLogsS3Prefix: String?

        public init(flowLogsEnabled: Bool? = nil, flowLogsS3Bucket: String? = nil, flowLogsS3Prefix: String? = nil) {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }

        private enum CodingKeys: String, CodingKey {
            case flowLogsEnabled = "FlowLogsEnabled"
            case flowLogsS3Bucket = "FlowLogsS3Bucket"
            case flowLogsS3Prefix = "FlowLogsS3Prefix"
        }
    }

    public struct AddCustomRoutingEndpointsRequest: AWSEncodableShape {
        /// The list of endpoint objects to add to a custom routing accelerator.
        public let endpointConfigurations: [CustomRoutingEndpointConfiguration]
        /// The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.
        public let endpointGroupArn: String

        public init(endpointConfigurations: [CustomRoutingEndpointConfiguration], endpointGroupArn: String) {
            self.endpointConfigurations = endpointConfigurations
            self.endpointGroupArn = endpointGroupArn
        }

        public func validate(name: String) throws {
            try self.endpointConfigurations.forEach {
                try $0.validate(name: "\(name).endpointConfigurations[]")
            }
            try self.validate(self.endpointConfigurations, name: "endpointConfigurations", parent: name, max: 20)
            try self.validate(self.endpointConfigurations, name: "endpointConfigurations", parent: name, min: 1)
            try self.validate(self.endpointGroupArn, name: "endpointGroupArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigurations = "EndpointConfigurations"
            case endpointGroupArn = "EndpointGroupArn"
        }
    }

    public struct AddCustomRoutingEndpointsResponse: AWSDecodableShape {
        /// The endpoint objects added to the custom routing accelerator.
        public let endpointDescriptions: [CustomRoutingEndpointDescription]?
        /// The Amazon Resource Name (ARN) of the endpoint group for the custom routing endpoint.
        public let endpointGroupArn: String?

        public init(endpointDescriptions: [CustomRoutingEndpointDescription]? = nil, endpointGroupArn: String? = nil) {
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointDescriptions = "EndpointDescriptions"
            case endpointGroupArn = "EndpointGroupArn"
        }
    }

    public struct AdvertiseByoipCidrRequest: AWSEncodableShape {
        /// The address range, in CIDR notation. This must be the exact range that you provisioned.
        /// 			You can't advertise only a portion of the provisioned range.
        public let cidr: String

        public init(cidr: String) {
            self.cidr = cidr
        }

        public func validate(name: String) throws {
            try self.validate(self.cidr, name: "cidr", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "Cidr"
        }
    }

    public struct AdvertiseByoipCidrResponse: AWSDecodableShape {
        /// Information about the address range.
        public let byoipCidr: ByoipCidr?

        public init(byoipCidr: ByoipCidr? = nil) {
            self.byoipCidr = byoipCidr
        }

        private enum CodingKeys: String, CodingKey {
            case byoipCidr = "ByoipCidr"
        }
    }

    public struct AllowCustomRoutingTrafficRequest: AWSEncodableShape {
        /// Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint can receive traffic
        /// 			from a custom routing accelerator. The value is TRUE or FALSE.
        /// 		       When set to TRUE, all destinations in the custom routing VPC subnet can receive traffic. Note
        /// 			that you cannot specify destination IP addresses and ports when the value is set to TRUE.
        /// 		       When set to FALSE (or not specified), you must specify a list of destination IP addresses that are allowed
        /// 			to receive traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is
        /// 			the same as the ports configured for the endpoint group.
        /// 		       The default value is FALSE.
        public let allowAllTrafficToEndpoint: Bool?
        /// A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to allow to receive
        /// 			traffic. The IP addresses must be a subset of the IP addresses that you specified for the endpoint group.
        /// 		        DestinationAddresses is required if AllowAllTrafficToEndpoint is FALSE or is
        /// 		not specified.
        public let destinationAddresses: [String]?
        /// A list of specific Amazon EC2 instance ports (destination ports) that you want to allow to receive traffic.
        public let destinationPorts: [Int]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public let endpointGroupArn: String
        /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
        public let endpointId: String

        public init(allowAllTrafficToEndpoint: Bool? = nil, destinationAddresses: [String]? = nil, destinationPorts: [Int]? = nil, endpointGroupArn: String, endpointId: String) {
            self.allowAllTrafficToEndpoint = allowAllTrafficToEndpoint
            self.destinationAddresses = destinationAddresses
            self.destinationPorts = destinationPorts
            self.endpointGroupArn = endpointGroupArn
            self.endpointId = endpointId
        }

        public func validate(name: String) throws {
            try self.destinationAddresses?.forEach {
                try validate($0, name: "destinationAddresses[]", parent: name, max: 45)
            }
            try self.validate(self.destinationAddresses, name: "destinationAddresses", parent: name, max: 100)
            try self.destinationPorts?.forEach {
                try validate($0, name: "destinationPorts[]", parent: name, max: 65535)
                try validate($0, name: "destinationPorts[]", parent: name, min: 1)
            }
            try self.validate(self.destinationPorts, name: "destinationPorts", parent: name, max: 100)
            try self.validate(self.endpointGroupArn, name: "endpointGroupArn", parent: name, max: 255)
            try self.validate(self.endpointId, name: "endpointId", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case allowAllTrafficToEndpoint = "AllowAllTrafficToEndpoint"
            case destinationAddresses = "DestinationAddresses"
            case destinationPorts = "DestinationPorts"
            case endpointGroupArn = "EndpointGroupArn"
            case endpointId = "EndpointId"
        }
    }

    public struct ByoipCidr: AWSDecodableShape {
        /// The address range, in CIDR notation.
        public let cidr: String?
        /// A history of status changes for an IP address range that you bring to AWS Global Accelerator
        /// 			through bring your own IP address (BYOIP).
        public let events: [ByoipCidrEvent]?
        /// The state of the address pool.
        public let state: ByoipCidrState?

        public init(cidr: String? = nil, events: [ByoipCidrEvent]? = nil, state: ByoipCidrState? = nil) {
            self.cidr = cidr
            self.events = events
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "Cidr"
            case events = "Events"
            case state = "State"
        }
    }

    public struct ByoipCidrEvent: AWSDecodableShape {
        /// A string that contains an Event message describing changes that you make in the status
        /// 			of an IP address range that you bring to AWS Global Accelerator through bring your own IP address (BYOIP).
        public let message: String?
        /// A timestamp when you make a status change for an IP address range that you bring to AWS Global Accelerator through
        /// 			bring your own IP address (BYOIP).
        public let timestamp: Date?

        public init(message: String? = nil, timestamp: Date? = nil) {
            self.message = message
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case timestamp = "Timestamp"
        }
    }

    public struct CidrAuthorizationContext: AWSEncodableShape {
        /// The plain-text authorization message for the prefix and account.
        public let message: String
        /// The signed authorization message for the prefix and account.
        public let signature: String

        public init(message: String, signature: String) {
            self.message = message
            self.signature = signature
        }

        public func validate(name: String) throws {
            try self.validate(self.message, name: "message", parent: name, max: 255)
            try self.validate(self.signature, name: "signature", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case signature = "Signature"
        }
    }

    public struct CreateAcceleratorRequest: AWSEncodableShape {
        /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true.
        /// 		       If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.
        public let enabled: Bool?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that is, the
        /// 			uniquenessâ€”of an accelerator.
        public let idempotencyToken: String
        /// Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose IP addresses
        /// 			from your own pool to use for the accelerator's static IP addresses when you create an accelerator. You can
        /// 			specify one or two addresses, separated by a space. Do not include the /32 suffix.
        /// 		       Only one IP address from each of your IP address ranges can be used for each accelerator. If you specify only
        /// 			one IP address from your IP address range, Global Accelerator assigns a second static IP address for the
        /// 			accelerator from the AWS IP address pool.
        /// 		       Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new
        /// 			accelerator with the new addresses.
        /// 		       For more information, see Bring Your Own
        /// 			IP Addresses (BYOIP) in the AWS Global Accelerator Developer Guide.
        public let ipAddresses: [String]?
        /// The value for the address type must be IPv4.
        public let ipAddressType: IpAddressType?
        /// The name of an accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or
        /// 			hyphens (-), and must not begin or end with a hyphen.
        public let name: String
        /// Create tags for an accelerator.
        /// 		       For more information, see Tagging
        /// 			in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
        public let tags: [Tag]?

        public init(enabled: Bool? = nil, idempotencyToken: String = CreateAcceleratorRequest.idempotencyToken(), ipAddresses: [String]? = nil, ipAddressType: IpAddressType? = nil, name: String, tags: [Tag]? = nil) {
            self.enabled = enabled
            self.idempotencyToken = idempotencyToken
            self.ipAddresses = ipAddresses
            self.ipAddressType = ipAddressType
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 255)
            try self.ipAddresses?.forEach {
                try validate($0, name: "ipAddresses[]", parent: name, max: 45)
            }
            try self.validate(self.ipAddresses, name: "ipAddresses", parent: name, max: 2)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case idempotencyToken = "IdempotencyToken"
            case ipAddresses = "IpAddresses"
            case ipAddressType = "IpAddressType"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateAcceleratorResponse: AWSDecodableShape {
        /// The accelerator that is created by specifying a listener and the supported IP address types.
        public let accelerator: Accelerator?

        public init(accelerator: Accelerator? = nil) {
            self.accelerator = accelerator
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
        }
    }

    public struct CreateCustomRoutingAcceleratorRequest: AWSEncodableShape {
        /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true.
        /// 	        If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.
        public let enabled: Bool?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that
        /// 			is, the uniquenessâ€”of the request.
        public let idempotencyToken: String
        /// Optionally, if you've added your own IP address pool to Global Accelerator (BYOIP), you can choose IP addresses
        /// 				from your own pool to use for the accelerator's static IP addresses when you create an accelerator. You can
        /// 				specify one or two addresses, separated by a space. Do not include the /32 suffix.
        /// 			      Only one IP address from each of your IP address ranges can be used for each accelerator. If you specify only
        /// 				one IP address from your IP address range, Global Accelerator assigns a second static IP address for the
        /// 				accelerator from the AWS IP address pool.
        /// 			      Note that you can't update IP addresses for an existing accelerator. To change them, you must create a new
        /// 				accelerator with the new addresses.
        /// 			      For more information, see Bring
        /// 				your own IP addresses (BYOIP) in the AWS Global Accelerator Developer Guide.
        public let ipAddresses: [String]?
        /// The value for the address type must be IPv4.
        public let ipAddressType: IpAddressType?
        /// The name of a custom routing accelerator. The name can have a maximum of 64 characters, must contain
        /// 		only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
        public let name: String
        /// Create tags for an accelerator.
        /// 	        For more information, see Tagging
        /// 		in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
        public let tags: [Tag]?

        public init(enabled: Bool? = nil, idempotencyToken: String = CreateCustomRoutingAcceleratorRequest.idempotencyToken(), ipAddresses: [String]? = nil, ipAddressType: IpAddressType? = nil, name: String, tags: [Tag]? = nil) {
            self.enabled = enabled
            self.idempotencyToken = idempotencyToken
            self.ipAddresses = ipAddresses
            self.ipAddressType = ipAddressType
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 255)
            try self.ipAddresses?.forEach {
                try validate($0, name: "ipAddresses[]", parent: name, max: 45)
            }
            try self.validate(self.ipAddresses, name: "ipAddresses", parent: name, max: 2)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case idempotencyToken = "IdempotencyToken"
            case ipAddresses = "IpAddresses"
            case ipAddressType = "IpAddressType"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateCustomRoutingAcceleratorResponse: AWSDecodableShape {
        /// The accelerator that is created.
        public let accelerator: CustomRoutingAccelerator?

        public init(accelerator: CustomRoutingAccelerator? = nil) {
            self.accelerator = accelerator
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
        }
    }

    public struct CreateCustomRoutingEndpointGroupRequest: AWSEncodableShape {
        /// Sets the port range and protocol for all endpoints (virtual private cloud subnets) in a custom routing endpoint group to accept
        /// 		client traffic on.
        public let destinationConfigurations: [CustomRoutingDestinationConfiguration]
        /// The AWS Region where the endpoint group is located. A listener can have only one endpoint group in a
        /// 		specific Region.
        public let endpointGroupRegion: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that is, the
        /// 		uniquenessâ€”of the request.
        public let idempotencyToken: String
        /// The Amazon Resource Name (ARN) of the listener for a custom routing endpoint.
        public let listenerArn: String

        public init(destinationConfigurations: [CustomRoutingDestinationConfiguration], endpointGroupRegion: String, idempotencyToken: String = CreateCustomRoutingEndpointGroupRequest.idempotencyToken(), listenerArn: String) {
            self.destinationConfigurations = destinationConfigurations
            self.endpointGroupRegion = endpointGroupRegion
            self.idempotencyToken = idempotencyToken
            self.listenerArn = listenerArn
        }

        public func validate(name: String) throws {
            try self.destinationConfigurations.forEach {
                try $0.validate(name: "\(name).destinationConfigurations[]")
            }
            try self.validate(self.destinationConfigurations, name: "destinationConfigurations", parent: name, max: 100)
            try self.validate(self.destinationConfigurations, name: "destinationConfigurations", parent: name, min: 1)
            try self.validate(self.endpointGroupRegion, name: "endpointGroupRegion", parent: name, max: 255)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 255)
            try self.validate(self.listenerArn, name: "listenerArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationConfigurations = "DestinationConfigurations"
            case endpointGroupRegion = "EndpointGroupRegion"
            case idempotencyToken = "IdempotencyToken"
            case listenerArn = "ListenerArn"
        }
    }

    public struct CreateCustomRoutingEndpointGroupResponse: AWSDecodableShape {
        /// The information about the endpoint group created for a custom routing accelerator.
        public let endpointGroup: CustomRoutingEndpointGroup?

        public init(endpointGroup: CustomRoutingEndpointGroup? = nil) {
            self.endpointGroup = endpointGroup
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroup = "EndpointGroup"
        }
    }

    public struct CreateCustomRoutingListenerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator for a custom routing listener.
        public let acceleratorArn: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that is, the
        /// 		uniquenessâ€”of the request.
        public let idempotencyToken: String
        /// The port range to support for connections from clients to your accelerator.
        /// 	        Separately, you set port ranges for endpoints. For more information, see About
        /// 		endpoints for custom routing accelerators.
        public let portRanges: [PortRange]

        public init(acceleratorArn: String, idempotencyToken: String = CreateCustomRoutingListenerRequest.idempotencyToken(), portRanges: [PortRange]) {
            self.acceleratorArn = acceleratorArn
            self.idempotencyToken = idempotencyToken
            self.portRanges = portRanges
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 255)
            try self.portRanges.forEach {
                try $0.validate(name: "\(name).portRanges[]")
            }
            try self.validate(self.portRanges, name: "portRanges", parent: name, max: 10)
            try self.validate(self.portRanges, name: "portRanges", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case idempotencyToken = "IdempotencyToken"
            case portRanges = "PortRanges"
        }
    }

    public struct CreateCustomRoutingListenerResponse: AWSDecodableShape {
        /// The listener that you've created for a custom routing accelerator.
        public let listener: CustomRoutingListener?

        public init(listener: CustomRoutingListener? = nil) {
            self.listener = listener
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
        }
    }

    public struct CreateEndpointGroupRequest: AWSEncodableShape {
        /// The list of endpoint objects.
        public let endpointConfigurations: [EndpointConfiguration]?
        /// The AWS Region where the endpoint group is located. A listener can have only one endpoint group in a
        /// 			specific Region.
        public let endpointGroupRegion: String
        /// The timeâ€”10 seconds or 30 secondsâ€”between each health check for an endpoint. The default value is 30.
        public let healthCheckIntervalSeconds: Int?
        /// If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The
        /// 			default value is slash (/).
        public let healthCheckPath: String?
        /// The port that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port
        /// 			is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the
        /// 			first port in the list.
        public let healthCheckPort: Int?
        /// The protocol that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default
        /// 			value is TCP.
        public let healthCheckProtocol: HealthCheckProtocol?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that is, the
        /// 			uniquenessâ€”of the request.
        public let idempotencyToken: String
        /// The Amazon Resource Name (ARN) of the listener.
        public let listenerArn: String
        /// Override specific listener ports used to route traffic to endpoints that are part of this endpoint group.
        /// 			For example, you can create a port override in which the listener
        /// 			receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080
        /// 			and 1443, respectively, on the endpoints.
        /// 		       For more information, see
        /// 			Port overrides in the AWS Global Accelerator Developer Guide.
        public let portOverrides: [PortOverride]?
        /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an
        /// 			unhealthy endpoint to healthy. The default value is 3.
        public let thresholdCount: Int?
        /// The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for
        /// 			this listener.
        /// 		       Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is
        /// 			applied to the traffic that would otherwise have been routed to the Region based on optimal routing.
        /// 		       The default value is 100.
        public let trafficDialPercentage: Float?

        public init(endpointConfigurations: [EndpointConfiguration]? = nil, endpointGroupRegion: String, healthCheckIntervalSeconds: Int? = nil, healthCheckPath: String? = nil, healthCheckPort: Int? = nil, healthCheckProtocol: HealthCheckProtocol? = nil, idempotencyToken: String = CreateEndpointGroupRequest.idempotencyToken(), listenerArn: String, portOverrides: [PortOverride]? = nil, thresholdCount: Int? = nil, trafficDialPercentage: Float? = nil) {
            self.endpointConfigurations = endpointConfigurations
            self.endpointGroupRegion = endpointGroupRegion
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.idempotencyToken = idempotencyToken
            self.listenerArn = listenerArn
            self.portOverrides = portOverrides
            self.thresholdCount = thresholdCount
            self.trafficDialPercentage = trafficDialPercentage
        }

        public func validate(name: String) throws {
            try self.endpointConfigurations?.forEach {
                try $0.validate(name: "\(name).endpointConfigurations[]")
            }
            try self.validate(self.endpointConfigurations, name: "endpointConfigurations", parent: name, max: 10)
            try self.validate(self.endpointGroupRegion, name: "endpointGroupRegion", parent: name, max: 255)
            try self.validate(self.healthCheckIntervalSeconds, name: "healthCheckIntervalSeconds", parent: name, max: 30)
            try self.validate(self.healthCheckIntervalSeconds, name: "healthCheckIntervalSeconds", parent: name, min: 10)
            try self.validate(self.healthCheckPath, name: "healthCheckPath", parent: name, max: 255)
            try self.validate(self.healthCheckPath, name: "healthCheckPath", parent: name, pattern: "^/[-a-zA-Z0-9@:%_\\\\+.~#?&/=]*$")
            try self.validate(self.healthCheckPort, name: "healthCheckPort", parent: name, max: 65535)
            try self.validate(self.healthCheckPort, name: "healthCheckPort", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 255)
            try self.validate(self.listenerArn, name: "listenerArn", parent: name, max: 255)
            try self.portOverrides?.forEach {
                try $0.validate(name: "\(name).portOverrides[]")
            }
            try self.validate(self.portOverrides, name: "portOverrides", parent: name, max: 10)
            try self.validate(self.thresholdCount, name: "thresholdCount", parent: name, max: 10)
            try self.validate(self.thresholdCount, name: "thresholdCount", parent: name, min: 1)
            try self.validate(self.trafficDialPercentage, name: "trafficDialPercentage", parent: name, max: 100.0)
            try self.validate(self.trafficDialPercentage, name: "trafficDialPercentage", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigurations = "EndpointConfigurations"
            case endpointGroupRegion = "EndpointGroupRegion"
            case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
            case healthCheckPath = "HealthCheckPath"
            case healthCheckPort = "HealthCheckPort"
            case healthCheckProtocol = "HealthCheckProtocol"
            case idempotencyToken = "IdempotencyToken"
            case listenerArn = "ListenerArn"
            case portOverrides = "PortOverrides"
            case thresholdCount = "ThresholdCount"
            case trafficDialPercentage = "TrafficDialPercentage"
        }
    }

    public struct CreateEndpointGroupResponse: AWSDecodableShape {
        /// The information about the endpoint group that was created.
        public let endpointGroup: EndpointGroup?

        public init(endpointGroup: EndpointGroup? = nil) {
            self.endpointGroup = endpointGroup
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroup = "EndpointGroup"
        }
    }

    public struct CreateListenerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of your accelerator.
        public let acceleratorArn: String
        /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications,
        /// 			regardless of the port and protocol of the client request. Client affinity gives you control over whether to always
        /// 			route each client to the same specific endpoint.
        /// 		       AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client
        /// 			affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) propertiesâ€”source IP address, source port,
        /// 			destination IP address, destination port, and protocolâ€”to select the hash value, and then chooses the best
        /// 			endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not
        /// 			be always routed to the same endpoint because the hash value changes.
        /// 		       If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP
        /// 			instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) propertiesâ€”
        /// 			source (client) IP address and destination IP addressâ€”to select the hash value.
        /// 		       The default value is NONE.
        public let clientAffinity: ClientAffinity?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotencyâ€”that is, the
        /// 			uniquenessâ€”of the request.
        public let idempotencyToken: String
        /// The list of port ranges to support for connections from clients to your accelerator.
        public let portRanges: [PortRange]
        /// The protocol for connections from clients to your accelerator.
        public let `protocol`: Protocol

        public init(acceleratorArn: String, clientAffinity: ClientAffinity? = nil, idempotencyToken: String = CreateListenerRequest.idempotencyToken(), portRanges: [PortRange], protocol: Protocol) {
            self.acceleratorArn = acceleratorArn
            self.clientAffinity = clientAffinity
            self.idempotencyToken = idempotencyToken
            self.portRanges = portRanges
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 255)
            try self.portRanges.forEach {
                try $0.validate(name: "\(name).portRanges[]")
            }
            try self.validate(self.portRanges, name: "portRanges", parent: name, max: 10)
            try self.validate(self.portRanges, name: "portRanges", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case clientAffinity = "ClientAffinity"
            case idempotencyToken = "IdempotencyToken"
            case portRanges = "PortRanges"
            case `protocol` = "Protocol"
        }
    }

    public struct CreateListenerResponse: AWSDecodableShape {
        /// The listener that you've created.
        public let listener: Listener?

        public init(listener: Listener? = nil) {
            self.listener = listener
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
        }
    }

    public struct CustomRoutingAccelerator: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator.
        public let acceleratorArn: String?
        /// The date and time that the accelerator was created.
        public let createdTime: Date?
        /// The Domain Name System (DNS) name that Global Accelerator creates that points to your accelerator's static IP addresses.
        /// 		       The naming convention for the DNS name is the following: A lowercase letter a,
        /// 			followed by a 16-bit random hex string, followed by .awsglobalaccelerator.com. For example:
        /// 			a1234567890abcdef.awsglobalaccelerator.com.
        /// 		       For more information about the default DNS name, see
        /// 			Support for DNS Addressing in Global Accelerator in the AWS Global Accelerator Developer Guide.
        public let dnsName: String?
        /// Indicates whether the accelerator is enabled. The value is true or false. The default value is true.
        /// 		       If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.
        public let enabled: Bool?
        /// The value for the address type must be IPv4.
        public let ipAddressType: IpAddressType?
        /// The static IP addresses that Global Accelerator associates with the accelerator.
        public let ipSets: [IpSet]?
        /// The date and time that the accelerator was last modified.
        public let lastModifiedTime: Date?
        /// The name of the accelerator. The name must contain only alphanumeric characters or
        /// 			hyphens (-), and must not begin or end with a hyphen.
        public let name: String?
        /// Describes the deployment status of the accelerator.
        public let status: CustomRoutingAcceleratorStatus?

        public init(acceleratorArn: String? = nil, createdTime: Date? = nil, dnsName: String? = nil, enabled: Bool? = nil, ipAddressType: IpAddressType? = nil, ipSets: [IpSet]? = nil, lastModifiedTime: Date? = nil, name: String? = nil, status: CustomRoutingAcceleratorStatus? = nil) {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case createdTime = "CreatedTime"
            case dnsName = "DnsName"
            case enabled = "Enabled"
            case ipAddressType = "IpAddressType"
            case ipSets = "IpSets"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct CustomRoutingAcceleratorAttributes: AWSDecodableShape {
        /// Indicates whether flow logs are enabled. The default value is false. If the value is true,
        /// 			FlowLogsS3Bucket and FlowLogsS3Prefix must be specified.
        /// 		       For more information, see Flow Logs in
        /// 			the AWS Global Accelerator Developer Guide.
        public let flowLogsEnabled: Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is
        /// 			true. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
        /// 			bucket.
        public let flowLogsS3Bucket: String?
        /// The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
        /// 			FlowLogsEnabled is true.
        /// 		       If you donâ€™t specify a prefix, the flow logs are stored in the
        /// 			root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:
        /// 		       DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id
        public let flowLogsS3Prefix: String?

        public init(flowLogsEnabled: Bool? = nil, flowLogsS3Bucket: String? = nil, flowLogsS3Prefix: String? = nil) {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }

        private enum CodingKeys: String, CodingKey {
            case flowLogsEnabled = "FlowLogsEnabled"
            case flowLogsS3Bucket = "FlowLogsS3Bucket"
            case flowLogsS3Prefix = "FlowLogsS3Prefix"
        }
    }

    public struct CustomRoutingDestinationConfiguration: AWSEncodableShape {
        /// The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        public let fromPort: Int
        /// The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.
        public let protocols: [CustomRoutingProtocol]
        /// The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        public let toPort: Int

        public init(fromPort: Int, protocols: [CustomRoutingProtocol], toPort: Int) {
            self.fromPort = fromPort
            self.protocols = protocols
            self.toPort = toPort
        }

        public func validate(name: String) throws {
            try self.validate(self.fromPort, name: "fromPort", parent: name, max: 65535)
            try self.validate(self.fromPort, name: "fromPort", parent: name, min: 1)
            try self.validate(self.protocols, name: "protocols", parent: name, max: 2)
            try self.validate(self.protocols, name: "protocols", parent: name, min: 1)
            try self.validate(self.toPort, name: "toPort", parent: name, max: 65535)
            try self.validate(self.toPort, name: "toPort", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case protocols = "Protocols"
            case toPort = "ToPort"
        }
    }

    public struct CustomRoutingDestinationDescription: AWSDecodableShape {
        /// The first port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        public let fromPort: Int?
        /// The protocol for the endpoint group that is associated with a custom routing accelerator. The protocol can be either TCP or UDP.
        public let protocols: [Protocol]?
        /// The last port, inclusive, in the range of ports for the endpoint group that is associated with a custom routing accelerator.
        public let toPort: Int?

        public init(fromPort: Int? = nil, protocols: [Protocol]? = nil, toPort: Int? = nil) {
            self.fromPort = fromPort
            self.protocols = protocols
            self.toPort = toPort
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case protocols = "Protocols"
            case toPort = "ToPort"
        }
    }

    public struct CustomRoutingEndpointConfiguration: AWSEncodableShape {
        /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC)
        /// 			subnet ID.
        public let endpointId: String?

        public init(endpointId: String? = nil) {
            self.endpointId = endpointId
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointId, name: "endpointId", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointId = "EndpointId"
        }
    }

    public struct CustomRoutingEndpointDescription: AWSDecodableShape {
        /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC)
        /// 			subnet ID.
        public let endpointId: String?

        public init(endpointId: String? = nil) {
            self.endpointId = endpointId
        }

        private enum CodingKeys: String, CodingKey {
            case endpointId = "EndpointId"
        }
    }

    public struct CustomRoutingEndpointGroup: AWSDecodableShape {
        /// For a custom routing accelerator, describes the port range and protocol for all endpoints
        /// 			(virtual private cloud subnets) in an endpoint group to accept client traffic on.
        public let destinationDescriptions: [CustomRoutingDestinationDescription]?
        /// For a custom routing accelerator, describes the endpoints (virtual private cloud subnets) in an
        /// 			endpoint group to accept client traffic on.
        public let endpointDescriptions: [CustomRoutingEndpointDescription]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public let endpointGroupArn: String?
        /// The AWS Region where the endpoint group is located.
        public let endpointGroupRegion: String?

        public init(destinationDescriptions: [CustomRoutingDestinationDescription]? = nil, endpointDescriptions: [CustomRoutingEndpointDescription]? = nil, endpointGroupArn: String? = nil, endpointGroupRegion: String? = nil) {
            self.destinationDescriptions = destinationDescriptions
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
        }

        private enum CodingKeys: String, CodingKey {
            case destinationDescriptions = "DestinationDescriptions"
            case endpointDescriptions = "EndpointDescriptions"
            case endpointGroupArn = "EndpointGroupArn"
            case endpointGroupRegion = "EndpointGroupRegion"
        }
    }

    public struct CustomRoutingListener: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let listenerArn: String?
        /// The port range to support for connections from clients to your accelerator.
        /// 		       Separately, you set port ranges for endpoints. For more information, see About
        /// 				endpoints for custom routing accelerators.
        public let portRanges: [PortRange]?

        public init(listenerArn: String? = nil, portRanges: [PortRange]? = nil) {
            self.listenerArn = listenerArn
            self.portRanges = portRanges
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
            case portRanges = "PortRanges"
        }
    }

    public struct DeleteAcceleratorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of an accelerator.
        public let acceleratorArn: String

        public init(acceleratorArn: String) {
            self.acceleratorArn = acceleratorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
        }
    }

    public struct DeleteCustomRoutingAcceleratorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator to delete.
        public let acceleratorArn: String

        public init(acceleratorArn: String) {
            self.acceleratorArn = acceleratorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
        }
    }

    public struct DeleteCustomRoutingEndpointGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint group to delete.
        public let endpointGroupArn: String

        public init(endpointGroupArn: String) {
            self.endpointGroupArn = endpointGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointGroupArn, name: "endpointGroupArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroupArn = "EndpointGroupArn"
        }
    }

    public struct DeleteCustomRoutingListenerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the listener to delete.
        public let listenerArn: String

        public init(listenerArn: String) {
            self.listenerArn = listenerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerArn, name: "listenerArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
        }
    }

    public struct DeleteEndpointGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint group to delete.
        public let endpointGroupArn: String

        public init(endpointGroupArn: String) {
            self.endpointGroupArn = endpointGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointGroupArn, name: "endpointGroupArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroupArn = "EndpointGroupArn"
        }
    }

    public struct DeleteListenerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let listenerArn: String

        public init(listenerArn: String) {
            self.listenerArn = listenerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerArn, name: "listenerArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
        }
    }

    public struct DenyCustomRoutingTrafficRequest: AWSEncodableShape {
        /// Indicates whether all destination IP addresses and ports for a specified VPC subnet endpoint cannot
        /// 			receive traffic from a custom routing accelerator. The value is TRUE or FALSE.
        /// 		       When set to TRUE, no destinations in the custom routing VPC subnet can receive traffic. Note
        /// 			that you cannot specify destination IP addresses and ports when the value is set to TRUE.
        /// 		       When set to FALSE (or not specified), you must specify a list of destination IP addresses that cannot receive
        /// 			traffic. A list of ports is optional. If you don't specify a list of ports, the ports that can accept traffic is
        /// 			the same as the ports configured for the endpoint group.
        /// 		       The default value is FALSE.
        public let denyAllTrafficToEndpoint: Bool?
        /// A list of specific Amazon EC2 instance IP addresses (destination addresses) in a subnet that you want to prevent from receiving
        /// 			traffic. The IP addresses must be a subset of the IP addresses allowed for the VPC subnet associated with the
        /// 			endpoint group.
        public let destinationAddresses: [String]?
        /// A list of specific Amazon EC2 instance ports (destination ports) in a subnet endpoint that you want to prevent from
        /// 			receiving traffic.
        public let destinationPorts: [Int]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public let endpointGroupArn: String
        /// An ID for the endpoint. For custom routing accelerators, this is the virtual private cloud (VPC) subnet ID.
        public let endpointId: String

        public init(denyAllTrafficToEndpoint: Bool? = nil, destinationAddresses: [String]? = nil, destinationPorts: [Int]? = nil, endpointGroupArn: String, endpointId: String) {
            self.denyAllTrafficToEndpoint = denyAllTrafficToEndpoint
            self.destinationAddresses = destinationAddresses
            self.destinationPorts = destinationPorts
            self.endpointGroupArn = endpointGroupArn
            self.endpointId = endpointId
        }

        public func validate(name: String) throws {
            try self.destinationAddresses?.forEach {
                try validate($0, name: "destinationAddresses[]", parent: name, max: 45)
            }
            try self.validate(self.destinationAddresses, name: "destinationAddresses", parent: name, max: 100)
            try self.destinationPorts?.forEach {
                try validate($0, name: "destinationPorts[]", parent: name, max: 65535)
                try validate($0, name: "destinationPorts[]", parent: name, min: 1)
            }
            try self.validate(self.destinationPorts, name: "destinationPorts", parent: name, max: 100)
            try self.validate(self.endpointGroupArn, name: "endpointGroupArn", parent: name, max: 255)
            try self.validate(self.endpointId, name: "endpointId", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case denyAllTrafficToEndpoint = "DenyAllTrafficToEndpoint"
            case destinationAddresses = "DestinationAddresses"
            case destinationPorts = "DestinationPorts"
            case endpointGroupArn = "EndpointGroupArn"
            case endpointId = "EndpointId"
        }
    }

    public struct DeprovisionByoipCidrRequest: AWSEncodableShape {
        /// The address range, in CIDR notation. The prefix must be the same prefix that you specified
        /// 			when you provisioned the address range.
        public let cidr: String

        public init(cidr: String) {
            self.cidr = cidr
        }

        public func validate(name: String) throws {
            try self.validate(self.cidr, name: "cidr", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "Cidr"
        }
    }

    public struct DeprovisionByoipCidrResponse: AWSDecodableShape {
        /// Information about the address range.
        public let byoipCidr: ByoipCidr?

        public init(byoipCidr: ByoipCidr? = nil) {
            self.byoipCidr = byoipCidr
        }

        private enum CodingKeys: String, CodingKey {
            case byoipCidr = "ByoipCidr"
        }
    }

    public struct DescribeAcceleratorAttributesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator with the attributes that you want to describe.
        public let acceleratorArn: String

        public init(acceleratorArn: String) {
            self.acceleratorArn = acceleratorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
        }
    }

    public struct DescribeAcceleratorAttributesResponse: AWSDecodableShape {
        /// The attributes of the accelerator.
        public let acceleratorAttributes: AcceleratorAttributes?

        public init(acceleratorAttributes: AcceleratorAttributes? = nil) {
            self.acceleratorAttributes = acceleratorAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorAttributes = "AcceleratorAttributes"
        }
    }

    public struct DescribeAcceleratorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator to describe.
        public let acceleratorArn: String

        public init(acceleratorArn: String) {
            self.acceleratorArn = acceleratorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
        }
    }

    public struct DescribeAcceleratorResponse: AWSDecodableShape {
        /// The description of the accelerator.
        public let accelerator: Accelerator?

        public init(accelerator: Accelerator? = nil) {
            self.accelerator = accelerator
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
        }
    }

    public struct DescribeCustomRoutingAcceleratorAttributesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator to describe the attributes for.
        public let acceleratorArn: String

        public init(acceleratorArn: String) {
            self.acceleratorArn = acceleratorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
        }
    }

    public struct DescribeCustomRoutingAcceleratorAttributesResponse: AWSDecodableShape {
        /// The attributes of the custom routing accelerator.
        public let acceleratorAttributes: CustomRoutingAcceleratorAttributes?

        public init(acceleratorAttributes: CustomRoutingAcceleratorAttributes? = nil) {
            self.acceleratorAttributes = acceleratorAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorAttributes = "AcceleratorAttributes"
        }
    }

    public struct DescribeCustomRoutingAcceleratorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator to describe.
        public let acceleratorArn: String

        public init(acceleratorArn: String) {
            self.acceleratorArn = acceleratorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
        }
    }

    public struct DescribeCustomRoutingAcceleratorResponse: AWSDecodableShape {
        /// The description of the custom routing accelerator.
        public let accelerator: CustomRoutingAccelerator?

        public init(accelerator: CustomRoutingAccelerator? = nil) {
            self.accelerator = accelerator
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
        }
    }

    public struct DescribeCustomRoutingEndpointGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint group to describe.
        public let endpointGroupArn: String

        public init(endpointGroupArn: String) {
            self.endpointGroupArn = endpointGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointGroupArn, name: "endpointGroupArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroupArn = "EndpointGroupArn"
        }
    }

    public struct DescribeCustomRoutingEndpointGroupResponse: AWSDecodableShape {
        /// The description of an endpoint group for a custom routing accelerator.
        public let endpointGroup: CustomRoutingEndpointGroup?

        public init(endpointGroup: CustomRoutingEndpointGroup? = nil) {
            self.endpointGroup = endpointGroup
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroup = "EndpointGroup"
        }
    }

    public struct DescribeCustomRoutingListenerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the listener to describe.
        public let listenerArn: String

        public init(listenerArn: String) {
            self.listenerArn = listenerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerArn, name: "listenerArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
        }
    }

    public struct DescribeCustomRoutingListenerResponse: AWSDecodableShape {
        /// The description of a listener for a custom routing accelerator.
        public let listener: CustomRoutingListener?

        public init(listener: CustomRoutingListener? = nil) {
            self.listener = listener
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
        }
    }

    public struct DescribeEndpointGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint group to describe.
        public let endpointGroupArn: String

        public init(endpointGroupArn: String) {
            self.endpointGroupArn = endpointGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointGroupArn, name: "endpointGroupArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroupArn = "EndpointGroupArn"
        }
    }

    public struct DescribeEndpointGroupResponse: AWSDecodableShape {
        /// The description of an endpoint group.
        public let endpointGroup: EndpointGroup?

        public init(endpointGroup: EndpointGroup? = nil) {
            self.endpointGroup = endpointGroup
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroup = "EndpointGroup"
        }
    }

    public struct DescribeListenerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the listener to describe.
        public let listenerArn: String

        public init(listenerArn: String) {
            self.listenerArn = listenerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerArn, name: "listenerArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
        }
    }

    public struct DescribeListenerResponse: AWSDecodableShape {
        /// The description of a listener.
        public let listener: Listener?

        public init(listener: Listener? = nil) {
            self.listener = listener
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
        }
    }

    public struct DestinationPortMapping: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator
        /// 			that you have port mappings for.
        public let acceleratorArn: String?
        /// The IP address/port combinations (sockets) that map to a given destination socket
        /// 			address.
        public let acceleratorSocketAddresses: [SocketAddress]?
        /// The endpoint IP address/port combination for traffic received on the accelerator socket address.
        public let destinationSocketAddress: SocketAddress?
        /// Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if
        /// 			traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.
        public let destinationTrafficState: CustomRoutingDestinationTrafficState?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public let endpointGroupArn: String?
        /// The AWS Region for the endpoint group.
        public let endpointGroupRegion: String?
        /// The ID for the virtual private cloud (VPC) subnet.
        public let endpointId: String?
        /// The IP address type, which must be IPv4.
        public let ipAddressType: IpAddressType?

        public init(acceleratorArn: String? = nil, acceleratorSocketAddresses: [SocketAddress]? = nil, destinationSocketAddress: SocketAddress? = nil, destinationTrafficState: CustomRoutingDestinationTrafficState? = nil, endpointGroupArn: String? = nil, endpointGroupRegion: String? = nil, endpointId: String? = nil, ipAddressType: IpAddressType? = nil) {
            self.acceleratorArn = acceleratorArn
            self.acceleratorSocketAddresses = acceleratorSocketAddresses
            self.destinationSocketAddress = destinationSocketAddress
            self.destinationTrafficState = destinationTrafficState
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.endpointId = endpointId
            self.ipAddressType = ipAddressType
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case acceleratorSocketAddresses = "AcceleratorSocketAddresses"
            case destinationSocketAddress = "DestinationSocketAddress"
            case destinationTrafficState = "DestinationTrafficState"
            case endpointGroupArn = "EndpointGroupArn"
            case endpointGroupRegion = "EndpointGroupRegion"
            case endpointId = "EndpointId"
            case ipAddressType = "IpAddressType"
        }
    }

    public struct EndpointConfiguration: AWSEncodableShape {
        /// Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint.
        /// 			The value is true or false. The default value is true for new accelerators.
        /// 		       If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as
        /// 			traffic travels to applications on the Application Load Balancer endpoint fronted by the accelerator.
        /// 		       For more information, see
        /// 			Preserve Client IP Addresses in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
        public let clientIPPreservationEnabled: Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon
        /// 			Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address
        /// 			allocation ID. For Amazon EC2 instances, this is the EC2 instance ID. A resource must be valid and active
        /// 			when you add it as an endpoint.
        /// 		       An Application Load Balancer can be either internal or internet-facing.
        public let endpointId: String?
        /// The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic
        /// 			based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The
        /// 			result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second
        /// 			and third endpoints, and 6/20 is routed to the last endpoint. For more information, see Endpoint Weights in the
        /// 				AWS Global Accelerator Developer Guide.
        public let weight: Int?

        public init(clientIPPreservationEnabled: Bool? = nil, endpointId: String? = nil, weight: Int? = nil) {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointId, name: "endpointId", parent: name, max: 255)
            try self.validate(self.weight, name: "weight", parent: name, max: 255)
            try self.validate(self.weight, name: "weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
            case endpointId = "EndpointId"
            case weight = "Weight"
        }
    }

    public struct EndpointDescription: AWSDecodableShape {
        /// Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint.
        /// 			The value is true or false. The default value is true for new accelerators.
        /// 		       If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as
        /// 			traffic travels to applications on the Application Load Balancer endpoint fronted by the accelerator.
        /// 		       For more information, see
        /// 			Viewing Client IP Addresses in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
        public let clientIPPreservationEnabled: Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon
        /// 			Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address
        /// 			allocation ID. For Amazon EC2 instances, this is the EC2 instance ID.
        /// 		       An Application Load Balancer can be either internal or internet-facing.
        public let endpointId: String?
        /// Returns a null result.
        public let healthReason: String?
        /// The health status of the endpoint.
        public let healthState: HealthState?
        /// The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic
        /// 			based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The
        /// 			result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second
        /// 			and third endpoints, and 6/20 is routed to the last endpoint. For more information, see Endpoint Weights in the
        /// 				AWS Global Accelerator Developer Guide.
        public let weight: Int?

        public init(clientIPPreservationEnabled: Bool? = nil, endpointId: String? = nil, healthReason: String? = nil, healthState: HealthState? = nil, weight: Int? = nil) {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.healthReason = healthReason
            self.healthState = healthState
            self.weight = weight
        }

        private enum CodingKeys: String, CodingKey {
            case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
            case endpointId = "EndpointId"
            case healthReason = "HealthReason"
            case healthState = "HealthState"
            case weight = "Weight"
        }
    }

    public struct EndpointGroup: AWSDecodableShape {
        /// The list of endpoint objects.
        public let endpointDescriptions: [EndpointDescription]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public let endpointGroupArn: String?
        /// The AWS Region where the endpoint group is located.
        public let endpointGroupRegion: String?
        /// The timeâ€”10 seconds or 30 secondsâ€”between health checks for each endpoint. The default value is 30.
        public let healthCheckIntervalSeconds: Int?
        /// If the protocol is HTTP/S, then this value provides the ping path that Global Accelerator uses for the destination on the
        /// 			endpoints for health checks. The default is slash (/).
        public let healthCheckPath: String?
        /// The port that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group.
        ///
        /// 		       The default port is the port for the listener that this endpoint group is associated with. If the listener port is a
        /// 			list, Global Accelerator uses the first specified port in the list of ports.
        public let healthCheckPort: Int?
        /// The protocol that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. The default
        /// 			value is TCP.
        public let healthCheckProtocol: HealthCheckProtocol?
        /// Allows you to override the destination ports used to route traffic to an endpoint.
        /// 			Using a port override lets you to map a list of external destination ports (that your
        /// 			users send traffic to) to a list of internal destination ports that you want an application
        /// 			endpoint to receive traffic on.
        public let portOverrides: [PortOverride]?
        /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an
        /// 			unhealthy endpoint to healthy. The default value is 3.
        public let thresholdCount: Int?
        /// The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for
        /// 			this listener.
        /// 		       Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is
        /// 			applied to the traffic that would otherwise have been routed to the Region based on optimal routing.
        /// 		       The default value is 100.
        public let trafficDialPercentage: Float?

        public init(endpointDescriptions: [EndpointDescription]? = nil, endpointGroupArn: String? = nil, endpointGroupRegion: String? = nil, healthCheckIntervalSeconds: Int? = nil, healthCheckPath: String? = nil, healthCheckPort: Int? = nil, healthCheckProtocol: HealthCheckProtocol? = nil, portOverrides: [PortOverride]? = nil, thresholdCount: Int? = nil, trafficDialPercentage: Float? = nil) {
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.portOverrides = portOverrides
            self.thresholdCount = thresholdCount
            self.trafficDialPercentage = trafficDialPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case endpointDescriptions = "EndpointDescriptions"
            case endpointGroupArn = "EndpointGroupArn"
            case endpointGroupRegion = "EndpointGroupRegion"
            case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
            case healthCheckPath = "HealthCheckPath"
            case healthCheckPort = "HealthCheckPort"
            case healthCheckProtocol = "HealthCheckProtocol"
            case portOverrides = "PortOverrides"
            case thresholdCount = "ThresholdCount"
            case trafficDialPercentage = "TrafficDialPercentage"
        }
    }

    public struct IpSet: AWSDecodableShape {
        /// The array of IP addresses in the IP address set. An IP address set can have a maximum of two IP addresses.
        public let ipAddresses: [String]?
        /// The types of IP addresses included in this IP set.
        public let ipFamily: String?

        public init(ipAddresses: [String]? = nil, ipFamily: String? = nil) {
            self.ipAddresses = ipAddresses
            self.ipFamily = ipFamily
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddresses = "IpAddresses"
            case ipFamily = "IpFamily"
        }
    }

    public struct ListAcceleratorsRequest: AWSEncodableShape {
        /// The number of Global Accelerator objects that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListAcceleratorsResponse: AWSDecodableShape {
        /// The list of accelerators for a customer account.
        public let accelerators: [Accelerator]?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(accelerators: [Accelerator]? = nil, nextToken: String? = nil) {
            self.accelerators = accelerators
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accelerators = "Accelerators"
            case nextToken = "NextToken"
        }
    }

    public struct ListByoipCidrsRequest: AWSEncodableShape {
        /// The maximum number of results to return with a single call. To retrieve the remaining results, make
        /// 			another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListByoipCidrsResponse: AWSDecodableShape {
        /// Information about your address ranges.
        public let byoipCidrs: [ByoipCidr]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(byoipCidrs: [ByoipCidr]? = nil, nextToken: String? = nil) {
            self.byoipCidrs = byoipCidrs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case byoipCidrs = "ByoipCidrs"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomRoutingAcceleratorsRequest: AWSEncodableShape {
        /// The number of custom routing Global Accelerator objects that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomRoutingAcceleratorsResponse: AWSDecodableShape {
        /// The list of custom routing accelerators for a customer account.
        public let accelerators: [CustomRoutingAccelerator]?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(accelerators: [CustomRoutingAccelerator]? = nil, nextToken: String? = nil) {
            self.accelerators = accelerators
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accelerators = "Accelerators"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomRoutingEndpointGroupsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the listener to list endpoint groups for.
        public let listenerArn: String
        /// The number of endpoint group objects that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(listenerArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.listenerArn = listenerArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerArn, name: "listenerArn", parent: name, max: 255)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomRoutingEndpointGroupsResponse: AWSDecodableShape {
        /// The list of the endpoint groups associated with a listener for a custom routing accelerator.
        public let endpointGroups: [CustomRoutingEndpointGroup]?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(endpointGroups: [CustomRoutingEndpointGroup]? = nil, nextToken: String? = nil) {
            self.endpointGroups = endpointGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroups = "EndpointGroups"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomRoutingListenersRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator to list listeners for.
        public let acceleratorArn: String
        /// The number of listener objects that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(acceleratorArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.acceleratorArn = acceleratorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomRoutingListenersResponse: AWSDecodableShape {
        /// The list of listeners for a custom routing accelerator.
        public let listeners: [CustomRoutingListener]?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(listeners: [CustomRoutingListener]? = nil, nextToken: String? = nil) {
            self.listeners = listeners
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case listeners = "Listeners"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomRoutingPortMappingsByDestinationRequest: AWSEncodableShape {
        /// The endpoint IP address in a virtual private cloud (VPC) subnet for which you want to receive back port
        /// 		mappings.
        public let destinationAddress: String
        /// The ID for the virtual private cloud (VPC) subnet.
        public let endpointId: String
        /// The number of destination port mappings that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(destinationAddress: String, endpointId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.destinationAddress = destinationAddress
            self.endpointId = endpointId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationAddress, name: "destinationAddress", parent: name, max: 255)
            try self.validate(self.endpointId, name: "endpointId", parent: name, max: 255)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationAddress = "DestinationAddress"
            case endpointId = "EndpointId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomRoutingPortMappingsByDestinationResponse: AWSDecodableShape {
        /// The port mappings for the endpoint IP address that you specified in the request.
        public let destinationPortMappings: [DestinationPortMapping]?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(destinationPortMappings: [DestinationPortMapping]? = nil, nextToken: String? = nil) {
            self.destinationPortMappings = destinationPortMappings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case destinationPortMappings = "DestinationPortMappings"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomRoutingPortMappingsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator to list the custom routing port mappings for.
        public let acceleratorArn: String
        /// The Amazon Resource Name (ARN) of the endpoint group to list the custom routing port mappings for.
        public let endpointGroupArn: String?
        /// The number of destination port mappings that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(acceleratorArn: String, endpointGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.acceleratorArn = acceleratorArn
            self.endpointGroupArn = endpointGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
            try self.validate(self.endpointGroupArn, name: "endpointGroupArn", parent: name, max: 255)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case endpointGroupArn = "EndpointGroupArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListCustomRoutingPortMappingsResponse: AWSDecodableShape {
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The port mappings for a custom routing accelerator.
        public let portMappings: [PortMapping]?

        public init(nextToken: String? = nil, portMappings: [PortMapping]? = nil) {
            self.nextToken = nextToken
            self.portMappings = portMappings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case portMappings = "PortMappings"
        }
    }

    public struct ListEndpointGroupsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let listenerArn: String
        /// The number of endpoint group objects that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(listenerArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.listenerArn = listenerArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerArn, name: "listenerArn", parent: name, max: 255)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListEndpointGroupsResponse: AWSDecodableShape {
        /// The list of the endpoint groups associated with a listener.
        public let endpointGroups: [EndpointGroup]?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(endpointGroups: [EndpointGroup]? = nil, nextToken: String? = nil) {
            self.endpointGroups = endpointGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroups = "EndpointGroups"
            case nextToken = "NextToken"
        }
    }

    public struct ListListenersRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator for which you want to list listener objects.
        public let acceleratorArn: String
        /// The number of listener objects that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(acceleratorArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.acceleratorArn = acceleratorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListListenersResponse: AWSDecodableShape {
        /// The list of listeners for an accelerator.
        public let listeners: [Listener]?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(listeners: [Listener]? = nil, nextToken: String? = nil) {
            self.listeners = listeners
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case listeners = "Listeners"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator to list tags for. An ARN uniquely identifies an accelerator.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Root level tag for the Tags parameters.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Listener: AWSDecodableShape {
        /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications,
        /// 			regardless of the port and protocol of the client request. Client affinity gives you control over whether to always
        /// 			route each client to the same specific endpoint.
        /// 		       AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client
        /// 			affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) propertiesâ€”source IP address, source port,
        /// 			destination IP address, destination port, and protocolâ€”to select the hash value, and then chooses the best
        /// 			endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not
        /// 			be always routed to the same endpoint because the hash value changes.
        /// 		       If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP
        /// 			instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) propertiesâ€”
        /// 			source (client) IP address and destination IP addressâ€”to select the hash value.
        /// 		       The default value is NONE.
        public let clientAffinity: ClientAffinity?
        /// The Amazon Resource Name (ARN) of the listener.
        public let listenerArn: String?
        /// The list of port ranges for the connections from clients to the accelerator.
        public let portRanges: [PortRange]?
        /// The protocol for the connections from clients to the accelerator.
        public let `protocol`: Protocol?

        public init(clientAffinity: ClientAffinity? = nil, listenerArn: String? = nil, portRanges: [PortRange]? = nil, protocol: Protocol? = nil) {
            self.clientAffinity = clientAffinity
            self.listenerArn = listenerArn
            self.portRanges = portRanges
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case clientAffinity = "ClientAffinity"
            case listenerArn = "ListenerArn"
            case portRanges = "PortRanges"
            case `protocol` = "Protocol"
        }
    }

    public struct PortMapping: AWSDecodableShape {
        /// The accelerator port.
        public let acceleratorPort: Int?
        /// The EC2 instance IP address and port number in the virtual private cloud (VPC) subnet.
        public let destinationSocketAddress: SocketAddress?
        /// Indicates whether or not a port mapping destination can receive traffic. The value is either ALLOW, if
        /// 			traffic is allowed to the destination, or DENY, if traffic is not allowed to the destination.
        public let destinationTrafficState: CustomRoutingDestinationTrafficState?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public let endpointGroupArn: String?
        /// The IP address of the VPC subnet (the subnet ID).
        public let endpointId: String?
        /// The protocols supported by the endpoint group.
        public let protocols: [CustomRoutingProtocol]?

        public init(acceleratorPort: Int? = nil, destinationSocketAddress: SocketAddress? = nil, destinationTrafficState: CustomRoutingDestinationTrafficState? = nil, endpointGroupArn: String? = nil, endpointId: String? = nil, protocols: [CustomRoutingProtocol]? = nil) {
            self.acceleratorPort = acceleratorPort
            self.destinationSocketAddress = destinationSocketAddress
            self.destinationTrafficState = destinationTrafficState
            self.endpointGroupArn = endpointGroupArn
            self.endpointId = endpointId
            self.protocols = protocols
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorPort = "AcceleratorPort"
            case destinationSocketAddress = "DestinationSocketAddress"
            case destinationTrafficState = "DestinationTrafficState"
            case endpointGroupArn = "EndpointGroupArn"
            case endpointId = "EndpointId"
            case protocols = "Protocols"
        }
    }

    public struct PortOverride: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint port that you want a listener port to be mapped to. This is the port on the endpoint,
        /// 			such as the Application Load Balancer or Amazon EC2 instance.
        public let endpointPort: Int?
        /// The listener port that you want to map to a specific endpoint port. This is the port that user traffic
        /// 		arrives to the Global Accelerator on.
        public let listenerPort: Int?

        public init(endpointPort: Int? = nil, listenerPort: Int? = nil) {
            self.endpointPort = endpointPort
            self.listenerPort = listenerPort
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointPort, name: "endpointPort", parent: name, max: 65535)
            try self.validate(self.endpointPort, name: "endpointPort", parent: name, min: 1)
            try self.validate(self.listenerPort, name: "listenerPort", parent: name, max: 65535)
            try self.validate(self.listenerPort, name: "listenerPort", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointPort = "EndpointPort"
            case listenerPort = "ListenerPort"
        }
    }

    public struct PortRange: AWSEncodableShape & AWSDecodableShape {
        /// The first port in the range of ports, inclusive.
        public let fromPort: Int?
        /// The last port in the range of ports, inclusive.
        public let toPort: Int?

        public init(fromPort: Int? = nil, toPort: Int? = nil) {
            self.fromPort = fromPort
            self.toPort = toPort
        }

        public func validate(name: String) throws {
            try self.validate(self.fromPort, name: "fromPort", parent: name, max: 65535)
            try self.validate(self.fromPort, name: "fromPort", parent: name, min: 1)
            try self.validate(self.toPort, name: "toPort", parent: name, max: 65535)
            try self.validate(self.toPort, name: "toPort", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case toPort = "ToPort"
        }
    }

    public struct ProvisionByoipCidrRequest: AWSEncodableShape {
        /// The public IPv4 address range, in CIDR notation. The most specific IP prefix that you can
        /// 			specify is /24. The address range cannot overlap with another address range that you've brought
        /// 			to this or another Region.
        public let cidr: String
        /// A signed document that proves that you are authorized to bring the specified IP address range to
        /// 			Amazon using BYOIP.
        ///
        public let cidrAuthorizationContext: CidrAuthorizationContext

        public init(cidr: String, cidrAuthorizationContext: CidrAuthorizationContext) {
            self.cidr = cidr
            self.cidrAuthorizationContext = cidrAuthorizationContext
        }

        public func validate(name: String) throws {
            try self.validate(self.cidr, name: "cidr", parent: name, max: 255)
            try self.cidrAuthorizationContext.validate(name: "\(name).cidrAuthorizationContext")
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "Cidr"
            case cidrAuthorizationContext = "CidrAuthorizationContext"
        }
    }

    public struct ProvisionByoipCidrResponse: AWSDecodableShape {
        /// Information about the address range.
        public let byoipCidr: ByoipCidr?

        public init(byoipCidr: ByoipCidr? = nil) {
            self.byoipCidr = byoipCidr
        }

        private enum CodingKeys: String, CodingKey {
            case byoipCidr = "ByoipCidr"
        }
    }

    public struct RemoveCustomRoutingEndpointsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint group to remove endpoints from.
        public let endpointGroupArn: String
        /// The IDs for the endpoints. For custom routing accelerators, endpoint IDs are the virtual private cloud (VPC)
        /// 		subnet IDs.
        public let endpointIds: [String]

        public init(endpointGroupArn: String, endpointIds: [String]) {
            self.endpointGroupArn = endpointGroupArn
            self.endpointIds = endpointIds
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointGroupArn, name: "endpointGroupArn", parent: name, max: 255)
            try self.endpointIds.forEach {
                try validate($0, name: "endpointIds[]", parent: name, max: 255)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroupArn = "EndpointGroupArn"
            case endpointIds = "EndpointIds"
        }
    }

    public struct SocketAddress: AWSDecodableShape {
        /// The IP address for the socket address.
        public let ipAddress: String?
        /// The port for the socket address.
        public let port: Int?

        public init(ipAddress: String? = nil, port: Int? = nil) {
            self.ipAddress = ipAddress
            self.port = port
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddress = "IpAddress"
            case port = "Port"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// A string that contains a Tag key.
        public let key: String
        /// A string that contains a Tag value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Global Accelerator resource to add tags to. An ARN uniquely identifies a resource.
        public let resourceArn: String
        /// The tags to add to a resource. A tag consists of a key and a value that you define.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Global Accelerator resource to remove tags from. An ARN uniquely identifies a resource.
        public let resourceArn: String
        /// The tag key pairs that you want to remove from the specified resources.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAcceleratorAttributesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator that you want to update.
        public let acceleratorArn: String
        /// Update whether flow logs are enabled. The default value is false. If the value is true,
        /// 				FlowLogsS3Bucket and FlowLogsS3Prefix must be specified.
        /// 		       For more information, see Flow Logs in
        /// 			the AWS Global Accelerator Developer Guide.
        public let flowLogsEnabled: Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is
        /// 				true. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
        /// 			bucket.
        public let flowLogsS3Bucket: String?
        /// Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
        /// 				FlowLogsEnabled is true.
        /// 		       If you donâ€™t specify a prefix, the flow logs are stored in the
        /// 			root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:
        /// 			      s3-bucket_name//AWSLogs/aws_account_id
        public let flowLogsS3Prefix: String?

        public init(acceleratorArn: String, flowLogsEnabled: Bool? = nil, flowLogsS3Bucket: String? = nil, flowLogsS3Prefix: String? = nil) {
            self.acceleratorArn = acceleratorArn
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
            try self.validate(self.flowLogsS3Bucket, name: "flowLogsS3Bucket", parent: name, max: 255)
            try self.validate(self.flowLogsS3Prefix, name: "flowLogsS3Prefix", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case flowLogsEnabled = "FlowLogsEnabled"
            case flowLogsS3Bucket = "FlowLogsS3Bucket"
            case flowLogsS3Prefix = "FlowLogsS3Prefix"
        }
    }

    public struct UpdateAcceleratorAttributesResponse: AWSDecodableShape {
        /// Updated attributes for the accelerator.
        public let acceleratorAttributes: AcceleratorAttributes?

        public init(acceleratorAttributes: AcceleratorAttributes? = nil) {
            self.acceleratorAttributes = acceleratorAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorAttributes = "AcceleratorAttributes"
        }
    }

    public struct UpdateAcceleratorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator to update.
        public let acceleratorArn: String
        /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true.
        /// 		       If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.
        public let enabled: Bool?
        /// The IP address type, which must be IPv4.
        public let ipAddressType: IpAddressType?
        /// The name of the accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or
        /// 			hyphens (-), and must not begin or end with a hyphen.
        public let name: String?

        public init(acceleratorArn: String, enabled: Bool? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil) {
            self.acceleratorArn = acceleratorArn
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case enabled = "Enabled"
            case ipAddressType = "IpAddressType"
            case name = "Name"
        }
    }

    public struct UpdateAcceleratorResponse: AWSDecodableShape {
        /// Information about the updated accelerator.
        public let accelerator: Accelerator?

        public init(accelerator: Accelerator? = nil) {
            self.accelerator = accelerator
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
        }
    }

    public struct UpdateCustomRoutingAcceleratorAttributesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the custom routing accelerator to update attributes for.
        public let acceleratorArn: String
        /// Update whether flow logs are enabled. The default value is false. If the value is true,
        /// 		FlowLogsS3Bucket and FlowLogsS3Prefix must be specified.
        /// 	        For more information, see Flow Logs in
        /// 		the AWS Global Accelerator Developer Guide.
        public let flowLogsEnabled: Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is
        /// 		true. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the
        /// 		bucket.
        public let flowLogsS3Bucket: String?
        /// Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if
        /// 		FlowLogsEnabled is true.
        /// 	        If you donâ€™t specify a prefix, the flow logs are stored in the
        /// 		root of the bucket. If you specify slash (/) for the S3 bucket prefix, the log file bucket folder structure will include a double slash (//), like the following:
        /// 	        DOC-EXAMPLE-BUCKET//AWSLogs/aws_account_id
        public let flowLogsS3Prefix: String?

        public init(acceleratorArn: String, flowLogsEnabled: Bool? = nil, flowLogsS3Bucket: String? = nil, flowLogsS3Prefix: String? = nil) {
            self.acceleratorArn = acceleratorArn
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
            try self.validate(self.flowLogsS3Bucket, name: "flowLogsS3Bucket", parent: name, max: 255)
            try self.validate(self.flowLogsS3Prefix, name: "flowLogsS3Prefix", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case flowLogsEnabled = "FlowLogsEnabled"
            case flowLogsS3Bucket = "FlowLogsS3Bucket"
            case flowLogsS3Prefix = "FlowLogsS3Prefix"
        }
    }

    public struct UpdateCustomRoutingAcceleratorAttributesResponse: AWSDecodableShape {
        /// Updated custom routing accelerator.
        public let acceleratorAttributes: CustomRoutingAcceleratorAttributes?

        public init(acceleratorAttributes: CustomRoutingAcceleratorAttributes? = nil) {
            self.acceleratorAttributes = acceleratorAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorAttributes = "AcceleratorAttributes"
        }
    }

    public struct UpdateCustomRoutingAcceleratorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the accelerator to update.
        public let acceleratorArn: String
        /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true.
        /// 	        If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.
        public let enabled: Bool?
        /// The value for the address type must be IPv4.
        public let ipAddressType: IpAddressType?
        /// The name of the accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or
        /// 		hyphens (-), and must not begin or end with a hyphen.
        public let name: String?

        public init(acceleratorArn: String, enabled: Bool? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil) {
            self.acceleratorArn = acceleratorArn
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.acceleratorArn, name: "acceleratorArn", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case enabled = "Enabled"
            case ipAddressType = "IpAddressType"
            case name = "Name"
        }
    }

    public struct UpdateCustomRoutingAcceleratorResponse: AWSDecodableShape {
        /// Information about the updated custom routing accelerator.
        public let accelerator: CustomRoutingAccelerator?

        public init(accelerator: CustomRoutingAccelerator? = nil) {
            self.accelerator = accelerator
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
        }
    }

    public struct UpdateCustomRoutingListenerRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the listener to update.
        public let listenerArn: String
        /// The updated port range to support for connections from clients to your accelerator. If you remove ports that are
        /// 	currently being used by a subnet endpoint, the call fails.
        /// 	        Separately, you set port ranges for endpoints. For more information, see About
        /// 		endpoints for custom routing accelerators.
        public let portRanges: [PortRange]

        public init(listenerArn: String, portRanges: [PortRange]) {
            self.listenerArn = listenerArn
            self.portRanges = portRanges
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerArn, name: "listenerArn", parent: name, max: 255)
            try self.portRanges.forEach {
                try $0.validate(name: "\(name).portRanges[]")
            }
            try self.validate(self.portRanges, name: "portRanges", parent: name, max: 10)
            try self.validate(self.portRanges, name: "portRanges", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
            case portRanges = "PortRanges"
        }
    }

    public struct UpdateCustomRoutingListenerResponse: AWSDecodableShape {
        /// Information for the updated listener for a custom routing accelerator.
        public let listener: CustomRoutingListener?

        public init(listener: CustomRoutingListener? = nil) {
            self.listener = listener
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
        }
    }

    public struct UpdateEndpointGroupRequest: AWSEncodableShape {
        /// The list of endpoint objects. A resource must be valid and active when you add it as an endpoint.
        public let endpointConfigurations: [EndpointConfiguration]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public let endpointGroupArn: String
        /// The timeâ€”10 seconds or 30 secondsâ€”between each health check for an endpoint. The default value is 30.
        public let healthCheckIntervalSeconds: Int?
        /// If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The
        /// 			default value is slash (/).
        public let healthCheckPath: String?
        /// The port that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port
        /// 			is the listener port that this endpoint group is associated with. If the listener port is a list of ports, Global Accelerator uses
        /// 			the first port in the list.
        public let healthCheckPort: Int?
        /// The protocol that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default
        /// 			value is TCP.
        public let healthCheckProtocol: HealthCheckProtocol?
        /// Override specific listener ports used to route traffic to endpoints that are part of this endpoint group.
        /// 			For example, you can create a port override in which the listener
        /// 			receives user traffic on ports 80 and 443, but your accelerator routes that traffic to ports 1080
        /// 			and 1443, respectively, on the endpoints.
        /// 		       For more information, see
        /// 			Port overrides in the AWS Global Accelerator Developer Guide.
        public let portOverrides: [PortOverride]?
        /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an
        /// 			unhealthy endpoint to healthy. The default value is 3.
        public let thresholdCount: Int?
        /// The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for
        /// 			this listener.
        /// 		       Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is
        /// 			applied to the traffic that would otherwise have been routed to the Region based on optimal routing.
        /// 		       The default value is 100.
        public let trafficDialPercentage: Float?

        public init(endpointConfigurations: [EndpointConfiguration]? = nil, endpointGroupArn: String, healthCheckIntervalSeconds: Int? = nil, healthCheckPath: String? = nil, healthCheckPort: Int? = nil, healthCheckProtocol: HealthCheckProtocol? = nil, portOverrides: [PortOverride]? = nil, thresholdCount: Int? = nil, trafficDialPercentage: Float? = nil) {
            self.endpointConfigurations = endpointConfigurations
            self.endpointGroupArn = endpointGroupArn
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.portOverrides = portOverrides
            self.thresholdCount = thresholdCount
            self.trafficDialPercentage = trafficDialPercentage
        }

        public func validate(name: String) throws {
            try self.endpointConfigurations?.forEach {
                try $0.validate(name: "\(name).endpointConfigurations[]")
            }
            try self.validate(self.endpointConfigurations, name: "endpointConfigurations", parent: name, max: 10)
            try self.validate(self.endpointGroupArn, name: "endpointGroupArn", parent: name, max: 255)
            try self.validate(self.healthCheckIntervalSeconds, name: "healthCheckIntervalSeconds", parent: name, max: 30)
            try self.validate(self.healthCheckIntervalSeconds, name: "healthCheckIntervalSeconds", parent: name, min: 10)
            try self.validate(self.healthCheckPath, name: "healthCheckPath", parent: name, max: 255)
            try self.validate(self.healthCheckPath, name: "healthCheckPath", parent: name, pattern: "^/[-a-zA-Z0-9@:%_\\\\+.~#?&/=]*$")
            try self.validate(self.healthCheckPort, name: "healthCheckPort", parent: name, max: 65535)
            try self.validate(self.healthCheckPort, name: "healthCheckPort", parent: name, min: 1)
            try self.portOverrides?.forEach {
                try $0.validate(name: "\(name).portOverrides[]")
            }
            try self.validate(self.portOverrides, name: "portOverrides", parent: name, max: 10)
            try self.validate(self.thresholdCount, name: "thresholdCount", parent: name, max: 10)
            try self.validate(self.thresholdCount, name: "thresholdCount", parent: name, min: 1)
            try self.validate(self.trafficDialPercentage, name: "trafficDialPercentage", parent: name, max: 100.0)
            try self.validate(self.trafficDialPercentage, name: "trafficDialPercentage", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigurations = "EndpointConfigurations"
            case endpointGroupArn = "EndpointGroupArn"
            case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
            case healthCheckPath = "HealthCheckPath"
            case healthCheckPort = "HealthCheckPort"
            case healthCheckProtocol = "HealthCheckProtocol"
            case portOverrides = "PortOverrides"
            case thresholdCount = "ThresholdCount"
            case trafficDialPercentage = "TrafficDialPercentage"
        }
    }

    public struct UpdateEndpointGroupResponse: AWSDecodableShape {
        /// The information about the endpoint group that was updated.
        public let endpointGroup: EndpointGroup?

        public init(endpointGroup: EndpointGroup? = nil) {
            self.endpointGroup = endpointGroup
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroup = "EndpointGroup"
        }
    }

    public struct UpdateListenerRequest: AWSEncodableShape {
        /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications,
        /// 			regardless of the port and protocol of the client request. Client affinity gives you control over whether to always
        /// 			route each client to the same specific endpoint.
        /// 		       AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client
        /// 			affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) propertiesâ€”source IP address, source port,
        /// 			destination IP address, destination port, and protocolâ€”to select the hash value, and then chooses the best
        /// 			endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not
        /// 			be always routed to the same endpoint because the hash value changes.
        /// 		       If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP
        /// 			instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) propertiesâ€”
        /// 			source (client) IP address and destination IP addressâ€”to select the hash value.
        /// 		       The default value is NONE.
        public let clientAffinity: ClientAffinity?
        /// The Amazon Resource Name (ARN) of the listener to update.
        public let listenerArn: String
        /// The updated list of port ranges for the connections from clients to the accelerator.
        public let portRanges: [PortRange]?
        /// The updated protocol for the connections from clients to the accelerator.
        public let `protocol`: Protocol?

        public init(clientAffinity: ClientAffinity? = nil, listenerArn: String, portRanges: [PortRange]? = nil, protocol: Protocol? = nil) {
            self.clientAffinity = clientAffinity
            self.listenerArn = listenerArn
            self.portRanges = portRanges
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerArn, name: "listenerArn", parent: name, max: 255)
            try self.portRanges?.forEach {
                try $0.validate(name: "\(name).portRanges[]")
            }
            try self.validate(self.portRanges, name: "portRanges", parent: name, max: 10)
            try self.validate(self.portRanges, name: "portRanges", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientAffinity = "ClientAffinity"
            case listenerArn = "ListenerArn"
            case portRanges = "PortRanges"
            case `protocol` = "Protocol"
        }
    }

    public struct UpdateListenerResponse: AWSDecodableShape {
        /// Information for the updated listener.
        public let listener: Listener?

        public init(listener: Listener? = nil) {
            self.listener = listener
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
        }
    }

    public struct WithdrawByoipCidrRequest: AWSEncodableShape {
        /// The address range, in CIDR notation.
        public let cidr: String

        public init(cidr: String) {
            self.cidr = cidr
        }

        public func validate(name: String) throws {
            try self.validate(self.cidr, name: "cidr", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "Cidr"
        }
    }

    public struct WithdrawByoipCidrResponse: AWSDecodableShape {
        /// Information about the address pool.
        public let byoipCidr: ByoipCidr?

        public init(byoipCidr: ByoipCidr? = nil) {
            self.byoipCidr = byoipCidr
        }

        private enum CodingKeys: String, CodingKey {
            case byoipCidr = "ByoipCidr"
        }
    }
}
