//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS GlobalAccelerator service.
///
/// AWS Global Accelerator
/// 		       This is the AWS Global Accelerator API Reference. This guide is for developers who need detailed information about
/// 			AWS Global Accelerator API actions, data types, and errors. For more information about Global Accelerator features, see the
/// 			AWS Global Accelerator Developer Guide.
/// 		       AWS Global Accelerator is a service in which you create accelerators to improve the performance
/// 			of your applications for local and global users. Depending on the type of accelerator you choose, you can
/// 			gain additional benefits.
/// 		         By using a standard accelerator, you can improve availability of your internet applications
/// 				that are used by a global audience. With a standard accelerator, Global Accelerator directs traffic to optimal endpoints over the AWS
/// 				global network.    For other scenarios, you might choose a custom routing accelerator. With a custom routing accelerator, you
/// 				can use application logic to directly map one or more users to a specific endpoint among many endpoints.
///
/// 			         Global Accelerator is a global service that supports endpoints in multiple AWS Regions but you must specify the
/// 				US West (Oregon) Region to create or update accelerators.
///
/// 		       By default, Global Accelerator provides you with two static IP addresses that you associate with your accelerator. With
/// 			a standard accelerator, instead of using the
/// 			IP addresses that Global Accelerator provides, you can configure these entry points to be IPv4 addresses from your own IP address ranges
/// 			that you bring to Global Accelerator. The static IP addresses are anycast from the AWS edge network. For a standard accelerator,
/// 			they distribute incoming application traffic across multiple endpoint resources in multiple AWS Regions, which increases
/// 			the availability of your applications. Endpoints for standard accelerators can be Network Load Balancers, Application Load Balancers,
/// 			Amazon EC2 instances, or Elastic IP addresses that are located in one AWS Region or multiple Regions. For custom routing
/// 			accelerators, you map traffic that arrives to the static IP addresses to specific Amazon EC2 servers in endpoints that
/// 			are virtual private cloud (VPC) subnets.
///
/// 		        The static IP addresses remain assigned to your accelerator for as long as it exists, even if you
/// 				disable the accelerator and it no longer accepts or routes traffic. However, when you
/// 					delete an accelerator, you lose the static IP addresses that
/// 				are assigned to it, so you can no longer route traffic by using them. You can use
/// 				IAM policies like tag-based permissions with Global Accelerator to limit the users who have
/// 				permissions to delete an accelerator. For more information, see Tag-based policies.
/// 		       For standard accelerators, Global Accelerator uses the AWS global network to route traffic to the optimal regional endpoint based
/// 			on health, client location, and policies that you configure. The service reacts instantly to
/// 			changes in health or configuration to ensure that internet traffic from clients is always
/// 			directed to healthy endpoints.
///
/// 		       For a list of the AWS Regions where Global Accelerator and other services are currently supported, see the
/// 			AWS
/// 				Region Table.
/// 		       AWS Global Accelerator includes the following components:
/// 		        Static IP addresses  Global Accelerator provides you with a set of two static IP addresses that are anycast from the AWS edge
/// 					network. If you bring your own IP address range to AWS (BYOIP) to use with a standard accelerator, you
/// 					can instead assign IP addresses from your own pool to use with your accelerator. For more information,
/// 					see
/// 						Bring your own IP addresses (BYOIP) in AWS Global Accelerator.
/// 					          The IP addresses serve as single fixed entry points for your clients. If you already have Elastic
/// 						Load Balancing load balancers, Amazon EC2 instances, or Elastic IP address resources set up for your applications,
/// 						you can easily add those to a standard accelerator in Global Accelerator. This allows Global Accelerator to use static IP addresses
/// 						to access the resources.
/// 					          The static IP addresses remain assigned to your accelerator for as long as it exists, even
/// 						if you disable the accelerator and it no longer accepts or routes traffic.
/// 						However, when you delete an accelerator, you lose the
/// 						static IP addresses that are assigned to it, so you can no longer route
/// 						traffic by using them. You can use IAM policies like tag-based permissions
/// 						with Global Accelerator to delete an accelerator. For more information, see Tag-based policies.
/// 				         Accelerator  An accelerator directs traffic to endpoints over the AWS global network to improve the
/// 					performance of your internet applications. Each accelerator includes one or more listeners.
/// 					          There are two types of accelerators:
/// 					            A standard accelerator directs traffic to the optimal AWS endpoint based
/// 							on several factors, including the userâ€™s location, the health of the endpoint, and the endpoint weights
/// 							that you configure. This improves the availability and performance of your applications.
/// 							Endpoints can be Network Load Balancers, Application Load Balancers, Amazon EC2 instances, or Elastic IP addresses.   A custom routing accelerator directs traffic to one of possibly thousands of
/// 								Amazon EC2 instances running in a single or multiple virtual private
/// 								clouds (VPCs). With custom routing, listener ports are mapped to
/// 								statically associate port ranges with VPC subnets, which
/// 								allows Global Accelerator to determine an EC2 instance IP address at the time of
/// 								connection. By default, all port mapping destinations in a VPC
/// 								subnet can't receive traffic. You can choose to configure all
/// 								destinations in the subnet to receive traffic, or to specify
/// 								individual port mappings that can receive traffic.
/// 					          For more information, see Types of accelerators.
/// 				         DNS name  Global Accelerator assigns each accelerator a default Domain Name System (DNS) name, similar to
/// 					a1234567890abcdef.awsglobalaccelerator.com, that points to
/// 					the static IP addresses that Global Accelerator assigns to you or that you choose from your
/// 					own IP address range. Depending on the use
/// 					case, you can use your accelerator's static IP addresses or DNS name to
/// 					route traffic to your accelerator, or set up DNS records to route traffic using
/// 					your own custom domain name.
/// 				         Network zone  A network zone services the static IP addresses for your accelerator from a unique IP subnet. Similar to an
/// 					AWS Availability Zone, a network zone is an isolated unit with its own set of physical infrastructure.
/// 					When you configure an accelerator, by default, Global Accelerator allocates two IPv4 addresses for it. If one IP address from a
/// 					network zone becomes unavailable due to IP address blocking by certain client networks, or network
/// 					disruptions, then client applications can retry on the healthy static IP address from the other isolated
/// 					network zone.
/// 				         Listener  A listener processes inbound connections from clients to Global Accelerator, based on the port (or port range)
/// 					and protocol (or protocols) that you configure. A listener can be configured for TCP, UDP, or both TCP and UDP protocols. Each
/// 					listener has one or more endpoint groups associated with it, and traffic is forwarded
/// 					to endpoints in one of the groups. You associate endpoint groups with listeners by specifying the Regions that you
/// 					want to distribute traffic to. With a standard accelerator, traffic is distributed to optimal endpoints within the endpoint
/// 					groups associated with a listener.  Endpoint group  Each endpoint group is associated with a specific AWS Region. Endpoint groups include one or
/// 					more endpoints in the Region. With a standard accelerator, you can increase or reduce the percentage of
/// 					traffic that would be otherwise directed to an endpoint group by adjusting a
/// 					setting called a traffic dial. The traffic dial lets
/// 					you easily do performance testing or blue/green deployment testing, for example, for new
/// 					releases across different AWS Regions.
/// 				         Endpoint  An endpoint is a resource that Global Accelerator directs traffic to.
/// 					          Endpoints for standard accelerators can be Network Load Balancers, Application Load Balancers, Amazon EC2 instances, or Elastic IP
/// 						addresses. An Application Load Balancer endpoint can be internet-facing or internal. Traffic for
/// 						standard accelerators is routed to endpoints based on the health of the
/// 						endpoint along with configuration options that you choose, such as endpoint
/// 						weights. For each endpoint, you can configure weights, which are numbers
/// 						that you can use to specify the proportion of traffic to route to each one.
/// 						This can be useful, for example, to do performance testing within a
/// 						Region.
/// 					          Endpoints for custom routing accelerators are virtual private cloud (VPC) subnets with one
/// 						or many EC2 instances.
///
public struct GlobalAccelerator: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the GlobalAccelerator client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "GlobalAccelerator_V20180706",
            service: "globalaccelerator",
            serviceProtocol: .json(version: "1.1"),
            apiVersion: "2018-08-08",
            endpoint: endpoint,
            errorType: GlobalAcceleratorErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Associate a virtual private cloud (VPC) subnet endpoint with your custom routing accelerator.
    /// 	        The listener port range must be large enough to support the number of IP addresses that can be
    /// 		specified in your subnet. The number of ports required is: subnet size times the number
    /// 		of ports per destination EC2 instances. For example, a subnet defined as /24 requires a listener
    /// 		port range of at least 255 ports.
    /// 	        Note: You must have enough remaining listener ports available to
    /// 		map to the subnet ports, or the call will fail with a LimitExceededException.
    /// 	        By default, all destinations in a subnet in a custom routing accelerator cannot receive traffic. To enable all
    /// 			destinations to receive traffic, or to specify individual port mappings that can receive
    /// 			traffic, see the
    /// 				AllowCustomRoutingTraffic operation.
    public func addCustomRoutingEndpoints(_ input: AddCustomRoutingEndpointsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AddCustomRoutingEndpointsResponse> {
        return self.client.execute(operation: "AddCustomRoutingEndpoints", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Advertises an IPv4 address range that is provisioned for use with your AWS resources
    /// 			through bring your own IP addresses (BYOIP). It can take a few minutes before traffic to
    /// 			the specified addresses starts routing to AWS because of propagation delays.
    /// 		       To stop advertising the BYOIP address range, use
    /// 			WithdrawByoipCidr.
    /// 		       For more information, see Bring Your Own
    /// 			IP Addresses (BYOIP) in the AWS Global Accelerator Developer Guide.
    public func advertiseByoipCidr(_ input: AdvertiseByoipCidrRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<AdvertiseByoipCidrResponse> {
        return self.client.execute(operation: "AdvertiseByoipCidr", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Specify the Amazon EC2 instance (destination) IP addresses and ports for a VPC subnet endpoint that can receive traffic
    /// 			for a custom routing accelerator. You can allow traffic to all destinations in the subnet endpoint, or allow traffic to a
    /// 			specified list of destination IP addresses and ports in the subnet. Note that you cannot specify IP addresses or ports
    /// 			outside of the range that you configured for the endpoint group.
    /// 		       After you make changes, you can verify that the updates are complete by checking the status of your
    /// 			accelerator: the status changes from IN_PROGRESS to DEPLOYED.
    @discardableResult public func allowCustomRoutingTraffic(_ input: AllowCustomRoutingTrafficRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "AllowCustomRoutingTraffic", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Create an accelerator. An accelerator includes one or more listeners that process inbound connections and direct traffic
    /// 			to one or more endpoint groups, each of which includes endpoints, such as Network Load Balancers.
    ///
    /// 			         Global Accelerator is a global service that supports endpoints in multiple AWS Regions but you must specify the
    /// 				US West (Oregon) Region to create or update accelerators.
    ///
    public func createAccelerator(_ input: CreateAcceleratorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateAcceleratorResponse> {
        return self.client.execute(operation: "CreateAccelerator", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Create a custom routing accelerator. A custom routing accelerator directs traffic to one of possibly thousands
    /// 		of Amazon EC2 instance destinations running in a single or multiple virtual private clouds (VPC) subnet endpoints.
    /// 	        Be aware that, by default, all destination EC2 instances in a VPC subnet endpoint cannot receive
    /// 			traffic. To enable all destinations to receive traffic, or to specify individual port
    /// 			mappings that can receive traffic, see the
    /// 				AllowCustomRoutingTraffic operation.
    ///
    /// 		          Global Accelerator is a global service that supports endpoints in multiple AWS Regions but you must specify the
    /// 			US West (Oregon) Region to create or update accelerators.
    ///
    public func createCustomRoutingAccelerator(_ input: CreateCustomRoutingAcceleratorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCustomRoutingAcceleratorResponse> {
        return self.client.execute(operation: "CreateCustomRoutingAccelerator", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Create an endpoint group for the specified listener for a custom routing accelerator.
    /// 		An endpoint group is a collection of endpoints in one AWS
    /// 		Region.
    public func createCustomRoutingEndpointGroup(_ input: CreateCustomRoutingEndpointGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCustomRoutingEndpointGroupResponse> {
        return self.client.execute(operation: "CreateCustomRoutingEndpointGroup", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Create a listener to process inbound connections from clients to a custom routing accelerator.
    /// 			Connections arrive to assigned static IP addresses on the port range that you specify.
    public func createCustomRoutingListener(_ input: CreateCustomRoutingListenerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCustomRoutingListenerResponse> {
        return self.client.execute(operation: "CreateCustomRoutingListener", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Create an endpoint group for the specified listener. An endpoint group is a collection of endpoints in one AWS
    /// 			Region. A resource must be valid and active when you add it as an endpoint.
    public func createEndpointGroup(_ input: CreateEndpointGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateEndpointGroupResponse> {
        return self.client.execute(operation: "CreateEndpointGroup", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Create a listener to process inbound connections from clients to an accelerator. Connections arrive to assigned static
    /// 			IP addresses on a port, port range, or list of port ranges that you specify.
    public func createListener(_ input: CreateListenerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateListenerResponse> {
        return self.client.execute(operation: "CreateListener", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Delete an accelerator. Before you can delete an accelerator, you must disable it and remove all dependent resources
    /// 			(listeners and endpoint groups). To disable the accelerator, update the accelerator to set Enabled to false.
    /// 		        When you create an accelerator, by default, Global Accelerator provides you with a set of two static IP addresses.
    /// 			Alternatively, you can bring your own IP address ranges to Global Accelerator and assign IP addresses from those ranges.
    ///
    /// 		          The IP addresses are assigned to your accelerator for as long as it exists, even if you disable the accelerator and
    /// 			it no longer accepts or routes traffic. However, when you delete an accelerator, you lose the
    /// 			static IP addresses that are assigned to the accelerator, so you can no longer route traffic by using them.
    /// 			As a best practice, ensure that you have permissions in place to avoid inadvertently deleting accelerators. You
    /// 			can use IAM policies with Global Accelerator to limit the users who have permissions to delete an accelerator. For more information,
    /// 			see Authentication and Access Control in
    /// 			the AWS Global Accelerator Developer Guide.
    @discardableResult public func deleteAccelerator(_ input: DeleteAcceleratorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteAccelerator", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Delete a custom routing accelerator. Before you can delete an accelerator, you must disable it and remove all dependent resources
    /// 		(listeners and endpoint groups). To disable the accelerator, update the accelerator to set Enabled to false.
    /// 	         When you create a custom routing accelerator, by default, Global Accelerator provides you with a set of two static IP addresses.
    ///
    /// 		          The IP
    /// 			addresses are assigned to your accelerator for as long as it exists, even if you disable the accelerator and
    /// 			it no longer accepts or routes traffic. However, when you delete an accelerator, you lose the
    /// 			static IP addresses that are assigned to the accelerator, so you can no longer route traffic by using them.
    /// 			As a best practice, ensure that you have permissions in place to avoid inadvertently deleting accelerators. You
    /// 			can use IAM policies with Global Accelerator to limit the users who have permissions to delete an accelerator. For more information,
    /// 			see Authentication and Access Control in
    /// 			the AWS Global Accelerator Developer Guide.
    @discardableResult public func deleteCustomRoutingAccelerator(_ input: DeleteCustomRoutingAcceleratorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteCustomRoutingAccelerator", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Delete an endpoint group from a listener for a custom routing accelerator.
    @discardableResult public func deleteCustomRoutingEndpointGroup(_ input: DeleteCustomRoutingEndpointGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteCustomRoutingEndpointGroup", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Delete a listener for a custom routing accelerator.
    @discardableResult public func deleteCustomRoutingListener(_ input: DeleteCustomRoutingListenerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteCustomRoutingListener", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Delete an endpoint group from a listener.
    @discardableResult public func deleteEndpointGroup(_ input: DeleteEndpointGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteEndpointGroup", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Delete a listener from an accelerator.
    @discardableResult public func deleteListener(_ input: DeleteListenerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteListener", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Specify the Amazon EC2 instance (destination) IP addresses and ports for a VPC subnet endpoint that cannot receive traffic
    /// 			for a custom routing accelerator. You can deny traffic to all destinations in the VPC endpoint, or deny traffic to a
    /// 			specified list of destination IP addresses and ports. Note that you cannot specify IP addresses
    /// 			or ports outside of the range that you configured for the endpoint group.
    /// 		       After you make changes, you can verify that the updates are complete by checking the status of your
    /// 			accelerator: the status changes from IN_PROGRESS to DEPLOYED.
    @discardableResult public func denyCustomRoutingTraffic(_ input: DenyCustomRoutingTrafficRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DenyCustomRoutingTraffic", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Releases the specified address range that you provisioned to use with your AWS resources
    /// 			through bring your own IP addresses (BYOIP) and deletes the corresponding address pool.
    /// 		       Before you can release an address range, you must stop advertising it by using WithdrawByoipCidr and you must not have
    /// 			any accelerators that are using static IP addresses allocated from its address range.
    ///
    /// 		       For more information, see Bring Your Own
    /// 			IP Addresses (BYOIP) in the AWS Global Accelerator Developer Guide.
    public func deprovisionByoipCidr(_ input: DeprovisionByoipCidrRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeprovisionByoipCidrResponse> {
        return self.client.execute(operation: "DeprovisionByoipCidr", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe an accelerator.
    public func describeAccelerator(_ input: DescribeAcceleratorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeAcceleratorResponse> {
        return self.client.execute(operation: "DescribeAccelerator", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe the attributes of an accelerator.
    ///
    public func describeAcceleratorAttributes(_ input: DescribeAcceleratorAttributesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeAcceleratorAttributesResponse> {
        return self.client.execute(operation: "DescribeAcceleratorAttributes", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe a custom routing accelerator.
    public func describeCustomRoutingAccelerator(_ input: DescribeCustomRoutingAcceleratorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeCustomRoutingAcceleratorResponse> {
        return self.client.execute(operation: "DescribeCustomRoutingAccelerator", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe the attributes of a custom routing accelerator.
    public func describeCustomRoutingAcceleratorAttributes(_ input: DescribeCustomRoutingAcceleratorAttributesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeCustomRoutingAcceleratorAttributesResponse> {
        return self.client.execute(operation: "DescribeCustomRoutingAcceleratorAttributes", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe an endpoint group for a custom routing accelerator.
    public func describeCustomRoutingEndpointGroup(_ input: DescribeCustomRoutingEndpointGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeCustomRoutingEndpointGroupResponse> {
        return self.client.execute(operation: "DescribeCustomRoutingEndpointGroup", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// The description of a listener for a custom routing accelerator.
    public func describeCustomRoutingListener(_ input: DescribeCustomRoutingListenerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeCustomRoutingListenerResponse> {
        return self.client.execute(operation: "DescribeCustomRoutingListener", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe an endpoint group.
    public func describeEndpointGroup(_ input: DescribeEndpointGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeEndpointGroupResponse> {
        return self.client.execute(operation: "DescribeEndpointGroup", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Describe a listener.
    public func describeListener(_ input: DescribeListenerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DescribeListenerResponse> {
        return self.client.execute(operation: "DescribeListener", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List the accelerators for an AWS account.
    public func listAccelerators(_ input: ListAcceleratorsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListAcceleratorsResponse> {
        return self.client.execute(operation: "ListAccelerators", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the IP address ranges that were specified in calls to ProvisionByoipCidr, including
    /// 			the current state and a history of state changes.
    public func listByoipCidrs(_ input: ListByoipCidrsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListByoipCidrsResponse> {
        return self.client.execute(operation: "ListByoipCidrs", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List the custom routing accelerators for an AWS account.
    public func listCustomRoutingAccelerators(_ input: ListCustomRoutingAcceleratorsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCustomRoutingAcceleratorsResponse> {
        return self.client.execute(operation: "ListCustomRoutingAccelerators", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List the endpoint groups that are associated with a listener for a custom routing accelerator.
    public func listCustomRoutingEndpointGroups(_ input: ListCustomRoutingEndpointGroupsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCustomRoutingEndpointGroupsResponse> {
        return self.client.execute(operation: "ListCustomRoutingEndpointGroups", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List the listeners for a custom routing accelerator.
    public func listCustomRoutingListeners(_ input: ListCustomRoutingListenersRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCustomRoutingListenersResponse> {
        return self.client.execute(operation: "ListCustomRoutingListeners", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Provides a complete mapping from the public accelerator IP address and port to destination EC2 instance
    /// 		IP addresses and ports in the virtual public cloud (VPC) subnet endpoint for a custom routing accelerator.
    /// 		For each subnet endpoint that you add, Global Accelerator creates a new static port mapping for the accelerator. The port
    /// 		mappings don't change after Global Accelerator generates them, so you can retrieve and cache the full mapping on your servers.
    /// 	        If you remove a subnet from your accelerator, Global Accelerator removes (reclaims) the port mappings. If you add a subnet to
    /// 		your accelerator, Global Accelerator creates new port mappings (the existing ones don't change). If you add or remove EC2 instances
    /// 		in your subnet, the port mappings don't change, because the mappings are created when you add the subnet to Global Accelerator.
    /// 	        The mappings also include a flag for each destination denoting which destination IP addresses and
    /// 		ports are allowed or denied traffic.
    public func listCustomRoutingPortMappings(_ input: ListCustomRoutingPortMappingsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCustomRoutingPortMappingsResponse> {
        return self.client.execute(operation: "ListCustomRoutingPortMappings", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List the port mappings for a specific EC2 instance (destination) in a VPC subnet endpoint. The
    /// 			response is the mappings for one destination IP address. This is useful when your subnet endpoint has mappings that
    /// 			span multiple custom routing accelerators in your account, or for scenarios where you only want to
    /// 			list the port mappings for a specific destination instance.
    public func listCustomRoutingPortMappingsByDestination(_ input: ListCustomRoutingPortMappingsByDestinationRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCustomRoutingPortMappingsByDestinationResponse> {
        return self.client.execute(operation: "ListCustomRoutingPortMappingsByDestination", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List the endpoint groups that are associated with a listener.
    public func listEndpointGroups(_ input: ListEndpointGroupsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListEndpointGroupsResponse> {
        return self.client.execute(operation: "ListEndpointGroups", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List the listeners for an accelerator.
    public func listListeners(_ input: ListListenersRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListListenersResponse> {
        return self.client.execute(operation: "ListListeners", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// List all tags for an accelerator.
    /// 		       For more information, see Tagging
    /// 			in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceResponse> {
        return self.client.execute(operation: "ListTagsForResource", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Provisions an IP address range to use with your AWS resources through bring your own IP
    /// 			addresses (BYOIP) and creates a corresponding address pool. After the address range is provisioned,
    /// 			it is ready to be advertised using
    /// 			AdvertiseByoipCidr.
    /// 		       For more information, see Bring Your Own
    /// 			IP Addresses (BYOIP) in the AWS Global Accelerator Developer Guide.
    public func provisionByoipCidr(_ input: ProvisionByoipCidrRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ProvisionByoipCidrResponse> {
        return self.client.execute(operation: "ProvisionByoipCidr", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Remove endpoints from a custom routing accelerator.
    @discardableResult public func removeCustomRoutingEndpoints(_ input: RemoveCustomRoutingEndpointsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "RemoveCustomRoutingEndpoints", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Add tags to an accelerator resource.
    /// 		       For more information, see Tagging
    /// 			in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceResponse> {
        return self.client.execute(operation: "TagResource", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Remove tags from a Global Accelerator resource. When you specify a tag key, the action removes both that key and its associated value.
    /// 			The operation succeeds even if you attempt to remove tags from an accelerator that was already removed.
    /// 		       For more information, see Tagging
    /// 			in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UntagResourceResponse> {
        return self.client.execute(operation: "UntagResource", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update an accelerator.
    ///
    ///
    /// 			         Global Accelerator is a global service that supports endpoints in multiple AWS Regions but you must specify the
    /// 				US West (Oregon) Region to create or update accelerators.
    ///
    public func updateAccelerator(_ input: UpdateAcceleratorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateAcceleratorResponse> {
        return self.client.execute(operation: "UpdateAccelerator", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update the attributes for an accelerator.
    public func updateAcceleratorAttributes(_ input: UpdateAcceleratorAttributesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateAcceleratorAttributesResponse> {
        return self.client.execute(operation: "UpdateAcceleratorAttributes", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update a custom routing accelerator.
    public func updateCustomRoutingAccelerator(_ input: UpdateCustomRoutingAcceleratorRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateCustomRoutingAcceleratorResponse> {
        return self.client.execute(operation: "UpdateCustomRoutingAccelerator", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update the attributes for a custom routing accelerator.
    public func updateCustomRoutingAcceleratorAttributes(_ input: UpdateCustomRoutingAcceleratorAttributesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateCustomRoutingAcceleratorAttributesResponse> {
        return self.client.execute(operation: "UpdateCustomRoutingAcceleratorAttributes", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update a listener for a custom routing accelerator.
    public func updateCustomRoutingListener(_ input: UpdateCustomRoutingListenerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateCustomRoutingListenerResponse> {
        return self.client.execute(operation: "UpdateCustomRoutingListener", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update an endpoint group. A resource must be valid and active when you add it as an endpoint.
    public func updateEndpointGroup(_ input: UpdateEndpointGroupRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateEndpointGroupResponse> {
        return self.client.execute(operation: "UpdateEndpointGroup", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Update a listener.
    public func updateListener(_ input: UpdateListenerRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateListenerResponse> {
        return self.client.execute(operation: "UpdateListener", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Stops advertising an address range that is provisioned as an address pool.
    /// 			You can perform this operation at most once every 10 seconds, even if you specify different address
    /// 			ranges each time.
    /// 		       It can take a few minutes before traffic to the specified addresses stops routing to AWS because of
    /// 			propagation delays.
    /// 		       For more information, see Bring Your Own
    /// 			IP Addresses (BYOIP) in the AWS Global Accelerator Developer Guide.
    public func withdrawByoipCidr(_ input: WithdrawByoipCidrRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<WithdrawByoipCidrResponse> {
        return self.client.execute(operation: "WithdrawByoipCidr", path: "/", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension GlobalAccelerator {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: GlobalAccelerator, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}
