//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension NetworkManager {
    // MARK: Enums

    public enum AttachmentErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case directConnectGatewayExistingAttachments = "DIRECT_CONNECT_GATEWAY_EXISTING_ATTACHMENTS"
        case directConnectGatewayNoPrivateVif = "DIRECT_CONNECT_GATEWAY_NO_PRIVATE_VIF"
        case directConnectGatewayNotFound = "DIRECT_CONNECT_GATEWAY_NOT_FOUND"
        case maximumNoEncapLimitExceeded = "MAXIMUM_NO_ENCAP_LIMIT_EXCEEDED"
        case subnetDuplicatedInAvailabilityZone = "SUBNET_DUPLICATED_IN_AVAILABILITY_ZONE"
        case subnetNoFreeAddresses = "SUBNET_NO_FREE_ADDRESSES"
        case subnetNoIpv6Cidrs = "SUBNET_NO_IPV6_CIDRS"
        case subnetNotFound = "SUBNET_NOT_FOUND"
        case subnetUnsupportedAvailabilityZone = "SUBNET_UNSUPPORTED_AVAILABILITY_ZONE"
        case vpcNotFound = "VPC_NOT_FOUND"
        case vpnConnectionNotFound = "VPN_CONNECTION_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pendingAttachmentAcceptance = "PENDING_ATTACHMENT_ACCEPTANCE"
        case pendingNetworkUpdate = "PENDING_NETWORK_UPDATE"
        case pendingTagAcceptance = "PENDING_TAG_ACCEPTANCE"
        case rejected = "REJECTED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connect = "CONNECT"
        case directConnectGateway = "DIRECT_CONNECT_GATEWAY"
        case siteToSiteVpn = "SITE_TO_SITE_VPN"
        case transitGatewayRouteTable = "TRANSIT_GATEWAY_ROUTE_TABLE"
        case vpc = "VPC"
        public var description: String { return self.rawValue }
    }

    public enum ChangeAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case add = "ADD"
        case modify = "MODIFY"
        case remove = "REMOVE"
        public var description: String { return self.rawValue }
    }

    public enum ChangeSetState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case executing = "EXECUTING"
        case executionSucceeded = "EXECUTION_SUCCEEDED"
        case failedGeneration = "FAILED_GENERATION"
        case outOfDate = "OUT_OF_DATE"
        case pendingGeneration = "PENDING_GENERATION"
        case readyToExecute = "READY_TO_EXECUTE"
        public var description: String { return self.rawValue }
    }

    public enum ChangeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ChangeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachmentMapping = "ATTACHMENT_MAPPING"
        case attachmentPoliciesConfiguration = "ATTACHMENT_POLICIES_CONFIGURATION"
        case attachmentRoutePropagation = "ATTACHMENT_ROUTE_PROPAGATION"
        case attachmentRouteStatic = "ATTACHMENT_ROUTE_STATIC"
        case coreNetworkConfiguration = "CORE_NETWORK_CONFIGURATION"
        case coreNetworkEdge = "CORE_NETWORK_EDGE"
        case coreNetworkSegment = "CORE_NETWORK_SEGMENT"
        case networkFunctionGroup = "NETWORK_FUNCTION_GROUP"
        case segmentActionsConfiguration = "SEGMENT_ACTIONS_CONFIGURATION"
        case segmentsConfiguration = "SEGMENTS_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public enum ConnectPeerAssociationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ConnectPeerErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case edgeLocationNoFreeIps = "EDGE_LOCATION_NO_FREE_IPS"
        case edgeLocationPeerDuplicate = "EDGE_LOCATION_PEER_DUPLICATE"
        case invalidInsideCidrBlock = "INVALID_INSIDE_CIDR_BLOCK"
        case ipOutsideSubnetCidrRange = "IP_OUTSIDE_SUBNET_CIDR_RANGE"
        case noAssociatedCidrBlock = "NO_ASSOCIATED_CIDR_BLOCK"
        case subnetNotFound = "SUBNET_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum ConnectPeerState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case down = "DOWN"
        case up = "UP"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bgp = "BGP"
        case ipsec = "IPSEC"
        public var description: String { return self.rawValue }
    }

    public enum CoreNetworkPolicyAlias: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case latest = "LATEST"
        case live = "LIVE"
        public var description: String { return self.rawValue }
    }

    public enum CoreNetworkState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum CustomerGatewayAssociationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum DeviceState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum GlobalNetworkState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum LinkAssociationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum LinkState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum PeeringErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case edgeLocationPeerDuplicate = "EDGE_LOCATION_PEER_DUPLICATE"
        case internalError = "INTERNAL_ERROR"
        case invalidTransitGatewayState = "INVALID_TRANSIT_GATEWAY_STATE"
        case missingRequiredPermissions = "MISSING_PERMISSIONS"
        case transitGatewayNotFound = "TRANSIT_GATEWAY_NOT_FOUND"
        case transitGatewayPeersLimitExceeded = "TRANSIT_GATEWAY_PEERS_LIMIT_EXCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum PeeringState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum PeeringType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case transitGateway = "TRANSIT_GATEWAY"
        public var description: String { return self.rawValue }
    }

    public enum RouteAnalysisCompletionReasonCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blackholeRouteForDestinationFound = "BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND"
        case cyclicPathDetected = "CYCLIC_PATH_DETECTED"
        case inactiveRouteForDestinationFound = "INACTIVE_ROUTE_FOR_DESTINATION_FOUND"
        case maxHopsExceeded = "MAX_HOPS_EXCEEDED"
        case noDestinationArnProvided = "NO_DESTINATION_ARN_PROVIDED"
        case possibleMiddlebox = "POSSIBLE_MIDDLEBOX"
        case routeNotFound = "ROUTE_NOT_FOUND"
        case transitGatewayAttachment = "TRANSIT_GATEWAY_ATTACHMENT_ATTACH_ARN_NO_MATCH"
        case transitGatewayAttachmentNotFound = "TRANSIT_GATEWAY_ATTACHMENT_NOT_FOUND"
        case transitGatewayAttachmentNotInTransitGateway = "TRANSIT_GATEWAY_ATTACHMENT_NOT_IN_TRANSIT_GATEWAY"
        case transitGatewayAttachmentStableRouteTableNotFound = "TRANSIT_GATEWAY_ATTACHMENT_STABLE_ROUTE_TABLE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum RouteAnalysisCompletionResultCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connected = "CONNECTED"
        case notConnected = "NOT_CONNECTED"
        public var description: String { return self.rawValue }
    }

    public enum RouteAnalysisStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum RouteState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case blackhole = "BLACKHOLE"
        public var description: String { return self.rawValue }
    }

    public enum RouteTableType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case coreNetworkSegment = "CORE_NETWORK_SEGMENT"
        case networkFunctionGroup = "NETWORK_FUNCTION_GROUP"
        case transitGatewayRouteTable = "TRANSIT_GATEWAY_ROUTE_TABLE"
        public var description: String { return self.rawValue }
    }

    public enum RouteType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `static` = "STATIC"
        case propagated = "PROPAGATED"
        public var description: String { return self.rawValue }
    }

    public enum SegmentActionServiceInsertion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sendTo = "send-to"
        case sendVia = "send-via"
        public var description: String { return self.rawValue }
    }

    public enum SendViaMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dualHop = "dual-hop"
        case singleHop = "single-hop"
        public var description: String { return self.rawValue }
    }

    public enum SiteState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum TransitGatewayConnectPeerAssociationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum TransitGatewayRegistrationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum TunnelProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gre = "GRE"
        case noEncap = "NO_ENCAP"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CannotParse"
        case fieldValidationFailed = "FieldValidationFailed"
        case other = "Other"
        case unknownOperation = "UnknownOperation"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AWSLocation: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the subnet that the device is located in.
        public let subnetArn: String?
        /// The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
        public let zone: String?

        @inlinable
        public init(subnetArn: String? = nil, zone: String? = nil) {
            self.subnetArn = subnetArn
            self.zone = zone
        }

        public func validate(name: String) throws {
            try self.validate(self.subnetArn, name: "subnetArn", parent: name, max: 500)
            try self.validate(self.subnetArn, name: "subnetArn", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:subnet\\/subnet-[0-9a-f]{8,17}$|^$")
            try self.validate(self.zone, name: "zone", parent: name, max: 256)
            try self.validate(self.zone, name: "zone", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case subnetArn = "SubnetArn"
            case zone = "Zone"
        }
    }

    public struct AcceptAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let attachmentId: String

        @inlinable
        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AcceptAttachmentResponse: AWSDecodableShape {
        /// The response to the attachment request.
        public let attachment: Attachment?

        @inlinable
        public init(attachment: Attachment? = nil) {
            self.attachment = attachment
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
        }
    }

    public struct AccountStatus: AWSDecodableShape {
        /// The ID of an account within the Amazon Web Services Organization.
        public let accountId: String?
        /// The status of SLR deployment for the account.
        public let slrDeploymentStatus: String?

        @inlinable
        public init(accountId: String? = nil, slrDeploymentStatus: String? = nil) {
            self.accountId = accountId
            self.slrDeploymentStatus = slrDeploymentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case slrDeploymentStatus = "SLRDeploymentStatus"
        }
    }

    public struct AssociateConnectPeerRequest: AWSEncodableShape {
        /// The ID of the Connect peer.
        public let connectPeerId: String
        /// The ID of the device.
        public let deviceId: String
        /// The ID of your global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String?

        @inlinable
        public init(connectPeerId: String, deviceId: String, globalNetworkId: String, linkId: String? = nil) {
            self.connectPeerId = connectPeerId
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.connectPeerId, forKey: .connectPeerId)
            try container.encode(self.deviceId, forKey: .deviceId)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.linkId, forKey: .linkId)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, max: 50)
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, pattern: "^connect-peer-([0-9a-f]{8,17})$")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeerId = "ConnectPeerId"
            case deviceId = "DeviceId"
            case linkId = "LinkId"
        }
    }

    public struct AssociateConnectPeerResponse: AWSDecodableShape {
        /// The response to the Connect peer request.
        public let connectPeerAssociation: ConnectPeerAssociation?

        @inlinable
        public init(connectPeerAssociation: ConnectPeerAssociation? = nil) {
            self.connectPeerAssociation = connectPeerAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeerAssociation = "ConnectPeerAssociation"
        }
    }

    public struct AssociateCustomerGatewayRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the customer gateway.
        public let customerGatewayArn: String
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String?

        @inlinable
        public init(customerGatewayArn: String, deviceId: String, globalNetworkId: String, linkId: String? = nil) {
            self.customerGatewayArn = customerGatewayArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.customerGatewayArn, forKey: .customerGatewayArn)
            try container.encode(self.deviceId, forKey: .deviceId)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.linkId, forKey: .linkId)
        }

        public func validate(name: String) throws {
            try self.validate(self.customerGatewayArn, name: "customerGatewayArn", parent: name, max: 500)
            try self.validate(self.customerGatewayArn, name: "customerGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case customerGatewayArn = "CustomerGatewayArn"
            case deviceId = "DeviceId"
            case linkId = "LinkId"
        }
    }

    public struct AssociateCustomerGatewayResponse: AWSDecodableShape {
        /// The customer gateway association.
        public let customerGatewayAssociation: CustomerGatewayAssociation?

        @inlinable
        public init(customerGatewayAssociation: CustomerGatewayAssociation? = nil) {
            self.customerGatewayAssociation = customerGatewayAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case customerGatewayAssociation = "CustomerGatewayAssociation"
        }
    }

    public struct AssociateLinkRequest: AWSEncodableShape {
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String

        @inlinable
        public init(deviceId: String, globalNetworkId: String, linkId: String) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.deviceId, forKey: .deviceId)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encode(self.linkId, forKey: .linkId)
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case linkId = "LinkId"
        }
    }

    public struct AssociateLinkResponse: AWSDecodableShape {
        /// The link association.
        public let linkAssociation: LinkAssociation?

        @inlinable
        public init(linkAssociation: LinkAssociation? = nil) {
            self.linkAssociation = linkAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case linkAssociation = "LinkAssociation"
        }
    }

    public struct AssociateTransitGatewayConnectPeerRequest: AWSEncodableShape {
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String?
        /// The Amazon Resource Name (ARN) of the Connect peer.
        public let transitGatewayConnectPeerArn: String

        @inlinable
        public init(deviceId: String, globalNetworkId: String, linkId: String? = nil, transitGatewayConnectPeerArn: String) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.deviceId, forKey: .deviceId)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.linkId, forKey: .linkId)
            try container.encode(self.transitGatewayConnectPeerArn, forKey: .transitGatewayConnectPeerArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.transitGatewayConnectPeerArn, name: "transitGatewayConnectPeerArn", parent: name, max: 500)
            try self.validate(self.transitGatewayConnectPeerArn, name: "transitGatewayConnectPeerArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case linkId = "LinkId"
            case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
        }
    }

    public struct AssociateTransitGatewayConnectPeerResponse: AWSDecodableShape {
        /// The transit gateway Connect peer association.
        public let transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation?

        @inlinable
        public init(transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation? = nil) {
            self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
        }
    }

    public struct Attachment: AWSDecodableShape {
        /// The ID of the attachment.
        public let attachmentId: String?
        /// The policy rule number associated with the attachment.
        public let attachmentPolicyRuleNumber: Int?
        /// The type of attachment.
        public let attachmentType: AttachmentType?
        /// The ARN of a core network.
        public let coreNetworkArn: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when the attachment was created.
        public let createdAt: Date?
        /// The Region where the edge is located. This is returned for all attachment types except a Direct Connect gateway attachment, which instead returns EdgeLocations.
        public let edgeLocation: String?
        /// The edge locations that the Direct Connect gateway is associated with. This is returned only for Direct Connect gateway attachments. All other attachment types retrun EdgeLocation.
        public let edgeLocations: [String]?
        /// Describes the error associated with the attachment request.
        public let lastModificationErrors: [AttachmentError]?
        /// The name of the network function group.
        public let networkFunctionGroupName: String?
        /// The ID of the attachment account owner.
        public let ownerAccountId: String?
        /// Describes a proposed change to a network function group associated with the attachment.
        public let proposedNetworkFunctionGroupChange: ProposedNetworkFunctionGroupChange?
        /// The attachment to move from one segment to another.
        public let proposedSegmentChange: ProposedSegmentChange?
        /// The attachment resource ARN.
        public let resourceArn: String?
        /// The name of the segment attachment.
        public let segmentName: String?
        /// The state of the attachment.
        public let state: AttachmentState?
        /// The tags associated with the attachment.
        public let tags: [Tag]?
        /// The timestamp when the attachment was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(attachmentId: String? = nil, attachmentPolicyRuleNumber: Int? = nil, attachmentType: AttachmentType? = nil, coreNetworkArn: String? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, edgeLocation: String? = nil, edgeLocations: [String]? = nil, lastModificationErrors: [AttachmentError]? = nil, networkFunctionGroupName: String? = nil, ownerAccountId: String? = nil, proposedNetworkFunctionGroupChange: ProposedNetworkFunctionGroupChange? = nil, proposedSegmentChange: ProposedSegmentChange? = nil, resourceArn: String? = nil, segmentName: String? = nil, state: AttachmentState? = nil, tags: [Tag]? = nil, updatedAt: Date? = nil) {
            self.attachmentId = attachmentId
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.attachmentType = attachmentType
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.edgeLocations = edgeLocations
            self.lastModificationErrors = lastModificationErrors
            self.networkFunctionGroupName = networkFunctionGroupName
            self.ownerAccountId = ownerAccountId
            self.proposedNetworkFunctionGroupChange = proposedNetworkFunctionGroupChange
            self.proposedSegmentChange = proposedSegmentChange
            self.resourceArn = resourceArn
            self.segmentName = segmentName
            self.state = state
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case attachmentPolicyRuleNumber = "AttachmentPolicyRuleNumber"
            case attachmentType = "AttachmentType"
            case coreNetworkArn = "CoreNetworkArn"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case edgeLocation = "EdgeLocation"
            case edgeLocations = "EdgeLocations"
            case lastModificationErrors = "LastModificationErrors"
            case networkFunctionGroupName = "NetworkFunctionGroupName"
            case ownerAccountId = "OwnerAccountId"
            case proposedNetworkFunctionGroupChange = "ProposedNetworkFunctionGroupChange"
            case proposedSegmentChange = "ProposedSegmentChange"
            case resourceArn = "ResourceArn"
            case segmentName = "SegmentName"
            case state = "State"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct AttachmentError: AWSDecodableShape {
        /// The error code for the attachment request.
        public let code: AttachmentErrorCode?
        /// The message associated with the error code.
        public let message: String?
        /// The ID of the attachment request.
        public let requestId: String?
        /// The ARN of the requested attachment resource.
        public let resourceArn: String?

        @inlinable
        public init(code: AttachmentErrorCode? = nil, message: String? = nil, requestId: String? = nil, resourceArn: String? = nil) {
            self.code = code
            self.message = message
            self.requestId = requestId
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case requestId = "RequestId"
            case resourceArn = "ResourceArn"
        }
    }

    public struct Bandwidth: AWSEncodableShape & AWSDecodableShape {
        /// Download speed in Mbps.
        public let downloadSpeed: Int?
        /// Upload speed in Mbps.
        public let uploadSpeed: Int?

        @inlinable
        public init(downloadSpeed: Int? = nil, uploadSpeed: Int? = nil) {
            self.downloadSpeed = downloadSpeed
            self.uploadSpeed = uploadSpeed
        }

        private enum CodingKeys: String, CodingKey {
            case downloadSpeed = "DownloadSpeed"
            case uploadSpeed = "UploadSpeed"
        }
    }

    public struct BgpOptions: AWSEncodableShape {
        /// The Peer ASN of the BGP.
        public let peerAsn: Int64?

        @inlinable
        public init(peerAsn: Int64? = nil) {
            self.peerAsn = peerAsn
        }

        private enum CodingKeys: String, CodingKey {
            case peerAsn = "PeerAsn"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The ID of the resource.
        public let resourceId: String
        /// The resource type.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ConnectAttachment: AWSDecodableShape {
        /// The attachment details.
        public let attachment: Attachment?
        /// Options for connecting an attachment.
        public let options: ConnectAttachmentOptions?
        /// The ID of the transport attachment.
        public let transportAttachmentId: String?

        @inlinable
        public init(attachment: Attachment? = nil, options: ConnectAttachmentOptions? = nil, transportAttachmentId: String? = nil) {
            self.attachment = attachment
            self.options = options
            self.transportAttachmentId = transportAttachmentId
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case options = "Options"
            case transportAttachmentId = "TransportAttachmentId"
        }
    }

    public struct ConnectAttachmentOptions: AWSEncodableShape & AWSDecodableShape {
        /// The protocol used for the attachment connection.
        public let `protocol`: TunnelProtocol?

        @inlinable
        public init(protocol: TunnelProtocol? = nil) {
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case `protocol` = "Protocol"
        }
    }

    public struct ConnectPeer: AWSDecodableShape {
        /// The configuration of the Connect peer.
        public let configuration: ConnectPeerConfiguration?
        /// The ID of the attachment to connect.
        public let connectAttachmentId: String?
        /// The ID of the Connect peer.
        public let connectPeerId: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when the Connect peer was created.
        public let createdAt: Date?
        /// The Connect peer Regions where edges are located.
        public let edgeLocation: String?
        /// Describes the error associated with the attachment request.
        public let lastModificationErrors: [ConnectPeerError]?
        /// The state of the Connect peer.
        public let state: ConnectPeerState?
        /// The subnet ARN for the Connect peer. This only applies only when the protocol is NO_ENCAP.
        public let subnetArn: String?
        /// The list of key-value tags associated with the Connect peer.
        public let tags: [Tag]?

        @inlinable
        public init(configuration: ConnectPeerConfiguration? = nil, connectAttachmentId: String? = nil, connectPeerId: String? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, edgeLocation: String? = nil, lastModificationErrors: [ConnectPeerError]? = nil, state: ConnectPeerState? = nil, subnetArn: String? = nil, tags: [Tag]? = nil) {
            self.configuration = configuration
            self.connectAttachmentId = connectAttachmentId
            self.connectPeerId = connectPeerId
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.lastModificationErrors = lastModificationErrors
            self.state = state
            self.subnetArn = subnetArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case connectAttachmentId = "ConnectAttachmentId"
            case connectPeerId = "ConnectPeerId"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case edgeLocation = "EdgeLocation"
            case lastModificationErrors = "LastModificationErrors"
            case state = "State"
            case subnetArn = "SubnetArn"
            case tags = "Tags"
        }
    }

    public struct ConnectPeerAssociation: AWSDecodableShape {
        /// The ID of the Connect peer.
        public let connectPeerId: String?
        /// The ID of the device to connect to.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The ID of the link.
        public let linkId: String?
        /// The state of the Connect peer association.
        public let state: ConnectPeerAssociationState?

        @inlinable
        public init(connectPeerId: String? = nil, deviceId: String? = nil, globalNetworkId: String? = nil, linkId: String? = nil, state: ConnectPeerAssociationState? = nil) {
            self.connectPeerId = connectPeerId
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeerId = "ConnectPeerId"
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case linkId = "LinkId"
            case state = "State"
        }
    }

    public struct ConnectPeerBgpConfiguration: AWSDecodableShape {
        /// The address of a core network.
        public let coreNetworkAddress: String?
        /// The ASN of the Coret Network.
        public let coreNetworkAsn: Int64?
        /// The address of a core network Connect peer.
        public let peerAddress: String?
        /// The ASN of the Connect peer.
        public let peerAsn: Int64?

        @inlinable
        public init(coreNetworkAddress: String? = nil, coreNetworkAsn: Int64? = nil, peerAddress: String? = nil, peerAsn: Int64? = nil) {
            self.coreNetworkAddress = coreNetworkAddress
            self.coreNetworkAsn = coreNetworkAsn
            self.peerAddress = peerAddress
            self.peerAsn = peerAsn
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkAddress = "CoreNetworkAddress"
            case coreNetworkAsn = "CoreNetworkAsn"
            case peerAddress = "PeerAddress"
            case peerAsn = "PeerAsn"
        }
    }

    public struct ConnectPeerConfiguration: AWSDecodableShape {
        /// The Connect peer BGP configurations.
        public let bgpConfigurations: [ConnectPeerBgpConfiguration]?
        /// The IP address of a core network.
        public let coreNetworkAddress: String?
        /// The inside IP addresses used for a Connect peer configuration.
        public let insideCidrBlocks: [String]?
        /// The IP address of the Connect peer.
        public let peerAddress: String?
        /// The protocol used for a Connect peer configuration.
        public let `protocol`: TunnelProtocol?

        @inlinable
        public init(bgpConfigurations: [ConnectPeerBgpConfiguration]? = nil, coreNetworkAddress: String? = nil, insideCidrBlocks: [String]? = nil, peerAddress: String? = nil, protocol: TunnelProtocol? = nil) {
            self.bgpConfigurations = bgpConfigurations
            self.coreNetworkAddress = coreNetworkAddress
            self.insideCidrBlocks = insideCidrBlocks
            self.peerAddress = peerAddress
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case bgpConfigurations = "BgpConfigurations"
            case coreNetworkAddress = "CoreNetworkAddress"
            case insideCidrBlocks = "InsideCidrBlocks"
            case peerAddress = "PeerAddress"
            case `protocol` = "Protocol"
        }
    }

    public struct ConnectPeerError: AWSDecodableShape {
        /// The error code for the Connect peer request.
        public let code: ConnectPeerErrorCode?
        /// The message associated with the error code.
        public let message: String?
        /// The ID of the Connect peer request.
        public let requestId: String?
        /// The ARN of the requested Connect peer resource.
        public let resourceArn: String?

        @inlinable
        public init(code: ConnectPeerErrorCode? = nil, message: String? = nil, requestId: String? = nil, resourceArn: String? = nil) {
            self.code = code
            self.message = message
            self.requestId = requestId
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case requestId = "RequestId"
            case resourceArn = "ResourceArn"
        }
    }

    public struct ConnectPeerSummary: AWSDecodableShape {
        /// The ID of a Connect peer attachment.
        public let connectAttachmentId: String?
        /// The ID of a Connect peer.
        public let connectPeerId: String?
        /// The state of a Connect peer.
        public let connectPeerState: ConnectPeerState?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when a Connect peer was created.
        public let createdAt: Date?
        /// The Region where the edge is located.
        public let edgeLocation: String?
        /// The subnet ARN for the Connect peer summary.
        public let subnetArn: String?
        /// The list of key-value tags associated with the Connect peer summary.
        public let tags: [Tag]?

        @inlinable
        public init(connectAttachmentId: String? = nil, connectPeerId: String? = nil, connectPeerState: ConnectPeerState? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, edgeLocation: String? = nil, subnetArn: String? = nil, tags: [Tag]? = nil) {
            self.connectAttachmentId = connectAttachmentId
            self.connectPeerId = connectPeerId
            self.connectPeerState = connectPeerState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.subnetArn = subnetArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case connectAttachmentId = "ConnectAttachmentId"
            case connectPeerId = "ConnectPeerId"
            case connectPeerState = "ConnectPeerState"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case edgeLocation = "EdgeLocation"
            case subnetArn = "SubnetArn"
            case tags = "Tags"
        }
    }

    public struct Connection: AWSDecodableShape {
        /// The ID of the second device in the connection.
        public let connectedDeviceId: String?
        /// The ID of the link for the second device in the connection.
        public let connectedLinkId: String?
        /// The Amazon Resource Name (ARN) of the connection.
        public let connectionArn: String?
        /// The ID of the connection.
        public let connectionId: String?
        /// The date and time that the connection was created.
        public let createdAt: Date?
        /// The description of the connection.
        public let description: String?
        /// The ID of the first device in the connection.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The ID of the link for the first device in the connection.
        public let linkId: String?
        /// The state of the connection.
        public let state: ConnectionState?
        /// The tags for the connection.
        public let tags: [Tag]?

        @inlinable
        public init(connectedDeviceId: String? = nil, connectedLinkId: String? = nil, connectionArn: String? = nil, connectionId: String? = nil, createdAt: Date? = nil, description: String? = nil, deviceId: String? = nil, globalNetworkId: String? = nil, linkId: String? = nil, state: ConnectionState? = nil, tags: [Tag]? = nil) {
            self.connectedDeviceId = connectedDeviceId
            self.connectedLinkId = connectedLinkId
            self.connectionArn = connectionArn
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.description = description
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case connectedDeviceId = "ConnectedDeviceId"
            case connectedLinkId = "ConnectedLinkId"
            case connectionArn = "ConnectionArn"
            case connectionId = "ConnectionId"
            case createdAt = "CreatedAt"
            case description = "Description"
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case linkId = "LinkId"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct ConnectionHealth: AWSDecodableShape {
        /// The connection status.
        public let status: ConnectionStatus?
        /// The time the status was last updated.
        public let timestamp: Date?
        /// The connection type.
        public let type: ConnectionType?

        @inlinable
        public init(status: ConnectionStatus? = nil, timestamp: Date? = nil, type: ConnectionType? = nil) {
            self.status = status
            self.timestamp = timestamp
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case timestamp = "Timestamp"
            case type = "Type"
        }
    }

    public struct CoreNetwork: AWSDecodableShape {
        /// The ARN of a core network.
        public let coreNetworkArn: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when a core network was created.
        public let createdAt: Date?
        /// The description of a core network.
        public let description: String?
        /// The edges within a core network.
        public let edges: [CoreNetworkEdge]?
        /// The ID of the global network that your core network is a part of.
        public let globalNetworkId: String?
        /// The network function groups associated with a core network.
        public let networkFunctionGroups: [CoreNetworkNetworkFunctionGroup]?
        /// The segments within a core network.
        public let segments: [CoreNetworkSegment]?
        /// The current state of a core network.
        public let state: CoreNetworkState?
        /// The list of key-value tags associated with a core network.
        public let tags: [Tag]?

        @inlinable
        public init(coreNetworkArn: String? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, description: String? = nil, edges: [CoreNetworkEdge]? = nil, globalNetworkId: String? = nil, networkFunctionGroups: [CoreNetworkNetworkFunctionGroup]? = nil, segments: [CoreNetworkSegment]? = nil, state: CoreNetworkState? = nil, tags: [Tag]? = nil) {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.edges = edges
            self.globalNetworkId = globalNetworkId
            self.networkFunctionGroups = networkFunctionGroups
            self.segments = segments
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkArn = "CoreNetworkArn"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case description = "Description"
            case edges = "Edges"
            case globalNetworkId = "GlobalNetworkId"
            case networkFunctionGroups = "NetworkFunctionGroups"
            case segments = "Segments"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct CoreNetworkChange: AWSDecodableShape {
        /// The action to take for a core network.
        public let action: ChangeAction?
        /// The resource identifier.
        public let identifier: String?
        /// Uniquely identifies the path for a change within the changeset. For example, the IdentifierPath for a core network segment change might be "CORE_NETWORK_SEGMENT/us-east-1/devsegment".
        public let identifierPath: String?
        /// The new value for a core network
        public let newValues: CoreNetworkChangeValues?
        /// The previous values for a core network.
        public let previousValues: CoreNetworkChangeValues?
        /// The type of change.
        public let type: ChangeType?

        @inlinable
        public init(action: ChangeAction? = nil, identifier: String? = nil, identifierPath: String? = nil, newValues: CoreNetworkChangeValues? = nil, previousValues: CoreNetworkChangeValues? = nil, type: ChangeType? = nil) {
            self.action = action
            self.identifier = identifier
            self.identifierPath = identifierPath
            self.newValues = newValues
            self.previousValues = previousValues
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case identifier = "Identifier"
            case identifierPath = "IdentifierPath"
            case newValues = "NewValues"
            case previousValues = "PreviousValues"
            case type = "Type"
        }
    }

    public struct CoreNetworkChangeEvent: AWSDecodableShape {
        /// The action taken for the change event.
        public let action: ChangeAction?
        /// The timestamp for an event change in status.
        public let eventTime: Date?
        /// Uniquely identifies the path for a change within the changeset. For example, the IdentifierPath for a core network segment change might be "CORE_NETWORK_SEGMENT/us-east-1/devsegment".
        public let identifierPath: String?
        /// The status of the core network change event.
        public let status: ChangeStatus?
        /// Describes the type of change event.
        public let type: ChangeType?
        /// Details of the change event.
        public let values: CoreNetworkChangeEventValues?

        @inlinable
        public init(action: ChangeAction? = nil, eventTime: Date? = nil, identifierPath: String? = nil, status: ChangeStatus? = nil, type: ChangeType? = nil, values: CoreNetworkChangeEventValues? = nil) {
            self.action = action
            self.eventTime = eventTime
            self.identifierPath = identifierPath
            self.status = status
            self.type = type
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case eventTime = "EventTime"
            case identifierPath = "IdentifierPath"
            case status = "Status"
            case type = "Type"
            case values = "Values"
        }
    }

    public struct CoreNetworkChangeEventValues: AWSDecodableShape {
        /// The ID of the attachment if the change event is associated with an attachment.
        public let attachmentId: String?
        /// For a STATIC_ROUTE event, this is the IP address.
        public let cidr: String?
        /// The edge location for the core network change event.
        public let edgeLocation: String?
        /// The changed network function group name.
        public let networkFunctionGroupName: String?
        /// The segment name if the change event is associated with a segment.
        public let segmentName: String?

        @inlinable
        public init(attachmentId: String? = nil, cidr: String? = nil, edgeLocation: String? = nil, networkFunctionGroupName: String? = nil, segmentName: String? = nil) {
            self.attachmentId = attachmentId
            self.cidr = cidr
            self.edgeLocation = edgeLocation
            self.networkFunctionGroupName = networkFunctionGroupName
            self.segmentName = segmentName
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case cidr = "Cidr"
            case edgeLocation = "EdgeLocation"
            case networkFunctionGroupName = "NetworkFunctionGroupName"
            case segmentName = "SegmentName"
        }
    }

    public struct CoreNetworkChangeValues: AWSDecodableShape {
        /// The ASN of a core network.
        public let asn: Int64?
        /// The IP addresses used for a core network.
        public let cidr: String?
        /// The ID of the destination.
        public let destinationIdentifier: String?
        /// The Regions where edges are located in a core network.
        public let edgeLocations: [String]?
        /// The inside IP addresses used for core network change values.
        public let insideCidrBlocks: [String]?
        /// The network function group name if the change event is associated with a network function group.
        public let networkFunctionGroupName: String?
        /// The names of the segments in a core network.
        public let segmentName: String?
        /// Describes the service insertion action.
        public let serviceInsertionActions: [ServiceInsertionAction]?
        /// The shared segments for a core network change value.
        public let sharedSegments: [String]?

        @inlinable
        public init(asn: Int64? = nil, cidr: String? = nil, destinationIdentifier: String? = nil, edgeLocations: [String]? = nil, insideCidrBlocks: [String]? = nil, networkFunctionGroupName: String? = nil, segmentName: String? = nil, serviceInsertionActions: [ServiceInsertionAction]? = nil, sharedSegments: [String]? = nil) {
            self.asn = asn
            self.cidr = cidr
            self.destinationIdentifier = destinationIdentifier
            self.edgeLocations = edgeLocations
            self.insideCidrBlocks = insideCidrBlocks
            self.networkFunctionGroupName = networkFunctionGroupName
            self.segmentName = segmentName
            self.serviceInsertionActions = serviceInsertionActions
            self.sharedSegments = sharedSegments
        }

        private enum CodingKeys: String, CodingKey {
            case asn = "Asn"
            case cidr = "Cidr"
            case destinationIdentifier = "DestinationIdentifier"
            case edgeLocations = "EdgeLocations"
            case insideCidrBlocks = "InsideCidrBlocks"
            case networkFunctionGroupName = "NetworkFunctionGroupName"
            case segmentName = "SegmentName"
            case serviceInsertionActions = "ServiceInsertionActions"
            case sharedSegments = "SharedSegments"
        }
    }

    public struct CoreNetworkEdge: AWSDecodableShape {
        /// The ASN of a core network edge.
        public let asn: Int64?
        /// The Region where a core network edge is located.
        public let edgeLocation: String?
        /// The inside IP addresses used for core network edges.
        public let insideCidrBlocks: [String]?

        @inlinable
        public init(asn: Int64? = nil, edgeLocation: String? = nil, insideCidrBlocks: [String]? = nil) {
            self.asn = asn
            self.edgeLocation = edgeLocation
            self.insideCidrBlocks = insideCidrBlocks
        }

        private enum CodingKeys: String, CodingKey {
            case asn = "Asn"
            case edgeLocation = "EdgeLocation"
            case insideCidrBlocks = "InsideCidrBlocks"
        }
    }

    public struct CoreNetworkNetworkFunctionGroup: AWSDecodableShape {
        /// The core network edge locations.
        public let edgeLocations: [String]?
        /// The name of the network function group.
        public let name: String?
        /// The segments associated with the network function group.
        public let segments: ServiceInsertionSegments?

        @inlinable
        public init(edgeLocations: [String]? = nil, name: String? = nil, segments: ServiceInsertionSegments? = nil) {
            self.edgeLocations = edgeLocations
            self.name = name
            self.segments = segments
        }

        private enum CodingKeys: String, CodingKey {
            case edgeLocations = "EdgeLocations"
            case name = "Name"
            case segments = "Segments"
        }
    }

    public struct CoreNetworkNetworkFunctionGroupIdentifier: AWSEncodableShape {
        /// The ID of the core network.
        public let coreNetworkId: String?
        /// The location for the core network edge.
        public let edgeLocation: String?
        /// The network function group name.
        public let networkFunctionGroupName: String?

        @inlinable
        public init(coreNetworkId: String? = nil, edgeLocation: String? = nil, networkFunctionGroupName: String? = nil) {
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.networkFunctionGroupName = networkFunctionGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, max: 63)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, min: 1)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.networkFunctionGroupName, name: "networkFunctionGroupName", parent: name, max: 256)
            try self.validate(self.networkFunctionGroupName, name: "networkFunctionGroupName", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkId = "CoreNetworkId"
            case edgeLocation = "EdgeLocation"
            case networkFunctionGroupName = "NetworkFunctionGroupName"
        }
    }

    public struct CoreNetworkPolicy: AWSDecodableShape {
        /// Whether a core network policy is the current LIVE policy or the most recently submitted policy.
        public let alias: CoreNetworkPolicyAlias?
        /// The state of a core network policy.
        public let changeSetState: ChangeSetState?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when a core network policy was created.
        public let createdAt: Date?
        /// The description of a core network policy.
        public let description: String?
        /// Describes a core network policy.
        public let policyDocument: String?
        /// Describes any errors in a core network policy.
        public let policyErrors: [CoreNetworkPolicyError]?
        /// The ID of the policy version.
        public let policyVersionId: Int?

        @inlinable
        public init(alias: CoreNetworkPolicyAlias? = nil, changeSetState: ChangeSetState? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, description: String? = nil, policyDocument: String? = nil, policyErrors: [CoreNetworkPolicyError]? = nil, policyVersionId: Int? = nil) {
            self.alias = alias
            self.changeSetState = changeSetState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.policyDocument = policyDocument
            self.policyErrors = policyErrors
            self.policyVersionId = policyVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case changeSetState = "ChangeSetState"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case description = "Description"
            case policyDocument = "PolicyDocument"
            case policyErrors = "PolicyErrors"
            case policyVersionId = "PolicyVersionId"
        }
    }

    public struct CoreNetworkPolicyError: AWSDecodableShape {
        /// The error code associated with a core network policy error.
        public let errorCode: String
        /// The message associated with a core network policy error code.
        public let message: String
        /// The JSON path where the error was discovered in the policy document.
        public let path: String?

        @inlinable
        public init(errorCode: String, message: String, path: String? = nil) {
            self.errorCode = errorCode
            self.message = message
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
            case path = "Path"
        }
    }

    public struct CoreNetworkPolicyException: AWSErrorShape {
        /// Describes a core network policy exception.
        public let errors: [CoreNetworkPolicyError]?
        public let message: String

        @inlinable
        public init(errors: [CoreNetworkPolicyError]? = nil, message: String) {
            self.errors = errors
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case message = "Message"
        }
    }

    public struct CoreNetworkPolicyVersion: AWSDecodableShape {
        /// Whether a core network policy is the current policy or the most recently submitted policy.
        public let alias: CoreNetworkPolicyAlias?
        /// The status of the policy version change set.
        public let changeSetState: ChangeSetState?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when a core network policy version was created.
        public let createdAt: Date?
        /// The description of a core network policy version.
        public let description: String?
        /// The ID of the policy version.
        public let policyVersionId: Int?

        @inlinable
        public init(alias: CoreNetworkPolicyAlias? = nil, changeSetState: ChangeSetState? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, description: String? = nil, policyVersionId: Int? = nil) {
            self.alias = alias
            self.changeSetState = changeSetState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.policyVersionId = policyVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case changeSetState = "ChangeSetState"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case description = "Description"
            case policyVersionId = "PolicyVersionId"
        }
    }

    public struct CoreNetworkSegment: AWSDecodableShape {
        /// The Regions where the edges are located.
        public let edgeLocations: [String]?
        /// The name of a core network segment.
        public let name: String?
        /// The shared segments of a core network.
        public let sharedSegments: [String]?

        @inlinable
        public init(edgeLocations: [String]? = nil, name: String? = nil, sharedSegments: [String]? = nil) {
            self.edgeLocations = edgeLocations
            self.name = name
            self.sharedSegments = sharedSegments
        }

        private enum CodingKeys: String, CodingKey {
            case edgeLocations = "EdgeLocations"
            case name = "Name"
            case sharedSegments = "SharedSegments"
        }
    }

    public struct CoreNetworkSegmentEdgeIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The Region where the segment edge is located.
        public let edgeLocation: String?
        /// The name of the segment edge.
        public let segmentName: String?

        @inlinable
        public init(coreNetworkId: String? = nil, edgeLocation: String? = nil, segmentName: String? = nil) {
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.segmentName = segmentName
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, max: 63)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, min: 1)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.segmentName, name: "segmentName", parent: name, max: 256)
            try self.validate(self.segmentName, name: "segmentName", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkId = "CoreNetworkId"
            case edgeLocation = "EdgeLocation"
            case segmentName = "SegmentName"
        }
    }

    public struct CoreNetworkSummary: AWSDecodableShape {
        /// a core network ARN.
        public let coreNetworkArn: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The description of a core network.
        public let description: String?
        /// The global network ID.
        public let globalNetworkId: String?
        /// The ID of the account owner.
        public let ownerAccountId: String?
        /// The state of a core network.
        public let state: CoreNetworkState?
        /// The key-value tags associated with a core network summary.
        public let tags: [Tag]?

        @inlinable
        public init(coreNetworkArn: String? = nil, coreNetworkId: String? = nil, description: String? = nil, globalNetworkId: String? = nil, ownerAccountId: String? = nil, state: CoreNetworkState? = nil, tags: [Tag]? = nil) {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.ownerAccountId = ownerAccountId
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkArn = "CoreNetworkArn"
            case coreNetworkId = "CoreNetworkId"
            case description = "Description"
            case globalNetworkId = "GlobalNetworkId"
            case ownerAccountId = "OwnerAccountId"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct CreateConnectAttachmentRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of a core network where you want to create the attachment.
        public let coreNetworkId: String
        /// The Region where the edge is located.
        public let edgeLocation: String
        /// Options for creating an attachment.
        public let options: ConnectAttachmentOptions
        /// The list of key-value tags associated with the request.
        public let tags: [Tag]?
        /// The ID of the attachment between the two connections.
        public let transportAttachmentId: String

        @inlinable
        public init(clientToken: String? = CreateConnectAttachmentRequest.idempotencyToken(), coreNetworkId: String, edgeLocation: String, options: ConnectAttachmentOptions, tags: [Tag]? = nil, transportAttachmentId: String) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.options = options
            self.tags = tags
            self.transportAttachmentId = transportAttachmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, max: 63)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, min: 1)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.transportAttachmentId, name: "transportAttachmentId", parent: name, max: 50)
            try self.validate(self.transportAttachmentId, name: "transportAttachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case coreNetworkId = "CoreNetworkId"
            case edgeLocation = "EdgeLocation"
            case options = "Options"
            case tags = "Tags"
            case transportAttachmentId = "TransportAttachmentId"
        }
    }

    public struct CreateConnectAttachmentResponse: AWSDecodableShape {
        /// The response to a Connect attachment request.
        public let connectAttachment: ConnectAttachment?

        @inlinable
        public init(connectAttachment: ConnectAttachment? = nil) {
            self.connectAttachment = connectAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case connectAttachment = "ConnectAttachment"
        }
    }

    public struct CreateConnectPeerRequest: AWSEncodableShape {
        /// The Connect peer BGP options. This only applies only when the protocol is GRE.
        public let bgpOptions: BgpOptions?
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of the connection attachment.
        public let connectAttachmentId: String
        /// A Connect peer core network address. This only applies only when the protocol is GRE.
        public let coreNetworkAddress: String?
        /// The inside IP addresses used for BGP peering.
        public let insideCidrBlocks: [String]?
        /// The Connect peer address.
        public let peerAddress: String
        /// The subnet ARN for the Connect peer. This only applies only when the protocol is NO_ENCAP.
        public let subnetArn: String?
        /// The tags associated with the peer request.
        public let tags: [Tag]?

        @inlinable
        public init(bgpOptions: BgpOptions? = nil, clientToken: String? = CreateConnectPeerRequest.idempotencyToken(), connectAttachmentId: String, coreNetworkAddress: String? = nil, insideCidrBlocks: [String]? = nil, peerAddress: String, subnetArn: String? = nil, tags: [Tag]? = nil) {
            self.bgpOptions = bgpOptions
            self.clientToken = clientToken
            self.connectAttachmentId = connectAttachmentId
            self.coreNetworkAddress = coreNetworkAddress
            self.insideCidrBlocks = insideCidrBlocks
            self.peerAddress = peerAddress
            self.subnetArn = subnetArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.connectAttachmentId, name: "connectAttachmentId", parent: name, max: 50)
            try self.validate(self.connectAttachmentId, name: "connectAttachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
            try self.validate(self.coreNetworkAddress, name: "coreNetworkAddress", parent: name, max: 50)
            try self.validate(self.coreNetworkAddress, name: "coreNetworkAddress", parent: name, min: 1)
            try self.validate(self.coreNetworkAddress, name: "coreNetworkAddress", parent: name, pattern: "^[\\s\\S]*$")
            try self.insideCidrBlocks?.forEach {
                try validate($0, name: "insideCidrBlocks[]", parent: name, max: 256)
                try validate($0, name: "insideCidrBlocks[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.peerAddress, name: "peerAddress", parent: name, max: 50)
            try self.validate(self.peerAddress, name: "peerAddress", parent: name, min: 1)
            try self.validate(self.peerAddress, name: "peerAddress", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.subnetArn, name: "subnetArn", parent: name, max: 500)
            try self.validate(self.subnetArn, name: "subnetArn", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:subnet\\/subnet-[0-9a-f]{8,17}$|^$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bgpOptions = "BgpOptions"
            case clientToken = "ClientToken"
            case connectAttachmentId = "ConnectAttachmentId"
            case coreNetworkAddress = "CoreNetworkAddress"
            case insideCidrBlocks = "InsideCidrBlocks"
            case peerAddress = "PeerAddress"
            case subnetArn = "SubnetArn"
            case tags = "Tags"
        }
    }

    public struct CreateConnectPeerResponse: AWSDecodableShape {
        /// The response to the request.
        public let connectPeer: ConnectPeer?

        @inlinable
        public init(connectPeer: ConnectPeer? = nil) {
            self.connectPeer = connectPeer
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeer = "ConnectPeer"
        }
    }

    public struct CreateConnectionRequest: AWSEncodableShape {
        /// The ID of the second device in the connection.
        public let connectedDeviceId: String
        /// The ID of the link for the second device.
        public let connectedLinkId: String?
        /// A description of the connection. Length Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the first device in the connection.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link for the first device.
        public let linkId: String?
        /// The tags to apply to the resource during creation.
        public let tags: [Tag]?

        @inlinable
        public init(connectedDeviceId: String, connectedLinkId: String? = nil, description: String? = nil, deviceId: String, globalNetworkId: String, linkId: String? = nil, tags: [Tag]? = nil) {
            self.connectedDeviceId = connectedDeviceId
            self.connectedLinkId = connectedLinkId
            self.description = description
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.connectedDeviceId, forKey: .connectedDeviceId)
            try container.encodeIfPresent(self.connectedLinkId, forKey: .connectedLinkId)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.deviceId, forKey: .deviceId)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.linkId, forKey: .linkId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectedDeviceId, name: "connectedDeviceId", parent: name, max: 50)
            try self.validate(self.connectedDeviceId, name: "connectedDeviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.connectedLinkId, name: "connectedLinkId", parent: name, max: 50)
            try self.validate(self.connectedLinkId, name: "connectedLinkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectedDeviceId = "ConnectedDeviceId"
            case connectedLinkId = "ConnectedLinkId"
            case description = "Description"
            case deviceId = "DeviceId"
            case linkId = "LinkId"
            case tags = "Tags"
        }
    }

    public struct CreateConnectionResponse: AWSDecodableShape {
        /// Information about the connection.
        public let connection: Connection?

        @inlinable
        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct CreateCoreNetworkRequest: AWSEncodableShape {
        /// The client token associated with a core network request.
        public let clientToken: String?
        /// The description of a core network.
        public let description: String?
        /// The ID of the global network that a core network will be a part of.
        public let globalNetworkId: String
        /// The policy document for creating a core network.
        public let policyDocument: String?
        /// Key-value tags associated with a core network request.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateCoreNetworkRequest.idempotencyToken(), description: String? = nil, globalNetworkId: String, policyDocument: String? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.policyDocument = policyDocument
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, max: 10000000)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case globalNetworkId = "GlobalNetworkId"
            case policyDocument = "PolicyDocument"
            case tags = "Tags"
        }
    }

    public struct CreateCoreNetworkResponse: AWSDecodableShape {
        /// Returns details about a core network.
        public let coreNetwork: CoreNetwork?

        @inlinable
        public init(coreNetwork: CoreNetwork? = nil) {
            self.coreNetwork = coreNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetwork = "CoreNetwork"
        }
    }

    public struct CreateDeviceRequest: AWSEncodableShape {
        /// The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.
        public let awsLocation: AWSLocation?
        /// A description of the device. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The location of the device.
        public let location: Location?
        /// The model of the device. Constraints: Maximum length of 128 characters.
        public let model: String?
        /// The serial number of the device. Constraints: Maximum length of 128 characters.
        public let serialNumber: String?
        /// The ID of the site.
        public let siteId: String?
        /// The tags to apply to the resource during creation.
        public let tags: [Tag]?
        /// The type of the device.
        public let type: String?
        /// The vendor of the device. Constraints: Maximum length of 128 characters.
        public let vendor: String?

        @inlinable
        public init(awsLocation: AWSLocation? = nil, description: String? = nil, globalNetworkId: String, location: Location? = nil, model: String? = nil, serialNumber: String? = nil, siteId: String? = nil, tags: [Tag]? = nil, type: String? = nil, vendor: String? = nil) {
            self.awsLocation = awsLocation
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.model = model
            self.serialNumber = serialNumber
            self.siteId = siteId
            self.tags = tags
            self.type = type
            self.vendor = vendor
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.awsLocation, forKey: .awsLocation)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.location, forKey: .location)
            try container.encodeIfPresent(self.model, forKey: .model)
            try container.encodeIfPresent(self.serialNumber, forKey: .serialNumber)
            try container.encodeIfPresent(self.siteId, forKey: .siteId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.type, forKey: .type)
            try container.encodeIfPresent(self.vendor, forKey: .vendor)
        }

        public func validate(name: String) throws {
            try self.awsLocation?.validate(name: "\(name).awsLocation")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.location?.validate(name: "\(name).location")
            try self.validate(self.model, name: "model", parent: name, max: 256)
            try self.validate(self.model, name: "model", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, max: 256)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.vendor, name: "vendor", parent: name, max: 256)
            try self.validate(self.vendor, name: "vendor", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsLocation = "AWSLocation"
            case description = "Description"
            case location = "Location"
            case model = "Model"
            case serialNumber = "SerialNumber"
            case siteId = "SiteId"
            case tags = "Tags"
            case type = "Type"
            case vendor = "Vendor"
        }
    }

    public struct CreateDeviceResponse: AWSDecodableShape {
        /// Information about the device.
        public let device: Device?

        @inlinable
        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "Device"
        }
    }

    public struct CreateDirectConnectGatewayAttachmentRequest: AWSEncodableShape {
        /// client token
        public let clientToken: String?
        /// The ID of the Cloud WAN core network that the Direct Connect gateway attachment should be attached to.
        public let coreNetworkId: String
        /// The ARN of the Direct Connect gateway attachment.
        public let directConnectGatewayArn: String
        /// One or more core network edge locations that the Direct Connect gateway attachment is associated with.
        public let edgeLocations: [String]
        /// The key value tags to apply to the Direct Connect gateway attachment during creation.
        public let tags: [Tag]?

        @inlinable
        public init(clientToken: String? = CreateDirectConnectGatewayAttachmentRequest.idempotencyToken(), coreNetworkId: String, directConnectGatewayArn: String, edgeLocations: [String], tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.directConnectGatewayArn = directConnectGatewayArn
            self.edgeLocations = edgeLocations
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.directConnectGatewayArn, name: "directConnectGatewayArn", parent: name, max: 500)
            try self.validate(self.directConnectGatewayArn, name: "directConnectGatewayArn", parent: name, pattern: "^arn:[^:]{1,63}:directconnect::[^:]{0,63}:dx-gateway\\/[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$")
            try self.edgeLocations.forEach {
                try validate($0, name: "edgeLocations[]", parent: name, max: 63)
                try validate($0, name: "edgeLocations[]", parent: name, min: 1)
                try validate($0, name: "edgeLocations[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case coreNetworkId = "CoreNetworkId"
            case directConnectGatewayArn = "DirectConnectGatewayArn"
            case edgeLocations = "EdgeLocations"
            case tags = "Tags"
        }
    }

    public struct CreateDirectConnectGatewayAttachmentResponse: AWSDecodableShape {
        /// Describes the details of a CreateDirectConnectGatewayAttachment request.
        public let directConnectGatewayAttachment: DirectConnectGatewayAttachment?

        @inlinable
        public init(directConnectGatewayAttachment: DirectConnectGatewayAttachment? = nil) {
            self.directConnectGatewayAttachment = directConnectGatewayAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayAttachment = "DirectConnectGatewayAttachment"
        }
    }

    public struct CreateGlobalNetworkRequest: AWSEncodableShape {
        /// A description of the global network. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The tags to apply to the resource during creation.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case tags = "Tags"
        }
    }

    public struct CreateGlobalNetworkResponse: AWSDecodableShape {
        /// Information about the global network object.
        public let globalNetwork: GlobalNetwork?

        @inlinable
        public init(globalNetwork: GlobalNetwork? = nil) {
            self.globalNetwork = globalNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case globalNetwork = "GlobalNetwork"
        }
    }

    public struct CreateLinkRequest: AWSEncodableShape {
        ///  The upload speed and download speed in Mbps.
        public let bandwidth: Bandwidth
        /// A description of the link. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The provider of the link. Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^
        public let provider: String?
        /// The ID of the site.
        public let siteId: String
        /// The tags to apply to the resource during creation.
        public let tags: [Tag]?
        /// The type of the link. Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^
        public let type: String?

        @inlinable
        public init(bandwidth: Bandwidth, description: String? = nil, globalNetworkId: String, provider: String? = nil, siteId: String, tags: [Tag]? = nil, type: String? = nil) {
            self.bandwidth = bandwidth
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.provider = provider
            self.siteId = siteId
            self.tags = tags
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.bandwidth, forKey: .bandwidth)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.provider, forKey: .provider)
            try container.encode(self.siteId, forKey: .siteId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.provider, name: "provider", parent: name, max: 256)
            try self.validate(self.provider, name: "provider", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth = "Bandwidth"
            case description = "Description"
            case provider = "Provider"
            case siteId = "SiteId"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct CreateLinkResponse: AWSDecodableShape {
        /// Information about the link.
        public let link: Link?

        @inlinable
        public init(link: Link? = nil) {
            self.link = link
        }

        private enum CodingKeys: String, CodingKey {
            case link = "Link"
        }
    }

    public struct CreateSiteRequest: AWSEncodableShape {
        /// A description of your site. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.    Address: The physical address of the site.    Latitude: The latitude of the site.     Longitude: The longitude of the site.
        public let location: Location?
        /// The tags to apply to the resource during creation.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, globalNetworkId: String, location: Location? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.location, forKey: .location)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.location?.validate(name: "\(name).location")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case location = "Location"
            case tags = "Tags"
        }
    }

    public struct CreateSiteResponse: AWSDecodableShape {
        /// Information about the site.
        public let site: Site?

        @inlinable
        public init(site: Site? = nil) {
            self.site = site
        }

        private enum CodingKeys: String, CodingKey {
            case site = "Site"
        }
    }

    public struct CreateSiteToSiteVpnAttachmentRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of a core network where you're creating a site-to-site VPN attachment.
        public let coreNetworkId: String
        /// The tags associated with the request.
        public let tags: [Tag]?
        /// The ARN identifying the VPN attachment.
        public let vpnConnectionArn: String

        @inlinable
        public init(clientToken: String? = CreateSiteToSiteVpnAttachmentRequest.idempotencyToken(), coreNetworkId: String, tags: [Tag]? = nil, vpnConnectionArn: String) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.tags = tags
            self.vpnConnectionArn = vpnConnectionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.vpnConnectionArn, name: "vpnConnectionArn", parent: name, max: 500)
            try self.validate(self.vpnConnectionArn, name: "vpnConnectionArn", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:vpn-connection\\/vpn-[0-9a-f]{8,17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case coreNetworkId = "CoreNetworkId"
            case tags = "Tags"
            case vpnConnectionArn = "VpnConnectionArn"
        }
    }

    public struct CreateSiteToSiteVpnAttachmentResponse: AWSDecodableShape {
        /// Details about a site-to-site VPN attachment.
        public let siteToSiteVpnAttachment: SiteToSiteVpnAttachment?

        @inlinable
        public init(siteToSiteVpnAttachment: SiteToSiteVpnAttachment? = nil) {
            self.siteToSiteVpnAttachment = siteToSiteVpnAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case siteToSiteVpnAttachment = "SiteToSiteVpnAttachment"
        }
    }

    public struct CreateTransitGatewayPeeringRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The list of key-value tags associated with the request.
        public let tags: [Tag]?
        /// The ARN of the transit gateway for the peering request.
        public let transitGatewayArn: String

        @inlinable
        public init(clientToken: String? = CreateTransitGatewayPeeringRequest.idempotencyToken(), coreNetworkId: String, tags: [Tag]? = nil, transitGatewayArn: String) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.tags = tags
            self.transitGatewayArn = transitGatewayArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, max: 500)
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case coreNetworkId = "CoreNetworkId"
            case tags = "Tags"
            case transitGatewayArn = "TransitGatewayArn"
        }
    }

    public struct CreateTransitGatewayPeeringResponse: AWSDecodableShape {
        /// Returns information about the transit gateway peering connection request.
        public let transitGatewayPeering: TransitGatewayPeering?

        @inlinable
        public init(transitGatewayPeering: TransitGatewayPeering? = nil) {
            self.transitGatewayPeering = transitGatewayPeering
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayPeering = "TransitGatewayPeering"
        }
    }

    public struct CreateTransitGatewayRouteTableAttachmentRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of the peer for the
        public let peeringId: String
        /// The list of key-value tags associated with the request.
        public let tags: [Tag]?
        /// The ARN of the transit gateway route table for the attachment request. For example, "TransitGatewayRouteTableArn": "arn:aws:ec2:us-west-2:123456789012:transit-gateway-route-table/tgw-rtb-9876543210123456".
        public let transitGatewayRouteTableArn: String

        @inlinable
        public init(clientToken: String? = CreateTransitGatewayRouteTableAttachmentRequest.idempotencyToken(), peeringId: String, tags: [Tag]? = nil, transitGatewayRouteTableArn: String) {
            self.clientToken = clientToken
            self.peeringId = peeringId
            self.tags = tags
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.peeringId, name: "peeringId", parent: name, max: 50)
            try self.validate(self.peeringId, name: "peeringId", parent: name, pattern: "^peering-([0-9a-f]{8,17})$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.transitGatewayRouteTableArn, name: "transitGatewayRouteTableArn", parent: name, max: 500)
            try self.validate(self.transitGatewayRouteTableArn, name: "transitGatewayRouteTableArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case peeringId = "PeeringId"
            case tags = "Tags"
            case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
        }
    }

    public struct CreateTransitGatewayRouteTableAttachmentResponse: AWSDecodableShape {
        /// The route table associated with the create transit gateway route table attachment request.
        public let transitGatewayRouteTableAttachment: TransitGatewayRouteTableAttachment?

        @inlinable
        public init(transitGatewayRouteTableAttachment: TransitGatewayRouteTableAttachment? = nil) {
            self.transitGatewayRouteTableAttachment = transitGatewayRouteTableAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayRouteTableAttachment = "TransitGatewayRouteTableAttachment"
        }
    }

    public struct CreateVpcAttachmentRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of a core network for the VPC attachment.
        public let coreNetworkId: String
        /// Options for the VPC attachment.
        public let options: VpcOptions?
        /// The subnet ARN of the VPC attachment.
        public let subnetArns: [String]
        /// The key-value tags associated with the request.
        public let tags: [Tag]?
        /// The ARN of the VPC.
        public let vpcArn: String

        @inlinable
        public init(clientToken: String? = CreateVpcAttachmentRequest.idempotencyToken(), coreNetworkId: String, options: VpcOptions? = nil, subnetArns: [String], tags: [Tag]? = nil, vpcArn: String) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.options = options
            self.subnetArns = subnetArns
            self.tags = tags
            self.vpcArn = vpcArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.subnetArns.forEach {
                try validate($0, name: "subnetArns[]", parent: name, max: 500)
                try validate($0, name: "subnetArns[]", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:subnet\\/subnet-[0-9a-f]{8,17}$|^$")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.vpcArn, name: "vpcArn", parent: name, max: 500)
            try self.validate(self.vpcArn, name: "vpcArn", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:vpc\\/vpc-[0-9a-f]{8,17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case coreNetworkId = "CoreNetworkId"
            case options = "Options"
            case subnetArns = "SubnetArns"
            case tags = "Tags"
            case vpcArn = "VpcArn"
        }
    }

    public struct CreateVpcAttachmentResponse: AWSDecodableShape {
        /// Provides details about the VPC attachment.
        public let vpcAttachment: VpcAttachment?

        @inlinable
        public init(vpcAttachment: VpcAttachment? = nil) {
            self.vpcAttachment = vpcAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case vpcAttachment = "VpcAttachment"
        }
    }

    public struct CustomerGatewayAssociation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the customer gateway.
        public let customerGatewayArn: String?
        /// The ID of the device.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The ID of the link.
        public let linkId: String?
        /// The association state.
        public let state: CustomerGatewayAssociationState?

        @inlinable
        public init(customerGatewayArn: String? = nil, deviceId: String? = nil, globalNetworkId: String? = nil, linkId: String? = nil, state: CustomerGatewayAssociationState? = nil) {
            self.customerGatewayArn = customerGatewayArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case customerGatewayArn = "CustomerGatewayArn"
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case linkId = "LinkId"
            case state = "State"
        }
    }

    public struct DeleteAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment to delete.
        public let attachmentId: String

        @inlinable
        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAttachmentResponse: AWSDecodableShape {
        /// Information about the deleted attachment.
        public let attachment: Attachment?

        @inlinable
        public init(attachment: Attachment? = nil) {
            self.attachment = attachment
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
        }
    }

    public struct DeleteConnectPeerRequest: AWSEncodableShape {
        /// The ID of the deleted Connect peer.
        public let connectPeerId: String

        @inlinable
        public init(connectPeerId: String) {
            self.connectPeerId = connectPeerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectPeerId, key: "ConnectPeerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, max: 50)
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, pattern: "^connect-peer-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectPeerResponse: AWSDecodableShape {
        /// Information about the deleted Connect peer.
        public let connectPeer: ConnectPeer?

        @inlinable
        public init(connectPeer: ConnectPeer? = nil) {
            self.connectPeer = connectPeer
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeer = "ConnectPeer"
        }
    }

    public struct DeleteConnectionRequest: AWSEncodableShape {
        /// The ID of the connection.
        public let connectionId: String
        /// The ID of the global network.
        public let globalNetworkId: String

        @inlinable
        public init(connectionId: String, globalNetworkId: String) {
            self.connectionId = connectionId
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectionId, key: "ConnectionId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 50)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectionResponse: AWSDecodableShape {
        /// Information about the connection.
        public let connection: Connection?

        @inlinable
        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DeleteCoreNetworkPolicyVersionRequest: AWSEncodableShape {
        /// The ID of a core network for the deleted policy.
        public let coreNetworkId: String
        /// The version ID of the deleted policy.
        public let policyVersionId: Int

        @inlinable
        public init(coreNetworkId: String, policyVersionId: Int) {
            self.coreNetworkId = coreNetworkId
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodePath(self.policyVersionId, key: "PolicyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCoreNetworkPolicyVersionResponse: AWSDecodableShape {
        /// Returns information about the deleted policy version.
        public let coreNetworkPolicy: CoreNetworkPolicy?

        @inlinable
        public init(coreNetworkPolicy: CoreNetworkPolicy? = nil) {
            self.coreNetworkPolicy = coreNetworkPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkPolicy = "CoreNetworkPolicy"
        }
    }

    public struct DeleteCoreNetworkRequest: AWSEncodableShape {
        /// The network ID of the deleted core network.
        public let coreNetworkId: String

        @inlinable
        public init(coreNetworkId: String) {
            self.coreNetworkId = coreNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCoreNetworkResponse: AWSDecodableShape {
        /// Information about the deleted core network.
        public let coreNetwork: CoreNetwork?

        @inlinable
        public init(coreNetwork: CoreNetwork? = nil) {
            self.coreNetwork = coreNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetwork = "CoreNetwork"
        }
    }

    public struct DeleteDeviceRequest: AWSEncodableShape {
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String

        @inlinable
        public init(deviceId: String, globalNetworkId: String) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceId, key: "DeviceId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDeviceResponse: AWSDecodableShape {
        /// Information about the device.
        public let device: Device?

        @inlinable
        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "Device"
        }
    }

    public struct DeleteGlobalNetworkRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String

        @inlinable
        public init(globalNetworkId: String) {
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGlobalNetworkResponse: AWSDecodableShape {
        /// Information about the global network.
        public let globalNetwork: GlobalNetwork?

        @inlinable
        public init(globalNetwork: GlobalNetwork? = nil) {
            self.globalNetwork = globalNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case globalNetwork = "GlobalNetwork"
        }
    }

    public struct DeleteLinkRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String

        @inlinable
        public init(globalNetworkId: String, linkId: String) {
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.linkId, key: "LinkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLinkResponse: AWSDecodableShape {
        /// Information about the link.
        public let link: Link?

        @inlinable
        public init(link: Link? = nil) {
            self.link = link
        }

        private enum CodingKeys: String, CodingKey {
            case link = "Link"
        }
    }

    public struct DeletePeeringRequest: AWSEncodableShape {
        /// The ID of the peering connection to delete.
        public let peeringId: String

        @inlinable
        public init(peeringId: String) {
            self.peeringId = peeringId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.peeringId, key: "PeeringId")
        }

        public func validate(name: String) throws {
            try self.validate(self.peeringId, name: "peeringId", parent: name, max: 50)
            try self.validate(self.peeringId, name: "peeringId", parent: name, pattern: "^peering-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePeeringResponse: AWSDecodableShape {
        /// Information about a deleted peering connection.
        public let peering: Peering?

        @inlinable
        public init(peering: Peering? = nil) {
            self.peering = peering
        }

        private enum CodingKeys: String, CodingKey {
            case peering = "Peering"
        }
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The ARN of the policy to delete.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSiteRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the site.
        public let siteId: String

        @inlinable
        public init(globalNetworkId: String, siteId: String) {
            self.globalNetworkId = globalNetworkId
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.siteId, key: "SiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSiteResponse: AWSDecodableShape {
        /// Information about the site.
        public let site: Site?

        @inlinable
        public init(site: Site? = nil) {
            self.site = site
        }

        private enum CodingKeys: String, CodingKey {
            case site = "Site"
        }
    }

    public struct DeregisterTransitGatewayRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The Amazon Resource Name (ARN) of the transit gateway.
        public let transitGatewayArn: String

        @inlinable
        public init(globalNetworkId: String, transitGatewayArn: String) {
            self.globalNetworkId = globalNetworkId
            self.transitGatewayArn = transitGatewayArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.transitGatewayArn, key: "TransitGatewayArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, max: 500)
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeregisterTransitGatewayResponse: AWSDecodableShape {
        /// The transit gateway registration information.
        public let transitGatewayRegistration: TransitGatewayRegistration?

        @inlinable
        public init(transitGatewayRegistration: TransitGatewayRegistration? = nil) {
            self.transitGatewayRegistration = transitGatewayRegistration
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayRegistration = "TransitGatewayRegistration"
        }
    }

    public struct DescribeGlobalNetworksRequest: AWSEncodableShape {
        /// The IDs of one or more global networks. The maximum is 10.
        public let globalNetworkIds: [String]?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(globalNetworkIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.globalNetworkIds = globalNetworkIds
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.globalNetworkIds, key: "globalNetworkIds")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.globalNetworkIds?.forEach {
                try validate($0, name: "globalNetworkIds[]", parent: name, max: 50)
                try validate($0, name: "globalNetworkIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGlobalNetworksResponse: AWSDecodableShape {
        /// Information about the global networks.
        public let globalNetworks: [GlobalNetwork]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(globalNetworks: [GlobalNetwork]? = nil, nextToken: String? = nil) {
            self.globalNetworks = globalNetworks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case globalNetworks = "GlobalNetworks"
            case nextToken = "NextToken"
        }
    }

    public struct Device: AWSDecodableShape {
        /// The Amazon Web Services location of the device.
        public let awsLocation: AWSLocation?
        /// The date and time that the site was created.
        public let createdAt: Date?
        /// The description of the device.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the device.
        public let deviceArn: String?
        /// The ID of the device.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The site location.
        public let location: Location?
        /// The device model.
        public let model: String?
        /// The device serial number.
        public let serialNumber: String?
        /// The site ID.
        public let siteId: String?
        /// The device state.
        public let state: DeviceState?
        /// The tags for the device.
        public let tags: [Tag]?
        /// The device type.
        public let type: String?
        /// The device vendor.
        public let vendor: String?

        @inlinable
        public init(awsLocation: AWSLocation? = nil, createdAt: Date? = nil, description: String? = nil, deviceArn: String? = nil, deviceId: String? = nil, globalNetworkId: String? = nil, location: Location? = nil, model: String? = nil, serialNumber: String? = nil, siteId: String? = nil, state: DeviceState? = nil, tags: [Tag]? = nil, type: String? = nil, vendor: String? = nil) {
            self.awsLocation = awsLocation
            self.createdAt = createdAt
            self.description = description
            self.deviceArn = deviceArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.model = model
            self.serialNumber = serialNumber
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
            self.vendor = vendor
        }

        private enum CodingKeys: String, CodingKey {
            case awsLocation = "AWSLocation"
            case createdAt = "CreatedAt"
            case description = "Description"
            case deviceArn = "DeviceArn"
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case location = "Location"
            case model = "Model"
            case serialNumber = "SerialNumber"
            case siteId = "SiteId"
            case state = "State"
            case tags = "Tags"
            case type = "Type"
            case vendor = "Vendor"
        }
    }

    public struct DirectConnectGatewayAttachment: AWSDecodableShape {
        public let attachment: Attachment?
        /// The Direct Connect gateway attachment ARN.
        public let directConnectGatewayArn: String?

        @inlinable
        public init(attachment: Attachment? = nil, directConnectGatewayArn: String? = nil) {
            self.attachment = attachment
            self.directConnectGatewayArn = directConnectGatewayArn
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case directConnectGatewayArn = "DirectConnectGatewayArn"
        }
    }

    public struct DisassociateConnectPeerRequest: AWSEncodableShape {
        /// The ID of the Connect peer to disassociate from a device.
        public let connectPeerId: String
        /// The ID of the global network.
        public let globalNetworkId: String

        @inlinable
        public init(connectPeerId: String, globalNetworkId: String) {
            self.connectPeerId = connectPeerId
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectPeerId, key: "ConnectPeerId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, max: 50)
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, pattern: "^connect-peer-([0-9a-f]{8,17})$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateConnectPeerResponse: AWSDecodableShape {
        /// Describes the Connect peer association.
        public let connectPeerAssociation: ConnectPeerAssociation?

        @inlinable
        public init(connectPeerAssociation: ConnectPeerAssociation? = nil) {
            self.connectPeerAssociation = connectPeerAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeerAssociation = "ConnectPeerAssociation"
        }
    }

    public struct DisassociateCustomerGatewayRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the customer gateway.
        public let customerGatewayArn: String
        /// The ID of the global network.
        public let globalNetworkId: String

        @inlinable
        public init(customerGatewayArn: String, globalNetworkId: String) {
            self.customerGatewayArn = customerGatewayArn
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.customerGatewayArn, key: "CustomerGatewayArn")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.customerGatewayArn, name: "customerGatewayArn", parent: name, max: 500)
            try self.validate(self.customerGatewayArn, name: "customerGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateCustomerGatewayResponse: AWSDecodableShape {
        /// Information about the customer gateway association.
        public let customerGatewayAssociation: CustomerGatewayAssociation?

        @inlinable
        public init(customerGatewayAssociation: CustomerGatewayAssociation? = nil) {
            self.customerGatewayAssociation = customerGatewayAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case customerGatewayAssociation = "CustomerGatewayAssociation"
        }
    }

    public struct DisassociateLinkRequest: AWSEncodableShape {
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String

        @inlinable
        public init(deviceId: String, globalNetworkId: String, linkId: String) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deviceId, key: "deviceId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.linkId, key: "linkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateLinkResponse: AWSDecodableShape {
        /// Information about the link association.
        public let linkAssociation: LinkAssociation?

        @inlinable
        public init(linkAssociation: LinkAssociation? = nil) {
            self.linkAssociation = linkAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case linkAssociation = "LinkAssociation"
        }
    }

    public struct DisassociateTransitGatewayConnectPeerRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
        public let transitGatewayConnectPeerArn: String

        @inlinable
        public init(globalNetworkId: String, transitGatewayConnectPeerArn: String) {
            self.globalNetworkId = globalNetworkId
            self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.transitGatewayConnectPeerArn, key: "TransitGatewayConnectPeerArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.transitGatewayConnectPeerArn, name: "transitGatewayConnectPeerArn", parent: name, max: 500)
            try self.validate(self.transitGatewayConnectPeerArn, name: "transitGatewayConnectPeerArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateTransitGatewayConnectPeerResponse: AWSDecodableShape {
        /// The transit gateway Connect peer association.
        public let transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation?

        @inlinable
        public init(transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation? = nil) {
            self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
        }
    }

    public struct EdgeOverride: AWSDecodableShape {
        /// The list of edge locations.
        public let edgeSets: [[String]]?
        /// The edge that should be used when overriding the current edge order.
        public let useEdge: String?

        @inlinable
        public init(edgeSets: [[String]]? = nil, useEdge: String? = nil) {
            self.edgeSets = edgeSets
            self.useEdge = useEdge
        }

        private enum CodingKeys: String, CodingKey {
            case edgeSets = "EdgeSets"
            case useEdge = "UseEdge"
        }
    }

    public struct ExecuteCoreNetworkChangeSetRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The ID of the policy version.
        public let policyVersionId: Int

        @inlinable
        public init(coreNetworkId: String, policyVersionId: Int) {
            self.coreNetworkId = coreNetworkId
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodePath(self.policyVersionId, key: "PolicyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExecuteCoreNetworkChangeSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GetConnectAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let attachmentId: String

        @inlinable
        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectAttachmentResponse: AWSDecodableShape {
        /// Details about the Connect attachment.
        public let connectAttachment: ConnectAttachment?

        @inlinable
        public init(connectAttachment: ConnectAttachment? = nil) {
            self.connectAttachment = connectAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case connectAttachment = "ConnectAttachment"
        }
    }

    public struct GetConnectPeerAssociationsRequest: AWSEncodableShape {
        /// The IDs of the Connect peers.
        public let connectPeerIds: [String]?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(connectPeerIds: [String]? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectPeerIds = connectPeerIds
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectPeerIds, key: "connectPeerIds")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.connectPeerIds?.forEach {
                try validate($0, name: "connectPeerIds[]", parent: name, max: 50)
                try validate($0, name: "connectPeerIds[]", parent: name, pattern: "^connect-peer-([0-9a-f]{8,17})$")
            }
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectPeerAssociationsResponse: AWSDecodableShape {
        /// Displays a list of Connect peer associations.
        public let connectPeerAssociations: [ConnectPeerAssociation]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(connectPeerAssociations: [ConnectPeerAssociation]? = nil, nextToken: String? = nil) {
            self.connectPeerAssociations = connectPeerAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeerAssociations = "ConnectPeerAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct GetConnectPeerRequest: AWSEncodableShape {
        /// The ID of the Connect peer.
        public let connectPeerId: String

        @inlinable
        public init(connectPeerId: String) {
            self.connectPeerId = connectPeerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectPeerId, key: "ConnectPeerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, max: 50)
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, pattern: "^connect-peer-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectPeerResponse: AWSDecodableShape {
        /// Returns information about a core network Connect peer.
        public let connectPeer: ConnectPeer?

        @inlinable
        public init(connectPeer: ConnectPeer? = nil) {
            self.connectPeer = connectPeer
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeer = "ConnectPeer"
        }
    }

    public struct GetConnectionsRequest: AWSEncodableShape {
        /// One or more connection IDs.
        public let connectionIds: [String]?
        /// The ID of the device.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(connectionIds: [String]? = nil, deviceId: String? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectionIds = connectionIds
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectionIds, key: "connectionIds")
            request.encodeQuery(self.deviceId, key: "deviceId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.connectionIds?.forEach {
                try validate($0, name: "connectionIds[]", parent: name, max: 50)
                try validate($0, name: "connectionIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectionsResponse: AWSDecodableShape {
        /// Information about the connections.
        public let connections: [Connection]?
        /// The token to use for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(connections: [Connection]? = nil, nextToken: String? = nil) {
            self.connections = connections
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case nextToken = "NextToken"
        }
    }

    public struct GetCoreNetworkChangeEventsRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ID of the policy version.
        public let policyVersionId: Int

        @inlinable
        public init(coreNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, policyVersionId: Int) {
            self.coreNetworkId = coreNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.policyVersionId, key: "PolicyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCoreNetworkChangeEventsResponse: AWSDecodableShape {
        /// The response to GetCoreNetworkChangeEventsRequest.
        public let coreNetworkChangeEvents: [CoreNetworkChangeEvent]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(coreNetworkChangeEvents: [CoreNetworkChangeEvent]? = nil, nextToken: String? = nil) {
            self.coreNetworkChangeEvents = coreNetworkChangeEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkChangeEvents = "CoreNetworkChangeEvents"
            case nextToken = "NextToken"
        }
    }

    public struct GetCoreNetworkChangeSetRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ID of the policy version.
        public let policyVersionId: Int

        @inlinable
        public init(coreNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, policyVersionId: Int) {
            self.coreNetworkId = coreNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.policyVersionId, key: "PolicyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCoreNetworkChangeSetResponse: AWSDecodableShape {
        /// Describes a core network changes.
        public let coreNetworkChanges: [CoreNetworkChange]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(coreNetworkChanges: [CoreNetworkChange]? = nil, nextToken: String? = nil) {
            self.coreNetworkChanges = coreNetworkChanges
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkChanges = "CoreNetworkChanges"
            case nextToken = "NextToken"
        }
    }

    public struct GetCoreNetworkPolicyRequest: AWSEncodableShape {
        /// The alias of a core network policy
        public let alias: CoreNetworkPolicyAlias?
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The ID of a core network policy version.
        public let policyVersionId: Int?

        @inlinable
        public init(alias: CoreNetworkPolicyAlias? = nil, coreNetworkId: String, policyVersionId: Int? = nil) {
            self.alias = alias
            self.coreNetworkId = coreNetworkId
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodeQuery(self.policyVersionId, key: "policyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCoreNetworkPolicyResponse: AWSDecodableShape {
        /// The details about a core network policy.
        public let coreNetworkPolicy: CoreNetworkPolicy?

        @inlinable
        public init(coreNetworkPolicy: CoreNetworkPolicy? = nil) {
            self.coreNetworkPolicy = coreNetworkPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkPolicy = "CoreNetworkPolicy"
        }
    }

    public struct GetCoreNetworkRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String

        @inlinable
        public init(coreNetworkId: String) {
            self.coreNetworkId = coreNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCoreNetworkResponse: AWSDecodableShape {
        /// Details about a core network.
        public let coreNetwork: CoreNetwork?

        @inlinable
        public init(coreNetwork: CoreNetwork? = nil) {
            self.coreNetwork = coreNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetwork = "CoreNetwork"
        }
    }

    public struct GetCustomerGatewayAssociationsRequest: AWSEncodableShape {
        /// One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.
        public let customerGatewayArns: [String]?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(customerGatewayArns: [String]? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.customerGatewayArns = customerGatewayArns
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.customerGatewayArns, key: "customerGatewayArns")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.customerGatewayArns?.forEach {
                try validate($0, name: "customerGatewayArns[]", parent: name, max: 500)
                try validate($0, name: "customerGatewayArns[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCustomerGatewayAssociationsResponse: AWSDecodableShape {
        /// The customer gateway associations.
        public let customerGatewayAssociations: [CustomerGatewayAssociation]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(customerGatewayAssociations: [CustomerGatewayAssociation]? = nil, nextToken: String? = nil) {
            self.customerGatewayAssociations = customerGatewayAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case customerGatewayAssociations = "CustomerGatewayAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct GetDevicesRequest: AWSEncodableShape {
        /// One or more device IDs. The maximum is 10.
        public let deviceIds: [String]?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ID of the site.
        public let siteId: String?

        @inlinable
        public init(deviceIds: [String]? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, siteId: String? = nil) {
            self.deviceIds = deviceIds
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deviceIds, key: "deviceIds")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.siteId, key: "siteId")
        }

        public func validate(name: String) throws {
            try self.deviceIds?.forEach {
                try validate($0, name: "deviceIds[]", parent: name, max: 50)
                try validate($0, name: "deviceIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDevicesResponse: AWSDecodableShape {
        /// The devices.
        public let devices: [Device]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(devices: [Device]? = nil, nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "Devices"
            case nextToken = "NextToken"
        }
    }

    public struct GetDirectConnectGatewayAttachmentRequest: AWSEncodableShape {
        /// The ID of the Direct Connect gateway attachment that you want to see details about.
        public let attachmentId: String

        @inlinable
        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDirectConnectGatewayAttachmentResponse: AWSDecodableShape {
        /// Shows details about the Direct Connect gateway attachment.
        public let directConnectGatewayAttachment: DirectConnectGatewayAttachment?

        @inlinable
        public init(directConnectGatewayAttachment: DirectConnectGatewayAttachment? = nil) {
            self.directConnectGatewayAttachment = directConnectGatewayAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayAttachment = "DirectConnectGatewayAttachment"
        }
    }

    public struct GetLinkAssociationsRequest: AWSEncodableShape {
        /// The ID of the device.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(deviceId: String? = nil, globalNetworkId: String, linkId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deviceId, key: "deviceId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.linkId, key: "linkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLinkAssociationsResponse: AWSDecodableShape {
        /// The link associations.
        public let linkAssociations: [LinkAssociation]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(linkAssociations: [LinkAssociation]? = nil, nextToken: String? = nil) {
            self.linkAssociations = linkAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case linkAssociations = "LinkAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct GetLinksRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// One or more link IDs. The maximum is 10.
        public let linkIds: [String]?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The link provider.
        public let provider: String?
        /// The ID of the site.
        public let siteId: String?
        /// The link type.
        public let type: String?

        @inlinable
        public init(globalNetworkId: String, linkIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, provider: String? = nil, siteId: String? = nil, type: String? = nil) {
            self.globalNetworkId = globalNetworkId
            self.linkIds = linkIds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.provider = provider
            self.siteId = siteId
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.linkIds, key: "linkIds")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.provider, key: "provider")
            request.encodeQuery(self.siteId, key: "siteId")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.linkIds?.forEach {
                try validate($0, name: "linkIds[]", parent: name, max: 50)
                try validate($0, name: "linkIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.provider, name: "provider", parent: name, max: 256)
            try self.validate(self.provider, name: "provider", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLinksResponse: AWSDecodableShape {
        /// The links.
        public let links: [Link]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(links: [Link]? = nil, nextToken: String? = nil) {
            self.links = links
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case links = "Links"
            case nextToken = "NextToken"
        }
    }

    public struct GetNetworkResourceCountsRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The resource type. The following are the supported resource types for Direct Connect:    dxcon     dx-gateway     dx-vif    The following are the supported resource types for Network Manager:    attachment     connect-peer     connection     core-network     device     link     peering     site    The following are the supported resource types for Amazon VPC:    customer-gateway     transit-gateway     transit-gateway-attachment     transit-gateway-connect-peer     transit-gateway-route-table     vpn-connection
        public let resourceType: String?

        @inlinable
        public init(globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, resourceType: String? = nil) {
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkResourceCountsResponse: AWSDecodableShape {
        /// The count of resources.
        public let networkResourceCounts: [NetworkResourceCount]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(networkResourceCounts: [NetworkResourceCount]? = nil, nextToken: String? = nil) {
            self.networkResourceCounts = networkResourceCounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkResourceCounts = "NetworkResourceCounts"
            case nextToken = "NextToken"
        }
    }

    public struct GetNetworkResourceRelationshipsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The Amazon Web Services Region.
        public let awsRegion: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ARN of the registered gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the gateway.
        public let resourceArn: String?
        /// The resource type. The following are the supported resource types for Direct Connect:    dxcon     dx-gateway     dx-vif    The following are the supported resource types for Network Manager:    attachment     connect-peer     connection     core-network     device     link     peering     site    The following are the supported resource types for Amazon VPC:    customer-gateway     transit-gateway     transit-gateway-attachment     transit-gateway-connect-peer     transit-gateway-route-table     vpn-connection
        public let resourceType: String?

        @inlinable
        public init(accountId: String? = nil, awsRegion: String? = nil, coreNetworkId: String? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "accountId")
            request.encodeQuery(self.awsRegion, key: "awsRegion")
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.registeredGatewayArn, key: "registeredGatewayArn")
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 63)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, max: 1500)
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkResourceRelationshipsResponse: AWSDecodableShape {
        /// The token for the next page of results.
        public let nextToken: String?
        /// The resource relationships.
        public let relationships: [Relationship]?

        @inlinable
        public init(nextToken: String? = nil, relationships: [Relationship]? = nil) {
            self.nextToken = nextToken
            self.relationships = relationships
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case relationships = "Relationships"
        }
    }

    public struct GetNetworkResourcesRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The Amazon Web Services Region.
        public let awsRegion: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ARN of the gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the resource.
        public let resourceArn: String?
        /// The resource type. The following are the supported resource types for Direct Connect:    dxcon     dx-gateway     dx-vif    The following are the supported resource types for Network Manager:    attachment     connect-peer     connection     core-network     device     link     peering     site    The following are the supported resource types for Amazon VPC:    customer-gateway     transit-gateway     transit-gateway-attachment     transit-gateway-connect-peer     transit-gateway-route-table     vpn-connection
        public let resourceType: String?

        @inlinable
        public init(accountId: String? = nil, awsRegion: String? = nil, coreNetworkId: String? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "accountId")
            request.encodeQuery(self.awsRegion, key: "awsRegion")
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.registeredGatewayArn, key: "registeredGatewayArn")
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 63)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, max: 1500)
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkResourcesResponse: AWSDecodableShape {
        /// The network resources.
        public let networkResources: [NetworkResource]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(networkResources: [NetworkResource]? = nil, nextToken: String? = nil) {
            self.networkResources = networkResources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkResources = "NetworkResources"
            case nextToken = "NextToken"
        }
    }

    public struct GetNetworkRoutesRequest: AWSEncodableShape {
        /// Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.
        public let destinationFilters: [String: [String]]?
        /// An exact CIDR block.
        public let exactCidrMatches: [String]?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The most specific route that matches the traffic (longest prefix match).
        public let longestPrefixMatches: [String]?
        /// The IDs of the prefix lists.
        public let prefixListIds: [String]?
        /// The ID of the route table.
        public let routeTableIdentifier: RouteTableIdentifier
        /// The route states.
        public let states: [RouteState]?
        /// The routes with a subnet that match the specified CIDR filter.
        public let subnetOfMatches: [String]?
        /// The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.
        public let supernetOfMatches: [String]?
        /// The route types.
        public let types: [RouteType]?

        @inlinable
        public init(destinationFilters: [String: [String]]? = nil, exactCidrMatches: [String]? = nil, globalNetworkId: String, longestPrefixMatches: [String]? = nil, prefixListIds: [String]? = nil, routeTableIdentifier: RouteTableIdentifier, states: [RouteState]? = nil, subnetOfMatches: [String]? = nil, supernetOfMatches: [String]? = nil, types: [RouteType]? = nil) {
            self.destinationFilters = destinationFilters
            self.exactCidrMatches = exactCidrMatches
            self.globalNetworkId = globalNetworkId
            self.longestPrefixMatches = longestPrefixMatches
            self.prefixListIds = prefixListIds
            self.routeTableIdentifier = routeTableIdentifier
            self.states = states
            self.subnetOfMatches = subnetOfMatches
            self.supernetOfMatches = supernetOfMatches
            self.types = types
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.destinationFilters, forKey: .destinationFilters)
            try container.encodeIfPresent(self.exactCidrMatches, forKey: .exactCidrMatches)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.longestPrefixMatches, forKey: .longestPrefixMatches)
            try container.encodeIfPresent(self.prefixListIds, forKey: .prefixListIds)
            try container.encode(self.routeTableIdentifier, forKey: .routeTableIdentifier)
            try container.encodeIfPresent(self.states, forKey: .states)
            try container.encodeIfPresent(self.subnetOfMatches, forKey: .subnetOfMatches)
            try container.encodeIfPresent(self.supernetOfMatches, forKey: .supernetOfMatches)
            try container.encodeIfPresent(self.types, forKey: .types)
        }

        public func validate(name: String) throws {
            try self.destinationFilters?.forEach {
                try validate($0.key, name: "destinationFilters.key", parent: name, max: 128)
                try validate($0.key, name: "destinationFilters.key", parent: name, pattern: "^[0-9a-zA-Z\\.-]*$")
            }
            try self.exactCidrMatches?.forEach {
                try validate($0, name: "exactCidrMatches[]", parent: name, max: 256)
                try validate($0, name: "exactCidrMatches[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.longestPrefixMatches?.forEach {
                try validate($0, name: "longestPrefixMatches[]", parent: name, max: 256)
                try validate($0, name: "longestPrefixMatches[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.prefixListIds?.forEach {
                try validate($0, name: "prefixListIds[]", parent: name, max: 256)
                try validate($0, name: "prefixListIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.routeTableIdentifier.validate(name: "\(name).routeTableIdentifier")
            try self.subnetOfMatches?.forEach {
                try validate($0, name: "subnetOfMatches[]", parent: name, max: 256)
                try validate($0, name: "subnetOfMatches[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.supernetOfMatches?.forEach {
                try validate($0, name: "supernetOfMatches[]", parent: name, max: 256)
                try validate($0, name: "supernetOfMatches[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case destinationFilters = "DestinationFilters"
            case exactCidrMatches = "ExactCidrMatches"
            case longestPrefixMatches = "LongestPrefixMatches"
            case prefixListIds = "PrefixListIds"
            case routeTableIdentifier = "RouteTableIdentifier"
            case states = "States"
            case subnetOfMatches = "SubnetOfMatches"
            case supernetOfMatches = "SupernetOfMatches"
            case types = "Types"
        }
    }

    public struct GetNetworkRoutesResponse: AWSDecodableShape {
        /// Describes a core network segment edge.
        public let coreNetworkSegmentEdge: CoreNetworkSegmentEdgeIdentifier?
        /// The network routes.
        public let networkRoutes: [NetworkRoute]?
        /// The ARN of the route table.
        public let routeTableArn: String?
        /// The route table creation time.
        public let routeTableTimestamp: Date?
        /// The route table type.
        public let routeTableType: RouteTableType?

        @inlinable
        public init(coreNetworkSegmentEdge: CoreNetworkSegmentEdgeIdentifier? = nil, networkRoutes: [NetworkRoute]? = nil, routeTableArn: String? = nil, routeTableTimestamp: Date? = nil, routeTableType: RouteTableType? = nil) {
            self.coreNetworkSegmentEdge = coreNetworkSegmentEdge
            self.networkRoutes = networkRoutes
            self.routeTableArn = routeTableArn
            self.routeTableTimestamp = routeTableTimestamp
            self.routeTableType = routeTableType
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkSegmentEdge = "CoreNetworkSegmentEdge"
            case networkRoutes = "NetworkRoutes"
            case routeTableArn = "RouteTableArn"
            case routeTableTimestamp = "RouteTableTimestamp"
            case routeTableType = "RouteTableType"
        }
    }

    public struct GetNetworkTelemetryRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The Amazon Web Services Region.
        public let awsRegion: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ARN of the gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the resource.
        public let resourceArn: String?
        /// The resource type. The following are the supported resource types:    connect-peer     transit-gateway-connect-peer     vpn-connection
        public let resourceType: String?

        @inlinable
        public init(accountId: String? = nil, awsRegion: String? = nil, coreNetworkId: String? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "accountId")
            request.encodeQuery(self.awsRegion, key: "awsRegion")
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.registeredGatewayArn, key: "registeredGatewayArn")
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 63)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, max: 1500)
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkTelemetryResponse: AWSDecodableShape {
        /// The network telemetry.
        public let networkTelemetry: [NetworkTelemetry]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(networkTelemetry: [NetworkTelemetry]? = nil, nextToken: String? = nil) {
            self.networkTelemetry = networkTelemetry
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkTelemetry = "NetworkTelemetry"
            case nextToken = "NextToken"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// The resource policy document.
        public let policyDocument: String?

        @inlinable
        public init(policyDocument: String? = nil) {
            self.policyDocument = policyDocument
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "PolicyDocument"
        }
    }

    public struct GetRouteAnalysisRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the route analysis.
        public let routeAnalysisId: String

        @inlinable
        public init(globalNetworkId: String, routeAnalysisId: String) {
            self.globalNetworkId = globalNetworkId
            self.routeAnalysisId = routeAnalysisId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.routeAnalysisId, key: "RouteAnalysisId")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.routeAnalysisId, name: "routeAnalysisId", parent: name, max: 256)
            try self.validate(self.routeAnalysisId, name: "routeAnalysisId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRouteAnalysisResponse: AWSDecodableShape {
        /// The route analysis.
        public let routeAnalysis: RouteAnalysis?

        @inlinable
        public init(routeAnalysis: RouteAnalysis? = nil) {
            self.routeAnalysis = routeAnalysis
        }

        private enum CodingKeys: String, CodingKey {
            case routeAnalysis = "RouteAnalysis"
        }
    }

    public struct GetSiteToSiteVpnAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let attachmentId: String

        @inlinable
        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSiteToSiteVpnAttachmentResponse: AWSDecodableShape {
        /// Describes the site-to-site attachment.
        public let siteToSiteVpnAttachment: SiteToSiteVpnAttachment?

        @inlinable
        public init(siteToSiteVpnAttachment: SiteToSiteVpnAttachment? = nil) {
            self.siteToSiteVpnAttachment = siteToSiteVpnAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case siteToSiteVpnAttachment = "SiteToSiteVpnAttachment"
        }
    }

    public struct GetSitesRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// One or more site IDs. The maximum is 10.
        public let siteIds: [String]?

        @inlinable
        public init(globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, siteIds: [String]? = nil) {
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.siteIds = siteIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.siteIds, key: "siteIds")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.siteIds?.forEach {
                try validate($0, name: "siteIds[]", parent: name, max: 50)
                try validate($0, name: "siteIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSitesResponse: AWSDecodableShape {
        /// The token for the next page of results.
        public let nextToken: String?
        /// The sites.
        public let sites: [Site]?

        @inlinable
        public init(nextToken: String? = nil, sites: [Site]? = nil) {
            self.nextToken = nextToken
            self.sites = sites
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sites = "Sites"
        }
    }

    public struct GetTransitGatewayConnectPeerAssociationsRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// One or more transit gateway Connect peer Amazon Resource Names (ARNs).
        public let transitGatewayConnectPeerArns: [String]?

        @inlinable
        public init(globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, transitGatewayConnectPeerArns: [String]? = nil) {
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.transitGatewayConnectPeerArns = transitGatewayConnectPeerArns
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.transitGatewayConnectPeerArns, key: "transitGatewayConnectPeerArns")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.transitGatewayConnectPeerArns?.forEach {
                try validate($0, name: "transitGatewayConnectPeerArns[]", parent: name, max: 500)
                try validate($0, name: "transitGatewayConnectPeerArns[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransitGatewayConnectPeerAssociationsResponse: AWSDecodableShape {
        /// The token to use for the next page of results.
        public let nextToken: String?
        /// Information about the transit gateway Connect peer associations.
        public let transitGatewayConnectPeerAssociations: [TransitGatewayConnectPeerAssociation]?

        @inlinable
        public init(nextToken: String? = nil, transitGatewayConnectPeerAssociations: [TransitGatewayConnectPeerAssociation]? = nil) {
            self.nextToken = nextToken
            self.transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case transitGatewayConnectPeerAssociations = "TransitGatewayConnectPeerAssociations"
        }
    }

    public struct GetTransitGatewayPeeringRequest: AWSEncodableShape {
        /// The ID of the peering request.
        public let peeringId: String

        @inlinable
        public init(peeringId: String) {
            self.peeringId = peeringId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.peeringId, key: "PeeringId")
        }

        public func validate(name: String) throws {
            try self.validate(self.peeringId, name: "peeringId", parent: name, max: 50)
            try self.validate(self.peeringId, name: "peeringId", parent: name, pattern: "^peering-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransitGatewayPeeringResponse: AWSDecodableShape {
        /// Returns information about a transit gateway peering.
        public let transitGatewayPeering: TransitGatewayPeering?

        @inlinable
        public init(transitGatewayPeering: TransitGatewayPeering? = nil) {
            self.transitGatewayPeering = transitGatewayPeering
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayPeering = "TransitGatewayPeering"
        }
    }

    public struct GetTransitGatewayRegistrationsRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.
        public let transitGatewayArns: [String]?

        @inlinable
        public init(globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, transitGatewayArns: [String]? = nil) {
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.transitGatewayArns = transitGatewayArns
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.transitGatewayArns, key: "transitGatewayArns")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.transitGatewayArns?.forEach {
                try validate($0, name: "transitGatewayArns[]", parent: name, max: 500)
                try validate($0, name: "transitGatewayArns[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransitGatewayRegistrationsResponse: AWSDecodableShape {
        /// The token for the next page of results.
        public let nextToken: String?
        /// The transit gateway registrations.
        public let transitGatewayRegistrations: [TransitGatewayRegistration]?

        @inlinable
        public init(nextToken: String? = nil, transitGatewayRegistrations: [TransitGatewayRegistration]? = nil) {
            self.nextToken = nextToken
            self.transitGatewayRegistrations = transitGatewayRegistrations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case transitGatewayRegistrations = "TransitGatewayRegistrations"
        }
    }

    public struct GetTransitGatewayRouteTableAttachmentRequest: AWSEncodableShape {
        /// The ID of the transit gateway route table attachment.
        public let attachmentId: String

        @inlinable
        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransitGatewayRouteTableAttachmentResponse: AWSDecodableShape {
        /// Returns information about the transit gateway route table attachment.
        public let transitGatewayRouteTableAttachment: TransitGatewayRouteTableAttachment?

        @inlinable
        public init(transitGatewayRouteTableAttachment: TransitGatewayRouteTableAttachment? = nil) {
            self.transitGatewayRouteTableAttachment = transitGatewayRouteTableAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayRouteTableAttachment = "TransitGatewayRouteTableAttachment"
        }
    }

    public struct GetVpcAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let attachmentId: String

        @inlinable
        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVpcAttachmentResponse: AWSDecodableShape {
        /// Returns details about a VPC attachment.
        public let vpcAttachment: VpcAttachment?

        @inlinable
        public init(vpcAttachment: VpcAttachment? = nil) {
            self.vpcAttachment = vpcAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case vpcAttachment = "VpcAttachment"
        }
    }

    public struct GlobalNetwork: AWSDecodableShape {
        /// The date and time that the global network was created.
        public let createdAt: Date?
        /// The description of the global network.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the global network.
        public let globalNetworkArn: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The state of the global network.
        public let state: GlobalNetworkState?
        /// The tags for the global network.
        public let tags: [Tag]?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, globalNetworkArn: String? = nil, globalNetworkId: String? = nil, state: GlobalNetworkState? = nil, tags: [Tag]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkArn = globalNetworkArn
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case globalNetworkArn = "GlobalNetworkArn"
            case globalNetworkId = "GlobalNetworkId"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// Indicates when to retry the request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct Link: AWSDecodableShape {
        /// The bandwidth for the link.
        public let bandwidth: Bandwidth?
        /// The date and time that the link was created.
        public let createdAt: Date?
        /// The description of the link.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The Amazon Resource Name (ARN) of the link.
        public let linkArn: String?
        /// The ID of the link.
        public let linkId: String?
        /// The provider of the link.
        public let provider: String?
        /// The ID of the site.
        public let siteId: String?
        /// The state of the link.
        public let state: LinkState?
        /// The tags for the link.
        public let tags: [Tag]?
        /// The type of the link.
        public let type: String?

        @inlinable
        public init(bandwidth: Bandwidth? = nil, createdAt: Date? = nil, description: String? = nil, globalNetworkId: String? = nil, linkArn: String? = nil, linkId: String? = nil, provider: String? = nil, siteId: String? = nil, state: LinkState? = nil, tags: [Tag]? = nil, type: String? = nil) {
            self.bandwidth = bandwidth
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.linkArn = linkArn
            self.linkId = linkId
            self.provider = provider
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth = "Bandwidth"
            case createdAt = "CreatedAt"
            case description = "Description"
            case globalNetworkId = "GlobalNetworkId"
            case linkArn = "LinkArn"
            case linkId = "LinkId"
            case provider = "Provider"
            case siteId = "SiteId"
            case state = "State"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct LinkAssociation: AWSDecodableShape {
        /// The device ID for the link association.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The state of the association.
        public let linkAssociationState: LinkAssociationState?
        /// The ID of the link.
        public let linkId: String?

        @inlinable
        public init(deviceId: String? = nil, globalNetworkId: String? = nil, linkAssociationState: LinkAssociationState? = nil, linkId: String? = nil) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkAssociationState = linkAssociationState
            self.linkId = linkId
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case linkAssociationState = "LinkAssociationState"
            case linkId = "LinkId"
        }
    }

    public struct ListAttachmentsRequest: AWSEncodableShape {
        /// The type of attachment.
        public let attachmentType: AttachmentType?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The Region where the edge is located.
        public let edgeLocation: String?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The state of the attachment.
        public let state: AttachmentState?

        @inlinable
        public init(attachmentType: AttachmentType? = nil, coreNetworkId: String? = nil, edgeLocation: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, state: AttachmentState? = nil) {
            self.attachmentType = attachmentType
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.attachmentType, key: "attachmentType")
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodeQuery(self.edgeLocation, key: "edgeLocation")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.state, key: "state")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, max: 63)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, min: 1)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAttachmentsResponse: AWSDecodableShape {
        /// Describes the list of attachments.
        public let attachments: [Attachment]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(attachments: [Attachment]? = nil, nextToken: String? = nil) {
            self.attachments = attachments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "Attachments"
            case nextToken = "NextToken"
        }
    }

    public struct ListConnectPeersRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let connectAttachmentId: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(connectAttachmentId: String? = nil, coreNetworkId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectAttachmentId = connectAttachmentId
            self.coreNetworkId = coreNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectAttachmentId, key: "connectAttachmentId")
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectAttachmentId, name: "connectAttachmentId", parent: name, max: 50)
            try self.validate(self.connectAttachmentId, name: "connectAttachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConnectPeersResponse: AWSDecodableShape {
        /// Describes the Connect peers.
        public let connectPeers: [ConnectPeerSummary]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(connectPeers: [ConnectPeerSummary]? = nil, nextToken: String? = nil) {
            self.connectPeers = connectPeers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeers = "ConnectPeers"
            case nextToken = "NextToken"
        }
    }

    public struct ListCoreNetworkPolicyVersionsRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(coreNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.coreNetworkId = coreNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCoreNetworkPolicyVersionsResponse: AWSDecodableShape {
        /// Describes core network policy versions.
        public let coreNetworkPolicyVersions: [CoreNetworkPolicyVersion]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(coreNetworkPolicyVersions: [CoreNetworkPolicyVersion]? = nil, nextToken: String? = nil) {
            self.coreNetworkPolicyVersions = coreNetworkPolicyVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkPolicyVersions = "CoreNetworkPolicyVersions"
            case nextToken = "NextToken"
        }
    }

    public struct ListCoreNetworksRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCoreNetworksResponse: AWSDecodableShape {
        /// Describes the list of core networks.
        public let coreNetworks: [CoreNetworkSummary]?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(coreNetworks: [CoreNetworkSummary]? = nil, nextToken: String? = nil) {
            self.coreNetworks = coreNetworks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworks = "CoreNetworks"
            case nextToken = "NextToken"
        }
    }

    public struct ListOrganizationServiceAccessStatusRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOrganizationServiceAccessStatusResponse: AWSDecodableShape {
        /// The token for the next page of results.
        public let nextToken: String?
        /// Displays the status of an Amazon Web Services Organization.
        public let organizationStatus: OrganizationStatus?

        @inlinable
        public init(nextToken: String? = nil, organizationStatus: OrganizationStatus? = nil) {
            self.nextToken = nextToken
            self.organizationStatus = organizationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationStatus = "OrganizationStatus"
        }
    }

    public struct ListPeeringsRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// Returns a list edge locations for the
        public let edgeLocation: String?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// Returns a list of a peering requests.
        public let peeringType: PeeringType?
        /// Returns a list of the peering request states.
        public let state: PeeringState?

        @inlinable
        public init(coreNetworkId: String? = nil, edgeLocation: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, peeringType: PeeringType? = nil, state: PeeringState? = nil) {
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.peeringType = peeringType
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodeQuery(self.edgeLocation, key: "edgeLocation")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.peeringType, key: "peeringType")
            request.encodeQuery(self.state, key: "state")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, max: 63)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, min: 1)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPeeringsResponse: AWSDecodableShape {
        /// The token for the next page of results.
        public let nextToken: String?
        /// Lists the transit gateway peerings for the ListPeerings request.
        public let peerings: [Peering]?

        @inlinable
        public init(nextToken: String? = nil, peerings: [Peering]? = nil) {
            self.nextToken = nextToken
            self.peerings = peerings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case peerings = "Peerings"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of tags.
        public let tagList: [Tag]?

        @inlinable
        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct Location: AWSEncodableShape & AWSDecodableShape {
        /// The physical address.
        public let address: String?
        /// The latitude.
        public let latitude: String?
        /// The longitude.
        public let longitude: String?

        @inlinable
        public init(address: String? = nil, latitude: String? = nil, longitude: String? = nil) {
            self.address = address
            self.latitude = latitude
            self.longitude = longitude
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, max: 256)
            try self.validate(self.address, name: "address", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.latitude, name: "latitude", parent: name, max: 256)
            try self.validate(self.latitude, name: "latitude", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.longitude, name: "longitude", parent: name, max: 256)
            try self.validate(self.longitude, name: "longitude", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case latitude = "Latitude"
            case longitude = "Longitude"
        }
    }

    public struct NetworkFunctionGroup: AWSDecodableShape {
        /// The name of the network function group.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct NetworkResource: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The Amazon Web Services Region.
        public let awsRegion: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.
        public let definition: String?
        /// The time that the resource definition was retrieved.
        public let definitionTimestamp: Date?
        /// The resource metadata.
        public let metadata: [String: String]?
        /// The ARN of the gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the resource.
        public let resourceArn: String?
        /// The ID of the resource.
        public let resourceId: String?
        /// The resource type. The following are the supported resource types for Direct Connect:    dxcon     dx-gateway     dx-vif    The following are the supported resource types for Network Manager:    attachment     connect-peer     connection     core-network     device     link     peering     site    The following are the supported resource types for Amazon VPC:    customer-gateway     transit-gateway     transit-gateway-attachment     transit-gateway-connect-peer     transit-gateway-route-table     vpn-connection
        public let resourceType: String?
        /// The tags.
        public let tags: [Tag]?

        @inlinable
        public init(accountId: String? = nil, awsRegion: String? = nil, coreNetworkId: String? = nil, definition: String? = nil, definitionTimestamp: Date? = nil, metadata: [String: String]? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, resourceType: String? = nil, tags: [Tag]? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.definition = definition
            self.definitionTimestamp = definitionTimestamp
            self.metadata = metadata
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case coreNetworkId = "CoreNetworkId"
            case definition = "Definition"
            case definitionTimestamp = "DefinitionTimestamp"
            case metadata = "Metadata"
            case registeredGatewayArn = "RegisteredGatewayArn"
            case resourceArn = "ResourceArn"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
            case tags = "Tags"
        }
    }

    public struct NetworkResourceCount: AWSDecodableShape {
        /// The resource count.
        public let count: Int?
        /// The resource type.
        public let resourceType: String?

        @inlinable
        public init(count: Int? = nil, resourceType: String? = nil) {
            self.count = count
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case resourceType = "ResourceType"
        }
    }

    public struct NetworkResourceSummary: AWSDecodableShape {
        /// Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.
        public let definition: String?
        /// Indicates whether this is a middlebox appliance.
        public let isMiddlebox: Bool?
        /// The value for the Name tag.
        public let nameTag: String?
        /// The ARN of the gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the resource.
        public let resourceArn: String?
        /// The resource type.
        public let resourceType: String?

        @inlinable
        public init(definition: String? = nil, isMiddlebox: Bool? = nil, nameTag: String? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.definition = definition
            self.isMiddlebox = isMiddlebox
            self.nameTag = nameTag
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case isMiddlebox = "IsMiddlebox"
            case nameTag = "NameTag"
            case registeredGatewayArn = "RegisteredGatewayArn"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
        }
    }

    public struct NetworkRoute: AWSDecodableShape {
        /// A unique identifier for the route, such as a CIDR block.
        public let destinationCidrBlock: String?
        /// The destinations.
        public let destinations: [NetworkRouteDestination]?
        /// The ID of the prefix list.
        public let prefixListId: String?
        /// The route state. The possible values are active and blackhole.
        public let state: RouteState?
        /// The route type. The possible values are propagated and static.
        public let type: RouteType?

        @inlinable
        public init(destinationCidrBlock: String? = nil, destinations: [NetworkRouteDestination]? = nil, prefixListId: String? = nil, state: RouteState? = nil, type: RouteType? = nil) {
            self.destinationCidrBlock = destinationCidrBlock
            self.destinations = destinations
            self.prefixListId = prefixListId
            self.state = state
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case destinationCidrBlock = "DestinationCidrBlock"
            case destinations = "Destinations"
            case prefixListId = "PrefixListId"
            case state = "State"
            case type = "Type"
        }
    }

    public struct NetworkRouteDestination: AWSDecodableShape {
        /// The ID of a core network attachment.
        public let coreNetworkAttachmentId: String?
        /// The edge location for the network destination.
        public let edgeLocation: String?
        /// The network function group name associated with the destination.
        public let networkFunctionGroupName: String?
        /// The ID of the resource.
        public let resourceId: String?
        /// The resource type.
        public let resourceType: String?
        /// The name of the segment.
        public let segmentName: String?
        /// The ID of the transit gateway attachment.
        public let transitGatewayAttachmentId: String?

        @inlinable
        public init(coreNetworkAttachmentId: String? = nil, edgeLocation: String? = nil, networkFunctionGroupName: String? = nil, resourceId: String? = nil, resourceType: String? = nil, segmentName: String? = nil, transitGatewayAttachmentId: String? = nil) {
            self.coreNetworkAttachmentId = coreNetworkAttachmentId
            self.edgeLocation = edgeLocation
            self.networkFunctionGroupName = networkFunctionGroupName
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.segmentName = segmentName
            self.transitGatewayAttachmentId = transitGatewayAttachmentId
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkAttachmentId = "CoreNetworkAttachmentId"
            case edgeLocation = "EdgeLocation"
            case networkFunctionGroupName = "NetworkFunctionGroupName"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
            case segmentName = "SegmentName"
            case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        }
    }

    public struct NetworkTelemetry: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The address.
        public let address: String?
        /// The Amazon Web Services Region.
        public let awsRegion: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The connection health.
        public let health: ConnectionHealth?
        /// The ARN of the gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the resource.
        public let resourceArn: String?
        /// The ID of the resource.
        public let resourceId: String?
        /// The resource type.
        public let resourceType: String?

        @inlinable
        public init(accountId: String? = nil, address: String? = nil, awsRegion: String? = nil, coreNetworkId: String? = nil, health: ConnectionHealth? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.accountId = accountId
            self.address = address
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.health = health
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case address = "Address"
            case awsRegion = "AwsRegion"
            case coreNetworkId = "CoreNetworkId"
            case health = "Health"
            case registeredGatewayArn = "RegisteredGatewayArn"
            case resourceArn = "ResourceArn"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct OrganizationStatus: AWSDecodableShape {
        /// The current service-linked role (SLR) deployment status for an Amazon Web Services Organization's accounts. This will be either SUCCEEDED or IN_PROGRESS.
        public let accountStatusList: [AccountStatus]?
        /// The status  of the organization's AWS service access. This will be ENABLED or DISABLED.
        public let organizationAwsServiceAccessStatus: String?
        /// The ID of an Amazon Web Services Organization.
        public let organizationId: String?
        /// The status of the SLR deployment for the account. This will be either SUCCEEDED or IN_PROGRESS.
        public let slrDeploymentStatus: String?

        @inlinable
        public init(accountStatusList: [AccountStatus]? = nil, organizationAwsServiceAccessStatus: String? = nil, organizationId: String? = nil, slrDeploymentStatus: String? = nil) {
            self.accountStatusList = accountStatusList
            self.organizationAwsServiceAccessStatus = organizationAwsServiceAccessStatus
            self.organizationId = organizationId
            self.slrDeploymentStatus = slrDeploymentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountStatusList = "AccountStatusList"
            case organizationAwsServiceAccessStatus = "OrganizationAwsServiceAccessStatus"
            case organizationId = "OrganizationId"
            case slrDeploymentStatus = "SLRDeploymentStatus"
        }
    }

    public struct PathComponent: AWSDecodableShape {
        /// The destination CIDR block in the route table.
        public let destinationCidrBlock: String?
        /// The resource.
        public let resource: NetworkResourceSummary?
        /// The sequence number in the path. The destination is 0.
        public let sequence: Int?

        @inlinable
        public init(destinationCidrBlock: String? = nil, resource: NetworkResourceSummary? = nil, sequence: Int? = nil) {
            self.destinationCidrBlock = destinationCidrBlock
            self.resource = resource
            self.sequence = sequence
        }

        private enum CodingKeys: String, CodingKey {
            case destinationCidrBlock = "DestinationCidrBlock"
            case resource = "Resource"
            case sequence = "Sequence"
        }
    }

    public struct Peering: AWSDecodableShape {
        /// The ARN of a core network.
        public let coreNetworkArn: String?
        /// The ID of the core network for the peering request.
        public let coreNetworkId: String?
        /// The timestamp when the attachment peer was created.
        public let createdAt: Date?
        /// The edge location for the peer.
        public let edgeLocation: String?
        /// Describes the error associated with the Connect peer request.
        public let lastModificationErrors: [PeeringError]?
        /// The ID of the account owner.
        public let ownerAccountId: String?
        /// The ID of the peering attachment.
        public let peeringId: String?
        /// The type of peering. This will be TRANSIT_GATEWAY.
        public let peeringType: PeeringType?
        /// The resource ARN of the peer.
        public let resourceArn: String?
        /// The current state of the peering connection.
        public let state: PeeringState?
        /// The list of key-value tags associated with the peering.
        public let tags: [Tag]?

        @inlinable
        public init(coreNetworkArn: String? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, edgeLocation: String? = nil, lastModificationErrors: [PeeringError]? = nil, ownerAccountId: String? = nil, peeringId: String? = nil, peeringType: PeeringType? = nil, resourceArn: String? = nil, state: PeeringState? = nil, tags: [Tag]? = nil) {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.lastModificationErrors = lastModificationErrors
            self.ownerAccountId = ownerAccountId
            self.peeringId = peeringId
            self.peeringType = peeringType
            self.resourceArn = resourceArn
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkArn = "CoreNetworkArn"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case edgeLocation = "EdgeLocation"
            case lastModificationErrors = "LastModificationErrors"
            case ownerAccountId = "OwnerAccountId"
            case peeringId = "PeeringId"
            case peeringType = "PeeringType"
            case resourceArn = "ResourceArn"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct PeeringError: AWSDecodableShape {
        /// The error code for the peering request.
        public let code: PeeringErrorCode?
        /// The message associated with the error code.
        public let message: String?
        /// Provides additional information about missing permissions for the peering error.
        public let missingPermissionsContext: PermissionsErrorContext?
        /// The ID of the Peering request.
        public let requestId: String?
        /// The ARN of the requested peering resource.
        public let resourceArn: String?

        @inlinable
        public init(code: PeeringErrorCode? = nil, message: String? = nil, missingPermissionsContext: PermissionsErrorContext? = nil, requestId: String? = nil, resourceArn: String? = nil) {
            self.code = code
            self.message = message
            self.missingPermissionsContext = missingPermissionsContext
            self.requestId = requestId
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case missingPermissionsContext = "MissingPermissionsContext"
            case requestId = "RequestId"
            case resourceArn = "ResourceArn"
        }
    }

    public struct PermissionsErrorContext: AWSDecodableShape {
        /// The missing permissions.
        public let missingPermission: String?

        @inlinable
        public init(missingPermission: String? = nil) {
            self.missingPermission = missingPermission
        }

        private enum CodingKeys: String, CodingKey {
            case missingPermission = "MissingPermission"
        }
    }

    public struct ProposedNetworkFunctionGroupChange: AWSDecodableShape {
        /// The proposed new attachment policy rule number for the network function group.
        public let attachmentPolicyRuleNumber: Int?
        /// The proposed name change for the network function group name.
        public let networkFunctionGroupName: String?
        /// The list of proposed changes to the key-value tags associated with the network function group.
        public let tags: [Tag]?

        @inlinable
        public init(attachmentPolicyRuleNumber: Int? = nil, networkFunctionGroupName: String? = nil, tags: [Tag]? = nil) {
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.networkFunctionGroupName = networkFunctionGroupName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentPolicyRuleNumber = "AttachmentPolicyRuleNumber"
            case networkFunctionGroupName = "NetworkFunctionGroupName"
            case tags = "Tags"
        }
    }

    public struct ProposedSegmentChange: AWSDecodableShape {
        /// The rule number in the policy document that applies to this change.
        public let attachmentPolicyRuleNumber: Int?
        /// The name of the segment to change.
        public let segmentName: String?
        /// The list of key-value tags that changed for the segment.
        public let tags: [Tag]?

        @inlinable
        public init(attachmentPolicyRuleNumber: Int? = nil, segmentName: String? = nil, tags: [Tag]? = nil) {
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.segmentName = segmentName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentPolicyRuleNumber = "AttachmentPolicyRuleNumber"
            case segmentName = "SegmentName"
            case tags = "Tags"
        }
    }

    public struct PutCoreNetworkPolicyRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of a core network.
        public let coreNetworkId: String
        /// a core network policy description.
        public let description: String?
        /// The ID of a core network policy.
        public let latestVersionId: Int?
        /// The policy document.
        public let policyDocument: String

        @inlinable
        public init(clientToken: String? = PutCoreNetworkPolicyRequest.idempotencyToken(), coreNetworkId: String, description: String? = nil, latestVersionId: Int? = nil, policyDocument: String) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.description = description
            self.latestVersionId = latestVersionId
            self.policyDocument = policyDocument
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.latestVersionId, forKey: .latestVersionId)
            try container.encode(self.policyDocument, forKey: .policyDocument)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, max: 10000000)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case latestVersionId = "LatestVersionId"
            case policyDocument = "PolicyDocument"
        }
    }

    public struct PutCoreNetworkPolicyResponse: AWSDecodableShape {
        /// Describes the changed core network policy.
        public let coreNetworkPolicy: CoreNetworkPolicy?

        @inlinable
        public init(coreNetworkPolicy: CoreNetworkPolicy? = nil) {
            self.coreNetworkPolicy = coreNetworkPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkPolicy = "CoreNetworkPolicy"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// The JSON resource policy document.
        public let policyDocument: String
        /// The ARN of the resource policy.
        public let resourceArn: String

        @inlinable
        public init(policyDocument: String, resourceArn: String) {
            self.policyDocument = policyDocument
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.policyDocument, forKey: .policyDocument)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, max: 10000000)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "PolicyDocument"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RegisterTransitGatewayRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The Amazon Resource Name (ARN) of the transit gateway.
        public let transitGatewayArn: String

        @inlinable
        public init(globalNetworkId: String, transitGatewayArn: String) {
            self.globalNetworkId = globalNetworkId
            self.transitGatewayArn = transitGatewayArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encode(self.transitGatewayArn, forKey: .transitGatewayArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, max: 500)
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayArn = "TransitGatewayArn"
        }
    }

    public struct RegisterTransitGatewayResponse: AWSDecodableShape {
        /// Information about the transit gateway registration.
        public let transitGatewayRegistration: TransitGatewayRegistration?

        @inlinable
        public init(transitGatewayRegistration: TransitGatewayRegistration? = nil) {
            self.transitGatewayRegistration = transitGatewayRegistration
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayRegistration = "TransitGatewayRegistration"
        }
    }

    public struct RejectAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let attachmentId: String

        @inlinable
        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RejectAttachmentResponse: AWSDecodableShape {
        /// Describes the rejected attachment request.
        public let attachment: Attachment?

        @inlinable
        public init(attachment: Attachment? = nil) {
            self.attachment = attachment
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
        }
    }

    public struct Relationship: AWSDecodableShape {
        /// The ARN of the resource.
        public let from: String?
        /// The ARN of the resource.
        public let to: String?

        @inlinable
        public init(from: String? = nil, to: String? = nil) {
            self.from = from
            self.to = to
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case to = "To"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        /// The specified resource could not be found.
        public let context: [String: String]?
        public let message: String
        /// The ID of the resource.
        public let resourceId: String
        /// The resource type.
        public let resourceType: String

        @inlinable
        public init(context: [String: String]? = nil, message: String, resourceId: String, resourceType: String) {
            self.context = context
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case context = "Context"
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RestoreCoreNetworkPolicyVersionRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The ID of the policy version to restore.
        public let policyVersionId: Int

        @inlinable
        public init(coreNetworkId: String, policyVersionId: Int) {
            self.coreNetworkId = coreNetworkId
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodePath(self.policyVersionId, key: "PolicyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RestoreCoreNetworkPolicyVersionResponse: AWSDecodableShape {
        /// Describes the restored core network policy.
        public let coreNetworkPolicy: CoreNetworkPolicy?

        @inlinable
        public init(coreNetworkPolicy: CoreNetworkPolicy? = nil) {
            self.coreNetworkPolicy = coreNetworkPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkPolicy = "CoreNetworkPolicy"
        }
    }

    public struct RouteAnalysis: AWSDecodableShape {
        /// The destination.
        public let destination: RouteAnalysisEndpointOptions?
        /// The forward path.
        public let forwardPath: RouteAnalysisPath?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// Indicates whether to analyze the return path. The return path is not analyzed if the forward path analysis does not succeed.
        public let includeReturnPath: Bool?
        /// The ID of the AWS account that created the route analysis.
        public let ownerAccountId: String?
        /// The return path.
        public let returnPath: RouteAnalysisPath?
        /// The ID of the route analysis.
        public let routeAnalysisId: String?
        /// The source.
        public let source: RouteAnalysisEndpointOptions?
        /// The time that the analysis started.
        public let startTimestamp: Date?
        /// The status of the route analysis.
        public let status: RouteAnalysisStatus?
        /// Indicates whether to include the location of middlebox appliances in the route analysis.
        public let useMiddleboxes: Bool?

        @inlinable
        public init(destination: RouteAnalysisEndpointOptions? = nil, forwardPath: RouteAnalysisPath? = nil, globalNetworkId: String? = nil, includeReturnPath: Bool? = nil, ownerAccountId: String? = nil, returnPath: RouteAnalysisPath? = nil, routeAnalysisId: String? = nil, source: RouteAnalysisEndpointOptions? = nil, startTimestamp: Date? = nil, status: RouteAnalysisStatus? = nil, useMiddleboxes: Bool? = nil) {
            self.destination = destination
            self.forwardPath = forwardPath
            self.globalNetworkId = globalNetworkId
            self.includeReturnPath = includeReturnPath
            self.ownerAccountId = ownerAccountId
            self.returnPath = returnPath
            self.routeAnalysisId = routeAnalysisId
            self.source = source
            self.startTimestamp = startTimestamp
            self.status = status
            self.useMiddleboxes = useMiddleboxes
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case forwardPath = "ForwardPath"
            case globalNetworkId = "GlobalNetworkId"
            case includeReturnPath = "IncludeReturnPath"
            case ownerAccountId = "OwnerAccountId"
            case returnPath = "ReturnPath"
            case routeAnalysisId = "RouteAnalysisId"
            case source = "Source"
            case startTimestamp = "StartTimestamp"
            case status = "Status"
            case useMiddleboxes = "UseMiddleboxes"
        }
    }

    public struct RouteAnalysisCompletion: AWSDecodableShape {
        /// The reason code. Available only if a connection is not found.    BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND - Found a black hole route with the destination CIDR block.    CYCLIC_PATH_DETECTED - Found the same resource multiple times while traversing the path.    INACTIVE_ROUTE_FOR_DESTINATION_FOUND - Found an inactive route with the destination CIDR block.    MAX_HOPS_EXCEEDED - Analysis exceeded 64 hops without finding the destination.    ROUTE_NOT_FOUND - Cannot find a route table with the destination CIDR block.    TGW_ATTACH_ARN_NO_MATCH - Found an attachment, but not with the correct destination ARN.    TGW_ATTACH_NOT_FOUND - Cannot find an attachment.    TGW_ATTACH_NOT_IN_TGW - Found an attachment, but not to the correct transit gateway.    TGW_ATTACH_STABLE_ROUTE_TABLE_NOT_FOUND - The state of the route table association is not associated.
        public let reasonCode: RouteAnalysisCompletionReasonCode?
        /// Additional information about the path. Available only if a connection is not found.
        public let reasonContext: [String: String]?
        /// The result of the analysis. If the status is NOT_CONNECTED, check the  reason code.
        public let resultCode: RouteAnalysisCompletionResultCode?

        @inlinable
        public init(reasonCode: RouteAnalysisCompletionReasonCode? = nil, reasonContext: [String: String]? = nil, resultCode: RouteAnalysisCompletionResultCode? = nil) {
            self.reasonCode = reasonCode
            self.reasonContext = reasonContext
            self.resultCode = resultCode
        }

        private enum CodingKeys: String, CodingKey {
            case reasonCode = "ReasonCode"
            case reasonContext = "ReasonContext"
            case resultCode = "ResultCode"
        }
    }

    public struct RouteAnalysisEndpointOptions: AWSDecodableShape {
        /// The IP address.
        public let ipAddress: String?
        /// The ARN of the transit gateway.
        public let transitGatewayArn: String?
        /// The ARN of the transit gateway attachment.
        public let transitGatewayAttachmentArn: String?

        @inlinable
        public init(ipAddress: String? = nil, transitGatewayArn: String? = nil, transitGatewayAttachmentArn: String? = nil) {
            self.ipAddress = ipAddress
            self.transitGatewayArn = transitGatewayArn
            self.transitGatewayAttachmentArn = transitGatewayAttachmentArn
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddress = "IpAddress"
            case transitGatewayArn = "TransitGatewayArn"
            case transitGatewayAttachmentArn = "TransitGatewayAttachmentArn"
        }
    }

    public struct RouteAnalysisEndpointOptionsSpecification: AWSEncodableShape {
        /// The IP address.
        public let ipAddress: String?
        /// The ARN of the transit gateway attachment.
        public let transitGatewayAttachmentArn: String?

        @inlinable
        public init(ipAddress: String? = nil, transitGatewayAttachmentArn: String? = nil) {
            self.ipAddress = ipAddress
            self.transitGatewayAttachmentArn = transitGatewayAttachmentArn
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, max: 50)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, min: 1)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.transitGatewayAttachmentArn, name: "transitGatewayAttachmentArn", parent: name, max: 500)
            try self.validate(self.transitGatewayAttachmentArn, name: "transitGatewayAttachmentArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddress = "IpAddress"
            case transitGatewayAttachmentArn = "TransitGatewayAttachmentArn"
        }
    }

    public struct RouteAnalysisPath: AWSDecodableShape {
        /// The status of the analysis at completion.
        public let completionStatus: RouteAnalysisCompletion?
        /// The route analysis path.
        public let path: [PathComponent]?

        @inlinable
        public init(completionStatus: RouteAnalysisCompletion? = nil, path: [PathComponent]? = nil) {
            self.completionStatus = completionStatus
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus = "CompletionStatus"
            case path = "Path"
        }
    }

    public struct RouteTableIdentifier: AWSEncodableShape {
        /// The route table identifier associated with the network function group.
        public let coreNetworkNetworkFunctionGroup: CoreNetworkNetworkFunctionGroupIdentifier?
        /// The segment edge in a core network.
        public let coreNetworkSegmentEdge: CoreNetworkSegmentEdgeIdentifier?
        /// The ARN of the transit gateway route table for the attachment request. For example, "TransitGatewayRouteTableArn": "arn:aws:ec2:us-west-2:123456789012:transit-gateway-route-table/tgw-rtb-9876543210123456".
        public let transitGatewayRouteTableArn: String?

        @inlinable
        public init(coreNetworkNetworkFunctionGroup: CoreNetworkNetworkFunctionGroupIdentifier? = nil, coreNetworkSegmentEdge: CoreNetworkSegmentEdgeIdentifier? = nil, transitGatewayRouteTableArn: String? = nil) {
            self.coreNetworkNetworkFunctionGroup = coreNetworkNetworkFunctionGroup
            self.coreNetworkSegmentEdge = coreNetworkSegmentEdge
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }

        public func validate(name: String) throws {
            try self.coreNetworkNetworkFunctionGroup?.validate(name: "\(name).coreNetworkNetworkFunctionGroup")
            try self.coreNetworkSegmentEdge?.validate(name: "\(name).coreNetworkSegmentEdge")
            try self.validate(self.transitGatewayRouteTableArn, name: "transitGatewayRouteTableArn", parent: name, max: 500)
            try self.validate(self.transitGatewayRouteTableArn, name: "transitGatewayRouteTableArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkNetworkFunctionGroup = "CoreNetworkNetworkFunctionGroup"
            case coreNetworkSegmentEdge = "CoreNetworkSegmentEdge"
            case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
        }
    }

    public struct ServiceInsertionAction: AWSDecodableShape {
        /// The action the service insertion takes for traffic.  send-via sends east-west traffic between attachments.  send-to sends north-south traffic to the  security appliance, and then from that to either the Internet or to an on-premesis  location.
        public let action: SegmentActionServiceInsertion?
        /// Describes the mode packets take for the send-via action. This is not used when the action is send-to. dual-hop packets traverse attachments in both the source to the destination core network edges. This mode requires that an inspection attachment must be present in all Regions of the service insertion-enabled segments.  For single-hop, packets traverse a single intermediate inserted attachment. You can use EdgeOverride to specify a specific edge to use.
        public let mode: SendViaMode?
        /// The list of network function groups and any edge overrides for the chosen service insertion action. Used for both send-to or send-via.
        public let via: Via?
        /// The list of destination segments if the service insertion action is send-via.
        public let whenSentTo: WhenSentTo?

        @inlinable
        public init(action: SegmentActionServiceInsertion? = nil, mode: SendViaMode? = nil, via: Via? = nil, whenSentTo: WhenSentTo? = nil) {
            self.action = action
            self.mode = mode
            self.via = via
            self.whenSentTo = whenSentTo
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case mode = "Mode"
            case via = "Via"
            case whenSentTo = "WhenSentTo"
        }
    }

    public struct ServiceInsertionSegments: AWSDecodableShape {
        /// The list of segments associated with the send-to action.
        public let sendTo: [String]?
        /// The list of segments associated with the send-via action.
        public let sendVia: [String]?

        @inlinable
        public init(sendTo: [String]? = nil, sendVia: [String]? = nil) {
            self.sendTo = sendTo
            self.sendVia = sendVia
        }

        private enum CodingKeys: String, CodingKey {
            case sendTo = "SendTo"
            case sendVia = "SendVia"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        /// The limit code.
        public let limitCode: String
        /// The error message.
        public let message: String
        /// The ID of the resource.
        public let resourceId: String?
        /// The resource type.
        public let resourceType: String?
        /// The service code.
        public let serviceCode: String

        @inlinable
        public init(limitCode: String, message: String, resourceId: String? = nil, resourceType: String? = nil, serviceCode: String) {
            self.limitCode = limitCode
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case limitCode = "LimitCode"
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
            case serviceCode = "ServiceCode"
        }
    }

    public struct Site: AWSDecodableShape {
        /// The date and time that the site was created.
        public let createdAt: Date?
        /// The description of the site.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The location of the site.
        public let location: Location?
        /// The Amazon Resource Name (ARN) of the site.
        public let siteArn: String?
        /// The ID of the site.
        public let siteId: String?
        /// The state of the site.
        public let state: SiteState?
        /// The tags for the site.
        public let tags: [Tag]?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, globalNetworkId: String? = nil, location: Location? = nil, siteArn: String? = nil, siteId: String? = nil, state: SiteState? = nil, tags: [Tag]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.siteArn = siteArn
            self.siteId = siteId
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case globalNetworkId = "GlobalNetworkId"
            case location = "Location"
            case siteArn = "SiteArn"
            case siteId = "SiteId"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct SiteToSiteVpnAttachment: AWSDecodableShape {
        /// Provides details about a site-to-site VPN attachment.
        public let attachment: Attachment?
        /// The ARN of the site-to-site VPN attachment.
        public let vpnConnectionArn: String?

        @inlinable
        public init(attachment: Attachment? = nil, vpnConnectionArn: String? = nil) {
            self.attachment = attachment
            self.vpnConnectionArn = vpnConnectionArn
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case vpnConnectionArn = "VpnConnectionArn"
        }
    }

    public struct StartOrganizationServiceAccessUpdateRequest: AWSEncodableShape {
        /// The action to take for the update request. This can be either ENABLE or DISABLE.
        public let action: String

        @inlinable
        public init(action: String) {
            self.action = action
        }

        public func validate(name: String) throws {
            try self.validate(self.action, name: "action", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
        }
    }

    public struct StartOrganizationServiceAccessUpdateResponse: AWSDecodableShape {
        /// The status of the service access update request for an Amazon Web Services Organization.
        public let organizationStatus: OrganizationStatus?

        @inlinable
        public init(organizationStatus: OrganizationStatus? = nil) {
            self.organizationStatus = organizationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case organizationStatus = "OrganizationStatus"
        }
    }

    public struct StartRouteAnalysisRequest: AWSEncodableShape {
        /// The destination.
        public let destination: RouteAnalysisEndpointOptionsSpecification
        /// The ID of the global network.
        public let globalNetworkId: String
        /// Indicates whether to analyze the return path. The default is false.
        public let includeReturnPath: Bool?
        /// The source from which traffic originates.
        public let source: RouteAnalysisEndpointOptionsSpecification
        /// Indicates whether to include the location of middlebox appliances in the route analysis. The default is false.
        public let useMiddleboxes: Bool?

        @inlinable
        public init(destination: RouteAnalysisEndpointOptionsSpecification, globalNetworkId: String, includeReturnPath: Bool? = nil, source: RouteAnalysisEndpointOptionsSpecification, useMiddleboxes: Bool? = nil) {
            self.destination = destination
            self.globalNetworkId = globalNetworkId
            self.includeReturnPath = includeReturnPath
            self.source = source
            self.useMiddleboxes = useMiddleboxes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.destination, forKey: .destination)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.includeReturnPath, forKey: .includeReturnPath)
            try container.encode(self.source, forKey: .source)
            try container.encodeIfPresent(self.useMiddleboxes, forKey: .useMiddleboxes)
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case includeReturnPath = "IncludeReturnPath"
            case source = "Source"
            case useMiddleboxes = "UseMiddleboxes"
        }
    }

    public struct StartRouteAnalysisResponse: AWSDecodableShape {
        /// The route analysis.
        public let routeAnalysis: RouteAnalysis?

        @inlinable
        public init(routeAnalysis: RouteAnalysis? = nil) {
            self.routeAnalysis = routeAnalysis
        }

        private enum CodingKeys: String, CodingKey {
            case routeAnalysis = "RouteAnalysis"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key. Constraints: Maximum length of 128 characters.
        public let key: String?
        /// The tag value. Constraints: Maximum length of 256 characters.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 10000000)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.value, name: "value", parent: name, max: 10000000)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags to apply to the specified resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// Indicates when to retry the request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct TransitGatewayConnectPeerAssociation: AWSDecodableShape {
        /// The ID of the device.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The ID of the link.
        public let linkId: String?
        /// The state of the association.
        public let state: TransitGatewayConnectPeerAssociationState?
        /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
        public let transitGatewayConnectPeerArn: String?

        @inlinable
        public init(deviceId: String? = nil, globalNetworkId: String? = nil, linkId: String? = nil, state: TransitGatewayConnectPeerAssociationState? = nil, transitGatewayConnectPeerArn: String? = nil) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case linkId = "LinkId"
            case state = "State"
            case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
        }
    }

    public struct TransitGatewayPeering: AWSDecodableShape {
        /// Describes a transit gateway peer connection.
        public let peering: Peering?
        /// The ARN of the transit gateway.
        public let transitGatewayArn: String?
        /// The ID of the transit gateway peering attachment.
        public let transitGatewayPeeringAttachmentId: String?

        @inlinable
        public init(peering: Peering? = nil, transitGatewayArn: String? = nil, transitGatewayPeeringAttachmentId: String? = nil) {
            self.peering = peering
            self.transitGatewayArn = transitGatewayArn
            self.transitGatewayPeeringAttachmentId = transitGatewayPeeringAttachmentId
        }

        private enum CodingKeys: String, CodingKey {
            case peering = "Peering"
            case transitGatewayArn = "TransitGatewayArn"
            case transitGatewayPeeringAttachmentId = "TransitGatewayPeeringAttachmentId"
        }
    }

    public struct TransitGatewayRegistration: AWSDecodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The state of the transit gateway registration.
        public let state: TransitGatewayRegistrationStateReason?
        /// The Amazon Resource Name (ARN) of the transit gateway.
        public let transitGatewayArn: String?

        @inlinable
        public init(globalNetworkId: String? = nil, state: TransitGatewayRegistrationStateReason? = nil, transitGatewayArn: String? = nil) {
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.transitGatewayArn = transitGatewayArn
        }

        private enum CodingKeys: String, CodingKey {
            case globalNetworkId = "GlobalNetworkId"
            case state = "State"
            case transitGatewayArn = "TransitGatewayArn"
        }
    }

    public struct TransitGatewayRegistrationStateReason: AWSDecodableShape {
        /// The code for the state reason.
        public let code: TransitGatewayRegistrationState?
        /// The message for the state reason.
        public let message: String?

        @inlinable
        public init(code: TransitGatewayRegistrationState? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct TransitGatewayRouteTableAttachment: AWSDecodableShape {
        public let attachment: Attachment?
        /// The ID of the peering attachment.
        public let peeringId: String?
        /// The ARN of the transit gateway attachment route table. For example, "TransitGatewayRouteTableArn": "arn:aws:ec2:us-west-2:123456789012:transit-gateway-route-table/tgw-rtb-9876543210123456".
        public let transitGatewayRouteTableArn: String?

        @inlinable
        public init(attachment: Attachment? = nil, peeringId: String? = nil, transitGatewayRouteTableArn: String? = nil) {
            self.attachment = attachment
            self.peeringId = peeringId
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case peeringId = "PeeringId"
            case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys to remove from the specified resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 10000000)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConnectionRequest: AWSEncodableShape {
        /// The ID of the link for the second device in the connection.
        public let connectedLinkId: String?
        /// The ID of the connection.
        public let connectionId: String
        /// A description of the connection. Length Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link for the first device in the connection.
        public let linkId: String?

        @inlinable
        public init(connectedLinkId: String? = nil, connectionId: String, description: String? = nil, globalNetworkId: String, linkId: String? = nil) {
            self.connectedLinkId = connectedLinkId
            self.connectionId = connectionId
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.connectedLinkId, forKey: .connectedLinkId)
            request.encodePath(self.connectionId, key: "ConnectionId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.linkId, forKey: .linkId)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectedLinkId, name: "connectedLinkId", parent: name, max: 50)
            try self.validate(self.connectedLinkId, name: "connectedLinkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 50)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectedLinkId = "ConnectedLinkId"
            case description = "Description"
            case linkId = "LinkId"
        }
    }

    public struct UpdateConnectionResponse: AWSDecodableShape {
        /// Information about the connection.
        public let connection: Connection?

        @inlinable
        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct UpdateCoreNetworkRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The description of the update.
        public let description: String?

        @inlinable
        public init(coreNetworkId: String, description: String? = nil) {
            self.coreNetworkId = coreNetworkId
            self.description = description
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            try container.encodeIfPresent(self.description, forKey: .description)
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateCoreNetworkResponse: AWSDecodableShape {
        /// Returns information about a core network update.
        public let coreNetwork: CoreNetwork?

        @inlinable
        public init(coreNetwork: CoreNetwork? = nil) {
            self.coreNetwork = coreNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetwork = "CoreNetwork"
        }
    }

    public struct UpdateDeviceRequest: AWSEncodableShape {
        /// The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.
        public let awsLocation: AWSLocation?
        /// A description of the device. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        public let location: Location?
        /// The model of the device. Constraints: Maximum length of 128 characters.
        public let model: String?
        /// The serial number of the device. Constraints: Maximum length of 128 characters.
        public let serialNumber: String?
        /// The ID of the site.
        public let siteId: String?
        /// The type of the device.
        public let type: String?
        /// The vendor of the device. Constraints: Maximum length of 128 characters.
        public let vendor: String?

        @inlinable
        public init(awsLocation: AWSLocation? = nil, description: String? = nil, deviceId: String, globalNetworkId: String, location: Location? = nil, model: String? = nil, serialNumber: String? = nil, siteId: String? = nil, type: String? = nil, vendor: String? = nil) {
            self.awsLocation = awsLocation
            self.description = description
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.model = model
            self.serialNumber = serialNumber
            self.siteId = siteId
            self.type = type
            self.vendor = vendor
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.awsLocation, forKey: .awsLocation)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.deviceId, key: "DeviceId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.location, forKey: .location)
            try container.encodeIfPresent(self.model, forKey: .model)
            try container.encodeIfPresent(self.serialNumber, forKey: .serialNumber)
            try container.encodeIfPresent(self.siteId, forKey: .siteId)
            try container.encodeIfPresent(self.type, forKey: .type)
            try container.encodeIfPresent(self.vendor, forKey: .vendor)
        }

        public func validate(name: String) throws {
            try self.awsLocation?.validate(name: "\(name).awsLocation")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.location?.validate(name: "\(name).location")
            try self.validate(self.model, name: "model", parent: name, max: 256)
            try self.validate(self.model, name: "model", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, max: 256)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.vendor, name: "vendor", parent: name, max: 256)
            try self.validate(self.vendor, name: "vendor", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsLocation = "AWSLocation"
            case description = "Description"
            case location = "Location"
            case model = "Model"
            case serialNumber = "SerialNumber"
            case siteId = "SiteId"
            case type = "Type"
            case vendor = "Vendor"
        }
    }

    public struct UpdateDeviceResponse: AWSDecodableShape {
        /// Information about the device.
        public let device: Device?

        @inlinable
        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "Device"
        }
    }

    public struct UpdateDirectConnectGatewayAttachmentRequest: AWSEncodableShape {
        /// The ID of the Direct Connect gateway attachment for the updated edge locations.
        public let attachmentId: String
        /// One or more edge locations to update for the Direct Connect gateway attachment. The updated array of edge locations overwrites the previous array of locations. EdgeLocations is only used for Direct Connect gateway attachments.
        public let edgeLocations: [String]?

        @inlinable
        public init(attachmentId: String, edgeLocations: [String]? = nil) {
            self.attachmentId = attachmentId
            self.edgeLocations = edgeLocations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
            try container.encodeIfPresent(self.edgeLocations, forKey: .edgeLocations)
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
            try self.edgeLocations?.forEach {
                try validate($0, name: "edgeLocations[]", parent: name, max: 63)
                try validate($0, name: "edgeLocations[]", parent: name, min: 1)
                try validate($0, name: "edgeLocations[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case edgeLocations = "EdgeLocations"
        }
    }

    public struct UpdateDirectConnectGatewayAttachmentResponse: AWSDecodableShape {
        /// Returns details of the Direct Connect gateway attachment with the updated edge locations.
        public let directConnectGatewayAttachment: DirectConnectGatewayAttachment?

        @inlinable
        public init(directConnectGatewayAttachment: DirectConnectGatewayAttachment? = nil) {
            self.directConnectGatewayAttachment = directConnectGatewayAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case directConnectGatewayAttachment = "DirectConnectGatewayAttachment"
        }
    }

    public struct UpdateGlobalNetworkRequest: AWSEncodableShape {
        /// A description of the global network. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of your global network.
        public let globalNetworkId: String

        @inlinable
        public init(description: String? = nil, globalNetworkId: String) {
            self.description = description
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateGlobalNetworkResponse: AWSDecodableShape {
        /// Information about the global network object.
        public let globalNetwork: GlobalNetwork?

        @inlinable
        public init(globalNetwork: GlobalNetwork? = nil) {
            self.globalNetwork = globalNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case globalNetwork = "GlobalNetwork"
        }
    }

    public struct UpdateLinkRequest: AWSEncodableShape {
        /// The upload and download speed in Mbps.
        public let bandwidth: Bandwidth?
        /// A description of the link. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String
        /// The provider of the link. Constraints: Maximum length of 128 characters.
        public let provider: String?
        /// The type of the link. Constraints: Maximum length of 128 characters.
        public let type: String?

        @inlinable
        public init(bandwidth: Bandwidth? = nil, description: String? = nil, globalNetworkId: String, linkId: String, provider: String? = nil, type: String? = nil) {
            self.bandwidth = bandwidth
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.provider = provider
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.bandwidth, forKey: .bandwidth)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.linkId, key: "LinkId")
            try container.encodeIfPresent(self.provider, forKey: .provider)
            try container.encodeIfPresent(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.provider, name: "provider", parent: name, max: 256)
            try self.validate(self.provider, name: "provider", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth = "Bandwidth"
            case description = "Description"
            case provider = "Provider"
            case type = "Type"
        }
    }

    public struct UpdateLinkResponse: AWSDecodableShape {
        /// Information about the link.
        public let link: Link?

        @inlinable
        public init(link: Link? = nil) {
            self.link = link
        }

        private enum CodingKeys: String, CodingKey {
            case link = "Link"
        }
    }

    public struct UpdateNetworkResourceMetadataRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The resource metadata.
        public let metadata: [String: String]
        /// The ARN of the resource.
        public let resourceArn: String

        @inlinable
        public init(globalNetworkId: String, metadata: [String: String], resourceArn: String) {
            self.globalNetworkId = globalNetworkId
            self.metadata = metadata
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encode(self.metadata, forKey: .metadata)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.metadata.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 256)
                try validate($0.key, name: "metadata.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
        }
    }

    public struct UpdateNetworkResourceMetadataResponse: AWSDecodableShape {
        /// The updated resource metadata.
        public let metadata: [String: String]?
        /// The ARN of the resource.
        public let resourceArn: String?

        @inlinable
        public init(metadata: [String: String]? = nil, resourceArn: String? = nil) {
            self.metadata = metadata
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
            case resourceArn = "ResourceArn"
        }
    }

    public struct UpdateSiteRequest: AWSEncodableShape {
        /// A description of your site. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The site location:    Address: The physical address of the site.    Latitude: The latitude of the site.     Longitude: The longitude of the site.
        public let location: Location?
        /// The ID of your site.
        public let siteId: String

        @inlinable
        public init(description: String? = nil, globalNetworkId: String, location: Location? = nil, siteId: String) {
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.location, forKey: .location)
            request.encodePath(self.siteId, key: "SiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.location?.validate(name: "\(name).location")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case location = "Location"
        }
    }

    public struct UpdateSiteResponse: AWSDecodableShape {
        /// Information about the site.
        public let site: Site?

        @inlinable
        public init(site: Site? = nil) {
            self.site = site
        }

        private enum CodingKeys: String, CodingKey {
            case site = "Site"
        }
    }

    public struct UpdateVpcAttachmentRequest: AWSEncodableShape {
        /// Adds a subnet ARN to the VPC attachment.
        public let addSubnetArns: [String]?
        /// The ID of the attachment.
        public let attachmentId: String
        /// Additional options for updating the VPC attachment.
        public let options: VpcOptions?
        /// Removes a subnet ARN from the attachment.
        public let removeSubnetArns: [String]?

        @inlinable
        public init(addSubnetArns: [String]? = nil, attachmentId: String, options: VpcOptions? = nil, removeSubnetArns: [String]? = nil) {
            self.addSubnetArns = addSubnetArns
            self.attachmentId = attachmentId
            self.options = options
            self.removeSubnetArns = removeSubnetArns
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.addSubnetArns, forKey: .addSubnetArns)
            request.encodePath(self.attachmentId, key: "AttachmentId")
            try container.encodeIfPresent(self.options, forKey: .options)
            try container.encodeIfPresent(self.removeSubnetArns, forKey: .removeSubnetArns)
        }

        public func validate(name: String) throws {
            try self.addSubnetArns?.forEach {
                try validate($0, name: "addSubnetArns[]", parent: name, max: 500)
                try validate($0, name: "addSubnetArns[]", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:subnet\\/subnet-[0-9a-f]{8,17}$|^$")
            }
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
            try self.removeSubnetArns?.forEach {
                try validate($0, name: "removeSubnetArns[]", parent: name, max: 500)
                try validate($0, name: "removeSubnetArns[]", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:subnet\\/subnet-[0-9a-f]{8,17}$|^$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case addSubnetArns = "AddSubnetArns"
            case options = "Options"
            case removeSubnetArns = "RemoveSubnetArns"
        }
    }

    public struct UpdateVpcAttachmentResponse: AWSDecodableShape {
        /// Describes the updated VPC attachment.
        public let vpcAttachment: VpcAttachment?

        @inlinable
        public init(vpcAttachment: VpcAttachment? = nil) {
            self.vpcAttachment = vpcAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case vpcAttachment = "VpcAttachment"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The fields that caused the error, if applicable.
        public let fields: [ValidationExceptionField]?
        public let message: String
        /// The reason for the error.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fields: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason? = nil) {
            self.fields = fields
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The message for the field.
        public let message: String
        /// The name of the field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case name = "Name"
        }
    }

    public struct Via: AWSDecodableShape {
        /// The list of network function groups associated with the service insertion action.
        public let networkFunctionGroups: [NetworkFunctionGroup]?
        /// Describes any edge overrides. An edge override is a specific edge to be used for traffic.
        public let withEdgeOverrides: [EdgeOverride]?

        @inlinable
        public init(networkFunctionGroups: [NetworkFunctionGroup]? = nil, withEdgeOverrides: [EdgeOverride]? = nil) {
            self.networkFunctionGroups = networkFunctionGroups
            self.withEdgeOverrides = withEdgeOverrides
        }

        private enum CodingKeys: String, CodingKey {
            case networkFunctionGroups = "NetworkFunctionGroups"
            case withEdgeOverrides = "WithEdgeOverrides"
        }
    }

    public struct VpcAttachment: AWSDecodableShape {
        /// Provides details about the VPC attachment.
        public let attachment: Attachment?
        /// Provides details about the VPC attachment.
        public let options: VpcOptions?
        /// The subnet ARNs.
        public let subnetArns: [String]?

        @inlinable
        public init(attachment: Attachment? = nil, options: VpcOptions? = nil, subnetArns: [String]? = nil) {
            self.attachment = attachment
            self.options = options
            self.subnetArns = subnetArns
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case options = "Options"
            case subnetArns = "SubnetArns"
        }
    }

    public struct VpcOptions: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether appliance mode is supported.  If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow. The default value is false.
        public let applianceModeSupport: Bool?
        /// Indicates whether IPv6 is supported.
        public let ipv6Support: Bool?

        @inlinable
        public init(applianceModeSupport: Bool? = nil, ipv6Support: Bool? = nil) {
            self.applianceModeSupport = applianceModeSupport
            self.ipv6Support = ipv6Support
        }

        private enum CodingKeys: String, CodingKey {
            case applianceModeSupport = "ApplianceModeSupport"
            case ipv6Support = "Ipv6Support"
        }
    }

    public struct WhenSentTo: AWSDecodableShape {
        /// The list of destination segments when the service insertion action is send-to.
        public let whenSentToSegmentsList: [String]?

        @inlinable
        public init(whenSentToSegmentsList: [String]? = nil) {
            self.whenSentToSegmentsList = whenSentToSegmentsList
        }

        private enum CodingKeys: String, CodingKey {
            case whenSentToSegmentsList = "WhenSentToSegmentsList"
        }
    }
}

// MARK: - Errors

/// Error enum for NetworkManager
public struct NetworkManagerErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case coreNetworkPolicyException = "CoreNetworkPolicyException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize NetworkManager
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was a conflict processing the request. Updating or deleting the resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Describes a core network policy exception.
    public static var coreNetworkPolicyException: Self { .init(.coreNetworkPolicyException) }
    /// The request has failed due to an internal error.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// A service limit was exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension NetworkManagerErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": NetworkManager.ConflictException.self,
        "CoreNetworkPolicyException": NetworkManager.CoreNetworkPolicyException.self,
        "InternalServerException": NetworkManager.InternalServerException.self,
        "ResourceNotFoundException": NetworkManager.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": NetworkManager.ServiceQuotaExceededException.self,
        "ThrottlingException": NetworkManager.ThrottlingException.self,
        "ValidationException": NetworkManager.ValidationException.self
    ]
}

extension NetworkManagerErrorType: Equatable {
    public static func == (lhs: NetworkManagerErrorType, rhs: NetworkManagerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension NetworkManagerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
