//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension NetworkManager {
    // MARK: Enums

    public enum AttachmentState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pendingAttachmentAcceptance = "PENDING_ATTACHMENT_ACCEPTANCE"
        case pendingNetworkUpdate = "PENDING_NETWORK_UPDATE"
        case pendingTagAcceptance = "PENDING_TAG_ACCEPTANCE"
        case rejected = "REJECTED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connect = "CONNECT"
        case siteToSiteVpn = "SITE_TO_SITE_VPN"
        case transitGatewayRouteTable = "TRANSIT_GATEWAY_ROUTE_TABLE"
        case vpc = "VPC"
        public var description: String { return self.rawValue }
    }

    public enum ChangeAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case add = "ADD"
        case modify = "MODIFY"
        case remove = "REMOVE"
        public var description: String { return self.rawValue }
    }

    public enum ChangeSetState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case executing = "EXECUTING"
        case executionSucceeded = "EXECUTION_SUCCEEDED"
        case failedGeneration = "FAILED_GENERATION"
        case outOfDate = "OUT_OF_DATE"
        case pendingGeneration = "PENDING_GENERATION"
        case readyToExecute = "READY_TO_EXECUTE"
        public var description: String { return self.rawValue }
    }

    public enum ChangeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum ChangeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachmentMapping = "ATTACHMENT_MAPPING"
        case attachmentPoliciesConfiguration = "ATTACHMENT_POLICIES_CONFIGURATION"
        case attachmentRoutePropagation = "ATTACHMENT_ROUTE_PROPAGATION"
        case attachmentRouteStatic = "ATTACHMENT_ROUTE_STATIC"
        case coreNetworkConfiguration = "CORE_NETWORK_CONFIGURATION"
        case coreNetworkEdge = "CORE_NETWORK_EDGE"
        case coreNetworkSegment = "CORE_NETWORK_SEGMENT"
        case segmentActionsConfiguration = "SEGMENT_ACTIONS_CONFIGURATION"
        case segmentsConfiguration = "SEGMENTS_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public enum ConnectPeerAssociationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ConnectPeerState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case down = "DOWN"
        case up = "UP"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bgp = "BGP"
        case ipsec = "IPSEC"
        public var description: String { return self.rawValue }
    }

    public enum CoreNetworkPolicyAlias: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case latest = "LATEST"
        case live = "LIVE"
        public var description: String { return self.rawValue }
    }

    public enum CoreNetworkState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum CustomerGatewayAssociationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum DeviceState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum GlobalNetworkState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum LinkAssociationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum LinkState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum PeeringState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum PeeringType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case transitGateway = "TRANSIT_GATEWAY"
        public var description: String { return self.rawValue }
    }

    public enum RouteAnalysisCompletionReasonCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blackholeRouteForDestinationFound = "BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND"
        case cyclicPathDetected = "CYCLIC_PATH_DETECTED"
        case inactiveRouteForDestinationFound = "INACTIVE_ROUTE_FOR_DESTINATION_FOUND"
        case maxHopsExceeded = "MAX_HOPS_EXCEEDED"
        case noDestinationArnProvided = "NO_DESTINATION_ARN_PROVIDED"
        case possibleMiddlebox = "POSSIBLE_MIDDLEBOX"
        case routeNotFound = "ROUTE_NOT_FOUND"
        case transitGatewayAttachment = "TRANSIT_GATEWAY_ATTACHMENT_ATTACH_ARN_NO_MATCH"
        case transitGatewayAttachmentNotFound = "TRANSIT_GATEWAY_ATTACHMENT_NOT_FOUND"
        case transitGatewayAttachmentNotInTransitGateway = "TRANSIT_GATEWAY_ATTACHMENT_NOT_IN_TRANSIT_GATEWAY"
        case transitGatewayAttachmentStableRouteTableNotFound = "TRANSIT_GATEWAY_ATTACHMENT_STABLE_ROUTE_TABLE_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum RouteAnalysisCompletionResultCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connected = "CONNECTED"
        case notConnected = "NOT_CONNECTED"
        public var description: String { return self.rawValue }
    }

    public enum RouteAnalysisStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum RouteState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case blackhole = "BLACKHOLE"
        public var description: String { return self.rawValue }
    }

    public enum RouteTableType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case coreNetworkSegment = "CORE_NETWORK_SEGMENT"
        case transitGatewayRouteTable = "TRANSIT_GATEWAY_ROUTE_TABLE"
        public var description: String { return self.rawValue }
    }

    public enum RouteType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `static` = "STATIC"
        case propagated = "PROPAGATED"
        public var description: String { return self.rawValue }
    }

    public enum SiteState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case pending = "PENDING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum TransitGatewayConnectPeerAssociationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum TransitGatewayRegistrationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum TunnelProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gre = "GRE"
        case noEncap = "NO_ENCAP"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AWSLocation: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the subnet that the device is located in.
        public let subnetArn: String?
        /// The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
        public let zone: String?

        public init(subnetArn: String? = nil, zone: String? = nil) {
            self.subnetArn = subnetArn
            self.zone = zone
        }

        public func validate(name: String) throws {
            try self.validate(self.subnetArn, name: "subnetArn", parent: name, max: 500)
            try self.validate(self.subnetArn, name: "subnetArn", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:subnet\\/subnet-[0-9a-f]{8,17}$|^$")
            try self.validate(self.zone, name: "zone", parent: name, max: 256)
            try self.validate(self.zone, name: "zone", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case subnetArn = "SubnetArn"
            case zone = "Zone"
        }
    }

    public struct AcceptAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let attachmentId: String

        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AcceptAttachmentResponse: AWSDecodableShape {
        /// The response to the attachment request.
        public let attachment: Attachment?

        public init(attachment: Attachment? = nil) {
            self.attachment = attachment
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
        }
    }

    public struct AccountStatus: AWSDecodableShape {
        /// The ID of an account within the Amazon Web Services Organization.
        public let accountId: String?
        /// The status of SLR deployment for the account.
        public let slrDeploymentStatus: String?

        public init(accountId: String? = nil, slrDeploymentStatus: String? = nil) {
            self.accountId = accountId
            self.slrDeploymentStatus = slrDeploymentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case slrDeploymentStatus = "SLRDeploymentStatus"
        }
    }

    public struct AssociateConnectPeerRequest: AWSEncodableShape {
        /// The ID of the Connect peer.
        public let connectPeerId: String
        /// The ID of the device.
        public let deviceId: String
        /// The ID of your global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String?

        public init(connectPeerId: String, deviceId: String, globalNetworkId: String, linkId: String? = nil) {
            self.connectPeerId = connectPeerId
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.connectPeerId, forKey: .connectPeerId)
            try container.encode(self.deviceId, forKey: .deviceId)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.linkId, forKey: .linkId)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, max: 50)
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, pattern: "^connect-peer-([0-9a-f]{8,17})$")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeerId = "ConnectPeerId"
            case deviceId = "DeviceId"
            case linkId = "LinkId"
        }
    }

    public struct AssociateConnectPeerResponse: AWSDecodableShape {
        /// The response to the Connect peer request.
        public let connectPeerAssociation: ConnectPeerAssociation?

        public init(connectPeerAssociation: ConnectPeerAssociation? = nil) {
            self.connectPeerAssociation = connectPeerAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeerAssociation = "ConnectPeerAssociation"
        }
    }

    public struct AssociateCustomerGatewayRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the customer gateway.
        public let customerGatewayArn: String
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String?

        public init(customerGatewayArn: String, deviceId: String, globalNetworkId: String, linkId: String? = nil) {
            self.customerGatewayArn = customerGatewayArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.customerGatewayArn, forKey: .customerGatewayArn)
            try container.encode(self.deviceId, forKey: .deviceId)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.linkId, forKey: .linkId)
        }

        public func validate(name: String) throws {
            try self.validate(self.customerGatewayArn, name: "customerGatewayArn", parent: name, max: 500)
            try self.validate(self.customerGatewayArn, name: "customerGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case customerGatewayArn = "CustomerGatewayArn"
            case deviceId = "DeviceId"
            case linkId = "LinkId"
        }
    }

    public struct AssociateCustomerGatewayResponse: AWSDecodableShape {
        /// The customer gateway association.
        public let customerGatewayAssociation: CustomerGatewayAssociation?

        public init(customerGatewayAssociation: CustomerGatewayAssociation? = nil) {
            self.customerGatewayAssociation = customerGatewayAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case customerGatewayAssociation = "CustomerGatewayAssociation"
        }
    }

    public struct AssociateLinkRequest: AWSEncodableShape {
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String

        public init(deviceId: String, globalNetworkId: String, linkId: String) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.deviceId, forKey: .deviceId)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encode(self.linkId, forKey: .linkId)
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case linkId = "LinkId"
        }
    }

    public struct AssociateLinkResponse: AWSDecodableShape {
        /// The link association.
        public let linkAssociation: LinkAssociation?

        public init(linkAssociation: LinkAssociation? = nil) {
            self.linkAssociation = linkAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case linkAssociation = "LinkAssociation"
        }
    }

    public struct AssociateTransitGatewayConnectPeerRequest: AWSEncodableShape {
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String?
        /// The Amazon Resource Name (ARN) of the Connect peer.
        public let transitGatewayConnectPeerArn: String

        public init(deviceId: String, globalNetworkId: String, linkId: String? = nil, transitGatewayConnectPeerArn: String) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.deviceId, forKey: .deviceId)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.linkId, forKey: .linkId)
            try container.encode(self.transitGatewayConnectPeerArn, forKey: .transitGatewayConnectPeerArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.transitGatewayConnectPeerArn, name: "transitGatewayConnectPeerArn", parent: name, max: 500)
            try self.validate(self.transitGatewayConnectPeerArn, name: "transitGatewayConnectPeerArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case linkId = "LinkId"
            case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
        }
    }

    public struct AssociateTransitGatewayConnectPeerResponse: AWSDecodableShape {
        /// The transit gateway Connect peer association.
        public let transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation?

        public init(transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation? = nil) {
            self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
        }
    }

    public struct Attachment: AWSDecodableShape {
        /// The ID of the attachment.
        public let attachmentId: String?
        /// The policy rule number associated with the attachment.
        public let attachmentPolicyRuleNumber: Int?
        /// The type of attachment.
        public let attachmentType: AttachmentType?
        /// The ARN of a core network.
        public let coreNetworkArn: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when the attachment was created.
        public let createdAt: Date?
        /// The Region where the edge is located.
        public let edgeLocation: String?
        /// The ID of the attachment account owner.
        public let ownerAccountId: String?
        /// The attachment to move from one segment to another.
        public let proposedSegmentChange: ProposedSegmentChange?
        /// The attachment resource ARN.
        public let resourceArn: String?
        /// The name of the segment attachment.
        public let segmentName: String?
        /// The state of the attachment.
        public let state: AttachmentState?
        /// The tags associated with the attachment.
        public let tags: [Tag]?
        /// The timestamp when the attachment was last updated.
        public let updatedAt: Date?

        public init(attachmentId: String? = nil, attachmentPolicyRuleNumber: Int? = nil, attachmentType: AttachmentType? = nil, coreNetworkArn: String? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, edgeLocation: String? = nil, ownerAccountId: String? = nil, proposedSegmentChange: ProposedSegmentChange? = nil, resourceArn: String? = nil, segmentName: String? = nil, state: AttachmentState? = nil, tags: [Tag]? = nil, updatedAt: Date? = nil) {
            self.attachmentId = attachmentId
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.attachmentType = attachmentType
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.ownerAccountId = ownerAccountId
            self.proposedSegmentChange = proposedSegmentChange
            self.resourceArn = resourceArn
            self.segmentName = segmentName
            self.state = state
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case attachmentPolicyRuleNumber = "AttachmentPolicyRuleNumber"
            case attachmentType = "AttachmentType"
            case coreNetworkArn = "CoreNetworkArn"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case edgeLocation = "EdgeLocation"
            case ownerAccountId = "OwnerAccountId"
            case proposedSegmentChange = "ProposedSegmentChange"
            case resourceArn = "ResourceArn"
            case segmentName = "SegmentName"
            case state = "State"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct Bandwidth: AWSEncodableShape & AWSDecodableShape {
        /// Download speed in Mbps.
        public let downloadSpeed: Int?
        /// Upload speed in Mbps.
        public let uploadSpeed: Int?

        public init(downloadSpeed: Int? = nil, uploadSpeed: Int? = nil) {
            self.downloadSpeed = downloadSpeed
            self.uploadSpeed = uploadSpeed
        }

        private enum CodingKeys: String, CodingKey {
            case downloadSpeed = "DownloadSpeed"
            case uploadSpeed = "UploadSpeed"
        }
    }

    public struct BgpOptions: AWSEncodableShape {
        /// The Peer ASN of the BGP.
        public let peerAsn: Int64?

        public init(peerAsn: Int64? = nil) {
            self.peerAsn = peerAsn
        }

        private enum CodingKeys: String, CodingKey {
            case peerAsn = "PeerAsn"
        }
    }

    public struct ConnectAttachment: AWSDecodableShape {
        /// The attachment details.
        public let attachment: Attachment?
        /// Options for connecting an attachment.
        public let options: ConnectAttachmentOptions?
        /// The ID of the transport attachment.
        public let transportAttachmentId: String?

        public init(attachment: Attachment? = nil, options: ConnectAttachmentOptions? = nil, transportAttachmentId: String? = nil) {
            self.attachment = attachment
            self.options = options
            self.transportAttachmentId = transportAttachmentId
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case options = "Options"
            case transportAttachmentId = "TransportAttachmentId"
        }
    }

    public struct ConnectAttachmentOptions: AWSEncodableShape & AWSDecodableShape {
        /// The protocol used for the attachment connection.
        public let `protocol`: TunnelProtocol?

        public init(protocol: TunnelProtocol? = nil) {
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case `protocol` = "Protocol"
        }
    }

    public struct ConnectPeer: AWSDecodableShape {
        /// The configuration of the Connect peer.
        public let configuration: ConnectPeerConfiguration?
        /// The ID of the attachment to connect.
        public let connectAttachmentId: String?
        /// The ID of the Connect peer.
        public let connectPeerId: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when the Connect peer was created.
        public let createdAt: Date?
        /// The Connect peer Regions where edges are located.
        public let edgeLocation: String?
        /// The state of the Connect peer.
        public let state: ConnectPeerState?
        /// The subnet ARN for the Connect peer.
        public let subnetArn: String?
        /// The list of key-value tags associated with the Connect peer.
        public let tags: [Tag]?

        public init(configuration: ConnectPeerConfiguration? = nil, connectAttachmentId: String? = nil, connectPeerId: String? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, edgeLocation: String? = nil, state: ConnectPeerState? = nil, subnetArn: String? = nil, tags: [Tag]? = nil) {
            self.configuration = configuration
            self.connectAttachmentId = connectAttachmentId
            self.connectPeerId = connectPeerId
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.state = state
            self.subnetArn = subnetArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case connectAttachmentId = "ConnectAttachmentId"
            case connectPeerId = "ConnectPeerId"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case edgeLocation = "EdgeLocation"
            case state = "State"
            case subnetArn = "SubnetArn"
            case tags = "Tags"
        }
    }

    public struct ConnectPeerAssociation: AWSDecodableShape {
        /// The ID of the Connect peer.
        public let connectPeerId: String?
        /// The ID of the device to connect to.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The ID of the link.
        public let linkId: String?
        /// The state of the Connect peer association.
        public let state: ConnectPeerAssociationState?

        public init(connectPeerId: String? = nil, deviceId: String? = nil, globalNetworkId: String? = nil, linkId: String? = nil, state: ConnectPeerAssociationState? = nil) {
            self.connectPeerId = connectPeerId
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeerId = "ConnectPeerId"
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case linkId = "LinkId"
            case state = "State"
        }
    }

    public struct ConnectPeerBgpConfiguration: AWSDecodableShape {
        /// The address of a core network.
        public let coreNetworkAddress: String?
        /// The ASN of the Coret Network.
        public let coreNetworkAsn: Int64?
        /// The address of a core network Connect peer.
        public let peerAddress: String?
        /// The ASN of the Connect peer.
        public let peerAsn: Int64?

        public init(coreNetworkAddress: String? = nil, coreNetworkAsn: Int64? = nil, peerAddress: String? = nil, peerAsn: Int64? = nil) {
            self.coreNetworkAddress = coreNetworkAddress
            self.coreNetworkAsn = coreNetworkAsn
            self.peerAddress = peerAddress
            self.peerAsn = peerAsn
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkAddress = "CoreNetworkAddress"
            case coreNetworkAsn = "CoreNetworkAsn"
            case peerAddress = "PeerAddress"
            case peerAsn = "PeerAsn"
        }
    }

    public struct ConnectPeerConfiguration: AWSDecodableShape {
        /// The Connect peer BGP configurations.
        public let bgpConfigurations: [ConnectPeerBgpConfiguration]?
        /// The IP address of a core network.
        public let coreNetworkAddress: String?
        /// The inside IP addresses used for a Connect peer configuration.
        public let insideCidrBlocks: [String]?
        /// The IP address of the Connect peer.
        public let peerAddress: String?
        /// The protocol used for a Connect peer configuration.
        public let `protocol`: TunnelProtocol?

        public init(bgpConfigurations: [ConnectPeerBgpConfiguration]? = nil, coreNetworkAddress: String? = nil, insideCidrBlocks: [String]? = nil, peerAddress: String? = nil, protocol: TunnelProtocol? = nil) {
            self.bgpConfigurations = bgpConfigurations
            self.coreNetworkAddress = coreNetworkAddress
            self.insideCidrBlocks = insideCidrBlocks
            self.peerAddress = peerAddress
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case bgpConfigurations = "BgpConfigurations"
            case coreNetworkAddress = "CoreNetworkAddress"
            case insideCidrBlocks = "InsideCidrBlocks"
            case peerAddress = "PeerAddress"
            case `protocol` = "Protocol"
        }
    }

    public struct ConnectPeerSummary: AWSDecodableShape {
        /// The ID of a Connect peer attachment.
        public let connectAttachmentId: String?
        /// The ID of a Connect peer.
        public let connectPeerId: String?
        /// The state of a Connect peer.
        public let connectPeerState: ConnectPeerState?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when a Connect peer was created.
        public let createdAt: Date?
        /// The Region where the edge is located.
        public let edgeLocation: String?
        /// The subnet ARN for the Connect peer summary.
        public let subnetArn: String?
        /// The list of key-value tags associated with the Connect peer summary.
        public let tags: [Tag]?

        public init(connectAttachmentId: String? = nil, connectPeerId: String? = nil, connectPeerState: ConnectPeerState? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, edgeLocation: String? = nil, subnetArn: String? = nil, tags: [Tag]? = nil) {
            self.connectAttachmentId = connectAttachmentId
            self.connectPeerId = connectPeerId
            self.connectPeerState = connectPeerState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.subnetArn = subnetArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case connectAttachmentId = "ConnectAttachmentId"
            case connectPeerId = "ConnectPeerId"
            case connectPeerState = "ConnectPeerState"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case edgeLocation = "EdgeLocation"
            case subnetArn = "SubnetArn"
            case tags = "Tags"
        }
    }

    public struct Connection: AWSDecodableShape {
        /// The ID of the second device in the connection.
        public let connectedDeviceId: String?
        /// The ID of the link for the second device in the connection.
        public let connectedLinkId: String?
        /// The Amazon Resource Name (ARN) of the connection.
        public let connectionArn: String?
        /// The ID of the connection.
        public let connectionId: String?
        /// The date and time that the connection was created.
        public let createdAt: Date?
        /// The description of the connection.
        public let description: String?
        /// The ID of the first device in the connection.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The ID of the link for the first device in the connection.
        public let linkId: String?
        /// The state of the connection.
        public let state: ConnectionState?
        /// The tags for the connection.
        public let tags: [Tag]?

        public init(connectedDeviceId: String? = nil, connectedLinkId: String? = nil, connectionArn: String? = nil, connectionId: String? = nil, createdAt: Date? = nil, description: String? = nil, deviceId: String? = nil, globalNetworkId: String? = nil, linkId: String? = nil, state: ConnectionState? = nil, tags: [Tag]? = nil) {
            self.connectedDeviceId = connectedDeviceId
            self.connectedLinkId = connectedLinkId
            self.connectionArn = connectionArn
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.description = description
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case connectedDeviceId = "ConnectedDeviceId"
            case connectedLinkId = "ConnectedLinkId"
            case connectionArn = "ConnectionArn"
            case connectionId = "ConnectionId"
            case createdAt = "CreatedAt"
            case description = "Description"
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case linkId = "LinkId"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct ConnectionHealth: AWSDecodableShape {
        /// The connection status.
        public let status: ConnectionStatus?
        /// The time the status was last updated.
        public let timestamp: Date?
        /// The connection type.
        public let type: ConnectionType?

        public init(status: ConnectionStatus? = nil, timestamp: Date? = nil, type: ConnectionType? = nil) {
            self.status = status
            self.timestamp = timestamp
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case timestamp = "Timestamp"
            case type = "Type"
        }
    }

    public struct CoreNetwork: AWSDecodableShape {
        /// The ARN of a core network.
        public let coreNetworkArn: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when a core network was created.
        public let createdAt: Date?
        /// The description of a core network.
        public let description: String?
        /// The edges within a core network.
        public let edges: [CoreNetworkEdge]?
        /// The ID of the global network that your core network is a part of.
        public let globalNetworkId: String?
        /// The segments within a core network.
        public let segments: [CoreNetworkSegment]?
        /// The current state of a core network.
        public let state: CoreNetworkState?
        /// The list of key-value tags associated with a core network.
        public let tags: [Tag]?

        public init(coreNetworkArn: String? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, description: String? = nil, edges: [CoreNetworkEdge]? = nil, globalNetworkId: String? = nil, segments: [CoreNetworkSegment]? = nil, state: CoreNetworkState? = nil, tags: [Tag]? = nil) {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.edges = edges
            self.globalNetworkId = globalNetworkId
            self.segments = segments
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkArn = "CoreNetworkArn"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case description = "Description"
            case edges = "Edges"
            case globalNetworkId = "GlobalNetworkId"
            case segments = "Segments"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct CoreNetworkChange: AWSDecodableShape {
        /// The action to take for a core network.
        public let action: ChangeAction?
        /// The resource identifier.
        public let identifier: String?
        /// Uniquely identifies the path for a change within the changeset. For example, the IdentifierPath for a core network segment change might be "CORE_NETWORK_SEGMENT/us-east-1/devsegment".
        public let identifierPath: String?
        /// The new value for a core network
        public let newValues: CoreNetworkChangeValues?
        /// The previous values for a core network.
        public let previousValues: CoreNetworkChangeValues?
        /// The type of change.
        public let type: ChangeType?

        public init(action: ChangeAction? = nil, identifier: String? = nil, identifierPath: String? = nil, newValues: CoreNetworkChangeValues? = nil, previousValues: CoreNetworkChangeValues? = nil, type: ChangeType? = nil) {
            self.action = action
            self.identifier = identifier
            self.identifierPath = identifierPath
            self.newValues = newValues
            self.previousValues = previousValues
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case identifier = "Identifier"
            case identifierPath = "IdentifierPath"
            case newValues = "NewValues"
            case previousValues = "PreviousValues"
            case type = "Type"
        }
    }

    public struct CoreNetworkChangeEvent: AWSDecodableShape {
        /// The action taken for the change event.
        public let action: ChangeAction?
        /// The timestamp for an event change in status.
        public let eventTime: Date?
        /// Uniquely identifies the path for a change within the changeset. For example, the IdentifierPath for a core network segment change might be "CORE_NETWORK_SEGMENT/us-east-1/devsegment".
        public let identifierPath: String?
        /// The status of the core network change event.
        public let status: ChangeStatus?
        /// Describes the type of change event.
        public let type: ChangeType?
        /// Details of the change event.
        public let values: CoreNetworkChangeEventValues?

        public init(action: ChangeAction? = nil, eventTime: Date? = nil, identifierPath: String? = nil, status: ChangeStatus? = nil, type: ChangeType? = nil, values: CoreNetworkChangeEventValues? = nil) {
            self.action = action
            self.eventTime = eventTime
            self.identifierPath = identifierPath
            self.status = status
            self.type = type
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case eventTime = "EventTime"
            case identifierPath = "IdentifierPath"
            case status = "Status"
            case type = "Type"
            case values = "Values"
        }
    }

    public struct CoreNetworkChangeEventValues: AWSDecodableShape {
        /// The ID of the attachment if the change event is associated with an attachment.
        public let attachmentId: String?
        /// For a STATIC_ROUTE event, this is the IP address.
        public let cidr: String?
        /// The edge location for the core network change event.
        public let edgeLocation: String?
        /// The segment name if the change event is associated with a segment.
        public let segmentName: String?

        public init(attachmentId: String? = nil, cidr: String? = nil, edgeLocation: String? = nil, segmentName: String? = nil) {
            self.attachmentId = attachmentId
            self.cidr = cidr
            self.edgeLocation = edgeLocation
            self.segmentName = segmentName
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case cidr = "Cidr"
            case edgeLocation = "EdgeLocation"
            case segmentName = "SegmentName"
        }
    }

    public struct CoreNetworkChangeValues: AWSDecodableShape {
        /// The ASN of a core network.
        public let asn: Int64?
        /// The IP addresses used for a core network.
        public let cidr: String?
        /// The ID of the destination.
        public let destinationIdentifier: String?
        /// The Regions where edges are located in a core network.
        public let edgeLocations: [String]?
        /// The inside IP addresses used for core network change values.
        public let insideCidrBlocks: [String]?
        /// The names of the segments in a core network.
        public let segmentName: String?
        /// The shared segments for a core network change value.
        public let sharedSegments: [String]?

        public init(asn: Int64? = nil, cidr: String? = nil, destinationIdentifier: String? = nil, edgeLocations: [String]? = nil, insideCidrBlocks: [String]? = nil, segmentName: String? = nil, sharedSegments: [String]? = nil) {
            self.asn = asn
            self.cidr = cidr
            self.destinationIdentifier = destinationIdentifier
            self.edgeLocations = edgeLocations
            self.insideCidrBlocks = insideCidrBlocks
            self.segmentName = segmentName
            self.sharedSegments = sharedSegments
        }

        private enum CodingKeys: String, CodingKey {
            case asn = "Asn"
            case cidr = "Cidr"
            case destinationIdentifier = "DestinationIdentifier"
            case edgeLocations = "EdgeLocations"
            case insideCidrBlocks = "InsideCidrBlocks"
            case segmentName = "SegmentName"
            case sharedSegments = "SharedSegments"
        }
    }

    public struct CoreNetworkEdge: AWSDecodableShape {
        /// The ASN of a core network edge.
        public let asn: Int64?
        /// The Region where a core network edge is located.
        public let edgeLocation: String?
        /// The inside IP addresses used for core network edges.
        public let insideCidrBlocks: [String]?

        public init(asn: Int64? = nil, edgeLocation: String? = nil, insideCidrBlocks: [String]? = nil) {
            self.asn = asn
            self.edgeLocation = edgeLocation
            self.insideCidrBlocks = insideCidrBlocks
        }

        private enum CodingKeys: String, CodingKey {
            case asn = "Asn"
            case edgeLocation = "EdgeLocation"
            case insideCidrBlocks = "InsideCidrBlocks"
        }
    }

    public struct CoreNetworkPolicy: AWSDecodableShape {
        /// Whether a core network policy is the current LIVE policy or the most recently submitted policy.
        public let alias: CoreNetworkPolicyAlias?
        /// The state of a core network policy.
        public let changeSetState: ChangeSetState?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when a core network policy was created.
        public let createdAt: Date?
        /// The description of a core network policy.
        public let description: String?
        /// Describes a core network policy.
        public let policyDocument: String?
        /// Describes any errors in a core network policy.
        public let policyErrors: [CoreNetworkPolicyError]?
        /// The ID of the policy version.
        public let policyVersionId: Int?

        public init(alias: CoreNetworkPolicyAlias? = nil, changeSetState: ChangeSetState? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, description: String? = nil, policyDocument: String? = nil, policyErrors: [CoreNetworkPolicyError]? = nil, policyVersionId: Int? = nil) {
            self.alias = alias
            self.changeSetState = changeSetState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.policyDocument = policyDocument
            self.policyErrors = policyErrors
            self.policyVersionId = policyVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case changeSetState = "ChangeSetState"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case description = "Description"
            case policyDocument = "PolicyDocument"
            case policyErrors = "PolicyErrors"
            case policyVersionId = "PolicyVersionId"
        }
    }

    public struct CoreNetworkPolicyError: AWSDecodableShape {
        /// The error code associated with a core network policy error.
        public let errorCode: String
        /// The message associated with a core network policy error code.
        public let message: String
        /// The JSON path where the error was discovered in the policy document.
        public let path: String?

        public init(errorCode: String, message: String, path: String? = nil) {
            self.errorCode = errorCode
            self.message = message
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
            case path = "Path"
        }
    }

    public struct CoreNetworkPolicyVersion: AWSDecodableShape {
        /// Whether a core network policy is the current policy or the most recently submitted policy.
        public let alias: CoreNetworkPolicyAlias?
        /// The status of the policy version change set.
        public let changeSetState: ChangeSetState?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The timestamp when a core network policy version was created.
        public let createdAt: Date?
        /// The description of a core network policy version.
        public let description: String?
        /// The ID of the policy version.
        public let policyVersionId: Int?

        public init(alias: CoreNetworkPolicyAlias? = nil, changeSetState: ChangeSetState? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, description: String? = nil, policyVersionId: Int? = nil) {
            self.alias = alias
            self.changeSetState = changeSetState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.policyVersionId = policyVersionId
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case changeSetState = "ChangeSetState"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case description = "Description"
            case policyVersionId = "PolicyVersionId"
        }
    }

    public struct CoreNetworkSegment: AWSDecodableShape {
        /// The Regions where the edges are located.
        public let edgeLocations: [String]?
        /// The name of a core network segment.
        public let name: String?
        /// The shared segments of a core network.
        public let sharedSegments: [String]?

        public init(edgeLocations: [String]? = nil, name: String? = nil, sharedSegments: [String]? = nil) {
            self.edgeLocations = edgeLocations
            self.name = name
            self.sharedSegments = sharedSegments
        }

        private enum CodingKeys: String, CodingKey {
            case edgeLocations = "EdgeLocations"
            case name = "Name"
            case sharedSegments = "SharedSegments"
        }
    }

    public struct CoreNetworkSegmentEdgeIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The Region where the segment edge is located.
        public let edgeLocation: String?
        /// The name of the segment edge.
        public let segmentName: String?

        public init(coreNetworkId: String? = nil, edgeLocation: String? = nil, segmentName: String? = nil) {
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.segmentName = segmentName
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, max: 63)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, min: 1)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.segmentName, name: "segmentName", parent: name, max: 256)
            try self.validate(self.segmentName, name: "segmentName", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkId = "CoreNetworkId"
            case edgeLocation = "EdgeLocation"
            case segmentName = "SegmentName"
        }
    }

    public struct CoreNetworkSummary: AWSDecodableShape {
        /// a core network ARN.
        public let coreNetworkArn: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The description of a core network.
        public let description: String?
        /// The global network ID.
        public let globalNetworkId: String?
        /// The ID of the account owner.
        public let ownerAccountId: String?
        /// The state of a core network.
        public let state: CoreNetworkState?
        /// The key-value tags associated with a core network summary.
        public let tags: [Tag]?

        public init(coreNetworkArn: String? = nil, coreNetworkId: String? = nil, description: String? = nil, globalNetworkId: String? = nil, ownerAccountId: String? = nil, state: CoreNetworkState? = nil, tags: [Tag]? = nil) {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.ownerAccountId = ownerAccountId
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkArn = "CoreNetworkArn"
            case coreNetworkId = "CoreNetworkId"
            case description = "Description"
            case globalNetworkId = "GlobalNetworkId"
            case ownerAccountId = "OwnerAccountId"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct CreateConnectAttachmentRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of a core network where you want to create the attachment.
        public let coreNetworkId: String
        /// The Region where the edge is located.
        public let edgeLocation: String
        /// Options for creating an attachment.
        public let options: ConnectAttachmentOptions
        /// The list of key-value tags associated with the request.
        public let tags: [Tag]?
        /// The ID of the attachment between the two connections.
        public let transportAttachmentId: String

        public init(clientToken: String? = CreateConnectAttachmentRequest.idempotencyToken(), coreNetworkId: String, edgeLocation: String, options: ConnectAttachmentOptions, tags: [Tag]? = nil, transportAttachmentId: String) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.options = options
            self.tags = tags
            self.transportAttachmentId = transportAttachmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, max: 63)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, min: 1)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.transportAttachmentId, name: "transportAttachmentId", parent: name, max: 50)
            try self.validate(self.transportAttachmentId, name: "transportAttachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case coreNetworkId = "CoreNetworkId"
            case edgeLocation = "EdgeLocation"
            case options = "Options"
            case tags = "Tags"
            case transportAttachmentId = "TransportAttachmentId"
        }
    }

    public struct CreateConnectAttachmentResponse: AWSDecodableShape {
        /// The response to a Connect attachment request.
        public let connectAttachment: ConnectAttachment?

        public init(connectAttachment: ConnectAttachment? = nil) {
            self.connectAttachment = connectAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case connectAttachment = "ConnectAttachment"
        }
    }

    public struct CreateConnectPeerRequest: AWSEncodableShape {
        /// The Connect peer BGP options.
        public let bgpOptions: BgpOptions?
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of the connection attachment.
        public let connectAttachmentId: String
        /// A Connect peer core network address.
        public let coreNetworkAddress: String?
        /// The inside IP addresses used for BGP peering.
        public let insideCidrBlocks: [String]?
        /// The Connect peer address.
        public let peerAddress: String
        /// The subnet ARN for the Connect peer.
        public let subnetArn: String?
        /// The tags associated with the peer request.
        public let tags: [Tag]?

        public init(bgpOptions: BgpOptions? = nil, clientToken: String? = CreateConnectPeerRequest.idempotencyToken(), connectAttachmentId: String, coreNetworkAddress: String? = nil, insideCidrBlocks: [String]? = nil, peerAddress: String, subnetArn: String? = nil, tags: [Tag]? = nil) {
            self.bgpOptions = bgpOptions
            self.clientToken = clientToken
            self.connectAttachmentId = connectAttachmentId
            self.coreNetworkAddress = coreNetworkAddress
            self.insideCidrBlocks = insideCidrBlocks
            self.peerAddress = peerAddress
            self.subnetArn = subnetArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.connectAttachmentId, name: "connectAttachmentId", parent: name, max: 50)
            try self.validate(self.connectAttachmentId, name: "connectAttachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
            try self.validate(self.coreNetworkAddress, name: "coreNetworkAddress", parent: name, max: 50)
            try self.validate(self.coreNetworkAddress, name: "coreNetworkAddress", parent: name, min: 1)
            try self.validate(self.coreNetworkAddress, name: "coreNetworkAddress", parent: name, pattern: "^[\\s\\S]*$")
            try self.insideCidrBlocks?.forEach {
                try validate($0, name: "insideCidrBlocks[]", parent: name, max: 256)
                try validate($0, name: "insideCidrBlocks[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.peerAddress, name: "peerAddress", parent: name, max: 50)
            try self.validate(self.peerAddress, name: "peerAddress", parent: name, min: 1)
            try self.validate(self.peerAddress, name: "peerAddress", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.subnetArn, name: "subnetArn", parent: name, max: 500)
            try self.validate(self.subnetArn, name: "subnetArn", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:subnet\\/subnet-[0-9a-f]{8,17}$|^$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bgpOptions = "BgpOptions"
            case clientToken = "ClientToken"
            case connectAttachmentId = "ConnectAttachmentId"
            case coreNetworkAddress = "CoreNetworkAddress"
            case insideCidrBlocks = "InsideCidrBlocks"
            case peerAddress = "PeerAddress"
            case subnetArn = "SubnetArn"
            case tags = "Tags"
        }
    }

    public struct CreateConnectPeerResponse: AWSDecodableShape {
        /// The response to the request.
        public let connectPeer: ConnectPeer?

        public init(connectPeer: ConnectPeer? = nil) {
            self.connectPeer = connectPeer
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeer = "ConnectPeer"
        }
    }

    public struct CreateConnectionRequest: AWSEncodableShape {
        /// The ID of the second device in the connection.
        public let connectedDeviceId: String
        /// The ID of the link for the second device.
        public let connectedLinkId: String?
        /// A description of the connection. Length Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the first device in the connection.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link for the first device.
        public let linkId: String?
        /// The tags to apply to the resource during creation.
        public let tags: [Tag]?

        public init(connectedDeviceId: String, connectedLinkId: String? = nil, description: String? = nil, deviceId: String, globalNetworkId: String, linkId: String? = nil, tags: [Tag]? = nil) {
            self.connectedDeviceId = connectedDeviceId
            self.connectedLinkId = connectedLinkId
            self.description = description
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.connectedDeviceId, forKey: .connectedDeviceId)
            try container.encodeIfPresent(self.connectedLinkId, forKey: .connectedLinkId)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.deviceId, forKey: .deviceId)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.linkId, forKey: .linkId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectedDeviceId, name: "connectedDeviceId", parent: name, max: 50)
            try self.validate(self.connectedDeviceId, name: "connectedDeviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.connectedLinkId, name: "connectedLinkId", parent: name, max: 50)
            try self.validate(self.connectedLinkId, name: "connectedLinkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectedDeviceId = "ConnectedDeviceId"
            case connectedLinkId = "ConnectedLinkId"
            case description = "Description"
            case deviceId = "DeviceId"
            case linkId = "LinkId"
            case tags = "Tags"
        }
    }

    public struct CreateConnectionResponse: AWSDecodableShape {
        /// Information about the connection.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct CreateCoreNetworkRequest: AWSEncodableShape {
        /// The client token associated with a core network request.
        public let clientToken: String?
        /// The description of a core network.
        public let description: String?
        /// The ID of the global network that a core network will be a part of.
        public let globalNetworkId: String
        /// The policy document for creating a core network.
        public let policyDocument: String?
        /// Key-value tags associated with a core network request.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateCoreNetworkRequest.idempotencyToken(), description: String? = nil, globalNetworkId: String, policyDocument: String? = nil, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.policyDocument = policyDocument
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, max: 10000000)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case globalNetworkId = "GlobalNetworkId"
            case policyDocument = "PolicyDocument"
            case tags = "Tags"
        }
    }

    public struct CreateCoreNetworkResponse: AWSDecodableShape {
        /// Returns details about a core network.
        public let coreNetwork: CoreNetwork?

        public init(coreNetwork: CoreNetwork? = nil) {
            self.coreNetwork = coreNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetwork = "CoreNetwork"
        }
    }

    public struct CreateDeviceRequest: AWSEncodableShape {
        /// The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.
        public let awsLocation: AWSLocation?
        /// A description of the device. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The location of the device.
        public let location: Location?
        /// The model of the device. Constraints: Maximum length of 128 characters.
        public let model: String?
        /// The serial number of the device. Constraints: Maximum length of 128 characters.
        public let serialNumber: String?
        /// The ID of the site.
        public let siteId: String?
        /// The tags to apply to the resource during creation.
        public let tags: [Tag]?
        /// The type of the device.
        public let type: String?
        /// The vendor of the device. Constraints: Maximum length of 128 characters.
        public let vendor: String?

        public init(awsLocation: AWSLocation? = nil, description: String? = nil, globalNetworkId: String, location: Location? = nil, model: String? = nil, serialNumber: String? = nil, siteId: String? = nil, tags: [Tag]? = nil, type: String? = nil, vendor: String? = nil) {
            self.awsLocation = awsLocation
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.model = model
            self.serialNumber = serialNumber
            self.siteId = siteId
            self.tags = tags
            self.type = type
            self.vendor = vendor
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.awsLocation, forKey: .awsLocation)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.location, forKey: .location)
            try container.encodeIfPresent(self.model, forKey: .model)
            try container.encodeIfPresent(self.serialNumber, forKey: .serialNumber)
            try container.encodeIfPresent(self.siteId, forKey: .siteId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.type, forKey: .type)
            try container.encodeIfPresent(self.vendor, forKey: .vendor)
        }

        public func validate(name: String) throws {
            try self.awsLocation?.validate(name: "\(name).awsLocation")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.location?.validate(name: "\(name).location")
            try self.validate(self.model, name: "model", parent: name, max: 256)
            try self.validate(self.model, name: "model", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, max: 256)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.vendor, name: "vendor", parent: name, max: 256)
            try self.validate(self.vendor, name: "vendor", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsLocation = "AWSLocation"
            case description = "Description"
            case location = "Location"
            case model = "Model"
            case serialNumber = "SerialNumber"
            case siteId = "SiteId"
            case tags = "Tags"
            case type = "Type"
            case vendor = "Vendor"
        }
    }

    public struct CreateDeviceResponse: AWSDecodableShape {
        /// Information about the device.
        public let device: Device?

        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "Device"
        }
    }

    public struct CreateGlobalNetworkRequest: AWSEncodableShape {
        /// A description of the global network. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The tags to apply to the resource during creation.
        public let tags: [Tag]?

        public init(description: String? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case tags = "Tags"
        }
    }

    public struct CreateGlobalNetworkResponse: AWSDecodableShape {
        /// Information about the global network object.
        public let globalNetwork: GlobalNetwork?

        public init(globalNetwork: GlobalNetwork? = nil) {
            self.globalNetwork = globalNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case globalNetwork = "GlobalNetwork"
        }
    }

    public struct CreateLinkRequest: AWSEncodableShape {
        ///  The upload speed and download speed in Mbps.
        public let bandwidth: Bandwidth
        /// A description of the link. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The provider of the link. Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^
        public let provider: String?
        /// The ID of the site.
        public let siteId: String
        /// The tags to apply to the resource during creation.
        public let tags: [Tag]?
        /// The type of the link. Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^
        public let type: String?

        public init(bandwidth: Bandwidth, description: String? = nil, globalNetworkId: String, provider: String? = nil, siteId: String, tags: [Tag]? = nil, type: String? = nil) {
            self.bandwidth = bandwidth
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.provider = provider
            self.siteId = siteId
            self.tags = tags
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.bandwidth, forKey: .bandwidth)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.provider, forKey: .provider)
            try container.encode(self.siteId, forKey: .siteId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.provider, name: "provider", parent: name, max: 256)
            try self.validate(self.provider, name: "provider", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth = "Bandwidth"
            case description = "Description"
            case provider = "Provider"
            case siteId = "SiteId"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct CreateLinkResponse: AWSDecodableShape {
        /// Information about the link.
        public let link: Link?

        public init(link: Link? = nil) {
            self.link = link
        }

        private enum CodingKeys: String, CodingKey {
            case link = "Link"
        }
    }

    public struct CreateSiteRequest: AWSEncodableShape {
        /// A description of your site. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.    Address: The physical address of the site.    Latitude: The latitude of the site.     Longitude: The longitude of the site.
        public let location: Location?
        /// The tags to apply to the resource during creation.
        public let tags: [Tag]?

        public init(description: String? = nil, globalNetworkId: String, location: Location? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.location, forKey: .location)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.location?.validate(name: "\(name).location")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case location = "Location"
            case tags = "Tags"
        }
    }

    public struct CreateSiteResponse: AWSDecodableShape {
        /// Information about the site.
        public let site: Site?

        public init(site: Site? = nil) {
            self.site = site
        }

        private enum CodingKeys: String, CodingKey {
            case site = "Site"
        }
    }

    public struct CreateSiteToSiteVpnAttachmentRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of a core network where you're creating a site-to-site VPN attachment.
        public let coreNetworkId: String
        /// The tags associated with the request.
        public let tags: [Tag]?
        /// The ARN identifying the VPN attachment.
        public let vpnConnectionArn: String

        public init(clientToken: String? = CreateSiteToSiteVpnAttachmentRequest.idempotencyToken(), coreNetworkId: String, tags: [Tag]? = nil, vpnConnectionArn: String) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.tags = tags
            self.vpnConnectionArn = vpnConnectionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.vpnConnectionArn, name: "vpnConnectionArn", parent: name, max: 500)
            try self.validate(self.vpnConnectionArn, name: "vpnConnectionArn", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:vpn-connection\\/vpn-[0-9a-f]{8,17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case coreNetworkId = "CoreNetworkId"
            case tags = "Tags"
            case vpnConnectionArn = "VpnConnectionArn"
        }
    }

    public struct CreateSiteToSiteVpnAttachmentResponse: AWSDecodableShape {
        /// Details about a site-to-site VPN attachment.
        public let siteToSiteVpnAttachment: SiteToSiteVpnAttachment?

        public init(siteToSiteVpnAttachment: SiteToSiteVpnAttachment? = nil) {
            self.siteToSiteVpnAttachment = siteToSiteVpnAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case siteToSiteVpnAttachment = "SiteToSiteVpnAttachment"
        }
    }

    public struct CreateTransitGatewayPeeringRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The list of key-value tags associated with the request.
        public let tags: [Tag]?
        /// The ARN of the transit gateway for the peering request.
        public let transitGatewayArn: String

        public init(clientToken: String? = CreateTransitGatewayPeeringRequest.idempotencyToken(), coreNetworkId: String, tags: [Tag]? = nil, transitGatewayArn: String) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.tags = tags
            self.transitGatewayArn = transitGatewayArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, max: 500)
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case coreNetworkId = "CoreNetworkId"
            case tags = "Tags"
            case transitGatewayArn = "TransitGatewayArn"
        }
    }

    public struct CreateTransitGatewayPeeringResponse: AWSDecodableShape {
        /// Returns information about the transit gateway peering connection request.
        public let transitGatewayPeering: TransitGatewayPeering?

        public init(transitGatewayPeering: TransitGatewayPeering? = nil) {
            self.transitGatewayPeering = transitGatewayPeering
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayPeering = "TransitGatewayPeering"
        }
    }

    public struct CreateTransitGatewayRouteTableAttachmentRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of the peer for the
        public let peeringId: String
        /// The list of key-value tags associated with the request.
        public let tags: [Tag]?
        /// The ARN of the transit gateway route table for the attachment request. For example, "TransitGatewayRouteTableArn": "arn:aws:ec2:us-west-2:123456789012:transit-gateway-route-table/tgw-rtb-9876543210123456".
        public let transitGatewayRouteTableArn: String

        public init(clientToken: String? = CreateTransitGatewayRouteTableAttachmentRequest.idempotencyToken(), peeringId: String, tags: [Tag]? = nil, transitGatewayRouteTableArn: String) {
            self.clientToken = clientToken
            self.peeringId = peeringId
            self.tags = tags
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.peeringId, name: "peeringId", parent: name, max: 50)
            try self.validate(self.peeringId, name: "peeringId", parent: name, pattern: "^peering-([0-9a-f]{8,17})$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.transitGatewayRouteTableArn, name: "transitGatewayRouteTableArn", parent: name, max: 500)
            try self.validate(self.transitGatewayRouteTableArn, name: "transitGatewayRouteTableArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case peeringId = "PeeringId"
            case tags = "Tags"
            case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
        }
    }

    public struct CreateTransitGatewayRouteTableAttachmentResponse: AWSDecodableShape {
        /// The route table associated with the create transit gateway route table attachment request.
        public let transitGatewayRouteTableAttachment: TransitGatewayRouteTableAttachment?

        public init(transitGatewayRouteTableAttachment: TransitGatewayRouteTableAttachment? = nil) {
            self.transitGatewayRouteTableAttachment = transitGatewayRouteTableAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayRouteTableAttachment = "TransitGatewayRouteTableAttachment"
        }
    }

    public struct CreateVpcAttachmentRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of a core network for the VPC attachment.
        public let coreNetworkId: String
        /// Options for the VPC attachment.
        public let options: VpcOptions?
        /// The subnet ARN of the VPC attachment.
        public let subnetArns: [String]
        /// The key-value tags associated with the request.
        public let tags: [Tag]?
        /// The ARN of the VPC.
        public let vpcArn: String

        public init(clientToken: String? = CreateVpcAttachmentRequest.idempotencyToken(), coreNetworkId: String, options: VpcOptions? = nil, subnetArns: [String], tags: [Tag]? = nil, vpcArn: String) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.options = options
            self.subnetArns = subnetArns
            self.tags = tags
            self.vpcArn = vpcArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.subnetArns.forEach {
                try validate($0, name: "subnetArns[]", parent: name, max: 500)
                try validate($0, name: "subnetArns[]", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:subnet\\/subnet-[0-9a-f]{8,17}$|^$")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.vpcArn, name: "vpcArn", parent: name, max: 500)
            try self.validate(self.vpcArn, name: "vpcArn", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:vpc\\/vpc-[0-9a-f]{8,17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case coreNetworkId = "CoreNetworkId"
            case options = "Options"
            case subnetArns = "SubnetArns"
            case tags = "Tags"
            case vpcArn = "VpcArn"
        }
    }

    public struct CreateVpcAttachmentResponse: AWSDecodableShape {
        /// Provides details about the VPC attachment.
        public let vpcAttachment: VpcAttachment?

        public init(vpcAttachment: VpcAttachment? = nil) {
            self.vpcAttachment = vpcAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case vpcAttachment = "VpcAttachment"
        }
    }

    public struct CustomerGatewayAssociation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the customer gateway.
        public let customerGatewayArn: String?
        /// The ID of the device.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The ID of the link.
        public let linkId: String?
        /// The association state.
        public let state: CustomerGatewayAssociationState?

        public init(customerGatewayArn: String? = nil, deviceId: String? = nil, globalNetworkId: String? = nil, linkId: String? = nil, state: CustomerGatewayAssociationState? = nil) {
            self.customerGatewayArn = customerGatewayArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case customerGatewayArn = "CustomerGatewayArn"
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case linkId = "LinkId"
            case state = "State"
        }
    }

    public struct DeleteAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment to delete.
        public let attachmentId: String

        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAttachmentResponse: AWSDecodableShape {
        /// Information about the deleted attachment.
        public let attachment: Attachment?

        public init(attachment: Attachment? = nil) {
            self.attachment = attachment
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
        }
    }

    public struct DeleteConnectPeerRequest: AWSEncodableShape {
        /// The ID of the deleted Connect peer.
        public let connectPeerId: String

        public init(connectPeerId: String) {
            self.connectPeerId = connectPeerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectPeerId, key: "ConnectPeerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, max: 50)
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, pattern: "^connect-peer-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectPeerResponse: AWSDecodableShape {
        /// Information about the deleted Connect peer.
        public let connectPeer: ConnectPeer?

        public init(connectPeer: ConnectPeer? = nil) {
            self.connectPeer = connectPeer
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeer = "ConnectPeer"
        }
    }

    public struct DeleteConnectionRequest: AWSEncodableShape {
        /// The ID of the connection.
        public let connectionId: String
        /// The ID of the global network.
        public let globalNetworkId: String

        public init(connectionId: String, globalNetworkId: String) {
            self.connectionId = connectionId
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectionId, key: "ConnectionId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 50)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectionResponse: AWSDecodableShape {
        /// Information about the connection.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DeleteCoreNetworkPolicyVersionRequest: AWSEncodableShape {
        /// The ID of a core network for the deleted policy.
        public let coreNetworkId: String
        /// The version ID of the deleted policy.
        public let policyVersionId: Int

        public init(coreNetworkId: String, policyVersionId: Int) {
            self.coreNetworkId = coreNetworkId
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodePath(self.policyVersionId, key: "PolicyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCoreNetworkPolicyVersionResponse: AWSDecodableShape {
        /// Returns information about the deleted policy version.
        public let coreNetworkPolicy: CoreNetworkPolicy?

        public init(coreNetworkPolicy: CoreNetworkPolicy? = nil) {
            self.coreNetworkPolicy = coreNetworkPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkPolicy = "CoreNetworkPolicy"
        }
    }

    public struct DeleteCoreNetworkRequest: AWSEncodableShape {
        /// The network ID of the deleted core network.
        public let coreNetworkId: String

        public init(coreNetworkId: String) {
            self.coreNetworkId = coreNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCoreNetworkResponse: AWSDecodableShape {
        /// Information about the deleted core network.
        public let coreNetwork: CoreNetwork?

        public init(coreNetwork: CoreNetwork? = nil) {
            self.coreNetwork = coreNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetwork = "CoreNetwork"
        }
    }

    public struct DeleteDeviceRequest: AWSEncodableShape {
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String

        public init(deviceId: String, globalNetworkId: String) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.deviceId, key: "DeviceId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDeviceResponse: AWSDecodableShape {
        /// Information about the device.
        public let device: Device?

        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "Device"
        }
    }

    public struct DeleteGlobalNetworkRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String

        public init(globalNetworkId: String) {
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGlobalNetworkResponse: AWSDecodableShape {
        /// Information about the global network.
        public let globalNetwork: GlobalNetwork?

        public init(globalNetwork: GlobalNetwork? = nil) {
            self.globalNetwork = globalNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case globalNetwork = "GlobalNetwork"
        }
    }

    public struct DeleteLinkRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String

        public init(globalNetworkId: String, linkId: String) {
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.linkId, key: "LinkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLinkResponse: AWSDecodableShape {
        /// Information about the link.
        public let link: Link?

        public init(link: Link? = nil) {
            self.link = link
        }

        private enum CodingKeys: String, CodingKey {
            case link = "Link"
        }
    }

    public struct DeletePeeringRequest: AWSEncodableShape {
        /// The ID of the peering connection to delete.
        public let peeringId: String

        public init(peeringId: String) {
            self.peeringId = peeringId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.peeringId, key: "PeeringId")
        }

        public func validate(name: String) throws {
            try self.validate(self.peeringId, name: "peeringId", parent: name, max: 50)
            try self.validate(self.peeringId, name: "peeringId", parent: name, pattern: "^peering-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePeeringResponse: AWSDecodableShape {
        /// Information about a deleted peering connection.
        public let peering: Peering?

        public init(peering: Peering? = nil) {
            self.peering = peering
        }

        private enum CodingKeys: String, CodingKey {
            case peering = "Peering"
        }
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The ARN of the policy to delete.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSiteRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the site.
        public let siteId: String

        public init(globalNetworkId: String, siteId: String) {
            self.globalNetworkId = globalNetworkId
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.siteId, key: "SiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSiteResponse: AWSDecodableShape {
        /// Information about the site.
        public let site: Site?

        public init(site: Site? = nil) {
            self.site = site
        }

        private enum CodingKeys: String, CodingKey {
            case site = "Site"
        }
    }

    public struct DeregisterTransitGatewayRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The Amazon Resource Name (ARN) of the transit gateway.
        public let transitGatewayArn: String

        public init(globalNetworkId: String, transitGatewayArn: String) {
            self.globalNetworkId = globalNetworkId
            self.transitGatewayArn = transitGatewayArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.transitGatewayArn, key: "TransitGatewayArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, max: 500)
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeregisterTransitGatewayResponse: AWSDecodableShape {
        /// The transit gateway registration information.
        public let transitGatewayRegistration: TransitGatewayRegistration?

        public init(transitGatewayRegistration: TransitGatewayRegistration? = nil) {
            self.transitGatewayRegistration = transitGatewayRegistration
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayRegistration = "TransitGatewayRegistration"
        }
    }

    public struct DescribeGlobalNetworksRequest: AWSEncodableShape {
        /// The IDs of one or more global networks. The maximum is 10.
        public let globalNetworkIds: [String]?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(globalNetworkIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.globalNetworkIds = globalNetworkIds
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.globalNetworkIds, key: "globalNetworkIds")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.globalNetworkIds?.forEach {
                try validate($0, name: "globalNetworkIds[]", parent: name, max: 50)
                try validate($0, name: "globalNetworkIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGlobalNetworksResponse: AWSDecodableShape {
        /// Information about the global networks.
        public let globalNetworks: [GlobalNetwork]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(globalNetworks: [GlobalNetwork]? = nil, nextToken: String? = nil) {
            self.globalNetworks = globalNetworks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case globalNetworks = "GlobalNetworks"
            case nextToken = "NextToken"
        }
    }

    public struct Device: AWSDecodableShape {
        /// The Amazon Web Services location of the device.
        public let awsLocation: AWSLocation?
        /// The date and time that the site was created.
        public let createdAt: Date?
        /// The description of the device.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the device.
        public let deviceArn: String?
        /// The ID of the device.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The site location.
        public let location: Location?
        /// The device model.
        public let model: String?
        /// The device serial number.
        public let serialNumber: String?
        /// The site ID.
        public let siteId: String?
        /// The device state.
        public let state: DeviceState?
        /// The tags for the device.
        public let tags: [Tag]?
        /// The device type.
        public let type: String?
        /// The device vendor.
        public let vendor: String?

        public init(awsLocation: AWSLocation? = nil, createdAt: Date? = nil, description: String? = nil, deviceArn: String? = nil, deviceId: String? = nil, globalNetworkId: String? = nil, location: Location? = nil, model: String? = nil, serialNumber: String? = nil, siteId: String? = nil, state: DeviceState? = nil, tags: [Tag]? = nil, type: String? = nil, vendor: String? = nil) {
            self.awsLocation = awsLocation
            self.createdAt = createdAt
            self.description = description
            self.deviceArn = deviceArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.model = model
            self.serialNumber = serialNumber
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
            self.vendor = vendor
        }

        private enum CodingKeys: String, CodingKey {
            case awsLocation = "AWSLocation"
            case createdAt = "CreatedAt"
            case description = "Description"
            case deviceArn = "DeviceArn"
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case location = "Location"
            case model = "Model"
            case serialNumber = "SerialNumber"
            case siteId = "SiteId"
            case state = "State"
            case tags = "Tags"
            case type = "Type"
            case vendor = "Vendor"
        }
    }

    public struct DisassociateConnectPeerRequest: AWSEncodableShape {
        /// The ID of the Connect peer to disassociate from a device.
        public let connectPeerId: String
        /// The ID of the global network.
        public let globalNetworkId: String

        public init(connectPeerId: String, globalNetworkId: String) {
            self.connectPeerId = connectPeerId
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectPeerId, key: "ConnectPeerId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, max: 50)
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, pattern: "^connect-peer-([0-9a-f]{8,17})$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateConnectPeerResponse: AWSDecodableShape {
        /// Describes the Connect peer association.
        public let connectPeerAssociation: ConnectPeerAssociation?

        public init(connectPeerAssociation: ConnectPeerAssociation? = nil) {
            self.connectPeerAssociation = connectPeerAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeerAssociation = "ConnectPeerAssociation"
        }
    }

    public struct DisassociateCustomerGatewayRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the customer gateway.
        public let customerGatewayArn: String
        /// The ID of the global network.
        public let globalNetworkId: String

        public init(customerGatewayArn: String, globalNetworkId: String) {
            self.customerGatewayArn = customerGatewayArn
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.customerGatewayArn, key: "CustomerGatewayArn")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.customerGatewayArn, name: "customerGatewayArn", parent: name, max: 500)
            try self.validate(self.customerGatewayArn, name: "customerGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateCustomerGatewayResponse: AWSDecodableShape {
        /// Information about the customer gateway association.
        public let customerGatewayAssociation: CustomerGatewayAssociation?

        public init(customerGatewayAssociation: CustomerGatewayAssociation? = nil) {
            self.customerGatewayAssociation = customerGatewayAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case customerGatewayAssociation = "CustomerGatewayAssociation"
        }
    }

    public struct DisassociateLinkRequest: AWSEncodableShape {
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String

        public init(deviceId: String, globalNetworkId: String, linkId: String) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deviceId, key: "deviceId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.linkId, key: "linkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateLinkResponse: AWSDecodableShape {
        /// Information about the link association.
        public let linkAssociation: LinkAssociation?

        public init(linkAssociation: LinkAssociation? = nil) {
            self.linkAssociation = linkAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case linkAssociation = "LinkAssociation"
        }
    }

    public struct DisassociateTransitGatewayConnectPeerRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
        public let transitGatewayConnectPeerArn: String

        public init(globalNetworkId: String, transitGatewayConnectPeerArn: String) {
            self.globalNetworkId = globalNetworkId
            self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.transitGatewayConnectPeerArn, key: "TransitGatewayConnectPeerArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.transitGatewayConnectPeerArn, name: "transitGatewayConnectPeerArn", parent: name, max: 500)
            try self.validate(self.transitGatewayConnectPeerArn, name: "transitGatewayConnectPeerArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateTransitGatewayConnectPeerResponse: AWSDecodableShape {
        /// The transit gateway Connect peer association.
        public let transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation?

        public init(transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation? = nil) {
            self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
        }
    }

    public struct ExecuteCoreNetworkChangeSetRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The ID of the policy version.
        public let policyVersionId: Int

        public init(coreNetworkId: String, policyVersionId: Int) {
            self.coreNetworkId = coreNetworkId
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodePath(self.policyVersionId, key: "PolicyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExecuteCoreNetworkChangeSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GetConnectAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let attachmentId: String

        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectAttachmentResponse: AWSDecodableShape {
        /// Details about the Connect attachment.
        public let connectAttachment: ConnectAttachment?

        public init(connectAttachment: ConnectAttachment? = nil) {
            self.connectAttachment = connectAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case connectAttachment = "ConnectAttachment"
        }
    }

    public struct GetConnectPeerAssociationsRequest: AWSEncodableShape {
        /// The IDs of the Connect peers.
        public let connectPeerIds: [String]?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(connectPeerIds: [String]? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectPeerIds = connectPeerIds
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectPeerIds, key: "connectPeerIds")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.connectPeerIds?.forEach {
                try validate($0, name: "connectPeerIds[]", parent: name, max: 50)
                try validate($0, name: "connectPeerIds[]", parent: name, pattern: "^connect-peer-([0-9a-f]{8,17})$")
            }
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectPeerAssociationsResponse: AWSDecodableShape {
        /// Displays a list of Connect peer associations.
        public let connectPeerAssociations: [ConnectPeerAssociation]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(connectPeerAssociations: [ConnectPeerAssociation]? = nil, nextToken: String? = nil) {
            self.connectPeerAssociations = connectPeerAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeerAssociations = "ConnectPeerAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct GetConnectPeerRequest: AWSEncodableShape {
        /// The ID of the Connect peer.
        public let connectPeerId: String

        public init(connectPeerId: String) {
            self.connectPeerId = connectPeerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectPeerId, key: "ConnectPeerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, max: 50)
            try self.validate(self.connectPeerId, name: "connectPeerId", parent: name, pattern: "^connect-peer-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectPeerResponse: AWSDecodableShape {
        /// Returns information about a core network Connect peer.
        public let connectPeer: ConnectPeer?

        public init(connectPeer: ConnectPeer? = nil) {
            self.connectPeer = connectPeer
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeer = "ConnectPeer"
        }
    }

    public struct GetConnectionsRequest: AWSEncodableShape {
        /// One or more connection IDs.
        public let connectionIds: [String]?
        /// The ID of the device.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(connectionIds: [String]? = nil, deviceId: String? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectionIds = connectionIds
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectionIds, key: "connectionIds")
            request.encodeQuery(self.deviceId, key: "deviceId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.connectionIds?.forEach {
                try validate($0, name: "connectionIds[]", parent: name, max: 50)
                try validate($0, name: "connectionIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectionsResponse: AWSDecodableShape {
        /// Information about the connections.
        public let connections: [Connection]?
        /// The token to use for the next page of results.
        public let nextToken: String?

        public init(connections: [Connection]? = nil, nextToken: String? = nil) {
            self.connections = connections
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case nextToken = "NextToken"
        }
    }

    public struct GetCoreNetworkChangeEventsRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ID of the policy version.
        public let policyVersionId: Int

        public init(coreNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, policyVersionId: Int) {
            self.coreNetworkId = coreNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.policyVersionId, key: "PolicyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCoreNetworkChangeEventsResponse: AWSDecodableShape {
        /// The response to GetCoreNetworkChangeEventsRequest.
        public let coreNetworkChangeEvents: [CoreNetworkChangeEvent]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(coreNetworkChangeEvents: [CoreNetworkChangeEvent]? = nil, nextToken: String? = nil) {
            self.coreNetworkChangeEvents = coreNetworkChangeEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkChangeEvents = "CoreNetworkChangeEvents"
            case nextToken = "NextToken"
        }
    }

    public struct GetCoreNetworkChangeSetRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ID of the policy version.
        public let policyVersionId: Int

        public init(coreNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, policyVersionId: Int) {
            self.coreNetworkId = coreNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.policyVersionId, key: "PolicyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCoreNetworkChangeSetResponse: AWSDecodableShape {
        /// Describes a core network changes.
        public let coreNetworkChanges: [CoreNetworkChange]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(coreNetworkChanges: [CoreNetworkChange]? = nil, nextToken: String? = nil) {
            self.coreNetworkChanges = coreNetworkChanges
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkChanges = "CoreNetworkChanges"
            case nextToken = "NextToken"
        }
    }

    public struct GetCoreNetworkPolicyRequest: AWSEncodableShape {
        /// The alias of a core network policy
        public let alias: CoreNetworkPolicyAlias?
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The ID of a core network policy version.
        public let policyVersionId: Int?

        public init(alias: CoreNetworkPolicyAlias? = nil, coreNetworkId: String, policyVersionId: Int? = nil) {
            self.alias = alias
            self.coreNetworkId = coreNetworkId
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodeQuery(self.policyVersionId, key: "policyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCoreNetworkPolicyResponse: AWSDecodableShape {
        /// The details about a core network policy.
        public let coreNetworkPolicy: CoreNetworkPolicy?

        public init(coreNetworkPolicy: CoreNetworkPolicy? = nil) {
            self.coreNetworkPolicy = coreNetworkPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkPolicy = "CoreNetworkPolicy"
        }
    }

    public struct GetCoreNetworkRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String

        public init(coreNetworkId: String) {
            self.coreNetworkId = coreNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCoreNetworkResponse: AWSDecodableShape {
        /// Details about a core network.
        public let coreNetwork: CoreNetwork?

        public init(coreNetwork: CoreNetwork? = nil) {
            self.coreNetwork = coreNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetwork = "CoreNetwork"
        }
    }

    public struct GetCustomerGatewayAssociationsRequest: AWSEncodableShape {
        /// One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.
        public let customerGatewayArns: [String]?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(customerGatewayArns: [String]? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.customerGatewayArns = customerGatewayArns
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.customerGatewayArns, key: "customerGatewayArns")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.customerGatewayArns?.forEach {
                try validate($0, name: "customerGatewayArns[]", parent: name, max: 500)
                try validate($0, name: "customerGatewayArns[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCustomerGatewayAssociationsResponse: AWSDecodableShape {
        /// The customer gateway associations.
        public let customerGatewayAssociations: [CustomerGatewayAssociation]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(customerGatewayAssociations: [CustomerGatewayAssociation]? = nil, nextToken: String? = nil) {
            self.customerGatewayAssociations = customerGatewayAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case customerGatewayAssociations = "CustomerGatewayAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct GetDevicesRequest: AWSEncodableShape {
        /// One or more device IDs. The maximum is 10.
        public let deviceIds: [String]?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ID of the site.
        public let siteId: String?

        public init(deviceIds: [String]? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, siteId: String? = nil) {
            self.deviceIds = deviceIds
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deviceIds, key: "deviceIds")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.siteId, key: "siteId")
        }

        public func validate(name: String) throws {
            try self.deviceIds?.forEach {
                try validate($0, name: "deviceIds[]", parent: name, max: 50)
                try validate($0, name: "deviceIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDevicesResponse: AWSDecodableShape {
        /// The devices.
        public let devices: [Device]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(devices: [Device]? = nil, nextToken: String? = nil) {
            self.devices = devices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "Devices"
            case nextToken = "NextToken"
        }
    }

    public struct GetLinkAssociationsRequest: AWSEncodableShape {
        /// The ID of the device.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(deviceId: String? = nil, globalNetworkId: String, linkId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.deviceId, key: "deviceId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.linkId, key: "linkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLinkAssociationsResponse: AWSDecodableShape {
        /// The link associations.
        public let linkAssociations: [LinkAssociation]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(linkAssociations: [LinkAssociation]? = nil, nextToken: String? = nil) {
            self.linkAssociations = linkAssociations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case linkAssociations = "LinkAssociations"
            case nextToken = "NextToken"
        }
    }

    public struct GetLinksRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// One or more link IDs. The maximum is 10.
        public let linkIds: [String]?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The link provider.
        public let provider: String?
        /// The ID of the site.
        public let siteId: String?
        /// The link type.
        public let type: String?

        public init(globalNetworkId: String, linkIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, provider: String? = nil, siteId: String? = nil, type: String? = nil) {
            self.globalNetworkId = globalNetworkId
            self.linkIds = linkIds
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.provider = provider
            self.siteId = siteId
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.linkIds, key: "linkIds")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.provider, key: "provider")
            request.encodeQuery(self.siteId, key: "siteId")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.linkIds?.forEach {
                try validate($0, name: "linkIds[]", parent: name, max: 50)
                try validate($0, name: "linkIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.provider, name: "provider", parent: name, max: 256)
            try self.validate(self.provider, name: "provider", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLinksResponse: AWSDecodableShape {
        /// The links.
        public let links: [Link]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(links: [Link]? = nil, nextToken: String? = nil) {
            self.links = links
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case links = "Links"
            case nextToken = "NextToken"
        }
    }

    public struct GetNetworkResourceCountsRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The resource type. The following are the supported resource types for Direct Connect:    dxcon     dx-gateway     dx-vif    The following are the supported resource types for Network Manager:    connection     device     link     site    The following are the supported resource types for Amazon VPC:    customer-gateway     transit-gateway     transit-gateway-attachment     transit-gateway-connect-peer     transit-gateway-route-table     vpn-connection
        public let resourceType: String?

        public init(globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, resourceType: String? = nil) {
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkResourceCountsResponse: AWSDecodableShape {
        /// The count of resources.
        public let networkResourceCounts: [NetworkResourceCount]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(networkResourceCounts: [NetworkResourceCount]? = nil, nextToken: String? = nil) {
            self.networkResourceCounts = networkResourceCounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkResourceCounts = "NetworkResourceCounts"
            case nextToken = "NextToken"
        }
    }

    public struct GetNetworkResourceRelationshipsRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The Amazon Web Services Region.
        public let awsRegion: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ARN of the registered gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the gateway.
        public let resourceArn: String?
        /// The resource type. The following are the supported resource types for Direct Connect:    dxcon     dx-gateway     dx-vif    The following are the supported resource types for Network Manager:    connection     device     link     site    The following are the supported resource types for Amazon VPC:    customer-gateway     transit-gateway     transit-gateway-attachment     transit-gateway-connect-peer     transit-gateway-route-table     vpn-connection
        public let resourceType: String?

        public init(accountId: String? = nil, awsRegion: String? = nil, coreNetworkId: String? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "accountId")
            request.encodeQuery(self.awsRegion, key: "awsRegion")
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.registeredGatewayArn, key: "registeredGatewayArn")
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 63)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, max: 1500)
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkResourceRelationshipsResponse: AWSDecodableShape {
        /// The token for the next page of results.
        public let nextToken: String?
        /// The resource relationships.
        public let relationships: [Relationship]?

        public init(nextToken: String? = nil, relationships: [Relationship]? = nil) {
            self.nextToken = nextToken
            self.relationships = relationships
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case relationships = "Relationships"
        }
    }

    public struct GetNetworkResourcesRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The Amazon Web Services Region.
        public let awsRegion: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ARN of the gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the resource.
        public let resourceArn: String?
        /// The resource type. The following are the supported resource types for Direct Connect:    dxcon - The definition model is Connection.    dx-gateway - The definition model is DirectConnectGateway.    dx-vif - The definition model is VirtualInterface.   The following are the supported resource types for Network Manager:    connection - The definition model is Connection.    device - The definition model is Device.    link - The definition model is Link.    site - The definition model is Site.   The following are the supported resource types for Amazon VPC:    customer-gateway - The definition model is CustomerGateway.    transit-gateway - The definition model is TransitGateway.    transit-gateway-attachment - The definition model is TransitGatewayAttachment.    transit-gateway-connect-peer - The definition model is TransitGatewayConnectPeer.    transit-gateway-route-table - The definition model is TransitGatewayRouteTable.    vpn-connection - The definition model is VpnConnection.
        public let resourceType: String?

        public init(accountId: String? = nil, awsRegion: String? = nil, coreNetworkId: String? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "accountId")
            request.encodeQuery(self.awsRegion, key: "awsRegion")
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.registeredGatewayArn, key: "registeredGatewayArn")
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 63)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, max: 1500)
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkResourcesResponse: AWSDecodableShape {
        /// The network resources.
        public let networkResources: [NetworkResource]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(networkResources: [NetworkResource]? = nil, nextToken: String? = nil) {
            self.networkResources = networkResources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkResources = "NetworkResources"
            case nextToken = "NextToken"
        }
    }

    public struct GetNetworkRoutesRequest: AWSEncodableShape {
        /// Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.
        public let destinationFilters: [String: [String]]?
        /// An exact CIDR block.
        public let exactCidrMatches: [String]?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The most specific route that matches the traffic (longest prefix match).
        public let longestPrefixMatches: [String]?
        /// The IDs of the prefix lists.
        public let prefixListIds: [String]?
        /// The ID of the route table.
        public let routeTableIdentifier: RouteTableIdentifier
        /// The route states.
        public let states: [RouteState]?
        /// The routes with a subnet that match the specified CIDR filter.
        public let subnetOfMatches: [String]?
        /// The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.
        public let supernetOfMatches: [String]?
        /// The route types.
        public let types: [RouteType]?

        public init(destinationFilters: [String: [String]]? = nil, exactCidrMatches: [String]? = nil, globalNetworkId: String, longestPrefixMatches: [String]? = nil, prefixListIds: [String]? = nil, routeTableIdentifier: RouteTableIdentifier, states: [RouteState]? = nil, subnetOfMatches: [String]? = nil, supernetOfMatches: [String]? = nil, types: [RouteType]? = nil) {
            self.destinationFilters = destinationFilters
            self.exactCidrMatches = exactCidrMatches
            self.globalNetworkId = globalNetworkId
            self.longestPrefixMatches = longestPrefixMatches
            self.prefixListIds = prefixListIds
            self.routeTableIdentifier = routeTableIdentifier
            self.states = states
            self.subnetOfMatches = subnetOfMatches
            self.supernetOfMatches = supernetOfMatches
            self.types = types
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.destinationFilters, forKey: .destinationFilters)
            try container.encodeIfPresent(self.exactCidrMatches, forKey: .exactCidrMatches)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.longestPrefixMatches, forKey: .longestPrefixMatches)
            try container.encodeIfPresent(self.prefixListIds, forKey: .prefixListIds)
            try container.encode(self.routeTableIdentifier, forKey: .routeTableIdentifier)
            try container.encodeIfPresent(self.states, forKey: .states)
            try container.encodeIfPresent(self.subnetOfMatches, forKey: .subnetOfMatches)
            try container.encodeIfPresent(self.supernetOfMatches, forKey: .supernetOfMatches)
            try container.encodeIfPresent(self.types, forKey: .types)
        }

        public func validate(name: String) throws {
            try self.destinationFilters?.forEach {
                try validate($0.key, name: "destinationFilters.key", parent: name, max: 128)
                try validate($0.key, name: "destinationFilters.key", parent: name, pattern: "^[0-9a-zA-Z\\.-]*$")
            }
            try self.exactCidrMatches?.forEach {
                try validate($0, name: "exactCidrMatches[]", parent: name, max: 256)
                try validate($0, name: "exactCidrMatches[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.longestPrefixMatches?.forEach {
                try validate($0, name: "longestPrefixMatches[]", parent: name, max: 256)
                try validate($0, name: "longestPrefixMatches[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.prefixListIds?.forEach {
                try validate($0, name: "prefixListIds[]", parent: name, max: 256)
                try validate($0, name: "prefixListIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.routeTableIdentifier.validate(name: "\(name).routeTableIdentifier")
            try self.subnetOfMatches?.forEach {
                try validate($0, name: "subnetOfMatches[]", parent: name, max: 256)
                try validate($0, name: "subnetOfMatches[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.supernetOfMatches?.forEach {
                try validate($0, name: "supernetOfMatches[]", parent: name, max: 256)
                try validate($0, name: "supernetOfMatches[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case destinationFilters = "DestinationFilters"
            case exactCidrMatches = "ExactCidrMatches"
            case longestPrefixMatches = "LongestPrefixMatches"
            case prefixListIds = "PrefixListIds"
            case routeTableIdentifier = "RouteTableIdentifier"
            case states = "States"
            case subnetOfMatches = "SubnetOfMatches"
            case supernetOfMatches = "SupernetOfMatches"
            case types = "Types"
        }
    }

    public struct GetNetworkRoutesResponse: AWSDecodableShape {
        /// Describes a core network segment edge.
        public let coreNetworkSegmentEdge: CoreNetworkSegmentEdgeIdentifier?
        /// The network routes.
        public let networkRoutes: [NetworkRoute]?
        /// The ARN of the route table.
        public let routeTableArn: String?
        /// The route table creation time.
        public let routeTableTimestamp: Date?
        /// The route table type.
        public let routeTableType: RouteTableType?

        public init(coreNetworkSegmentEdge: CoreNetworkSegmentEdgeIdentifier? = nil, networkRoutes: [NetworkRoute]? = nil, routeTableArn: String? = nil, routeTableTimestamp: Date? = nil, routeTableType: RouteTableType? = nil) {
            self.coreNetworkSegmentEdge = coreNetworkSegmentEdge
            self.networkRoutes = networkRoutes
            self.routeTableArn = routeTableArn
            self.routeTableTimestamp = routeTableTimestamp
            self.routeTableType = routeTableType
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkSegmentEdge = "CoreNetworkSegmentEdge"
            case networkRoutes = "NetworkRoutes"
            case routeTableArn = "RouteTableArn"
            case routeTableTimestamp = "RouteTableTimestamp"
            case routeTableType = "RouteTableType"
        }
    }

    public struct GetNetworkTelemetryRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The Amazon Web Services Region.
        public let awsRegion: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The ARN of the gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the resource.
        public let resourceArn: String?
        /// The resource type. The following are the supported resource types for Direct Connect:    dxcon     dx-gateway     dx-vif    The following are the supported resource types for Network Manager:    connection     device     link     site    The following are the supported resource types for Amazon VPC:    customer-gateway     transit-gateway     transit-gateway-attachment     transit-gateway-connect-peer     transit-gateway-route-table     vpn-connection
        public let resourceType: String?

        public init(accountId: String? = nil, awsRegion: String? = nil, coreNetworkId: String? = nil, globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountId, key: "accountId")
            request.encodeQuery(self.awsRegion, key: "awsRegion")
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.registeredGatewayArn, key: "registeredGatewayArn")
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, max: 63)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, min: 1)
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, max: 1500)
            try self.validate(self.registeredGatewayArn, name: "registeredGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 256)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNetworkTelemetryResponse: AWSDecodableShape {
        /// The network telemetry.
        public let networkTelemetry: [NetworkTelemetry]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(networkTelemetry: [NetworkTelemetry]? = nil, nextToken: String? = nil) {
            self.networkTelemetry = networkTelemetry
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkTelemetry = "NetworkTelemetry"
            case nextToken = "NextToken"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// The resource policy document.
        public let policyDocument: String?

        public init(policyDocument: String? = nil) {
            self.policyDocument = policyDocument
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "PolicyDocument"
        }
    }

    public struct GetRouteAnalysisRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the route analysis.
        public let routeAnalysisId: String

        public init(globalNetworkId: String, routeAnalysisId: String) {
            self.globalNetworkId = globalNetworkId
            self.routeAnalysisId = routeAnalysisId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.routeAnalysisId, key: "RouteAnalysisId")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.routeAnalysisId, name: "routeAnalysisId", parent: name, max: 256)
            try self.validate(self.routeAnalysisId, name: "routeAnalysisId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRouteAnalysisResponse: AWSDecodableShape {
        /// The route analysis.
        public let routeAnalysis: RouteAnalysis?

        public init(routeAnalysis: RouteAnalysis? = nil) {
            self.routeAnalysis = routeAnalysis
        }

        private enum CodingKeys: String, CodingKey {
            case routeAnalysis = "RouteAnalysis"
        }
    }

    public struct GetSiteToSiteVpnAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let attachmentId: String

        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSiteToSiteVpnAttachmentResponse: AWSDecodableShape {
        /// Describes the site-to-site attachment.
        public let siteToSiteVpnAttachment: SiteToSiteVpnAttachment?

        public init(siteToSiteVpnAttachment: SiteToSiteVpnAttachment? = nil) {
            self.siteToSiteVpnAttachment = siteToSiteVpnAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case siteToSiteVpnAttachment = "SiteToSiteVpnAttachment"
        }
    }

    public struct GetSitesRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// One or more site IDs. The maximum is 10.
        public let siteIds: [String]?

        public init(globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, siteIds: [String]? = nil) {
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.siteIds = siteIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.siteIds, key: "siteIds")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.siteIds?.forEach {
                try validate($0, name: "siteIds[]", parent: name, max: 50)
                try validate($0, name: "siteIds[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSitesResponse: AWSDecodableShape {
        /// The token for the next page of results.
        public let nextToken: String?
        /// The sites.
        public let sites: [Site]?

        public init(nextToken: String? = nil, sites: [Site]? = nil) {
            self.nextToken = nextToken
            self.sites = sites
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sites = "Sites"
        }
    }

    public struct GetTransitGatewayConnectPeerAssociationsRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// One or more transit gateway Connect peer Amazon Resource Names (ARNs).
        public let transitGatewayConnectPeerArns: [String]?

        public init(globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, transitGatewayConnectPeerArns: [String]? = nil) {
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.transitGatewayConnectPeerArns = transitGatewayConnectPeerArns
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.transitGatewayConnectPeerArns, key: "transitGatewayConnectPeerArns")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.transitGatewayConnectPeerArns?.forEach {
                try validate($0, name: "transitGatewayConnectPeerArns[]", parent: name, max: 500)
                try validate($0, name: "transitGatewayConnectPeerArns[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransitGatewayConnectPeerAssociationsResponse: AWSDecodableShape {
        /// The token to use for the next page of results.
        public let nextToken: String?
        /// Information about the transit gateway Connect peer associations.
        public let transitGatewayConnectPeerAssociations: [TransitGatewayConnectPeerAssociation]?

        public init(nextToken: String? = nil, transitGatewayConnectPeerAssociations: [TransitGatewayConnectPeerAssociation]? = nil) {
            self.nextToken = nextToken
            self.transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case transitGatewayConnectPeerAssociations = "TransitGatewayConnectPeerAssociations"
        }
    }

    public struct GetTransitGatewayPeeringRequest: AWSEncodableShape {
        /// The ID of the peering request.
        public let peeringId: String

        public init(peeringId: String) {
            self.peeringId = peeringId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.peeringId, key: "PeeringId")
        }

        public func validate(name: String) throws {
            try self.validate(self.peeringId, name: "peeringId", parent: name, max: 50)
            try self.validate(self.peeringId, name: "peeringId", parent: name, pattern: "^peering-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransitGatewayPeeringResponse: AWSDecodableShape {
        /// Returns information about a transit gateway peering.
        public let transitGatewayPeering: TransitGatewayPeering?

        public init(transitGatewayPeering: TransitGatewayPeering? = nil) {
            self.transitGatewayPeering = transitGatewayPeering
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayPeering = "TransitGatewayPeering"
        }
    }

    public struct GetTransitGatewayRegistrationsRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.
        public let transitGatewayArns: [String]?

        public init(globalNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil, transitGatewayArns: [String]? = nil) {
            self.globalNetworkId = globalNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.transitGatewayArns = transitGatewayArns
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.transitGatewayArns, key: "transitGatewayArns")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.transitGatewayArns?.forEach {
                try validate($0, name: "transitGatewayArns[]", parent: name, max: 500)
                try validate($0, name: "transitGatewayArns[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransitGatewayRegistrationsResponse: AWSDecodableShape {
        /// The token for the next page of results.
        public let nextToken: String?
        /// The transit gateway registrations.
        public let transitGatewayRegistrations: [TransitGatewayRegistration]?

        public init(nextToken: String? = nil, transitGatewayRegistrations: [TransitGatewayRegistration]? = nil) {
            self.nextToken = nextToken
            self.transitGatewayRegistrations = transitGatewayRegistrations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case transitGatewayRegistrations = "TransitGatewayRegistrations"
        }
    }

    public struct GetTransitGatewayRouteTableAttachmentRequest: AWSEncodableShape {
        /// The ID of the transit gateway route table attachment.
        public let attachmentId: String

        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTransitGatewayRouteTableAttachmentResponse: AWSDecodableShape {
        /// Returns information about the transit gateway route table attachment.
        public let transitGatewayRouteTableAttachment: TransitGatewayRouteTableAttachment?

        public init(transitGatewayRouteTableAttachment: TransitGatewayRouteTableAttachment? = nil) {
            self.transitGatewayRouteTableAttachment = transitGatewayRouteTableAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayRouteTableAttachment = "TransitGatewayRouteTableAttachment"
        }
    }

    public struct GetVpcAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let attachmentId: String

        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVpcAttachmentResponse: AWSDecodableShape {
        /// Returns details about a VPC attachment.
        public let vpcAttachment: VpcAttachment?

        public init(vpcAttachment: VpcAttachment? = nil) {
            self.vpcAttachment = vpcAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case vpcAttachment = "VpcAttachment"
        }
    }

    public struct GlobalNetwork: AWSDecodableShape {
        /// The date and time that the global network was created.
        public let createdAt: Date?
        /// The description of the global network.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the global network.
        public let globalNetworkArn: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The state of the global network.
        public let state: GlobalNetworkState?
        /// The tags for the global network.
        public let tags: [Tag]?

        public init(createdAt: Date? = nil, description: String? = nil, globalNetworkArn: String? = nil, globalNetworkId: String? = nil, state: GlobalNetworkState? = nil, tags: [Tag]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkArn = globalNetworkArn
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case globalNetworkArn = "GlobalNetworkArn"
            case globalNetworkId = "GlobalNetworkId"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct Link: AWSDecodableShape {
        /// The bandwidth for the link.
        public let bandwidth: Bandwidth?
        /// The date and time that the link was created.
        public let createdAt: Date?
        /// The description of the link.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The Amazon Resource Name (ARN) of the link.
        public let linkArn: String?
        /// The ID of the link.
        public let linkId: String?
        /// The provider of the link.
        public let provider: String?
        /// The ID of the site.
        public let siteId: String?
        /// The state of the link.
        public let state: LinkState?
        /// The tags for the link.
        public let tags: [Tag]?
        /// The type of the link.
        public let type: String?

        public init(bandwidth: Bandwidth? = nil, createdAt: Date? = nil, description: String? = nil, globalNetworkId: String? = nil, linkArn: String? = nil, linkId: String? = nil, provider: String? = nil, siteId: String? = nil, state: LinkState? = nil, tags: [Tag]? = nil, type: String? = nil) {
            self.bandwidth = bandwidth
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.linkArn = linkArn
            self.linkId = linkId
            self.provider = provider
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth = "Bandwidth"
            case createdAt = "CreatedAt"
            case description = "Description"
            case globalNetworkId = "GlobalNetworkId"
            case linkArn = "LinkArn"
            case linkId = "LinkId"
            case provider = "Provider"
            case siteId = "SiteId"
            case state = "State"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct LinkAssociation: AWSDecodableShape {
        /// The device ID for the link association.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The state of the association.
        public let linkAssociationState: LinkAssociationState?
        /// The ID of the link.
        public let linkId: String?

        public init(deviceId: String? = nil, globalNetworkId: String? = nil, linkAssociationState: LinkAssociationState? = nil, linkId: String? = nil) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkAssociationState = linkAssociationState
            self.linkId = linkId
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case linkAssociationState = "LinkAssociationState"
            case linkId = "LinkId"
        }
    }

    public struct ListAttachmentsRequest: AWSEncodableShape {
        /// The type of attachment.
        public let attachmentType: AttachmentType?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The Region where the edge is located.
        public let edgeLocation: String?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The state of the attachment.
        public let state: AttachmentState?

        public init(attachmentType: AttachmentType? = nil, coreNetworkId: String? = nil, edgeLocation: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, state: AttachmentState? = nil) {
            self.attachmentType = attachmentType
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.attachmentType, key: "attachmentType")
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodeQuery(self.edgeLocation, key: "edgeLocation")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.state, key: "state")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, max: 63)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, min: 1)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAttachmentsResponse: AWSDecodableShape {
        /// Describes the list of attachments.
        public let attachments: [Attachment]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(attachments: [Attachment]? = nil, nextToken: String? = nil) {
            self.attachments = attachments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "Attachments"
            case nextToken = "NextToken"
        }
    }

    public struct ListConnectPeersRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let connectAttachmentId: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(connectAttachmentId: String? = nil, coreNetworkId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectAttachmentId = connectAttachmentId
            self.coreNetworkId = coreNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectAttachmentId, key: "connectAttachmentId")
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectAttachmentId, name: "connectAttachmentId", parent: name, max: 50)
            try self.validate(self.connectAttachmentId, name: "connectAttachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConnectPeersResponse: AWSDecodableShape {
        /// Describes the Connect peers.
        public let connectPeers: [ConnectPeerSummary]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(connectPeers: [ConnectPeerSummary]? = nil, nextToken: String? = nil) {
            self.connectPeers = connectPeers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectPeers = "ConnectPeers"
            case nextToken = "NextToken"
        }
    }

    public struct ListCoreNetworkPolicyVersionsRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(coreNetworkId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.coreNetworkId = coreNetworkId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCoreNetworkPolicyVersionsResponse: AWSDecodableShape {
        /// Describes core network policy versions.
        public let coreNetworkPolicyVersions: [CoreNetworkPolicyVersion]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(coreNetworkPolicyVersions: [CoreNetworkPolicyVersion]? = nil, nextToken: String? = nil) {
            self.coreNetworkPolicyVersions = coreNetworkPolicyVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkPolicyVersions = "CoreNetworkPolicyVersions"
            case nextToken = "NextToken"
        }
    }

    public struct ListCoreNetworksRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCoreNetworksResponse: AWSDecodableShape {
        /// Describes the list of core networks.
        public let coreNetworks: [CoreNetworkSummary]?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(coreNetworks: [CoreNetworkSummary]? = nil, nextToken: String? = nil) {
            self.coreNetworks = coreNetworks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworks = "CoreNetworks"
            case nextToken = "NextToken"
        }
    }

    public struct ListOrganizationServiceAccessStatusRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOrganizationServiceAccessStatusResponse: AWSDecodableShape {
        /// The token for the next page of results.
        public let nextToken: String?
        /// Displays the status of an Amazon Web Services Organization.
        public let organizationStatus: OrganizationStatus?

        public init(nextToken: String? = nil, organizationStatus: OrganizationStatus? = nil) {
            self.nextToken = nextToken
            self.organizationStatus = organizationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case organizationStatus = "OrganizationStatus"
        }
    }

    public struct ListPeeringsRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// Returns a list edge locations for the
        public let edgeLocation: String?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// Returns a list of a peering requests.
        public let peeringType: PeeringType?
        /// Returns a list of the peering request states.
        public let state: PeeringState?

        public init(coreNetworkId: String? = nil, edgeLocation: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, peeringType: PeeringType? = nil, state: PeeringState? = nil) {
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.peeringType = peeringType
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.coreNetworkId, key: "coreNetworkId")
            request.encodeQuery(self.edgeLocation, key: "edgeLocation")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.peeringType, key: "peeringType")
            request.encodeQuery(self.state, key: "state")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, max: 63)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, min: 1)
            try self.validate(self.edgeLocation, name: "edgeLocation", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPeeringsResponse: AWSDecodableShape {
        /// The token for the next page of results.
        public let nextToken: String?
        /// Lists the transit gateway peerings for the ListPeerings request.
        public let peerings: [Peering]?

        public init(nextToken: String? = nil, peerings: [Peering]? = nil) {
            self.nextToken = nextToken
            self.peerings = peerings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case peerings = "Peerings"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of tags.
        public let tagList: [Tag]?

        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct Location: AWSEncodableShape & AWSDecodableShape {
        /// The physical address.
        public let address: String?
        /// The latitude.
        public let latitude: String?
        /// The longitude.
        public let longitude: String?

        public init(address: String? = nil, latitude: String? = nil, longitude: String? = nil) {
            self.address = address
            self.latitude = latitude
            self.longitude = longitude
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, max: 256)
            try self.validate(self.address, name: "address", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.latitude, name: "latitude", parent: name, max: 256)
            try self.validate(self.latitude, name: "latitude", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.longitude, name: "longitude", parent: name, max: 256)
            try self.validate(self.longitude, name: "longitude", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case latitude = "Latitude"
            case longitude = "Longitude"
        }
    }

    public struct NetworkResource: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The Amazon Web Services Region.
        public let awsRegion: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.
        public let definition: String?
        /// The time that the resource definition was retrieved.
        public let definitionTimestamp: Date?
        /// The resource metadata.
        public let metadata: [String: String]?
        /// The ARN of the gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the resource.
        public let resourceArn: String?
        /// The ID of the resource.
        public let resourceId: String?
        /// The resource type. The following are the supported resource types for Direct Connect:    dxcon     dx-gateway     dx-vif    The following are the supported resource types for Network Manager:    connection     device     link     site    The following are the supported resource types for Amazon VPC:    customer-gateway     transit-gateway     transit-gateway-attachment     transit-gateway-connect-peer     transit-gateway-route-table     vpn-connection
        public let resourceType: String?
        /// The tags.
        public let tags: [Tag]?

        public init(accountId: String? = nil, awsRegion: String? = nil, coreNetworkId: String? = nil, definition: String? = nil, definitionTimestamp: Date? = nil, metadata: [String: String]? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, resourceType: String? = nil, tags: [Tag]? = nil) {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.definition = definition
            self.definitionTimestamp = definitionTimestamp
            self.metadata = metadata
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsRegion = "AwsRegion"
            case coreNetworkId = "CoreNetworkId"
            case definition = "Definition"
            case definitionTimestamp = "DefinitionTimestamp"
            case metadata = "Metadata"
            case registeredGatewayArn = "RegisteredGatewayArn"
            case resourceArn = "ResourceArn"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
            case tags = "Tags"
        }
    }

    public struct NetworkResourceCount: AWSDecodableShape {
        /// The resource count.
        public let count: Int?
        /// The resource type.
        public let resourceType: String?

        public init(count: Int? = nil, resourceType: String? = nil) {
            self.count = count
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case resourceType = "ResourceType"
        }
    }

    public struct NetworkResourceSummary: AWSDecodableShape {
        /// Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.
        public let definition: String?
        /// Indicates whether this is a middlebox appliance.
        public let isMiddlebox: Bool?
        /// The value for the Name tag.
        public let nameTag: String?
        /// The ARN of the gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the resource.
        public let resourceArn: String?
        /// The resource type.
        public let resourceType: String?

        public init(definition: String? = nil, isMiddlebox: Bool? = nil, nameTag: String? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil) {
            self.definition = definition
            self.isMiddlebox = isMiddlebox
            self.nameTag = nameTag
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case isMiddlebox = "IsMiddlebox"
            case nameTag = "NameTag"
            case registeredGatewayArn = "RegisteredGatewayArn"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
        }
    }

    public struct NetworkRoute: AWSDecodableShape {
        /// A unique identifier for the route, such as a CIDR block.
        public let destinationCidrBlock: String?
        /// The destinations.
        public let destinations: [NetworkRouteDestination]?
        /// The ID of the prefix list.
        public let prefixListId: String?
        /// The route state. The possible values are active and blackhole.
        public let state: RouteState?
        /// The route type. The possible values are propagated and static.
        public let type: RouteType?

        public init(destinationCidrBlock: String? = nil, destinations: [NetworkRouteDestination]? = nil, prefixListId: String? = nil, state: RouteState? = nil, type: RouteType? = nil) {
            self.destinationCidrBlock = destinationCidrBlock
            self.destinations = destinations
            self.prefixListId = prefixListId
            self.state = state
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case destinationCidrBlock = "DestinationCidrBlock"
            case destinations = "Destinations"
            case prefixListId = "PrefixListId"
            case state = "State"
            case type = "Type"
        }
    }

    public struct NetworkRouteDestination: AWSDecodableShape {
        /// The ID of a core network attachment.
        public let coreNetworkAttachmentId: String?
        /// The edge location for the network destination.
        public let edgeLocation: String?
        /// The ID of the resource.
        public let resourceId: String?
        /// The resource type.
        public let resourceType: String?
        /// The name of the segment.
        public let segmentName: String?
        /// The ID of the transit gateway attachment.
        public let transitGatewayAttachmentId: String?

        public init(coreNetworkAttachmentId: String? = nil, edgeLocation: String? = nil, resourceId: String? = nil, resourceType: String? = nil, segmentName: String? = nil, transitGatewayAttachmentId: String? = nil) {
            self.coreNetworkAttachmentId = coreNetworkAttachmentId
            self.edgeLocation = edgeLocation
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.segmentName = segmentName
            self.transitGatewayAttachmentId = transitGatewayAttachmentId
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkAttachmentId = "CoreNetworkAttachmentId"
            case edgeLocation = "EdgeLocation"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
            case segmentName = "SegmentName"
            case transitGatewayAttachmentId = "TransitGatewayAttachmentId"
        }
    }

    public struct NetworkTelemetry: AWSDecodableShape {
        /// The Amazon Web Services account ID.
        public let accountId: String?
        /// The address.
        public let address: String?
        /// The Amazon Web Services Region.
        public let awsRegion: String?
        /// The ID of a core network.
        public let coreNetworkId: String?
        /// The connection health.
        public let health: ConnectionHealth?
        /// The ARN of the gateway.
        public let registeredGatewayArn: String?
        /// The ARN of the resource.
        public let resourceArn: String?
        /// The ID of the resource.
        public let resourceId: String?
        /// The resource type.
        public let resourceType: String?

        public init(accountId: String? = nil, address: String? = nil, awsRegion: String? = nil, coreNetworkId: String? = nil, health: ConnectionHealth? = nil, registeredGatewayArn: String? = nil, resourceArn: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.accountId = accountId
            self.address = address
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.health = health
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case address = "Address"
            case awsRegion = "AwsRegion"
            case coreNetworkId = "CoreNetworkId"
            case health = "Health"
            case registeredGatewayArn = "RegisteredGatewayArn"
            case resourceArn = "ResourceArn"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct OrganizationStatus: AWSDecodableShape {
        /// The current service-linked role (SLR) deployment status for an Amazon Web Services Organization's accounts. This will be either SUCCEEDED or IN_PROGRESS.
        public let accountStatusList: [AccountStatus]?
        /// The status  of the organization's AWS service access. This will be ENABLED or DISABLED.
        public let organizationAwsServiceAccessStatus: String?
        /// The ID of an Amazon Web Services Organization.
        public let organizationId: String?
        /// The status of the SLR deployment for the account. This will be either SUCCEEDED or IN_PROGRESS.
        public let slrDeploymentStatus: String?

        public init(accountStatusList: [AccountStatus]? = nil, organizationAwsServiceAccessStatus: String? = nil, organizationId: String? = nil, slrDeploymentStatus: String? = nil) {
            self.accountStatusList = accountStatusList
            self.organizationAwsServiceAccessStatus = organizationAwsServiceAccessStatus
            self.organizationId = organizationId
            self.slrDeploymentStatus = slrDeploymentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountStatusList = "AccountStatusList"
            case organizationAwsServiceAccessStatus = "OrganizationAwsServiceAccessStatus"
            case organizationId = "OrganizationId"
            case slrDeploymentStatus = "SLRDeploymentStatus"
        }
    }

    public struct PathComponent: AWSDecodableShape {
        /// The destination CIDR block in the route table.
        public let destinationCidrBlock: String?
        /// The resource.
        public let resource: NetworkResourceSummary?
        /// The sequence number in the path. The destination is 0.
        public let sequence: Int?

        public init(destinationCidrBlock: String? = nil, resource: NetworkResourceSummary? = nil, sequence: Int? = nil) {
            self.destinationCidrBlock = destinationCidrBlock
            self.resource = resource
            self.sequence = sequence
        }

        private enum CodingKeys: String, CodingKey {
            case destinationCidrBlock = "DestinationCidrBlock"
            case resource = "Resource"
            case sequence = "Sequence"
        }
    }

    public struct Peering: AWSDecodableShape {
        /// The ARN of a core network.
        public let coreNetworkArn: String?
        /// The ID of the core network for the peering request.
        public let coreNetworkId: String?
        /// The timestamp when the attachment peer was created.
        public let createdAt: Date?
        /// The edge location for the peer.
        public let edgeLocation: String?
        /// The ID of the account owner.
        public let ownerAccountId: String?
        /// The ID of the peering attachment.
        public let peeringId: String?
        /// The type of peering. This will be TRANSIT_GATEWAY.
        public let peeringType: PeeringType?
        /// The resource ARN of the peer.
        public let resourceArn: String?
        /// The current state of the peering connection.
        public let state: PeeringState?
        /// The list of key-value tags associated with the peering.
        public let tags: [Tag]?

        public init(coreNetworkArn: String? = nil, coreNetworkId: String? = nil, createdAt: Date? = nil, edgeLocation: String? = nil, ownerAccountId: String? = nil, peeringId: String? = nil, peeringType: PeeringType? = nil, resourceArn: String? = nil, state: PeeringState? = nil, tags: [Tag]? = nil) {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.ownerAccountId = ownerAccountId
            self.peeringId = peeringId
            self.peeringType = peeringType
            self.resourceArn = resourceArn
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkArn = "CoreNetworkArn"
            case coreNetworkId = "CoreNetworkId"
            case createdAt = "CreatedAt"
            case edgeLocation = "EdgeLocation"
            case ownerAccountId = "OwnerAccountId"
            case peeringId = "PeeringId"
            case peeringType = "PeeringType"
            case resourceArn = "ResourceArn"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct ProposedSegmentChange: AWSDecodableShape {
        /// The rule number in the policy document that applies to this change.
        public let attachmentPolicyRuleNumber: Int?
        /// The name of the segment to change.
        public let segmentName: String?
        /// The list of key-value tags that changed for the segment.
        public let tags: [Tag]?

        public init(attachmentPolicyRuleNumber: Int? = nil, segmentName: String? = nil, tags: [Tag]? = nil) {
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.segmentName = segmentName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentPolicyRuleNumber = "AttachmentPolicyRuleNumber"
            case segmentName = "SegmentName"
            case tags = "Tags"
        }
    }

    public struct PutCoreNetworkPolicyRequest: AWSEncodableShape {
        /// The client token associated with the request.
        public let clientToken: String?
        /// The ID of a core network.
        public let coreNetworkId: String
        /// a core network policy description.
        public let description: String?
        /// The ID of a core network policy.
        public let latestVersionId: Int?
        /// The policy document.
        public let policyDocument: String

        public init(clientToken: String? = PutCoreNetworkPolicyRequest.idempotencyToken(), coreNetworkId: String, description: String? = nil, latestVersionId: Int? = nil, policyDocument: String) {
            self.clientToken = clientToken
            self.coreNetworkId = coreNetworkId
            self.description = description
            self.latestVersionId = latestVersionId
            self.policyDocument = policyDocument
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.latestVersionId, forKey: .latestVersionId)
            try container.encode(self.policyDocument, forKey: .policyDocument)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, max: 10000000)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case latestVersionId = "LatestVersionId"
            case policyDocument = "PolicyDocument"
        }
    }

    public struct PutCoreNetworkPolicyResponse: AWSDecodableShape {
        /// Describes the changed core network policy.
        public let coreNetworkPolicy: CoreNetworkPolicy?

        public init(coreNetworkPolicy: CoreNetworkPolicy? = nil) {
            self.coreNetworkPolicy = coreNetworkPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkPolicy = "CoreNetworkPolicy"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// The JSON resource policy document.
        public let policyDocument: String
        /// The ARN of the resource policy.
        public let resourceArn: String

        public init(policyDocument: String, resourceArn: String) {
            self.policyDocument = policyDocument
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.policyDocument, forKey: .policyDocument)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, max: 10000000)
            try self.validate(self.policyDocument, name: "policyDocument", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "PolicyDocument"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RegisterTransitGatewayRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The Amazon Resource Name (ARN) of the transit gateway.
        public let transitGatewayArn: String

        public init(globalNetworkId: String, transitGatewayArn: String) {
            self.globalNetworkId = globalNetworkId
            self.transitGatewayArn = transitGatewayArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encode(self.transitGatewayArn, forKey: .transitGatewayArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, max: 500)
            try self.validate(self.transitGatewayArn, name: "transitGatewayArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayArn = "TransitGatewayArn"
        }
    }

    public struct RegisterTransitGatewayResponse: AWSDecodableShape {
        /// Information about the transit gateway registration.
        public let transitGatewayRegistration: TransitGatewayRegistration?

        public init(transitGatewayRegistration: TransitGatewayRegistration? = nil) {
            self.transitGatewayRegistration = transitGatewayRegistration
        }

        private enum CodingKeys: String, CodingKey {
            case transitGatewayRegistration = "TransitGatewayRegistration"
        }
    }

    public struct RejectAttachmentRequest: AWSEncodableShape {
        /// The ID of the attachment.
        public let attachmentId: String

        public init(attachmentId: String) {
            self.attachmentId = attachmentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attachmentId, key: "AttachmentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RejectAttachmentResponse: AWSDecodableShape {
        /// Describes the rejected attachment request.
        public let attachment: Attachment?

        public init(attachment: Attachment? = nil) {
            self.attachment = attachment
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
        }
    }

    public struct Relationship: AWSDecodableShape {
        /// The ARN of the resource.
        public let from: String?
        /// The ARN of the resource.
        public let to: String?

        public init(from: String? = nil, to: String? = nil) {
            self.from = from
            self.to = to
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case to = "To"
        }
    }

    public struct RestoreCoreNetworkPolicyVersionRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The ID of the policy version to restore.
        public let policyVersionId: Int

        public init(coreNetworkId: String, policyVersionId: Int) {
            self.coreNetworkId = coreNetworkId
            self.policyVersionId = policyVersionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            request.encodePath(self.policyVersionId, key: "PolicyVersionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RestoreCoreNetworkPolicyVersionResponse: AWSDecodableShape {
        /// Describes the restored core network policy.
        public let coreNetworkPolicy: CoreNetworkPolicy?

        public init(coreNetworkPolicy: CoreNetworkPolicy? = nil) {
            self.coreNetworkPolicy = coreNetworkPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkPolicy = "CoreNetworkPolicy"
        }
    }

    public struct RouteAnalysis: AWSDecodableShape {
        /// The destination.
        public let destination: RouteAnalysisEndpointOptions?
        /// The forward path.
        public let forwardPath: RouteAnalysisPath?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// Indicates whether to analyze the return path. The return path is not analyzed if the forward path analysis does not succeed.
        public let includeReturnPath: Bool?
        /// The ID of the AWS account that created the route analysis.
        public let ownerAccountId: String?
        /// The return path.
        public let returnPath: RouteAnalysisPath?
        /// The ID of the route analysis.
        public let routeAnalysisId: String?
        /// The source.
        public let source: RouteAnalysisEndpointOptions?
        /// The time that the analysis started.
        public let startTimestamp: Date?
        /// The status of the route analysis.
        public let status: RouteAnalysisStatus?
        /// Indicates whether to include the location of middlebox appliances in the route analysis.
        public let useMiddleboxes: Bool?

        public init(destination: RouteAnalysisEndpointOptions? = nil, forwardPath: RouteAnalysisPath? = nil, globalNetworkId: String? = nil, includeReturnPath: Bool? = nil, ownerAccountId: String? = nil, returnPath: RouteAnalysisPath? = nil, routeAnalysisId: String? = nil, source: RouteAnalysisEndpointOptions? = nil, startTimestamp: Date? = nil, status: RouteAnalysisStatus? = nil, useMiddleboxes: Bool? = nil) {
            self.destination = destination
            self.forwardPath = forwardPath
            self.globalNetworkId = globalNetworkId
            self.includeReturnPath = includeReturnPath
            self.ownerAccountId = ownerAccountId
            self.returnPath = returnPath
            self.routeAnalysisId = routeAnalysisId
            self.source = source
            self.startTimestamp = startTimestamp
            self.status = status
            self.useMiddleboxes = useMiddleboxes
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case forwardPath = "ForwardPath"
            case globalNetworkId = "GlobalNetworkId"
            case includeReturnPath = "IncludeReturnPath"
            case ownerAccountId = "OwnerAccountId"
            case returnPath = "ReturnPath"
            case routeAnalysisId = "RouteAnalysisId"
            case source = "Source"
            case startTimestamp = "StartTimestamp"
            case status = "Status"
            case useMiddleboxes = "UseMiddleboxes"
        }
    }

    public struct RouteAnalysisCompletion: AWSDecodableShape {
        /// The reason code. Available only if a connection is not found.    BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND - Found a black hole route with the destination CIDR block.    CYCLIC_PATH_DETECTED - Found the same resource multiple times while traversing the path.    INACTIVE_ROUTE_FOR_DESTINATION_FOUND - Found an inactive route with the destination CIDR block.    MAX_HOPS_EXCEEDED - Analysis exceeded 64 hops without finding the destination.    ROUTE_NOT_FOUND - Cannot find a route table with the destination CIDR block.    TGW_ATTACH_ARN_NO_MATCH - Found an attachment, but not with the correct destination ARN.    TGW_ATTACH_NOT_FOUND - Cannot find an attachment.    TGW_ATTACH_NOT_IN_TGW - Found an attachment, but not to the correct transit gateway.    TGW_ATTACH_STABLE_ROUTE_TABLE_NOT_FOUND - The state of the route table association is not associated.
        public let reasonCode: RouteAnalysisCompletionReasonCode?
        /// Additional information about the path. Available only if a connection is not found.
        public let reasonContext: [String: String]?
        /// The result of the analysis. If the status is NOT_CONNECTED, check the  reason code.
        public let resultCode: RouteAnalysisCompletionResultCode?

        public init(reasonCode: RouteAnalysisCompletionReasonCode? = nil, reasonContext: [String: String]? = nil, resultCode: RouteAnalysisCompletionResultCode? = nil) {
            self.reasonCode = reasonCode
            self.reasonContext = reasonContext
            self.resultCode = resultCode
        }

        private enum CodingKeys: String, CodingKey {
            case reasonCode = "ReasonCode"
            case reasonContext = "ReasonContext"
            case resultCode = "ResultCode"
        }
    }

    public struct RouteAnalysisEndpointOptions: AWSDecodableShape {
        /// The IP address.
        public let ipAddress: String?
        /// The ARN of the transit gateway.
        public let transitGatewayArn: String?
        /// The ARN of the transit gateway attachment.
        public let transitGatewayAttachmentArn: String?

        public init(ipAddress: String? = nil, transitGatewayArn: String? = nil, transitGatewayAttachmentArn: String? = nil) {
            self.ipAddress = ipAddress
            self.transitGatewayArn = transitGatewayArn
            self.transitGatewayAttachmentArn = transitGatewayAttachmentArn
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddress = "IpAddress"
            case transitGatewayArn = "TransitGatewayArn"
            case transitGatewayAttachmentArn = "TransitGatewayAttachmentArn"
        }
    }

    public struct RouteAnalysisEndpointOptionsSpecification: AWSEncodableShape {
        /// The IP address.
        public let ipAddress: String?
        /// The ARN of the transit gateway attachment.
        public let transitGatewayAttachmentArn: String?

        public init(ipAddress: String? = nil, transitGatewayAttachmentArn: String? = nil) {
            self.ipAddress = ipAddress
            self.transitGatewayAttachmentArn = transitGatewayAttachmentArn
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, max: 50)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, min: 1)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.transitGatewayAttachmentArn, name: "transitGatewayAttachmentArn", parent: name, max: 500)
            try self.validate(self.transitGatewayAttachmentArn, name: "transitGatewayAttachmentArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddress = "IpAddress"
            case transitGatewayAttachmentArn = "TransitGatewayAttachmentArn"
        }
    }

    public struct RouteAnalysisPath: AWSDecodableShape {
        /// The status of the analysis at completion.
        public let completionStatus: RouteAnalysisCompletion?
        /// The route analysis path.
        public let path: [PathComponent]?

        public init(completionStatus: RouteAnalysisCompletion? = nil, path: [PathComponent]? = nil) {
            self.completionStatus = completionStatus
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case completionStatus = "CompletionStatus"
            case path = "Path"
        }
    }

    public struct RouteTableIdentifier: AWSEncodableShape {
        /// The segment edge in a core network.
        public let coreNetworkSegmentEdge: CoreNetworkSegmentEdgeIdentifier?
        /// The ARN of the transit gateway route table for the attachment request. For example, "TransitGatewayRouteTableArn": "arn:aws:ec2:us-west-2:123456789012:transit-gateway-route-table/tgw-rtb-9876543210123456".
        public let transitGatewayRouteTableArn: String?

        public init(coreNetworkSegmentEdge: CoreNetworkSegmentEdgeIdentifier? = nil, transitGatewayRouteTableArn: String? = nil) {
            self.coreNetworkSegmentEdge = coreNetworkSegmentEdge
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }

        public func validate(name: String) throws {
            try self.coreNetworkSegmentEdge?.validate(name: "\(name).coreNetworkSegmentEdge")
            try self.validate(self.transitGatewayRouteTableArn, name: "transitGatewayRouteTableArn", parent: name, max: 500)
            try self.validate(self.transitGatewayRouteTableArn, name: "transitGatewayRouteTableArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetworkSegmentEdge = "CoreNetworkSegmentEdge"
            case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
        }
    }

    public struct Site: AWSDecodableShape {
        /// The date and time that the site was created.
        public let createdAt: Date?
        /// The description of the site.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The location of the site.
        public let location: Location?
        /// The Amazon Resource Name (ARN) of the site.
        public let siteArn: String?
        /// The ID of the site.
        public let siteId: String?
        /// The state of the site.
        public let state: SiteState?
        /// The tags for the site.
        public let tags: [Tag]?

        public init(createdAt: Date? = nil, description: String? = nil, globalNetworkId: String? = nil, location: Location? = nil, siteArn: String? = nil, siteId: String? = nil, state: SiteState? = nil, tags: [Tag]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.siteArn = siteArn
            self.siteId = siteId
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case globalNetworkId = "GlobalNetworkId"
            case location = "Location"
            case siteArn = "SiteArn"
            case siteId = "SiteId"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct SiteToSiteVpnAttachment: AWSDecodableShape {
        /// Provides details about a site-to-site VPN attachment.
        public let attachment: Attachment?
        /// The ARN of the site-to-site VPN attachment.
        public let vpnConnectionArn: String?

        public init(attachment: Attachment? = nil, vpnConnectionArn: String? = nil) {
            self.attachment = attachment
            self.vpnConnectionArn = vpnConnectionArn
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case vpnConnectionArn = "VpnConnectionArn"
        }
    }

    public struct StartOrganizationServiceAccessUpdateRequest: AWSEncodableShape {
        /// The action to take for the update request. This can be either ENABLE or DISABLE.
        public let action: String

        public init(action: String) {
            self.action = action
        }

        public func validate(name: String) throws {
            try self.validate(self.action, name: "action", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
        }
    }

    public struct StartOrganizationServiceAccessUpdateResponse: AWSDecodableShape {
        /// The status of the service access update request for an Amazon Web Services Organization.
        public let organizationStatus: OrganizationStatus?

        public init(organizationStatus: OrganizationStatus? = nil) {
            self.organizationStatus = organizationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case organizationStatus = "OrganizationStatus"
        }
    }

    public struct StartRouteAnalysisRequest: AWSEncodableShape {
        /// The destination.
        public let destination: RouteAnalysisEndpointOptionsSpecification
        /// The ID of the global network.
        public let globalNetworkId: String
        /// Indicates whether to analyze the return path. The default is false.
        public let includeReturnPath: Bool?
        /// The source from which traffic originates.
        public let source: RouteAnalysisEndpointOptionsSpecification
        /// Indicates whether to include the location of middlebox appliances in the route analysis. The default is false.
        public let useMiddleboxes: Bool?

        public init(destination: RouteAnalysisEndpointOptionsSpecification, globalNetworkId: String, includeReturnPath: Bool? = nil, source: RouteAnalysisEndpointOptionsSpecification, useMiddleboxes: Bool? = nil) {
            self.destination = destination
            self.globalNetworkId = globalNetworkId
            self.includeReturnPath = includeReturnPath
            self.source = source
            self.useMiddleboxes = useMiddleboxes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.destination, forKey: .destination)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.includeReturnPath, forKey: .includeReturnPath)
            try container.encode(self.source, forKey: .source)
            try container.encodeIfPresent(self.useMiddleboxes, forKey: .useMiddleboxes)
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.source.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case includeReturnPath = "IncludeReturnPath"
            case source = "Source"
            case useMiddleboxes = "UseMiddleboxes"
        }
    }

    public struct StartRouteAnalysisResponse: AWSDecodableShape {
        /// The route analysis.
        public let routeAnalysis: RouteAnalysis?

        public init(routeAnalysis: RouteAnalysis? = nil) {
            self.routeAnalysis = routeAnalysis
        }

        private enum CodingKeys: String, CodingKey {
            case routeAnalysis = "RouteAnalysis"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key. Constraints: Maximum length of 128 characters.
        public let key: String?
        /// The tag value. Constraints: Maximum length of 256 characters.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 10000000)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.value, name: "value", parent: name, max: 10000000)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags to apply to the specified resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TransitGatewayConnectPeerAssociation: AWSDecodableShape {
        /// The ID of the device.
        public let deviceId: String?
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The ID of the link.
        public let linkId: String?
        /// The state of the association.
        public let state: TransitGatewayConnectPeerAssociationState?
        /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
        public let transitGatewayConnectPeerArn: String?

        public init(deviceId: String? = nil, globalNetworkId: String? = nil, linkId: String? = nil, state: TransitGatewayConnectPeerAssociationState? = nil, transitGatewayConnectPeerArn: String? = nil) {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
        }

        private enum CodingKeys: String, CodingKey {
            case deviceId = "DeviceId"
            case globalNetworkId = "GlobalNetworkId"
            case linkId = "LinkId"
            case state = "State"
            case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
        }
    }

    public struct TransitGatewayPeering: AWSDecodableShape {
        /// Describes a transit gateway peer connection.
        public let peering: Peering?
        /// The ARN of the transit gateway.
        public let transitGatewayArn: String?
        /// The ID of the transit gateway peering attachment.
        public let transitGatewayPeeringAttachmentId: String?

        public init(peering: Peering? = nil, transitGatewayArn: String? = nil, transitGatewayPeeringAttachmentId: String? = nil) {
            self.peering = peering
            self.transitGatewayArn = transitGatewayArn
            self.transitGatewayPeeringAttachmentId = transitGatewayPeeringAttachmentId
        }

        private enum CodingKeys: String, CodingKey {
            case peering = "Peering"
            case transitGatewayArn = "TransitGatewayArn"
            case transitGatewayPeeringAttachmentId = "TransitGatewayPeeringAttachmentId"
        }
    }

    public struct TransitGatewayRegistration: AWSDecodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String?
        /// The state of the transit gateway registration.
        public let state: TransitGatewayRegistrationStateReason?
        /// The Amazon Resource Name (ARN) of the transit gateway.
        public let transitGatewayArn: String?

        public init(globalNetworkId: String? = nil, state: TransitGatewayRegistrationStateReason? = nil, transitGatewayArn: String? = nil) {
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.transitGatewayArn = transitGatewayArn
        }

        private enum CodingKeys: String, CodingKey {
            case globalNetworkId = "GlobalNetworkId"
            case state = "State"
            case transitGatewayArn = "TransitGatewayArn"
        }
    }

    public struct TransitGatewayRegistrationStateReason: AWSDecodableShape {
        /// The code for the state reason.
        public let code: TransitGatewayRegistrationState?
        /// The message for the state reason.
        public let message: String?

        public init(code: TransitGatewayRegistrationState? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct TransitGatewayRouteTableAttachment: AWSDecodableShape {
        public let attachment: Attachment?
        /// The ID of the peering attachment.
        public let peeringId: String?
        /// The ARN of the transit gateway attachment route table. For example, "TransitGatewayRouteTableArn": "arn:aws:ec2:us-west-2:123456789012:transit-gateway-route-table/tgw-rtb-9876543210123456".
        public let transitGatewayRouteTableArn: String?

        public init(attachment: Attachment? = nil, peeringId: String? = nil, transitGatewayRouteTableArn: String? = nil) {
            self.attachment = attachment
            self.peeringId = peeringId
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case peeringId = "PeeringId"
            case transitGatewayRouteTableArn = "TransitGatewayRouteTableArn"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys to remove from the specified resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 10000000)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConnectionRequest: AWSEncodableShape {
        /// The ID of the link for the second device in the connection.
        public let connectedLinkId: String?
        /// The ID of the connection.
        public let connectionId: String
        /// A description of the connection. Length Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link for the first device in the connection.
        public let linkId: String?

        public init(connectedLinkId: String? = nil, connectionId: String, description: String? = nil, globalNetworkId: String, linkId: String? = nil) {
            self.connectedLinkId = connectedLinkId
            self.connectionId = connectionId
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.connectedLinkId, forKey: .connectedLinkId)
            request.encodePath(self.connectionId, key: "ConnectionId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.linkId, forKey: .linkId)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectedLinkId, name: "connectedLinkId", parent: name, max: 50)
            try self.validate(self.connectedLinkId, name: "connectedLinkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 50)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectedLinkId = "ConnectedLinkId"
            case description = "Description"
            case linkId = "LinkId"
        }
    }

    public struct UpdateConnectionResponse: AWSDecodableShape {
        /// Information about the connection.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct UpdateCoreNetworkRequest: AWSEncodableShape {
        /// The ID of a core network.
        public let coreNetworkId: String
        /// The description of the update.
        public let description: String?

        public init(coreNetworkId: String, description: String? = nil) {
            self.coreNetworkId = coreNetworkId
            self.description = description
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.coreNetworkId, key: "CoreNetworkId")
            try container.encodeIfPresent(self.description, forKey: .description)
        }

        public func validate(name: String) throws {
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, max: 50)
            try self.validate(self.coreNetworkId, name: "coreNetworkId", parent: name, pattern: "^core-network-([0-9a-f]{8,17})$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateCoreNetworkResponse: AWSDecodableShape {
        /// Returns information about a core network update.
        public let coreNetwork: CoreNetwork?

        public init(coreNetwork: CoreNetwork? = nil) {
            self.coreNetwork = coreNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case coreNetwork = "CoreNetwork"
        }
    }

    public struct UpdateDeviceRequest: AWSEncodableShape {
        /// The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.
        public let awsLocation: AWSLocation?
        /// A description of the device. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the device.
        public let deviceId: String
        /// The ID of the global network.
        public let globalNetworkId: String
        public let location: Location?
        /// The model of the device. Constraints: Maximum length of 128 characters.
        public let model: String?
        /// The serial number of the device. Constraints: Maximum length of 128 characters.
        public let serialNumber: String?
        /// The ID of the site.
        public let siteId: String?
        /// The type of the device.
        public let type: String?
        /// The vendor of the device. Constraints: Maximum length of 128 characters.
        public let vendor: String?

        public init(awsLocation: AWSLocation? = nil, description: String? = nil, deviceId: String, globalNetworkId: String, location: Location? = nil, model: String? = nil, serialNumber: String? = nil, siteId: String? = nil, type: String? = nil, vendor: String? = nil) {
            self.awsLocation = awsLocation
            self.description = description
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.model = model
            self.serialNumber = serialNumber
            self.siteId = siteId
            self.type = type
            self.vendor = vendor
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.awsLocation, forKey: .awsLocation)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.deviceId, key: "DeviceId")
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.location, forKey: .location)
            try container.encodeIfPresent(self.model, forKey: .model)
            try container.encodeIfPresent(self.serialNumber, forKey: .serialNumber)
            try container.encodeIfPresent(self.siteId, forKey: .siteId)
            try container.encodeIfPresent(self.type, forKey: .type)
            try container.encodeIfPresent(self.vendor, forKey: .vendor)
        }

        public func validate(name: String) throws {
            try self.awsLocation?.validate(name: "\(name).awsLocation")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.deviceId, name: "deviceId", parent: name, max: 50)
            try self.validate(self.deviceId, name: "deviceId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.location?.validate(name: "\(name).location")
            try self.validate(self.model, name: "model", parent: name, max: 256)
            try self.validate(self.model, name: "model", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, max: 256)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.vendor, name: "vendor", parent: name, max: 256)
            try self.validate(self.vendor, name: "vendor", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsLocation = "AWSLocation"
            case description = "Description"
            case location = "Location"
            case model = "Model"
            case serialNumber = "SerialNumber"
            case siteId = "SiteId"
            case type = "Type"
            case vendor = "Vendor"
        }
    }

    public struct UpdateDeviceResponse: AWSDecodableShape {
        /// Information about the device.
        public let device: Device?

        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "Device"
        }
    }

    public struct UpdateGlobalNetworkRequest: AWSEncodableShape {
        /// A description of the global network. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of your global network.
        public let globalNetworkId: String

        public init(description: String? = nil, globalNetworkId: String) {
            self.description = description
            self.globalNetworkId = globalNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateGlobalNetworkResponse: AWSDecodableShape {
        /// Information about the global network object.
        public let globalNetwork: GlobalNetwork?

        public init(globalNetwork: GlobalNetwork? = nil) {
            self.globalNetwork = globalNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case globalNetwork = "GlobalNetwork"
        }
    }

    public struct UpdateLinkRequest: AWSEncodableShape {
        /// The upload and download speed in Mbps.
        public let bandwidth: Bandwidth?
        /// A description of the link. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The ID of the link.
        public let linkId: String
        /// The provider of the link. Constraints: Maximum length of 128 characters.
        public let provider: String?
        /// The type of the link. Constraints: Maximum length of 128 characters.
        public let type: String?

        public init(bandwidth: Bandwidth? = nil, description: String? = nil, globalNetworkId: String, linkId: String, provider: String? = nil, type: String? = nil) {
            self.bandwidth = bandwidth
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.provider = provider
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.bandwidth, forKey: .bandwidth)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            request.encodePath(self.linkId, key: "LinkId")
            try container.encodeIfPresent(self.provider, forKey: .provider)
            try container.encodeIfPresent(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.linkId, name: "linkId", parent: name, max: 50)
            try self.validate(self.linkId, name: "linkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.provider, name: "provider", parent: name, max: 256)
            try self.validate(self.provider, name: "provider", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth = "Bandwidth"
            case description = "Description"
            case provider = "Provider"
            case type = "Type"
        }
    }

    public struct UpdateLinkResponse: AWSDecodableShape {
        /// Information about the link.
        public let link: Link?

        public init(link: Link? = nil) {
            self.link = link
        }

        private enum CodingKeys: String, CodingKey {
            case link = "Link"
        }
    }

    public struct UpdateNetworkResourceMetadataRequest: AWSEncodableShape {
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The resource metadata.
        public let metadata: [String: String]
        /// The ARN of the resource.
        public let resourceArn: String

        public init(globalNetworkId: String, metadata: [String: String], resourceArn: String) {
            self.globalNetworkId = globalNetworkId
            self.metadata = metadata
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encode(self.metadata, forKey: .metadata)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.metadata.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 256)
                try validate($0.key, name: "metadata.key", parent: name, pattern: "^[\\s\\S]*$")
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "metadata[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1500)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
        }
    }

    public struct UpdateNetworkResourceMetadataResponse: AWSDecodableShape {
        /// The updated resource metadata.
        public let metadata: [String: String]?
        /// The ARN of the resource.
        public let resourceArn: String?

        public init(metadata: [String: String]? = nil, resourceArn: String? = nil) {
            self.metadata = metadata
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
            case resourceArn = "ResourceArn"
        }
    }

    public struct UpdateSiteRequest: AWSEncodableShape {
        /// A description of your site. Constraints: Maximum length of 256 characters.
        public let description: String?
        /// The ID of the global network.
        public let globalNetworkId: String
        /// The site location:    Address: The physical address of the site.    Latitude: The latitude of the site.     Longitude: The longitude of the site.
        public let location: Location?
        /// The ID of your site.
        public let siteId: String

        public init(description: String? = nil, globalNetworkId: String, location: Location? = nil, siteId: String) {
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.globalNetworkId, key: "GlobalNetworkId")
            try container.encodeIfPresent(self.location, forKey: .location)
            request.encodePath(self.siteId, key: "SiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, max: 50)
            try self.validate(self.globalNetworkId, name: "globalNetworkId", parent: name, pattern: "^[\\s\\S]*$")
            try self.location?.validate(name: "\(name).location")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 50)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case location = "Location"
        }
    }

    public struct UpdateSiteResponse: AWSDecodableShape {
        /// Information about the site.
        public let site: Site?

        public init(site: Site? = nil) {
            self.site = site
        }

        private enum CodingKeys: String, CodingKey {
            case site = "Site"
        }
    }

    public struct UpdateVpcAttachmentRequest: AWSEncodableShape {
        /// Adds a subnet ARN to the VPC attachment.
        public let addSubnetArns: [String]?
        /// The ID of the attachment.
        public let attachmentId: String
        /// Additional options for updating the VPC attachment.
        public let options: VpcOptions?
        /// Removes a subnet ARN from the attachment.
        public let removeSubnetArns: [String]?

        public init(addSubnetArns: [String]? = nil, attachmentId: String, options: VpcOptions? = nil, removeSubnetArns: [String]? = nil) {
            self.addSubnetArns = addSubnetArns
            self.attachmentId = attachmentId
            self.options = options
            self.removeSubnetArns = removeSubnetArns
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.addSubnetArns, forKey: .addSubnetArns)
            request.encodePath(self.attachmentId, key: "AttachmentId")
            try container.encodeIfPresent(self.options, forKey: .options)
            try container.encodeIfPresent(self.removeSubnetArns, forKey: .removeSubnetArns)
        }

        public func validate(name: String) throws {
            try self.addSubnetArns?.forEach {
                try validate($0, name: "addSubnetArns[]", parent: name, max: 500)
                try validate($0, name: "addSubnetArns[]", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:subnet\\/subnet-[0-9a-f]{8,17}$|^$")
            }
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 50)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^attachment-([0-9a-f]{8,17})$")
            try self.removeSubnetArns?.forEach {
                try validate($0, name: "removeSubnetArns[]", parent: name, max: 500)
                try validate($0, name: "removeSubnetArns[]", parent: name, pattern: "^arn:[^:]{1,63}:ec2:[^:]{0,63}:[^:]{0,63}:subnet\\/subnet-[0-9a-f]{8,17}$|^$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case addSubnetArns = "AddSubnetArns"
            case options = "Options"
            case removeSubnetArns = "RemoveSubnetArns"
        }
    }

    public struct UpdateVpcAttachmentResponse: AWSDecodableShape {
        /// Describes the updated VPC attachment.
        public let vpcAttachment: VpcAttachment?

        public init(vpcAttachment: VpcAttachment? = nil) {
            self.vpcAttachment = vpcAttachment
        }

        private enum CodingKeys: String, CodingKey {
            case vpcAttachment = "VpcAttachment"
        }
    }

    public struct VpcAttachment: AWSDecodableShape {
        /// Provides details about the VPC attachment.
        public let attachment: Attachment?
        /// Provides details about the VPC attachment.
        public let options: VpcOptions?
        /// The subnet ARNs.
        public let subnetArns: [String]?

        public init(attachment: Attachment? = nil, options: VpcOptions? = nil, subnetArns: [String]? = nil) {
            self.attachment = attachment
            self.options = options
            self.subnetArns = subnetArns
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case options = "Options"
            case subnetArns = "SubnetArns"
        }
    }

    public struct VpcOptions: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether appliance mode is supported.  If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow. The default value is false.
        public let applianceModeSupport: Bool?
        /// Indicates whether IPv6 is supported.
        public let ipv6Support: Bool?

        public init(applianceModeSupport: Bool? = nil, ipv6Support: Bool? = nil) {
            self.applianceModeSupport = applianceModeSupport
            self.ipv6Support = ipv6Support
        }

        private enum CodingKeys: String, CodingKey {
            case applianceModeSupport = "ApplianceModeSupport"
            case ipv6Support = "Ipv6Support"
        }
    }
}

// MARK: - Errors

/// Error enum for NetworkManager
public struct NetworkManagerErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case coreNetworkPolicyException = "CoreNetworkPolicyException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize NetworkManager
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There was a conflict processing the request. Updating or deleting the resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Describes a core network policy exception.
    public static var coreNetworkPolicyException: Self { .init(.coreNetworkPolicyException) }
    /// The request has failed due to an internal error.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// A service limit was exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension NetworkManagerErrorType: Equatable {
    public static func == (lhs: NetworkManagerErrorType, rhs: NetworkManagerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension NetworkManagerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
