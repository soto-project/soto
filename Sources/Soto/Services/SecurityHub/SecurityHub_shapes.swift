//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension SecurityHub {
    // MARK: Enums

    public enum AdminStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AutoEnableStandards: String, CustomStringConvertible, Codable, _SotoSendable {
        case `default` = "DEFAULT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum AwsIamAccessKeyStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum AwsS3BucketNotificationConfigurationS3KeyFilterRuleName: String, CustomStringConvertible, Codable, _SotoSendable {
        case prefix = "Prefix"
        case suffix = "Suffix"
        public var description: String { return self.rawValue }
    }

    public enum ComplianceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case notAvailable = "NOT_AVAILABLE"
        case passed = "PASSED"
        case warning = "WARNING"
        public var description: String { return self.rawValue }
    }

    public enum ControlStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DateRangeUnit: String, CustomStringConvertible, Codable, _SotoSendable {
        case days = "DAYS"
        public var description: String { return self.rawValue }
    }

    public enum IntegrationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case receiveFindingsFromSecurityHub = "RECEIVE_FINDINGS_FROM_SECURITY_HUB"
        case sendFindingsToSecurityHub = "SEND_FINDINGS_TO_SECURITY_HUB"
        case updateFindingsInSecurityHub = "UPDATE_FINDINGS_IN_SECURITY_HUB"
        public var description: String { return self.rawValue }
    }

    public enum MalwareState: String, CustomStringConvertible, Codable, _SotoSendable {
        case observed = "OBSERVED"
        case removalFailed = "REMOVAL_FAILED"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum MalwareType: String, CustomStringConvertible, Codable, _SotoSendable {
        case adware = "ADWARE"
        case blendedThreat = "BLENDED_THREAT"
        case botnetAgent = "BOTNET_AGENT"
        case coinMiner = "COIN_MINER"
        case exploitKit = "EXPLOIT_KIT"
        case keylogger = "KEYLOGGER"
        case macro = "MACRO"
        case potentiallyUnwanted = "POTENTIALLY_UNWANTED"
        case ransomware = "RANSOMWARE"
        case remoteAccess = "REMOTE_ACCESS"
        case rootkit = "ROOTKIT"
        case spyware = "SPYWARE"
        case trojan = "TROJAN"
        case virus = "VIRUS"
        case worm = "WORM"
        public var description: String { return self.rawValue }
    }

    public enum MapFilterComparison: String, CustomStringConvertible, Codable, _SotoSendable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum NetworkDirection: String, CustomStringConvertible, Codable, _SotoSendable {
        case `in` = "IN"
        case out = "OUT"
        public var description: String { return self.rawValue }
    }

    public enum Partition: String, CustomStringConvertible, Codable, _SotoSendable {
        case aws
        case awsCn = "aws-cn"
        case awsUsGov = "aws-us-gov"
        public var description: String { return self.rawValue }
    }

    public enum RecordState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum SeverityLabel: String, CustomStringConvertible, Codable, _SotoSendable {
        case critical = "CRITICAL"
        case high = "HIGH"
        case informational = "INFORMATIONAL"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum SeverityRating: String, CustomStringConvertible, Codable, _SotoSendable {
        case critical = "CRITICAL"
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "asc"
        case descending = "desc"
        public var description: String { return self.rawValue }
    }

    public enum StandardsStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case deleting = "DELETING"
        case failed = "FAILED"
        case incomplete = "INCOMPLETE"
        case pending = "PENDING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum StatusReasonCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case internalError = "INTERNAL_ERROR"
        case noAvailableConfigurationRecorder = "NO_AVAILABLE_CONFIGURATION_RECORDER"
        public var description: String { return self.rawValue }
    }

    public enum StringFilterComparison: String, CustomStringConvertible, Codable, _SotoSendable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        case prefix = "PREFIX"
        case prefixNotEquals = "PREFIX_NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelIndicatorCategory: String, CustomStringConvertible, Codable, _SotoSendable {
        case backdoor = "BACKDOOR"
        case cardStealer = "CARD_STEALER"
        case commandAndControl = "COMMAND_AND_CONTROL"
        case dropSite = "DROP_SITE"
        case exploitSite = "EXPLOIT_SITE"
        case keylogger = "KEYLOGGER"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelIndicatorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case domain = "DOMAIN"
        case emailAddress = "EMAIL_ADDRESS"
        case hashMd5 = "HASH_MD5"
        case hashSha1 = "HASH_SHA1"
        case hashSha256 = "HASH_SHA256"
        case hashSha512 = "HASH_SHA512"
        case ipv4Address = "IPV4_ADDRESS"
        case ipv6Address = "IPV6_ADDRESS"
        case mutex = "MUTEX"
        case process = "PROCESS"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public enum VerificationState: String, CustomStringConvertible, Codable, _SotoSendable {
        case benignPositive = "BENIGN_POSITIVE"
        case falsePositive = "FALSE_POSITIVE"
        case truePositive = "TRUE_POSITIVE"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum VulnerabilityFixAvailable: String, CustomStringConvertible, Codable, _SotoSendable {
        case no = "NO"
        case partial = "PARTIAL"
        case yes = "YES"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowState: String, CustomStringConvertible, Codable, _SotoSendable {
        case assigned = "ASSIGNED"
        case deferred = "DEFERRED"
        case inProgress = "IN_PROGRESS"
        case new = "NEW"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case new = "NEW"
        case notified = "NOTIFIED"
        case resolved = "RESOLVED"
        case suppressed = "SUPPRESSED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcceptAdministratorInvitationRequest: AWSEncodableShape {
        /// The account ID of the Security Hub administrator account that sent the invitation.
        public let administratorId: String
        /// The identifier of the invitation sent from the Security Hub administrator account.
        public let invitationId: String

        public init(administratorId: String, invitationId: String) {
            self.administratorId = administratorId
            self.invitationId = invitationId
        }

        public func validate(name: String) throws {
            try self.validate(self.administratorId, name: "administratorId", parent: name, pattern: "\\S")
            try self.validate(self.invitationId, name: "invitationId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case administratorId = "AdministratorId"
            case invitationId = "InvitationId"
        }
    }

    public struct AcceptAdministratorInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AcceptInvitationRequest: AWSEncodableShape {
        /// The identifier of the invitation sent from the Security Hub administrator account.
        public let invitationId: String
        /// The account ID of the Security Hub administrator account that sent the invitation.
        public let masterId: String

        public init(invitationId: String, masterId: String) {
            self.invitationId = invitationId
            self.masterId = masterId
        }

        public func validate(name: String) throws {
            try self.validate(self.invitationId, name: "invitationId", parent: name, pattern: "\\S")
            try self.validate(self.masterId, name: "masterId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case invitationId = "InvitationId"
            case masterId = "MasterId"
        }
    }

    public struct AcceptInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AccountDetails: AWSEncodableShape {
        /// The ID of an Amazon Web Services account.
        public let accountId: String
        /// The email of an Amazon Web Services account.
        public let email: String?

        public init(accountId: String, email: String? = nil) {
            self.accountId = accountId
            self.email = email
        }

        public func validate(name: String) throws {
            try self.validate(self.email, name: "email", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case email = "Email"
        }
    }

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// The type of action that was detected. The possible action types are:    NETWORK_CONNECTION     AWS_API_CALL     DNS_REQUEST     PORT_PROBE
        public let actionType: String?
        /// Included if ActionType is AWS_API_CALL. Provides details about the API call that was detected.
        public let awsApiCallAction: AwsApiCallAction?
        /// Included if ActionType is DNS_REQUEST. Provides details about the DNS request that was detected.
        public let dnsRequestAction: DnsRequestAction?
        /// Included if ActionType is NETWORK_CONNECTION. Provides details about the network connection that was detected.
        public let networkConnectionAction: NetworkConnectionAction?
        /// Included if ActionType is PORT_PROBE. Provides details about the port probe that was detected.
        public let portProbeAction: PortProbeAction?

        public init(actionType: String? = nil, awsApiCallAction: AwsApiCallAction? = nil, dnsRequestAction: DnsRequestAction? = nil, networkConnectionAction: NetworkConnectionAction? = nil, portProbeAction: PortProbeAction? = nil) {
            self.actionType = actionType
            self.awsApiCallAction = awsApiCallAction
            self.dnsRequestAction = dnsRequestAction
            self.networkConnectionAction = networkConnectionAction
            self.portProbeAction = portProbeAction
        }

        public func validate(name: String) throws {
            try self.validate(self.actionType, name: "actionType", parent: name, pattern: "\\S")
            try self.awsApiCallAction?.validate(name: "\(name).awsApiCallAction")
            try self.dnsRequestAction?.validate(name: "\(name).dnsRequestAction")
            try self.networkConnectionAction?.validate(name: "\(name).networkConnectionAction")
            try self.portProbeAction?.validate(name: "\(name).portProbeAction")
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "ActionType"
            case awsApiCallAction = "AwsApiCallAction"
            case dnsRequestAction = "DnsRequestAction"
            case networkConnectionAction = "NetworkConnectionAction"
            case portProbeAction = "PortProbeAction"
        }
    }

    public struct ActionLocalIpDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IP address.
        public let ipAddressV4: String?

        public init(ipAddressV4: String? = nil) {
            self.ipAddressV4 = ipAddressV4
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAddressV4, name: "ipAddressV4", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddressV4 = "IpAddressV4"
        }
    }

    public struct ActionLocalPortDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of the port.
        public let port: Int?
        /// The port name of the local connection.
        public let portName: String?

        public init(port: Int? = nil, portName: String? = nil) {
            self.port = port
            self.portName = portName
        }

        public func validate(name: String) throws {
            try self.validate(self.portName, name: "portName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case port = "Port"
            case portName = "PortName"
        }
    }

    public struct ActionRemoteIpDetails: AWSEncodableShape & AWSDecodableShape {
        /// The city where the remote IP address is located.
        public let city: City?
        /// The country where the remote IP address is located.
        public let country: Country?
        /// The coordinates of the location of the remote IP address.
        public let geoLocation: GeoLocation?
        /// The IP address.
        public let ipAddressV4: String?
        /// The internet service provider (ISP) organization associated with the remote IP address.
        public let organization: IpOrganizationDetails?

        public init(city: City? = nil, country: Country? = nil, geoLocation: GeoLocation? = nil, ipAddressV4: String? = nil, organization: IpOrganizationDetails? = nil) {
            self.city = city
            self.country = country
            self.geoLocation = geoLocation
            self.ipAddressV4 = ipAddressV4
            self.organization = organization
        }

        public func validate(name: String) throws {
            try self.city?.validate(name: "\(name).city")
            try self.country?.validate(name: "\(name).country")
            try self.validate(self.ipAddressV4, name: "ipAddressV4", parent: name, pattern: "\\S")
            try self.organization?.validate(name: "\(name).organization")
        }

        private enum CodingKeys: String, CodingKey {
            case city = "City"
            case country = "Country"
            case geoLocation = "GeoLocation"
            case ipAddressV4 = "IpAddressV4"
            case organization = "Organization"
        }
    }

    public struct ActionRemotePortDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of the port.
        public let port: Int?
        /// The port name of the remote connection.
        public let portName: String?

        public init(port: Int? = nil, portName: String? = nil) {
            self.port = port
            self.portName = portName
        }

        public func validate(name: String) throws {
            try self.validate(self.portName, name: "portName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case port = "Port"
            case portName = "PortName"
        }
    }

    public struct ActionTarget: AWSDecodableShape {
        /// The ARN for the target action.
        public let actionTargetArn: String
        /// The description of the target action.
        public let description: String
        /// The name of the action target.
        public let name: String

        public init(actionTargetArn: String, description: String, name: String) {
            self.actionTargetArn = actionTargetArn
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct Adjustment: AWSEncodableShape & AWSDecodableShape {
        /// The metric to adjust.
        public let metric: String?
        /// The reason for the adjustment.
        public let reason: String?

        public init(metric: String? = nil, reason: String? = nil) {
            self.metric = metric
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.metric, name: "metric", parent: name, pattern: "\\S")
            try self.validate(self.reason, name: "reason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "Metric"
            case reason = "Reason"
        }
    }

    public struct AdminAccount: AWSDecodableShape {
        /// The Amazon Web Services account identifier of the Security Hub administrator account.
        public let accountId: String?
        /// The current status of the Security Hub administrator account. Indicates whether the account is currently enabled as a Security Hub administrator.
        public let status: AdminStatus?

        public init(accountId: String? = nil, status: AdminStatus? = nil) {
            self.accountId = accountId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case status = "Status"
        }
    }

    public struct AvailabilityZone: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the subnet. You can specify one subnet per Availability Zone.
        public let subnetId: String?
        /// The name of the Availability Zone.
        public let zoneName: String?

        public init(subnetId: String? = nil, zoneName: String? = nil) {
            self.subnetId = subnetId
            self.zoneName = zoneName
        }

        public func validate(name: String) throws {
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
            try self.validate(self.zoneName, name: "zoneName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case subnetId = "SubnetId"
            case zoneName = "ZoneName"
        }
    }

    public struct AwsApiCallAction: AWSEncodableShape & AWSDecodableShape {
        /// Identifies the resources that were affected by the API call.
        public let affectedResources: [String: String]?
        /// The name of the API method that was issued.
        public let api: String?
        /// Indicates whether the API call originated from a remote IP address (remoteip) or from a DNS domain (domain).
        public let callerType: String?
        /// Provided if CallerType is domain. Provides information about the DNS domain that the API call originated from.
        public let domainDetails: AwsApiCallActionDomainDetails?
        /// An ISO8601-formatted timestamp that indicates when the API call was first observed.
        public let firstSeen: String?
        /// An ISO8601-formatted timestamp that indicates when the API call was most recently observed.
        public let lastSeen: String?
        /// Provided if CallerType is remoteIp. Provides information about the remote IP address that the API call originated from.
        public let remoteIpDetails: ActionRemoteIpDetails?
        /// The name of the Amazon Web Services service that the API method belongs to.
        public let serviceName: String?

        public init(affectedResources: [String: String]? = nil, api: String? = nil, callerType: String? = nil, domainDetails: AwsApiCallActionDomainDetails? = nil, firstSeen: String? = nil, lastSeen: String? = nil, remoteIpDetails: ActionRemoteIpDetails? = nil, serviceName: String? = nil) {
            self.affectedResources = affectedResources
            self.api = api
            self.callerType = callerType
            self.domainDetails = domainDetails
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
            self.remoteIpDetails = remoteIpDetails
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.affectedResources?.forEach {
                try validate($0.key, name: "affectedResources.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "affectedResources[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.api, name: "api", parent: name, pattern: "\\S")
            try self.validate(self.callerType, name: "callerType", parent: name, pattern: "\\S")
            try self.domainDetails?.validate(name: "\(name).domainDetails")
            try self.validate(self.firstSeen, name: "firstSeen", parent: name, pattern: "\\S")
            try self.validate(self.lastSeen, name: "lastSeen", parent: name, pattern: "\\S")
            try self.remoteIpDetails?.validate(name: "\(name).remoteIpDetails")
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case affectedResources = "AffectedResources"
            case api = "Api"
            case callerType = "CallerType"
            case domainDetails = "DomainDetails"
            case firstSeen = "FirstSeen"
            case lastSeen = "LastSeen"
            case remoteIpDetails = "RemoteIpDetails"
            case serviceName = "ServiceName"
        }
    }

    public struct AwsApiCallActionDomainDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the DNS domain that issued the API call.
        public let domain: String?

        public init(domain: String? = nil) {
            self.domain = domain
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
        }
    }

    public struct AwsApiGatewayAccessLogSettings: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the CloudWatch Logs log group that receives the access logs.
        public let destinationArn: String?
        /// A single-line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public let format: String?

        public init(destinationArn: String? = nil, format: String? = nil) {
            self.destinationArn = destinationArn
            self.format = format
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "\\S")
            try self.validate(self.format, name: "format", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn = "DestinationArn"
            case format = "Format"
        }
    }

    public struct AwsApiGatewayCanarySettings: AWSEncodableShape & AWSDecodableShape {
        /// The deployment identifier for the canary deployment.
        public let deploymentId: String?
        /// The percentage of traffic that is diverted to a canary deployment.
        public let percentTraffic: Double?
        /// Stage variables that are overridden in the canary release deployment. The variables include new stage variables that are introduced in the canary. Each variable is represented as a string-to-string map between the stage variable name and the variable value.
        public let stageVariableOverrides: [String: String]?
        /// Indicates whether the canary deployment uses the stage cache.
        public let useStageCache: Bool?

        public init(deploymentId: String? = nil, percentTraffic: Double? = nil, stageVariableOverrides: [String: String]? = nil, useStageCache: Bool? = nil) {
            self.deploymentId = deploymentId
            self.percentTraffic = percentTraffic
            self.stageVariableOverrides = stageVariableOverrides
            self.useStageCache = useStageCache
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "\\S")
            try self.stageVariableOverrides?.forEach {
                try validate($0.key, name: "stageVariableOverrides.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "stageVariableOverrides[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "DeploymentId"
            case percentTraffic = "PercentTraffic"
            case stageVariableOverrides = "StageVariableOverrides"
            case useStageCache = "UseStageCache"
        }
    }

    public struct AwsApiGatewayEndpointConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of endpoint types for the REST API. For an edge-optimized API, the endpoint type is EDGE. For a Regional API, the endpoint type is REGIONAL. For a private API, the endpoint type is PRIVATE.
        public let types: [String]?

        public init(types: [String]? = nil) {
            self.types = types
        }

        public func validate(name: String) throws {
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case types = "Types"
        }
    }

    public struct AwsApiGatewayMethodSettings: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the cached responses are encrypted.
        public let cacheDataEncrypted: Bool?
        /// Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.
        public let cacheTtlInSeconds: Int?
        /// Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.
        public let cachingEnabled: Bool?
        /// Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.
        public let dataTraceEnabled: Bool?
        /// The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.
        public let httpMethod: String?
        /// The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs. If the logging level is ERROR, then the logs only include error-level entries. If the logging level is INFO, then the logs include both ERROR events and extra informational events. Valid values: OFF | ERROR | INFO
        public let loggingLevel: String?
        /// Indicates whether CloudWatch metrics are enabled for the method.
        public let metricsEnabled: Bool?
        /// Indicates whether authorization is required for a cache invalidation request.
        public let requireAuthorizationForCacheControl: Bool?
        /// The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash. For example, the path value /resource/subresource must be encoded as /~1resource~1subresource. To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.
        public let resourcePath: String?
        /// The throttling burst limit for the method.
        public let throttlingBurstLimit: Int?
        /// The throttling rate limit for the method.
        public let throttlingRateLimit: Double?
        /// Indicates how to handle unauthorized requests for cache invalidation. Valid values: FAIL_WITH_403 | SUCCEED_WITH_RESPONSE_HEADER | SUCCEED_WITHOUT_RESPONSE_HEADER
        public let unauthorizedCacheControlHeaderStrategy: String?

        public init(cacheDataEncrypted: Bool? = nil, cacheTtlInSeconds: Int? = nil, cachingEnabled: Bool? = nil, dataTraceEnabled: Bool? = nil, httpMethod: String? = nil, loggingLevel: String? = nil, metricsEnabled: Bool? = nil, requireAuthorizationForCacheControl: Bool? = nil, resourcePath: String? = nil, throttlingBurstLimit: Int? = nil, throttlingRateLimit: Double? = nil, unauthorizedCacheControlHeaderStrategy: String? = nil) {
            self.cacheDataEncrypted = cacheDataEncrypted
            self.cacheTtlInSeconds = cacheTtlInSeconds
            self.cachingEnabled = cachingEnabled
            self.dataTraceEnabled = dataTraceEnabled
            self.httpMethod = httpMethod
            self.loggingLevel = loggingLevel
            self.metricsEnabled = metricsEnabled
            self.requireAuthorizationForCacheControl = requireAuthorizationForCacheControl
            self.resourcePath = resourcePath
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
            self.unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy
        }

        public func validate(name: String) throws {
            try self.validate(self.httpMethod, name: "httpMethod", parent: name, pattern: "\\S")
            try self.validate(self.loggingLevel, name: "loggingLevel", parent: name, pattern: "\\S")
            try self.validate(self.resourcePath, name: "resourcePath", parent: name, pattern: "\\S")
            try self.validate(self.unauthorizedCacheControlHeaderStrategy, name: "unauthorizedCacheControlHeaderStrategy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cacheDataEncrypted = "CacheDataEncrypted"
            case cacheTtlInSeconds = "CacheTtlInSeconds"
            case cachingEnabled = "CachingEnabled"
            case dataTraceEnabled = "DataTraceEnabled"
            case httpMethod = "HttpMethod"
            case loggingLevel = "LoggingLevel"
            case metricsEnabled = "MetricsEnabled"
            case requireAuthorizationForCacheControl = "RequireAuthorizationForCacheControl"
            case resourcePath = "ResourcePath"
            case throttlingBurstLimit = "ThrottlingBurstLimit"
            case throttlingRateLimit = "ThrottlingRateLimit"
            case unauthorizedCacheControlHeaderStrategy = "UnauthorizedCacheControlHeaderStrategy"
        }
    }

    public struct AwsApiGatewayRestApiDetails: AWSEncodableShape & AWSDecodableShape {
        /// The source of the API key for metering requests according to a usage plan.  HEADER indicates whether to read the API key from the X-API-Key header of a request.  AUTHORIZER indicates whether to read the API key from the UsageIdentifierKey from a custom authorizer.
        public let apiKeySource: String?
        /// The list of binary media types supported by the REST API.
        public let binaryMediaTypes: [String]?
        /// Indicates when the API was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdDate: String?
        /// A description of the REST API.
        public let description: String?
        /// The endpoint configuration of the REST API.
        public let endpointConfiguration: AwsApiGatewayEndpointConfiguration?
        /// The identifier of the REST API.
        public let id: String?
        /// The minimum size in bytes of a payload before compression is enabled. If null, then compression is disabled. If 0, then all payloads are compressed.
        public let minimumCompressionSize: Int?
        /// The name of the REST API.
        public let name: String?
        /// The version identifier for the REST API.
        public let version: String?

        public init(apiKeySource: String? = nil, binaryMediaTypes: [String]? = nil, createdDate: String? = nil, description: String? = nil, endpointConfiguration: AwsApiGatewayEndpointConfiguration? = nil, id: String? = nil, minimumCompressionSize: Int? = nil, name: String? = nil, version: String? = nil) {
            self.apiKeySource = apiKeySource
            self.binaryMediaTypes = binaryMediaTypes
            self.createdDate = createdDate
            self.description = description
            self.endpointConfiguration = endpointConfiguration
            self.id = id
            self.minimumCompressionSize = minimumCompressionSize
            self.name = name
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKeySource, name: "apiKeySource", parent: name, pattern: "\\S")
            try self.binaryMediaTypes?.forEach {
                try validate($0, name: "binaryMediaTypes[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.createdDate, name: "createdDate", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.endpointConfiguration?.validate(name: "\(name).endpointConfiguration")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySource = "ApiKeySource"
            case binaryMediaTypes = "BinaryMediaTypes"
            case createdDate = "CreatedDate"
            case description = "Description"
            case endpointConfiguration = "EndpointConfiguration"
            case id = "Id"
            case minimumCompressionSize = "MinimumCompressionSize"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct AwsApiGatewayStageDetails: AWSEncodableShape & AWSDecodableShape {
        /// Settings for logging access for the stage.
        public let accessLogSettings: AwsApiGatewayAccessLogSettings?
        /// Indicates whether a cache cluster is enabled for the stage.
        public let cacheClusterEnabled: Bool?
        /// If a cache cluster is enabled, the size of the cache cluster.
        public let cacheClusterSize: String?
        /// If a cache cluster is enabled, the status of the cache cluster.
        public let cacheClusterStatus: String?
        /// Information about settings for canary deployment in the stage.
        public let canarySettings: AwsApiGatewayCanarySettings?
        /// The identifier of the client certificate for the stage.
        public let clientCertificateId: String?
        /// Indicates when the stage was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdDate: String?
        /// The identifier of the deployment that the stage points to.
        public let deploymentId: String?
        /// A description of the stage.
        public let description: String?
        /// The version of the API documentation that is associated with the stage.
        public let documentationVersion: String?
        /// Indicates when the stage was most recently updated. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastUpdatedDate: String?
        /// Defines the method settings for the stage.
        public let methodSettings: [AwsApiGatewayMethodSettings]?
        /// The name of the stage.
        public let stageName: String?
        /// Indicates whether active tracing with X-Ray is enabled for the stage.
        public let tracingEnabled: Bool?
        /// A map that defines the stage variables for the stage. Variable names can have alphanumeric and underscore characters. Variable values can contain the following characters:   Uppercase and lowercase letters   Numbers   Special characters -._~:/?#&=,
        public let variables: [String: String]?
        /// The ARN of the web ACL associated with the stage.
        public let webAclArn: String?

        public init(accessLogSettings: AwsApiGatewayAccessLogSettings? = nil, cacheClusterEnabled: Bool? = nil, cacheClusterSize: String? = nil, cacheClusterStatus: String? = nil, canarySettings: AwsApiGatewayCanarySettings? = nil, clientCertificateId: String? = nil, createdDate: String? = nil, deploymentId: String? = nil, description: String? = nil, documentationVersion: String? = nil, lastUpdatedDate: String? = nil, methodSettings: [AwsApiGatewayMethodSettings]? = nil, stageName: String? = nil, tracingEnabled: Bool? = nil, variables: [String: String]? = nil, webAclArn: String? = nil) {
            self.accessLogSettings = accessLogSettings
            self.cacheClusterEnabled = cacheClusterEnabled
            self.cacheClusterSize = cacheClusterSize
            self.cacheClusterStatus = cacheClusterStatus
            self.canarySettings = canarySettings
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.description = description
            self.documentationVersion = documentationVersion
            self.lastUpdatedDate = lastUpdatedDate
            self.methodSettings = methodSettings
            self.stageName = stageName
            self.tracingEnabled = tracingEnabled
            self.variables = variables
            self.webAclArn = webAclArn
        }

        public func validate(name: String) throws {
            try self.accessLogSettings?.validate(name: "\(name).accessLogSettings")
            try self.validate(self.cacheClusterSize, name: "cacheClusterSize", parent: name, pattern: "\\S")
            try self.validate(self.cacheClusterStatus, name: "cacheClusterStatus", parent: name, pattern: "\\S")
            try self.canarySettings?.validate(name: "\(name).canarySettings")
            try self.validate(self.clientCertificateId, name: "clientCertificateId", parent: name, pattern: "\\S")
            try self.validate(self.createdDate, name: "createdDate", parent: name, pattern: "\\S")
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.documentationVersion, name: "documentationVersion", parent: name, pattern: "\\S")
            try self.validate(self.lastUpdatedDate, name: "lastUpdatedDate", parent: name, pattern: "\\S")
            try self.methodSettings?.forEach {
                try $0.validate(name: "\(name).methodSettings[]")
            }
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "\\S")
            try self.variables?.forEach {
                try validate($0.key, name: "variables.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "variables[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.webAclArn, name: "webAclArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogSettings = "AccessLogSettings"
            case cacheClusterEnabled = "CacheClusterEnabled"
            case cacheClusterSize = "CacheClusterSize"
            case cacheClusterStatus = "CacheClusterStatus"
            case canarySettings = "CanarySettings"
            case clientCertificateId = "ClientCertificateId"
            case createdDate = "CreatedDate"
            case deploymentId = "DeploymentId"
            case description = "Description"
            case documentationVersion = "DocumentationVersion"
            case lastUpdatedDate = "LastUpdatedDate"
            case methodSettings = "MethodSettings"
            case stageName = "StageName"
            case tracingEnabled = "TracingEnabled"
            case variables = "Variables"
            case webAclArn = "WebAclArn"
        }
    }

    public struct AwsApiGatewayV2ApiDetails: AWSEncodableShape & AWSDecodableShape {
        /// The URI of the API.  Uses the format  .execute-api..amazonaws.com  The stage name is typically appended to the URI to form a complete path to a deployed API stage.
        public let apiEndpoint: String?
        /// The identifier of the API.
        public let apiId: String?
        /// An API key selection expression. Supported only for WebSocket APIs.
        public let apiKeySelectionExpression: String?
        /// A cross-origin resource sharing (CORS) configuration. Supported only for HTTP APIs.
        public let corsConfiguration: AwsCorsConfiguration?
        /// Indicates when the API was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdDate: String?
        /// A description of the API.
        public let description: String?
        /// The name of the API.
        public let name: String?
        /// The API protocol for the API. Valid values: WEBSOCKET | HTTP
        public let protocolType: String?
        /// The route selection expression for the API. For HTTP APIs, must be ${request.method} ${request.path}. This is the default value for HTTP APIs. For WebSocket APIs, there is no default value.
        public let routeSelectionExpression: String?
        /// The version identifier for the API.
        public let version: String?

        public init(apiEndpoint: String? = nil, apiId: String? = nil, apiKeySelectionExpression: String? = nil, corsConfiguration: AwsCorsConfiguration? = nil, createdDate: String? = nil, description: String? = nil, name: String? = nil, protocolType: String? = nil, routeSelectionExpression: String? = nil, version: String? = nil) {
            self.apiEndpoint = apiEndpoint
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.apiEndpoint, name: "apiEndpoint", parent: name, pattern: "\\S")
            try self.validate(self.apiId, name: "apiId", parent: name, pattern: "\\S")
            try self.validate(self.apiKeySelectionExpression, name: "apiKeySelectionExpression", parent: name, pattern: "\\S")
            try self.corsConfiguration?.validate(name: "\(name).corsConfiguration")
            try self.validate(self.createdDate, name: "createdDate", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.protocolType, name: "protocolType", parent: name, pattern: "\\S")
            try self.validate(self.routeSelectionExpression, name: "routeSelectionExpression", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case apiEndpoint = "ApiEndpoint"
            case apiId = "ApiId"
            case apiKeySelectionExpression = "ApiKeySelectionExpression"
            case corsConfiguration = "CorsConfiguration"
            case createdDate = "CreatedDate"
            case description = "Description"
            case name = "Name"
            case protocolType = "ProtocolType"
            case routeSelectionExpression = "RouteSelectionExpression"
            case version = "Version"
        }
    }

    public struct AwsApiGatewayV2RouteSettings: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether data trace logging is enabled. Data trace logging affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.
        public let dataTraceEnabled: Bool?
        /// Indicates whether detailed metrics are enabled.
        public let detailedMetricsEnabled: Bool?
        /// The logging level. The logging level affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs. If the logging level is ERROR, then the logs only include error-level entries. If the logging level is INFO, then the logs include both ERROR events and extra informational events. Valid values: OFF | ERROR | INFO
        public let loggingLevel: String?
        /// The throttling burst limit.
        public let throttlingBurstLimit: Int?
        /// The throttling rate limit.
        public let throttlingRateLimit: Double?

        public init(dataTraceEnabled: Bool? = nil, detailedMetricsEnabled: Bool? = nil, loggingLevel: String? = nil, throttlingBurstLimit: Int? = nil, throttlingRateLimit: Double? = nil) {
            self.dataTraceEnabled = dataTraceEnabled
            self.detailedMetricsEnabled = detailedMetricsEnabled
            self.loggingLevel = loggingLevel
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.loggingLevel, name: "loggingLevel", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataTraceEnabled = "DataTraceEnabled"
            case detailedMetricsEnabled = "DetailedMetricsEnabled"
            case loggingLevel = "LoggingLevel"
            case throttlingBurstLimit = "ThrottlingBurstLimit"
            case throttlingRateLimit = "ThrottlingRateLimit"
        }
    }

    public struct AwsApiGatewayV2StageDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about settings for logging access for the stage.
        public let accessLogSettings: AwsApiGatewayAccessLogSettings?
        /// Indicates whether the stage is managed by API Gateway.
        public let apiGatewayManaged: Bool?
        /// Indicates whether updates to an API automatically trigger a new deployment.
        public let autoDeploy: Bool?
        /// The identifier of a client certificate for a stage. Supported only for WebSocket API calls.
        public let clientCertificateId: String?
        /// Indicates when the stage was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdDate: String?
        /// Default route settings for the stage.
        public let defaultRouteSettings: AwsApiGatewayV2RouteSettings?
        /// The identifier of the deployment that the stage is associated with.
        public let deploymentId: String?
        /// The description of the stage.
        public let description: String?
        /// The status of the last deployment of a stage. Supported only if the stage has automatic deployment enabled.
        public let lastDeploymentStatusMessage: String?
        /// Indicates when the stage was most recently updated. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastUpdatedDate: String?
        /// The route settings for the stage.
        public let routeSettings: AwsApiGatewayV2RouteSettings?
        /// The name of the stage.
        public let stageName: String?
        /// A map that defines the stage variables for the stage. Variable names can have alphanumeric and underscore characters. Variable values can contain the following characters:   Uppercase and lowercase letters   Numbers   Special characters -._~:/?#&=,
        public let stageVariables: [String: String]?

        public init(accessLogSettings: AwsApiGatewayAccessLogSettings? = nil, apiGatewayManaged: Bool? = nil, autoDeploy: Bool? = nil, clientCertificateId: String? = nil, createdDate: String? = nil, defaultRouteSettings: AwsApiGatewayV2RouteSettings? = nil, deploymentId: String? = nil, description: String? = nil, lastDeploymentStatusMessage: String? = nil, lastUpdatedDate: String? = nil, routeSettings: AwsApiGatewayV2RouteSettings? = nil, stageName: String? = nil, stageVariables: [String: String]? = nil) {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
        }

        public func validate(name: String) throws {
            try self.accessLogSettings?.validate(name: "\(name).accessLogSettings")
            try self.validate(self.clientCertificateId, name: "clientCertificateId", parent: name, pattern: "\\S")
            try self.validate(self.createdDate, name: "createdDate", parent: name, pattern: "\\S")
            try self.defaultRouteSettings?.validate(name: "\(name).defaultRouteSettings")
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.lastDeploymentStatusMessage, name: "lastDeploymentStatusMessage", parent: name, pattern: "\\S")
            try self.validate(self.lastUpdatedDate, name: "lastUpdatedDate", parent: name, pattern: "\\S")
            try self.routeSettings?.validate(name: "\(name).routeSettings")
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "\\S")
            try self.stageVariables?.forEach {
                try validate($0.key, name: "stageVariables.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "stageVariables[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogSettings = "AccessLogSettings"
            case apiGatewayManaged = "ApiGatewayManaged"
            case autoDeploy = "AutoDeploy"
            case clientCertificateId = "ClientCertificateId"
            case createdDate = "CreatedDate"
            case defaultRouteSettings = "DefaultRouteSettings"
            case deploymentId = "DeploymentId"
            case description = "Description"
            case lastDeploymentStatusMessage = "LastDeploymentStatusMessage"
            case lastUpdatedDate = "LastUpdatedDate"
            case routeSettings = "RouteSettings"
            case stageName = "StageName"
            case stageVariables = "StageVariables"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Availability Zone.
        public let value: String?

        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The list of Availability Zones for the automatic scaling group.
        public let availabilityZones: [AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails]?
        /// Indicates whether capacity rebalancing is enabled.
        public let capacityRebalance: Bool?
        /// Indicates when the auto scaling group was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdTime: String?
        /// The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before it checks the health status of an EC2 instance that has come into service.
        public let healthCheckGracePeriod: Int?
        /// The service to use for the health checks. Valid values are EC2 or ELB.
        public let healthCheckType: String?
        /// The name of the launch configuration.
        public let launchConfigurationName: String?
        /// The launch template to use.
        public let launchTemplate: AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification?
        /// The list of load balancers associated with the group.
        public let loadBalancerNames: [String]?
        /// The mixed instances policy for the automatic scaling group.
        public let mixedInstancesPolicy: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails?

        public init(availabilityZones: [AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails]? = nil, capacityRebalance: Bool? = nil, createdTime: String? = nil, healthCheckGracePeriod: Int? = nil, healthCheckType: String? = nil, launchConfigurationName: String? = nil, launchTemplate: AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification? = nil, loadBalancerNames: [String]? = nil, mixedInstancesPolicy: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails? = nil) {
            self.availabilityZones = availabilityZones
            self.capacityRebalance = capacityRebalance
            self.createdTime = createdTime
            self.healthCheckGracePeriod = healthCheckGracePeriod
            self.healthCheckType = healthCheckType
            self.launchConfigurationName = launchConfigurationName
            self.launchTemplate = launchTemplate
            self.loadBalancerNames = loadBalancerNames
            self.mixedInstancesPolicy = mixedInstancesPolicy
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try $0.validate(name: "\(name).availabilityZones[]")
            }
            try self.validate(self.createdTime, name: "createdTime", parent: name, pattern: "\\S")
            try self.validate(self.healthCheckType, name: "healthCheckType", parent: name, pattern: "\\S")
            try self.validate(self.launchConfigurationName, name: "launchConfigurationName", parent: name, pattern: "\\S")
            try self.launchTemplate?.validate(name: "\(name).launchTemplate")
            try self.loadBalancerNames?.forEach {
                try validate($0, name: "loadBalancerNames[]", parent: name, pattern: "\\S")
            }
            try self.mixedInstancesPolicy?.validate(name: "\(name).mixedInstancesPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case capacityRebalance = "CapacityRebalance"
            case createdTime = "CreatedTime"
            case healthCheckGracePeriod = "HealthCheckGracePeriod"
            case healthCheckType = "HealthCheckType"
            case launchConfigurationName = "LaunchConfigurationName"
            case launchTemplate = "LaunchTemplate"
            case loadBalancerNames = "LoadBalancerNames"
            case mixedInstancesPolicy = "MixedInstancesPolicy"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public let launchTemplateId: String?
        /// The name of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public let launchTemplateName: String?
        /// Identifies the version of the launch template. You can specify a version identifier, or use the values $Latest or $Default.
        public let version: String?

        public init(launchTemplateId: String? = nil, launchTemplateName: String? = nil, version: String? = nil) {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.launchTemplateId, name: "launchTemplateId", parent: name, pattern: "\\S")
            try self.validate(self.launchTemplateName, name: "launchTemplateName", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case launchTemplateId = "LaunchTemplateId"
            case launchTemplateName = "LaunchTemplateName"
            case version = "Version"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The instances distribution. The instances distribution specifies the distribution of On-Demand Instances and Spot Instances, the maximum price to pay for Spot Instances, and how the Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacity.
        public let instancesDistribution: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails?
        /// The launch template to use and the instance types (overrides) to use to provision EC2 instances to fulfill On-Demand and Spot capacities.
        public let launchTemplate: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails?

        public init(instancesDistribution: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails? = nil, launchTemplate: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails? = nil) {
            self.instancesDistribution = instancesDistribution
            self.launchTemplate = launchTemplate
        }

        public func validate(name: String) throws {
            try self.instancesDistribution?.validate(name: "\(name).instancesDistribution")
            try self.launchTemplate?.validate(name: "\(name).launchTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case instancesDistribution = "InstancesDistribution"
            case launchTemplate = "LaunchTemplate"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails: AWSEncodableShape & AWSDecodableShape {
        /// How to allocate instance types to fulfill On-Demand capacity. The valid value is prioritized.
        public let onDemandAllocationStrategy: String?
        /// The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances.
        public let onDemandBaseCapacity: Int?
        /// The percentage of On-Demand Instances and Spot Instances for additional capacity beyond OnDemandBaseCapacity.
        public let onDemandPercentageAboveBaseCapacity: Int?
        /// How to allocate instances across Spot Instance pools. Valid values are as follows:    lowest-price     capacity-optimized     capacity-optimized-prioritized
        public let spotAllocationStrategy: String?
        /// The number of Spot Instance pools across which to allocate your Spot Instances.
        public let spotInstancePools: Int?
        /// The maximum price per unit hour that you are willing to pay for a Spot Instance.
        public let spotMaxPrice: String?

        public init(onDemandAllocationStrategy: String? = nil, onDemandBaseCapacity: Int? = nil, onDemandPercentageAboveBaseCapacity: Int? = nil, spotAllocationStrategy: String? = nil, spotInstancePools: Int? = nil, spotMaxPrice: String? = nil) {
            self.onDemandAllocationStrategy = onDemandAllocationStrategy
            self.onDemandBaseCapacity = onDemandBaseCapacity
            self.onDemandPercentageAboveBaseCapacity = onDemandPercentageAboveBaseCapacity
            self.spotAllocationStrategy = spotAllocationStrategy
            self.spotInstancePools = spotInstancePools
            self.spotMaxPrice = spotMaxPrice
        }

        public func validate(name: String) throws {
            try self.validate(self.onDemandAllocationStrategy, name: "onDemandAllocationStrategy", parent: name, pattern: "\\S")
            try self.validate(self.spotAllocationStrategy, name: "spotAllocationStrategy", parent: name, pattern: "\\S")
            try self.validate(self.spotMaxPrice, name: "spotMaxPrice", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case onDemandAllocationStrategy = "OnDemandAllocationStrategy"
            case onDemandBaseCapacity = "OnDemandBaseCapacity"
            case onDemandPercentageAboveBaseCapacity = "OnDemandPercentageAboveBaseCapacity"
            case spotAllocationStrategy = "SpotAllocationStrategy"
            case spotInstancePools = "SpotInstancePools"
            case spotMaxPrice = "SpotMaxPrice"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails: AWSEncodableShape & AWSDecodableShape {
        /// The launch template to use for a mixed instances policy.
        public let launchTemplateSpecification: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification?
        /// Property values to use to override the values in the launch template.
        public let overrides: [AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]?

        public init(launchTemplateSpecification: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification? = nil, overrides: [AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]? = nil) {
            self.launchTemplateSpecification = launchTemplateSpecification
            self.overrides = overrides
        }

        public func validate(name: String) throws {
            try self.launchTemplateSpecification?.validate(name: "\(name).launchTemplateSpecification")
            try self.overrides?.forEach {
                try $0.validate(name: "\(name).overrides[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case launchTemplateSpecification = "LaunchTemplateSpecification"
            case overrides = "Overrides"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public let launchTemplateId: String?
        /// The name of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public let launchTemplateName: String?
        /// Identifies the version of the launch template. You can specify a version identifier, or use the values $Latest or $Default.
        public let version: String?

        public init(launchTemplateId: String? = nil, launchTemplateName: String? = nil, version: String? = nil) {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.launchTemplateId, name: "launchTemplateId", parent: name, pattern: "\\S")
            try self.validate(self.launchTemplateName, name: "launchTemplateName", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case launchTemplateId = "LaunchTemplateId"
            case launchTemplateName = "LaunchTemplateName"
            case version = "Version"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails: AWSEncodableShape & AWSDecodableShape {
        /// The instance type. For example, m3.xlarge.
        public let instanceType: String?
        /// The number of capacity units provided by the specified instance type in terms of virtual CPUs, memory, storage, throughput, or other relative performance characteristic.
        public let weightedCapacity: String?

        public init(instanceType: String? = nil, weightedCapacity: String? = nil) {
            self.instanceType = instanceType
            self.weightedCapacity = weightedCapacity
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
            try self.validate(self.weightedCapacity, name: "weightedCapacity", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceType = "InstanceType"
            case weightedCapacity = "WeightedCapacity"
        }
    }

    public struct AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The device name that is exposed to the EC2 instance. For example, /dev/sdh or xvdh.
        public let deviceName: String?
        /// Parameters that are used to automatically set up Amazon EBS volumes when an instance is launched.
        public let ebs: AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails?
        /// Whether to suppress the device that is included in the block device mapping of the Amazon Machine Image (AMI). If NoDevice is true, then you cannot specify Ebs.>
        public let noDevice: Bool?
        /// The name of the virtual device (for example, ephemeral0). You can provide either VirtualName or Ebs, but not both.
        public let virtualName: String?

        public init(deviceName: String? = nil, ebs: AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails? = nil, noDevice: Bool? = nil, virtualName: String? = nil) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "\\S")
            try self.ebs?.validate(name: "\(name).ebs")
            try self.validate(self.virtualName, name: "virtualName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "DeviceName"
            case ebs = "Ebs"
            case noDevice = "NoDevice"
            case virtualName = "VirtualName"
        }
    }

    public struct AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to delete the volume when the instance is terminated.
        public let deleteOnTermination: Bool?
        /// Whether to encrypt the volume.
        public let encrypted: Bool?
        /// The number of input/output (I/O) operations per second (IOPS) to provision for the volume. Only supported for gp3 or io1 volumes. Required for io1 volumes. Not used with standard, gp2, st1, or sc1 volumes.
        public let iops: Int?
        /// The snapshot ID of the volume to use. You must specify either VolumeSize or SnapshotId.
        public let snapshotId: String?
        /// The volume size, in GiBs. The following are the supported volumes sizes for each volume type:   gp2 and gp3: 1-16,384   io1: 4-16,384   st1 and sc1: 125-16,384   standard: 1-1,024   You must specify either SnapshotId or VolumeSize. If you specify both SnapshotId and VolumeSize, the volume size must be equal or greater than the size of the snapshot.
        public let volumeSize: Int?
        /// The volume type. Valid values are as follows:    gp2     gp3     io1     sc1     st1     standard
        public let volumeType: String?

        public init(deleteOnTermination: Bool? = nil, encrypted: Bool? = nil, iops: Int? = nil, snapshotId: String? = nil, volumeSize: Int? = nil, volumeType: String? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "\\S")
            try self.validate(self.volumeType, name: "volumeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteOnTermination = "DeleteOnTermination"
            case encrypted = "Encrypted"
            case iops = "Iops"
            case snapshotId = "SnapshotId"
            case volumeSize = "VolumeSize"
            case volumeType = "VolumeType"
        }
    }

    public struct AwsAutoScalingLaunchConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// For Auto Scaling groups that run in a VPC, specifies whether to assign a public IP address to the group's instances.
        public let associatePublicIpAddress: Bool?
        /// Specifies the block devices for the instance.
        public let blockDeviceMappings: [AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails]?
        /// The identifier of a ClassicLink-enabled VPC that EC2-Classic instances are linked to.
        public let classicLinkVpcId: String?
        /// The identifiers of one or more security groups for the VPC that is specified in ClassicLinkVPCId.
        public let classicLinkVpcSecurityGroups: [String]?
        /// The creation date and time for the launch configuration. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdTime: String?
        /// Whether the launch configuration is optimized for Amazon EBS I/O.
        public let ebsOptimized: Bool?
        /// The name or the ARN of the instance profile associated with the IAM role for the instance. The instance profile contains the IAM role.
        public let iamInstanceProfile: String?
        /// The identifier of the Amazon Machine Image (AMI) that is used to launch EC2 instances.
        public let imageId: String?
        /// Indicates the type of monitoring for instances in the group.
        public let instanceMonitoring: AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails?
        /// The instance type for the instances.
        public let instanceType: String?
        /// The identifier of the kernel associated with the AMI.
        public let kernelId: String?
        /// The name of the key pair.
        public let keyName: String?
        /// The name of the launch configuration.
        public let launchConfigurationName: String?
        /// The metadata options for the instances.
        public let metadataOptions: AwsAutoScalingLaunchConfigurationMetadataOptions?
        /// The tenancy of the instance. An instance with dedicated tenancy runs on isolated, single-tenant hardware and can only be launched into a VPC.
        public let placementTenancy: String?
        /// The identifier of the RAM disk associated with the AMI.
        public let ramdiskId: String?
        /// The security groups to assign to the instances in the Auto Scaling group.
        public let securityGroups: [String]?
        /// The maximum hourly price to be paid for any Spot Instance that is launched to fulfill the request.
        public let spotPrice: String?
        /// The user data to make available to the launched EC2 instances. Must be base64-encoded text.
        public let userData: String?

        public init(associatePublicIpAddress: Bool? = nil, blockDeviceMappings: [AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails]? = nil, classicLinkVpcId: String? = nil, classicLinkVpcSecurityGroups: [String]? = nil, createdTime: String? = nil, ebsOptimized: Bool? = nil, iamInstanceProfile: String? = nil, imageId: String? = nil, instanceMonitoring: AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails? = nil, instanceType: String? = nil, kernelId: String? = nil, keyName: String? = nil, launchConfigurationName: String? = nil, metadataOptions: AwsAutoScalingLaunchConfigurationMetadataOptions? = nil, placementTenancy: String? = nil, ramdiskId: String? = nil, securityGroups: [String]? = nil, spotPrice: String? = nil, userData: String? = nil) {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.blockDeviceMappings = blockDeviceMappings
            self.classicLinkVpcId = classicLinkVpcId
            self.classicLinkVpcSecurityGroups = classicLinkVpcSecurityGroups
            self.createdTime = createdTime
            self.ebsOptimized = ebsOptimized
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceMonitoring = instanceMonitoring
            self.instanceType = instanceType
            self.kernelId = kernelId
            self.keyName = keyName
            self.launchConfigurationName = launchConfigurationName
            self.metadataOptions = metadataOptions
            self.placementTenancy = placementTenancy
            self.ramdiskId = ramdiskId
            self.securityGroups = securityGroups
            self.spotPrice = spotPrice
            self.userData = userData
        }

        public func validate(name: String) throws {
            try self.blockDeviceMappings?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappings[]")
            }
            try self.validate(self.classicLinkVpcId, name: "classicLinkVpcId", parent: name, pattern: "\\S")
            try self.classicLinkVpcSecurityGroups?.forEach {
                try validate($0, name: "classicLinkVpcSecurityGroups[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.createdTime, name: "createdTime", parent: name, pattern: "\\S")
            try self.validate(self.iamInstanceProfile, name: "iamInstanceProfile", parent: name, pattern: "\\S")
            try self.validate(self.imageId, name: "imageId", parent: name, pattern: "\\S")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
            try self.validate(self.kernelId, name: "kernelId", parent: name, pattern: "\\S")
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "\\S")
            try self.validate(self.launchConfigurationName, name: "launchConfigurationName", parent: name, pattern: "\\S")
            try self.metadataOptions?.validate(name: "\(name).metadataOptions")
            try self.validate(self.placementTenancy, name: "placementTenancy", parent: name, pattern: "\\S")
            try self.validate(self.ramdiskId, name: "ramdiskId", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.spotPrice, name: "spotPrice", parent: name, pattern: "\\S")
            try self.validate(self.userData, name: "userData", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associatePublicIpAddress = "AssociatePublicIpAddress"
            case blockDeviceMappings = "BlockDeviceMappings"
            case classicLinkVpcId = "ClassicLinkVpcId"
            case classicLinkVpcSecurityGroups = "ClassicLinkVpcSecurityGroups"
            case createdTime = "CreatedTime"
            case ebsOptimized = "EbsOptimized"
            case iamInstanceProfile = "IamInstanceProfile"
            case imageId = "ImageId"
            case instanceMonitoring = "InstanceMonitoring"
            case instanceType = "InstanceType"
            case kernelId = "KernelId"
            case keyName = "KeyName"
            case launchConfigurationName = "LaunchConfigurationName"
            case metadataOptions = "MetadataOptions"
            case placementTenancy = "PlacementTenancy"
            case ramdiskId = "RamdiskId"
            case securityGroups = "SecurityGroups"
            case spotPrice = "SpotPrice"
            case userData = "UserData"
        }
    }

    public struct AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails: AWSEncodableShape & AWSDecodableShape {
        /// If set to true, then instances in the group launch with detailed monitoring. If set to false, then instances in the group launch with basic monitoring.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsAutoScalingLaunchConfigurationMetadataOptions: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the HTTP metadata endpoint on your instances. By default, the metadata endpoint is enabled.
        public let httpEndpoint: String?
        /// The HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
        public let httpPutResponseHopLimit: Int?
        /// Indicates whether token usage is required or optional for metadata requests. By default, token usage is optional.
        public let httpTokens: String?

        public init(httpEndpoint: String? = nil, httpPutResponseHopLimit: Int? = nil, httpTokens: String? = nil) {
            self.httpEndpoint = httpEndpoint
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
        }

        public func validate(name: String) throws {
            try self.validate(self.httpEndpoint, name: "httpEndpoint", parent: name, pattern: "\\S")
            try self.validate(self.httpTokens, name: "httpTokens", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case httpEndpoint = "HttpEndpoint"
            case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
            case httpTokens = "HttpTokens"
        }
    }

    public struct AwsBackupBackupPlanAdvancedBackupSettingsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the backup option for a selected resource. This option is only available for Windows
        /// Volume Shadow Copy Service (VSS) backup jobs. Valid values are as follows:   Set to WindowsVSS: enabled to enable the WindowsVSS backup option and create a Windows VSS backup.   Set to WindowsVSS: disabled to create a regular backup. The WindowsVSS option is not enabled by default.
        public let backupOptions: [String: String]?
        /// The name of a resource type. The only supported resource type is Amazon EC2 instances with Windows VSS. The only valid value is EC2.
        public let resourceType: String?

        public init(backupOptions: [String: String]? = nil, resourceType: String? = nil) {
            self.backupOptions = backupOptions
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.backupOptions?.forEach {
                try validate($0.key, name: "backupOptions.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "backupOptions[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case backupOptions = "BackupOptions"
            case resourceType = "ResourceType"
        }
    }

    public struct AwsBackupBackupPlanBackupPlanDetails: AWSEncodableShape & AWSDecodableShape {
        /// A list of backup options for each resource type.
        public let advancedBackupSettings: [AwsBackupBackupPlanAdvancedBackupSettingsDetails]?
        /// The display name of a backup plan.
        public let backupPlanName: String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        public let backupPlanRule: [AwsBackupBackupPlanRuleDetails]?

        public init(advancedBackupSettings: [AwsBackupBackupPlanAdvancedBackupSettingsDetails]? = nil, backupPlanName: String? = nil, backupPlanRule: [AwsBackupBackupPlanRuleDetails]? = nil) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.backupPlanRule = backupPlanRule
        }

        public func validate(name: String) throws {
            try self.advancedBackupSettings?.forEach {
                try $0.validate(name: "\(name).advancedBackupSettings[]")
            }
            try self.validate(self.backupPlanName, name: "backupPlanName", parent: name, pattern: "\\S")
            try self.backupPlanRule?.forEach {
                try $0.validate(name: "\(name).backupPlanRule[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanName = "BackupPlanName"
            case backupPlanRule = "BackupPlanRule"
        }
    }

    public struct AwsBackupBackupPlanDetails: AWSEncodableShape & AWSDecodableShape {
        /// Uniquely identifies the backup plan to be associated with the selection of resources.
        public let backupPlan: AwsBackupBackupPlanBackupPlanDetails?
        /// An Amazon Resource Name (ARN) that uniquely identifies the backup plan.
        public let backupPlanArn: String?
        /// A unique ID for the backup plan.
        public let backupPlanId: String?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings. Version IDs cannot be edited.
        public let versionId: String?

        public init(backupPlan: AwsBackupBackupPlanBackupPlanDetails? = nil, backupPlanArn: String? = nil, backupPlanId: String? = nil, versionId: String? = nil) {
            self.backupPlan = backupPlan
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.backupPlan?.validate(name: "\(name).backupPlan")
            try self.validate(self.backupPlanArn, name: "backupPlanArn", parent: name, pattern: "\\S")
            try self.validate(self.backupPlanId, name: "backupPlanId", parent: name, pattern: "\\S")
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlan = "BackupPlan"
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case versionId = "VersionId"
        }
    }

    public struct AwsBackupBackupPlanLifecycleDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public let deleteAfterDays: Int64?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public let moveToColdStorageAfterDays: Int64?

        public init(deleteAfterDays: Int64? = nil, moveToColdStorageAfterDays: Int64? = nil) {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAfterDays = "DeleteAfterDays"
            case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
        }
    }

    public struct AwsBackupBackupPlanRuleCopyActionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup.
        public let destinationBackupVaultArn: String?
        /// Defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. If you do not specify a lifecycle, Backup applies the lifecycle policy of the source backup to the destination backup. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days.
        public let lifecycle: AwsBackupBackupPlanLifecycleDetails?

        public init(destinationBackupVaultArn: String? = nil, lifecycle: AwsBackupBackupPlanLifecycleDetails? = nil) {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.lifecycle = lifecycle
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationBackupVaultArn, name: "destinationBackupVaultArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationBackupVaultArn = "DestinationBackupVaultArn"
            case lifecycle = "Lifecycle"
        }
    }

    public struct AwsBackupBackupPlanRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// A value in minutes after a backup job is successfully started before it must be completed, or it is canceled by Backup.
        public let completionWindowMinutes: Int64?
        /// An array of CopyAction objects, each of which contains details of the copy operation.
        public let copyActions: [AwsBackupBackupPlanRuleCopyActionsDetails]?
        /// Specifies whether Backup creates continuous backups capable of point-in-time restore (PITR).
        public let enableContinuousBackup: Bool?
        /// Defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. If you do not specify a lifecycle, Backup applies the lifecycle policy of the source backup to the destination backup. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days.
        public let lifecycle: AwsBackupBackupPlanLifecycleDetails?
        /// Uniquely identifies a rule that is used to schedule the backup of a selection of resources.
        public let ruleId: String?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        public let ruleName: String?
        /// A cron expression in UTC specifying when Backup initiates a backup job.
        public let scheduleExpression: String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully.
        public let startWindowMinutes: Int64?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the Amazon Web Services account used to create them and the Amazon Web Services Region  where they are created. They consist of letters, numbers, and hyphens.
        public let targetBackupVault: String?

        public init(completionWindowMinutes: Int64? = nil, copyActions: [AwsBackupBackupPlanRuleCopyActionsDetails]? = nil, enableContinuousBackup: Bool? = nil, lifecycle: AwsBackupBackupPlanLifecycleDetails? = nil, ruleId: String? = nil, ruleName: String? = nil, scheduleExpression: String? = nil, startWindowMinutes: Int64? = nil, targetBackupVault: String? = nil) {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.ruleId = ruleId
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVault = targetBackupVault
        }

        public func validate(name: String) throws {
            try self.copyActions?.forEach {
                try $0.validate(name: "\(name).copyActions[]")
            }
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "\\S")
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, pattern: "\\S")
            try self.validate(self.targetBackupVault, name: "targetBackupVault", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case completionWindowMinutes = "CompletionWindowMinutes"
            case copyActions = "CopyActions"
            case enableContinuousBackup = "EnableContinuousBackup"
            case lifecycle = "Lifecycle"
            case ruleId = "RuleId"
            case ruleName = "RuleName"
            case scheduleExpression = "ScheduleExpression"
            case startWindowMinutes = "StartWindowMinutes"
            case targetBackupVault = "TargetBackupVault"
        }
    }

    public struct AwsBackupBackupVaultDetails: AWSEncodableShape & AWSDecodableShape {
        /// A resource-based policy that is used to manage access permissions on the target backup vault.
        public let accessPolicy: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the
        /// Amazon Web Services account used to create them and the Amazon Web Services Region where they are created.
        /// They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// The unique ARN associated with the server-side encryption key. You can specify a key to encrypt your backups from services that support
        /// full Backup management. If you do not specify a key, Backup creates an KMS key for you by default.
        public let encryptionKeyArn: String?
        /// The Amazon SNS event notifications for the specified backup vault.
        public let notifications: AwsBackupBackupVaultNotificationsDetails?

        public init(accessPolicy: String? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, encryptionKeyArn: String? = nil, notifications: AwsBackupBackupVaultNotificationsDetails? = nil) {
            self.accessPolicy = accessPolicy
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.encryptionKeyArn = encryptionKeyArn
            self.notifications = notifications
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicy, name: "accessPolicy", parent: name, pattern: "\\S")
            try self.validate(self.backupVaultArn, name: "backupVaultArn", parent: name, pattern: "\\S")
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "\\S")
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, pattern: "\\S")
            try self.notifications?.validate(name: "\(name).notifications")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicy = "AccessPolicy"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case encryptionKeyArn = "EncryptionKeyArn"
            case notifications = "Notifications"
        }
    }

    public struct AwsBackupBackupVaultNotificationsDetails: AWSEncodableShape & AWSDecodableShape {
        /// An array of events that indicate the status of jobs to back up resources to the backup vault.
        /// The following events are supported:    BACKUP_JOB_STARTED | BACKUP_JOB_COMPLETED     COPY_JOB_STARTED | COPY_JOB_SUCCESSFUL | COPY_JOB_FAILED     RESTORE_JOB_STARTED | RESTORE_JOB_COMPLETED | RECOVERY_POINT_MODIFIED     S3_BACKUP_OBJECT_FAILED | S3_RESTORE_OBJECT_FAILED
        public let backupVaultEvents: [String]?
        /// An ARN that uniquely identifies the Amazon SNS topic for a backup vaults events.
        public let snsTopicArn: String?

        public init(backupVaultEvents: [String]? = nil, snsTopicArn: String? = nil) {
            self.backupVaultEvents = backupVaultEvents
            self.snsTopicArn = snsTopicArn
        }

        public func validate(name: String) throws {
            try self.backupVaultEvents?.forEach {
                try validate($0, name: "backupVaultEvents[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultEvents = "BackupVaultEvents"
            case snsTopicArn = "SnsTopicArn"
        }
    }

    public struct AwsBackupRecoveryPointCalculatedLifecycleDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater
        /// than 90 days plus MoveToColdStorageAfterDays.
        public let deleteAt: String?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public let moveToColdStorageAt: String?

        public init(deleteAt: String? = nil, moveToColdStorageAt: String? = nil) {
            self.deleteAt = deleteAt
            self.moveToColdStorageAt = moveToColdStorageAt
        }

        public func validate(name: String) throws {
            try self.validate(self.deleteAt, name: "deleteAt", parent: name, pattern: "\\S")
            try self.validate(self.moveToColdStorageAt, name: "moveToColdStorageAt", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAt = "DeleteAt"
            case moveToColdStorageAt = "MoveToColdStorageAt"
        }
    }

    public struct AwsBackupRecoveryPointCreatedByDetails: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most
        /// 1,024 bytes long. Version IDs cannot be edited.
        public let backupPlanVersion: String?
        /// Uniquely identifies a rule used to schedule the backup of a selection of resources.
        public let backupRuleId: String?

        public init(backupPlanArn: String? = nil, backupPlanId: String? = nil, backupPlanVersion: String? = nil, backupRuleId: String? = nil) {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanVersion = backupPlanVersion
            self.backupRuleId = backupRuleId
        }

        public func validate(name: String) throws {
            try self.validate(self.backupPlanArn, name: "backupPlanArn", parent: name, pattern: "\\S")
            try self.validate(self.backupPlanId, name: "backupPlanId", parent: name, pattern: "\\S")
            try self.validate(self.backupPlanVersion, name: "backupPlanVersion", parent: name, pattern: "\\S")
            try self.validate(self.backupRuleId, name: "backupRuleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case backupPlanVersion = "BackupPlanVersion"
            case backupRuleId = "BackupRuleId"
        }
    }

    public struct AwsBackupRecoveryPointDetails: AWSEncodableShape & AWSDecodableShape {
        /// The size, in bytes, of a backup.
        public let backupSizeInBytes: Int64?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names
        /// that are unique to the Amazon Web Services account used to create them and the Amazon Web Services Region
        /// where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public let calculatedLifecycle: AwsBackupRecoveryPointCalculatedLifecycleDetails?
        /// The date and time that a job to create a recovery point is completed, in Unix format and UTC.
        /// The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087
        /// represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: String?
        /// Contains identifying information about the creation of a recovery point, including the
        /// BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId
        /// of the backup plan that is used to create it.
        public let createdBy: AwsBackupRecoveryPointCreatedByDetails?
        /// The date and time a recovery point is created, in Unix format and UTC. The value of CreationDate
        /// is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: String?
        /// The ARN for the server-side encryption key that is used to protect your backups.
        public let encryptionKeyArn: String?
        /// Specifies the IAM role ARN used to create the target recovery point
        public let iamRoleArn: String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is
        /// encrypted, or FALSE if the recovery point is not encrypted.
        public let isEncrypted: Bool?
        /// The date and time that a recovery point was last restored, in Unix format and UTC. The value of
        /// LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents
        /// Friday, January 26, 2018 12:11:30.087 AM.
        public let lastRestoreTime: String?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it
        /// expires. Backup transitions and expires backups automatically according to the lifecycle that
        /// you define
        public let lifecycle: AwsBackupRecoveryPointLifecycleDetails?
        /// An ARN that uniquely identifies a recovery point.
        public let recoveryPointArn: String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The type of Amazon Web Services resource saved as a recovery point, such as an Amazon EBS volume or an Amazon RDS database.
        public let resourceType: String?
        /// The ARN for the backup vault where the recovery point was originally copied from. If the recovery
        /// point is restored to the same account, this value will be null.
        public let sourceBackupVaultArn: String?
        /// A status code specifying the state of the recovery point. Valid values are as follows:    COMPLETED     DELETING     EXPIRED     PARTIAL
        public let status: String?
        /// A message explaining the reason of the recovery point deletion failure.
        public let statusMessage: String?
        /// Specifies the storage class of the recovery point. Valid values are as follows:    COLD     DELETED     WARM
        public let storageClass: String?

        public init(backupSizeInBytes: Int64? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, calculatedLifecycle: AwsBackupRecoveryPointCalculatedLifecycleDetails? = nil, completionDate: String? = nil, createdBy: AwsBackupRecoveryPointCreatedByDetails? = nil, creationDate: String? = nil, encryptionKeyArn: String? = nil, iamRoleArn: String? = nil, isEncrypted: Bool? = nil, lastRestoreTime: String? = nil, lifecycle: AwsBackupRecoveryPointLifecycleDetails? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil, sourceBackupVaultArn: String? = nil, status: String? = nil, statusMessage: String? = nil, storageClass: String? = nil) {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.isEncrypted = isEncrypted
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
            self.storageClass = storageClass
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultArn, name: "backupVaultArn", parent: name, pattern: "\\S")
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "\\S")
            try self.calculatedLifecycle?.validate(name: "\(name).calculatedLifecycle")
            try self.validate(self.completionDate, name: "completionDate", parent: name, pattern: "\\S")
            try self.createdBy?.validate(name: "\(name).createdBy")
            try self.validate(self.creationDate, name: "creationDate", parent: name, pattern: "\\S")
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, pattern: "\\S")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.lastRestoreTime, name: "lastRestoreTime", parent: name, pattern: "\\S")
            try self.validate(self.recoveryPointArn, name: "recoveryPointArn", parent: name, pattern: "\\S")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "\\S")
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "\\S")
            try self.validate(self.sourceBackupVaultArn, name: "sourceBackupVaultArn", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.statusMessage, name: "statusMessage", parent: name, pattern: "\\S")
            try self.validate(self.storageClass, name: "storageClass", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case backupSizeInBytes = "BackupSizeInBytes"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case calculatedLifecycle = "CalculatedLifecycle"
            case completionDate = "CompletionDate"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case encryptionKeyArn = "EncryptionKeyArn"
            case iamRoleArn = "IamRoleArn"
            case isEncrypted = "IsEncrypted"
            case lastRestoreTime = "LastRestoreTime"
            case lifecycle = "Lifecycle"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
            case sourceBackupVaultArn = "SourceBackupVaultArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case storageClass = "StorageClass"
        }
    }

    public struct AwsBackupRecoveryPointLifecycleDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater
        /// than 90 days plus MoveToColdStorageAfterDays.
        public let deleteAfterDays: Int64?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public let moveToColdStorageAfterDays: Int64?

        public init(deleteAfterDays: Int64? = nil, moveToColdStorageAfterDays: Int64? = nil) {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAfterDays = "DeleteAfterDays"
            case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
        }
    }

    public struct AwsCertificateManagerCertificateDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the private certificate authority (CA) that will be used to issue the certificate.
        public let certificateAuthorityArn: String?
        /// Indicates when the certificate was requested. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdAt: String?
        /// The fully qualified domain name (FQDN), such as www.example.com, that is secured by the certificate.
        public let domainName: String?
        /// Contains information about the initial validation of each domain name that occurs as a result of the RequestCertificate request. Only provided if the certificate type is AMAZON_ISSUED.
        public let domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]?
        /// Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a purpose for which the certificate public key can be used and consists of a name and an object identifier (OID).
        public let extendedKeyUsages: [AwsCertificateManagerCertificateExtendedKeyUsage]?
        /// For a failed certificate request, the reason for the failure. Valid values: NO_AVAILABLE_CONTACTS | ADDITIONAL_VERIFICATION_REQUIRED | DOMAIN_NOT_ALLOWED | INVALID_PUBLIC_DOMAIN | DOMAIN_VALIDATION_DENIED | CAA_ERROR | PCA_LIMIT_EXCEEDED | PCA_INVALID_ARN | PCA_INVALID_STATE | PCA_REQUEST_FAILED | PCA_NAME_CONSTRAINTS_VALIDATION | PCA_RESOURCE_NOT_FOUND | PCA_INVALID_ARGS | PCA_INVALID_DURATION | PCA_ACCESS_DENIED | SLR_NOT_FOUND | OTHER
        public let failureReason: String?
        /// Indicates when the certificate was imported. Provided if the certificate type is IMPORTED. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let importedAt: String?
        /// The list of ARNs for the Amazon Web Services resources that use the certificate.
        public let inUseBy: [String]?
        /// Indicates when the certificate was issued. Provided if the certificate type is AMAZON_ISSUED. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let issuedAt: String?
        /// The name of the certificate authority that issued and signed the certificate.
        public let issuer: String?
        /// The algorithm that was used to generate the public-private key pair. Valid values: RSA_2048 | RSA_1024 | RSA_4096 | EC_prime256v1 | EC_secp384r1 | EC_secp521r1
        public let keyAlgorithm: String?
        /// A list of key usage X.509 v3 extension objects.
        public let keyUsages: [AwsCertificateManagerCertificateKeyUsage]?
        /// The time after which the certificate becomes invalid. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let notAfter: String?
        /// The time before which the certificate is not valid. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let notBefore: String?
        /// Provides a value that specifies whether to add the certificate to a transparency log.
        public let options: AwsCertificateManagerCertificateOptions?
        /// Whether the certificate is eligible for renewal. Valid values: ELIGIBLE | INELIGIBLE
        public let renewalEligibility: String?
        /// Information about the status of the Certificate Manager managed renewal for the certificate. Provided only when the certificate type is AMAZON_ISSUED.
        public let renewalSummary: AwsCertificateManagerCertificateRenewalSummary?
        /// The serial number of the certificate.
        public let serial: String?
        /// The algorithm that was used to sign the certificate.
        public let signatureAlgorithm: String?
        /// The status of the certificate. Valid values: PENDING_VALIDATION | ISSUED | INACTIVE | EXPIRED | VALIDATION_TIMED_OUT | REVOKED | FAILED
        public let status: String?
        /// The name of the entity that is associated with the public key contained in the certificate.
        public let subject: String?
        /// One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate. The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website.
        public let subjectAlternativeNames: [String]?
        /// The source of the certificate. For certificates that Certificate Manager provides, Type is AMAZON_ISSUED. For certificates that are imported with ImportCertificate, Type is IMPORTED. Valid values: IMPORTED | AMAZON_ISSUED | PRIVATE
        public let type: String?

        public init(certificateAuthorityArn: String? = nil, createdAt: String? = nil, domainName: String? = nil, domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]? = nil, extendedKeyUsages: [AwsCertificateManagerCertificateExtendedKeyUsage]? = nil, failureReason: String? = nil, importedAt: String? = nil, inUseBy: [String]? = nil, issuedAt: String? = nil, issuer: String? = nil, keyAlgorithm: String? = nil, keyUsages: [AwsCertificateManagerCertificateKeyUsage]? = nil, notAfter: String? = nil, notBefore: String? = nil, options: AwsCertificateManagerCertificateOptions? = nil, renewalEligibility: String? = nil, renewalSummary: AwsCertificateManagerCertificateRenewalSummary? = nil, serial: String? = nil, signatureAlgorithm: String? = nil, status: String? = nil, subject: String? = nil, subjectAlternativeNames: [String]? = nil, type: String? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.createdAt = createdAt
            self.domainName = domainName
            self.domainValidationOptions = domainValidationOptions
            self.extendedKeyUsages = extendedKeyUsages
            self.failureReason = failureReason
            self.importedAt = importedAt
            self.inUseBy = inUseBy
            self.issuedAt = issuedAt
            self.issuer = issuer
            self.keyAlgorithm = keyAlgorithm
            self.keyUsages = keyUsages
            self.notAfter = notAfter
            self.notBefore = notBefore
            self.options = options
            self.renewalEligibility = renewalEligibility
            self.renewalSummary = renewalSummary
            self.serial = serial
            self.signatureAlgorithm = signatureAlgorithm
            self.status = status
            self.subject = subject
            self.subjectAlternativeNames = subjectAlternativeNames
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateAuthorityArn, name: "certificateAuthorityArn", parent: name, pattern: "\\S")
            try self.validate(self.createdAt, name: "createdAt", parent: name, pattern: "\\S")
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.domainValidationOptions?.forEach {
                try $0.validate(name: "\(name).domainValidationOptions[]")
            }
            try self.extendedKeyUsages?.forEach {
                try $0.validate(name: "\(name).extendedKeyUsages[]")
            }
            try self.validate(self.failureReason, name: "failureReason", parent: name, pattern: "\\S")
            try self.validate(self.importedAt, name: "importedAt", parent: name, pattern: "\\S")
            try self.inUseBy?.forEach {
                try validate($0, name: "inUseBy[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.issuedAt, name: "issuedAt", parent: name, pattern: "\\S")
            try self.validate(self.issuer, name: "issuer", parent: name, pattern: "\\S")
            try self.validate(self.keyAlgorithm, name: "keyAlgorithm", parent: name, pattern: "\\S")
            try self.keyUsages?.forEach {
                try $0.validate(name: "\(name).keyUsages[]")
            }
            try self.validate(self.notAfter, name: "notAfter", parent: name, pattern: "\\S")
            try self.validate(self.notBefore, name: "notBefore", parent: name, pattern: "\\S")
            try self.options?.validate(name: "\(name).options")
            try self.validate(self.renewalEligibility, name: "renewalEligibility", parent: name, pattern: "\\S")
            try self.renewalSummary?.validate(name: "\(name).renewalSummary")
            try self.validate(self.serial, name: "serial", parent: name, pattern: "\\S")
            try self.validate(self.signatureAlgorithm, name: "signatureAlgorithm", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.subject, name: "subject", parent: name, pattern: "\\S")
            try self.subjectAlternativeNames?.forEach {
                try validate($0, name: "subjectAlternativeNames[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case domainValidationOptions = "DomainValidationOptions"
            case extendedKeyUsages = "ExtendedKeyUsages"
            case failureReason = "FailureReason"
            case importedAt = "ImportedAt"
            case inUseBy = "InUseBy"
            case issuedAt = "IssuedAt"
            case issuer = "Issuer"
            case keyAlgorithm = "KeyAlgorithm"
            case keyUsages = "KeyUsages"
            case notAfter = "NotAfter"
            case notBefore = "NotBefore"
            case options = "Options"
            case renewalEligibility = "RenewalEligibility"
            case renewalSummary = "RenewalSummary"
            case serial = "Serial"
            case signatureAlgorithm = "SignatureAlgorithm"
            case status = "Status"
            case subject = "Subject"
            case subjectAlternativeNames = "SubjectAlternativeNames"
            case type = "Type"
        }
    }

    public struct AwsCertificateManagerCertificateDomainValidationOption: AWSEncodableShape & AWSDecodableShape {
        /// A fully qualified domain name (FQDN) in the certificate.
        public let domainName: String?
        /// The CNAME record that is added to the DNS database for domain validation.
        public let resourceRecord: AwsCertificateManagerCertificateResourceRecord?
        /// The domain name that Certificate Manager uses to send domain validation emails.
        public let validationDomain: String?
        /// A list of email addresses that Certificate Manager uses to send domain validation emails.
        public let validationEmails: [String]?
        /// The method used to validate the domain name.
        public let validationMethod: String?
        /// The validation status of the domain name.
        public let validationStatus: String?

        public init(domainName: String? = nil, resourceRecord: AwsCertificateManagerCertificateResourceRecord? = nil, validationDomain: String? = nil, validationEmails: [String]? = nil, validationMethod: String? = nil, validationStatus: String? = nil) {
            self.domainName = domainName
            self.resourceRecord = resourceRecord
            self.validationDomain = validationDomain
            self.validationEmails = validationEmails
            self.validationMethod = validationMethod
            self.validationStatus = validationStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.resourceRecord?.validate(name: "\(name).resourceRecord")
            try self.validate(self.validationDomain, name: "validationDomain", parent: name, pattern: "\\S")
            try self.validationEmails?.forEach {
                try validate($0, name: "validationEmails[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.validationMethod, name: "validationMethod", parent: name, pattern: "\\S")
            try self.validate(self.validationStatus, name: "validationStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case resourceRecord = "ResourceRecord"
            case validationDomain = "ValidationDomain"
            case validationEmails = "ValidationEmails"
            case validationMethod = "ValidationMethod"
            case validationStatus = "ValidationStatus"
        }
    }

    public struct AwsCertificateManagerCertificateExtendedKeyUsage: AWSEncodableShape & AWSDecodableShape {
        /// The name of an extension value. Indicates the purpose for which the certificate public key can be used.
        public let name: String?
        /// An object identifier (OID) for the extension value. The format is numbers separated by periods.
        public let oId: String?

        public init(name: String? = nil, oId: String? = nil) {
            self.name = name
            self.oId = oId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.oId, name: "oId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case oId = "OId"
        }
    }

    public struct AwsCertificateManagerCertificateKeyUsage: AWSEncodableShape & AWSDecodableShape {
        /// The key usage extension name.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct AwsCertificateManagerCertificateOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether to add the certificate to a transparency log. Valid values: DISABLED | ENABLED
        public let certificateTransparencyLoggingPreference: String?

        public init(certificateTransparencyLoggingPreference: String? = nil) {
            self.certificateTransparencyLoggingPreference = certificateTransparencyLoggingPreference
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateTransparencyLoggingPreference, name: "certificateTransparencyLoggingPreference", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateTransparencyLoggingPreference = "CertificateTransparencyLoggingPreference"
        }
    }

    public struct AwsCertificateManagerCertificateRenewalSummary: AWSEncodableShape & AWSDecodableShape {
        /// Information about the validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal. Provided only when the certificate type is AMAZON_ISSUED.
        public let domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]?
        /// The status of the Certificate Manager managed renewal of the certificate. Valid values: PENDING_AUTO_RENEWAL | PENDING_VALIDATION | SUCCESS | FAILED
        public let renewalStatus: String?
        /// The reason that a renewal request was unsuccessful. This attribute is used only when RenewalStatus is FAILED. Valid values: NO_AVAILABLE_CONTACTS | ADDITIONAL_VERIFICATION_REQUIRED | DOMAIN_NOT_ALLOWED | INVALID_PUBLIC_DOMAIN | DOMAIN_VALIDATION_DENIED | CAA_ERROR | PCA_LIMIT_EXCEEDED | PCA_INVALID_ARN | PCA_INVALID_STATE | PCA_REQUEST_FAILED | PCA_NAME_CONSTRAINTS_VALIDATION | PCA_RESOURCE_NOT_FOUND | PCA_INVALID_ARGS | PCA_INVALID_DURATION | PCA_ACCESS_DENIED | SLR_NOT_FOUND | OTHER
        public let renewalStatusReason: String?
        /// Indicates when the renewal summary was last updated. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let updatedAt: String?

        public init(domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]? = nil, renewalStatus: String? = nil, renewalStatusReason: String? = nil, updatedAt: String? = nil) {
            self.domainValidationOptions = domainValidationOptions
            self.renewalStatus = renewalStatus
            self.renewalStatusReason = renewalStatusReason
            self.updatedAt = updatedAt
        }

        public func validate(name: String) throws {
            try self.domainValidationOptions?.forEach {
                try $0.validate(name: "\(name).domainValidationOptions[]")
            }
            try self.validate(self.renewalStatus, name: "renewalStatus", parent: name, pattern: "\\S")
            try self.validate(self.renewalStatusReason, name: "renewalStatusReason", parent: name, pattern: "\\S")
            try self.validate(self.updatedAt, name: "updatedAt", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case domainValidationOptions = "DomainValidationOptions"
            case renewalStatus = "RenewalStatus"
            case renewalStatusReason = "RenewalStatusReason"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct AwsCertificateManagerCertificateResourceRecord: AWSEncodableShape & AWSDecodableShape {
        /// The name of the resource.
        public let name: String?
        /// The type of resource.
        public let type: String?
        /// The value of the resource.
        public let value: String?

        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct AwsCloudFormationStackDetails: AWSEncodableShape & AWSDecodableShape {
        /// The capabilities allowed in the stack.
        public let capabilities: [String]?
        /// The time at which the stack was created.
        public let creationTime: String?
        /// A user-defined description associated with the stack.
        public let description: String?
        /// Boolean to enable or disable rollback on stack creation failures.
        public let disableRollback: Bool?
        /// Information about whether a stack's actual configuration differs, or has drifted, from its expected
        /// configuration, as defined in the stack template and any values specified as template parameters.
        public let driftInformation: AwsCloudFormationStackDriftInformationDetails?
        /// Whether termination protection is enabled for the stack.
        public let enableTerminationProtection: Bool?
        /// The time the nested stack was last updated. This field will only be returned if the stack has been
        /// updated at least once.
        public let lastUpdatedTime: String?
        /// The Amazon Resource Names (ARNs) of the Amazon SNS topic to which stack-related events are published.
        public let notificationArns: [String]?
        /// A list of output structures.
        public let outputs: [AwsCloudFormationStackOutputsDetails]?
        /// The ARN of an IAM role that's associated with the stack.
        public let roleArn: String?
        /// Unique identifier of the stack.
        public let stackId: String?
        /// The name associated with the stack.
        public let stackName: String?
        /// Current status of the stack.
        public let stackStatus: String?
        /// Success or failure message associated with the stack status.
        public let stackStatusReason: String?
        /// The length of time, in minutes, that CloudFormation waits for the nested stack to reach
        /// the CREATE_COMPLETE state.
        public let timeoutInMinutes: Int?

        public init(capabilities: [String]? = nil, creationTime: String? = nil, description: String? = nil, disableRollback: Bool? = nil, driftInformation: AwsCloudFormationStackDriftInformationDetails? = nil, enableTerminationProtection: Bool? = nil, lastUpdatedTime: String? = nil, notificationArns: [String]? = nil, outputs: [AwsCloudFormationStackOutputsDetails]? = nil, roleArn: String? = nil, stackId: String? = nil, stackName: String? = nil, stackStatus: String? = nil, stackStatusReason: String? = nil, timeoutInMinutes: Int? = nil) {
            self.capabilities = capabilities
            self.creationTime = creationTime
            self.description = description
            self.disableRollback = disableRollback
            self.driftInformation = driftInformation
            self.enableTerminationProtection = enableTerminationProtection
            self.lastUpdatedTime = lastUpdatedTime
            self.notificationArns = notificationArns
            self.outputs = outputs
            self.roleArn = roleArn
            self.stackId = stackId
            self.stackName = stackName
            self.stackStatus = stackStatus
            self.stackStatusReason = stackStatusReason
            self.timeoutInMinutes = timeoutInMinutes
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.creationTime, name: "creationTime", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.driftInformation?.validate(name: "\(name).driftInformation")
            try self.validate(self.lastUpdatedTime, name: "lastUpdatedTime", parent: name, pattern: "\\S")
            try self.notificationArns?.forEach {
                try validate($0, name: "notificationArns[]", parent: name, pattern: "\\S")
            }
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.stackId, name: "stackId", parent: name, pattern: "\\S")
            try self.validate(self.stackName, name: "stackName", parent: name, pattern: "\\S")
            try self.validate(self.stackStatus, name: "stackStatus", parent: name, pattern: "\\S")
            try self.validate(self.stackStatusReason, name: "stackStatusReason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case creationTime = "CreationTime"
            case description = "Description"
            case disableRollback = "DisableRollback"
            case driftInformation = "DriftInformation"
            case enableTerminationProtection = "EnableTerminationProtection"
            case lastUpdatedTime = "LastUpdatedTime"
            case notificationArns = "NotificationArns"
            case outputs = "Outputs"
            case roleArn = "RoleArn"
            case stackId = "StackId"
            case stackName = "StackName"
            case stackStatus = "StackStatus"
            case stackStatusReason = "StackStatusReason"
            case timeoutInMinutes = "TimeoutInMinutes"
        }
    }

    public struct AwsCloudFormationStackDriftInformationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Status of the stack's actual configuration compared to its expected template configuration.
        public let stackDriftStatus: String?

        public init(stackDriftStatus: String? = nil) {
            self.stackDriftStatus = stackDriftStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.stackDriftStatus, name: "stackDriftStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case stackDriftStatus = "StackDriftStatus"
        }
    }

    public struct AwsCloudFormationStackOutputsDetails: AWSEncodableShape & AWSDecodableShape {
        /// A user-defined description associated with the output.
        public let description: String?
        /// The key associated with the output.
        public let outputKey: String?
        /// The value associated with the output.
        public let outputValue: String?

        public init(description: String? = nil, outputKey: String? = nil, outputValue: String? = nil) {
            self.description = description
            self.outputKey = outputKey
            self.outputValue = outputValue
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.outputKey, name: "outputKey", parent: name, pattern: "\\S")
            try self.validate(self.outputValue, name: "outputValue", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case outputKey = "OutputKey"
            case outputValue = "OutputValue"
        }
    }

    public struct AwsCloudFrontDistributionCacheBehavior: AWSEncodableShape & AWSDecodableShape {
        /// The protocol that viewers can use to access the files in an origin. You can specify the following options:    allow-all - Viewers can use HTTP or HTTPS.    redirect-to-https - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.    https-only - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).
        public let viewerProtocolPolicy: String?

        public init(viewerProtocolPolicy: String? = nil) {
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.viewerProtocolPolicy, name: "viewerProtocolPolicy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case viewerProtocolPolicy = "ViewerProtocolPolicy"
        }
    }

    public struct AwsCloudFrontDistributionCacheBehaviors: AWSEncodableShape & AWSDecodableShape {
        /// The cache behaviors for the distribution.
        public let items: [AwsCloudFrontDistributionCacheBehavior]?

        public init(items: [AwsCloudFrontDistributionCacheBehavior]? = nil) {
            self.items = items
        }

        public func validate(name: String) throws {
            try self.items?.forEach {
                try $0.validate(name: "\(name).items[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
        }
    }

    public struct AwsCloudFrontDistributionDefaultCacheBehavior: AWSEncodableShape & AWSDecodableShape {
        /// The protocol that viewers can use to access the files in an origin. You can specify the following options:    allow-all - Viewers can use HTTP or HTTPS.    redirect-to-https - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.    https-only - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).
        public let viewerProtocolPolicy: String?

        public init(viewerProtocolPolicy: String? = nil) {
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.viewerProtocolPolicy, name: "viewerProtocolPolicy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case viewerProtocolPolicy = "ViewerProtocolPolicy"
        }
    }

    public struct AwsCloudFrontDistributionDetails: AWSEncodableShape & AWSDecodableShape {
        /// Provides information about the cache configuration for the distribution.
        public let cacheBehaviors: AwsCloudFrontDistributionCacheBehaviors?
        /// The default cache behavior for the configuration.
        public let defaultCacheBehavior: AwsCloudFrontDistributionDefaultCacheBehavior?
        /// The object that CloudFront sends in response to requests from the origin (for example, index.html) when a viewer requests the root URL for the distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/product-description.html).
        public let defaultRootObject: String?
        /// The domain name corresponding to the distribution.
        public let domainName: String?
        /// The entity tag is a hash of the object.
        public let eTag: String?
        /// Indicates when that the distribution was last modified. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastModifiedTime: String?
        /// A complex type that controls whether access logs are written for the distribution.
        public let logging: AwsCloudFrontDistributionLogging?
        /// Provides information about the origin groups in the distribution.
        public let originGroups: AwsCloudFrontDistributionOriginGroups?
        /// A complex type that contains information about origins for this distribution.
        public let origins: AwsCloudFrontDistributionOrigins?
        /// Indicates the current status of the distribution.
        public let status: String?
        /// Provides information about the TLS/SSL configuration that the distribution uses to communicate with viewers.
        public let viewerCertificate: AwsCloudFrontDistributionViewerCertificate?
        /// A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution.
        public let webAclId: String?

        public init(cacheBehaviors: AwsCloudFrontDistributionCacheBehaviors? = nil, defaultCacheBehavior: AwsCloudFrontDistributionDefaultCacheBehavior? = nil, defaultRootObject: String? = nil, domainName: String? = nil, eTag: String? = nil, lastModifiedTime: String? = nil, logging: AwsCloudFrontDistributionLogging? = nil, originGroups: AwsCloudFrontDistributionOriginGroups? = nil, origins: AwsCloudFrontDistributionOrigins? = nil, status: String? = nil, viewerCertificate: AwsCloudFrontDistributionViewerCertificate? = nil, webAclId: String? = nil) {
            self.cacheBehaviors = cacheBehaviors
            self.defaultCacheBehavior = defaultCacheBehavior
            self.defaultRootObject = defaultRootObject
            self.domainName = domainName
            self.eTag = eTag
            self.lastModifiedTime = lastModifiedTime
            self.logging = logging
            self.originGroups = originGroups
            self.origins = origins
            self.status = status
            self.viewerCertificate = viewerCertificate
            self.webAclId = webAclId
        }

        public func validate(name: String) throws {
            try self.cacheBehaviors?.validate(name: "\(name).cacheBehaviors")
            try self.defaultCacheBehavior?.validate(name: "\(name).defaultCacheBehavior")
            try self.validate(self.defaultRootObject, name: "defaultRootObject", parent: name, pattern: "\\S")
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "\\S")
            try self.validate(self.lastModifiedTime, name: "lastModifiedTime", parent: name, pattern: "\\S")
            try self.logging?.validate(name: "\(name).logging")
            try self.origins?.validate(name: "\(name).origins")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.viewerCertificate?.validate(name: "\(name).viewerCertificate")
            try self.validate(self.webAclId, name: "webAclId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cacheBehaviors = "CacheBehaviors"
            case defaultCacheBehavior = "DefaultCacheBehavior"
            case defaultRootObject = "DefaultRootObject"
            case domainName = "DomainName"
            case eTag = "ETag"
            case lastModifiedTime = "LastModifiedTime"
            case logging = "Logging"
            case originGroups = "OriginGroups"
            case origins = "Origins"
            case status = "Status"
            case viewerCertificate = "ViewerCertificate"
            case webAclId = "WebAclId"
        }
    }

    public struct AwsCloudFrontDistributionLogging: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket to store the access logs in.
        public let bucket: String?
        /// With this field, you can enable or disable the selected distribution.
        public let enabled: Bool?
        /// Specifies whether you want CloudFront to include cookies in access logs.
        public let includeCookies: Bool?
        /// An optional string that you want CloudFront to use as a prefix to the access log filenames for this distribution.
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool? = nil, includeCookies: Bool? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "\\S")
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case enabled = "Enabled"
            case includeCookies = "IncludeCookies"
            case prefix = "Prefix"
        }
    }

    public struct AwsCloudFrontDistributionOriginCustomOriginConfig: AWSEncodableShape & AWSDecodableShape {
        /// The HTTP port that CloudFront uses to connect to the origin.
        public let httpPort: Int?
        /// The HTTPS port that CloudFront uses to connect to the origin.
        public let httpsPort: Int?
        /// Specifies how long, in seconds, CloudFront persists its connection to the origin.
        public let originKeepaliveTimeout: Int?
        /// Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin.
        public let originProtocolPolicy: String?
        /// Specifies how long, in seconds, CloudFront waits for a response from the origin.
        public let originReadTimeout: Int?
        /// Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS.
        public let originSslProtocols: AwsCloudFrontDistributionOriginSslProtocols?

        public init(httpPort: Int? = nil, httpsPort: Int? = nil, originKeepaliveTimeout: Int? = nil, originProtocolPolicy: String? = nil, originReadTimeout: Int? = nil, originSslProtocols: AwsCloudFrontDistributionOriginSslProtocols? = nil) {
            self.httpPort = httpPort
            self.httpsPort = httpsPort
            self.originKeepaliveTimeout = originKeepaliveTimeout
            self.originProtocolPolicy = originProtocolPolicy
            self.originReadTimeout = originReadTimeout
            self.originSslProtocols = originSslProtocols
        }

        public func validate(name: String) throws {
            try self.validate(self.originProtocolPolicy, name: "originProtocolPolicy", parent: name, pattern: "\\S")
            try self.originSslProtocols?.validate(name: "\(name).originSslProtocols")
        }

        private enum CodingKeys: String, CodingKey {
            case httpPort = "HttpPort"
            case httpsPort = "HttpsPort"
            case originKeepaliveTimeout = "OriginKeepaliveTimeout"
            case originProtocolPolicy = "OriginProtocolPolicy"
            case originReadTimeout = "OriginReadTimeout"
            case originSslProtocols = "OriginSslProtocols"
        }
    }

    public struct AwsCloudFrontDistributionOriginGroup: AWSEncodableShape & AWSDecodableShape {
        /// Provides the criteria for an origin group to fail over.
        public let failoverCriteria: AwsCloudFrontDistributionOriginGroupFailover?

        public init(failoverCriteria: AwsCloudFrontDistributionOriginGroupFailover? = nil) {
            self.failoverCriteria = failoverCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case failoverCriteria = "FailoverCriteria"
        }
    }

    public struct AwsCloudFrontDistributionOriginGroupFailover: AWSEncodableShape & AWSDecodableShape {
        /// Information about the status codes that cause an origin group to fail over.
        public let statusCodes: AwsCloudFrontDistributionOriginGroupFailoverStatusCodes?

        public init(statusCodes: AwsCloudFrontDistributionOriginGroupFailoverStatusCodes? = nil) {
            self.statusCodes = statusCodes
        }

        private enum CodingKeys: String, CodingKey {
            case statusCodes = "StatusCodes"
        }
    }

    public struct AwsCloudFrontDistributionOriginGroupFailoverStatusCodes: AWSEncodableShape & AWSDecodableShape {
        /// The list of status code values that can cause a failover to the next origin.
        public let items: [Int]?
        /// The number of status codes that can cause a failover.
        public let quantity: Int?

        public init(items: [Int]? = nil, quantity: Int? = nil) {
            self.items = items
            self.quantity = quantity
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case quantity = "Quantity"
        }
    }

    public struct AwsCloudFrontDistributionOriginGroups: AWSEncodableShape & AWSDecodableShape {
        /// The list of origin groups.
        public let items: [AwsCloudFrontDistributionOriginGroup]?

        public init(items: [AwsCloudFrontDistributionOriginGroup]? = nil) {
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
        }
    }

    public struct AwsCloudFrontDistributionOriginItem: AWSEncodableShape & AWSDecodableShape {
        /// An origin that is not an Amazon S3 bucket, with one exception.
        /// If the Amazon S3 bucket is configured with static website hosting, use this attribute.
        /// If the Amazon S3 bucket is not configured with static website hosting, use the S3OriginConfig type instead.
        public let customOriginConfig: AwsCloudFrontDistributionOriginCustomOriginConfig?
        /// Amazon S3 origins: The DNS name of the S3 bucket from which you want CloudFront to get objects for this origin.
        public let domainName: String?
        /// A unique identifier for the origin or origin group.
        public let id: String?
        /// An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
        public let originPath: String?
        /// An origin that is an S3 bucket that is not configured with static website hosting.
        public let s3OriginConfig: AwsCloudFrontDistributionOriginS3OriginConfig?

        public init(customOriginConfig: AwsCloudFrontDistributionOriginCustomOriginConfig? = nil, domainName: String? = nil, id: String? = nil, originPath: String? = nil, s3OriginConfig: AwsCloudFrontDistributionOriginS3OriginConfig? = nil) {
            self.customOriginConfig = customOriginConfig
            self.domainName = domainName
            self.id = id
            self.originPath = originPath
            self.s3OriginConfig = s3OriginConfig
        }

        public func validate(name: String) throws {
            try self.customOriginConfig?.validate(name: "\(name).customOriginConfig")
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.originPath, name: "originPath", parent: name, pattern: "\\S")
            try self.s3OriginConfig?.validate(name: "\(name).s3OriginConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case customOriginConfig = "CustomOriginConfig"
            case domainName = "DomainName"
            case id = "Id"
            case originPath = "OriginPath"
            case s3OriginConfig = "S3OriginConfig"
        }
    }

    public struct AwsCloudFrontDistributionOriginS3OriginConfig: AWSEncodableShape & AWSDecodableShape {
        /// The CloudFront origin access identity to associate with the origin.
        public let originAccessIdentity: String?

        public init(originAccessIdentity: String? = nil) {
            self.originAccessIdentity = originAccessIdentity
        }

        public func validate(name: String) throws {
            try self.validate(self.originAccessIdentity, name: "originAccessIdentity", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case originAccessIdentity = "OriginAccessIdentity"
        }
    }

    public struct AwsCloudFrontDistributionOriginSslProtocols: AWSEncodableShape & AWSDecodableShape {
        /// A list that contains allowed SSL/TLS protocols for this distribution.
        public let items: [String]?
        /// The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing
        /// an HTTPS connection with this origin.
        public let quantity: Int?

        public init(items: [String]? = nil, quantity: Int? = nil) {
            self.items = items
            self.quantity = quantity
        }

        public func validate(name: String) throws {
            try self.items?.forEach {
                try validate($0, name: "items[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case quantity = "Quantity"
        }
    }

    public struct AwsCloudFrontDistributionOrigins: AWSEncodableShape & AWSDecodableShape {
        /// A complex type that contains origins or origin groups for this distribution.
        public let items: [AwsCloudFrontDistributionOriginItem]?

        public init(items: [AwsCloudFrontDistributionOriginItem]? = nil) {
            self.items = items
        }

        public func validate(name: String) throws {
            try self.items?.forEach {
                try $0.validate(name: "\(name).items[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
        }
    }

    public struct AwsCloudFrontDistributionViewerCertificate: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the ACM certificate. Used if the certificate is stored in ACM. If you provide an ACM certificate ARN, you must also provide MinimumCertificateVersion and SslSupportMethod.
        public let acmCertificateArn: String?
        /// The identifier of the certificate. Note that in CloudFront, this attribute is deprecated.
        public let certificate: String?
        /// The source of the certificate identified by Certificate. Note that in CloudFront, this attribute is deprecated.
        public let certificateSource: String?
        /// Whether the distribution uses the CloudFront domain name. If set to false, then you provide either AcmCertificateArn or IamCertificateId.
        public let cloudFrontDefaultCertificate: Bool?
        /// The identifier of the IAM certificate. Used if the certificate is stored in IAM. If you provide IamCertificateId, then you also must provide MinimumProtocolVersion and SslSupportMethod.
        public let iamCertificateId: String?
        /// The security policy that CloudFront uses for HTTPS connections with viewers. If SslSupportMethod is sni-only, then MinimumProtocolVersion must be TLSv1 or higher.
        public let minimumProtocolVersion: String?
        /// The viewers that the distribution accepts HTTPS connections from.
        public let sslSupportMethod: String?

        public init(acmCertificateArn: String? = nil, certificate: String? = nil, certificateSource: String? = nil, cloudFrontDefaultCertificate: Bool? = nil, iamCertificateId: String? = nil, minimumProtocolVersion: String? = nil, sslSupportMethod: String? = nil) {
            self.acmCertificateArn = acmCertificateArn
            self.certificate = certificate
            self.certificateSource = certificateSource
            self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
            self.iamCertificateId = iamCertificateId
            self.minimumProtocolVersion = minimumProtocolVersion
            self.sslSupportMethod = sslSupportMethod
        }

        public func validate(name: String) throws {
            try self.validate(self.acmCertificateArn, name: "acmCertificateArn", parent: name, pattern: "\\S")
            try self.validate(self.certificate, name: "certificate", parent: name, pattern: "\\S")
            try self.validate(self.certificateSource, name: "certificateSource", parent: name, pattern: "\\S")
            try self.validate(self.iamCertificateId, name: "iamCertificateId", parent: name, pattern: "\\S")
            try self.validate(self.minimumProtocolVersion, name: "minimumProtocolVersion", parent: name, pattern: "\\S")
            try self.validate(self.sslSupportMethod, name: "sslSupportMethod", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case acmCertificateArn = "AcmCertificateArn"
            case certificate = "Certificate"
            case certificateSource = "CertificateSource"
            case cloudFrontDefaultCertificate = "CloudFrontDefaultCertificate"
            case iamCertificateId = "IamCertificateId"
            case minimumProtocolVersion = "MinimumProtocolVersion"
            case sslSupportMethod = "SslSupportMethod"
        }
    }

    public struct AwsCloudTrailTrailDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the log group that CloudTrail logs are delivered to.
        public let cloudWatchLogsLogGroupArn: String?
        /// The ARN of the role that the CloudWatch Events endpoint assumes when it writes to the log group.
        public let cloudWatchLogsRoleArn: String?
        /// Indicates whether the trail has custom event selectors.
        public let hasCustomEventSelectors: Bool?
        /// The Region where the trail was created.
        public let homeRegion: String?
        /// Indicates whether the trail publishes events from global services such as IAM to the log files.
        public let includeGlobalServiceEvents: Bool?
        /// Indicates whether the trail applies only to the current Region or to all Regions.
        public let isMultiRegionTrail: Bool?
        /// Whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account.
        public let isOrganizationTrail: Bool?
        /// The KMS key ID to use to encrypt the logs.
        public let kmsKeyId: String?
        /// Indicates whether CloudTrail log file validation is enabled.
        public let logFileValidationEnabled: Bool?
        /// The name of the trail.
        public let name: String?
        /// The name of the S3 bucket where the log files are published.
        public let s3BucketName: String?
        /// The S3 key prefix. The key prefix is added after the name of the S3 bucket where the log files are published.
        public let s3KeyPrefix: String?
        /// The ARN of the SNS topic that is used for notifications of log file delivery.
        public let snsTopicArn: String?
        /// The name of the SNS topic that is used for notifications of log file delivery.
        public let snsTopicName: String?
        /// The ARN of the trail.
        public let trailArn: String?

        public init(cloudWatchLogsLogGroupArn: String? = nil, cloudWatchLogsRoleArn: String? = nil, hasCustomEventSelectors: Bool? = nil, homeRegion: String? = nil, includeGlobalServiceEvents: Bool? = nil, isMultiRegionTrail: Bool? = nil, isOrganizationTrail: Bool? = nil, kmsKeyId: String? = nil, logFileValidationEnabled: Bool? = nil, name: String? = nil, s3BucketName: String? = nil, s3KeyPrefix: String? = nil, snsTopicArn: String? = nil, snsTopicName: String? = nil, trailArn: String? = nil) {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.hasCustomEventSelectors = hasCustomEventSelectors
            self.homeRegion = homeRegion
            self.includeGlobalServiceEvents = includeGlobalServiceEvents
            self.isMultiRegionTrail = isMultiRegionTrail
            self.isOrganizationTrail = isOrganizationTrail
            self.kmsKeyId = kmsKeyId
            self.logFileValidationEnabled = logFileValidationEnabled
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.snsTopicArn = snsTopicArn
            self.snsTopicName = snsTopicName
            self.trailArn = trailArn
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.cloudWatchLogsRoleArn, name: "cloudWatchLogsRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.homeRegion, name: "homeRegion", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "\\S")
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, pattern: "\\S")
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "\\S")
            try self.validate(self.snsTopicName, name: "snsTopicName", parent: name, pattern: "\\S")
            try self.validate(self.trailArn, name: "trailArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
            case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
            case hasCustomEventSelectors = "HasCustomEventSelectors"
            case homeRegion = "HomeRegion"
            case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
            case isMultiRegionTrail = "IsMultiRegionTrail"
            case isOrganizationTrail = "IsOrganizationTrail"
            case kmsKeyId = "KmsKeyId"
            case logFileValidationEnabled = "LogFileValidationEnabled"
            case name = "Name"
            case s3BucketName = "S3BucketName"
            case s3KeyPrefix = "S3KeyPrefix"
            case snsTopicArn = "SnsTopicArn"
            case snsTopicName = "SnsTopicName"
            case trailArn = "TrailArn"
        }
    }

    public struct AwsCloudWatchAlarmDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether actions should be executed during any changes to the alarm state.
        public let actionsEnabled: Bool?
        /// The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an ALARM state from any other state.
        public let alarmActions: [String]?
        /// The ARN of the alarm.
        public let alarmArn: String?
        /// The time stamp of the last update to the alarm configuration.
        public let alarmConfigurationUpdatedTimestamp: String?
        /// The description of the alarm.
        public let alarmDescription: String?
        /// The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID
        /// and uses that ID for the alarm name.
        public let alarmName: String?
        /// The arithmetic operation to use when comparing the specified statistic and threshold. The specified
        /// statistic value is used as the first operand.
        public let comparisonOperator: String?
        /// The number of datapoints that must be breaching to trigger the alarm.
        public let datapointsToAlarm: Int?
        /// The dimensions for the metric associated with the alarm.
        public let dimensions: [AwsCloudWatchAlarmDimensionsDetails]?
        /// Used only for alarms based on percentiles. If ignore, the alarm state does not change during
        /// periods with too few data points to be statistically significant. If evaluate or this parameter is not used,
        /// the alarm is always evaluated and possibly changes state no matter how many data points are available.
        public let evaluateLowSampleCountPercentile: String?
        /// The number of periods over which data is compared to the specified threshold.
        public let evaluationPeriods: Int?
        /// The percentile statistic for the metric associated with the alarm.
        public let extendedStatistic: String?
        /// The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from
        /// any other state. Each action is specified as an ARN.
        public let insufficientDataActions: [String]?
        /// The name of the metric associated with the alarm. This is required for an alarm based on a metric.
        /// For an alarm based on a math expression, you use Metrics instead and you can't specify MetricName.
        public let metricName: String?
        /// The namespace of the metric associated with the alarm. This is required for an alarm based on a
        /// metric. For an alarm based on a math expression, you can't specify Namespace and you use
        /// Metrics instead.
        public let namespace: String?
        /// The actions to execute when this alarm transitions to the OK state from any other state.
        /// Each action is specified as an ARN.
        public let okActions: [String]?
        /// The period, in seconds, over which the statistic is applied. This is required for an alarm based on a
        /// metric.
        public let period: Int?
        /// The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ExtendedStatistic. For an alarm based on a metric, you must specify either Statistic or ExtendedStatistic but not both. For an alarm based on a math expression, you can't specify Statistic. Instead, you use Metrics.
        public let statistic: String?
        /// The value to compare with the specified statistic.
        public let threshold: Double?
        /// n an alarm based on an anomaly detection model, this is the ID of the ANOMALY_DETECTION_BAND function used as the threshold for the alarm.
        public let thresholdMetricId: String?
        /// Sets how this alarm is to handle missing data points.
        public let treatMissingData: String?
        /// The unit of the metric associated with the alarm.
        public let unit: String?

        public init(actionsEnabled: Bool? = nil, alarmActions: [String]? = nil, alarmArn: String? = nil, alarmConfigurationUpdatedTimestamp: String? = nil, alarmDescription: String? = nil, alarmName: String? = nil, comparisonOperator: String? = nil, datapointsToAlarm: Int? = nil, dimensions: [AwsCloudWatchAlarmDimensionsDetails]? = nil, evaluateLowSampleCountPercentile: String? = nil, evaluationPeriods: Int? = nil, extendedStatistic: String? = nil, insufficientDataActions: [String]? = nil, metricName: String? = nil, namespace: String? = nil, okActions: [String]? = nil, period: Int? = nil, statistic: String? = nil, threshold: Double? = nil, thresholdMetricId: String? = nil, treatMissingData: String? = nil, unit: String? = nil) {
            self.actionsEnabled = actionsEnabled
            self.alarmActions = alarmActions
            self.alarmArn = alarmArn
            self.alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestamp
            self.alarmDescription = alarmDescription
            self.alarmName = alarmName
            self.comparisonOperator = comparisonOperator
            self.datapointsToAlarm = datapointsToAlarm
            self.dimensions = dimensions
            self.evaluateLowSampleCountPercentile = evaluateLowSampleCountPercentile
            self.evaluationPeriods = evaluationPeriods
            self.extendedStatistic = extendedStatistic
            self.insufficientDataActions = insufficientDataActions
            self.metricName = metricName
            self.namespace = namespace
            self.okActions = okActions
            self.period = period
            self.statistic = statistic
            self.threshold = threshold
            self.thresholdMetricId = thresholdMetricId
            self.treatMissingData = treatMissingData
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.alarmActions?.forEach {
                try validate($0, name: "alarmActions[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.alarmArn, name: "alarmArn", parent: name, pattern: "\\S")
            try self.validate(self.alarmConfigurationUpdatedTimestamp, name: "alarmConfigurationUpdatedTimestamp", parent: name, pattern: "\\S")
            try self.validate(self.alarmDescription, name: "alarmDescription", parent: name, pattern: "\\S")
            try self.validate(self.alarmName, name: "alarmName", parent: name, pattern: "\\S")
            try self.validate(self.comparisonOperator, name: "comparisonOperator", parent: name, pattern: "\\S")
            try self.dimensions?.forEach {
                try $0.validate(name: "\(name).dimensions[]")
            }
            try self.validate(self.evaluateLowSampleCountPercentile, name: "evaluateLowSampleCountPercentile", parent: name, pattern: "\\S")
            try self.validate(self.extendedStatistic, name: "extendedStatistic", parent: name, pattern: "\\S")
            try self.insufficientDataActions?.forEach {
                try validate($0, name: "insufficientDataActions[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "\\S")
            try self.okActions?.forEach {
                try validate($0, name: "okActions[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.statistic, name: "statistic", parent: name, pattern: "\\S")
            try self.validate(self.thresholdMetricId, name: "thresholdMetricId", parent: name, pattern: "\\S")
            try self.validate(self.treatMissingData, name: "treatMissingData", parent: name, pattern: "\\S")
            try self.validate(self.unit, name: "unit", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case actionsEnabled = "ActionsEnabled"
            case alarmActions = "AlarmActions"
            case alarmArn = "AlarmArn"
            case alarmConfigurationUpdatedTimestamp = "AlarmConfigurationUpdatedTimestamp"
            case alarmDescription = "AlarmDescription"
            case alarmName = "AlarmName"
            case comparisonOperator = "ComparisonOperator"
            case datapointsToAlarm = "DatapointsToAlarm"
            case dimensions = "Dimensions"
            case evaluateLowSampleCountPercentile = "EvaluateLowSampleCountPercentile"
            case evaluationPeriods = "EvaluationPeriods"
            case extendedStatistic = "ExtendedStatistic"
            case insufficientDataActions = "InsufficientDataActions"
            case metricName = "MetricName"
            case namespace = "Namespace"
            case okActions = "OkActions"
            case period = "Period"
            case statistic = "Statistic"
            case threshold = "Threshold"
            case thresholdMetricId = "ThresholdMetricId"
            case treatMissingData = "TreatMissingData"
            case unit = "Unit"
        }
    }

    public struct AwsCloudWatchAlarmDimensionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of a dimension.
        public let name: String?
        /// The value of a dimension.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsCodeBuildProjectArtifactsDetails: AWSEncodableShape & AWSDecodableShape {
        /// An identifier for the artifact definition.
        public let artifactIdentifier: String?
        /// Indicates whether to disable encryption on the artifact. Only valid when Type is S3.
        public let encryptionDisabled: Bool?
        /// Only used when Type is S3. The name of the S3 bucket where the artifact is located.
        public let location: String?
        /// Only used when Type is S3. The name of the artifact. Used with NamepaceType and Path to determine the pattern for storing the artifact.
        public let name: String?
        /// Only used when Type is S3. The value to use for the namespace. Used with Name and Path to determine the pattern for storing the artifact.
        public let namespaceType: String?
        /// Whether the name specified in the buildspec file overrides the artifact name.
        public let overrideArtifactName: Bool?
        /// Only used when Type is S3. The type of output artifact to create.
        public let packaging: String?
        /// Only used when Type is S3. The path to the artifact. Used with Name and NamespaceType to determine the pattern for storing the artifact.
        public let path: String?
        /// The type of build artifact.
        public let type: String?

        public init(artifactIdentifier: String? = nil, encryptionDisabled: Bool? = nil, location: String? = nil, name: String? = nil, namespaceType: String? = nil, overrideArtifactName: Bool? = nil, packaging: String? = nil, path: String? = nil, type: String? = nil) {
            self.artifactIdentifier = artifactIdentifier
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.name = name
            self.namespaceType = namespaceType
            self.overrideArtifactName = overrideArtifactName
            self.packaging = packaging
            self.path = path
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.artifactIdentifier, name: "artifactIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.location, name: "location", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.namespaceType, name: "namespaceType", parent: name, pattern: "\\S")
            try self.validate(self.packaging, name: "packaging", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactIdentifier = "ArtifactIdentifier"
            case encryptionDisabled = "EncryptionDisabled"
            case location = "Location"
            case name = "Name"
            case namespaceType = "NamespaceType"
            case overrideArtifactName = "OverrideArtifactName"
            case packaging = "Packaging"
            case path = "Path"
            case type = "Type"
        }
    }

    public struct AwsCodeBuildProjectDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about the build artifacts for the CodeBuild project.
        public let artifacts: [AwsCodeBuildProjectArtifactsDetails]?
        /// The KMS key used to encrypt the build output artifacts. You can specify either the ARN of the KMS key or, if available, the KMS key alias (using the format alias/alias-name).
        public let encryptionKey: String?
        /// Information about the build environment for this build project.
        public let environment: AwsCodeBuildProjectEnvironment?
        /// Information about logs for the build project.
        public let logsConfig: AwsCodeBuildProjectLogsConfigDetails?
        /// The name of the build project.
        public let name: String?
        /// Information about the secondary artifacts for the CodeBuild project.
        public let secondaryArtifacts: [AwsCodeBuildProjectArtifactsDetails]?
        /// The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.
        public let serviceRole: String?
        /// Information about the build input source code for this build project.
        public let source: AwsCodeBuildProjectSource?
        /// Information about the VPC configuration that CodeBuild accesses.
        public let vpcConfig: AwsCodeBuildProjectVpcConfig?

        public init(artifacts: [AwsCodeBuildProjectArtifactsDetails]? = nil, encryptionKey: String? = nil, environment: AwsCodeBuildProjectEnvironment? = nil, logsConfig: AwsCodeBuildProjectLogsConfigDetails? = nil, name: String? = nil, secondaryArtifacts: [AwsCodeBuildProjectArtifactsDetails]? = nil, serviceRole: String? = nil, source: AwsCodeBuildProjectSource? = nil, vpcConfig: AwsCodeBuildProjectVpcConfig? = nil) {
            self.artifacts = artifacts
            self.encryptionKey = encryptionKey
            self.environment = environment
            self.logsConfig = logsConfig
            self.name = name
            self.secondaryArtifacts = secondaryArtifacts
            self.serviceRole = serviceRole
            self.source = source
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.artifacts?.forEach {
                try $0.validate(name: "\(name).artifacts[]")
            }
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, pattern: "\\S")
            try self.environment?.validate(name: "\(name).environment")
            try self.logsConfig?.validate(name: "\(name).logsConfig")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.secondaryArtifacts?.forEach {
                try $0.validate(name: "\(name).secondaryArtifacts[]")
            }
            try self.validate(self.serviceRole, name: "serviceRole", parent: name, pattern: "\\S")
            try self.source?.validate(name: "\(name).source")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case artifacts = "Artifacts"
            case encryptionKey = "EncryptionKey"
            case environment = "Environment"
            case logsConfig = "LogsConfig"
            case name = "Name"
            case secondaryArtifacts = "SecondaryArtifacts"
            case serviceRole = "ServiceRole"
            case source = "Source"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct AwsCodeBuildProjectEnvironment: AWSEncodableShape & AWSDecodableShape {
        /// The certificate to use with this build project.
        public let certificate: String?
        /// A set of environment variables to make available to builds for the build project.
        public let environmentVariables: [AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails]?
        /// The type of credentials CodeBuild uses to pull images in your build. Valid values:    CODEBUILD specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust the CodeBuild service principal.    SERVICE_ROLE specifies that CodeBuild uses your build project's service role.   When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an CodeBuild curated image, you must use CODEBUILD credentials.
        public let imagePullCredentialsType: String?
        /// Whether to allow the Docker daemon to run inside a Docker container. Set to true if the build project is used to build Docker images.
        public let privilegedMode: Bool?
        /// The credentials for access to a private registry.
        public let registryCredential: AwsCodeBuildProjectEnvironmentRegistryCredential?
        /// The type of build environment to use for related builds. The environment type ARM_CONTAINER is available only in Regions US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and Europe (Frankfurt). The environment type LINUX_CONTAINER with compute type build.general1.2xlarge is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia). The environment type LINUX_GPU_CONTAINER is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia). Valid values: WINDOWS_CONTAINER | LINUX_CONTAINER | LINUX_GPU_CONTAINER | ARM_CONTAINER
        public let type: String?

        public init(certificate: String? = nil, environmentVariables: [AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails]? = nil, imagePullCredentialsType: String? = nil, privilegedMode: Bool? = nil, registryCredential: AwsCodeBuildProjectEnvironmentRegistryCredential? = nil, type: String? = nil) {
            self.certificate = certificate
            self.environmentVariables = environmentVariables
            self.imagePullCredentialsType = imagePullCredentialsType
            self.privilegedMode = privilegedMode
            self.registryCredential = registryCredential
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.certificate, name: "certificate", parent: name, pattern: "\\S")
            try self.environmentVariables?.forEach {
                try $0.validate(name: "\(name).environmentVariables[]")
            }
            try self.validate(self.imagePullCredentialsType, name: "imagePullCredentialsType", parent: name, pattern: "\\S")
            try self.registryCredential?.validate(name: "\(name).registryCredential")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
            case environmentVariables = "EnvironmentVariables"
            case imagePullCredentialsType = "ImagePullCredentialsType"
            case privilegedMode = "PrivilegedMode"
            case registryCredential = "RegistryCredential"
            case type = "Type"
        }
    }

    public struct AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the environment variable.
        public let name: String?
        /// The type of environment variable.
        public let type: String?
        /// The value of the environment variable.
        public let value: String?

        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct AwsCodeBuildProjectEnvironmentRegistryCredential: AWSEncodableShape & AWSDecodableShape {
        /// The ARN or name of credentials created using Secrets Manager.  The credential can use the name of the credentials only if they exist in your current Amazon Web Services Region.
        public let credential: String?
        /// The service that created the credentials to access a private Docker registry. The valid value, SECRETS_MANAGER, is for Secrets Manager.
        public let credentialProvider: String?

        public init(credential: String? = nil, credentialProvider: String? = nil) {
            self.credential = credential
            self.credentialProvider = credentialProvider
        }

        public func validate(name: String) throws {
            try self.validate(self.credential, name: "credential", parent: name, pattern: "\\S")
            try self.validate(self.credentialProvider, name: "credentialProvider", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case credential = "Credential"
            case credentialProvider = "CredentialProvider"
        }
    }

    public struct AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The group name of the logs in CloudWatch Logs.
        public let groupName: String?
        /// The current status of the logs in CloudWatch Logs for a build project.
        public let status: String?
        /// The prefix of the stream name of the CloudWatch Logs.
        public let streamName: String?

        public init(groupName: String? = nil, status: String? = nil, streamName: String? = nil) {
            self.groupName = groupName
            self.status = status
            self.streamName = streamName
        }

        public func validate(name: String) throws {
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.streamName, name: "streamName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case status = "Status"
            case streamName = "StreamName"
        }
    }

    public struct AwsCodeBuildProjectLogsConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about CloudWatch Logs for the build project.
        public let cloudWatchLogs: AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails?
        /// Information about logs built to an S3 bucket for a build project.
        public let s3Logs: AwsCodeBuildProjectLogsConfigS3LogsDetails?

        public init(cloudWatchLogs: AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails? = nil, s3Logs: AwsCodeBuildProjectLogsConfigS3LogsDetails? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Logs = s3Logs
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogs?.validate(name: "\(name).cloudWatchLogs")
            try self.s3Logs?.validate(name: "\(name).s3Logs")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs = "CloudWatchLogs"
            case s3Logs = "S3Logs"
        }
    }

    public struct AwsCodeBuildProjectLogsConfigS3LogsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to disable encryption of the S3 build log output.
        public let encryptionDisabled: Bool?
        /// The ARN of the S3 bucket and the path prefix for S3 logs.
        public let location: String?
        /// The current status of the S3 build logs.
        public let status: String?

        public init(encryptionDisabled: Bool? = nil, location: String? = nil, status: String? = nil) {
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.location, name: "location", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionDisabled = "EncryptionDisabled"
            case location = "Location"
            case status = "Status"
        }
    }

    public struct AwsCodeBuildProjectSource: AWSEncodableShape & AWSDecodableShape {
        /// Information about the Git clone depth for the build project.
        public let gitCloneDepth: Int?
        /// Whether to ignore SSL warnings while connecting to the project source code.
        public let insecureSsl: Bool?
        /// Information about the location of the source code to be built. Valid values include:   For source code settings that are specified in the source action of a pipeline in CodePipeline, location should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.   For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the build spec file (for example, https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name ).   For source code in an S3 input bucket, one of the following.   The path to the ZIP file that contains the source code (for example, bucket-name/path/to/object-name.zip).   The path to the folder that contains the source code (for example, bucket-name/path/to/source-code/folder/).     For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the build spec file.   For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the build spec file.
        public let location: String?
        /// The type of repository that contains the source code to be built. Valid values are:    BITBUCKET - The source code is in a Bitbucket repository.    CODECOMMIT - The source code is in an CodeCommit repository.    CODEPIPELINE - The source code settings are specified in the source action of a pipeline in CodePipeline.    GITHUB - The source code is in a GitHub repository.    GITHUB_ENTERPRISE - The source code is in a GitHub Enterprise repository.    NO_SOURCE - The project does not have input source code.    S3 - The source code is in an S3 input bucket.
        public let type: String?

        public init(gitCloneDepth: Int? = nil, insecureSsl: Bool? = nil, location: String? = nil, type: String? = nil) {
            self.gitCloneDepth = gitCloneDepth
            self.insecureSsl = insecureSsl
            self.location = location
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.location, name: "location", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case gitCloneDepth = "GitCloneDepth"
            case insecureSsl = "InsecureSsl"
            case location = "Location"
            case type = "Type"
        }
    }

    public struct AwsCodeBuildProjectVpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of one or more security group IDs in your VPC.
        public let securityGroupIds: [String]?
        /// A list of one or more subnet IDs in your VPC.
        public let subnets: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(securityGroupIds: [String]? = nil, subnets: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "\\S")
            }
            try self.subnets?.forEach {
                try validate($0, name: "subnets[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnets = "Subnets"
            case vpcId = "VpcId"
        }
    }

    public struct AwsCorsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the CORS request includes credentials.
        public let allowCredentials: Bool?
        /// The allowed headers for CORS requests.
        public let allowHeaders: [String]?
        /// The allowed methods for CORS requests.
        public let allowMethods: [String]?
        /// The allowed origins for CORS requests.
        public let allowOrigins: [String]?
        /// The exposed headers for CORS requests.
        public let exposeHeaders: [String]?
        /// The number of seconds for which the browser caches preflight request results.
        public let maxAge: Int?

        public init(allowCredentials: Bool? = nil, allowHeaders: [String]? = nil, allowMethods: [String]? = nil, allowOrigins: [String]? = nil, exposeHeaders: [String]? = nil, maxAge: Int? = nil) {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }

        public func validate(name: String) throws {
            try self.allowHeaders?.forEach {
                try validate($0, name: "allowHeaders[]", parent: name, pattern: "\\S")
            }
            try self.allowMethods?.forEach {
                try validate($0, name: "allowMethods[]", parent: name, pattern: "\\S")
            }
            try self.allowOrigins?.forEach {
                try validate($0, name: "allowOrigins[]", parent: name, pattern: "\\S")
            }
            try self.exposeHeaders?.forEach {
                try validate($0, name: "exposeHeaders[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowCredentials = "AllowCredentials"
            case allowHeaders = "AllowHeaders"
            case allowMethods = "AllowMethods"
            case allowOrigins = "AllowOrigins"
            case exposeHeaders = "ExposeHeaders"
            case maxAge = "MaxAge"
        }
    }

    public struct AwsDynamoDbTableAttributeDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The name of the attribute.
        public let attributeName: String?
        /// The type of the attribute.
        public let attributeType: String?

        public init(attributeName: String? = nil, attributeType: String? = nil) {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "\\S")
            try self.validate(self.attributeType, name: "attributeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeType = "AttributeType"
        }
    }

    public struct AwsDynamoDbTableBillingModeSummary: AWSEncodableShape & AWSDecodableShape {
        /// The method used to charge for read and write throughput and to manage capacity.
        public let billingMode: String?
        /// If the billing mode is PAY_PER_REQUEST, indicates when the billing mode was set to that value. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastUpdateToPayPerRequestDateTime: String?

        public init(billingMode: String? = nil, lastUpdateToPayPerRequestDateTime: String? = nil) {
            self.billingMode = billingMode
            self.lastUpdateToPayPerRequestDateTime = lastUpdateToPayPerRequestDateTime
        }

        public func validate(name: String) throws {
            try self.validate(self.billingMode, name: "billingMode", parent: name, pattern: "\\S")
            try self.validate(self.lastUpdateToPayPerRequestDateTime, name: "lastUpdateToPayPerRequestDateTime", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case billingMode = "BillingMode"
            case lastUpdateToPayPerRequestDateTime = "LastUpdateToPayPerRequestDateTime"
        }
    }

    public struct AwsDynamoDbTableDetails: AWSEncodableShape & AWSDecodableShape {
        /// A list of attribute definitions for the table.
        public let attributeDefinitions: [AwsDynamoDbTableAttributeDefinition]?
        /// Information about the billing for read/write capacity on the table.
        public let billingModeSummary: AwsDynamoDbTableBillingModeSummary?
        /// Indicates when the table was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let creationDateTime: String?
        /// List of global secondary indexes for the table.
        public let globalSecondaryIndexes: [AwsDynamoDbTableGlobalSecondaryIndex]?
        /// The version of global tables being used.
        public let globalTableVersion: String?
        /// The number of items in the table.
        public let itemCount: Int?
        /// The primary key structure for the table.
        public let keySchema: [AwsDynamoDbTableKeySchema]?
        /// The ARN of the latest stream for the table.
        public let latestStreamArn: String?
        /// The label of the latest stream. The label is not a unique identifier.
        public let latestStreamLabel: String?
        /// The list of local secondary indexes for the table.
        public let localSecondaryIndexes: [AwsDynamoDbTableLocalSecondaryIndex]?
        /// Information about the provisioned throughput for the table.
        public let provisionedThroughput: AwsDynamoDbTableProvisionedThroughput?
        /// The list of replicas of this table.
        public let replicas: [AwsDynamoDbTableReplica]?
        /// Information about the restore for the table.
        public let restoreSummary: AwsDynamoDbTableRestoreSummary?
        /// Information about the server-side encryption for the table.
        public let sseDescription: AwsDynamoDbTableSseDescription?
        /// The current DynamoDB Streams configuration for the table.
        public let streamSpecification: AwsDynamoDbTableStreamSpecification?
        /// The identifier of the table.
        public let tableId: String?
        /// The name of the table.
        public let tableName: String?
        /// The total size of the table in bytes.
        public let tableSizeBytes: Int64?
        /// The current status of the table. Valid values are as follows:    ACTIVE     ARCHIVED     ARCHIVING     CREATING     DELETING     INACCESSIBLE_ENCRYPTION_CREDENTIALS     UPDATING
        public let tableStatus: String?

        public init(attributeDefinitions: [AwsDynamoDbTableAttributeDefinition]? = nil, billingModeSummary: AwsDynamoDbTableBillingModeSummary? = nil, creationDateTime: String? = nil, globalSecondaryIndexes: [AwsDynamoDbTableGlobalSecondaryIndex]? = nil, globalTableVersion: String? = nil, itemCount: Int? = nil, keySchema: [AwsDynamoDbTableKeySchema]? = nil, latestStreamArn: String? = nil, latestStreamLabel: String? = nil, localSecondaryIndexes: [AwsDynamoDbTableLocalSecondaryIndex]? = nil, provisionedThroughput: AwsDynamoDbTableProvisionedThroughput? = nil, replicas: [AwsDynamoDbTableReplica]? = nil, restoreSummary: AwsDynamoDbTableRestoreSummary? = nil, sseDescription: AwsDynamoDbTableSseDescription? = nil, streamSpecification: AwsDynamoDbTableStreamSpecification? = nil, tableId: String? = nil, tableName: String? = nil, tableSizeBytes: Int64? = nil, tableStatus: String? = nil) {
            self.attributeDefinitions = attributeDefinitions
            self.billingModeSummary = billingModeSummary
            self.creationDateTime = creationDateTime
            self.globalSecondaryIndexes = globalSecondaryIndexes
            self.globalTableVersion = globalTableVersion
            self.itemCount = itemCount
            self.keySchema = keySchema
            self.latestStreamArn = latestStreamArn
            self.latestStreamLabel = latestStreamLabel
            self.localSecondaryIndexes = localSecondaryIndexes
            self.provisionedThroughput = provisionedThroughput
            self.replicas = replicas
            self.restoreSummary = restoreSummary
            self.sseDescription = sseDescription
            self.streamSpecification = streamSpecification
            self.tableId = tableId
            self.tableName = tableName
            self.tableSizeBytes = tableSizeBytes
            self.tableStatus = tableStatus
        }

        public func validate(name: String) throws {
            try self.attributeDefinitions?.forEach {
                try $0.validate(name: "\(name).attributeDefinitions[]")
            }
            try self.billingModeSummary?.validate(name: "\(name).billingModeSummary")
            try self.validate(self.creationDateTime, name: "creationDateTime", parent: name, pattern: "\\S")
            try self.globalSecondaryIndexes?.forEach {
                try $0.validate(name: "\(name).globalSecondaryIndexes[]")
            }
            try self.validate(self.globalTableVersion, name: "globalTableVersion", parent: name, pattern: "\\S")
            try self.keySchema?.forEach {
                try $0.validate(name: "\(name).keySchema[]")
            }
            try self.validate(self.latestStreamArn, name: "latestStreamArn", parent: name, pattern: "\\S")
            try self.validate(self.latestStreamLabel, name: "latestStreamLabel", parent: name, pattern: "\\S")
            try self.localSecondaryIndexes?.forEach {
                try $0.validate(name: "\(name).localSecondaryIndexes[]")
            }
            try self.provisionedThroughput?.validate(name: "\(name).provisionedThroughput")
            try self.replicas?.forEach {
                try $0.validate(name: "\(name).replicas[]")
            }
            try self.restoreSummary?.validate(name: "\(name).restoreSummary")
            try self.sseDescription?.validate(name: "\(name).sseDescription")
            try self.streamSpecification?.validate(name: "\(name).streamSpecification")
            try self.validate(self.tableId, name: "tableId", parent: name, pattern: "\\S")
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "\\S")
            try self.validate(self.tableStatus, name: "tableStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeDefinitions = "AttributeDefinitions"
            case billingModeSummary = "BillingModeSummary"
            case creationDateTime = "CreationDateTime"
            case globalSecondaryIndexes = "GlobalSecondaryIndexes"
            case globalTableVersion = "GlobalTableVersion"
            case itemCount = "ItemCount"
            case keySchema = "KeySchema"
            case latestStreamArn = "LatestStreamArn"
            case latestStreamLabel = "LatestStreamLabel"
            case localSecondaryIndexes = "LocalSecondaryIndexes"
            case provisionedThroughput = "ProvisionedThroughput"
            case replicas = "Replicas"
            case restoreSummary = "RestoreSummary"
            case sseDescription = "SseDescription"
            case streamSpecification = "StreamSpecification"
            case tableId = "TableId"
            case tableName = "TableName"
            case tableSizeBytes = "TableSizeBytes"
            case tableStatus = "TableStatus"
        }
    }

    public struct AwsDynamoDbTableGlobalSecondaryIndex: AWSEncodableShape & AWSDecodableShape {
        /// Whether the index is currently backfilling.
        public let backfilling: Bool?
        /// The ARN of the index.
        public let indexArn: String?
        /// The name of the index.
        public let indexName: String?
        /// The total size in bytes of the index.
        public let indexSizeBytes: Int64?
        /// The current status of the index.    ACTIVE     CREATING     DELETING     UPDATING
        public let indexStatus: String?
        /// The number of items in the index.
        public let itemCount: Int?
        /// The key schema for the index.
        public let keySchema: [AwsDynamoDbTableKeySchema]?
        /// Attributes that are copied from the table into an index.
        public let projection: AwsDynamoDbTableProjection?
        /// Information about the provisioned throughput settings for the indexes.
        public let provisionedThroughput: AwsDynamoDbTableProvisionedThroughput?

        public init(backfilling: Bool? = nil, indexArn: String? = nil, indexName: String? = nil, indexSizeBytes: Int64? = nil, indexStatus: String? = nil, itemCount: Int? = nil, keySchema: [AwsDynamoDbTableKeySchema]? = nil, projection: AwsDynamoDbTableProjection? = nil, provisionedThroughput: AwsDynamoDbTableProvisionedThroughput? = nil) {
            self.backfilling = backfilling
            self.indexArn = indexArn
            self.indexName = indexName
            self.indexSizeBytes = indexSizeBytes
            self.indexStatus = indexStatus
            self.itemCount = itemCount
            self.keySchema = keySchema
            self.projection = projection
            self.provisionedThroughput = provisionedThroughput
        }

        public func validate(name: String) throws {
            try self.validate(self.indexArn, name: "indexArn", parent: name, pattern: "\\S")
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "\\S")
            try self.validate(self.indexStatus, name: "indexStatus", parent: name, pattern: "\\S")
            try self.keySchema?.forEach {
                try $0.validate(name: "\(name).keySchema[]")
            }
            try self.projection?.validate(name: "\(name).projection")
            try self.provisionedThroughput?.validate(name: "\(name).provisionedThroughput")
        }

        private enum CodingKeys: String, CodingKey {
            case backfilling = "Backfilling"
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case indexSizeBytes = "IndexSizeBytes"
            case indexStatus = "IndexStatus"
            case itemCount = "ItemCount"
            case keySchema = "KeySchema"
            case projection = "Projection"
            case provisionedThroughput = "ProvisionedThroughput"
        }
    }

    public struct AwsDynamoDbTableKeySchema: AWSEncodableShape & AWSDecodableShape {
        /// The name of the key schema attribute.
        public let attributeName: String?
        /// The type of key used for the key schema attribute. Valid values are HASH or RANGE.
        public let keyType: String?

        public init(attributeName: String? = nil, keyType: String? = nil) {
            self.attributeName = attributeName
            self.keyType = keyType
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "\\S")
            try self.validate(self.keyType, name: "keyType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case keyType = "KeyType"
        }
    }

    public struct AwsDynamoDbTableLocalSecondaryIndex: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the index.
        public let indexArn: String?
        /// The name of the index.
        public let indexName: String?
        /// The complete key schema for the index.
        public let keySchema: [AwsDynamoDbTableKeySchema]?
        /// Attributes that are copied from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        public let projection: AwsDynamoDbTableProjection?

        public init(indexArn: String? = nil, indexName: String? = nil, keySchema: [AwsDynamoDbTableKeySchema]? = nil, projection: AwsDynamoDbTableProjection? = nil) {
            self.indexArn = indexArn
            self.indexName = indexName
            self.keySchema = keySchema
            self.projection = projection
        }

        public func validate(name: String) throws {
            try self.validate(self.indexArn, name: "indexArn", parent: name, pattern: "\\S")
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "\\S")
            try self.keySchema?.forEach {
                try $0.validate(name: "\(name).keySchema[]")
            }
            try self.projection?.validate(name: "\(name).projection")
        }

        private enum CodingKeys: String, CodingKey {
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case keySchema = "KeySchema"
            case projection = "Projection"
        }
    }

    public struct AwsDynamoDbTableProjection: AWSEncodableShape & AWSDecodableShape {
        /// The nonkey attributes that are projected into the index. For each attribute, provide the attribute name.
        public let nonKeyAttributes: [String]?
        /// The types of attributes that are projected into the index. Valid values are as follows:    ALL     INCLUDE     KEYS_ONLY
        public let projectionType: String?

        public init(nonKeyAttributes: [String]? = nil, projectionType: String? = nil) {
            self.nonKeyAttributes = nonKeyAttributes
            self.projectionType = projectionType
        }

        public func validate(name: String) throws {
            try self.nonKeyAttributes?.forEach {
                try validate($0, name: "nonKeyAttributes[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.projectionType, name: "projectionType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case nonKeyAttributes = "NonKeyAttributes"
            case projectionType = "ProjectionType"
        }
    }

    public struct AwsDynamoDbTableProvisionedThroughput: AWSEncodableShape & AWSDecodableShape {
        /// Indicates when the provisioned throughput was last decreased. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastDecreaseDateTime: String?
        /// Indicates when the provisioned throughput was last increased. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastIncreaseDateTime: String?
        /// The number of times during the current UTC calendar day that the provisioned throughput was decreased.
        public let numberOfDecreasesToday: Int?
        /// The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ThrottlingException.
        public let readCapacityUnits: Int?
        /// The maximum number of writes consumed per second before DynamoDB returns a ThrottlingException.
        public let writeCapacityUnits: Int?

        public init(lastDecreaseDateTime: String? = nil, lastIncreaseDateTime: String? = nil, numberOfDecreasesToday: Int? = nil, readCapacityUnits: Int? = nil, writeCapacityUnits: Int? = nil) {
            self.lastDecreaseDateTime = lastDecreaseDateTime
            self.lastIncreaseDateTime = lastIncreaseDateTime
            self.numberOfDecreasesToday = numberOfDecreasesToday
            self.readCapacityUnits = readCapacityUnits
            self.writeCapacityUnits = writeCapacityUnits
        }

        public func validate(name: String) throws {
            try self.validate(self.lastDecreaseDateTime, name: "lastDecreaseDateTime", parent: name, pattern: "\\S")
            try self.validate(self.lastIncreaseDateTime, name: "lastIncreaseDateTime", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case lastDecreaseDateTime = "LastDecreaseDateTime"
            case lastIncreaseDateTime = "LastIncreaseDateTime"
            case numberOfDecreasesToday = "NumberOfDecreasesToday"
            case readCapacityUnits = "ReadCapacityUnits"
            case writeCapacityUnits = "WriteCapacityUnits"
        }
    }

    public struct AwsDynamoDbTableProvisionedThroughputOverride: AWSEncodableShape & AWSDecodableShape {
        /// The read capacity units for the replica.
        public let readCapacityUnits: Int?

        public init(readCapacityUnits: Int? = nil) {
            self.readCapacityUnits = readCapacityUnits
        }

        private enum CodingKeys: String, CodingKey {
            case readCapacityUnits = "ReadCapacityUnits"
        }
    }

    public struct AwsDynamoDbTableReplica: AWSEncodableShape & AWSDecodableShape {
        /// List of global secondary indexes for the replica.
        public let globalSecondaryIndexes: [AwsDynamoDbTableReplicaGlobalSecondaryIndex]?
        /// The identifier of the KMS key that will be used for KMS encryption for the replica.
        public let kmsMasterKeyId: String?
        /// Replica-specific configuration for the provisioned throughput.
        public let provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride?
        /// The name of the Region where the replica is located.
        public let regionName: String?
        /// The current status of the replica. Valid values are as follows:    ACTIVE     CREATING     CREATION_FAILED     DELETING     UPDATING
        public let replicaStatus: String?
        /// Detailed information about the replica status.
        public let replicaStatusDescription: String?

        public init(globalSecondaryIndexes: [AwsDynamoDbTableReplicaGlobalSecondaryIndex]? = nil, kmsMasterKeyId: String? = nil, provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride? = nil, regionName: String? = nil, replicaStatus: String? = nil, replicaStatusDescription: String? = nil) {
            self.globalSecondaryIndexes = globalSecondaryIndexes
            self.kmsMasterKeyId = kmsMasterKeyId
            self.provisionedThroughputOverride = provisionedThroughputOverride
            self.regionName = regionName
            self.replicaStatus = replicaStatus
            self.replicaStatusDescription = replicaStatusDescription
        }

        public func validate(name: String) throws {
            try self.globalSecondaryIndexes?.forEach {
                try $0.validate(name: "\(name).globalSecondaryIndexes[]")
            }
            try self.validate(self.kmsMasterKeyId, name: "kmsMasterKeyId", parent: name, pattern: "\\S")
            try self.validate(self.regionName, name: "regionName", parent: name, pattern: "\\S")
            try self.validate(self.replicaStatus, name: "replicaStatus", parent: name, pattern: "\\S")
            try self.validate(self.replicaStatusDescription, name: "replicaStatusDescription", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case globalSecondaryIndexes = "GlobalSecondaryIndexes"
            case kmsMasterKeyId = "KmsMasterKeyId"
            case provisionedThroughputOverride = "ProvisionedThroughputOverride"
            case regionName = "RegionName"
            case replicaStatus = "ReplicaStatus"
            case replicaStatusDescription = "ReplicaStatusDescription"
        }
    }

    public struct AwsDynamoDbTableReplicaGlobalSecondaryIndex: AWSEncodableShape & AWSDecodableShape {
        /// The name of the index.
        public let indexName: String?
        /// Replica-specific configuration for the provisioned throughput for the index.
        public let provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride?

        public init(indexName: String? = nil, provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride? = nil) {
            self.indexName = indexName
            self.provisionedThroughputOverride = provisionedThroughputOverride
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case indexName = "IndexName"
            case provisionedThroughputOverride = "ProvisionedThroughputOverride"
        }
    }

    public struct AwsDynamoDbTableRestoreSummary: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the point in time that the table was restored to. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let restoreDateTime: String?
        /// Whether a restore is currently in progress.
        public let restoreInProgress: Bool?
        /// The ARN of the source backup from which the table was restored.
        public let sourceBackupArn: String?
        /// The ARN of the source table for the backup.
        public let sourceTableArn: String?

        public init(restoreDateTime: String? = nil, restoreInProgress: Bool? = nil, sourceBackupArn: String? = nil, sourceTableArn: String? = nil) {
            self.restoreDateTime = restoreDateTime
            self.restoreInProgress = restoreInProgress
            self.sourceBackupArn = sourceBackupArn
            self.sourceTableArn = sourceTableArn
        }

        public func validate(name: String) throws {
            try self.validate(self.restoreDateTime, name: "restoreDateTime", parent: name, pattern: "\\S")
            try self.validate(self.sourceBackupArn, name: "sourceBackupArn", parent: name, pattern: "\\S")
            try self.validate(self.sourceTableArn, name: "sourceTableArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case restoreDateTime = "RestoreDateTime"
            case restoreInProgress = "RestoreInProgress"
            case sourceBackupArn = "SourceBackupArn"
            case sourceTableArn = "SourceTableArn"
        }
    }

    public struct AwsDynamoDbTableSseDescription: AWSEncodableShape & AWSDecodableShape {
        /// If the key is inaccessible, the date and time when DynamoDB detected that the key was inaccessible. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let inaccessibleEncryptionDateTime: String?
        /// The ARN of the KMS key that is used for the KMS encryption.
        public let kmsMasterKeyArn: String?
        /// The type of server-side encryption.
        public let sseType: String?
        /// The status of the server-side encryption.
        public let status: String?

        public init(inaccessibleEncryptionDateTime: String? = nil, kmsMasterKeyArn: String? = nil, sseType: String? = nil, status: String? = nil) {
            self.inaccessibleEncryptionDateTime = inaccessibleEncryptionDateTime
            self.kmsMasterKeyArn = kmsMasterKeyArn
            self.sseType = sseType
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.inaccessibleEncryptionDateTime, name: "inaccessibleEncryptionDateTime", parent: name, pattern: "\\S")
            try self.validate(self.kmsMasterKeyArn, name: "kmsMasterKeyArn", parent: name, pattern: "\\S")
            try self.validate(self.sseType, name: "sseType", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case inaccessibleEncryptionDateTime = "InaccessibleEncryptionDateTime"
            case kmsMasterKeyArn = "KmsMasterKeyArn"
            case sseType = "SseType"
            case status = "Status"
        }
    }

    public struct AwsDynamoDbTableStreamSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether DynamoDB Streams is enabled on the table.
        public let streamEnabled: Bool?
        /// Determines the information that is written to the table.
        public let streamViewType: String?

        public init(streamEnabled: Bool? = nil, streamViewType: String? = nil) {
            self.streamEnabled = streamEnabled
            self.streamViewType = streamViewType
        }

        public func validate(name: String) throws {
            try self.validate(self.streamViewType, name: "streamViewType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case streamEnabled = "StreamEnabled"
            case streamViewType = "StreamViewType"
        }
    }

    public struct AwsEc2EipDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier that Amazon Web Services assigns to represent the allocation of the Elastic IP address for use with Amazon VPC.
        public let allocationId: String?
        /// The identifier that represents the association of the Elastic IP address with an EC2 instance.
        public let associationId: String?
        /// The domain in which to allocate the address. If the address is for use with EC2 instances in a VPC, then Domain is vpc. Otherwise, Domain is standard.
        public let domain: String?
        /// The identifier of the EC2 instance.
        public let instanceId: String?
        /// The name of the location from which the Elastic IP address is advertised.
        public let networkBorderGroup: String?
        /// The identifier of the network interface.
        public let networkInterfaceId: String?
        /// The Amazon Web Services account ID of the owner of the network interface.
        public let networkInterfaceOwnerId: String?
        /// The private IP address that is associated with the Elastic IP address.
        public let privateIpAddress: String?
        /// A public IP address that is associated with the EC2 instance.
        public let publicIp: String?
        /// The identifier of an IP address pool. This parameter allows Amazon EC2 to select an IP address from the address pool.
        public let publicIpv4Pool: String?

        public init(allocationId: String? = nil, associationId: String? = nil, domain: String? = nil, instanceId: String? = nil, networkBorderGroup: String? = nil, networkInterfaceId: String? = nil, networkInterfaceOwnerId: String? = nil, privateIpAddress: String? = nil, publicIp: String? = nil, publicIpv4Pool: String? = nil) {
            self.allocationId = allocationId
            self.associationId = associationId
            self.domain = domain
            self.instanceId = instanceId
            self.networkBorderGroup = networkBorderGroup
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfaceOwnerId = networkInterfaceOwnerId
            self.privateIpAddress = privateIpAddress
            self.publicIp = publicIp
            self.publicIpv4Pool = publicIpv4Pool
        }

        public func validate(name: String) throws {
            try self.validate(self.allocationId, name: "allocationId", parent: name, pattern: "\\S")
            try self.validate(self.associationId, name: "associationId", parent: name, pattern: "\\S")
            try self.validate(self.domain, name: "domain", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "\\S")
            try self.validate(self.networkBorderGroup, name: "networkBorderGroup", parent: name, pattern: "\\S")
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
            try self.validate(self.networkInterfaceOwnerId, name: "networkInterfaceOwnerId", parent: name, pattern: "\\S")
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "\\S")
            try self.validate(self.publicIp, name: "publicIp", parent: name, pattern: "\\S")
            try self.validate(self.publicIpv4Pool, name: "publicIpv4Pool", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case allocationId = "AllocationId"
            case associationId = "AssociationId"
            case domain = "Domain"
            case instanceId = "InstanceId"
            case networkBorderGroup = "NetworkBorderGroup"
            case networkInterfaceId = "NetworkInterfaceId"
            case networkInterfaceOwnerId = "NetworkInterfaceOwnerId"
            case privateIpAddress = "PrivateIpAddress"
            case publicIp = "PublicIp"
            case publicIpv4Pool = "PublicIpv4Pool"
        }
    }

    public struct AwsEc2InstanceDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IAM profile ARN of the instance.
        public let iamInstanceProfileArn: String?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public let imageId: String?
        /// The IPv4 addresses associated with the instance.
        public let ipV4Addresses: [String]?
        /// The IPv6 addresses associated with the instance.
        public let ipV6Addresses: [String]?
        /// The key name associated with the instance.
        public let keyName: String?
        /// Indicates when the instance was launched. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let launchedAt: String?
        /// Details about the metadata options for the Amazon EC2 instance.
        public let metadataOptions: AwsEc2InstanceMetadataOptions?
        /// The identifiers of the network interfaces for the EC2 instance. The details for each network interface are in a corresponding AwsEc2NetworkInterfacesDetails object.
        public let networkInterfaces: [AwsEc2InstanceNetworkInterfacesDetails]?
        /// The identifier of the subnet that the instance was launched in.
        public let subnetId: String?
        /// The instance type of the instance.
        public let type: String?
        /// The virtualization type of the Amazon Machine Image (AMI) required to launch the instance.
        public let virtualizationType: String?
        /// The identifier of the VPC that the instance was launched in.
        public let vpcId: String?

        public init(iamInstanceProfileArn: String? = nil, imageId: String? = nil, ipV4Addresses: [String]? = nil, ipV6Addresses: [String]? = nil, keyName: String? = nil, launchedAt: String? = nil, metadataOptions: AwsEc2InstanceMetadataOptions? = nil, networkInterfaces: [AwsEc2InstanceNetworkInterfacesDetails]? = nil, subnetId: String? = nil, type: String? = nil, virtualizationType: String? = nil, vpcId: String? = nil) {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.metadataOptions = metadataOptions
            self.networkInterfaces = networkInterfaces
            self.subnetId = subnetId
            self.type = type
            self.virtualizationType = virtualizationType
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.iamInstanceProfileArn, name: "iamInstanceProfileArn", parent: name, pattern: "\\S")
            try self.validate(self.imageId, name: "imageId", parent: name, pattern: "\\S")
            try self.ipV4Addresses?.forEach {
                try validate($0, name: "ipV4Addresses[]", parent: name, pattern: "\\S")
            }
            try self.ipV6Addresses?.forEach {
                try validate($0, name: "ipV6Addresses[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "\\S")
            try self.validate(self.launchedAt, name: "launchedAt", parent: name, pattern: "\\S")
            try self.metadataOptions?.validate(name: "\(name).metadataOptions")
            try self.networkInterfaces?.forEach {
                try $0.validate(name: "\(name).networkInterfaces[]")
            }
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.virtualizationType, name: "virtualizationType", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case iamInstanceProfileArn = "IamInstanceProfileArn"
            case imageId = "ImageId"
            case ipV4Addresses = "IpV4Addresses"
            case ipV6Addresses = "IpV6Addresses"
            case keyName = "KeyName"
            case launchedAt = "LaunchedAt"
            case metadataOptions = "MetadataOptions"
            case networkInterfaces = "NetworkInterfaces"
            case subnetId = "SubnetId"
            case type = "Type"
            case virtualizationType = "VirtualizationType"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2InstanceMetadataOptions: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the HTTP metadata endpoint on the instance.
        public let httpEndpoint: String?
        /// Enables or disables the IPv6 endpoint for the instance metadata service.
        public let httpProtocolIpv6: String?
        /// The desired HTTP PUT response hop limit for instance metadata requests.  The larger the number, the further instance metadata requests can travel.
        public let httpPutResponseHopLimit: Int?
        /// The state of token usage for your instance metadata requests.
        public let httpTokens: String?
        /// Specifies whether to allow access to instance tags from the instance metadata.
        public let instanceMetadataTags: String?

        public init(httpEndpoint: String? = nil, httpProtocolIpv6: String? = nil, httpPutResponseHopLimit: Int? = nil, httpTokens: String? = nil, instanceMetadataTags: String? = nil) {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }

        public func validate(name: String) throws {
            try self.validate(self.httpEndpoint, name: "httpEndpoint", parent: name, pattern: "\\S")
            try self.validate(self.httpProtocolIpv6, name: "httpProtocolIpv6", parent: name, pattern: "\\S")
            try self.validate(self.httpTokens, name: "httpTokens", parent: name, pattern: "\\S")
            try self.validate(self.instanceMetadataTags, name: "instanceMetadataTags", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case httpEndpoint = "HttpEndpoint"
            case httpProtocolIpv6 = "HttpProtocolIpv6"
            case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
            case httpTokens = "HttpTokens"
            case instanceMetadataTags = "InstanceMetadataTags"
        }
    }

    public struct AwsEc2InstanceNetworkInterfacesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the network interface. The details are in a corresponding AwsEc2NetworkInterfacesDetails object.
        public let networkInterfaceId: String?

        public init(networkInterfaceId: String? = nil) {
            self.networkInterfaceId = networkInterfaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case networkInterfaceId = "NetworkInterfaceId"
        }
    }

    public struct AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The device name.
        public let deviceName: String?
        ///  Parameters used to automatically set up Amazon EBS volumes when the instance is  launched.
        public let ebs: AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails?
        ///  Omits the device from the block device mapping when an empty string is specified.
        public let noDevice: String?
        ///  The virtual device name (ephemeralN). Instance store volumes are numbered starting  from 0. An instance type with 2 available instance store volumes can specify mappings  for ephemeral0 and ephemeral1. The number of available instance store volumes depends  on the instance type.
        public let virtualName: String?

        public init(deviceName: String? = nil, ebs: AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails? = nil, noDevice: String? = nil, virtualName: String? = nil) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "\\S")
            try self.ebs?.validate(name: "\(name).ebs")
            try self.validate(self.noDevice, name: "noDevice", parent: name, pattern: "\\S")
            try self.validate(self.virtualName, name: "virtualName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "DeviceName"
            case ebs = "Ebs"
            case noDevice = "NoDevice"
            case virtualName = "VirtualName"
        }
    }

    public struct AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether the EBS volume is deleted on instance termination.
        public let deleteOnTermination: Bool?
        ///  Indicates whether the EBS volume is encrypted. Encrypted volumes can only be  attached to instances that support Amazon EBS encryption. If you're creating a  volume from a snapshot, you can't specify an encryption value.
        public let encrypted: Bool?
        ///  The number of I/O operations per second (IOPS).
        public let iops: Int?
        ///  The Amazon Resource Name (ARN) of the symmetric Key Management Service (KMS) customer managed key  used for encryption.
        public let kmsKeyId: String?
        ///  The ID of the EBS snapshot.
        public let snapshotId: String?
        ///  The throughput to provision for a gp3 volume, with a maximum of 1,000 MiB/s.
        public let throughput: Int?
        ///  The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.
        public let volumeSize: Int?
        ///  The volume type.
        public let volumeType: String?

        public init(deleteOnTermination: Bool? = nil, encrypted: Bool? = nil, iops: Int? = nil, kmsKeyId: String? = nil, snapshotId: String? = nil, throughput: Int? = nil, volumeSize: Int? = nil, volumeType: String? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "\\S")
            try self.validate(self.volumeType, name: "volumeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteOnTermination = "DeleteOnTermination"
            case encrypted = "Encrypted"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case snapshotId = "SnapshotId"
            case throughput = "Throughput"
            case volumeSize = "VolumeSize"
            case volumeType = "VolumeType"
        }
    }

    public struct AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The ID of the Capacity Reservation in which to run the instance.
        public let capacityReservationId: String?
        ///  The Amazon Resource Name (ARN) of the Capacity Reservation resource group in which to run the instance.
        public let capacityReservationResourceGroupArn: String?

        public init(capacityReservationId: String? = nil, capacityReservationResourceGroupArn: String? = nil) {
            self.capacityReservationId = capacityReservationId
            self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityReservationId, name: "capacityReservationId", parent: name, pattern: "\\S")
            try self.validate(self.capacityReservationResourceGroupArn, name: "capacityReservationResourceGroupArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityReservationId = "CapacityReservationId"
            case capacityReservationResourceGroupArn = "CapacityReservationResourceGroupArn"
        }
    }

    public struct AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates the instance's Capacity Reservation preferences. If equal to open, the instance can run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). If equal to none, the instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        public let capacityReservationPreference: String?
        ///  Specifies a target Capacity Reservation.
        public let capacityReservationTarget: AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails?

        public init(capacityReservationPreference: String? = nil, capacityReservationTarget: AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails? = nil) {
            self.capacityReservationPreference = capacityReservationPreference
            self.capacityReservationTarget = capacityReservationTarget
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityReservationPreference, name: "capacityReservationPreference", parent: name, pattern: "\\S")
            try self.capacityReservationTarget?.validate(name: "\(name).capacityReservationTarget")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityReservationPreference = "CapacityReservationPreference"
            case capacityReservationTarget = "CapacityReservationTarget"
        }
    }

    public struct AwsEc2LaunchTemplateDataCpuOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The number of CPU cores for the instance.
        public let coreCount: Int?
        ///  The number of threads per CPU core. A value of 1 disables multithreading for the instance,  The default value is 2.
        public let threadsPerCore: Int?

        public init(coreCount: Int? = nil, threadsPerCore: Int? = nil) {
            self.coreCount = coreCount
            self.threadsPerCore = threadsPerCore
        }

        private enum CodingKeys: String, CodingKey {
            case coreCount = "CoreCount"
            case threadsPerCore = "ThreadsPerCore"
        }
    }

    public struct AwsEc2LaunchTemplateDataCreditSpecificationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The credit option for CPU usage of a T instance.
        public let cpuCredits: String?

        public init(cpuCredits: String? = nil) {
            self.cpuCredits = cpuCredits
        }

        public func validate(name: String) throws {
            try self.validate(self.cpuCredits, name: "cpuCredits", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cpuCredits = "CpuCredits"
        }
    }

    public struct AwsEc2LaunchTemplateDataDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Information about a block device mapping for an Amazon EC2 launch template.
        public let blockDeviceMappingSet: [AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails]?
        ///  Specifies an instance's Capacity Reservation targeting option. You can specify only  one option at a time.
        public let capacityReservationSpecification: AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails?
        ///  Specifies the CPU options for an instance. For more information, see  Optimize CPU options in the Amazon Elastic Compute Cloud User Guide.
        public let cpuOptions: AwsEc2LaunchTemplateDataCpuOptionsDetails?
        ///  Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
        public let creditSpecification: AwsEc2LaunchTemplateDataCreditSpecificationDetails?
        ///  Indicates whether to enable the instance for stop protection. For more information,  see Enable stop protection in the Amazon EC2 User Guide.
        public let disableApiStop: Bool?
        ///  If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API. If set to true, you can.
        public let disableApiTermination: Bool?
        ///  Indicates whether the instance is optimized for Amazon EBS I/O.
        public let ebsOptimized: Bool?
        ///  Provides details about Elastic Graphics accelerators to associate with the instance.
        public let elasticGpuSpecificationSet: [AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails]?
        ///  The Amazon Elastic Inference accelerator for the instance.
        public let elasticInferenceAcceleratorSet: [AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails]?
        ///  Indicates whether the Amazon EC2 instance is enabled for Amazon Web Services Nitro Enclaves.
        public let enclaveOptions: AwsEc2LaunchTemplateDataEnclaveOptionsDetails?
        ///  Specifies whether your Amazon EC2 instance is configured for hibernation.
        public let hibernationOptions: AwsEc2LaunchTemplateDataHibernationOptionsDetails?
        ///  The name or Amazon Resource Name (ARN) of an IAM instance profile.
        public let iamInstanceProfile: AwsEc2LaunchTemplateDataIamInstanceProfileDetails?
        ///  The ID of the Amazon Machine Image (AMI).
        public let imageId: String?
        ///  Provides the options for specifying the instance initiated shutdown behavior.
        public let instanceInitiatedShutdownBehavior: String?
        ///  Specifies the market (purchasing) option for an instance.
        public let instanceMarketOptions: AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails?
        ///  The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance  types with these attributes. If you specify InstanceRequirements, you can't specify InstanceType.
        public let instanceRequirements: AwsEc2LaunchTemplateDataInstanceRequirementsDetails?
        ///  The instance type. For more information, see Instance types in the Amazon EC2 User Guide. If you specify InstanceType, you can't  specify InstanceRequirements.
        public let instanceType: String?
        ///  The ID of the kernel.
        public let kernelId: String?
        ///  The name of the key pair that allows users to connect to the instance.
        public let keyName: String?
        ///  Specifies a license configuration for an instance.
        public let licenseSet: [AwsEc2LaunchTemplateDataLicenseSetDetails]?
        ///  The maintenance options of your instance.
        public let maintenanceOptions: AwsEc2LaunchTemplateDataMaintenanceOptionsDetails?
        ///  The metadata options for the instance. For more information, see Instance metadata and user data in the Amazon EC2 User Guide.
        public let metadataOptions: AwsEc2LaunchTemplateDataMetadataOptionsDetails?
        ///  The monitoring for the instance.
        public let monitoring: AwsEc2LaunchTemplateDataMonitoringDetails?
        ///  Specifies the parameters for a network interface that is attached to the instance.
        public let networkInterfaceSet: [AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails]?
        ///  Specifies the placement of an instance.
        public let placement: AwsEc2LaunchTemplateDataPlacementDetails?
        ///  The options for the instance hostname.
        public let privateDnsNameOptions: AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails?
        ///  The ID of the RAM disk.
        public let ramDiskId: String?
        ///  One or more security group IDs.
        public let securityGroupIdSet: [String]?
        ///  One or more security group names. For a nondefault VPC, you must use security group IDs instead. You cannot specify both a security group ID and security name in the same request.
        public let securityGroupSet: [String]?
        ///  The user data to make available to the instance.
        public let userData: String?

        public init(blockDeviceMappingSet: [AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails]? = nil, capacityReservationSpecification: AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails? = nil, cpuOptions: AwsEc2LaunchTemplateDataCpuOptionsDetails? = nil, creditSpecification: AwsEc2LaunchTemplateDataCreditSpecificationDetails? = nil, disableApiStop: Bool? = nil, disableApiTermination: Bool? = nil, ebsOptimized: Bool? = nil, elasticGpuSpecificationSet: [AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails]? = nil, elasticInferenceAcceleratorSet: [AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails]? = nil, enclaveOptions: AwsEc2LaunchTemplateDataEnclaveOptionsDetails? = nil, hibernationOptions: AwsEc2LaunchTemplateDataHibernationOptionsDetails? = nil, iamInstanceProfile: AwsEc2LaunchTemplateDataIamInstanceProfileDetails? = nil, imageId: String? = nil, instanceInitiatedShutdownBehavior: String? = nil, instanceMarketOptions: AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails? = nil, instanceRequirements: AwsEc2LaunchTemplateDataInstanceRequirementsDetails? = nil, instanceType: String? = nil, kernelId: String? = nil, keyName: String? = nil, licenseSet: [AwsEc2LaunchTemplateDataLicenseSetDetails]? = nil, maintenanceOptions: AwsEc2LaunchTemplateDataMaintenanceOptionsDetails? = nil, metadataOptions: AwsEc2LaunchTemplateDataMetadataOptionsDetails? = nil, monitoring: AwsEc2LaunchTemplateDataMonitoringDetails? = nil, networkInterfaceSet: [AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails]? = nil, placement: AwsEc2LaunchTemplateDataPlacementDetails? = nil, privateDnsNameOptions: AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails? = nil, ramDiskId: String? = nil, securityGroupIdSet: [String]? = nil, securityGroupSet: [String]? = nil, userData: String? = nil) {
            self.blockDeviceMappingSet = blockDeviceMappingSet
            self.capacityReservationSpecification = capacityReservationSpecification
            self.cpuOptions = cpuOptions
            self.creditSpecification = creditSpecification
            self.disableApiStop = disableApiStop
            self.disableApiTermination = disableApiTermination
            self.ebsOptimized = ebsOptimized
            self.elasticGpuSpecificationSet = elasticGpuSpecificationSet
            self.elasticInferenceAcceleratorSet = elasticInferenceAcceleratorSet
            self.enclaveOptions = enclaveOptions
            self.hibernationOptions = hibernationOptions
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.instanceMarketOptions = instanceMarketOptions
            self.instanceRequirements = instanceRequirements
            self.instanceType = instanceType
            self.kernelId = kernelId
            self.keyName = keyName
            self.licenseSet = licenseSet
            self.maintenanceOptions = maintenanceOptions
            self.metadataOptions = metadataOptions
            self.monitoring = monitoring
            self.networkInterfaceSet = networkInterfaceSet
            self.placement = placement
            self.privateDnsNameOptions = privateDnsNameOptions
            self.ramDiskId = ramDiskId
            self.securityGroupIdSet = securityGroupIdSet
            self.securityGroupSet = securityGroupSet
            self.userData = userData
        }

        public func validate(name: String) throws {
            try self.blockDeviceMappingSet?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappingSet[]")
            }
            try self.capacityReservationSpecification?.validate(name: "\(name).capacityReservationSpecification")
            try self.creditSpecification?.validate(name: "\(name).creditSpecification")
            try self.elasticGpuSpecificationSet?.forEach {
                try $0.validate(name: "\(name).elasticGpuSpecificationSet[]")
            }
            try self.elasticInferenceAcceleratorSet?.forEach {
                try $0.validate(name: "\(name).elasticInferenceAcceleratorSet[]")
            }
            try self.iamInstanceProfile?.validate(name: "\(name).iamInstanceProfile")
            try self.validate(self.imageId, name: "imageId", parent: name, pattern: "\\S")
            try self.validate(self.instanceInitiatedShutdownBehavior, name: "instanceInitiatedShutdownBehavior", parent: name, pattern: "\\S")
            try self.instanceMarketOptions?.validate(name: "\(name).instanceMarketOptions")
            try self.instanceRequirements?.validate(name: "\(name).instanceRequirements")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
            try self.validate(self.kernelId, name: "kernelId", parent: name, pattern: "\\S")
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "\\S")
            try self.licenseSet?.forEach {
                try $0.validate(name: "\(name).licenseSet[]")
            }
            try self.maintenanceOptions?.validate(name: "\(name).maintenanceOptions")
            try self.metadataOptions?.validate(name: "\(name).metadataOptions")
            try self.networkInterfaceSet?.forEach {
                try $0.validate(name: "\(name).networkInterfaceSet[]")
            }
            try self.placement?.validate(name: "\(name).placement")
            try self.privateDnsNameOptions?.validate(name: "\(name).privateDnsNameOptions")
            try self.validate(self.ramDiskId, name: "ramDiskId", parent: name, pattern: "\\S")
            try self.securityGroupIdSet?.forEach {
                try validate($0, name: "securityGroupIdSet[]", parent: name, pattern: "\\S")
            }
            try self.securityGroupSet?.forEach {
                try validate($0, name: "securityGroupSet[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.userData, name: "userData", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case blockDeviceMappingSet = "BlockDeviceMappingSet"
            case capacityReservationSpecification = "CapacityReservationSpecification"
            case cpuOptions = "CpuOptions"
            case creditSpecification = "CreditSpecification"
            case disableApiStop = "DisableApiStop"
            case disableApiTermination = "DisableApiTermination"
            case ebsOptimized = "EbsOptimized"
            case elasticGpuSpecificationSet = "ElasticGpuSpecificationSet"
            case elasticInferenceAcceleratorSet = "ElasticInferenceAcceleratorSet"
            case enclaveOptions = "EnclaveOptions"
            case hibernationOptions = "HibernationOptions"
            case iamInstanceProfile = "IamInstanceProfile"
            case imageId = "ImageId"
            case instanceInitiatedShutdownBehavior = "InstanceInitiatedShutdownBehavior"
            case instanceMarketOptions = "InstanceMarketOptions"
            case instanceRequirements = "InstanceRequirements"
            case instanceType = "InstanceType"
            case kernelId = "KernelId"
            case keyName = "KeyName"
            case licenseSet = "LicenseSet"
            case maintenanceOptions = "MaintenanceOptions"
            case metadataOptions = "MetadataOptions"
            case monitoring = "Monitoring"
            case networkInterfaceSet = "NetworkInterfaceSet"
            case placement = "Placement"
            case privateDnsNameOptions = "PrivateDnsNameOptions"
            case ramDiskId = "RamDiskId"
            case securityGroupIdSet = "SecurityGroupIdSet"
            case securityGroupSet = "SecurityGroupSet"
            case userData = "UserData"
        }
    }

    public struct AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The type of Elastic Graphics accelerator.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The number of Elastic Inference accelerators to attach to the instance.
        public let count: Int?
        ///  The type of Elastic Inference accelerator.
        public let type: String?

        public init(count: Int? = nil, type: String? = nil) {
            self.count = count
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case type = "Type"
        }
    }

    public struct AwsEc2LaunchTemplateDataEnclaveOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  If this parameter is set to true, the instance is enabled for Amazon Web Services Nitro Enclaves.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsEc2LaunchTemplateDataHibernationOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  If you set this parameter to true, the instance is enabled for hibernation.
        public let configured: Bool?

        public init(configured: Bool? = nil) {
            self.configured = configured
        }

        private enum CodingKeys: String, CodingKey {
            case configured = "Configured"
        }
    }

    public struct AwsEc2LaunchTemplateDataIamInstanceProfileDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the instance profile.
        public let arn: String?
        ///  The name of the instance profile.
        public let name: String?

        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The market type.
        public let marketType: String?
        ///  The options for Spot Instances.
        public let spotOptions: AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails?

        public init(marketType: String? = nil, spotOptions: AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails? = nil) {
            self.marketType = marketType
            self.spotOptions = spotOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.marketType, name: "marketType", parent: name, pattern: "\\S")
            try self.spotOptions?.validate(name: "\(name).spotOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case marketType = "MarketType"
            case spotOptions = "SpotOptions"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Deprecated.
        public let blockDurationMinutes: Int?
        ///  The behavior when a Spot Instance is interrupted.
        public let instanceInterruptionBehavior: String?
        ///  The maximum hourly price you're willing to pay for the Spot Instances.
        public let maxPrice: String?
        ///  The Spot Instance request type.
        public let spotInstanceType: String?
        ///  The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ), for persistent requests.
        public let validUntil: String?

        public init(blockDurationMinutes: Int? = nil, instanceInterruptionBehavior: String? = nil, maxPrice: String? = nil, spotInstanceType: String? = nil, validUntil: String? = nil) {
            self.blockDurationMinutes = blockDurationMinutes
            self.instanceInterruptionBehavior = instanceInterruptionBehavior
            self.maxPrice = maxPrice
            self.spotInstanceType = spotInstanceType
            self.validUntil = validUntil
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceInterruptionBehavior, name: "instanceInterruptionBehavior", parent: name, pattern: "\\S")
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, pattern: "\\S")
            try self.validate(self.spotInstanceType, name: "spotInstanceType", parent: name, pattern: "\\S")
            try self.validate(self.validUntil, name: "validUntil", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case blockDurationMinutes = "BlockDurationMinutes"
            case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
            case maxPrice = "MaxPrice"
            case spotInstanceType = "SpotInstanceType"
            case validUntil = "ValidUntil"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum number of accelerators. If this parameter isn't specified, there's no maximum limit. To exclude accelerator-enabled instance types, set Max to 0.
        public let max: Int?
        ///  The minimum number of accelerators. If this parameter isn't specified, there's no minimum limit.
        public let min: Int?

        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum amount of memory, in MiB. If this parameter isn't specified, there's no maximum limit.
        public let max: Int?
        ///  The minimum amount of memory, in MiB. If 0 is specified, there's no maximum limit.
        public let min: Int?

        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum baseline bandwidth, in Mbps. If this parameter is omitted, there's no maximum limit.
        public let max: Int?
        ///  The minimum baseline bandwidth, in Mbps. If this parameter is omitted, there's no minimum limit.
        public let min: Int?

        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web Services Inferentia chips) on an instance.
        public let acceleratorCount: AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails?
        /// Indicates whether instance types must have accelerators by specific manufacturers.
        public let acceleratorManufacturers: [String]?
        ///  The accelerators that must be on the instance type.
        public let acceleratorNames: [String]?
        ///  The minimum and maximum amount of total accelerator memory, in MiB.
        public let acceleratorTotalMemoryMiB: AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails?
        /// The accelerator types that must be on the instance type.
        public let acceleratorTypes: [String]?
        /// Indicates whether bare metal instance types must be included, excluded, or required.
        public let bareMetal: String?
        ///  The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see Amazon EBS optimized instances in the Amazon EC2 User Guide.
        public let baselineEbsBandwidthMbps: AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails?
        ///  Indicates whether burstable performance T instance types are included, excluded, or required. For more information, Burstable performance instances in the Amazon EC2 User Guide.
        public let burstablePerformance: String?
        ///  The CPU manufacturers to include.
        public let cpuManufacturers: [String]?
        ///  The instance types to exclude.
        public let excludedInstanceTypes: [String]?
        ///  Indicates whether current or previous generation instance types are included.
        public let instanceGenerations: [String]?
        ///  Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, see Amazon EC2 instance store in the Amazon EC2 User Guide.
        public let localStorage: String?
        ///  The type of local storage that is required.
        public let localStorageTypes: [String]?
        ///  The minimum and maximum amount of memory per vCPU, in GiB.
        public let memoryGiBPerVCpu: AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails?
        ///  The minimum and maximum amount of memory, in MiB.
        public let memoryMiB: AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails?
        ///  The minimum and maximum number of network interfaces.
        public let networkInterfaceCount: AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails?
        ///  The price protection threshold for On-Demand Instances. This is the maximum youll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. A high value, such as 999999, turns off price protection.
        public let onDemandMaxPricePercentageOverLowestPrice: Int?
        ///  Indicates whether instance types must support hibernation for On-Demand Instances.
        public let requireHibernateSupport: Bool?
        ///  The price protection threshold for Spot Instances. This is the maximum youll pay for a Spot Instance, expressed as a  percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When  Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.  The parameter accepts an integer, which Amazon EC2 interprets as a percentage. A high value, such as 999999, turns off price protection.
        public let spotMaxPricePercentageOverLowestPrice: Int?
        ///  The minimum and maximum amount of total local storage, in GB.
        public let totalLocalStorageGB: AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails?
        ///  The minimum and maximum number of vCPUs.
        public let vCpuCount: AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails?

        public init(acceleratorCount: AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails? = nil, acceleratorManufacturers: [String]? = nil, acceleratorNames: [String]? = nil, acceleratorTotalMemoryMiB: AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails? = nil, acceleratorTypes: [String]? = nil, bareMetal: String? = nil, baselineEbsBandwidthMbps: AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails? = nil, burstablePerformance: String? = nil, cpuManufacturers: [String]? = nil, excludedInstanceTypes: [String]? = nil, instanceGenerations: [String]? = nil, localStorage: String? = nil, localStorageTypes: [String]? = nil, memoryGiBPerVCpu: AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails? = nil, memoryMiB: AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails? = nil, networkInterfaceCount: AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails? = nil, onDemandMaxPricePercentageOverLowestPrice: Int? = nil, requireHibernateSupport: Bool? = nil, spotMaxPricePercentageOverLowestPrice: Int? = nil, totalLocalStorageGB: AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails? = nil, vCpuCount: AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails? = nil) {
            self.acceleratorCount = acceleratorCount
            self.acceleratorManufacturers = acceleratorManufacturers
            self.acceleratorNames = acceleratorNames
            self.acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB
            self.acceleratorTypes = acceleratorTypes
            self.bareMetal = bareMetal
            self.baselineEbsBandwidthMbps = baselineEbsBandwidthMbps
            self.burstablePerformance = burstablePerformance
            self.cpuManufacturers = cpuManufacturers
            self.excludedInstanceTypes = excludedInstanceTypes
            self.instanceGenerations = instanceGenerations
            self.localStorage = localStorage
            self.localStorageTypes = localStorageTypes
            self.memoryGiBPerVCpu = memoryGiBPerVCpu
            self.memoryMiB = memoryMiB
            self.networkInterfaceCount = networkInterfaceCount
            self.onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPrice
            self.requireHibernateSupport = requireHibernateSupport
            self.spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPrice
            self.totalLocalStorageGB = totalLocalStorageGB
            self.vCpuCount = vCpuCount
        }

        public func validate(name: String) throws {
            try self.acceleratorManufacturers?.forEach {
                try validate($0, name: "acceleratorManufacturers[]", parent: name, pattern: "\\S")
            }
            try self.acceleratorNames?.forEach {
                try validate($0, name: "acceleratorNames[]", parent: name, pattern: "\\S")
            }
            try self.acceleratorTypes?.forEach {
                try validate($0, name: "acceleratorTypes[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.bareMetal, name: "bareMetal", parent: name, pattern: "\\S")
            try self.validate(self.burstablePerformance, name: "burstablePerformance", parent: name, pattern: "\\S")
            try self.cpuManufacturers?.forEach {
                try validate($0, name: "cpuManufacturers[]", parent: name, pattern: "\\S")
            }
            try self.excludedInstanceTypes?.forEach {
                try validate($0, name: "excludedInstanceTypes[]", parent: name, pattern: "\\S")
            }
            try self.instanceGenerations?.forEach {
                try validate($0, name: "instanceGenerations[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.localStorage, name: "localStorage", parent: name, pattern: "\\S")
            try self.localStorageTypes?.forEach {
                try validate($0, name: "localStorageTypes[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorCount = "AcceleratorCount"
            case acceleratorManufacturers = "AcceleratorManufacturers"
            case acceleratorNames = "AcceleratorNames"
            case acceleratorTotalMemoryMiB = "AcceleratorTotalMemoryMiB"
            case acceleratorTypes = "AcceleratorTypes"
            case bareMetal = "BareMetal"
            case baselineEbsBandwidthMbps = "BaselineEbsBandwidthMbps"
            case burstablePerformance = "BurstablePerformance"
            case cpuManufacturers = "CpuManufacturers"
            case excludedInstanceTypes = "ExcludedInstanceTypes"
            case instanceGenerations = "InstanceGenerations"
            case localStorage = "LocalStorage"
            case localStorageTypes = "LocalStorageTypes"
            case memoryGiBPerVCpu = "MemoryGiBPerVCpu"
            case memoryMiB = "MemoryMiB"
            case networkInterfaceCount = "NetworkInterfaceCount"
            case onDemandMaxPricePercentageOverLowestPrice = "OnDemandMaxPricePercentageOverLowestPrice"
            case requireHibernateSupport = "RequireHibernateSupport"
            case spotMaxPricePercentageOverLowestPrice = "SpotMaxPricePercentageOverLowestPrice"
            case totalLocalStorageGB = "TotalLocalStorageGB"
            case vCpuCount = "VCpuCount"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum amount of memory per vCPU, in GiB. If this parameter is omitted, there's no maximum limit.
        public let max: Double?
        ///  The minimum amount of memory per vCPU, in GiB. If this parameter is omitted, there's no maximum limit.
        public let min: Double?

        public init(max: Double? = nil, min: Double? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum amount of memory, in MiB.
        public let max: Int?
        ///  The minimum amount of memory, in MiB.
        public let min: Int?

        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum number of network interfaces.
        public let max: Int?
        ///  The minimum number of network interfaces.
        public let min: Int?

        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum amount of total local storage, in GB.
        public let max: Double?
        ///  The minimum amount of total local storage, in GB.
        public let min: Double?

        public init(max: Double? = nil, min: Double? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum number of vCPUs.
        public let max: Int?
        ///  The minimum number of vCPUs.
        public let min: Int?

        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataLicenseSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the license configuration.
        public let licenseConfigurationArn: String?

        public init(licenseConfigurationArn: String? = nil) {
            self.licenseConfigurationArn = licenseConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.licenseConfigurationArn, name: "licenseConfigurationArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurationArn = "LicenseConfigurationArn"
        }
    }

    public struct AwsEc2LaunchTemplateDataMaintenanceOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Disables the automatic recovery behavior of your instance or sets it to default.
        public let autoRecovery: String?

        public init(autoRecovery: String? = nil) {
            self.autoRecovery = autoRecovery
        }

        public func validate(name: String) throws {
            try self.validate(self.autoRecovery, name: "autoRecovery", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case autoRecovery = "AutoRecovery"
        }
    }

    public struct AwsEc2LaunchTemplateDataMetadataOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is enabled, and you wont be able to access your instance metadata.
        public let httpEndpoint: String?
        ///  Enables or disables the IPv6 endpoint for the instance metadata service.
        public let httpProtocolIpv6: String?
        ///  The desired HTTP PUT response hop limit for instance metadata requests. The larger  the number, the further instance metadata requests can travel.
        public let httpPutResponseHopLimit: Int?
        ///  The state of token usage for your instance metadata requests.
        public let httpTokens: String?
        ///  When set to enabled, this parameter allows access to instance tags from the instance metadata. When set to disabled, it turns off access to instance tags from the instance metadata. For more information, see
        /// Work with instance tags in instance metadata in the Amazon EC2 User Guide.
        public let instanceMetadataTags: String?

        public init(httpEndpoint: String? = nil, httpProtocolIpv6: String? = nil, httpPutResponseHopLimit: Int? = nil, httpTokens: String? = nil, instanceMetadataTags: String? = nil) {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }

        public func validate(name: String) throws {
            try self.validate(self.httpEndpoint, name: "httpEndpoint", parent: name, pattern: "\\S")
            try self.validate(self.httpProtocolIpv6, name: "httpProtocolIpv6", parent: name, pattern: "\\S")
            try self.validate(self.httpTokens, name: "httpTokens", parent: name, pattern: "\\S")
            try self.validate(self.instanceMetadataTags, name: "instanceMetadataTags", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case httpEndpoint = "HttpEndpoint"
            case httpProtocolIpv6 = "HttpProtocolIpv6"
            case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
            case httpTokens = "HttpTokens"
            case instanceMetadataTags = "InstanceMetadataTags"
        }
    }

    public struct AwsEc2LaunchTemplateDataMonitoringDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Enables detailed monitoring when true is specified. Otherwise, basic monitoring is enabled.  For more information about detailed monitoring, see  Enable or turn off detailed monitoring for your instances in the Amazon EC2 User Guide.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether to associate a Carrier IP address with eth0 for a new network interface.  You use this option when you launch an instance in a Wavelength Zone and want to  associate a Carrier IP address with the network interface. For more information, see  Carrier IP address in the Wavelength Developer Guide.
        public let associateCarrierIpAddress: Bool?
        ///  Associates a public IPv4 address with eth0 for a new network interface.
        public let associatePublicIpAddress: Bool?
        ///  Indicates whether the network interface is deleted when the instance is terminated.
        public let deleteOnTermination: Bool?
        ///  A description for the network interface.
        public let description: String?
        ///  The device index for the network interface attachment.
        public let deviceIndex: Int?
        ///  The IDs of one or more security groups.
        public let groups: [String]?
        ///  The type of network interface.
        public let interfaceType: String?
        ///  The number of IPv4 prefixes to be automatically assigned to the network interface.  You cannot use this option if you use the Ipv4Prefixes option.
        public let ipv4PrefixCount: Int?
        ///  One or more IPv4 prefixes to be assigned to the network interface. You cannot use  this option if you use the Ipv4PrefixCount option.
        public let ipv4Prefixes: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails]?
        ///  The number of IPv6 addresses to assign to a network interface. Amazon EC2  automatically selects the IPv6 addresses from the subnet range. You can't use this  option if you use Ipv6Addresses.
        public let ipv6AddressCount: Int?
        ///  One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.  You can't use this option if you use Ipv6AddressCount.
        public let ipv6Addresses: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails]?
        ///  The number of IPv6 prefixes to be automatically assigned to the network interface.  You cannot use this option if you use the Ipv6Prefix option.
        public let ipv6PrefixCount: Int?
        ///  One or more IPv6 prefixes to be assigned to the network interface. You cannot use  this option if you use the Ipv6PrefixCount option.
        public let ipv6Prefixes: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails]?
        ///  The index of the network card. Some instance types support multiple network cards.  The primary network interface must be assigned to network card index 0. The default  is network card index 0.
        public let networkCardIndex: Int?
        ///  The ID of the network interface.
        public let networkInterfaceId: String?
        ///  The primary private IPv4 address of the network interface.
        public let privateIpAddress: String?
        ///  One or more private IPv4 addresses.
        public let privateIpAddresses: [AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails]?
        ///  The number of secondary private IPv4 addresses to assign to a network interface.
        public let secondaryPrivateIpAddressCount: Int?
        ///  The ID of the subnet for the network interface.
        public let subnetId: String?

        public init(associateCarrierIpAddress: Bool? = nil, associatePublicIpAddress: Bool? = nil, deleteOnTermination: Bool? = nil, description: String? = nil, deviceIndex: Int? = nil, groups: [String]? = nil, interfaceType: String? = nil, ipv4PrefixCount: Int? = nil, ipv4Prefixes: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails]? = nil, ipv6AddressCount: Int? = nil, ipv6Addresses: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails]? = nil, ipv6PrefixCount: Int? = nil, ipv6Prefixes: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails]? = nil, networkCardIndex: Int? = nil, networkInterfaceId: String? = nil, privateIpAddress: String? = nil, privateIpAddresses: [AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails]? = nil, secondaryPrivateIpAddressCount: Int? = nil, subnetId: String? = nil) {
            self.associateCarrierIpAddress = associateCarrierIpAddress
            self.associatePublicIpAddress = associatePublicIpAddress
            self.deleteOnTermination = deleteOnTermination
            self.description = description
            self.deviceIndex = deviceIndex
            self.groups = groups
            self.interfaceType = interfaceType
            self.ipv4PrefixCount = ipv4PrefixCount
            self.ipv4Prefixes = ipv4Prefixes
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.ipv6PrefixCount = ipv6PrefixCount
            self.ipv6Prefixes = ipv6Prefixes
            self.networkCardIndex = networkCardIndex
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.groups?.forEach {
                try validate($0, name: "groups[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.interfaceType, name: "interfaceType", parent: name, pattern: "\\S")
            try self.ipv4Prefixes?.forEach {
                try $0.validate(name: "\(name).ipv4Prefixes[]")
            }
            try self.ipv6Addresses?.forEach {
                try $0.validate(name: "\(name).ipv6Addresses[]")
            }
            try self.ipv6Prefixes?.forEach {
                try $0.validate(name: "\(name).ipv6Prefixes[]")
            }
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "\\S")
            try self.privateIpAddresses?.forEach {
                try $0.validate(name: "\(name).privateIpAddresses[]")
            }
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associateCarrierIpAddress = "AssociateCarrierIpAddress"
            case associatePublicIpAddress = "AssociatePublicIpAddress"
            case deleteOnTermination = "DeleteOnTermination"
            case description = "Description"
            case deviceIndex = "DeviceIndex"
            case groups = "Groups"
            case interfaceType = "InterfaceType"
            case ipv4PrefixCount = "Ipv4PrefixCount"
            case ipv4Prefixes = "Ipv4Prefixes"
            case ipv6AddressCount = "Ipv6AddressCount"
            case ipv6Addresses = "Ipv6Addresses"
            case ipv6PrefixCount = "Ipv6PrefixCount"
            case ipv6Prefixes = "Ipv6Prefixes"
            case networkCardIndex = "NetworkCardIndex"
            case networkInterfaceId = "NetworkInterfaceId"
            case privateIpAddress = "PrivateIpAddress"
            case privateIpAddresses = "PrivateIpAddresses"
            case secondaryPrivateIpAddressCount = "SecondaryPrivateIpAddressCount"
            case subnetId = "SubnetId"
        }
    }

    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The IPv4 prefix. For more information, see Assigning prefixes to Amazon EC2 network interfaces in the Amazon Elastic Compute Cloud User Guide.
        public let ipv4Prefix: String?

        public init(ipv4Prefix: String? = nil) {
            self.ipv4Prefix = ipv4Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv4Prefix, name: "ipv4Prefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipv4Prefix = "Ipv4Prefix"
        }
    }

    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
        public let ipv6Address: String?

        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv6Address, name: "ipv6Address", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6Address = "Ipv6Address"
        }
    }

    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The IPv6 prefix.
        public let ipv6Prefix: String?

        public init(ipv6Prefix: String? = nil) {
            self.ipv6Prefix = ipv6Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv6Prefix, name: "ipv6Prefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6Prefix = "Ipv6Prefix"
        }
    }

    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        public let primary: Bool?
        ///  The private IPv4 address.
        public let privateIpAddress: String?

        public init(primary: Bool? = nil, privateIpAddress: String? = nil) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case primary = "Primary"
            case privateIpAddress = "PrivateIpAddress"
        }
    }

    public struct AwsEc2LaunchTemplateDataPlacementDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The affinity setting for an instance on an EC2 Dedicated Host.
        public let affinity: String?
        ///  The Availability Zone for the instance.
        public let availabilityZone: String?
        ///  The name of the placement group for the instance.
        public let groupName: String?
        ///  The ID of the Dedicated Host for the instance.
        public let hostId: String?
        ///  The Amazon Resource Name (ARN) of the host resource group in which to launch the instances.
        public let hostResourceGroupArn: String?
        ///  The number of the partition the instance should launch in.
        public let partitionNumber: Int?
        ///  Reserved for future use.
        public let spreadDomain: String?
        ///  The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.
        public let tenancy: String?

        public init(affinity: String? = nil, availabilityZone: String? = nil, groupName: String? = nil, hostId: String? = nil, hostResourceGroupArn: String? = nil, partitionNumber: Int? = nil, spreadDomain: String? = nil, tenancy: String? = nil) {
            self.affinity = affinity
            self.availabilityZone = availabilityZone
            self.groupName = groupName
            self.hostId = hostId
            self.hostResourceGroupArn = hostResourceGroupArn
            self.partitionNumber = partitionNumber
            self.spreadDomain = spreadDomain
            self.tenancy = tenancy
        }

        public func validate(name: String) throws {
            try self.validate(self.affinity, name: "affinity", parent: name, pattern: "\\S")
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.validate(self.hostId, name: "hostId", parent: name, pattern: "\\S")
            try self.validate(self.hostResourceGroupArn, name: "hostResourceGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.spreadDomain, name: "spreadDomain", parent: name, pattern: "\\S")
            try self.validate(self.tenancy, name: "tenancy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case affinity = "Affinity"
            case availabilityZone = "AvailabilityZone"
            case groupName = "GroupName"
            case hostId = "HostId"
            case hostResourceGroupArn = "HostResourceGroupArn"
            case partitionNumber = "PartitionNumber"
            case spreadDomain = "SpreadDomain"
            case tenancy = "Tenancy"
        }
    }

    public struct AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        public let enableResourceNameDnsAAAARecord: Bool?
        ///  Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        public let enableResourceNameDnsARecord: Bool?
        ///  The type of hostname for EC2 instances.
        public let hostnameType: String?

        public init(enableResourceNameDnsAAAARecord: Bool? = nil, enableResourceNameDnsARecord: Bool? = nil, hostnameType: String? = nil) {
            self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
            self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
            self.hostnameType = hostnameType
        }

        public func validate(name: String) throws {
            try self.validate(self.hostnameType, name: "hostnameType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case enableResourceNameDnsAAAARecord = "EnableResourceNameDnsAAAARecord"
            case enableResourceNameDnsARecord = "EnableResourceNameDnsARecord"
            case hostnameType = "HostnameType"
        }
    }

    public struct AwsEc2LaunchTemplateDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The default version of the launch template.
        public let defaultVersionNumber: Int64?
        ///  An ID for the launch template.
        public let id: String?
        ///  The latest version of the launch template.
        public let latestVersionNumber: Int64?
        ///  The information to include in the launch template.
        public let launchTemplateData: AwsEc2LaunchTemplateDataDetails?
        ///  A name for the launch template.
        public let launchTemplateName: String?

        public init(defaultVersionNumber: Int64? = nil, id: String? = nil, latestVersionNumber: Int64? = nil, launchTemplateData: AwsEc2LaunchTemplateDataDetails? = nil, launchTemplateName: String? = nil) {
            self.defaultVersionNumber = defaultVersionNumber
            self.id = id
            self.latestVersionNumber = latestVersionNumber
            self.launchTemplateData = launchTemplateData
            self.launchTemplateName = launchTemplateName
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.launchTemplateData?.validate(name: "\(name).launchTemplateData")
            try self.validate(self.launchTemplateName, name: "launchTemplateName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultVersionNumber = "DefaultVersionNumber"
            case id = "Id"
            case latestVersionNumber = "LatestVersionNumber"
            case launchTemplateData = "LaunchTemplateData"
            case launchTemplateName = "LaunchTemplateName"
        }
    }

    public struct AwsEc2NetworkAclAssociation: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the association between the network ACL and the subnet.
        public let networkAclAssociationId: String?
        /// The identifier of the network ACL.
        public let networkAclId: String?
        /// The identifier of the subnet that is associated with the network ACL.
        public let subnetId: String?

        public init(networkAclAssociationId: String? = nil, networkAclId: String? = nil, subnetId: String? = nil) {
            self.networkAclAssociationId = networkAclAssociationId
            self.networkAclId = networkAclId
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.validate(self.networkAclAssociationId, name: "networkAclAssociationId", parent: name, pattern: "\\S")
            try self.validate(self.networkAclId, name: "networkAclId", parent: name, pattern: "\\S")
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case networkAclAssociationId = "NetworkAclAssociationId"
            case networkAclId = "NetworkAclId"
            case subnetId = "SubnetId"
        }
    }

    public struct AwsEc2NetworkAclDetails: AWSEncodableShape & AWSDecodableShape {
        /// Associations between the network ACL and subnets.
        public let associations: [AwsEc2NetworkAclAssociation]?
        /// The set of rules in the network ACL.
        public let entries: [AwsEc2NetworkAclEntry]?
        /// Whether this is the default network ACL for the VPC.
        public let isDefault: Bool?
        /// The identifier of the network ACL.
        public let networkAclId: String?
        /// The identifier of the Amazon Web Services account that owns the network ACL.
        public let ownerId: String?
        /// The identifier of the VPC for the network ACL.
        public let vpcId: String?

        public init(associations: [AwsEc2NetworkAclAssociation]? = nil, entries: [AwsEc2NetworkAclEntry]? = nil, isDefault: Bool? = nil, networkAclId: String? = nil, ownerId: String? = nil, vpcId: String? = nil) {
            self.associations = associations
            self.entries = entries
            self.isDefault = isDefault
            self.networkAclId = networkAclId
            self.ownerId = ownerId
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.associations?.forEach {
                try $0.validate(name: "\(name).associations[]")
            }
            try self.entries?.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.networkAclId, name: "networkAclId", parent: name, pattern: "\\S")
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associations = "Associations"
            case entries = "Entries"
            case isDefault = "IsDefault"
            case networkAclId = "NetworkAclId"
            case ownerId = "OwnerId"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2NetworkAclEntry: AWSEncodableShape & AWSDecodableShape {
        /// The IPV4 network range for which to deny or allow access.
        public let cidrBlock: String?
        /// Whether the rule is an egress rule. An egress rule is a rule that applies to traffic that leaves the subnet.
        public let egress: Bool?
        /// The Internet Control Message Protocol (ICMP) type and code for which to deny or allow access.
        public let icmpTypeCode: IcmpTypeCode?
        /// The IPV6 network range for which to deny or allow access.
        public let ipv6CidrBlock: String?
        /// For TCP or UDP protocols, the range of ports that the rule applies to.
        public let portRange: PortRangeFromTo?
        /// The protocol that the rule applies to. To deny or allow access to all protocols, use the value -1.
        public let `protocol`: String?
        /// Whether the rule is used to allow access or deny access.
        public let ruleAction: String?
        /// The rule number. The rules are processed in order by their number.
        public let ruleNumber: Int?

        public init(cidrBlock: String? = nil, egress: Bool? = nil, icmpTypeCode: IcmpTypeCode? = nil, ipv6CidrBlock: String? = nil, portRange: PortRangeFromTo? = nil, protocol: String? = nil, ruleAction: String? = nil, ruleNumber: Int? = nil) {
            self.cidrBlock = cidrBlock
            self.egress = egress
            self.icmpTypeCode = icmpTypeCode
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.ruleNumber = ruleNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "\\S")
            try self.validate(self.ipv6CidrBlock, name: "ipv6CidrBlock", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.validate(self.ruleAction, name: "ruleAction", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrBlock = "CidrBlock"
            case egress = "Egress"
            case icmpTypeCode = "IcmpTypeCode"
            case ipv6CidrBlock = "Ipv6CidrBlock"
            case portRange = "PortRange"
            case `protocol` = "Protocol"
            case ruleAction = "RuleAction"
            case ruleNumber = "RuleNumber"
        }
    }

    public struct AwsEc2NetworkInterfaceAttachment: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the network interface attachment
        public let attachmentId: String?
        /// Indicates when the attachment initiated. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let attachTime: String?
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public let deleteOnTermination: Bool?
        /// The device index of the network interface attachment on the instance.
        public let deviceIndex: Int?
        /// The ID of the instance.
        public let instanceId: String?
        /// The Amazon Web Services account ID of the owner of the instance.
        public let instanceOwnerId: String?
        /// The attachment state. Valid values: attaching | attached | detaching | detached
        public let status: String?

        public init(attachmentId: String? = nil, attachTime: String? = nil, deleteOnTermination: Bool? = nil, deviceIndex: Int? = nil, instanceId: String? = nil, instanceOwnerId: String? = nil, status: String? = nil) {
            self.attachmentId = attachmentId
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.deviceIndex = deviceIndex
            self.instanceId = instanceId
            self.instanceOwnerId = instanceOwnerId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "\\S")
            try self.validate(self.attachTime, name: "attachTime", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "\\S")
            try self.validate(self.instanceOwnerId, name: "instanceOwnerId", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case attachTime = "AttachTime"
            case deleteOnTermination = "DeleteOnTermination"
            case deviceIndex = "DeviceIndex"
            case instanceId = "InstanceId"
            case instanceOwnerId = "InstanceOwnerId"
            case status = "Status"
        }
    }

    public struct AwsEc2NetworkInterfaceDetails: AWSEncodableShape & AWSDecodableShape {
        /// The network interface attachment.
        public let attachment: AwsEc2NetworkInterfaceAttachment?
        /// The IPv6 addresses associated with the network interface.
        public let ipV6Addresses: [AwsEc2NetworkInterfaceIpV6AddressDetail]?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The private IPv4 addresses associated with the network interface.
        public let privateIpAddresses: [AwsEc2NetworkInterfacePrivateIpAddressDetail]?
        /// The public DNS name of the network interface.
        public let publicDnsName: String?
        /// The address of the Elastic IP address bound to the network interface.
        public let publicIp: String?
        /// Security groups for the network interface.
        public let securityGroups: [AwsEc2NetworkInterfaceSecurityGroup]?
        /// Indicates whether traffic to or from the instance is validated.
        public let sourceDestCheck: Bool?

        public init(attachment: AwsEc2NetworkInterfaceAttachment? = nil, ipV6Addresses: [AwsEc2NetworkInterfaceIpV6AddressDetail]? = nil, networkInterfaceId: String? = nil, privateIpAddresses: [AwsEc2NetworkInterfacePrivateIpAddressDetail]? = nil, publicDnsName: String? = nil, publicIp: String? = nil, securityGroups: [AwsEc2NetworkInterfaceSecurityGroup]? = nil, sourceDestCheck: Bool? = nil) {
            self.attachment = attachment
            self.ipV6Addresses = ipV6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.sourceDestCheck = sourceDestCheck
        }

        public func validate(name: String) throws {
            try self.attachment?.validate(name: "\(name).attachment")
            try self.ipV6Addresses?.forEach {
                try $0.validate(name: "\(name).ipV6Addresses[]")
            }
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
            try self.privateIpAddresses?.forEach {
                try $0.validate(name: "\(name).privateIpAddresses[]")
            }
            try self.validate(self.publicDnsName, name: "publicDnsName", parent: name, pattern: "\\S")
            try self.validate(self.publicIp, name: "publicIp", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try $0.validate(name: "\(name).securityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case ipV6Addresses = "IpV6Addresses"
            case networkInterfaceId = "NetworkInterfaceId"
            case privateIpAddresses = "PrivateIpAddresses"
            case publicDnsName = "PublicDnsName"
            case publicIp = "PublicIp"
            case securityGroups = "SecurityGroups"
            case sourceDestCheck = "SourceDestCheck"
        }
    }

    public struct AwsEc2NetworkInterfaceIpV6AddressDetail: AWSEncodableShape & AWSDecodableShape {
        /// The IPV6 address.
        public let ipV6Address: String?

        public init(ipV6Address: String? = nil) {
            self.ipV6Address = ipV6Address
        }

        public func validate(name: String) throws {
            try self.validate(self.ipV6Address, name: "ipV6Address", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipV6Address = "IpV6Address"
        }
    }

    public struct AwsEc2NetworkInterfacePrivateIpAddressDetail: AWSEncodableShape & AWSDecodableShape {
        /// The private DNS name for the IP address.
        public let privateDnsName: String?
        /// The IP address.
        public let privateIpAddress: String?

        public init(privateDnsName: String? = nil, privateIpAddress: String? = nil) {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.privateDnsName, name: "privateDnsName", parent: name, pattern: "\\S")
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case privateDnsName = "PrivateDnsName"
            case privateIpAddress = "PrivateIpAddress"
        }
    }

    public struct AwsEc2NetworkInterfaceSecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the security group.
        public let groupId: String?
        /// The name of the security group.
        public let groupName: String?

        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "\\S")
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
        }
    }

    public struct AwsEc2SecurityGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the security group.
        public let groupId: String?
        /// The name of the security group.
        public let groupName: String?
        /// The inbound rules associated with the security group.
        public let ipPermissions: [AwsEc2SecurityGroupIpPermission]?
        /// [VPC only] The outbound rules associated with the security group.
        public let ipPermissionsEgress: [AwsEc2SecurityGroupIpPermission]?
        /// The Amazon Web Services account ID of the owner of the security group.
        public let ownerId: String?
        /// [VPC only] The ID of the VPC for the security group.
        public let vpcId: String?

        public init(groupId: String? = nil, groupName: String? = nil, ipPermissions: [AwsEc2SecurityGroupIpPermission]? = nil, ipPermissionsEgress: [AwsEc2SecurityGroupIpPermission]? = nil, ownerId: String? = nil, vpcId: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.ipPermissionsEgress = ipPermissionsEgress
            self.ownerId = ownerId
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "\\S")
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.ipPermissions?.forEach {
                try $0.validate(name: "\(name).ipPermissions[]")
            }
            try self.ipPermissionsEgress?.forEach {
                try $0.validate(name: "\(name).ipPermissionsEgress[]")
            }
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
            case ipPermissions = "IpPermissions"
            case ipPermissionsEgress = "IpPermissionsEgress"
            case ownerId = "OwnerId"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2SecurityGroupIpPermission: AWSEncodableShape & AWSDecodableShape {
        /// The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        public let fromPort: Int?
        /// The IP protocol name (tcp, udp, icmp, icmpv6) or number. [VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or icmpv6 allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For icmpv6, the port range is optional. If you omit the port range, traffic for all types and codes is allowed.
        public let ipProtocol: String?
        /// The IPv4 ranges.
        public let ipRanges: [AwsEc2SecurityGroupIpRange]?
        /// The IPv6 ranges.
        public let ipv6Ranges: [AwsEc2SecurityGroupIpv6Range]?
        /// [VPC only] The prefix list IDs for an Amazon Web Services service. With outbound rules, this is the Amazon Web Services service to access through a VPC endpoint from instances associated with the security group.
        public let prefixListIds: [AwsEc2SecurityGroupPrefixListId]?
        /// The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        public let toPort: Int?
        /// The security group and Amazon Web Services account ID pairs.
        public let userIdGroupPairs: [AwsEc2SecurityGroupUserIdGroupPair]?

        public init(fromPort: Int? = nil, ipProtocol: String? = nil, ipRanges: [AwsEc2SecurityGroupIpRange]? = nil, ipv6Ranges: [AwsEc2SecurityGroupIpv6Range]? = nil, prefixListIds: [AwsEc2SecurityGroupPrefixListId]? = nil, toPort: Int? = nil, userIdGroupPairs: [AwsEc2SecurityGroupUserIdGroupPair]? = nil) {
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.ipRanges = ipRanges
            self.ipv6Ranges = ipv6Ranges
            self.prefixListIds = prefixListIds
            self.toPort = toPort
            self.userIdGroupPairs = userIdGroupPairs
        }

        public func validate(name: String) throws {
            try self.validate(self.ipProtocol, name: "ipProtocol", parent: name, pattern: "\\S")
            try self.ipRanges?.forEach {
                try $0.validate(name: "\(name).ipRanges[]")
            }
            try self.ipv6Ranges?.forEach {
                try $0.validate(name: "\(name).ipv6Ranges[]")
            }
            try self.prefixListIds?.forEach {
                try $0.validate(name: "\(name).prefixListIds[]")
            }
            try self.userIdGroupPairs?.forEach {
                try $0.validate(name: "\(name).userIdGroupPairs[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case ipProtocol = "IpProtocol"
            case ipRanges = "IpRanges"
            case ipv6Ranges = "Ipv6Ranges"
            case prefixListIds = "PrefixListIds"
            case toPort = "ToPort"
            case userIdGroupPairs = "UserIdGroupPairs"
        }
    }

    public struct AwsEc2SecurityGroupIpRange: AWSEncodableShape & AWSDecodableShape {
        /// The IPv4 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv4 address, use the /32 prefix length.
        public let cidrIp: String?

        public init(cidrIp: String? = nil) {
            self.cidrIp = cidrIp
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrIp, name: "cidrIp", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrIp = "CidrIp"
        }
    }

    public struct AwsEc2SecurityGroupIpv6Range: AWSEncodableShape & AWSDecodableShape {
        /// The IPv6 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv6 address, use the /128 prefix length.
        public let cidrIpv6: String?

        public init(cidrIpv6: String? = nil) {
            self.cidrIpv6 = cidrIpv6
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrIpv6, name: "cidrIpv6", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrIpv6 = "CidrIpv6"
        }
    }

    public struct AwsEc2SecurityGroupPrefixListId: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the prefix.
        public let prefixListId: String?

        public init(prefixListId: String? = nil) {
            self.prefixListId = prefixListId
        }

        public func validate(name: String) throws {
            try self.validate(self.prefixListId, name: "prefixListId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case prefixListId = "PrefixListId"
        }
    }

    public struct AwsEc2SecurityGroupUserIdGroupPair: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the security group.
        public let groupId: String?
        /// The name of the security group.
        public let groupName: String?
        /// The status of a VPC peering connection, if applicable.
        public let peeringStatus: String?
        /// The ID of an Amazon Web Services account. For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned. [EC2-Classic] Required when adding or removing rules that reference a security group in another VPC.
        public let userId: String?
        /// The ID of the VPC for the referenced security group, if applicable.
        public let vpcId: String?
        /// The ID of the VPC peering connection, if applicable.
        public let vpcPeeringConnectionId: String?

        public init(groupId: String? = nil, groupName: String? = nil, peeringStatus: String? = nil, userId: String? = nil, vpcId: String? = nil, vpcPeeringConnectionId: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
            self.peeringStatus = peeringStatus
            self.userId = userId
            self.vpcId = vpcId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "\\S")
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.validate(self.peeringStatus, name: "peeringStatus", parent: name, pattern: "\\S")
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
            try self.validate(self.vpcPeeringConnectionId, name: "vpcPeeringConnectionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
            case peeringStatus = "PeeringStatus"
            case userId = "UserId"
            case vpcId = "VpcId"
            case vpcPeeringConnectionId = "VpcPeeringConnectionId"
        }
    }

    public struct AwsEc2SubnetDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to assign an IPV6 address to a network interface that is created in this subnet.
        public let assignIpv6AddressOnCreation: Bool?
        /// The Availability Zone for the subnet.
        public let availabilityZone: String?
        /// The identifier of the Availability Zone for the subnet.
        public let availabilityZoneId: String?
        /// The number of available IPV4 addresses in the subnet. Does not include addresses for stopped instances.
        public let availableIpAddressCount: Int?
        /// The IPV4 CIDR block that is assigned to the subnet.
        public let cidrBlock: String?
        /// Whether this subnet is the default subnet for the Availability Zone.
        public let defaultForAz: Bool?
        /// The IPV6 CIDR blocks that are associated with the subnet.
        public let ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]?
        /// Whether instances in this subnet receive a public IP address.
        public let mapPublicIpOnLaunch: Bool?
        /// The identifier of the Amazon Web Services account that owns the subnet.
        public let ownerId: String?
        /// The current state of the subnet. Valid values are available or pending.
        public let state: String?
        /// The ARN of the subnet.
        public let subnetArn: String?
        /// The identifier of the subnet.
        public let subnetId: String?
        /// The identifier of the VPC that contains the subnet.
        public let vpcId: String?

        public init(assignIpv6AddressOnCreation: Bool? = nil, availabilityZone: String? = nil, availabilityZoneId: String? = nil, availableIpAddressCount: Int? = nil, cidrBlock: String? = nil, defaultForAz: Bool? = nil, ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]? = nil, mapPublicIpOnLaunch: Bool? = nil, ownerId: String? = nil, state: String? = nil, subnetArn: String? = nil, subnetId: String? = nil, vpcId: String? = nil) {
            self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.availableIpAddressCount = availableIpAddressCount
            self.cidrBlock = cidrBlock
            self.defaultForAz = defaultForAz
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
            self.ownerId = ownerId
            self.state = state
            self.subnetArn = subnetArn
            self.subnetId = subnetId
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, pattern: "\\S")
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "\\S")
            try self.ipv6CidrBlockAssociationSet?.forEach {
                try $0.validate(name: "\(name).ipv6CidrBlockAssociationSet[]")
            }
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
            try self.validate(self.subnetArn, name: "subnetArn", parent: name, pattern: "\\S")
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case assignIpv6AddressOnCreation = "AssignIpv6AddressOnCreation"
            case availabilityZone = "AvailabilityZone"
            case availabilityZoneId = "AvailabilityZoneId"
            case availableIpAddressCount = "AvailableIpAddressCount"
            case cidrBlock = "CidrBlock"
            case defaultForAz = "DefaultForAz"
            case ipv6CidrBlockAssociationSet = "Ipv6CidrBlockAssociationSet"
            case mapPublicIpOnLaunch = "MapPublicIpOnLaunch"
            case ownerId = "OwnerId"
            case state = "State"
            case subnetArn = "SubnetArn"
            case subnetId = "SubnetId"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2TransitGatewayDetails: AWSEncodableShape & AWSDecodableShape {
        /// A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
        public let amazonSideAsn: Int?
        /// The ID of the default association route table.
        public let associationDefaultRouteTableId: String?
        /// Turn on or turn off automatic acceptance of attachment requests.
        public let autoAcceptSharedAttachments: String?
        /// Turn on or turn off automatic association with the default association route table.
        public let defaultRouteTableAssociation: String?
        /// Turn on or turn off automatic propagation of routes to the default propagation route table.
        public let defaultRouteTablePropagation: String?
        /// The description of the transit gateway.
        public let description: String?
        /// Turn on or turn off DNS support.
        public let dnsSupport: String?
        /// The ID of the transit gateway.
        public let id: String?
        /// Indicates whether multicast is supported on the transit gateway.
        public let multicastSupport: String?
        /// The ID of the default propagation route table.
        public let propagationDefaultRouteTableId: String?
        /// The transit gateway Classless Inter-Domain Routing (CIDR) blocks.
        public let transitGatewayCidrBlocks: [String]?
        /// Turn on or turn off Equal Cost Multipath Protocol (ECMP) support.
        public let vpnEcmpSupport: String?

        public init(amazonSideAsn: Int? = nil, associationDefaultRouteTableId: String? = nil, autoAcceptSharedAttachments: String? = nil, defaultRouteTableAssociation: String? = nil, defaultRouteTablePropagation: String? = nil, description: String? = nil, dnsSupport: String? = nil, id: String? = nil, multicastSupport: String? = nil, propagationDefaultRouteTableId: String? = nil, transitGatewayCidrBlocks: [String]? = nil, vpnEcmpSupport: String? = nil) {
            self.amazonSideAsn = amazonSideAsn
            self.associationDefaultRouteTableId = associationDefaultRouteTableId
            self.autoAcceptSharedAttachments = autoAcceptSharedAttachments
            self.defaultRouteTableAssociation = defaultRouteTableAssociation
            self.defaultRouteTablePropagation = defaultRouteTablePropagation
            self.description = description
            self.dnsSupport = dnsSupport
            self.id = id
            self.multicastSupport = multicastSupport
            self.propagationDefaultRouteTableId = propagationDefaultRouteTableId
            self.transitGatewayCidrBlocks = transitGatewayCidrBlocks
            self.vpnEcmpSupport = vpnEcmpSupport
        }

        public func validate(name: String) throws {
            try self.validate(self.associationDefaultRouteTableId, name: "associationDefaultRouteTableId", parent: name, pattern: "\\S")
            try self.validate(self.autoAcceptSharedAttachments, name: "autoAcceptSharedAttachments", parent: name, pattern: "\\S")
            try self.validate(self.defaultRouteTableAssociation, name: "defaultRouteTableAssociation", parent: name, pattern: "\\S")
            try self.validate(self.defaultRouteTablePropagation, name: "defaultRouteTablePropagation", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.dnsSupport, name: "dnsSupport", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.multicastSupport, name: "multicastSupport", parent: name, pattern: "\\S")
            try self.validate(self.propagationDefaultRouteTableId, name: "propagationDefaultRouteTableId", parent: name, pattern: "\\S")
            try self.transitGatewayCidrBlocks?.forEach {
                try validate($0, name: "transitGatewayCidrBlocks[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.vpnEcmpSupport, name: "vpnEcmpSupport", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case amazonSideAsn = "AmazonSideAsn"
            case associationDefaultRouteTableId = "AssociationDefaultRouteTableId"
            case autoAcceptSharedAttachments = "AutoAcceptSharedAttachments"
            case defaultRouteTableAssociation = "DefaultRouteTableAssociation"
            case defaultRouteTablePropagation = "DefaultRouteTablePropagation"
            case description = "Description"
            case dnsSupport = "DnsSupport"
            case id = "Id"
            case multicastSupport = "MulticastSupport"
            case propagationDefaultRouteTableId = "PropagationDefaultRouteTableId"
            case transitGatewayCidrBlocks = "TransitGatewayCidrBlocks"
            case vpnEcmpSupport = "VpnEcmpSupport"
        }
    }

    public struct AwsEc2VolumeAttachment: AWSEncodableShape & AWSDecodableShape {
        /// The datetime when the attachment initiated.
        public let attachTime: String?
        /// Whether the EBS volume is deleted when the EC2 instance is terminated.
        public let deleteOnTermination: Bool?
        /// The identifier of the EC2 instance.
        public let instanceId: String?
        /// The attachment state of the volume. Valid values are as follows:    attaching     attached     busy     detaching     detached
        public let status: String?

        public init(attachTime: String? = nil, deleteOnTermination: Bool? = nil, instanceId: String? = nil, status: String? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.instanceId = instanceId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.attachTime, name: "attachTime", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attachTime = "AttachTime"
            case deleteOnTermination = "DeleteOnTermination"
            case instanceId = "InstanceId"
            case status = "Status"
        }
    }

    public struct AwsEc2VolumeDetails: AWSEncodableShape & AWSDecodableShape {
        /// The volume attachments.
        public let attachments: [AwsEc2VolumeAttachment]?
        /// Indicates when the volume was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createTime: String?
        /// The device name for the volume that is attached to the instance.
        public let deviceName: String?
        /// Specifies whether the volume is encrypted.
        public let encrypted: Bool?
        /// The ARN of the KMS key that was used to protect the volume encryption key for the volume.
        public let kmsKeyId: String?
        /// The size of the volume, in GiBs.
        public let size: Int?
        /// The snapshot from which the volume was created.
        public let snapshotId: String?
        /// The volume state. Valid values are as follows:    available     creating     deleted     deleting     error     in-use
        public let status: String?
        /// The ID of the volume.
        public let volumeId: String?
        /// Indicates whether the volume was scanned or skipped.
        public let volumeScanStatus: String?
        /// The volume type.
        public let volumeType: String?

        public init(attachments: [AwsEc2VolumeAttachment]? = nil, createTime: String? = nil, deviceName: String? = nil, encrypted: Bool? = nil, kmsKeyId: String? = nil, size: Int? = nil, snapshotId: String? = nil, status: String? = nil, volumeId: String? = nil, volumeScanStatus: String? = nil, volumeType: String? = nil) {
            self.attachments = attachments
            self.createTime = createTime
            self.deviceName = deviceName
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.size = size
            self.snapshotId = snapshotId
            self.status = status
            self.volumeId = volumeId
            self.volumeScanStatus = volumeScanStatus
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.attachments?.forEach {
                try $0.validate(name: "\(name).attachments[]")
            }
            try self.validate(self.createTime, name: "createTime", parent: name, pattern: "\\S")
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.volumeId, name: "volumeId", parent: name, pattern: "\\S")
            try self.validate(self.volumeScanStatus, name: "volumeScanStatus", parent: name, pattern: "\\S")
            try self.validate(self.volumeType, name: "volumeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "Attachments"
            case createTime = "CreateTime"
            case deviceName = "DeviceName"
            case encrypted = "Encrypted"
            case kmsKeyId = "KmsKeyId"
            case size = "Size"
            case snapshotId = "SnapshotId"
            case status = "Status"
            case volumeId = "VolumeId"
            case volumeScanStatus = "VolumeScanStatus"
            case volumeType = "VolumeType"
        }
    }

    public struct AwsEc2VpcDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about the IPv4 CIDR blocks associated with the VPC.
        public let cidrBlockAssociationSet: [CidrBlockAssociation]?
        /// The identifier of the set of Dynamic Host Configuration Protocol (DHCP) options that are associated with the VPC. If the default options are associated with the VPC, then this is default.
        public let dhcpOptionsId: String?
        /// Information about the IPv6 CIDR blocks associated with the VPC.
        public let ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]?
        /// The current state of the VPC. Valid values are available or pending.
        public let state: String?

        public init(cidrBlockAssociationSet: [CidrBlockAssociation]? = nil, dhcpOptionsId: String? = nil, ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]? = nil, state: String? = nil) {
            self.cidrBlockAssociationSet = cidrBlockAssociationSet
            self.dhcpOptionsId = dhcpOptionsId
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.state = state
        }

        public func validate(name: String) throws {
            try self.cidrBlockAssociationSet?.forEach {
                try $0.validate(name: "\(name).cidrBlockAssociationSet[]")
            }
            try self.validate(self.dhcpOptionsId, name: "dhcpOptionsId", parent: name, pattern: "\\S")
            try self.ipv6CidrBlockAssociationSet?.forEach {
                try $0.validate(name: "\(name).ipv6CidrBlockAssociationSet[]")
            }
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrBlockAssociationSet = "CidrBlockAssociationSet"
            case dhcpOptionsId = "DhcpOptionsId"
            case ipv6CidrBlockAssociationSet = "Ipv6CidrBlockAssociationSet"
            case state = "State"
        }
    }

    public struct AwsEc2VpcEndpointServiceDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether requests from other Amazon Web Services accounts to create an endpoint to the service must first be accepted.
        public let acceptanceRequired: Bool?
        /// The Availability Zones where the service is available.
        public let availabilityZones: [String]?
        /// The DNS names for the service.
        public let baseEndpointDnsNames: [String]?
        /// The ARNs of the Gateway Load Balancers for the service.
        public let gatewayLoadBalancerArns: [String]?
        /// Whether the service manages its VPC endpoints.
        public let managesVpcEndpoints: Bool?
        /// The ARNs of the Network Load Balancers for the service.
        public let networkLoadBalancerArns: [String]?
        /// The private DNS name for the service.
        public let privateDnsName: String?
        /// The identifier of the service.
        public let serviceId: String?
        /// The name of the service.
        public let serviceName: String?
        /// The current state of the service. Valid values are as follows:    Available     Deleted     Deleting     Failed     Pending
        public let serviceState: String?
        /// The types for the service.
        public let serviceType: [AwsEc2VpcEndpointServiceServiceTypeDetails]?

        public init(acceptanceRequired: Bool? = nil, availabilityZones: [String]? = nil, baseEndpointDnsNames: [String]? = nil, gatewayLoadBalancerArns: [String]? = nil, managesVpcEndpoints: Bool? = nil, networkLoadBalancerArns: [String]? = nil, privateDnsName: String? = nil, serviceId: String? = nil, serviceName: String? = nil, serviceState: String? = nil, serviceType: [AwsEc2VpcEndpointServiceServiceTypeDetails]? = nil) {
            self.acceptanceRequired = acceptanceRequired
            self.availabilityZones = availabilityZones
            self.baseEndpointDnsNames = baseEndpointDnsNames
            self.gatewayLoadBalancerArns = gatewayLoadBalancerArns
            self.managesVpcEndpoints = managesVpcEndpoints
            self.networkLoadBalancerArns = networkLoadBalancerArns
            self.privateDnsName = privateDnsName
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceState = serviceState
            self.serviceType = serviceType
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "\\S")
            }
            try self.baseEndpointDnsNames?.forEach {
                try validate($0, name: "baseEndpointDnsNames[]", parent: name, pattern: "\\S")
            }
            try self.gatewayLoadBalancerArns?.forEach {
                try validate($0, name: "gatewayLoadBalancerArns[]", parent: name, pattern: "\\S")
            }
            try self.networkLoadBalancerArns?.forEach {
                try validate($0, name: "networkLoadBalancerArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.privateDnsName, name: "privateDnsName", parent: name, pattern: "\\S")
            try self.validate(self.serviceId, name: "serviceId", parent: name, pattern: "\\S")
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "\\S")
            try self.validate(self.serviceState, name: "serviceState", parent: name, pattern: "\\S")
            try self.serviceType?.forEach {
                try $0.validate(name: "\(name).serviceType[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceRequired = "AcceptanceRequired"
            case availabilityZones = "AvailabilityZones"
            case baseEndpointDnsNames = "BaseEndpointDnsNames"
            case gatewayLoadBalancerArns = "GatewayLoadBalancerArns"
            case managesVpcEndpoints = "ManagesVpcEndpoints"
            case networkLoadBalancerArns = "NetworkLoadBalancerArns"
            case privateDnsName = "PrivateDnsName"
            case serviceId = "ServiceId"
            case serviceName = "ServiceName"
            case serviceState = "ServiceState"
            case serviceType = "ServiceType"
        }
    }

    public struct AwsEc2VpcEndpointServiceServiceTypeDetails: AWSEncodableShape & AWSDecodableShape {
        /// The type of service.
        public let serviceType: String?

        public init(serviceType: String? = nil) {
            self.serviceType = serviceType
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceType, name: "serviceType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceType = "ServiceType"
        }
    }

    public struct AwsEc2VpcPeeringConnectionDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about the accepter VPC.
        public let accepterVpcInfo: AwsEc2VpcPeeringConnectionVpcInfoDetails?
        /// The time at which an unaccepted VPC peering connection will expire.
        public let expirationTime: String?
        /// Information about the requester VPC.
        public let requesterVpcInfo: AwsEc2VpcPeeringConnectionVpcInfoDetails?
        /// The status of the VPC peering connection.
        public let status: AwsEc2VpcPeeringConnectionStatusDetails?
        /// The ID of the VPC peering connection.
        public let vpcPeeringConnectionId: String?

        public init(accepterVpcInfo: AwsEc2VpcPeeringConnectionVpcInfoDetails? = nil, expirationTime: String? = nil, requesterVpcInfo: AwsEc2VpcPeeringConnectionVpcInfoDetails? = nil, status: AwsEc2VpcPeeringConnectionStatusDetails? = nil, vpcPeeringConnectionId: String? = nil) {
            self.accepterVpcInfo = accepterVpcInfo
            self.expirationTime = expirationTime
            self.requesterVpcInfo = requesterVpcInfo
            self.status = status
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public func validate(name: String) throws {
            try self.accepterVpcInfo?.validate(name: "\(name).accepterVpcInfo")
            try self.validate(self.expirationTime, name: "expirationTime", parent: name, pattern: "\\S")
            try self.requesterVpcInfo?.validate(name: "\(name).requesterVpcInfo")
            try self.status?.validate(name: "\(name).status")
            try self.validate(self.vpcPeeringConnectionId, name: "vpcPeeringConnectionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accepterVpcInfo = "AccepterVpcInfo"
            case expirationTime = "ExpirationTime"
            case requesterVpcInfo = "RequesterVpcInfo"
            case status = "Status"
            case vpcPeeringConnectionId = "VpcPeeringConnectionId"
        }
    }

    public struct AwsEc2VpcPeeringConnectionStatusDetails: AWSEncodableShape & AWSDecodableShape {
        /// The status of the VPC peering connection.
        public let code: String?
        /// A message that provides more information about the status, if applicable.
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, pattern: "\\S")
            try self.validate(self.message, name: "message", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct AwsEc2VpcPeeringConnectionVpcInfoDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IPv4 CIDR block for the VPC.
        public let cidrBlock: String?
        /// Information about the IPv4 CIDR blocks for the VPC.
        public let cidrBlockSet: [VpcInfoCidrBlockSetDetails]?
        /// The IPv6 CIDR block for the VPC.
        public let ipv6CidrBlockSet: [VpcInfoIpv6CidrBlockSetDetails]?
        /// The ID of the Amazon Web Services account that owns the VPC.
        public let ownerId: String?
        /// Information about the VPC peering connection options for the accepter or requester VPC.
        public let peeringOptions: VpcInfoPeeringOptionsDetails?
        /// The Amazon Web Services Region in which the VPC is located.
        public let region: String?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(cidrBlock: String? = nil, cidrBlockSet: [VpcInfoCidrBlockSetDetails]? = nil, ipv6CidrBlockSet: [VpcInfoIpv6CidrBlockSetDetails]? = nil, ownerId: String? = nil, peeringOptions: VpcInfoPeeringOptionsDetails? = nil, region: String? = nil, vpcId: String? = nil) {
            self.cidrBlock = cidrBlock
            self.cidrBlockSet = cidrBlockSet
            self.ipv6CidrBlockSet = ipv6CidrBlockSet
            self.ownerId = ownerId
            self.peeringOptions = peeringOptions
            self.region = region
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "\\S")
            try self.cidrBlockSet?.forEach {
                try $0.validate(name: "\(name).cidrBlockSet[]")
            }
            try self.ipv6CidrBlockSet?.forEach {
                try $0.validate(name: "\(name).ipv6CidrBlockSet[]")
            }
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.region, name: "region", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrBlock = "CidrBlock"
            case cidrBlockSet = "CidrBlockSet"
            case ipv6CidrBlockSet = "Ipv6CidrBlockSet"
            case ownerId = "OwnerId"
            case peeringOptions = "PeeringOptions"
            case region = "Region"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2VpnConnectionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The category of the VPN connection. VPN indicates an Amazon Web Services VPN connection. VPN-Classic indicates an Amazon Web Services Classic VPN connection.
        public let category: String?
        /// The configuration information for the VPN connection's customer gateway, in the native XML format.
        public let customerGatewayConfiguration: String?
        /// The identifier of the customer gateway that is at your end of the VPN connection.
        public let customerGatewayId: String?
        /// The VPN connection options.
        public let options: AwsEc2VpnConnectionOptionsDetails?
        /// The static routes that are associated with the VPN connection.
        public let routes: [AwsEc2VpnConnectionRoutesDetails]?
        /// The current state of the VPN connection. Valid values are as follows:    available     deleted     deleting     pending
        public let state: String?
        /// The identifier of the transit gateway that is associated with the VPN connection.
        public let transitGatewayId: String?
        /// The type of VPN connection.
        public let type: String?
        /// Information about the VPN tunnel.
        public let vgwTelemetry: [AwsEc2VpnConnectionVgwTelemetryDetails]?
        /// The identifier of the VPN connection.
        public let vpnConnectionId: String?
        /// The identifier of the virtual private gateway that is at the Amazon Web Services side of the VPN connection.
        public let vpnGatewayId: String?

        public init(category: String? = nil, customerGatewayConfiguration: String? = nil, customerGatewayId: String? = nil, options: AwsEc2VpnConnectionOptionsDetails? = nil, routes: [AwsEc2VpnConnectionRoutesDetails]? = nil, state: String? = nil, transitGatewayId: String? = nil, type: String? = nil, vgwTelemetry: [AwsEc2VpnConnectionVgwTelemetryDetails]? = nil, vpnConnectionId: String? = nil, vpnGatewayId: String? = nil) {
            self.category = category
            self.customerGatewayConfiguration = customerGatewayConfiguration
            self.customerGatewayId = customerGatewayId
            self.options = options
            self.routes = routes
            self.state = state
            self.transitGatewayId = transitGatewayId
            self.type = type
            self.vgwTelemetry = vgwTelemetry
            self.vpnConnectionId = vpnConnectionId
            self.vpnGatewayId = vpnGatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.category, name: "category", parent: name, pattern: "\\S")
            try self.validate(self.customerGatewayConfiguration, name: "customerGatewayConfiguration", parent: name, pattern: "\\S")
            try self.validate(self.customerGatewayId, name: "customerGatewayId", parent: name, pattern: "\\S")
            try self.options?.validate(name: "\(name).options")
            try self.routes?.forEach {
                try $0.validate(name: "\(name).routes[]")
            }
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
            try self.validate(self.transitGatewayId, name: "transitGatewayId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.vgwTelemetry?.forEach {
                try $0.validate(name: "\(name).vgwTelemetry[]")
            }
            try self.validate(self.vpnConnectionId, name: "vpnConnectionId", parent: name, pattern: "\\S")
            try self.validate(self.vpnGatewayId, name: "vpnGatewayId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case customerGatewayConfiguration = "CustomerGatewayConfiguration"
            case customerGatewayId = "CustomerGatewayId"
            case options = "Options"
            case routes = "Routes"
            case state = "State"
            case transitGatewayId = "TransitGatewayId"
            case type = "Type"
            case vgwTelemetry = "VgwTelemetry"
            case vpnConnectionId = "VpnConnectionId"
            case vpnGatewayId = "VpnGatewayId"
        }
    }

    public struct AwsEc2VpnConnectionOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the VPN connection uses static routes only.
        public let staticRoutesOnly: Bool?
        /// The VPN tunnel options.
        public let tunnelOptions: [AwsEc2VpnConnectionOptionsTunnelOptionsDetails]?

        public init(staticRoutesOnly: Bool? = nil, tunnelOptions: [AwsEc2VpnConnectionOptionsTunnelOptionsDetails]? = nil) {
            self.staticRoutesOnly = staticRoutesOnly
            self.tunnelOptions = tunnelOptions
        }

        public func validate(name: String) throws {
            try self.tunnelOptions?.forEach {
                try $0.validate(name: "\(name).tunnelOptions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case staticRoutesOnly = "StaticRoutesOnly"
            case tunnelOptions = "TunnelOptions"
        }
    }

    public struct AwsEc2VpnConnectionOptionsTunnelOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of seconds after which a Dead Peer Detection (DPD) timeout occurs.
        public let dpdTimeoutSeconds: Int?
        /// The Internet Key Exchange (IKE) versions that are permitted for the VPN tunnel.
        public let ikeVersions: [String]?
        /// The external IP address of the VPN tunnel.
        public let outsideIpAddress: String?
        /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1 IKE negotiations.
        public let phase1DhGroupNumbers: [Int]?
        /// The permitted encryption algorithms for the VPN tunnel for phase 1 IKE negotiations.
        public let phase1EncryptionAlgorithms: [String]?
        /// The permitted integrity algorithms for the VPN tunnel for phase 1 IKE negotiations.
        public let phase1IntegrityAlgorithms: [String]?
        /// The lifetime for phase 1 of the IKE negotiation, in seconds.
        public let phase1LifetimeSeconds: Int?
        /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2 IKE negotiations.
        public let phase2DhGroupNumbers: [Int]?
        /// The permitted encryption algorithms for the VPN tunnel for phase 2 IKE negotiations.
        public let phase2EncryptionAlgorithms: [String]?
        /// The permitted integrity algorithms for the VPN tunnel for phase 2 IKE negotiations.
        public let phase2IntegrityAlgorithms: [String]?
        /// The lifetime for phase 2 of the IKE negotiation, in seconds.
        public let phase2LifetimeSeconds: Int?
        /// The preshared key to establish initial authentication between the virtual private gateway and the customer gateway.
        public let preSharedKey: String?
        /// The percentage of the rekey window, which is determined by RekeyMarginTimeSeconds during which the rekey time is randomly selected.
        public let rekeyFuzzPercentage: Int?
        /// The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey.
        public let rekeyMarginTimeSeconds: Int?
        /// The number of packets in an IKE replay window.
        public let replayWindowSize: Int?
        /// The range of inside IPv4 addresses for the tunnel.
        public let tunnelInsideCidr: String?

        public init(dpdTimeoutSeconds: Int? = nil, ikeVersions: [String]? = nil, outsideIpAddress: String? = nil, phase1DhGroupNumbers: [Int]? = nil, phase1EncryptionAlgorithms: [String]? = nil, phase1IntegrityAlgorithms: [String]? = nil, phase1LifetimeSeconds: Int? = nil, phase2DhGroupNumbers: [Int]? = nil, phase2EncryptionAlgorithms: [String]? = nil, phase2IntegrityAlgorithms: [String]? = nil, phase2LifetimeSeconds: Int? = nil, preSharedKey: String? = nil, rekeyFuzzPercentage: Int? = nil, rekeyMarginTimeSeconds: Int? = nil, replayWindowSize: Int? = nil, tunnelInsideCidr: String? = nil) {
            self.dpdTimeoutSeconds = dpdTimeoutSeconds
            self.ikeVersions = ikeVersions
            self.outsideIpAddress = outsideIpAddress
            self.phase1DhGroupNumbers = phase1DhGroupNumbers
            self.phase1EncryptionAlgorithms = phase1EncryptionAlgorithms
            self.phase1IntegrityAlgorithms = phase1IntegrityAlgorithms
            self.phase1LifetimeSeconds = phase1LifetimeSeconds
            self.phase2DhGroupNumbers = phase2DhGroupNumbers
            self.phase2EncryptionAlgorithms = phase2EncryptionAlgorithms
            self.phase2IntegrityAlgorithms = phase2IntegrityAlgorithms
            self.phase2LifetimeSeconds = phase2LifetimeSeconds
            self.preSharedKey = preSharedKey
            self.rekeyFuzzPercentage = rekeyFuzzPercentage
            self.rekeyMarginTimeSeconds = rekeyMarginTimeSeconds
            self.replayWindowSize = replayWindowSize
            self.tunnelInsideCidr = tunnelInsideCidr
        }

        public func validate(name: String) throws {
            try self.ikeVersions?.forEach {
                try validate($0, name: "ikeVersions[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.outsideIpAddress, name: "outsideIpAddress", parent: name, pattern: "\\S")
            try self.phase1EncryptionAlgorithms?.forEach {
                try validate($0, name: "phase1EncryptionAlgorithms[]", parent: name, pattern: "\\S")
            }
            try self.phase1IntegrityAlgorithms?.forEach {
                try validate($0, name: "phase1IntegrityAlgorithms[]", parent: name, pattern: "\\S")
            }
            try self.phase2EncryptionAlgorithms?.forEach {
                try validate($0, name: "phase2EncryptionAlgorithms[]", parent: name, pattern: "\\S")
            }
            try self.phase2IntegrityAlgorithms?.forEach {
                try validate($0, name: "phase2IntegrityAlgorithms[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.preSharedKey, name: "preSharedKey", parent: name, pattern: "\\S")
            try self.validate(self.tunnelInsideCidr, name: "tunnelInsideCidr", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dpdTimeoutSeconds = "DpdTimeoutSeconds"
            case ikeVersions = "IkeVersions"
            case outsideIpAddress = "OutsideIpAddress"
            case phase1DhGroupNumbers = "Phase1DhGroupNumbers"
            case phase1EncryptionAlgorithms = "Phase1EncryptionAlgorithms"
            case phase1IntegrityAlgorithms = "Phase1IntegrityAlgorithms"
            case phase1LifetimeSeconds = "Phase1LifetimeSeconds"
            case phase2DhGroupNumbers = "Phase2DhGroupNumbers"
            case phase2EncryptionAlgorithms = "Phase2EncryptionAlgorithms"
            case phase2IntegrityAlgorithms = "Phase2IntegrityAlgorithms"
            case phase2LifetimeSeconds = "Phase2LifetimeSeconds"
            case preSharedKey = "PreSharedKey"
            case rekeyFuzzPercentage = "RekeyFuzzPercentage"
            case rekeyMarginTimeSeconds = "RekeyMarginTimeSeconds"
            case replayWindowSize = "ReplayWindowSize"
            case tunnelInsideCidr = "TunnelInsideCidr"
        }
    }

    public struct AwsEc2VpnConnectionRoutesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The CIDR block associated with the local subnet of the customer data center.
        public let destinationCidrBlock: String?
        /// The current state of the static route.
        public let state: String?

        public init(destinationCidrBlock: String? = nil, state: String? = nil) {
            self.destinationCidrBlock = destinationCidrBlock
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationCidrBlock, name: "destinationCidrBlock", parent: name, pattern: "\\S")
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationCidrBlock = "DestinationCidrBlock"
            case state = "State"
        }
    }

    public struct AwsEc2VpnConnectionVgwTelemetryDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of accepted routes.
        public let acceptedRouteCount: Int?
        /// The ARN of the VPN tunnel endpoint certificate.
        public let certificateArn: String?
        /// The date and time of the last change in status. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastStatusChange: String?
        /// The Internet-routable IP address of the virtual private gateway's outside interface.
        public let outsideIpAddress: String?
        /// The status of the VPN tunnel. Valid values are DOWN or UP.
        public let status: String?
        /// If an error occurs, a description of the error.
        public let statusMessage: String?

        public init(acceptedRouteCount: Int? = nil, certificateArn: String? = nil, lastStatusChange: String? = nil, outsideIpAddress: String? = nil, status: String? = nil, statusMessage: String? = nil) {
            self.acceptedRouteCount = acceptedRouteCount
            self.certificateArn = certificateArn
            self.lastStatusChange = lastStatusChange
            self.outsideIpAddress = outsideIpAddress
            self.status = status
            self.statusMessage = statusMessage
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, pattern: "\\S")
            try self.validate(self.lastStatusChange, name: "lastStatusChange", parent: name, pattern: "\\S")
            try self.validate(self.outsideIpAddress, name: "outsideIpAddress", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.statusMessage, name: "statusMessage", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptedRouteCount = "AcceptedRouteCount"
            case certificateArn = "CertificateArn"
            case lastStatusChange = "LastStatusChange"
            case outsideIpAddress = "OutsideIpAddress"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct AwsEcrContainerImageDetails: AWSEncodableShape & AWSDecodableShape {
        /// The architecture of the image. Valid values are as follows:    arm64     i386     x86_64
        public let architecture: String?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The date and time when the image was pushed to the repository. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let imagePublishedAt: String?
        /// The list of tags that are associated with the image.
        public let imageTags: [String]?
        /// The Amazon Web Services account identifier that is associated with the registry that the image belongs to.
        public let registryId: String?
        /// The name of the repository that the image belongs to.
        public let repositoryName: String?

        public init(architecture: String? = nil, imageDigest: String? = nil, imagePublishedAt: String? = nil, imageTags: [String]? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.architecture = architecture
            self.imageDigest = imageDigest
            self.imagePublishedAt = imagePublishedAt
            self.imageTags = imageTags
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.architecture, name: "architecture", parent: name, pattern: "\\S")
            try self.validate(self.imageDigest, name: "imageDigest", parent: name, pattern: "\\S")
            try self.validate(self.imagePublishedAt, name: "imagePublishedAt", parent: name, pattern: "\\S")
            try self.imageTags?.forEach {
                try validate($0, name: "imageTags[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "\\S")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "Architecture"
            case imageDigest = "ImageDigest"
            case imagePublishedAt = "ImagePublishedAt"
            case imageTags = "ImageTags"
            case registryId = "RegistryId"
            case repositoryName = "RepositoryName"
        }
    }

    public struct AwsEcrRepositoryDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the repository.
        public let arn: String?
        /// The image scanning configuration for a repository.
        public let imageScanningConfiguration: AwsEcrRepositoryImageScanningConfigurationDetails?
        /// The tag mutability setting for the repository. Valid values are IMMUTABLE or MUTABLE.
        public let imageTagMutability: String?
        /// Information about the lifecycle policy for the repository.
        public let lifecyclePolicy: AwsEcrRepositoryLifecyclePolicyDetails?
        /// The name of the repository.
        public let repositoryName: String?
        /// The text of the repository policy.
        public let repositoryPolicyText: String?

        public init(arn: String? = nil, imageScanningConfiguration: AwsEcrRepositoryImageScanningConfigurationDetails? = nil, imageTagMutability: String? = nil, lifecyclePolicy: AwsEcrRepositoryLifecyclePolicyDetails? = nil, repositoryName: String? = nil, repositoryPolicyText: String? = nil) {
            self.arn = arn
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTagMutability = imageTagMutability
            self.lifecyclePolicy = lifecyclePolicy
            self.repositoryName = repositoryName
            self.repositoryPolicyText = repositoryPolicyText
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.imageTagMutability, name: "imageTagMutability", parent: name, pattern: "\\S")
            try self.lifecyclePolicy?.validate(name: "\(name).lifecyclePolicy")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "\\S")
            try self.validate(self.repositoryPolicyText, name: "repositoryPolicyText", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case imageScanningConfiguration = "ImageScanningConfiguration"
            case imageTagMutability = "ImageTagMutability"
            case lifecyclePolicy = "LifecyclePolicy"
            case repositoryName = "RepositoryName"
            case repositoryPolicyText = "RepositoryPolicyText"
        }
    }

    public struct AwsEcrRepositoryImageScanningConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to scan images after they are pushed to a repository.
        public let scanOnPush: Bool?

        public init(scanOnPush: Bool? = nil) {
            self.scanOnPush = scanOnPush
        }

        private enum CodingKeys: String, CodingKey {
            case scanOnPush = "ScanOnPush"
        }
    }

    public struct AwsEcrRepositoryLifecyclePolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The text of the lifecycle policy.
        public let lifecyclePolicyText: String?
        /// The Amazon Web Services account identifier that is associated with the registry that contains the repository.
        public let registryId: String?

        public init(lifecyclePolicyText: String? = nil, registryId: String? = nil) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecyclePolicyText, name: "lifecyclePolicyText", parent: name, pattern: "\\S")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText = "LifecyclePolicyText"
            case registryId = "RegistryId"
        }
    }

    public struct AwsEcsClusterClusterSettingsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the setting. The valid value is containerInsights.
        public let name: String?
        /// The value of the setting. Valid values are disabled or enabled.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsEcsClusterConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Contains the run command configuration for the cluster.
        public let executeCommandConfiguration: AwsEcsClusterConfigurationExecuteCommandConfigurationDetails?

        public init(executeCommandConfiguration: AwsEcsClusterConfigurationExecuteCommandConfigurationDetails? = nil) {
            self.executeCommandConfiguration = executeCommandConfiguration
        }

        public func validate(name: String) throws {
            try self.executeCommandConfiguration?.validate(name: "\(name).executeCommandConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case executeCommandConfiguration = "ExecuteCommandConfiguration"
        }
    }

    public struct AwsEcsClusterConfigurationExecuteCommandConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the KMS key that is used to encrypt the data between the local client and the container.
        public let kmsKeyId: String?
        /// The log configuration for the results of the run command actions. Required if Logging is NONE.
        public let logConfiguration: AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails?
        /// The log setting to use for redirecting logs for run command results.
        public let logging: String?

        public init(kmsKeyId: String? = nil, logConfiguration: AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails? = nil, logging: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.logConfiguration = logConfiguration
            self.logging = logging
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.logConfiguration?.validate(name: "\(name).logConfiguration")
            try self.validate(self.logging, name: "logging", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case logConfiguration = "LogConfiguration"
            case logging = "Logging"
        }
    }

    public struct AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to enable encryption on the CloudWatch logs.
        public let cloudWatchEncryptionEnabled: Bool?
        /// The name of the CloudWatch log group to send the logs to.
        public let cloudWatchLogGroupName: String?
        /// The name of the S3 bucket to send logs to.
        public let s3BucketName: String?
        /// Whether to encrypt the logs that are sent to the S3 bucket.
        public let s3EncryptionEnabled: Bool?
        /// Identifies the folder in the S3 bucket to send the logs to.
        public let s3KeyPrefix: String?

        public init(cloudWatchEncryptionEnabled: Bool? = nil, cloudWatchLogGroupName: String? = nil, s3BucketName: String? = nil, s3EncryptionEnabled: Bool? = nil, s3KeyPrefix: String? = nil) {
            self.cloudWatchEncryptionEnabled = cloudWatchEncryptionEnabled
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.s3BucketName = s3BucketName
            self.s3EncryptionEnabled = s3EncryptionEnabled
            self.s3KeyPrefix = s3KeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, pattern: "\\S")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "\\S")
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchEncryptionEnabled = "CloudWatchEncryptionEnabled"
            case cloudWatchLogGroupName = "CloudWatchLogGroupName"
            case s3BucketName = "S3BucketName"
            case s3EncryptionEnabled = "S3EncryptionEnabled"
            case s3KeyPrefix = "S3KeyPrefix"
        }
    }

    public struct AwsEcsClusterDefaultCapacityProviderStrategyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The minimum number of tasks to run on the specified capacity provider.
        public let base: Int?
        /// The name of the capacity provider.
        public let capacityProvider: String?
        /// The relative percentage of the total number of tasks launched that should use the capacity provider.
        public let weight: Int?

        public init(base: Int? = nil, capacityProvider: String? = nil, weight: Int? = nil) {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityProvider, name: "capacityProvider", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case base = "Base"
            case capacityProvider = "CapacityProvider"
            case weight = "Weight"
        }
    }

    public struct AwsEcsClusterDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of services that are running on the cluster in an ACTIVE state. You can view these services with the Amazon ECS  ListServices API operation.
        public let activeServicesCount: Int?
        /// The short name of one or more capacity providers to associate with the cluster.
        public let capacityProviders: [String]?
        /// The Amazon Resource Name (ARN) that identifies the cluster.
        public let clusterArn: String?
        /// A name that you use to identify your cluster.
        public let clusterName: String?
        /// The setting to use to create the cluster. Specifically used to configure whether to enable CloudWatch Container Insights for the cluster.
        public let clusterSettings: [AwsEcsClusterClusterSettingsDetails]?
        /// The run command configuration for the cluster.
        public let configuration: AwsEcsClusterConfigurationDetails?
        /// The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.
        public let defaultCapacityProviderStrategy: [AwsEcsClusterDefaultCapacityProviderStrategyDetails]?
        /// The number of container instances registered into the cluster. This includes container instances in both ACTIVE and DRAINING status.
        public let registeredContainerInstancesCount: Int?
        /// The number of tasks in the cluster that are in the RUNNING state.
        public let runningTasksCount: Int?
        /// The status of the cluster.
        public let status: String?

        public init(activeServicesCount: Int? = nil, capacityProviders: [String]? = nil, clusterArn: String? = nil, clusterName: String? = nil, clusterSettings: [AwsEcsClusterClusterSettingsDetails]? = nil, configuration: AwsEcsClusterConfigurationDetails? = nil, defaultCapacityProviderStrategy: [AwsEcsClusterDefaultCapacityProviderStrategyDetails]? = nil, registeredContainerInstancesCount: Int? = nil, runningTasksCount: Int? = nil, status: String? = nil) {
            self.activeServicesCount = activeServicesCount
            self.capacityProviders = capacityProviders
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterSettings = clusterSettings
            self.configuration = configuration
            self.defaultCapacityProviderStrategy = defaultCapacityProviderStrategy
            self.registeredContainerInstancesCount = registeredContainerInstancesCount
            self.runningTasksCount = runningTasksCount
            self.status = status
        }

        public func validate(name: String) throws {
            try self.capacityProviders?.forEach {
                try validate($0, name: "capacityProviders[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.clusterArn, name: "clusterArn", parent: name, pattern: "\\S")
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "\\S")
            try self.clusterSettings?.forEach {
                try $0.validate(name: "\(name).clusterSettings[]")
            }
            try self.configuration?.validate(name: "\(name).configuration")
            try self.defaultCapacityProviderStrategy?.forEach {
                try $0.validate(name: "\(name).defaultCapacityProviderStrategy[]")
            }
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case activeServicesCount = "ActiveServicesCount"
            case capacityProviders = "CapacityProviders"
            case clusterArn = "ClusterArn"
            case clusterName = "ClusterName"
            case clusterSettings = "ClusterSettings"
            case configuration = "Configuration"
            case defaultCapacityProviderStrategy = "DefaultCapacityProviderStrategy"
            case registeredContainerInstancesCount = "RegisteredContainerInstancesCount"
            case runningTasksCount = "RunningTasksCount"
            case status = "Status"
        }
    }

    public struct AwsEcsContainerDetails: AWSEncodableShape & AWSDecodableShape {
        /// The image used for the container.
        public let image: String?
        /// The mount points for data volumes in your container.
        public let mountPoints: [AwsMountPoint]?
        /// The name of the container.
        public let name: String?
        /// When this parameter is true, the container is given elevated privileges on the host container instance
        /// (similar to the root user).
        public let privileged: Bool?

        public init(image: String? = nil, mountPoints: [AwsMountPoint]? = nil, name: String? = nil, privileged: Bool? = nil) {
            self.image = image
            self.mountPoints = mountPoints
            self.name = name
            self.privileged = privileged
        }

        public func validate(name: String) throws {
            try self.validate(self.image, name: "image", parent: name, pattern: "\\S")
            try self.mountPoints?.forEach {
                try $0.validate(name: "\(name).mountPoints[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case image = "Image"
            case mountPoints = "MountPoints"
            case name = "Name"
            case privileged = "Privileged"
        }
    }

    public struct AwsEcsServiceCapacityProviderStrategyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The minimum number of tasks to run on the capacity provider. Only one strategy item can specify a value for Base. The value must be between 0 and 100000.
        public let base: Int?
        /// The short name of the capacity provider.
        public let capacityProvider: String?
        /// The relative percentage of the total number of tasks that should use the capacity provider. If no weight is specified, the default value is 0. At least one capacity provider must have a weight greater than 0. The value can be between 0 and 1000.
        public let weight: Int?

        public init(base: Int? = nil, capacityProvider: String? = nil, weight: Int? = nil) {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityProvider, name: "capacityProvider", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case base = "Base"
            case capacityProvider = "CapacityProvider"
            case weight = "Weight"
        }
    }

    public struct AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to enable the deployment circuit breaker logic for the service.
        public let enable: Bool?
        /// Whether to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
        public let rollback: Bool?

        public init(enable: Bool? = nil, rollback: Bool? = nil) {
            self.enable = enable
            self.rollback = rollback
        }

        private enum CodingKeys: String, CodingKey {
            case enable = "Enable"
            case rollback = "Rollback"
        }
    }

    public struct AwsEcsServiceDeploymentConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether a service deployment fails if a service cannot reach a steady state.
        public let deploymentCircuitBreaker: AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails?
        /// For a service that uses the rolling update (ECS) deployment type, the maximum number of tasks in a service that are allowed in the RUNNING or PENDING state during a deployment, and for tasks that use the EC2 launch type, when any container instances are in the DRAINING state. Provided as a percentage of the desired number of tasks. The default value is 200%. For a service that uses the blue/green (CODE_DEPLOY) or EXTERNAL deployment types, and tasks that use the EC2 launch type, the maximum number of tasks in the service that remain in the RUNNING state while the container instances are in the DRAINING state. For the Fargate launch type, the maximum percent value is not used.
        public let maximumPercent: Int?
        /// For a service that uses the rolling update (ECS) deployment type, the minimum number of tasks in a service that must remain in the RUNNING state during a deployment, and while any container instances are in the DRAINING state if the service contains tasks using the EC2 launch type. Expressed as a percentage of the desired number of tasks. The default value is 100%. For a service that uses the blue/green (CODE_DEPLOY) or EXTERNAL deployment types and tasks that use the EC2 launch type, the minimum number of the tasks in the service that remain in the RUNNING state while the container instances are in the DRAINING state. For the Fargate launch type, the minimum healthy percent value is not used.
        public let minimumHealthyPercent: Int?

        public init(deploymentCircuitBreaker: AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails? = nil, maximumPercent: Int? = nil, minimumHealthyPercent: Int? = nil) {
            self.deploymentCircuitBreaker = deploymentCircuitBreaker
            self.maximumPercent = maximumPercent
            self.minimumHealthyPercent = minimumHealthyPercent
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentCircuitBreaker = "DeploymentCircuitBreaker"
            case maximumPercent = "MaximumPercent"
            case minimumHealthyPercent = "MinimumHealthyPercent"
        }
    }

    public struct AwsEcsServiceDeploymentControllerDetails: AWSEncodableShape & AWSDecodableShape {
        /// The rolling update (ECS) deployment type replaces the current running version of the container with the latest version. The blue/green (CODE_DEPLOY) deployment type uses the blue/green deployment model that is powered by CodeDeploy. This deployment model a new deployment of a service can be verified before production traffic is sent to it. The external (EXTERNAL) deployment type allows the use of any third-party deployment controller for full control over the deployment process for an Amazon ECS service. Valid values: ECS | CODE_DEPLOY | EXTERNAL
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsEcsServiceDetails: AWSEncodableShape & AWSDecodableShape {
        /// The capacity provider strategy that the service uses.
        public let capacityProviderStrategy: [AwsEcsServiceCapacityProviderStrategyDetails]?
        /// The ARN of the cluster that hosts the service.
        public let cluster: String?
        /// Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.
        public let deploymentConfiguration: AwsEcsServiceDeploymentConfigurationDetails?
        /// Contains the deployment controller type that the service uses.
        public let deploymentController: AwsEcsServiceDeploymentControllerDetails?
        /// The number of instantiations of the task definition to run on the service.
        public let desiredCount: Int?
        /// Whether to enable Amazon ECS managed tags for the tasks in the service.
        public let enableEcsManagedTags: Bool?
        /// Whether the execute command functionality is enabled for the service.
        public let enableExecuteCommand: Bool?
        /// After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.
        public let healthCheckGracePeriodSeconds: Int?
        /// The launch type that the service uses. Valid values: EC2 | FARGATE | EXTERNAL
        public let launchType: String?
        /// Information about the load balancers that the service uses.
        public let loadBalancers: [AwsEcsServiceLoadBalancersDetails]?
        /// The name of the service.
        public let name: String?
        /// For tasks that use the awsvpc networking mode, the VPC subnet and security group configuration.
        public let networkConfiguration: AwsEcsServiceNetworkConfigurationDetails?
        /// The placement constraints for the tasks in the service.
        public let placementConstraints: [AwsEcsServicePlacementConstraintsDetails]?
        /// Information about how tasks for the service are placed.
        public let placementStrategies: [AwsEcsServicePlacementStrategiesDetails]?
        /// The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the LATEST platform version is used by default.
        public let platformVersion: String?
        /// Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated. Valid values: TASK_DEFINITION | SERVICE
        public let propagateTags: String?
        /// The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.
        public let role: String?
        /// The scheduling strategy to use for the service. The REPLICA scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions. The DAEMON scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints. Valid values: REPLICA | DAEMON
        public let schedulingStrategy: String?
        /// The ARN of the service.
        public let serviceArn: String?
        /// The name of the service. The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.
        public let serviceName: String?
        /// Information about the service discovery registries to assign to the service.
        public let serviceRegistries: [AwsEcsServiceServiceRegistriesDetails]?
        /// The task definition to use for tasks in the service.
        public let taskDefinition: String?

        public init(capacityProviderStrategy: [AwsEcsServiceCapacityProviderStrategyDetails]? = nil, cluster: String? = nil, deploymentConfiguration: AwsEcsServiceDeploymentConfigurationDetails? = nil, deploymentController: AwsEcsServiceDeploymentControllerDetails? = nil, desiredCount: Int? = nil, enableEcsManagedTags: Bool? = nil, enableExecuteCommand: Bool? = nil, healthCheckGracePeriodSeconds: Int? = nil, launchType: String? = nil, loadBalancers: [AwsEcsServiceLoadBalancersDetails]? = nil, name: String? = nil, networkConfiguration: AwsEcsServiceNetworkConfigurationDetails? = nil, placementConstraints: [AwsEcsServicePlacementConstraintsDetails]? = nil, placementStrategies: [AwsEcsServicePlacementStrategiesDetails]? = nil, platformVersion: String? = nil, propagateTags: String? = nil, role: String? = nil, schedulingStrategy: String? = nil, serviceArn: String? = nil, serviceName: String? = nil, serviceRegistries: [AwsEcsServiceServiceRegistriesDetails]? = nil, taskDefinition: String? = nil) {
            self.capacityProviderStrategy = capacityProviderStrategy
            self.cluster = cluster
            self.deploymentConfiguration = deploymentConfiguration
            self.deploymentController = deploymentController
            self.desiredCount = desiredCount
            self.enableEcsManagedTags = enableEcsManagedTags
            self.enableExecuteCommand = enableExecuteCommand
            self.healthCheckGracePeriodSeconds = healthCheckGracePeriodSeconds
            self.launchType = launchType
            self.loadBalancers = loadBalancers
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.placementConstraints = placementConstraints
            self.placementStrategies = placementStrategies
            self.platformVersion = platformVersion
            self.propagateTags = propagateTags
            self.role = role
            self.schedulingStrategy = schedulingStrategy
            self.serviceArn = serviceArn
            self.serviceName = serviceName
            self.serviceRegistries = serviceRegistries
            self.taskDefinition = taskDefinition
        }

        public func validate(name: String) throws {
            try self.capacityProviderStrategy?.forEach {
                try $0.validate(name: "\(name).capacityProviderStrategy[]")
            }
            try self.validate(self.cluster, name: "cluster", parent: name, pattern: "\\S")
            try self.deploymentController?.validate(name: "\(name).deploymentController")
            try self.validate(self.launchType, name: "launchType", parent: name, pattern: "\\S")
            try self.loadBalancers?.forEach {
                try $0.validate(name: "\(name).loadBalancers[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.networkConfiguration?.validate(name: "\(name).networkConfiguration")
            try self.placementConstraints?.forEach {
                try $0.validate(name: "\(name).placementConstraints[]")
            }
            try self.placementStrategies?.forEach {
                try $0.validate(name: "\(name).placementStrategies[]")
            }
            try self.validate(self.platformVersion, name: "platformVersion", parent: name, pattern: "\\S")
            try self.validate(self.propagateTags, name: "propagateTags", parent: name, pattern: "\\S")
            try self.validate(self.role, name: "role", parent: name, pattern: "\\S")
            try self.validate(self.schedulingStrategy, name: "schedulingStrategy", parent: name, pattern: "\\S")
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "\\S")
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "\\S")
            try self.serviceRegistries?.forEach {
                try $0.validate(name: "\(name).serviceRegistries[]")
            }
            try self.validate(self.taskDefinition, name: "taskDefinition", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityProviderStrategy = "CapacityProviderStrategy"
            case cluster = "Cluster"
            case deploymentConfiguration = "DeploymentConfiguration"
            case deploymentController = "DeploymentController"
            case desiredCount = "DesiredCount"
            case enableEcsManagedTags = "EnableEcsManagedTags"
            case enableExecuteCommand = "EnableExecuteCommand"
            case healthCheckGracePeriodSeconds = "HealthCheckGracePeriodSeconds"
            case launchType = "LaunchType"
            case loadBalancers = "LoadBalancers"
            case name = "Name"
            case networkConfiguration = "NetworkConfiguration"
            case placementConstraints = "PlacementConstraints"
            case placementStrategies = "PlacementStrategies"
            case platformVersion = "PlatformVersion"
            case propagateTags = "PropagateTags"
            case role = "Role"
            case schedulingStrategy = "SchedulingStrategy"
            case serviceArn = "ServiceArn"
            case serviceName = "ServiceName"
            case serviceRegistries = "ServiceRegistries"
            case taskDefinition = "TaskDefinition"
        }
    }

    public struct AwsEcsServiceLoadBalancersDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the container to associate with the load balancer.
        public let containerName: String?
        /// The port on the container to associate with the load balancer. This port must correspond to a containerPort in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the hostPort of the port mapping.
        public let containerPort: Int?
        /// The name of the load balancer to associate with the Amazon ECS service or task set. Only specified when using a Classic Load Balancer. For an Application Load Balancer or a Network Load Balancer, the load balancer name is omitted.
        public let loadBalancerName: String?
        /// The ARN of the Elastic Load Balancing target group or groups associated with a service or task set. Only specified when using an Application Load Balancer or a Network Load Balancer. For a Classic Load Balancer, the target group ARN is omitted.
        public let targetGroupArn: String?

        public init(containerName: String? = nil, containerPort: Int? = nil, loadBalancerName: String? = nil, targetGroupArn: String? = nil) {
            self.containerName = containerName
            self.containerPort = containerPort
            self.loadBalancerName = loadBalancerName
            self.targetGroupArn = targetGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.containerName, name: "containerName", parent: name, pattern: "\\S")
            try self.validate(self.loadBalancerName, name: "loadBalancerName", parent: name, pattern: "\\S")
            try self.validate(self.targetGroupArn, name: "targetGroupArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
            case containerPort = "ContainerPort"
            case loadBalancerName = "LoadBalancerName"
            case targetGroupArn = "TargetGroupArn"
        }
    }

    public struct AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the task's elastic network interface receives a public IP address. The default value is DISABLED. Valid values: ENABLED | DISABLED
        public let assignPublicIp: String?
        /// The IDs of the security groups associated with the task or service. You can provide up to five security groups.
        public let securityGroups: [String]?
        /// The IDs of the subnets associated with the task or service. You can provide up to 16 subnets.
        public let subnets: [String]?

        public init(assignPublicIp: String? = nil, securityGroups: [String]? = nil, subnets: [String]? = nil) {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }

        public func validate(name: String) throws {
            try self.validate(self.assignPublicIp, name: "assignPublicIp", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.subnets?.forEach {
                try validate($0, name: "subnets[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assignPublicIp = "AssignPublicIp"
            case securityGroups = "SecurityGroups"
            case subnets = "Subnets"
        }
    }

    public struct AwsEcsServiceNetworkConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The VPC subnet and security group configuration.
        public let awsVpcConfiguration: AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails?

        public init(awsVpcConfiguration: AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails? = nil) {
            self.awsVpcConfiguration = awsVpcConfiguration
        }

        public func validate(name: String) throws {
            try self.awsVpcConfiguration?.validate(name: "\(name).awsVpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case awsVpcConfiguration = "AwsVpcConfiguration"
        }
    }

    public struct AwsEcsServicePlacementConstraintsDetails: AWSEncodableShape & AWSDecodableShape {
        /// A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance.
        public let expression: String?
        /// The type of constraint. Use distinctInstance to run each task in a particular group on a different container instance. Use memberOf to restrict the selection to a group of valid candidates. Valid values: distinctInstance | memberOf
        public let type: String?

        public init(expression: String? = nil, type: String? = nil) {
            self.expression = expression
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case type = "Type"
        }
    }

    public struct AwsEcsServicePlacementStrategiesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this attribute is not used.
        public let field: String?
        /// The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the value of Field. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified in Field. Valid values: random | spread | binpack
        public let type: String?

        public init(field: String? = nil, type: String? = nil) {
            self.field = field
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.field, name: "field", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case field = "Field"
            case type = "Type"
        }
    }

    public struct AwsEcsServiceServiceRegistriesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The container name value to use for the service discovery service. If the task definition uses the bridge or host network mode, you must specify ContainerName and ContainerPort. If the task definition uses the awsvpc network mode and a type SRV DNS record, you must specify either ContainerName and ContainerPort, or Port , but not both.
        public let containerName: String?
        /// The port value to use for the service discovery service. If the task definition uses the bridge or host network mode, you must specify ContainerName and ContainerPort. If the task definition uses the awsvpc network mode and a type SRV DNS record, you must specify either ContainerName and ContainerPort, or Port , but not both.
        public let containerPort: Int?
        /// The port value to use for a service discovery service that specifies an SRV record. This field can be used if both the awsvpcawsvpc network mode and SRV records are used.
        public let port: Int?
        /// The ARN of the service registry.
        public let registryArn: String?

        public init(containerName: String? = nil, containerPort: Int? = nil, port: Int? = nil, registryArn: String? = nil) {
            self.containerName = containerName
            self.containerPort = containerPort
            self.port = port
            self.registryArn = registryArn
        }

        public func validate(name: String) throws {
            try self.validate(self.containerName, name: "containerName", parent: name, pattern: "\\S")
            try self.validate(self.registryArn, name: "registryArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
            case containerPort = "ContainerPort"
            case port = "Port"
            case registryArn = "RegistryArn"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails: AWSEncodableShape & AWSDecodableShape {
        /// The dependency condition of the dependent container. Indicates the required status of the dependent container before the current container can start. Valid values are as follows:    COMPLETE     HEALTHY     SUCCESS     START
        public let condition: String?
        /// The name of the dependent container.
        public let containerName: String?

        public init(condition: String? = nil, containerName: String? = nil) {
            self.condition = condition
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try self.validate(self.condition, name: "condition", parent: name, pattern: "\\S")
            try self.validate(self.containerName, name: "containerName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case containerName = "ContainerName"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The command that is passed to the container.
        public let command: [String]?
        /// The number of CPU units reserved for the container.
        public let cpu: Int?
        /// The dependencies that are defined for container startup and shutdown.
        public let dependsOn: [AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails]?
        /// Whether to disable networking within the container.
        public let disableNetworking: Bool?
        /// A list of DNS search domains that are presented to the container.
        public let dnsSearchDomains: [String]?
        /// A list of DNS servers that are presented to the container.
        public let dnsServers: [String]?
        /// A key-value map of labels to add to the container.
        public let dockerLabels: [String: String]?
        /// A list of strings to provide custom labels for SELinux and AppArmor multi-level security systems.
        public let dockerSecurityOptions: [String]?
        /// The entry point that is passed to the container.
        public let entryPoint: [String]?
        /// The environment variables to pass to a container.
        public let environment: [AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails]?
        /// A list of files containing the environment variables to pass to a container.
        public let environmentFiles: [AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails]?
        /// Whether the container is essential. All tasks must have at least one essential container.
        public let essential: Bool?
        /// A list of hostnames and IP address mappings to append to the /etc/hosts file on the container.
        public let extraHosts: [AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails]?
        /// The FireLens configuration for the container. Specifies and configures a log router for container logs.
        public let firelensConfiguration: AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails?
        /// The container health check command and associated configuration parameters for the container.
        public let healthCheck: AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails?
        /// The hostname to use for the container.
        public let hostname: String?
        /// The image used to start the container.
        public let image: String?
        /// If set to true, then containerized applications can be deployed that require stdin or a tty to be allocated.
        public let interactive: Bool?
        /// A list of links for the container in the form  container_name:alias . Allows containers to communicate with each other without the need for port mappings.
        public let links: [String]?
        /// Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.
        public let linuxParameters: AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails?
        /// The log configuration specification for the container.
        public let logConfiguration: AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails?
        /// The amount (in MiB) of memory to present to the container. If the container attempts to exceed the memory specified here, the container is shut down. The total amount of memory reserved for all containers within a task must be lower than the task memory value, if one is specified.
        public let memory: Int?
        /// The soft limit (in MiB) of memory to reserve for the container.
        public let memoryReservation: Int?
        /// The mount points for the data volumes in the container.
        public let mountPoints: [AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails]?
        /// The name of the container.
        public let name: String?
        /// The list of port mappings for the container.
        public let portMappings: [AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails]?
        /// Whether the container is given elevated privileges on the host container instance. The elevated privileges are similar to the root user.
        public let privileged: Bool?
        /// Whether to allocate a TTY to the container.
        public let pseudoTerminal: Bool?
        /// Whether the container is given read-only access to its root file system.
        public let readonlyRootFilesystem: Bool?
        /// The private repository authentication credentials to use.
        public let repositoryCredentials: AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails?
        /// The type and amount of a resource to assign to a container. The only supported resource is a GPU.
        public let resourceRequirements: [AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails]?
        /// The secrets to pass to the container.
        public let secrets: [AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]?
        /// The number of seconds to wait before giving up on resolving dependencies for a container.
        public let startTimeout: Int?
        /// The number of seconds to wait before the container is stopped if it doesn't shut down normally on its own.
        public let stopTimeout: Int?
        /// A list of namespaced kernel parameters to set in the container.
        public let systemControls: [AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails]?
        /// A list of ulimits to set in the container.
        public let ulimits: [AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]?
        /// The user to use inside the container. The value can use one of the following formats.     user       user : group       uid       uid : gid       user : gid       uid : group
        public let user: String?
        /// Data volumes to mount from another container.
        public let volumesFrom: [AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails]?
        /// The working directory in which to run commands inside the container.
        public let workingDirectory: String?

        public init(command: [String]? = nil, cpu: Int? = nil, dependsOn: [AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails]? = nil, disableNetworking: Bool? = nil, dnsSearchDomains: [String]? = nil, dnsServers: [String]? = nil, dockerLabels: [String: String]? = nil, dockerSecurityOptions: [String]? = nil, entryPoint: [String]? = nil, environment: [AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails]? = nil, environmentFiles: [AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails]? = nil, essential: Bool? = nil, extraHosts: [AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails]? = nil, firelensConfiguration: AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails? = nil, healthCheck: AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails? = nil, hostname: String? = nil, image: String? = nil, interactive: Bool? = nil, links: [String]? = nil, linuxParameters: AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails? = nil, logConfiguration: AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails? = nil, memory: Int? = nil, memoryReservation: Int? = nil, mountPoints: [AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails]? = nil, name: String? = nil, portMappings: [AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails]? = nil, privileged: Bool? = nil, pseudoTerminal: Bool? = nil, readonlyRootFilesystem: Bool? = nil, repositoryCredentials: AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails? = nil, resourceRequirements: [AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails]? = nil, secrets: [AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]? = nil, startTimeout: Int? = nil, stopTimeout: Int? = nil, systemControls: [AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails]? = nil, ulimits: [AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]? = nil, user: String? = nil, volumesFrom: [AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails]? = nil, workingDirectory: String? = nil) {
            self.command = command
            self.cpu = cpu
            self.dependsOn = dependsOn
            self.disableNetworking = disableNetworking
            self.dnsSearchDomains = dnsSearchDomains
            self.dnsServers = dnsServers
            self.dockerLabels = dockerLabels
            self.dockerSecurityOptions = dockerSecurityOptions
            self.entryPoint = entryPoint
            self.environment = environment
            self.environmentFiles = environmentFiles
            self.essential = essential
            self.extraHosts = extraHosts
            self.firelensConfiguration = firelensConfiguration
            self.healthCheck = healthCheck
            self.hostname = hostname
            self.image = image
            self.interactive = interactive
            self.links = links
            self.linuxParameters = linuxParameters
            self.logConfiguration = logConfiguration
            self.memory = memory
            self.memoryReservation = memoryReservation
            self.mountPoints = mountPoints
            self.name = name
            self.portMappings = portMappings
            self.privileged = privileged
            self.pseudoTerminal = pseudoTerminal
            self.readonlyRootFilesystem = readonlyRootFilesystem
            self.repositoryCredentials = repositoryCredentials
            self.resourceRequirements = resourceRequirements
            self.secrets = secrets
            self.startTimeout = startTimeout
            self.stopTimeout = stopTimeout
            self.systemControls = systemControls
            self.ulimits = ulimits
            self.user = user
            self.volumesFrom = volumesFrom
            self.workingDirectory = workingDirectory
        }

        public func validate(name: String) throws {
            try self.command?.forEach {
                try validate($0, name: "command[]", parent: name, pattern: "\\S")
            }
            try self.dependsOn?.forEach {
                try $0.validate(name: "\(name).dependsOn[]")
            }
            try self.dnsSearchDomains?.forEach {
                try validate($0, name: "dnsSearchDomains[]", parent: name, pattern: "\\S")
            }
            try self.dnsServers?.forEach {
                try validate($0, name: "dnsServers[]", parent: name, pattern: "\\S")
            }
            try self.dockerLabels?.forEach {
                try validate($0.key, name: "dockerLabels.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "dockerLabels[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.dockerSecurityOptions?.forEach {
                try validate($0, name: "dockerSecurityOptions[]", parent: name, pattern: "\\S")
            }
            try self.entryPoint?.forEach {
                try validate($0, name: "entryPoint[]", parent: name, pattern: "\\S")
            }
            try self.environment?.forEach {
                try $0.validate(name: "\(name).environment[]")
            }
            try self.environmentFiles?.forEach {
                try $0.validate(name: "\(name).environmentFiles[]")
            }
            try self.extraHosts?.forEach {
                try $0.validate(name: "\(name).extraHosts[]")
            }
            try self.firelensConfiguration?.validate(name: "\(name).firelensConfiguration")
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.validate(self.hostname, name: "hostname", parent: name, pattern: "\\S")
            try self.validate(self.image, name: "image", parent: name, pattern: "\\S")
            try self.links?.forEach {
                try validate($0, name: "links[]", parent: name, pattern: "\\S")
            }
            try self.linuxParameters?.validate(name: "\(name).linuxParameters")
            try self.logConfiguration?.validate(name: "\(name).logConfiguration")
            try self.mountPoints?.forEach {
                try $0.validate(name: "\(name).mountPoints[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.portMappings?.forEach {
                try $0.validate(name: "\(name).portMappings[]")
            }
            try self.repositoryCredentials?.validate(name: "\(name).repositoryCredentials")
            try self.resourceRequirements?.forEach {
                try $0.validate(name: "\(name).resourceRequirements[]")
            }
            try self.secrets?.forEach {
                try $0.validate(name: "\(name).secrets[]")
            }
            try self.systemControls?.forEach {
                try $0.validate(name: "\(name).systemControls[]")
            }
            try self.ulimits?.forEach {
                try $0.validate(name: "\(name).ulimits[]")
            }
            try self.validate(self.user, name: "user", parent: name, pattern: "\\S")
            try self.volumesFrom?.forEach {
                try $0.validate(name: "\(name).volumesFrom[]")
            }
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case cpu = "Cpu"
            case dependsOn = "DependsOn"
            case disableNetworking = "DisableNetworking"
            case dnsSearchDomains = "DnsSearchDomains"
            case dnsServers = "DnsServers"
            case dockerLabels = "DockerLabels"
            case dockerSecurityOptions = "DockerSecurityOptions"
            case entryPoint = "EntryPoint"
            case environment = "Environment"
            case environmentFiles = "EnvironmentFiles"
            case essential = "Essential"
            case extraHosts = "ExtraHosts"
            case firelensConfiguration = "FirelensConfiguration"
            case healthCheck = "HealthCheck"
            case hostname = "Hostname"
            case image = "Image"
            case interactive = "Interactive"
            case links = "Links"
            case linuxParameters = "LinuxParameters"
            case logConfiguration = "LogConfiguration"
            case memory = "Memory"
            case memoryReservation = "MemoryReservation"
            case mountPoints = "MountPoints"
            case name = "Name"
            case portMappings = "PortMappings"
            case privileged = "Privileged"
            case pseudoTerminal = "PseudoTerminal"
            case readonlyRootFilesystem = "ReadonlyRootFilesystem"
            case repositoryCredentials = "RepositoryCredentials"
            case resourceRequirements = "ResourceRequirements"
            case secrets = "Secrets"
            case startTimeout = "StartTimeout"
            case stopTimeout = "StopTimeout"
            case systemControls = "SystemControls"
            case ulimits = "Ulimits"
            case user = "User"
            case volumesFrom = "VolumesFrom"
            case workingDirectory = "WorkingDirectory"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the environment variable.
        public let name: String?
        /// The value of the environment variable.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The type of environment file. The valid value is s3.
        public let type: String?
        /// The ARN of the S3 object that contains the environment variable file.
        public let value: String?

        public init(type: String? = nil, value: String? = nil) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The hostname to use in the /etc/hosts entry.
        public let hostname: String?
        /// The IP address to use in the /etc/hosts entry.
        public let ipAddress: String?

        public init(hostname: String? = nil, ipAddress: String? = nil) {
            self.hostname = hostname
            self.ipAddress = ipAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.hostname, name: "hostname", parent: name, pattern: "\\S")
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "Hostname"
            case ipAddress = "IpAddress"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The options to use to configure the log router. The valid option keys are as follows:    enable-ecs-log-metadata. The value can be true or false.    config-file-type. The value can be s3 or file.    config-file-value. The value is either an S3 ARN or a file path.
        public let options: [String: String]?
        /// The log router to use. Valid values are fluentbit or fluentd.
        public let type: String?

        public init(options: [String: String]? = nil, type: String? = nil) {
            self.options = options
            self.type = type
        }

        public func validate(name: String) throws {
            try self.options?.forEach {
                try validate($0.key, name: "options.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "options[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case type = "Type"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails: AWSEncodableShape & AWSDecodableShape {
        /// The command that the container runs to determine whether it is healthy.
        public let command: [String]?
        /// The time period in seconds between each health check execution. The default value is 30 seconds.
        public let interval: Int?
        /// The number of times to retry a failed health check before the container is considered unhealthy. The default value is 3.
        public let retries: Int?
        /// The optional grace period in seconds that allows containers time to bootstrap before failed health checks count towards the maximum number of retries.
        public let startPeriod: Int?
        /// The time period in seconds to wait for a health check to succeed before it is considered a failure. The default value is 5.
        public let timeout: Int?

        public init(command: [String]? = nil, interval: Int? = nil, retries: Int? = nil, startPeriod: Int? = nil, timeout: Int? = nil) {
            self.command = command
            self.interval = interval
            self.retries = retries
            self.startPeriod = startPeriod
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.command?.forEach {
                try validate($0, name: "command[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case interval = "Interval"
            case retries = "Retries"
            case startPeriod = "StartPeriod"
            case timeout = "Timeout"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Linux capabilities for the container that are added to the default configuration provided by Docker. Valid values are as follows: Valid values: "ALL" | "AUDIT_CONTROL" | "AUDIT_WRITE" | 		"BLOCK_SUSPEND" | "CHOWN" | "DAC_OVERRIDE" | 		"DAC_READ_SEARCH" | "FOWNER" | "FSETID" | 		"IPC_LOCK" | "IPC_OWNER" | "KILL" | 		"LEASE" | "LINUX_IMMUTABLE" | "MAC_ADMIN" | 			"MAC_OVERRIDE" | "MKNOD" | "NET_ADMIN" | 		"NET_BIND_SERVICE" | "NET_BROADCAST" | "NET_RAW" | 		"SETFCAP" | "SETGID" | "SETPCAP" | 		"SETUID" | "SYS_ADMIN" | "SYS_BOOT" | 		"SYS_CHROOT" | "SYS_MODULE" | "SYS_NICE" | 		"SYS_PACCT" | "SYS_PTRACE" | "SYS_RAWIO" | 		"SYS_RESOURCE" | "SYS_TIME" | "SYS_TTY_CONFIG" | 		"SYSLOG" | "WAKE_ALARM"
        public let add: [String]?
        /// The Linux capabilities for the container that are dropped from the default configuration provided by Docker. Valid values: "ALL" | "AUDIT_CONTROL" | "AUDIT_WRITE" | 		"BLOCK_SUSPEND" | "CHOWN" | "DAC_OVERRIDE" | 		"DAC_READ_SEARCH" | "FOWNER" | "FSETID" | 		"IPC_LOCK" | "IPC_OWNER" | "KILL" | 		"LEASE" | "LINUX_IMMUTABLE" | "MAC_ADMIN" | 			"MAC_OVERRIDE" | "MKNOD" | "NET_ADMIN" | 		"NET_BIND_SERVICE" | "NET_BROADCAST" | "NET_RAW" | 		"SETFCAP" | "SETGID" | "SETPCAP" | 		"SETUID" | "SYS_ADMIN" | "SYS_BOOT" | 		"SYS_CHROOT" | "SYS_MODULE" | "SYS_NICE" | 		"SYS_PACCT" | "SYS_PTRACE" | "SYS_RAWIO" | 		"SYS_RESOURCE" | "SYS_TIME" | "SYS_TTY_CONFIG" | 		"SYSLOG" | "WAKE_ALARM"
        public let drop: [String]?

        public init(add: [String]? = nil, drop: [String]? = nil) {
            self.add = add
            self.drop = drop
        }

        public func validate(name: String) throws {
            try self.add?.forEach {
                try validate($0, name: "add[]", parent: name, pattern: "\\S")
            }
            try self.drop?.forEach {
                try validate($0, name: "drop[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case add = "Add"
            case drop = "Drop"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.
        public let capabilities: AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails?
        /// The host devices to expose to the container.
        public let devices: [AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails]?
        /// Whether to run an init process inside the container that forwards signals and reaps processes.
        public let initProcessEnabled: Bool?
        /// The total amount of swap memory (in MiB) that a container can use.
        public let maxSwap: Int?
        /// The value for the size (in MiB) of the /dev/shm volume.
        public let sharedMemorySize: Int?
        /// Configures the container's memory swappiness behavior. Determines how aggressively pages are swapped. The higher the value, the more aggressive the swappiness. The default is 60.
        public let swappiness: Int?
        /// The container path, mount options, and size (in MiB) of the tmpfs mount.
        public let tmpfs: [AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails]?

        public init(capabilities: AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails? = nil, devices: [AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails]? = nil, initProcessEnabled: Bool? = nil, maxSwap: Int? = nil, sharedMemorySize: Int? = nil, swappiness: Int? = nil, tmpfs: [AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails]? = nil) {
            self.capabilities = capabilities
            self.devices = devices
            self.initProcessEnabled = initProcessEnabled
            self.maxSwap = maxSwap
            self.sharedMemorySize = sharedMemorySize
            self.swappiness = swappiness
            self.tmpfs = tmpfs
        }

        public func validate(name: String) throws {
            try self.capabilities?.validate(name: "\(name).capabilities")
            try self.devices?.forEach {
                try $0.validate(name: "\(name).devices[]")
            }
            try self.tmpfs?.forEach {
                try $0.validate(name: "\(name).tmpfs[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case devices = "Devices"
            case initProcessEnabled = "InitProcessEnabled"
            case maxSwap = "MaxSwap"
            case sharedMemorySize = "SharedMemorySize"
            case swappiness = "Swappiness"
            case tmpfs = "Tmpfs"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The path inside the container at which to expose the host device.
        public let containerPath: String?
        /// The path for the device on the host container instance.
        public let hostPath: String?
        /// The explicit permissions to provide to the container for the device. By default, the container has permissions for read, write, and mknod for the device.
        public let permissions: [String]?

        public init(containerPath: String? = nil, hostPath: String? = nil, permissions: [String]? = nil) {
            self.containerPath = containerPath
            self.hostPath = hostPath
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.validate(self.containerPath, name: "containerPath", parent: name, pattern: "\\S")
            try self.validate(self.hostPath, name: "hostPath", parent: name, pattern: "\\S")
            try self.permissions?.forEach {
                try validate($0, name: "permissions[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case containerPath = "ContainerPath"
            case hostPath = "HostPath"
            case permissions = "Permissions"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The absolute file path where the tmpfs volume is to be mounted.
        public let containerPath: String?
        /// The list of tmpfs volume mount options. Valid values: "defaults" | "ro" | "rw" | "suid" | 		"nosuid" | "dev" | "nodev" | "exec" | 		"noexec" | "sync" | "async" | "dirsync" 		| "remount" | "mand" | "nomand" | "atime" 		| "noatime" | "diratime" | "nodiratime" | 		"bind" | "rbind" | "unbindable" | 		"runbindable" | "private" | "rprivate" | 		"shared" | "rshared" | "slave" | 		"rslave" | "relatime" | "norelatime" | 		"strictatime" | "nostrictatime" | "mode" | 		"uid" | "gid" | "nr_inodes" | 			"nr_blocks" | "mpol"
        public let mountOptions: [String]?
        /// The maximum size (in MiB) of the tmpfs volume.
        public let size: Int?

        public init(containerPath: String? = nil, mountOptions: [String]? = nil, size: Int? = nil) {
            self.containerPath = containerPath
            self.mountOptions = mountOptions
            self.size = size
        }

        public func validate(name: String) throws {
            try self.validate(self.containerPath, name: "containerPath", parent: name, pattern: "\\S")
            try self.mountOptions?.forEach {
                try validate($0, name: "mountOptions[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case containerPath = "ContainerPath"
            case mountOptions = "MountOptions"
            case size = "Size"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The log driver to use for the container. Valid values on Fargate are as follows:    awsfirelens     awslogs     splunk    Valid values on Amazon EC2 are as follows:    awsfirelens     awslogs     fluentd     gelf     journald     json-file     logentries     splunk     syslog
        public let logDriver: String?
        /// The configuration options to send to the log driver. Requires version 1.19 of the Docker Remote API or greater on your container instance.
        public let options: [String: String]?
        /// The secrets to pass to the log configuration.
        public let secretOptions: [AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]?

        public init(logDriver: String? = nil, options: [String: String]? = nil, secretOptions: [AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]? = nil) {
            self.logDriver = logDriver
            self.options = options
            self.secretOptions = secretOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.logDriver, name: "logDriver", parent: name, pattern: "\\S")
            try self.options?.forEach {
                try validate($0.key, name: "options.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "options[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.secretOptions?.forEach {
                try $0.validate(name: "\(name).secretOptions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case logDriver = "LogDriver"
            case options = "Options"
            case secretOptions = "SecretOptions"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the secret.
        public let name: String?
        /// The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.
        public let valueFrom: String?

        public init(name: String? = nil, valueFrom: String? = nil) {
            self.name = name
            self.valueFrom = valueFrom
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.valueFrom, name: "valueFrom", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case valueFrom = "ValueFrom"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The path on the container to mount the host volume at.
        public let containerPath: String?
        /// Whether the container has read-only access to the volume.
        public let readOnly: Bool?
        /// The name of the volume to mount. Must match the name of a volume listed in VolumeDetails for the task definition.
        public let sourceVolume: String?

        public init(containerPath: String? = nil, readOnly: Bool? = nil, sourceVolume: String? = nil) {
            self.containerPath = containerPath
            self.readOnly = readOnly
            self.sourceVolume = sourceVolume
        }

        public func validate(name: String) throws {
            try self.validate(self.containerPath, name: "containerPath", parent: name, pattern: "\\S")
            try self.validate(self.sourceVolume, name: "sourceVolume", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerPath = "ContainerPath"
            case readOnly = "ReadOnly"
            case sourceVolume = "SourceVolume"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The port number on the container that is bound to the user-specified or automatically assigned host port.
        public let containerPort: Int?
        /// The port number on the container instance to reserve for the container.
        public let hostPort: Int?
        /// The protocol used for the port mapping. The default is tcp.
        public let `protocol`: String?

        public init(containerPort: Int? = nil, hostPort: Int? = nil, protocol: String? = nil) {
            self.containerPort = containerPort
            self.hostPort = hostPort
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerPort = "ContainerPort"
            case hostPort = "HostPort"
            case `protocol` = "Protocol"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the secret that contains the private repository credentials.
        public let credentialsParameter: String?

        public init(credentialsParameter: String? = nil) {
            self.credentialsParameter = credentialsParameter
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsParameter, name: "credentialsParameter", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialsParameter = "CredentialsParameter"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The type of resource to assign to a container. Valid values are GPU or InferenceAccelerator.
        public let type: String?
        /// The value for the specified resource type. For GPU, the value is the number of physical GPUs the Amazon ECS container agent reserves for the container. For InferenceAccelerator, the value should match the DeviceName attribute of an entry in InferenceAccelerators.
        public let value: String?

        public init(type: String? = nil, value: String? = nil) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the secret.
        public let name: String?
        /// The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.
        public let valueFrom: String?

        public init(name: String? = nil, valueFrom: String? = nil) {
            self.name = name
            self.valueFrom = valueFrom
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.valueFrom, name: "valueFrom", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case valueFrom = "ValueFrom"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The namespaced kernel parameter for which to set a value.
        public let namespace: String?
        /// The value of the parameter.
        public let value: String?

        public init(namespace: String? = nil, value: String? = nil) {
            self.namespace = namespace
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "Namespace"
            case value = "Value"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The hard limit for the ulimit type.
        public let hardLimit: Int?
        /// The type of the ulimit. Valid values are as follows:    core     cpu     data     fsize     locks     memlock     msgqueue     nice     nofile     nproc     rss     rtprio     rttime     sigpending     stack
        public let name: String?
        /// The soft limit for the ulimit type.
        public let softLimit: Int?

        public init(hardLimit: Int? = nil, name: String? = nil, softLimit: Int? = nil) {
            self.hardLimit = hardLimit
            self.name = name
            self.softLimit = softLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hardLimit = "HardLimit"
            case name = "Name"
            case softLimit = "SoftLimit"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the container has read-only access to the volume.
        public let readOnly: Bool?
        /// The name of another container within the same task definition from which to mount volumes.
        public let sourceContainer: String?

        public init(readOnly: Bool? = nil, sourceContainer: String? = nil) {
            self.readOnly = readOnly
            self.sourceContainer = sourceContainer
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceContainer, name: "sourceContainer", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case readOnly = "ReadOnly"
            case sourceContainer = "SourceContainer"
        }
    }

    public struct AwsEcsTaskDefinitionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The container definitions that describe the containers that make up the task.
        public let containerDefinitions: [AwsEcsTaskDefinitionContainerDefinitionsDetails]?
        /// The number of CPU units used by the task.Valid values are as follows:    256 (.25 vCPU)     512 (.5 vCPU)     1024 (1 vCPU)     2048 (2 vCPU)     4096 (4 vCPU)
        public let cpu: String?
        /// The ARN of the task execution role that grants the container agent permission to make API calls on behalf of the container user.
        public let executionRoleArn: String?
        /// The name of a family that this task definition is registered to.
        public let family: String?
        /// The Elastic Inference accelerators to use for the containers in the task.
        public let inferenceAccelerators: [AwsEcsTaskDefinitionInferenceAcceleratorsDetails]?
        /// The inter-process communication (IPC) resource namespace to use for the containers in the task. Valid values are as follows:    host     none     task
        public let ipcMode: String?
        /// The amount (in MiB) of memory used by the task.  For tasks that are hosted on Amazon EC2, you can provide a task-level memory value or a container-level memory value. For tasks that are hosted on Fargate, you must use one of the specified values in the  Amazon Elastic Container Service Developer Guide , which determines your range of supported values for the Cpu and Memory parameters.
        public let memory: String?
        /// The Docker networking mode to use for the containers in the task. Valid values are as follows:    awsvpc     bridge     host     none
        public let networkMode: String?
        /// The process namespace to use for the containers in the task. Valid values are host or task.
        public let pidMode: String?
        /// The placement constraint objects to use for tasks.
        public let placementConstraints: [AwsEcsTaskDefinitionPlacementConstraintsDetails]?
        /// The configuration details for the App Mesh proxy.
        public let proxyConfiguration: AwsEcsTaskDefinitionProxyConfigurationDetails?
        /// The task launch types that the task definition was validated against.
        public let requiresCompatibilities: [String]?
        /// The short name or ARN of the IAM role that grants containers in the task permission to call Amazon Web Services API operations on your behalf.
        public let taskRoleArn: String?
        /// The data volume definitions for the task.
        public let volumes: [AwsEcsTaskDefinitionVolumesDetails]?

        public init(containerDefinitions: [AwsEcsTaskDefinitionContainerDefinitionsDetails]? = nil, cpu: String? = nil, executionRoleArn: String? = nil, family: String? = nil, inferenceAccelerators: [AwsEcsTaskDefinitionInferenceAcceleratorsDetails]? = nil, ipcMode: String? = nil, memory: String? = nil, networkMode: String? = nil, pidMode: String? = nil, placementConstraints: [AwsEcsTaskDefinitionPlacementConstraintsDetails]? = nil, proxyConfiguration: AwsEcsTaskDefinitionProxyConfigurationDetails? = nil, requiresCompatibilities: [String]? = nil, taskRoleArn: String? = nil, volumes: [AwsEcsTaskDefinitionVolumesDetails]? = nil) {
            self.containerDefinitions = containerDefinitions
            self.cpu = cpu
            self.executionRoleArn = executionRoleArn
            self.family = family
            self.inferenceAccelerators = inferenceAccelerators
            self.ipcMode = ipcMode
            self.memory = memory
            self.networkMode = networkMode
            self.pidMode = pidMode
            self.placementConstraints = placementConstraints
            self.proxyConfiguration = proxyConfiguration
            self.requiresCompatibilities = requiresCompatibilities
            self.taskRoleArn = taskRoleArn
            self.volumes = volumes
        }

        public func validate(name: String) throws {
            try self.containerDefinitions?.forEach {
                try $0.validate(name: "\(name).containerDefinitions[]")
            }
            try self.validate(self.cpu, name: "cpu", parent: name, pattern: "\\S")
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.family, name: "family", parent: name, pattern: "\\S")
            try self.inferenceAccelerators?.forEach {
                try $0.validate(name: "\(name).inferenceAccelerators[]")
            }
            try self.validate(self.ipcMode, name: "ipcMode", parent: name, pattern: "\\S")
            try self.validate(self.memory, name: "memory", parent: name, pattern: "\\S")
            try self.validate(self.networkMode, name: "networkMode", parent: name, pattern: "\\S")
            try self.validate(self.pidMode, name: "pidMode", parent: name, pattern: "\\S")
            try self.placementConstraints?.forEach {
                try $0.validate(name: "\(name).placementConstraints[]")
            }
            try self.proxyConfiguration?.validate(name: "\(name).proxyConfiguration")
            try self.requiresCompatibilities?.forEach {
                try validate($0, name: "requiresCompatibilities[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.taskRoleArn, name: "taskRoleArn", parent: name, pattern: "\\S")
            try self.volumes?.forEach {
                try $0.validate(name: "\(name).volumes[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case containerDefinitions = "ContainerDefinitions"
            case cpu = "Cpu"
            case executionRoleArn = "ExecutionRoleArn"
            case family = "Family"
            case inferenceAccelerators = "InferenceAccelerators"
            case ipcMode = "IpcMode"
            case memory = "Memory"
            case networkMode = "NetworkMode"
            case pidMode = "PidMode"
            case placementConstraints = "PlacementConstraints"
            case proxyConfiguration = "ProxyConfiguration"
            case requiresCompatibilities = "RequiresCompatibilities"
            case taskRoleArn = "TaskRoleArn"
            case volumes = "Volumes"
        }
    }

    public struct AwsEcsTaskDefinitionInferenceAcceleratorsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Elastic Inference accelerator device name.
        public let deviceName: String?
        /// The Elastic Inference accelerator type to use.
        public let deviceType: String?

        public init(deviceName: String? = nil, deviceType: String? = nil) {
            self.deviceName = deviceName
            self.deviceType = deviceType
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "\\S")
            try self.validate(self.deviceType, name: "deviceType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "DeviceName"
            case deviceType = "DeviceType"
        }
    }

    public struct AwsEcsTaskDefinitionPlacementConstraintsDetails: AWSEncodableShape & AWSDecodableShape {
        /// A cluster query language expression to apply to the constraint.
        public let expression: String?
        /// The type of constraint.
        public let type: String?

        public init(expression: String? = nil, type: String? = nil) {
            self.expression = expression
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case type = "Type"
        }
    }

    public struct AwsEcsTaskDefinitionProxyConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the container that will serve as the App Mesh proxy.
        public let containerName: String?
        /// The set of network configuration parameters to provide to the Container Network Interface (CNI) plugin, specified as key-value pairs.
        public let proxyConfigurationProperties: [AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]?
        /// The proxy type.
        public let type: String?

        public init(containerName: String? = nil, proxyConfigurationProperties: [AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]? = nil, type: String? = nil) {
            self.containerName = containerName
            self.proxyConfigurationProperties = proxyConfigurationProperties
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.containerName, name: "containerName", parent: name, pattern: "\\S")
            try self.proxyConfigurationProperties?.forEach {
                try $0.validate(name: "\(name).proxyConfigurationProperties[]")
            }
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
            case proxyConfigurationProperties = "ProxyConfigurationProperties"
            case type = "Type"
        }
    }

    public struct AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the property.
        public let name: String?
        /// The value of the property.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsEcsTaskDefinitionVolumesDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about a Docker volume.
        public let dockerVolumeConfiguration: AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails?
        /// Information about the Amazon Elastic File System file system that is used for task storage.
        public let efsVolumeConfiguration: AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails?
        /// Information about a bind mount host volume.
        public let host: AwsEcsTaskDefinitionVolumesHostDetails?
        /// The name of the data volume.
        public let name: String?

        public init(dockerVolumeConfiguration: AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails? = nil, efsVolumeConfiguration: AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails? = nil, host: AwsEcsTaskDefinitionVolumesHostDetails? = nil, name: String? = nil) {
            self.dockerVolumeConfiguration = dockerVolumeConfiguration
            self.efsVolumeConfiguration = efsVolumeConfiguration
            self.host = host
            self.name = name
        }

        public func validate(name: String) throws {
            try self.dockerVolumeConfiguration?.validate(name: "\(name).dockerVolumeConfiguration")
            try self.efsVolumeConfiguration?.validate(name: "\(name).efsVolumeConfiguration")
            try self.host?.validate(name: "\(name).host")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dockerVolumeConfiguration = "DockerVolumeConfiguration"
            case efsVolumeConfiguration = "EfsVolumeConfiguration"
            case host = "Host"
            case name = "Name"
        }
    }

    public struct AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to create the Docker volume automatically if it does not already exist.
        public let autoprovision: Bool?
        /// The Docker volume driver to use.
        public let driver: String?
        /// A map of Docker driver-specific options that are passed through.
        public let driverOpts: [String: String]?
        /// Custom metadata to add to the Docker volume.
        public let labels: [String: String]?
        /// The scope for the Docker volume that determines its lifecycle. Docker volumes that are scoped to a task are provisioned
        /// automatically when the task starts and destroyed when the task stops. Docker volumes that are shared persist after the task stops. Valid values are shared or task.
        public let scope: String?

        public init(autoprovision: Bool? = nil, driver: String? = nil, driverOpts: [String: String]? = nil, labels: [String: String]? = nil, scope: String? = nil) {
            self.autoprovision = autoprovision
            self.driver = driver
            self.driverOpts = driverOpts
            self.labels = labels
            self.scope = scope
        }

        public func validate(name: String) throws {
            try self.validate(self.driver, name: "driver", parent: name, pattern: "\\S")
            try self.driverOpts?.forEach {
                try validate($0.key, name: "driverOpts.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "driverOpts[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.labels?.forEach {
                try validate($0.key, name: "labels.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "labels[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.scope, name: "scope", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case autoprovision = "Autoprovision"
            case driver = "Driver"
            case driverOpts = "DriverOpts"
            case labels = "Labels"
            case scope = "Scope"
        }
    }

    public struct AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon EFS access point identifier to use.
        public let accessPointId: String?
        /// Whether to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system.
        public let iam: String?

        public init(accessPointId: String? = nil, iam: String? = nil) {
            self.accessPointId = accessPointId
            self.iam = iam
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPointId, name: "accessPointId", parent: name, pattern: "\\S")
            try self.validate(self.iam, name: "iam", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointId = "AccessPointId"
            case iam = "Iam"
        }
    }

    public struct AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The authorization configuration details for the Amazon EFS file system.
        public let authorizationConfig: AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails?
        /// The Amazon EFS file system identifier to use.
        public let filesystemId: String?
        /// The directory within the Amazon EFS file system to mount as the root directory inside the host.
        public let rootDirectory: String?
        /// Whether to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server.
        public let transitEncryption: String?
        /// The port to use when sending encrypted data between the Amazon ECS host and the Amazon EFS server.
        public let transitEncryptionPort: Int?

        public init(authorizationConfig: AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails? = nil, filesystemId: String? = nil, rootDirectory: String? = nil, transitEncryption: String? = nil, transitEncryptionPort: Int? = nil) {
            self.authorizationConfig = authorizationConfig
            self.filesystemId = filesystemId
            self.rootDirectory = rootDirectory
            self.transitEncryption = transitEncryption
            self.transitEncryptionPort = transitEncryptionPort
        }

        public func validate(name: String) throws {
            try self.authorizationConfig?.validate(name: "\(name).authorizationConfig")
            try self.validate(self.filesystemId, name: "filesystemId", parent: name, pattern: "\\S")
            try self.validate(self.rootDirectory, name: "rootDirectory", parent: name, pattern: "\\S")
            try self.validate(self.transitEncryption, name: "transitEncryption", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationConfig = "AuthorizationConfig"
            case filesystemId = "FilesystemId"
            case rootDirectory = "RootDirectory"
            case transitEncryption = "TransitEncryption"
            case transitEncryptionPort = "TransitEncryptionPort"
        }
    }

    public struct AwsEcsTaskDefinitionVolumesHostDetails: AWSEncodableShape & AWSDecodableShape {
        /// The path on the host container instance that is presented to the container.
        public let sourcePath: String?

        public init(sourcePath: String? = nil) {
            self.sourcePath = sourcePath
        }

        public func validate(name: String) throws {
            try self.validate(self.sourcePath, name: "sourcePath", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case sourcePath = "SourcePath"
        }
    }

    public struct AwsEcsTaskDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster that hosts the task.
        public let clusterArn: String?
        /// The containers that are associated with the task.
        public let containers: [AwsEcsContainerDetails]?
        /// The Unix timestamp for the time when the task was created. More specifically, it's for the time when
        /// the task entered the PENDING state.
        public let createdAt: String?
        /// The name of the task group that's associated with the task.
        public let group: String?
        /// The Unix timestamp for the time when the task started. More specifically, it's for the time when the  task transitioned from the PENDING state to the RUNNING state.
        public let startedAt: String?
        /// The tag specified when a task is started. If an Amazon ECS service started the task, the  startedBy parameter contains the deployment ID of that service.
        public let startedBy: String?
        /// The ARN of the task definition that creates the task.
        public let taskDefinitionArn: String?
        /// The version counter for the task.
        public let version: String?
        /// Details about the data volume that is used in a task definition.
        public let volumes: [AwsEcsTaskVolumeDetails]?

        public init(clusterArn: String? = nil, containers: [AwsEcsContainerDetails]? = nil, createdAt: String? = nil, group: String? = nil, startedAt: String? = nil, startedBy: String? = nil, taskDefinitionArn: String? = nil, version: String? = nil, volumes: [AwsEcsTaskVolumeDetails]? = nil) {
            self.clusterArn = clusterArn
            self.containers = containers
            self.createdAt = createdAt
            self.group = group
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.taskDefinitionArn = taskDefinitionArn
            self.version = version
            self.volumes = volumes
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterArn, name: "clusterArn", parent: name, pattern: "\\S")
            try self.containers?.forEach {
                try $0.validate(name: "\(name).containers[]")
            }
            try self.validate(self.createdAt, name: "createdAt", parent: name, pattern: "\\S")
            try self.validate(self.group, name: "group", parent: name, pattern: "\\S")
            try self.validate(self.startedAt, name: "startedAt", parent: name, pattern: "\\S")
            try self.validate(self.startedBy, name: "startedBy", parent: name, pattern: "\\S")
            try self.validate(self.taskDefinitionArn, name: "taskDefinitionArn", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
            try self.volumes?.forEach {
                try $0.validate(name: "\(name).volumes[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "ClusterArn"
            case containers = "Containers"
            case createdAt = "CreatedAt"
            case group = "Group"
            case startedAt = "StartedAt"
            case startedBy = "StartedBy"
            case taskDefinitionArn = "TaskDefinitionArn"
            case version = "Version"
            case volumes = "Volumes"
        }
    }

    public struct AwsEcsTaskVolumeDetails: AWSEncodableShape & AWSDecodableShape {
        /// This parameter is specified when you use bind mount host volumes. The contents of the host parameter
        /// determine whether your bind mount host volume persists on the host container instance and where it's stored.
        public let host: AwsEcsTaskVolumeHostDetails?
        /// The name of the volume. Up to 255 letters (uppercase and lowercase), numbers, underscores, and
        /// hyphens are allowed. This name is referenced in the sourceVolume parameter of container definition mountPoints.
        public let name: String?

        public init(host: AwsEcsTaskVolumeHostDetails? = nil, name: String? = nil) {
            self.host = host
            self.name = name
        }

        public func validate(name: String) throws {
            try self.host?.validate(name: "\(name).host")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case host = "Host"
            case name = "Name"
        }
    }

    public struct AwsEcsTaskVolumeHostDetails: AWSEncodableShape & AWSDecodableShape {
        /// When the host parameter is used, specify a sourcePath to declare the path
        /// on the host container instance that's presented to the container.
        public let sourcePath: String?

        public init(sourcePath: String? = nil) {
            self.sourcePath = sourcePath
        }

        public func validate(name: String) throws {
            try self.validate(self.sourcePath, name: "sourcePath", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case sourcePath = "SourcePath"
        }
    }

    public struct AwsEfsAccessPointDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the Amazon EFS access point.
        public let accessPointId: String?
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point.
        public let arn: String?
        /// The opaque string specified in the request to ensure idempotent creation.
        public let clientToken: String?
        /// The ID of the Amazon EFS file system that the access point applies to.
        public let fileSystemId: String?
        /// The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point,
        /// that is used for all file operations by NFS clients using the access point.
        public let posixUser: AwsEfsAccessPointPosixUserDetails?
        /// The directory on the Amazon EFS file system that the access point exposes as the root
        /// directory to NFS clients using the access point.
        public let rootDirectory: AwsEfsAccessPointRootDirectoryDetails?

        public init(accessPointId: String? = nil, arn: String? = nil, clientToken: String? = nil, fileSystemId: String? = nil, posixUser: AwsEfsAccessPointPosixUserDetails? = nil, rootDirectory: AwsEfsAccessPointRootDirectoryDetails? = nil) {
            self.accessPointId = accessPointId
            self.arn = arn
            self.clientToken = clientToken
            self.fileSystemId = fileSystemId
            self.posixUser = posixUser
            self.rootDirectory = rootDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPointId, name: "accessPointId", parent: name, pattern: "\\S")
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "\\S")
            try self.posixUser?.validate(name: "\(name).posixUser")
            try self.rootDirectory?.validate(name: "\(name).rootDirectory")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointId = "AccessPointId"
            case arn = "Arn"
            case clientToken = "ClientToken"
            case fileSystemId = "FileSystemId"
            case posixUser = "PosixUser"
            case rootDirectory = "RootDirectory"
        }
    }

    public struct AwsEfsAccessPointPosixUserDetails: AWSEncodableShape & AWSDecodableShape {
        /// The POSIX group ID used for all file system operations using this access point.
        public let gid: String?
        /// Secondary POSIX group IDs used for all file system operations using this access point.
        public let secondaryGids: [String]?
        /// The POSIX user ID used for all file system operations using this access point.
        public let uid: String?

        public init(gid: String? = nil, secondaryGids: [String]? = nil, uid: String? = nil) {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }

        public func validate(name: String) throws {
            try self.validate(self.gid, name: "gid", parent: name, pattern: "\\S")
            try self.secondaryGids?.forEach {
                try validate($0, name: "secondaryGids[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.uid, name: "uid", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case gid = "Gid"
            case secondaryGids = "SecondaryGids"
            case uid = "Uid"
        }
    }

    public struct AwsEfsAccessPointRootDirectoryCreationInfoDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the POSIX group ID to apply to the root directory.
        public let ownerGid: String?
        /// Specifies the POSIX user ID to apply to the root directory.
        public let ownerUid: String?
        /// Specifies the POSIX permissions to apply to the root directory, in the format of an octal number
        /// representing the file's mode bits.
        public let permissions: String?

        public init(ownerGid: String? = nil, ownerUid: String? = nil, permissions: String? = nil) {
            self.ownerGid = ownerGid
            self.ownerUid = ownerUid
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.validate(self.ownerGid, name: "ownerGid", parent: name, pattern: "\\S")
            try self.validate(self.ownerUid, name: "ownerUid", parent: name, pattern: "\\S")
            try self.validate(self.permissions, name: "permissions", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ownerGid = "OwnerGid"
            case ownerUid = "OwnerUid"
            case permissions = "Permissions"
        }
    }

    public struct AwsEfsAccessPointRootDirectoryDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the POSIX IDs and permissions to apply to the access point's root directory.
        public let creationInfo: AwsEfsAccessPointRootDirectoryCreationInfoDetails?
        /// Specifies the path on the Amazon EFS file system to expose as the root directory to NFS clients
        /// using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified
        /// path does not exist, you are required to provide CreationInfo.
        public let path: String?

        public init(creationInfo: AwsEfsAccessPointRootDirectoryCreationInfoDetails? = nil, path: String? = nil) {
            self.creationInfo = creationInfo
            self.path = path
        }

        public func validate(name: String) throws {
            try self.creationInfo?.validate(name: "\(name).creationInfo")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case creationInfo = "CreationInfo"
            case path = "Path"
        }
    }

    public struct AwsEksClusterDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the cluster.
        public let arn: String?
        /// The certificate authority data for the cluster.
        public let certificateAuthorityData: String?
        /// The status of the cluster. Valid values are as follows:    ACTIVE     CREATING     DELETING     FAILED     PENDING     UPDATING
        public let clusterStatus: String?
        /// The endpoint for the Amazon EKS API server.
        public let endpoint: String?
        /// The logging configuration for the cluster.
        public let logging: AwsEksClusterLoggingDetails?
        /// The name of the cluster.
        public let name: String?
        /// The VPC configuration used by the cluster control plane.
        public let resourcesVpcConfig: AwsEksClusterResourcesVpcConfigDetails?
        /// The ARN of the IAM role that provides permissions for the Amazon EKS control plane to make calls to Amazon Web Services API operations on your behalf.
        public let roleArn: String?
        /// The Amazon EKS server version for the cluster.
        public let version: String?

        public init(arn: String? = nil, certificateAuthorityData: String? = nil, clusterStatus: String? = nil, endpoint: String? = nil, logging: AwsEksClusterLoggingDetails? = nil, name: String? = nil, resourcesVpcConfig: AwsEksClusterResourcesVpcConfigDetails? = nil, roleArn: String? = nil, version: String? = nil) {
            self.arn = arn
            self.certificateAuthorityData = certificateAuthorityData
            self.clusterStatus = clusterStatus
            self.endpoint = endpoint
            self.logging = logging
            self.name = name
            self.resourcesVpcConfig = resourcesVpcConfig
            self.roleArn = roleArn
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.certificateAuthorityData, name: "certificateAuthorityData", parent: name, pattern: "\\S")
            try self.validate(self.clusterStatus, name: "clusterStatus", parent: name, pattern: "\\S")
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "\\S")
            try self.logging?.validate(name: "\(name).logging")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.resourcesVpcConfig?.validate(name: "\(name).resourcesVpcConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case certificateAuthorityData = "CertificateAuthorityData"
            case clusterStatus = "ClusterStatus"
            case endpoint = "Endpoint"
            case logging = "Logging"
            case name = "Name"
            case resourcesVpcConfig = "ResourcesVpcConfig"
            case roleArn = "RoleArn"
            case version = "Version"
        }
    }

    public struct AwsEksClusterLoggingClusterLoggingDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the logging types that are listed in Types are enabled.
        public let enabled: Bool?
        /// A list of logging types. Valid values are as follows:    api     audit     authenticator     controllerManager     scheduler
        public let types: [String]?

        public init(enabled: Bool? = nil, types: [String]? = nil) {
            self.enabled = enabled
            self.types = types
        }

        public func validate(name: String) throws {
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case types = "Types"
        }
    }

    public struct AwsEksClusterLoggingDetails: AWSEncodableShape & AWSDecodableShape {
        /// Cluster logging configurations.
        public let clusterLogging: [AwsEksClusterLoggingClusterLoggingDetails]?

        public init(clusterLogging: [AwsEksClusterLoggingClusterLoggingDetails]? = nil) {
            self.clusterLogging = clusterLogging
        }

        public func validate(name: String) throws {
            try self.clusterLogging?.forEach {
                try $0.validate(name: "\(name).clusterLogging[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clusterLogging = "ClusterLogging"
        }
    }

    public struct AwsEksClusterResourcesVpcConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The security groups that are associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Amazon EKS control plane.
        public let securityGroupIds: [String]?
        /// The subnets that are associated with the cluster.
        public let subnetIds: [String]?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "\\S")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct AwsElasticBeanstalkEnvironmentDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the application that is associated with the environment.
        public let applicationName: String?
        /// The URL to the CNAME for this environment.
        public let cname: String?
        /// The creation date for this environment.
        public let dateCreated: String?
        /// The date when this environment was last modified.
        public let dateUpdated: String?
        /// A description of the environment.
        public let description: String?
        /// For load-balanced, autoscaling environments, the URL to the load balancer. For single-instance environments, the IP address of the instance.
        public let endpointUrl: String?
        /// The ARN of the environment.
        public let environmentArn: String?
        /// The identifier of the environment.
        public let environmentId: String?
        /// Links to other environments in the same group.
        public let environmentLinks: [AwsElasticBeanstalkEnvironmentEnvironmentLink]?
        /// The name of the environment.
        public let environmentName: String?
        /// The configuration setting for the environment.
        public let optionSettings: [AwsElasticBeanstalkEnvironmentOptionSetting]?
        /// The ARN of the platform version for the environment.
        public let platformArn: String?
        /// The name of the solution stack that is deployed with the environment.
        public let solutionStackName: String?
        /// The current operational status of the environment. Valid values are as follows:    Aborting     Launching     LinkingFrom     LinkingTo     Ready     Terminated     Terminating     Updating
        public let status: String?
        /// The tier of the environment.
        public let tier: AwsElasticBeanstalkEnvironmentTier?
        /// The application version of the environment.
        public let versionLabel: String?

        public init(applicationName: String? = nil, cname: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, endpointUrl: String? = nil, environmentArn: String? = nil, environmentId: String? = nil, environmentLinks: [AwsElasticBeanstalkEnvironmentEnvironmentLink]? = nil, environmentName: String? = nil, optionSettings: [AwsElasticBeanstalkEnvironmentOptionSetting]? = nil, platformArn: String? = nil, solutionStackName: String? = nil, status: String? = nil, tier: AwsElasticBeanstalkEnvironmentTier? = nil, versionLabel: String? = nil) {
            self.applicationName = applicationName
            self.cname = cname
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.endpointUrl = endpointUrl
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentLinks = environmentLinks
            self.environmentName = environmentName
            self.optionSettings = optionSettings
            self.platformArn = platformArn
            self.solutionStackName = solutionStackName
            self.status = status
            self.tier = tier
            self.versionLabel = versionLabel
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "\\S")
            try self.validate(self.cname, name: "cname", parent: name, pattern: "\\S")
            try self.validate(self.dateCreated, name: "dateCreated", parent: name, pattern: "\\S")
            try self.validate(self.dateUpdated, name: "dateUpdated", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.endpointUrl, name: "endpointUrl", parent: name, pattern: "\\S")
            try self.validate(self.environmentArn, name: "environmentArn", parent: name, pattern: "\\S")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.environmentLinks?.forEach {
                try $0.validate(name: "\(name).environmentLinks[]")
            }
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "\\S")
            try self.optionSettings?.forEach {
                try $0.validate(name: "\(name).optionSettings[]")
            }
            try self.validate(self.platformArn, name: "platformArn", parent: name, pattern: "\\S")
            try self.validate(self.solutionStackName, name: "solutionStackName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.tier?.validate(name: "\(name).tier")
            try self.validate(self.versionLabel, name: "versionLabel", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case cname = "Cname"
            case dateCreated = "DateCreated"
            case dateUpdated = "DateUpdated"
            case description = "Description"
            case endpointUrl = "EndpointUrl"
            case environmentArn = "EnvironmentArn"
            case environmentId = "EnvironmentId"
            case environmentLinks = "EnvironmentLinks"
            case environmentName = "EnvironmentName"
            case optionSettings = "OptionSettings"
            case platformArn = "PlatformArn"
            case solutionStackName = "SolutionStackName"
            case status = "Status"
            case tier = "Tier"
            case versionLabel = "VersionLabel"
        }
    }

    public struct AwsElasticBeanstalkEnvironmentEnvironmentLink: AWSEncodableShape & AWSDecodableShape {
        /// The name of the linked environment.
        public let environmentName: String?
        /// The name of the environment link.
        public let linkName: String?

        public init(environmentName: String? = nil, linkName: String? = nil) {
            self.environmentName = environmentName
            self.linkName = linkName
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "\\S")
            try self.validate(self.linkName, name: "linkName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case environmentName = "EnvironmentName"
            case linkName = "LinkName"
        }
    }

    public struct AwsElasticBeanstalkEnvironmentOptionSetting: AWSEncodableShape & AWSDecodableShape {
        /// The type of resource that the configuration option is associated with.
        public let namespace: String?
        /// The name of the option.
        public let optionName: String?
        /// The name of the resource.
        public let resourceName: String?
        /// The value of the configuration setting.
        public let value: String?

        public init(namespace: String? = nil, optionName: String? = nil, resourceName: String? = nil, value: String? = nil) {
            self.namespace = namespace
            self.optionName = optionName
            self.resourceName = resourceName
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "\\S")
            try self.validate(self.optionName, name: "optionName", parent: name, pattern: "\\S")
            try self.validate(self.resourceName, name: "resourceName", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "Namespace"
            case optionName = "OptionName"
            case resourceName = "ResourceName"
            case value = "Value"
        }
    }

    public struct AwsElasticBeanstalkEnvironmentTier: AWSEncodableShape & AWSDecodableShape {
        /// The name of the environment tier. Valid values are WebServer or Worker.
        public let name: String?
        /// The type of environment tier. Valid values are Standard or SQS/HTTP.
        public let type: String?
        /// The version of the environment tier.
        public let version: String?

        public init(name: String? = nil, type: String? = nil, version: String? = nil) {
            self.name = name
            self.type = type
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
            case version = "Version"
        }
    }

    public struct AwsElasticsearchDomainDetails: AWSEncodableShape & AWSDecodableShape {
        /// IAM policy document specifying the access policies for the new Elasticsearch domain.
        public let accessPolicies: String?
        /// Additional options for the domain endpoint.
        public let domainEndpointOptions: AwsElasticsearchDomainDomainEndpointOptions?
        /// Unique identifier for an Elasticsearch domain.
        public let domainId: String?
        /// Name of an Elasticsearch domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region. Domain names must start with a lowercase letter and must be between 3 and 28 characters. Valid characters are a-z (lowercase only), 0-9, and  (hyphen).
        public let domainName: String?
        /// Information about an OpenSearch cluster configuration.
        public let elasticsearchClusterConfig: AwsElasticsearchDomainElasticsearchClusterConfigDetails?
        /// OpenSearch version.
        public let elasticsearchVersion: String?
        /// Details about the configuration for encryption at rest.
        public let encryptionAtRestOptions: AwsElasticsearchDomainEncryptionAtRestOptions?
        /// Domain-specific endpoint used to submit index, search, and data upload requests to an Elasticsearch domain. The endpoint is a service URL.
        public let endpoint: String?
        /// The key-value pair that exists if the Elasticsearch domain uses VPC endpoints.
        public let endpoints: [String: String]?
        /// Configures the CloudWatch Logs to publish for the Elasticsearch domain.
        public let logPublishingOptions: AwsElasticsearchDomainLogPublishingOptions?
        /// Details about the configuration for node-to-node encryption.
        public let nodeToNodeEncryptionOptions: AwsElasticsearchDomainNodeToNodeEncryptionOptions?
        /// Information about the status of a domain relative to the latest service software.
        public let serviceSoftwareOptions: AwsElasticsearchDomainServiceSoftwareOptions?
        /// Information that OpenSearch derives based on VPCOptions for the domain.
        public let vpcOptions: AwsElasticsearchDomainVPCOptions?

        public init(accessPolicies: String? = nil, domainEndpointOptions: AwsElasticsearchDomainDomainEndpointOptions? = nil, domainId: String? = nil, domainName: String? = nil, elasticsearchClusterConfig: AwsElasticsearchDomainElasticsearchClusterConfigDetails? = nil, elasticsearchVersion: String? = nil, encryptionAtRestOptions: AwsElasticsearchDomainEncryptionAtRestOptions? = nil, endpoint: String? = nil, endpoints: [String: String]? = nil, logPublishingOptions: AwsElasticsearchDomainLogPublishingOptions? = nil, nodeToNodeEncryptionOptions: AwsElasticsearchDomainNodeToNodeEncryptionOptions? = nil, serviceSoftwareOptions: AwsElasticsearchDomainServiceSoftwareOptions? = nil, vpcOptions: AwsElasticsearchDomainVPCOptions? = nil) {
            self.accessPolicies = accessPolicies
            self.domainEndpointOptions = domainEndpointOptions
            self.domainId = domainId
            self.domainName = domainName
            self.elasticsearchClusterConfig = elasticsearchClusterConfig
            self.elasticsearchVersion = elasticsearchVersion
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.endpoint = endpoint
            self.endpoints = endpoints
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.vpcOptions = vpcOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, pattern: "\\S")
            try self.domainEndpointOptions?.validate(name: "\(name).domainEndpointOptions")
            try self.validate(self.domainId, name: "domainId", parent: name, pattern: "\\S")
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.elasticsearchClusterConfig?.validate(name: "\(name).elasticsearchClusterConfig")
            try self.validate(self.elasticsearchVersion, name: "elasticsearchVersion", parent: name, pattern: "\\S")
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "\\S")
            try self.endpoints?.forEach {
                try validate($0.key, name: "endpoints.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "endpoints[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.logPublishingOptions?.validate(name: "\(name).logPublishingOptions")
            try self.serviceSoftwareOptions?.validate(name: "\(name).serviceSoftwareOptions")
            try self.vpcOptions?.validate(name: "\(name).vpcOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case domainEndpointOptions = "DomainEndpointOptions"
            case domainId = "DomainId"
            case domainName = "DomainName"
            case elasticsearchClusterConfig = "ElasticsearchClusterConfig"
            case elasticsearchVersion = "ElasticsearchVersion"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case endpoint = "Endpoint"
            case endpoints = "Endpoints"
            case logPublishingOptions = "LogPublishingOptions"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case serviceSoftwareOptions = "ServiceSoftwareOptions"
            case vpcOptions = "VPCOptions"
        }
    }

    public struct AwsElasticsearchDomainDomainEndpointOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether to require that all traffic to the domain arrive over HTTPS.
        public let enforceHTTPS: Bool?
        /// The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain. Valid values:    Policy-Min-TLS-1-0-2019-07, which supports TLSv1.0 and higher    Policy-Min-TLS-1-2-2019-07, which only supports TLSv1.2
        public let tlsSecurityPolicy: String?

        public init(enforceHTTPS: Bool? = nil, tlsSecurityPolicy: String? = nil) {
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.tlsSecurityPolicy, name: "tlsSecurityPolicy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case enforceHTTPS = "EnforceHTTPS"
            case tlsSecurityPolicy = "TLSSecurityPolicy"
        }
    }

    public struct AwsElasticsearchDomainElasticsearchClusterConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances to use for the master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public let dedicatedMasterCount: Int?
        /// Whether to use a dedicated master node for the Elasticsearch domain. A dedicated master node performs cluster management tasks, but doesn't hold data or respond to data upload requests.
        public let dedicatedMasterEnabled: Bool?
        /// The hardware configuration of the computer that hosts the dedicated master node. A sample value is m3.medium.elasticsearch. If this attribute is specified, then DedicatedMasterEnabled must be true. For a list of valid values, see Supported instance types in Amazon OpenSearch Service in the Amazon OpenSearch Service Developer Guide.
        public let dedicatedMasterType: String?
        /// The number of data nodes to use in the Elasticsearch domain.
        public let instanceCount: Int?
        /// The instance type for your data nodes. For example, m3.medium.elasticsearch. For a list of valid values, see Supported instance types in Amazon OpenSearch Service in the Amazon OpenSearch Service Developer Guide.
        public let instanceType: String?
        /// Configuration options for zone awareness. Provided if ZoneAwarenessEnabled is true.
        public let zoneAwarenessConfig: AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails?
        /// Whether to enable zone awareness for the Elasticsearch domain. When zone awareness is enabled, OpenSearch allocates the cluster's nodes and replica index shards across Availability Zones in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.
        public let zoneAwarenessEnabled: Bool?

        public init(dedicatedMasterCount: Int? = nil, dedicatedMasterEnabled: Bool? = nil, dedicatedMasterType: String? = nil, instanceCount: Int? = nil, instanceType: String? = nil, zoneAwarenessConfig: AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails? = nil, zoneAwarenessEnabled: Bool? = nil) {
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.dedicatedMasterType, name: "dedicatedMasterType", parent: name, pattern: "\\S")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dedicatedMasterCount = "DedicatedMasterCount"
            case dedicatedMasterEnabled = "DedicatedMasterEnabled"
            case dedicatedMasterType = "DedicatedMasterType"
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case zoneAwarenessConfig = "ZoneAwarenessConfig"
            case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
        }
    }

    public struct AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// he number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.
        public let availabilityZoneCount: Int?

        public init(availabilityZoneCount: Int? = nil) {
            self.availabilityZoneCount = availabilityZoneCount
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneCount = "AvailabilityZoneCount"
        }
    }

    public struct AwsElasticsearchDomainEncryptionAtRestOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether encryption at rest is enabled.
        public let enabled: Bool?
        /// The KMS key ID. Takes the form 1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a.
        public let kmsKeyId: String?

        public init(enabled: Bool? = nil, kmsKeyId: String? = nil) {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct AwsElasticsearchDomainLogPublishingOptions: AWSEncodableShape & AWSDecodableShape {
        public let auditLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig?
        /// Configures the OpenSearch index logs publishing.
        public let indexSlowLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig?
        /// Configures the OpenSearch search slow log publishing.
        public let searchSlowLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig?

        public init(auditLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil, indexSlowLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil, searchSlowLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil) {
            self.auditLogs = auditLogs
            self.indexSlowLogs = indexSlowLogs
            self.searchSlowLogs = searchSlowLogs
        }

        public func validate(name: String) throws {
            try self.auditLogs?.validate(name: "\(name).auditLogs")
            try self.indexSlowLogs?.validate(name: "\(name).indexSlowLogs")
            try self.searchSlowLogs?.validate(name: "\(name).searchSlowLogs")
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs = "AuditLogs"
            case indexSlowLogs = "IndexSlowLogs"
            case searchSlowLogs = "SearchSlowLogs"
        }
    }

    public struct AwsElasticsearchDomainLogPublishingOptionsLogConfig: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the CloudWatch Logs group to publish the logs to.
        public let cloudWatchLogsLogGroupArn: String?
        /// Whether the log publishing is enabled.
        public let enabled: Bool?

        public init(cloudWatchLogsLogGroupArn: String? = nil, enabled: Bool? = nil) {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
            case enabled = "Enabled"
        }
    }

    public struct AwsElasticsearchDomainNodeToNodeEncryptionOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether node-to-node encryption is enabled.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsElasticsearchDomainServiceSoftwareOptions: AWSEncodableShape & AWSDecodableShape {
        /// The epoch time when the deployment window closes for required updates. After this time, Amazon OpenSearch Service schedules the software upgrade automatically.
        public let automatedUpdateDate: String?
        /// Whether a request to update the domain can be canceled.
        public let cancellable: Bool?
        /// The version of the service software that is currently installed on the domain.
        public let currentVersion: String?
        /// A more detailed description of the service software status.
        public let description: String?
        /// The most recent version of the service software.
        public let newVersion: String?
        /// Whether a service software update is available for the domain.
        public let updateAvailable: Bool?
        /// The status of the service software update. Valid values are as follows:    COMPLETED     ELIGIBLE     IN_PROGRESS     NOT_ELIGIBLE     PENDING_UPDATE
        public let updateStatus: String?

        public init(automatedUpdateDate: String? = nil, cancellable: Bool? = nil, currentVersion: String? = nil, description: String? = nil, newVersion: String? = nil, updateAvailable: Bool? = nil, updateStatus: String? = nil) {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.automatedUpdateDate, name: "automatedUpdateDate", parent: name, pattern: "\\S")
            try self.validate(self.currentVersion, name: "currentVersion", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.newVersion, name: "newVersion", parent: name, pattern: "\\S")
            try self.validate(self.updateStatus, name: "updateStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case automatedUpdateDate = "AutomatedUpdateDate"
            case cancellable = "Cancellable"
            case currentVersion = "CurrentVersion"
            case description = "Description"
            case newVersion = "NewVersion"
            case updateAvailable = "UpdateAvailable"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct AwsElasticsearchDomainVPCOptions: AWSEncodableShape & AWSDecodableShape {
        /// The list of Availability Zones associated with the VPC subnets.
        public let availabilityZones: [String]?
        /// The list of security group IDs associated with the VPC endpoints for the domain.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs associated with the VPC endpoints for the domain.
        public let subnetIds: [String]?
        /// ID for the VPC.
        public let vpcId: String?

        public init(availabilityZones: [String]? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "\\S")
            }
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "\\S")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcId = "VPCId"
        }
    }

    public struct AwsElbAppCookieStickinessPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The name of the application cookie used for stickiness.
        public let cookieName: String?
        /// The mnemonic name for the policy being created. The name must be unique within the set of policies for the load balancer.
        public let policyName: String?

        public init(cookieName: String? = nil, policyName: String? = nil) {
            self.cookieName = cookieName
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.cookieName, name: "cookieName", parent: name, pattern: "\\S")
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cookieName = "CookieName"
            case policyName = "PolicyName"
        }
    }

    public struct AwsElbLbCookieStickinessPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The amount of time, in seconds, after which the cookie is considered stale. If an expiration period is not specified, the stickiness session lasts for the duration of the browser session.
        public let cookieExpirationPeriod: Int64?
        /// The name of the policy. The name must be unique within the set of policies for the load balancer.
        public let policyName: String?

        public init(cookieExpirationPeriod: Int64? = nil, policyName: String? = nil) {
            self.cookieExpirationPeriod = cookieExpirationPeriod
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cookieExpirationPeriod = "CookieExpirationPeriod"
            case policyName = "PolicyName"
        }
    }

    public struct AwsElbLoadBalancerAccessLog: AWSEncodableShape & AWSDecodableShape {
        /// The interval in minutes for publishing the access logs. You can publish access logs either every 5 minutes or every 60 minutes.
        public let emitInterval: Int?
        /// Indicates whether access logs are enabled for the load balancer.
        public let enabled: Bool?
        /// The name of the S3 bucket where the access logs are stored.
        public let s3BucketName: String?
        /// The logical hierarchy that was created for the S3 bucket. If a prefix is not provided, the log is placed at the root level of the bucket.
        public let s3BucketPrefix: String?

        public init(emitInterval: Int? = nil, enabled: Bool? = nil, s3BucketName: String? = nil, s3BucketPrefix: String? = nil) {
            self.emitInterval = emitInterval
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.s3BucketPrefix = s3BucketPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "\\S")
            try self.validate(self.s3BucketPrefix, name: "s3BucketPrefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case emitInterval = "EmitInterval"
            case enabled = "Enabled"
            case s3BucketName = "S3BucketName"
            case s3BucketPrefix = "S3BucketPrefix"
        }
    }

    public struct AwsElbLoadBalancerAdditionalAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name of the attribute.
        public let key: String?
        /// The value of the attribute.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct AwsElbLoadBalancerAttributes: AWSEncodableShape & AWSDecodableShape {
        /// Information about the access log configuration for the load balancer. If the access log is enabled, the load balancer captures detailed information about all requests. It delivers the information to a specified S3 bucket.
        public let accessLog: AwsElbLoadBalancerAccessLog?
        /// Any additional attributes for a load balancer.
        public let additionalAttributes: [AwsElbLoadBalancerAdditionalAttribute]?
        /// Information about the connection draining configuration for the load balancer. If connection draining is enabled, the load balancer allows existing requests to complete before it shifts traffic away from a deregistered or unhealthy instance.
        public let connectionDraining: AwsElbLoadBalancerConnectionDraining?
        /// Connection settings for the load balancer. If an idle timeout is configured, the load balancer allows connections to remain idle for the specified duration. When a connection is idle, no data is sent over the connection.
        public let connectionSettings: AwsElbLoadBalancerConnectionSettings?
        /// Cross-zone load balancing settings for the load balancer. If cross-zone load balancing is enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones.
        public let crossZoneLoadBalancing: AwsElbLoadBalancerCrossZoneLoadBalancing?

        public init(accessLog: AwsElbLoadBalancerAccessLog? = nil, additionalAttributes: [AwsElbLoadBalancerAdditionalAttribute]? = nil, connectionDraining: AwsElbLoadBalancerConnectionDraining? = nil, connectionSettings: AwsElbLoadBalancerConnectionSettings? = nil, crossZoneLoadBalancing: AwsElbLoadBalancerCrossZoneLoadBalancing? = nil) {
            self.accessLog = accessLog
            self.additionalAttributes = additionalAttributes
            self.connectionDraining = connectionDraining
            self.connectionSettings = connectionSettings
            self.crossZoneLoadBalancing = crossZoneLoadBalancing
        }

        public func validate(name: String) throws {
            try self.accessLog?.validate(name: "\(name).accessLog")
            try self.additionalAttributes?.forEach {
                try $0.validate(name: "\(name).additionalAttributes[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessLog = "AccessLog"
            case additionalAttributes = "AdditionalAttributes"
            case connectionDraining = "ConnectionDraining"
            case connectionSettings = "ConnectionSettings"
            case crossZoneLoadBalancing = "CrossZoneLoadBalancing"
        }
    }

    public struct AwsElbLoadBalancerBackendServerDescription: AWSEncodableShape & AWSDecodableShape {
        /// The port on which the EC2 instance is listening.
        public let instancePort: Int?
        /// The names of the policies that are enabled for the EC2 instance.
        public let policyNames: [String]?

        public init(instancePort: Int? = nil, policyNames: [String]? = nil) {
            self.instancePort = instancePort
            self.policyNames = policyNames
        }

        public func validate(name: String) throws {
            try self.policyNames?.forEach {
                try validate($0, name: "policyNames[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case instancePort = "InstancePort"
            case policyNames = "PolicyNames"
        }
    }

    public struct AwsElbLoadBalancerConnectionDraining: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether connection draining is enabled for the load balancer.
        public let enabled: Bool?
        /// The maximum time, in seconds, to keep the existing connections open before deregistering the instances.
        public let timeout: Int?

        public init(enabled: Bool? = nil, timeout: Int? = nil) {
            self.enabled = enabled
            self.timeout = timeout
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case timeout = "Timeout"
        }
    }

    public struct AwsElbLoadBalancerConnectionSettings: AWSEncodableShape & AWSDecodableShape {
        /// The time, in seconds, that the connection can be idle (no data is sent over the connection) before it is closed by the load balancer.
        public let idleTimeout: Int?

        public init(idleTimeout: Int? = nil) {
            self.idleTimeout = idleTimeout
        }

        private enum CodingKeys: String, CodingKey {
            case idleTimeout = "IdleTimeout"
        }
    }

    public struct AwsElbLoadBalancerCrossZoneLoadBalancing: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether cross-zone load balancing is enabled for the load balancer.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsElbLoadBalancerDetails: AWSEncodableShape & AWSDecodableShape {
        /// The list of Availability Zones for the load balancer.
        public let availabilityZones: [String]?
        /// Information about the configuration of the EC2 instances.
        public let backendServerDescriptions: [AwsElbLoadBalancerBackendServerDescription]?
        /// The name of the Amazon Route53 hosted zone for the load balancer.
        public let canonicalHostedZoneName: String?
        /// The ID of the Amazon Route53 hosted zone for the load balancer.
        public let canonicalHostedZoneNameID: String?
        /// Indicates when the load balancer was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdTime: String?
        /// The DNS name of the load balancer.
        public let dnsName: String?
        /// Information about the health checks that are conducted on the load balancer.
        public let healthCheck: AwsElbLoadBalancerHealthCheck?
        /// List of EC2 instances for the load balancer.
        public let instances: [AwsElbLoadBalancerInstance]?
        /// The policies that are enabled for the load balancer listeners.
        public let listenerDescriptions: [AwsElbLoadBalancerListenerDescription]?
        /// The attributes for a load balancer.
        public let loadBalancerAttributes: AwsElbLoadBalancerAttributes?
        /// The name of the load balancer.
        public let loadBalancerName: String?
        /// The policies for a load balancer.
        public let policies: AwsElbLoadBalancerPolicies?
        /// The type of load balancer. Only provided if the load balancer is in a VPC. If Scheme is internet-facing, the load balancer has a public DNS name that resolves to a public IP address. If Scheme is internal, the load balancer has a public DNS name that resolves to a private IP address.
        public let scheme: String?
        /// The security groups for the load balancer. Only provided if the load balancer is in a VPC.
        public let securityGroups: [String]?
        /// Information about the security group for the load balancer. This is the security group that is used for inbound rules.
        public let sourceSecurityGroup: AwsElbLoadBalancerSourceSecurityGroup?
        /// The list of subnet identifiers for the load balancer.
        public let subnets: [String]?
        /// The identifier of the VPC for the load balancer.
        public let vpcId: String?

        public init(availabilityZones: [String]? = nil, backendServerDescriptions: [AwsElbLoadBalancerBackendServerDescription]? = nil, canonicalHostedZoneName: String? = nil, canonicalHostedZoneNameID: String? = nil, createdTime: String? = nil, dnsName: String? = nil, healthCheck: AwsElbLoadBalancerHealthCheck? = nil, instances: [AwsElbLoadBalancerInstance]? = nil, listenerDescriptions: [AwsElbLoadBalancerListenerDescription]? = nil, loadBalancerAttributes: AwsElbLoadBalancerAttributes? = nil, loadBalancerName: String? = nil, policies: AwsElbLoadBalancerPolicies? = nil, scheme: String? = nil, securityGroups: [String]? = nil, sourceSecurityGroup: AwsElbLoadBalancerSourceSecurityGroup? = nil, subnets: [String]? = nil, vpcId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.backendServerDescriptions = backendServerDescriptions
            self.canonicalHostedZoneName = canonicalHostedZoneName
            self.canonicalHostedZoneNameID = canonicalHostedZoneNameID
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.healthCheck = healthCheck
            self.instances = instances
            self.listenerDescriptions = listenerDescriptions
            self.loadBalancerAttributes = loadBalancerAttributes
            self.loadBalancerName = loadBalancerName
            self.policies = policies
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.sourceSecurityGroup = sourceSecurityGroup
            self.subnets = subnets
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "\\S")
            }
            try self.backendServerDescriptions?.forEach {
                try $0.validate(name: "\(name).backendServerDescriptions[]")
            }
            try self.validate(self.canonicalHostedZoneName, name: "canonicalHostedZoneName", parent: name, pattern: "\\S")
            try self.validate(self.canonicalHostedZoneNameID, name: "canonicalHostedZoneNameID", parent: name, pattern: "\\S")
            try self.validate(self.createdTime, name: "createdTime", parent: name, pattern: "\\S")
            try self.validate(self.dnsName, name: "dnsName", parent: name, pattern: "\\S")
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.instances?.forEach {
                try $0.validate(name: "\(name).instances[]")
            }
            try self.listenerDescriptions?.forEach {
                try $0.validate(name: "\(name).listenerDescriptions[]")
            }
            try self.loadBalancerAttributes?.validate(name: "\(name).loadBalancerAttributes")
            try self.validate(self.loadBalancerName, name: "loadBalancerName", parent: name, pattern: "\\S")
            try self.policies?.validate(name: "\(name).policies")
            try self.validate(self.scheme, name: "scheme", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.sourceSecurityGroup?.validate(name: "\(name).sourceSecurityGroup")
            try self.subnets?.forEach {
                try validate($0, name: "subnets[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case backendServerDescriptions = "BackendServerDescriptions"
            case canonicalHostedZoneName = "CanonicalHostedZoneName"
            case canonicalHostedZoneNameID = "CanonicalHostedZoneNameID"
            case createdTime = "CreatedTime"
            case dnsName = "DnsName"
            case healthCheck = "HealthCheck"
            case instances = "Instances"
            case listenerDescriptions = "ListenerDescriptions"
            case loadBalancerAttributes = "LoadBalancerAttributes"
            case loadBalancerName = "LoadBalancerName"
            case policies = "Policies"
            case scheme = "Scheme"
            case securityGroups = "SecurityGroups"
            case sourceSecurityGroup = "SourceSecurityGroup"
            case subnets = "Subnets"
            case vpcId = "VpcId"
        }
    }

    public struct AwsElbLoadBalancerHealthCheck: AWSEncodableShape & AWSDecodableShape {
        /// The number of consecutive health check successes required before the instance is moved to the Healthy state.
        public let healthyThreshold: Int?
        /// The approximate interval, in seconds, between health checks of an individual instance.
        public let interval: Int?
        /// The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535. For the HTTP and HTTPS protocols, the target also specifies the ping path. For the TCP protocol, the target is specified as TCP:  . For the SSL protocol, the target is specified as SSL. . For the HTTP and HTTPS protocols, the target is specified as  :/ .
        public let target: String?
        /// The amount of time, in seconds, during which no response means a failed health check.
        public let timeout: Int?
        /// The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.
        public let unhealthyThreshold: Int?

        public init(healthyThreshold: Int? = nil, interval: Int? = nil, target: String? = nil, timeout: Int? = nil, unhealthyThreshold: Int? = nil) {
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.target = target
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try self.validate(self.target, name: "target", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold = "HealthyThreshold"
            case interval = "Interval"
            case target = "Target"
            case timeout = "Timeout"
            case unhealthyThreshold = "UnhealthyThreshold"
        }
    }

    public struct AwsElbLoadBalancerInstance: AWSEncodableShape & AWSDecodableShape {
        /// The instance identifier.
        public let instanceId: String?

        public init(instanceId: String? = nil) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
        }
    }

    public struct AwsElbLoadBalancerListener: AWSEncodableShape & AWSDecodableShape {
        /// The port on which the instance is listening.
        public let instancePort: Int?
        /// The protocol to use to route traffic to instances. Valid values: HTTP | HTTPS | TCP | SSL
        public let instanceProtocol: String?
        /// The port on which the load balancer is listening. On EC2-VPC, you can specify any port from the range 1-65535. On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.
        public let loadBalancerPort: Int?
        /// The load balancer transport protocol to use for routing. Valid values: HTTP | HTTPS | TCP | SSL
        public let `protocol`: String?
        /// The ARN of the server certificate.
        public let sslCertificateId: String?

        public init(instancePort: Int? = nil, instanceProtocol: String? = nil, loadBalancerPort: Int? = nil, protocol: String? = nil, sslCertificateId: String? = nil) {
            self.instancePort = instancePort
            self.instanceProtocol = instanceProtocol
            self.loadBalancerPort = loadBalancerPort
            self.`protocol` = `protocol`
            self.sslCertificateId = sslCertificateId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceProtocol, name: "instanceProtocol", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.validate(self.sslCertificateId, name: "sslCertificateId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case instancePort = "InstancePort"
            case instanceProtocol = "InstanceProtocol"
            case loadBalancerPort = "LoadBalancerPort"
            case `protocol` = "Protocol"
            case sslCertificateId = "SslCertificateId"
        }
    }

    public struct AwsElbLoadBalancerListenerDescription: AWSEncodableShape & AWSDecodableShape {
        /// Information about the listener.
        public let listener: AwsElbLoadBalancerListener?
        /// The policies enabled for the listener.
        public let policyNames: [String]?

        public init(listener: AwsElbLoadBalancerListener? = nil, policyNames: [String]? = nil) {
            self.listener = listener
            self.policyNames = policyNames
        }

        public func validate(name: String) throws {
            try self.listener?.validate(name: "\(name).listener")
            try self.policyNames?.forEach {
                try validate($0, name: "policyNames[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
            case policyNames = "PolicyNames"
        }
    }

    public struct AwsElbLoadBalancerPolicies: AWSEncodableShape & AWSDecodableShape {
        /// The stickiness policies that are created using CreateAppCookieStickinessPolicy.
        public let appCookieStickinessPolicies: [AwsElbAppCookieStickinessPolicy]?
        /// The stickiness policies that are created using CreateLBCookieStickinessPolicy.
        public let lbCookieStickinessPolicies: [AwsElbLbCookieStickinessPolicy]?
        /// The policies other than the stickiness policies.
        public let otherPolicies: [String]?

        public init(appCookieStickinessPolicies: [AwsElbAppCookieStickinessPolicy]? = nil, lbCookieStickinessPolicies: [AwsElbLbCookieStickinessPolicy]? = nil, otherPolicies: [String]? = nil) {
            self.appCookieStickinessPolicies = appCookieStickinessPolicies
            self.lbCookieStickinessPolicies = lbCookieStickinessPolicies
            self.otherPolicies = otherPolicies
        }

        public func validate(name: String) throws {
            try self.appCookieStickinessPolicies?.forEach {
                try $0.validate(name: "\(name).appCookieStickinessPolicies[]")
            }
            try self.lbCookieStickinessPolicies?.forEach {
                try $0.validate(name: "\(name).lbCookieStickinessPolicies[]")
            }
            try self.otherPolicies?.forEach {
                try validate($0, name: "otherPolicies[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case appCookieStickinessPolicies = "AppCookieStickinessPolicies"
            case lbCookieStickinessPolicies = "LbCookieStickinessPolicies"
            case otherPolicies = "OtherPolicies"
        }
    }

    public struct AwsElbLoadBalancerSourceSecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// The name of the security group.
        public let groupName: String?
        /// The owner of the security group.
        public let ownerAlias: String?

        public init(groupName: String? = nil, ownerAlias: String? = nil) {
            self.groupName = groupName
            self.ownerAlias = ownerAlias
        }

        public func validate(name: String) throws {
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.validate(self.ownerAlias, name: "ownerAlias", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case ownerAlias = "OwnerAlias"
        }
    }

    public struct AwsElbv2LoadBalancerAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name of the load balancer attribute.
        public let key: String?
        /// The value of the load balancer attribute.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct AwsElbv2LoadBalancerDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Availability Zones for the load balancer.
        public let availabilityZones: [AvailabilityZone]?
        /// The ID of the Amazon Route 53 hosted zone associated with the load balancer.
        public let canonicalHostedZoneId: String?
        /// Indicates when the load balancer was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdTime: String?
        /// The public DNS name of the load balancer.
        public let dnsName: String?
        /// The type of IP addresses used by the subnets for your load balancer. The possible values are ipv4 (for IPv4 addresses) and dualstack (for IPv4 and IPv6 addresses).
        public let ipAddressType: String?
        /// Attributes of the load balancer.
        public let loadBalancerAttributes: [AwsElbv2LoadBalancerAttribute]?
        /// The nodes of an Internet-facing load balancer have public IP addresses.
        public let scheme: String?
        /// The IDs of the security groups for the load balancer.
        public let securityGroups: [String]?
        /// The state of the load balancer.
        public let state: LoadBalancerState?
        /// The type of load balancer.
        public let type: String?
        /// The ID of the VPC for the load balancer.
        public let vpcId: String?

        public init(availabilityZones: [AvailabilityZone]? = nil, canonicalHostedZoneId: String? = nil, createdTime: String? = nil, dnsName: String? = nil, ipAddressType: String? = nil, loadBalancerAttributes: [AwsElbv2LoadBalancerAttribute]? = nil, scheme: String? = nil, securityGroups: [String]? = nil, state: LoadBalancerState? = nil, type: String? = nil, vpcId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.canonicalHostedZoneId = canonicalHostedZoneId
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.ipAddressType = ipAddressType
            self.loadBalancerAttributes = loadBalancerAttributes
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.state = state
            self.type = type
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try $0.validate(name: "\(name).availabilityZones[]")
            }
            try self.validate(self.canonicalHostedZoneId, name: "canonicalHostedZoneId", parent: name, pattern: "\\S")
            try self.validate(self.createdTime, name: "createdTime", parent: name, pattern: "\\S")
            try self.validate(self.dnsName, name: "dnsName", parent: name, pattern: "\\S")
            try self.validate(self.ipAddressType, name: "ipAddressType", parent: name, pattern: "\\S")
            try self.loadBalancerAttributes?.forEach {
                try $0.validate(name: "\(name).loadBalancerAttributes[]")
            }
            try self.validate(self.scheme, name: "scheme", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.state?.validate(name: "\(name).state")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case canonicalHostedZoneId = "CanonicalHostedZoneId"
            case createdTime = "CreatedTime"
            case dnsName = "DNSName"
            case ipAddressType = "IpAddressType"
            case loadBalancerAttributes = "LoadBalancerAttributes"
            case scheme = "Scheme"
            case securityGroups = "SecurityGroups"
            case state = "State"
            case type = "Type"
            case vpcId = "VpcId"
        }
    }

    public struct AwsIamAccessKeyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the access key.
        public let accessKeyId: String?
        /// The Amazon Web Services account ID of the account for the key.
        public let accountId: String?
        /// Indicates when the IAM access key was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdAt: String?
        /// The ID of the principal associated with an access key.
        public let principalId: String?
        /// The name of the principal.
        public let principalName: String?
        /// The type of principal associated with an access key.
        public let principalType: String?
        /// Information about the session that the key was used for.
        public let sessionContext: AwsIamAccessKeySessionContext?
        /// The status of the IAM access key related to a finding.
        public let status: AwsIamAccessKeyStatus?
        /// The user associated with the IAM access key related to a finding. The UserName parameter has been replaced with the PrincipalName parameter because access keys can also be assigned to principals that are not IAM users.
        public let userName: String?

        public init(accessKeyId: String? = nil, accountId: String? = nil, createdAt: String? = nil, principalId: String? = nil, principalName: String? = nil, principalType: String? = nil, sessionContext: AwsIamAccessKeySessionContext? = nil, status: AwsIamAccessKeyStatus? = nil) {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.createdAt = createdAt
            self.principalId = principalId
            self.principalName = principalName
            self.principalType = principalType
            self.sessionContext = sessionContext
            self.status = status
            self.userName = nil
        }

        @available(*, deprecated, message: "Members userName have been deprecated")
        public init(accessKeyId: String? = nil, accountId: String? = nil, createdAt: String? = nil, principalId: String? = nil, principalName: String? = nil, principalType: String? = nil, sessionContext: AwsIamAccessKeySessionContext? = nil, status: AwsIamAccessKeyStatus? = nil, userName: String? = nil) {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.createdAt = createdAt
            self.principalId = principalId
            self.principalName = principalName
            self.principalType = principalType
            self.sessionContext = sessionContext
            self.status = status
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.accessKeyId, name: "accessKeyId", parent: name, pattern: "\\S")
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\S")
            try self.validate(self.createdAt, name: "createdAt", parent: name, pattern: "\\S")
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "\\S")
            try self.validate(self.principalName, name: "principalName", parent: name, pattern: "\\S")
            try self.validate(self.principalType, name: "principalType", parent: name, pattern: "\\S")
            try self.sessionContext?.validate(name: "\(name).sessionContext")
            try self.validate(self.userName, name: "userName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "AccessKeyId"
            case accountId = "AccountId"
            case createdAt = "CreatedAt"
            case principalId = "PrincipalId"
            case principalName = "PrincipalName"
            case principalType = "PrincipalType"
            case sessionContext = "SessionContext"
            case status = "Status"
            case userName = "UserName"
        }
    }

    public struct AwsIamAccessKeySessionContext: AWSEncodableShape & AWSDecodableShape {
        /// Attributes of the session that the key was used for.
        public let attributes: AwsIamAccessKeySessionContextAttributes?
        /// Information about the entity that created the session.
        public let sessionIssuer: AwsIamAccessKeySessionContextSessionIssuer?

        public init(attributes: AwsIamAccessKeySessionContextAttributes? = nil, sessionIssuer: AwsIamAccessKeySessionContextSessionIssuer? = nil) {
            self.attributes = attributes
            self.sessionIssuer = sessionIssuer
        }

        public func validate(name: String) throws {
            try self.attributes?.validate(name: "\(name).attributes")
            try self.sessionIssuer?.validate(name: "\(name).sessionIssuer")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case sessionIssuer = "SessionIssuer"
        }
    }

    public struct AwsIamAccessKeySessionContextAttributes: AWSEncodableShape & AWSDecodableShape {
        /// Indicates when the session was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let creationDate: String?
        /// Indicates whether the session used multi-factor authentication (MFA).
        public let mfaAuthenticated: Bool?

        public init(creationDate: String? = nil, mfaAuthenticated: Bool? = nil) {
            self.creationDate = creationDate
            self.mfaAuthenticated = mfaAuthenticated
        }

        public func validate(name: String) throws {
            try self.validate(self.creationDate, name: "creationDate", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case mfaAuthenticated = "MfaAuthenticated"
        }
    }

    public struct AwsIamAccessKeySessionContextSessionIssuer: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the Amazon Web Services account that created the session.
        public let accountId: String?
        /// The ARN of the session.
        public let arn: String?
        /// The principal ID of the principal (user, role, or group) that created the session.
        public let principalId: String?
        /// The type of principal (user, role, or group) that created the session.
        public let type: String?
        /// The name of the principal that created the session.
        public let userName: String?

        public init(accountId: String? = nil, arn: String? = nil, principalId: String? = nil, type: String? = nil, userName: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.type = type
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\S")
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.userName, name: "userName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case arn = "Arn"
            case principalId = "PrincipalId"
            case type = "Type"
            case userName = "UserName"
        }
    }

    public struct AwsIamAttachedManagedPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the policy.
        public let policyArn: String?
        /// The name of the policy.
        public let policyName: String?

        public init(policyArn: String? = nil, policyName: String? = nil) {
            self.policyArn = policyArn
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyArn, name: "policyArn", parent: name, pattern: "\\S")
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case policyArn = "PolicyArn"
            case policyName = "PolicyName"
        }
    }

    public struct AwsIamGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// A list of the managed policies that are attached to the IAM group.
        public let attachedManagedPolicies: [AwsIamAttachedManagedPolicy]?
        /// Indicates when the IAM group was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createDate: String?
        /// The identifier of the IAM group.
        public let groupId: String?
        /// The name of the IAM group.
        public let groupName: String?
        /// The list of inline policies that are embedded in the group.
        public let groupPolicyList: [AwsIamGroupPolicy]?
        /// The path to the group.
        public let path: String?

        public init(attachedManagedPolicies: [AwsIamAttachedManagedPolicy]? = nil, createDate: String? = nil, groupId: String? = nil, groupName: String? = nil, groupPolicyList: [AwsIamGroupPolicy]? = nil, path: String? = nil) {
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.groupPolicyList = groupPolicyList
            self.path = path
        }

        public func validate(name: String) throws {
            try self.attachedManagedPolicies?.forEach {
                try $0.validate(name: "\(name).attachedManagedPolicies[]")
            }
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "\\S")
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.groupPolicyList?.forEach {
                try $0.validate(name: "\(name).groupPolicyList[]")
            }
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attachedManagedPolicies = "AttachedManagedPolicies"
            case createDate = "CreateDate"
            case groupId = "GroupId"
            case groupName = "GroupName"
            case groupPolicyList = "GroupPolicyList"
            case path = "Path"
        }
    }

    public struct AwsIamGroupPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The name of the policy.
        public let policyName: String?

        public init(policyName: String? = nil) {
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "PolicyName"
        }
    }

    public struct AwsIamInstanceProfile: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the instance profile.
        public let arn: String?
        /// Indicates when the instance profile was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createDate: String?
        /// The identifier of the instance profile.
        public let instanceProfileId: String?
        /// The name of the instance profile.
        public let instanceProfileName: String?
        /// The path to the instance profile.
        public let path: String?
        /// The roles associated with the instance profile.
        public let roles: [AwsIamInstanceProfileRole]?

        public init(arn: String? = nil, createDate: String? = nil, instanceProfileId: String? = nil, instanceProfileName: String? = nil, path: String? = nil, roles: [AwsIamInstanceProfileRole]? = nil) {
            self.arn = arn
            self.createDate = createDate
            self.instanceProfileId = instanceProfileId
            self.instanceProfileName = instanceProfileName
            self.path = path
            self.roles = roles
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.validate(self.instanceProfileId, name: "instanceProfileId", parent: name, pattern: "\\S")
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.roles?.forEach {
                try $0.validate(name: "\(name).roles[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createDate = "CreateDate"
            case instanceProfileId = "InstanceProfileId"
            case instanceProfileName = "InstanceProfileName"
            case path = "Path"
            case roles = "Roles"
        }
    }

    public struct AwsIamInstanceProfileRole: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the role.
        public let arn: String?
        /// The policy that grants an entity permission to assume the role.
        public let assumeRolePolicyDocument: String?
        /// Indicates when the role was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createDate: String?
        /// The path to the role.
        public let path: String?
        /// The identifier of the role.
        public let roleId: String?
        /// The name of the role.
        public let roleName: String?

        public init(arn: String? = nil, assumeRolePolicyDocument: String? = nil, createDate: String? = nil, path: String? = nil, roleId: String? = nil, roleName: String? = nil) {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.createDate = createDate
            self.path = path
            self.roleId = roleId
            self.roleName = roleName
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, max: 131_072)
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, min: 1)
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+$")
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.validate(self.roleId, name: "roleId", parent: name, pattern: "\\S")
            try self.validate(self.roleName, name: "roleName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
            case createDate = "CreateDate"
            case path = "Path"
            case roleId = "RoleId"
            case roleName = "RoleName"
        }
    }

    public struct AwsIamPermissionsBoundary: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the policy used to set the permissions boundary.
        public let permissionsBoundaryArn: String?
        /// The usage type for the permissions boundary.
        public let permissionsBoundaryType: String?

        public init(permissionsBoundaryArn: String? = nil, permissionsBoundaryType: String? = nil) {
            self.permissionsBoundaryArn = permissionsBoundaryArn
            self.permissionsBoundaryType = permissionsBoundaryType
        }

        public func validate(name: String) throws {
            try self.validate(self.permissionsBoundaryArn, name: "permissionsBoundaryArn", parent: name, pattern: "\\S")
            try self.validate(self.permissionsBoundaryType, name: "permissionsBoundaryType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case permissionsBoundaryArn = "PermissionsBoundaryArn"
            case permissionsBoundaryType = "PermissionsBoundaryType"
        }
    }

    public struct AwsIamPolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of users, groups, and roles that the policy is attached to.
        public let attachmentCount: Int?
        /// When the policy was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createDate: String?
        /// The identifier of the default version of the policy.
        public let defaultVersionId: String?
        /// A description of the policy.
        public let description: String?
        /// Whether the policy can be attached to a user, group, or role.
        public let isAttachable: Bool?
        /// The path to the policy.
        public let path: String?
        /// The number of users and roles that use the policy to set the permissions boundary.
        public let permissionsBoundaryUsageCount: Int?
        /// The unique identifier of the policy.
        public let policyId: String?
        /// The name of the policy.
        public let policyName: String?
        /// List of versions of the policy.
        public let policyVersionList: [AwsIamPolicyVersion]?
        /// When the policy was most recently updated. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let updateDate: String?

        public init(attachmentCount: Int? = nil, createDate: String? = nil, defaultVersionId: String? = nil, description: String? = nil, isAttachable: Bool? = nil, path: String? = nil, permissionsBoundaryUsageCount: Int? = nil, policyId: String? = nil, policyName: String? = nil, policyVersionList: [AwsIamPolicyVersion]? = nil, updateDate: String? = nil) {
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.policyVersionList = policyVersionList
            self.updateDate = updateDate
        }

        public func validate(name: String) throws {
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.validate(self.defaultVersionId, name: "defaultVersionId", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.validate(self.policyId, name: "policyId", parent: name, pattern: "\\S")
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
            try self.policyVersionList?.forEach {
                try $0.validate(name: "\(name).policyVersionList[]")
            }
            try self.validate(self.updateDate, name: "updateDate", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentCount = "AttachmentCount"
            case createDate = "CreateDate"
            case defaultVersionId = "DefaultVersionId"
            case description = "Description"
            case isAttachable = "IsAttachable"
            case path = "Path"
            case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
            case policyId = "PolicyId"
            case policyName = "PolicyName"
            case policyVersionList = "PolicyVersionList"
            case updateDate = "UpdateDate"
        }
    }

    public struct AwsIamPolicyVersion: AWSEncodableShape & AWSDecodableShape {
        /// Indicates when the version was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createDate: String?
        /// Whether the version is the default version.
        public let isDefaultVersion: Bool?
        /// The identifier of the policy version.
        public let versionId: String?

        public init(createDate: String? = nil, isDefaultVersion: Bool? = nil, versionId: String? = nil) {
            self.createDate = createDate
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case isDefaultVersion = "IsDefaultVersion"
            case versionId = "VersionId"
        }
    }

    public struct AwsIamRoleDetails: AWSEncodableShape & AWSDecodableShape {
        /// The trust policy that grants permission to assume the role.
        public let assumeRolePolicyDocument: String?
        /// The list of the managed policies that are attached to the role.
        public let attachedManagedPolicies: [AwsIamAttachedManagedPolicy]?
        /// Indicates when the role was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createDate: String?
        /// The list of instance profiles that contain this role.
        public let instanceProfileList: [AwsIamInstanceProfile]?
        /// The maximum session duration (in seconds) that you want to set for the specified role.
        public let maxSessionDuration: Int?
        /// The path to the role.
        public let path: String?
        public let permissionsBoundary: AwsIamPermissionsBoundary?
        /// The stable and unique string identifying the role.
        public let roleId: String?
        /// The friendly name that identifies the role.
        public let roleName: String?
        /// The list of inline policies that are embedded in the role.
        public let rolePolicyList: [AwsIamRolePolicy]?

        public init(assumeRolePolicyDocument: String? = nil, attachedManagedPolicies: [AwsIamAttachedManagedPolicy]? = nil, createDate: String? = nil, instanceProfileList: [AwsIamInstanceProfile]? = nil, maxSessionDuration: Int? = nil, path: String? = nil, permissionsBoundary: AwsIamPermissionsBoundary? = nil, roleId: String? = nil, roleName: String? = nil, rolePolicyList: [AwsIamRolePolicy]? = nil) {
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.instanceProfileList = instanceProfileList
            self.maxSessionDuration = maxSessionDuration
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleName = roleName
            self.rolePolicyList = rolePolicyList
        }

        public func validate(name: String) throws {
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, max: 131_072)
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, min: 1)
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+$")
            try self.attachedManagedPolicies?.forEach {
                try $0.validate(name: "\(name).attachedManagedPolicies[]")
            }
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.instanceProfileList?.forEach {
                try $0.validate(name: "\(name).instanceProfileList[]")
            }
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.permissionsBoundary?.validate(name: "\(name).permissionsBoundary")
            try self.validate(self.roleId, name: "roleId", parent: name, pattern: "\\S")
            try self.validate(self.roleName, name: "roleName", parent: name, pattern: "\\S")
            try self.rolePolicyList?.forEach {
                try $0.validate(name: "\(name).rolePolicyList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
            case attachedManagedPolicies = "AttachedManagedPolicies"
            case createDate = "CreateDate"
            case instanceProfileList = "InstanceProfileList"
            case maxSessionDuration = "MaxSessionDuration"
            case path = "Path"
            case permissionsBoundary = "PermissionsBoundary"
            case roleId = "RoleId"
            case roleName = "RoleName"
            case rolePolicyList = "RolePolicyList"
        }
    }

    public struct AwsIamRolePolicy: AWSEncodableShape & AWSDecodableShape {
        /// The name of the policy.
        public let policyName: String?

        public init(policyName: String? = nil) {
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "PolicyName"
        }
    }

    public struct AwsIamUserDetails: AWSEncodableShape & AWSDecodableShape {
        /// A list of the managed policies that are attached to the user.
        public let attachedManagedPolicies: [AwsIamAttachedManagedPolicy]?
        /// Indicates when the user was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createDate: String?
        /// A list of IAM groups that the user belongs to.
        public let groupList: [String]?
        /// The path to the user.
        public let path: String?
        /// The permissions boundary for the user.
        public let permissionsBoundary: AwsIamPermissionsBoundary?
        /// The unique identifier for the user.
        public let userId: String?
        /// The name of the user.
        public let userName: String?
        /// The list of inline policies that are embedded in the user.
        public let userPolicyList: [AwsIamUserPolicy]?

        public init(attachedManagedPolicies: [AwsIamAttachedManagedPolicy]? = nil, createDate: String? = nil, groupList: [String]? = nil, path: String? = nil, permissionsBoundary: AwsIamPermissionsBoundary? = nil, userId: String? = nil, userName: String? = nil, userPolicyList: [AwsIamUserPolicy]? = nil) {
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupList = groupList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.userId = userId
            self.userName = userName
            self.userPolicyList = userPolicyList
        }

        public func validate(name: String) throws {
            try self.attachedManagedPolicies?.forEach {
                try $0.validate(name: "\(name).attachedManagedPolicies[]")
            }
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.groupList?.forEach {
                try validate($0, name: "groupList[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.permissionsBoundary?.validate(name: "\(name).permissionsBoundary")
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
            try self.validate(self.userName, name: "userName", parent: name, pattern: "\\S")
            try self.userPolicyList?.forEach {
                try $0.validate(name: "\(name).userPolicyList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attachedManagedPolicies = "AttachedManagedPolicies"
            case createDate = "CreateDate"
            case groupList = "GroupList"
            case path = "Path"
            case permissionsBoundary = "PermissionsBoundary"
            case userId = "UserId"
            case userName = "UserName"
            case userPolicyList = "UserPolicyList"
        }
    }

    public struct AwsIamUserPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The name of the policy.
        public let policyName: String?

        public init(policyName: String? = nil) {
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "PolicyName"
        }
    }

    public struct AwsKinesisStreamDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        public let arn: String?
        /// The name of the Kinesis stream. If you don't specify a name, CloudFront generates a unique
        /// physical ID and uses that ID for the stream name.
        public let name: String?
        /// The number of hours for the data records that are stored in shards to remain accessible.
        public let retentionPeriodHours: Int?
        /// The number of shards that the stream uses.
        public let shardCount: Int?
        /// When specified, enables or updates server-side encryption using an KMS key for a specified stream.
        /// Removing this property from your stack template and updating your stack disables encryption.
        public let streamEncryption: AwsKinesisStreamStreamEncryptionDetails?

        public init(arn: String? = nil, name: String? = nil, retentionPeriodHours: Int? = nil, shardCount: Int? = nil, streamEncryption: AwsKinesisStreamStreamEncryptionDetails? = nil) {
            self.arn = arn
            self.name = name
            self.retentionPeriodHours = retentionPeriodHours
            self.shardCount = shardCount
            self.streamEncryption = streamEncryption
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.streamEncryption?.validate(name: "\(name).streamEncryption")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
            case retentionPeriodHours = "RetentionPeriodHours"
            case shardCount = "ShardCount"
            case streamEncryption = "StreamEncryption"
        }
    }

    public struct AwsKinesisStreamStreamEncryptionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The encryption type to use.
        public let encryptionType: String?
        /// The globally unique identifier for the customer-managed KMS key to use for encryption.
        public let keyId: String?

        public init(encryptionType: String? = nil, keyId: String? = nil) {
            self.encryptionType = encryptionType
            self.keyId = keyId
        }

        public func validate(name: String) throws {
            try self.validate(self.encryptionType, name: "encryptionType", parent: name, pattern: "\\S")
            try self.validate(self.keyId, name: "keyId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "EncryptionType"
            case keyId = "KeyId"
        }
    }

    public struct AwsKmsKeyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The twelve-digit account ID of the Amazon Web Services account that owns the KMS key.
        public let awsAccountId: String?
        /// Indicates when the KMS key was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let creationDate: Double?
        /// A description of the KMS key.
        public let description: String?
        /// The globally unique identifier for the KMS key.
        public let keyId: String?
        /// The manager of the KMS key. KMS keys in your Amazon Web Services account are either customer managed or Amazon Web Services managed.
        public let keyManager: String?
        /// Whether the key has key rotation enabled.
        public let keyRotationStatus: Bool?
        /// The state of the KMS key. Valid values are as follows:    Disabled     Enabled     PendingDeletion     PendingImport     Unavailable
        public let keyState: String?
        /// The source of the KMS key material. When this value is AWS_KMS, KMS created the key material. When this value is EXTERNAL, the key material was imported from your existing key management infrastructure or the KMS key lacks key material. When this value is AWS_CLOUDHSM, the key material was created in the CloudHSM cluster associated with a custom key store.
        public let origin: String?

        public init(awsAccountId: String? = nil, creationDate: Double? = nil, description: String? = nil, keyId: String? = nil, keyManager: String? = nil, keyRotationStatus: Bool? = nil, keyState: String? = nil, origin: String? = nil) {
            self.awsAccountId = awsAccountId
            self.creationDate = creationDate
            self.description = description
            self.keyId = keyId
            self.keyManager = keyManager
            self.keyRotationStatus = keyRotationStatus
            self.keyState = keyState
            self.origin = origin
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.keyId, name: "keyId", parent: name, pattern: "\\S")
            try self.validate(self.keyManager, name: "keyManager", parent: name, pattern: "\\S")
            try self.validate(self.keyState, name: "keyState", parent: name, pattern: "\\S")
            try self.validate(self.origin, name: "origin", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AWSAccountId"
            case creationDate = "CreationDate"
            case description = "Description"
            case keyId = "KeyId"
            case keyManager = "KeyManager"
            case keyRotationStatus = "KeyRotationStatus"
            case keyState = "KeyState"
            case origin = "Origin"
        }
    }

    public struct AwsLambdaFunctionCode: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public let s3Bucket: String?
        /// The Amazon S3 key of the deployment package.
        public let s3Key: String?
        /// For versioned objects, the version of the deployment package object to use.
        public let s3ObjectVersion: String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public let zipFile: String?

        public init(s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil, zipFile: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "\\S")
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: "\\S")
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, pattern: "\\S")
            try self.validate(self.zipFile, name: "zipFile", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
            case s3ObjectVersion = "S3ObjectVersion"
            case zipFile = "ZipFile"
        }
    }

    public struct AwsLambdaFunctionDeadLetterConfig: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of an SQS queue or SNS topic.
        public let targetArn: String?

        public init(targetArn: String? = nil) {
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.targetArn, name: "targetArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case targetArn = "TargetArn"
        }
    }

    public struct AwsLambdaFunctionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The instruction set architecture that the function uses. Valid values are x86_64 or
        /// arm64.
        public let architectures: [String]?
        /// An AwsLambdaFunctionCode object.
        public let code: AwsLambdaFunctionCode?
        /// The SHA256 hash of the function's deployment package.
        public let codeSha256: String?
        /// The function's dead letter queue.
        public let deadLetterConfig: AwsLambdaFunctionDeadLetterConfig?
        /// The function's environment variables.
        public let environment: AwsLambdaFunctionEnvironment?
        /// The name of the function.
        public let functionName: String?
        /// The function that Lambda calls to begin executing your function.
        public let handler: String?
        /// The KMS key that is used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed customer managed key.
        public let kmsKeyArn: String?
        /// Indicates when the function was last updated. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastModified: String?
        /// The function's layers.
        public let layers: [AwsLambdaFunctionLayer]?
        /// For Lambda@Edge functions, the ARN of the master function.
        public let masterArn: String?
        /// The memory that is allocated to the function.
        public let memorySize: Int?
        /// The type of deployment package that's used to deploy the function code to Lambda. Set to Image for a container image and Zip  for a .zip file archive.
        public let packageType: String?
        /// The latest updated revision of the function or alias.
        public let revisionId: String?
        /// The function's execution role.
        public let role: String?
        /// The runtime environment for the Lambda function.
        public let runtime: String?
        /// The amount of time that Lambda allows a function to run before stopping it.
        public let timeout: Int?
        /// The function's X-Ray tracing configuration.
        public let tracingConfig: AwsLambdaFunctionTracingConfig?
        /// The version of the Lambda function.
        public let version: String?
        /// The function's networking configuration.
        public let vpcConfig: AwsLambdaFunctionVpcConfig?

        public init(architectures: [String]? = nil, code: AwsLambdaFunctionCode? = nil, codeSha256: String? = nil, deadLetterConfig: AwsLambdaFunctionDeadLetterConfig? = nil, environment: AwsLambdaFunctionEnvironment? = nil, functionName: String? = nil, handler: String? = nil, kmsKeyArn: String? = nil, lastModified: String? = nil, layers: [AwsLambdaFunctionLayer]? = nil, masterArn: String? = nil, memorySize: Int? = nil, packageType: String? = nil, revisionId: String? = nil, role: String? = nil, runtime: String? = nil, timeout: Int? = nil, tracingConfig: AwsLambdaFunctionTracingConfig? = nil, version: String? = nil, vpcConfig: AwsLambdaFunctionVpcConfig? = nil) {
            self.architectures = architectures
            self.code = code
            self.codeSha256 = codeSha256
            self.deadLetterConfig = deadLetterConfig
            self.environment = environment
            self.functionName = functionName
            self.handler = handler
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.layers = layers
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.architectures?.forEach {
                try validate($0, name: "architectures[]", parent: name, pattern: "\\S")
            }
            try self.code?.validate(name: "\(name).code")
            try self.validate(self.codeSha256, name: "codeSha256", parent: name, pattern: "\\S")
            try self.deadLetterConfig?.validate(name: "\(name).deadLetterConfig")
            try self.environment?.validate(name: "\(name).environment")
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "\\S")
            try self.validate(self.handler, name: "handler", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "\\S")
            try self.validate(self.lastModified, name: "lastModified", parent: name, pattern: "\\S")
            try self.layers?.forEach {
                try $0.validate(name: "\(name).layers[]")
            }
            try self.validate(self.masterArn, name: "masterArn", parent: name, pattern: "\\S")
            try self.validate(self.packageType, name: "packageType", parent: name, pattern: "\\S")
            try self.validate(self.revisionId, name: "revisionId", parent: name, pattern: "\\S")
            try self.validate(self.role, name: "role", parent: name, pattern: "\\S")
            try self.validate(self.runtime, name: "runtime", parent: name, pattern: "\\S")
            try self.tracingConfig?.validate(name: "\(name).tracingConfig")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case architectures = "Architectures"
            case code = "Code"
            case codeSha256 = "CodeSha256"
            case deadLetterConfig = "DeadLetterConfig"
            case environment = "Environment"
            case functionName = "FunctionName"
            case handler = "Handler"
            case kmsKeyArn = "KmsKeyArn"
            case lastModified = "LastModified"
            case layers = "Layers"
            case masterArn = "MasterArn"
            case memorySize = "MemorySize"
            case packageType = "PackageType"
            case revisionId = "RevisionId"
            case role = "Role"
            case runtime = "Runtime"
            case timeout = "Timeout"
            case tracingConfig = "TracingConfig"
            case version = "Version"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct AwsLambdaFunctionEnvironment: AWSEncodableShape & AWSDecodableShape {
        /// An AwsLambdaFunctionEnvironmentError object.
        public let error: AwsLambdaFunctionEnvironmentError?
        /// Environment variable key-value pairs.
        public let variables: [String: String]?

        public init(error: AwsLambdaFunctionEnvironmentError? = nil, variables: [String: String]? = nil) {
            self.error = error
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.error?.validate(name: "\(name).error")
            try self.variables?.forEach {
                try validate($0.key, name: "variables.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "variables[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case variables = "Variables"
        }
    }

    public struct AwsLambdaFunctionEnvironmentError: AWSEncodableShape & AWSDecodableShape {
        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        public func validate(name: String) throws {
            try self.validate(self.errorCode, name: "errorCode", parent: name, pattern: "\\S")
            try self.validate(self.message, name: "message", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct AwsLambdaFunctionLayer: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the function layer.
        public let arn: String?
        /// The size of the layer archive in bytes.
        public let codeSize: Int?

        public init(arn: String? = nil, codeSize: Int? = nil) {
            self.arn = arn
            self.codeSize = codeSize
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case codeSize = "CodeSize"
        }
    }

    public struct AwsLambdaFunctionTracingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The tracing mode.
        public let mode: String?

        public init(mode: String? = nil) {
            self.mode = mode
        }

        public func validate(name: String) throws {
            try self.validate(self.mode, name: "mode", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct AwsLambdaFunctionVpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of VPC security groups IDs.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs.
        public let subnetIds: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "\\S")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcId = "VpcId"
        }
    }

    public struct AwsLambdaLayerVersionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The layer's compatible runtimes. Maximum number of five items. Valid values: nodejs10.x | nodejs12.x | java8 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | dotnetcore1.0 | dotnetcore2.1 | go1.x | ruby2.5 | provided
        public let compatibleRuntimes: [String]?
        /// Indicates when the version was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdDate: String?
        /// The version number.
        public let version: Int64?

        public init(compatibleRuntimes: [String]? = nil, createdDate: String? = nil, version: Int64? = nil) {
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.version = version
        }

        public func validate(name: String) throws {
            try self.compatibleRuntimes?.forEach {
                try validate($0, name: "compatibleRuntimes[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.createdDate, name: "createdDate", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleRuntimes = "CompatibleRuntimes"
            case createdDate = "CreatedDate"
            case version = "Version"
        }
    }

    public struct AwsMountPoint: AWSEncodableShape & AWSDecodableShape {
        /// The path on the container to mount the host volume at.
        public let containerPath: String?
        /// The name of the volume to mount. Must be a volume name referenced in the name parameter
        /// of task definition volume.
        public let sourceVolume: String?

        public init(containerPath: String? = nil, sourceVolume: String? = nil) {
            self.containerPath = containerPath
            self.sourceVolume = sourceVolume
        }

        public func validate(name: String) throws {
            try self.validate(self.containerPath, name: "containerPath", parent: name, pattern: "\\S")
            try self.validate(self.sourceVolume, name: "sourceVolume", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerPath = "ContainerPath"
            case sourceVolume = "SourceVolume"
        }
    }

    public struct AwsNetworkFirewallFirewallDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the firewall is protected from deletion. If set to true, then the firewall cannot be deleted.
        public let deleteProtection: Bool?
        /// A description of the firewall.
        public let description: String?
        /// The ARN of the firewall.
        public let firewallArn: String?
        /// The identifier of the firewall.
        public let firewallId: String?
        /// A descriptive name of the firewall.
        public let firewallName: String?
        /// The ARN of the firewall policy.
        public let firewallPolicyArn: String?
        /// Whether the firewall is protected from a change to the firewall policy. If set to true, you cannot associate a different policy with the firewall.
        public let firewallPolicyChangeProtection: Bool?
        /// Whether the firewall is protected from a change to the subnet associations. If set to true, you cannot map different subnets to the firewall.
        public let subnetChangeProtection: Bool?
        /// The public subnets that Network Firewall uses for the firewall. Each subnet must belong to a different Availability Zone.
        public let subnetMappings: [AwsNetworkFirewallFirewallSubnetMappingsDetails]?
        /// The identifier of the VPC where the firewall is used.
        public let vpcId: String?

        public init(deleteProtection: Bool? = nil, description: String? = nil, firewallArn: String? = nil, firewallId: String? = nil, firewallName: String? = nil, firewallPolicyArn: String? = nil, firewallPolicyChangeProtection: Bool? = nil, subnetChangeProtection: Bool? = nil, subnetMappings: [AwsNetworkFirewallFirewallSubnetMappingsDetails]? = nil, vpcId: String? = nil) {
            self.deleteProtection = deleteProtection
            self.description = description
            self.firewallArn = firewallArn
            self.firewallId = firewallId
            self.firewallName = firewallName
            self.firewallPolicyArn = firewallPolicyArn
            self.firewallPolicyChangeProtection = firewallPolicyChangeProtection
            self.subnetChangeProtection = subnetChangeProtection
            self.subnetMappings = subnetMappings
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.firewallArn, name: "firewallArn", parent: name, pattern: "\\S")
            try self.validate(self.firewallId, name: "firewallId", parent: name, pattern: "\\S")
            try self.validate(self.firewallName, name: "firewallName", parent: name, pattern: "\\S")
            try self.validate(self.firewallPolicyArn, name: "firewallPolicyArn", parent: name, pattern: "\\S")
            try self.subnetMappings?.forEach {
                try $0.validate(name: "\(name).subnetMappings[]")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteProtection = "DeleteProtection"
            case description = "Description"
            case firewallArn = "FirewallArn"
            case firewallId = "FirewallId"
            case firewallName = "FirewallName"
            case firewallPolicyArn = "FirewallPolicyArn"
            case firewallPolicyChangeProtection = "FirewallPolicyChangeProtection"
            case subnetChangeProtection = "SubnetChangeProtection"
            case subnetMappings = "SubnetMappings"
            case vpcId = "VpcId"
        }
    }

    public struct AwsNetworkFirewallFirewallPolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// A description of the firewall policy.
        public let description: String?
        /// The firewall policy configuration.
        public let firewallPolicy: FirewallPolicyDetails?
        /// The ARN of the firewall policy.
        public let firewallPolicyArn: String?
        /// The identifier of the firewall policy.
        public let firewallPolicyId: String?
        /// The name of the firewall policy.
        public let firewallPolicyName: String?

        public init(description: String? = nil, firewallPolicy: FirewallPolicyDetails? = nil, firewallPolicyArn: String? = nil, firewallPolicyId: String? = nil, firewallPolicyName: String? = nil) {
            self.description = description
            self.firewallPolicy = firewallPolicy
            self.firewallPolicyArn = firewallPolicyArn
            self.firewallPolicyId = firewallPolicyId
            self.firewallPolicyName = firewallPolicyName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.firewallPolicy?.validate(name: "\(name).firewallPolicy")
            try self.validate(self.firewallPolicyArn, name: "firewallPolicyArn", parent: name, pattern: "\\S")
            try self.validate(self.firewallPolicyId, name: "firewallPolicyId", parent: name, pattern: "\\S")
            try self.validate(self.firewallPolicyName, name: "firewallPolicyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case firewallPolicy = "FirewallPolicy"
            case firewallPolicyArn = "FirewallPolicyArn"
            case firewallPolicyId = "FirewallPolicyId"
            case firewallPolicyName = "FirewallPolicyName"
        }
    }

    public struct AwsNetworkFirewallFirewallSubnetMappingsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the subnet
        public let subnetId: String?

        public init(subnetId: String? = nil) {
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case subnetId = "SubnetId"
        }
    }

    public struct AwsNetworkFirewallRuleGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of operating resources that this rule group can use.
        public let capacity: Int?
        /// A description of the rule group.
        public let description: String?
        /// Details about the rule group.
        public let ruleGroup: RuleGroupDetails?
        /// The ARN of the rule group.
        public let ruleGroupArn: String?
        /// The identifier of the rule group.
        public let ruleGroupId: String?
        /// The descriptive name of the rule group.
        public let ruleGroupName: String?
        /// The type of rule group. A rule group can be stateful or stateless.
        public let type: String?

        public init(capacity: Int? = nil, description: String? = nil, ruleGroup: RuleGroupDetails? = nil, ruleGroupArn: String? = nil, ruleGroupId: String? = nil, ruleGroupName: String? = nil, type: String? = nil) {
            self.capacity = capacity
            self.description = description
            self.ruleGroup = ruleGroup
            self.ruleGroupArn = ruleGroupArn
            self.ruleGroupId = ruleGroupId
            self.ruleGroupName = ruleGroupName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.ruleGroup?.validate(name: "\(name).ruleGroup")
            try self.validate(self.ruleGroupArn, name: "ruleGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.ruleGroupId, name: "ruleGroupId", parent: name, pattern: "\\S")
            try self.validate(self.ruleGroupName, name: "ruleGroupName", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "Capacity"
            case description = "Description"
            case ruleGroup = "RuleGroup"
            case ruleGroupArn = "RuleGroupArn"
            case ruleGroupId = "RuleGroupId"
            case ruleGroupName = "RuleGroupName"
            case type = "Type"
        }
    }

    public struct AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Enables fine-grained access control.
        public let enabled: Bool?
        /// Enables the internal user database.
        public let internalUserDatabaseEnabled: Bool?
        /// Specifies information about the master user of the domain.
        public let masterUserOptions: AwsOpenSearchServiceDomainMasterUserOptionsDetails?

        public init(enabled: Bool? = nil, internalUserDatabaseEnabled: Bool? = nil, masterUserOptions: AwsOpenSearchServiceDomainMasterUserOptionsDetails? = nil) {
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.masterUserOptions = masterUserOptions
        }

        public func validate(name: String) throws {
            try self.masterUserOptions?.validate(name: "\(name).masterUserOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
            case masterUserOptions = "MasterUserOptions"
        }
    }

    public struct AwsOpenSearchServiceDomainClusterConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances to use for the master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public let dedicatedMasterCount: Int?
        /// Whether to use a dedicated master node for the OpenSearch domain. A dedicated master node performs cluster management tasks, but does not hold data or respond to data upload requests.
        public let dedicatedMasterEnabled: Bool?
        /// The hardware configuration of the computer that hosts the dedicated master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public let dedicatedMasterType: String?
        /// The number of data nodes to use in the OpenSearch domain.
        public let instanceCount: Int?
        /// The instance type for your data nodes. For a list of valid values, see Supported instance types in Amazon OpenSearch Service in the Amazon OpenSearch Service Developer Guide.
        public let instanceType: String?
        /// The number of UltraWarm instances.
        public let warmCount: Int?
        /// Whether UltraWarm is enabled.
        public let warmEnabled: Bool?
        /// The type of UltraWarm instance.
        public let warmType: String?
        /// Configuration options for zone awareness. Provided if ZoneAwarenessEnabled is true.
        public let zoneAwarenessConfig: AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails?
        /// Whether to enable zone awareness for the OpenSearch domain. When zone awareness is enabled, OpenSearch Service allocates the cluster's nodes and replica index shards across Availability Zones (AZs) in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.
        public let zoneAwarenessEnabled: Bool?

        public init(dedicatedMasterCount: Int? = nil, dedicatedMasterEnabled: Bool? = nil, dedicatedMasterType: String? = nil, instanceCount: Int? = nil, instanceType: String? = nil, warmCount: Int? = nil, warmEnabled: Bool? = nil, warmType: String? = nil, zoneAwarenessConfig: AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails? = nil, zoneAwarenessEnabled: Bool? = nil) {
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.warmCount = warmCount
            self.warmEnabled = warmEnabled
            self.warmType = warmType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.dedicatedMasterType, name: "dedicatedMasterType", parent: name, pattern: "\\S")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
            try self.validate(self.warmType, name: "warmType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dedicatedMasterCount = "DedicatedMasterCount"
            case dedicatedMasterEnabled = "DedicatedMasterEnabled"
            case dedicatedMasterType = "DedicatedMasterType"
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case warmCount = "WarmCount"
            case warmEnabled = "WarmEnabled"
            case warmType = "WarmType"
            case zoneAwarenessConfig = "ZoneAwarenessConfig"
            case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
        }
    }

    public struct AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of Availability Zones that the domain uses. Valid values are 2 or 3. The default is 2.
        public let availabilityZoneCount: Int?

        public init(availabilityZoneCount: Int? = nil) {
            self.availabilityZoneCount = availabilityZoneCount
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneCount = "AvailabilityZoneCount"
        }
    }

    public struct AwsOpenSearchServiceDomainDetails: AWSEncodableShape & AWSDecodableShape {
        /// IAM policy document that specifies the access policies for the OpenSearch Service domain.
        public let accessPolicies: String?
        /// Specifies options for fine-grained access control.
        public let advancedSecurityOptions: AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails?
        /// The ARN of the OpenSearch Service domain.
        public let arn: String?
        /// Details about the configuration of an OpenSearch cluster.
        public let clusterConfig: AwsOpenSearchServiceDomainClusterConfigDetails?
        /// The domain endpoint.
        public let domainEndpoint: String?
        /// Additional options for the domain endpoint.
        public let domainEndpointOptions: AwsOpenSearchServiceDomainDomainEndpointOptionsDetails?
        /// The domain endpoints. Used if the OpenSearch domain resides in a VPC. This is a map of key-value pairs. The key is always vpc. The value is the endpoint.
        public let domainEndpoints: [String: String]?
        /// The name of the endpoint.
        public let domainName: String?
        /// Details about the configuration for encryption at rest.
        public let encryptionAtRestOptions: AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails?
        /// The version of the domain engine.
        public let engineVersion: String?
        /// The identifier of the domain.
        public let id: String?
        /// Configures the CloudWatch Logs to publish for the OpenSearch domain.
        public let logPublishingOptions: AwsOpenSearchServiceDomainLogPublishingOptionsDetails?
        /// Details about the configuration for node-to-node encryption.
        public let nodeToNodeEncryptionOptions: AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails?
        /// Information about the status of a domain relative to the latest service software.
        public let serviceSoftwareOptions: AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails?
        /// Information that OpenSearch Service derives based on VPCOptions for the domain.
        public let vpcOptions: AwsOpenSearchServiceDomainVpcOptionsDetails?

        public init(accessPolicies: String? = nil, advancedSecurityOptions: AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails? = nil, arn: String? = nil, clusterConfig: AwsOpenSearchServiceDomainClusterConfigDetails? = nil, domainEndpoint: String? = nil, domainEndpointOptions: AwsOpenSearchServiceDomainDomainEndpointOptionsDetails? = nil, domainEndpoints: [String: String]? = nil, domainName: String? = nil, encryptionAtRestOptions: AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails? = nil, engineVersion: String? = nil, id: String? = nil, logPublishingOptions: AwsOpenSearchServiceDomainLogPublishingOptionsDetails? = nil, nodeToNodeEncryptionOptions: AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails? = nil, serviceSoftwareOptions: AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails? = nil, vpcOptions: AwsOpenSearchServiceDomainVpcOptionsDetails? = nil) {
            self.accessPolicies = accessPolicies
            self.advancedSecurityOptions = advancedSecurityOptions
            self.arn = arn
            self.clusterConfig = clusterConfig
            self.domainEndpoint = domainEndpoint
            self.domainEndpointOptions = domainEndpointOptions
            self.domainEndpoints = domainEndpoints
            self.domainName = domainName
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.engineVersion = engineVersion
            self.id = id
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.vpcOptions = vpcOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, pattern: "\\S")
            try self.advancedSecurityOptions?.validate(name: "\(name).advancedSecurityOptions")
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.clusterConfig?.validate(name: "\(name).clusterConfig")
            try self.validate(self.domainEndpoint, name: "domainEndpoint", parent: name, pattern: "\\S")
            try self.domainEndpointOptions?.validate(name: "\(name).domainEndpointOptions")
            try self.domainEndpoints?.forEach {
                try validate($0.key, name: "domainEndpoints.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "domainEndpoints[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.logPublishingOptions?.validate(name: "\(name).logPublishingOptions")
            try self.serviceSoftwareOptions?.validate(name: "\(name).serviceSoftwareOptions")
            try self.vpcOptions?.validate(name: "\(name).vpcOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case advancedSecurityOptions = "AdvancedSecurityOptions"
            case arn = "Arn"
            case clusterConfig = "ClusterConfig"
            case domainEndpoint = "DomainEndpoint"
            case domainEndpointOptions = "DomainEndpointOptions"
            case domainEndpoints = "DomainEndpoints"
            case domainName = "DomainName"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case engineVersion = "EngineVersion"
            case id = "Id"
            case logPublishingOptions = "LogPublishingOptions"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case serviceSoftwareOptions = "ServiceSoftwareOptions"
            case vpcOptions = "VpcOptions"
        }
    }

    public struct AwsOpenSearchServiceDomainDomainEndpointOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The fully qualified URL for the custom endpoint.
        public let customEndpoint: String?
        /// The ARN for the security certificate. The certificate is managed in ACM.
        public let customEndpointCertificateArn: String?
        /// Whether to enable a custom endpoint for the domain.
        public let customEndpointEnabled: Bool?
        /// Whether to require that all traffic to the domain arrive over HTTPS.
        public let enforceHTTPS: Bool?
        /// The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.
        public let tlsSecurityPolicy: String?

        public init(customEndpoint: String? = nil, customEndpointCertificateArn: String? = nil, customEndpointEnabled: Bool? = nil, enforceHTTPS: Bool? = nil, tlsSecurityPolicy: String? = nil) {
            self.customEndpoint = customEndpoint
            self.customEndpointCertificateArn = customEndpointCertificateArn
            self.customEndpointEnabled = customEndpointEnabled
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.customEndpoint, name: "customEndpoint", parent: name, pattern: "\\S")
            try self.validate(self.customEndpointCertificateArn, name: "customEndpointCertificateArn", parent: name, pattern: "\\S")
            try self.validate(self.tlsSecurityPolicy, name: "tlsSecurityPolicy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case customEndpoint = "CustomEndpoint"
            case customEndpointCertificateArn = "CustomEndpointCertificateArn"
            case customEndpointEnabled = "CustomEndpointEnabled"
            case enforceHTTPS = "EnforceHTTPS"
            case tlsSecurityPolicy = "TLSSecurityPolicy"
        }
    }

    public struct AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether encryption at rest is enabled.
        public let enabled: Bool?
        /// The KMS key ID.
        public let kmsKeyId: String?

        public init(enabled: Bool? = nil, kmsKeyId: String? = nil) {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct AwsOpenSearchServiceDomainLogPublishingOption: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the CloudWatch Logs group to publish the logs to.
        public let cloudWatchLogsLogGroupArn: String?
        /// Whether the log publishing is enabled.
        public let enabled: Bool?

        public init(cloudWatchLogsLogGroupArn: String? = nil, enabled: Bool? = nil) {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
            case enabled = "Enabled"
        }
    }

    public struct AwsOpenSearchServiceDomainLogPublishingOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Configures the OpenSearch audit logs publishing.
        public let auditLogs: AwsOpenSearchServiceDomainLogPublishingOption?
        /// Configures the OpenSearch index logs publishing.
        public let indexSlowLogs: AwsOpenSearchServiceDomainLogPublishingOption?
        /// Configures the OpenSearch search slow log publishing.
        public let searchSlowLogs: AwsOpenSearchServiceDomainLogPublishingOption?

        public init(auditLogs: AwsOpenSearchServiceDomainLogPublishingOption? = nil, indexSlowLogs: AwsOpenSearchServiceDomainLogPublishingOption? = nil, searchSlowLogs: AwsOpenSearchServiceDomainLogPublishingOption? = nil) {
            self.auditLogs = auditLogs
            self.indexSlowLogs = indexSlowLogs
            self.searchSlowLogs = searchSlowLogs
        }

        public func validate(name: String) throws {
            try self.auditLogs?.validate(name: "\(name).auditLogs")
            try self.indexSlowLogs?.validate(name: "\(name).indexSlowLogs")
            try self.searchSlowLogs?.validate(name: "\(name).searchSlowLogs")
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs = "AuditLogs"
            case indexSlowLogs = "IndexSlowLogs"
            case searchSlowLogs = "SearchSlowLogs"
        }
    }

    public struct AwsOpenSearchServiceDomainMasterUserOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the master user.
        public let masterUserArn: String?
        /// The username for the master user.
        public let masterUserName: String?
        /// The password for the master user.
        public let masterUserPassword: String?

        public init(masterUserArn: String? = nil, masterUserName: String? = nil, masterUserPassword: String? = nil) {
            self.masterUserArn = masterUserArn
            self.masterUserName = masterUserName
            self.masterUserPassword = masterUserPassword
        }

        public func validate(name: String) throws {
            try self.validate(self.masterUserArn, name: "masterUserArn", parent: name, pattern: "\\S")
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, pattern: "\\S")
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case masterUserArn = "MasterUserArn"
            case masterUserName = "MasterUserName"
            case masterUserPassword = "MasterUserPassword"
        }
    }

    public struct AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether node-to-node encryption is enabled.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The epoch time when the deployment window closes for required updates. After this time, OpenSearch Service schedules the software upgrade automatically.
        public let automatedUpdateDate: String?
        /// Whether a request to update the domain can be canceled.
        public let cancellable: Bool?
        /// The version of the service software that is currently installed on the domain.
        public let currentVersion: String?
        /// A more detailed description of the service software status.
        public let description: String?
        /// The most recent version of the service software.
        public let newVersion: String?
        /// Whether the service software update is optional.
        public let optionalDeployment: Bool?
        /// Whether a service software update is available for the domain.
        public let updateAvailable: Bool?
        /// The status of the service software update. Valid values are as follows:    COMPLETED     ELIGIBLE     IN_PROGRESS     NOT_ELIGIBLE     PENDING_UPDATE
        public let updateStatus: String?

        public init(automatedUpdateDate: String? = nil, cancellable: Bool? = nil, currentVersion: String? = nil, description: String? = nil, newVersion: String? = nil, optionalDeployment: Bool? = nil, updateAvailable: Bool? = nil, updateStatus: String? = nil) {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.optionalDeployment = optionalDeployment
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.automatedUpdateDate, name: "automatedUpdateDate", parent: name, pattern: "\\S")
            try self.validate(self.currentVersion, name: "currentVersion", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.newVersion, name: "newVersion", parent: name, pattern: "\\S")
            try self.validate(self.updateStatus, name: "updateStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case automatedUpdateDate = "AutomatedUpdateDate"
            case cancellable = "Cancellable"
            case currentVersion = "CurrentVersion"
            case description = "Description"
            case newVersion = "NewVersion"
            case optionalDeployment = "OptionalDeployment"
            case updateAvailable = "UpdateAvailable"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct AwsOpenSearchServiceDomainVpcOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The list of security group IDs that are associated with the VPC endpoints for the domain.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs that are associated with the VPC endpoints for the domain.
        public let subnetIds: [String]?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "\\S")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct AwsRdsDbClusterAssociatedRole: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role.
        public let roleArn: String?
        /// The status of the association between the IAM role and the DB cluster. Valid values are as follows:    ACTIVE     INVALID     PENDING
        public let status: String?

        public init(roleArn: String? = nil, status: String? = nil) {
            self.roleArn = roleArn
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case status = "Status"
        }
    }

    public struct AwsRdsDbClusterDetails: AWSEncodableShape & AWSDecodableShape {
        /// The status of the database activity stream. Valid values are as follows:    started     starting     stopped     stopping
        public let activityStreamStatus: String?
        /// For all database engines except Aurora, specifies the allocated storage size in gibibytes (GiB).
        public let allocatedStorage: Int?
        /// A list of the IAM roles that are associated with the DB cluster.
        public let associatedRoles: [AwsRdsDbClusterAssociatedRole]?
        /// A list of Availability Zones (AZs) where instances in the DB cluster can be created.
        public let availabilityZones: [String]?
        /// The number of days for which automated backups are retained.
        public let backupRetentionPeriod: Int?
        /// Indicates when the DB cluster was created, in Universal Coordinated Time (UTC). Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let clusterCreateTime: String?
        /// Whether tags are copied from the DB cluster to snapshots of the DB cluster.
        public let copyTagsToSnapshot: Bool?
        /// Whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.
        public let crossAccountClone: Bool?
        /// A list of custom endpoints for the DB cluster.
        public let customEndpoints: [String]?
        /// The name of the database.
        public let databaseName: String?
        /// The DB cluster identifier that the user assigned to the cluster. This identifier is the unique key that identifies a DB cluster.
        public let dbClusterIdentifier: String?
        /// The list of instances that make up the DB cluster.
        public let dbClusterMembers: [AwsRdsDbClusterMember]?
        /// The list of option group memberships for this DB cluster.
        public let dbClusterOptionGroupMemberships: [AwsRdsDbClusterOptionGroupMembership]?
        /// The name of the DB cluster parameter group for the DB cluster.
        public let dbClusterParameterGroup: String?
        /// The identifier of the DB cluster. The identifier must be unique within each Amazon Web Services Region and is immutable.
        public let dbClusterResourceId: String?
        /// The subnet group that is associated with the DB cluster, including the name, description, and subnets in the subnet group.
        public let dbSubnetGroup: String?
        /// Whether the DB cluster has deletion protection enabled.
        public let deletionProtection: Bool?
        /// The Active Directory domain membership records that are associated with the DB cluster.
        public let domainMemberships: [AwsRdsDbDomainMembership]?
        /// A list of log types that this DB cluster is configured to export to CloudWatch Logs.
        public let enabledCloudWatchLogsExports: [String]?
        /// The connection endpoint for the primary instance of the DB cluster.
        public let endpoint: String?
        /// The name of the database engine to use for this DB cluster. Valid values are as follows:    aurora     aurora-mysql     aurora-postgresql
        public let engine: String?
        /// The database engine mode of the DB cluster.Valid values are as follows:    global     multimaster     parallelquery     provisioned     serverless
        public let engineMode: String?
        /// The version number of the database engine to use.
        public let engineVersion: String?
        /// Specifies the identifier that Amazon Route 53 assigns when you create a hosted zone.
        public let hostedZoneId: String?
        /// Whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.
        public let httpEndpointEnabled: Bool?
        /// Whether the mapping of IAM accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.
        public let kmsKeyId: String?
        /// The name of the master user for the DB cluster.
        public let masterUsername: String?
        /// Whether the DB cluster has instances in multiple Availability Zones.
        public let multiAz: Bool?
        /// The port number on which the DB instances in the DB cluster accept connections.
        public let port: Int?
        /// The range of time each day when automated backups are created, if automated backups are enabled. Uses the format HH:MM-HH:MM. For example, 04:52-05:22.
        public let preferredBackupWindow: String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Uses the format :HH:MM-:HH:MM. For the day values, use mon|tue|wed|thu|fri|sat|sun. For example, sun:09:32-sun:10:02.
        public let preferredMaintenanceWindow: String?
        /// The reader endpoint for the DB cluster.
        public let readerEndpoint: String?
        /// The identifiers of the read replicas that are associated with this DB cluster.
        public let readReplicaIdentifiers: [String]?
        /// The current status of this DB cluster.
        public let status: String?
        /// Whether the DB cluster is encrypted.
        public let storageEncrypted: Bool?
        /// A list of VPC security groups that the DB cluster belongs to.
        public let vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]?

        public init(activityStreamStatus: String? = nil, allocatedStorage: Int? = nil, associatedRoles: [AwsRdsDbClusterAssociatedRole]? = nil, availabilityZones: [String]? = nil, backupRetentionPeriod: Int? = nil, clusterCreateTime: String? = nil, copyTagsToSnapshot: Bool? = nil, crossAccountClone: Bool? = nil, customEndpoints: [String]? = nil, databaseName: String? = nil, dbClusterIdentifier: String? = nil, dbClusterMembers: [AwsRdsDbClusterMember]? = nil, dbClusterOptionGroupMemberships: [AwsRdsDbClusterOptionGroupMembership]? = nil, dbClusterParameterGroup: String? = nil, dbClusterResourceId: String? = nil, dbSubnetGroup: String? = nil, deletionProtection: Bool? = nil, domainMemberships: [AwsRdsDbDomainMembership]? = nil, enabledCloudWatchLogsExports: [String]? = nil, endpoint: String? = nil, engine: String? = nil, engineMode: String? = nil, engineVersion: String? = nil, hostedZoneId: String? = nil, httpEndpointEnabled: Bool? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, kmsKeyId: String? = nil, masterUsername: String? = nil, multiAz: Bool? = nil, port: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, readerEndpoint: String? = nil, readReplicaIdentifiers: [String]? = nil, status: String? = nil, storageEncrypted: Bool? = nil, vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]? = nil) {
            self.activityStreamStatus = activityStreamStatus
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.availabilityZones = availabilityZones
            self.backupRetentionPeriod = backupRetentionPeriod
            self.clusterCreateTime = clusterCreateTime
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.crossAccountClone = crossAccountClone
            self.customEndpoints = customEndpoints
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterMembers = dbClusterMembers
            self.dbClusterOptionGroupMemberships = dbClusterOptionGroupMemberships
            self.dbClusterParameterGroup = dbClusterParameterGroup
            self.dbClusterResourceId = dbClusterResourceId
            self.dbSubnetGroup = dbSubnetGroup
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudWatchLogsExports = enabledCloudWatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.hostedZoneId = hostedZoneId
            self.httpEndpointEnabled = httpEndpointEnabled
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.masterUsername = masterUsername
            self.multiAz = multiAz
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.readerEndpoint = readerEndpoint
            self.readReplicaIdentifiers = readReplicaIdentifiers
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.activityStreamStatus, name: "activityStreamStatus", parent: name, pattern: "\\S")
            try self.associatedRoles?.forEach {
                try $0.validate(name: "\(name).associatedRoles[]")
            }
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.clusterCreateTime, name: "clusterCreateTime", parent: name, pattern: "\\S")
            try self.customEndpoints?.forEach {
                try validate($0, name: "customEndpoints[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "\\S")
            try self.validate(self.dbClusterIdentifier, name: "dbClusterIdentifier", parent: name, pattern: "\\S")
            try self.dbClusterMembers?.forEach {
                try $0.validate(name: "\(name).dbClusterMembers[]")
            }
            try self.dbClusterOptionGroupMemberships?.forEach {
                try $0.validate(name: "\(name).dbClusterOptionGroupMemberships[]")
            }
            try self.validate(self.dbClusterParameterGroup, name: "dbClusterParameterGroup", parent: name, pattern: "\\S")
            try self.validate(self.dbClusterResourceId, name: "dbClusterResourceId", parent: name, pattern: "\\S")
            try self.validate(self.dbSubnetGroup, name: "dbSubnetGroup", parent: name, pattern: "\\S")
            try self.domainMemberships?.forEach {
                try $0.validate(name: "\(name).domainMemberships[]")
            }
            try self.enabledCloudWatchLogsExports?.forEach {
                try validate($0, name: "enabledCloudWatchLogsExports[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "\\S")
            try self.validate(self.engine, name: "engine", parent: name, pattern: "\\S")
            try self.validate(self.engineMode, name: "engineMode", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.masterUsername, name: "masterUsername", parent: name, pattern: "\\S")
            try self.validate(self.preferredBackupWindow, name: "preferredBackupWindow", parent: name, pattern: "\\S")
            try self.validate(self.preferredMaintenanceWindow, name: "preferredMaintenanceWindow", parent: name, pattern: "\\S")
            try self.validate(self.readerEndpoint, name: "readerEndpoint", parent: name, pattern: "\\S")
            try self.readReplicaIdentifiers?.forEach {
                try validate($0, name: "readReplicaIdentifiers[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.vpcSecurityGroups?.forEach {
                try $0.validate(name: "\(name).vpcSecurityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case activityStreamStatus = "ActivityStreamStatus"
            case allocatedStorage = "AllocatedStorage"
            case associatedRoles = "AssociatedRoles"
            case availabilityZones = "AvailabilityZones"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case clusterCreateTime = "ClusterCreateTime"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case crossAccountClone = "CrossAccountClone"
            case customEndpoints = "CustomEndpoints"
            case databaseName = "DatabaseName"
            case dbClusterIdentifier = "DbClusterIdentifier"
            case dbClusterMembers = "DbClusterMembers"
            case dbClusterOptionGroupMemberships = "DbClusterOptionGroupMemberships"
            case dbClusterParameterGroup = "DbClusterParameterGroup"
            case dbClusterResourceId = "DbClusterResourceId"
            case dbSubnetGroup = "DbSubnetGroup"
            case deletionProtection = "DeletionProtection"
            case domainMemberships = "DomainMemberships"
            case enabledCloudWatchLogsExports = "EnabledCloudWatchLogsExports"
            case endpoint = "Endpoint"
            case engine = "Engine"
            case engineMode = "EngineMode"
            case engineVersion = "EngineVersion"
            case hostedZoneId = "HostedZoneId"
            case httpEndpointEnabled = "HttpEndpointEnabled"
            case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
            case kmsKeyId = "KmsKeyId"
            case masterUsername = "MasterUsername"
            case multiAz = "MultiAz"
            case port = "Port"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case readerEndpoint = "ReaderEndpoint"
            case readReplicaIdentifiers = "ReadReplicaIdentifiers"
            case status = "Status"
            case storageEncrypted = "StorageEncrypted"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct AwsRdsDbClusterMember: AWSEncodableShape & AWSDecodableShape {
        /// The status of the DB cluster parameter group for this member of the DB cluster.
        public let dbClusterParameterGroupStatus: String?
        /// The instance identifier for this member of the DB cluster.
        public let dbInstanceIdentifier: String?
        /// Whether the cluster member is the primary instance for the DB cluster.
        public let isClusterWriter: Bool?
        /// Specifies the order in which an Aurora replica is promoted to the primary instance when the existing primary instance fails.
        public let promotionTier: Int?

        public init(dbClusterParameterGroupStatus: String? = nil, dbInstanceIdentifier: String? = nil, isClusterWriter: Bool? = nil, promotionTier: Int? = nil) {
            self.dbClusterParameterGroupStatus = dbClusterParameterGroupStatus
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.isClusterWriter = isClusterWriter
            self.promotionTier = promotionTier
        }

        public func validate(name: String) throws {
            try self.validate(self.dbClusterParameterGroupStatus, name: "dbClusterParameterGroupStatus", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupStatus = "DbClusterParameterGroupStatus"
            case dbInstanceIdentifier = "DbInstanceIdentifier"
            case isClusterWriter = "IsClusterWriter"
            case promotionTier = "PromotionTier"
        }
    }

    public struct AwsRdsDbClusterOptionGroupMembership: AWSEncodableShape & AWSDecodableShape {
        /// The name of the DB cluster option group.
        public let dbClusterOptionGroupName: String?
        /// The status of the DB cluster option group.
        public let status: String?

        public init(dbClusterOptionGroupName: String? = nil, status: String? = nil) {
            self.dbClusterOptionGroupName = dbClusterOptionGroupName
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.dbClusterOptionGroupName, name: "dbClusterOptionGroupName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterOptionGroupName = "DbClusterOptionGroupName"
            case status = "Status"
        }
    }

    public struct AwsRdsDbClusterSnapshotDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the allocated storage size in gibibytes (GiB).
        public let allocatedStorage: Int?
        /// A list of Availability Zones where instances in the DB cluster can be created.
        public let availabilityZones: [String]?
        /// Indicates when the DB cluster was created, in Universal Coordinated Time (UTC). Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let clusterCreateTime: String?
        /// The DB cluster identifier.
        public let dbClusterIdentifier: String?
        /// The identifier of the DB cluster snapshot.
        public let dbClusterSnapshotIdentifier: String?
        /// The name of the database engine that you want to use for this DB instance.
        public let engine: String?
        /// The version of the database engine to use.
        public let engineVersion: String?
        /// Whether mapping of IAM accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.
        public let kmsKeyId: String?
        /// The license model information for this DB cluster snapshot.
        public let licenseModel: String?
        /// The name of the master user for the DB cluster.
        public let masterUsername: String?
        /// Specifies the percentage of the estimated data that has been transferred.
        public let percentProgress: Int?
        /// The port number on which the DB instances in the DB cluster accept connections.
        public let port: Int?
        /// Indicates when the snapshot was taken. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let snapshotCreateTime: String?
        /// The type of DB cluster snapshot.
        public let snapshotType: String?
        /// The status of this DB cluster snapshot.
        public let status: String?
        /// Whether the DB cluster is encrypted.
        public let storageEncrypted: Bool?
        /// The VPC ID that is associated with the DB cluster snapshot.
        public let vpcId: String?

        public init(allocatedStorage: Int? = nil, availabilityZones: [String]? = nil, clusterCreateTime: String? = nil, dbClusterIdentifier: String? = nil, dbClusterSnapshotIdentifier: String? = nil, engine: String? = nil, engineVersion: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, kmsKeyId: String? = nil, licenseModel: String? = nil, masterUsername: String? = nil, percentProgress: Int? = nil, port: Int? = nil, snapshotCreateTime: String? = nil, snapshotType: String? = nil, status: String? = nil, storageEncrypted: Bool? = nil, vpcId: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.availabilityZones = availabilityZones
            self.clusterCreateTime = clusterCreateTime
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.percentProgress = percentProgress
            self.port = port
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.clusterCreateTime, name: "clusterCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.dbClusterIdentifier, name: "dbClusterIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbClusterSnapshotIdentifier, name: "dbClusterSnapshotIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.engine, name: "engine", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.licenseModel, name: "licenseModel", parent: name, pattern: "\\S")
            try self.validate(self.masterUsername, name: "masterUsername", parent: name, pattern: "\\S")
            try self.validate(self.snapshotCreateTime, name: "snapshotCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.snapshotType, name: "snapshotType", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case availabilityZones = "AvailabilityZones"
            case clusterCreateTime = "ClusterCreateTime"
            case dbClusterIdentifier = "DbClusterIdentifier"
            case dbClusterSnapshotIdentifier = "DbClusterSnapshotIdentifier"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
            case kmsKeyId = "KmsKeyId"
            case licenseModel = "LicenseModel"
            case masterUsername = "MasterUsername"
            case percentProgress = "PercentProgress"
            case port = "Port"
            case snapshotCreateTime = "SnapshotCreateTime"
            case snapshotType = "SnapshotType"
            case status = "Status"
            case storageEncrypted = "StorageEncrypted"
            case vpcId = "VpcId"
        }
    }

    public struct AwsRdsDbDomainMembership: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the Active Directory domain.
        public let domain: String?
        /// The fully qualified domain name of the Active Directory domain.
        public let fqdn: String?
        /// The name of the IAM role to use when making API calls to the Directory Service.
        public let iamRoleName: String?
        /// The status of the Active Directory Domain membership for the DB instance.
        public let status: String?

        public init(domain: String? = nil, fqdn: String? = nil, iamRoleName: String? = nil, status: String? = nil) {
            self.domain = domain
            self.fqdn = fqdn
            self.iamRoleName = iamRoleName
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, pattern: "\\S")
            try self.validate(self.fqdn, name: "fqdn", parent: name, pattern: "\\S")
            try self.validate(self.iamRoleName, name: "iamRoleName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
            case fqdn = "Fqdn"
            case iamRoleName = "IamRoleName"
            case status = "Status"
        }
    }

    public struct AwsRdsDbInstanceAssociatedRole: AWSEncodableShape & AWSDecodableShape {
        /// The name of the feature associated with the IAM role.
        public let featureName: String?
        /// The ARN of the IAM role that is associated with the DB instance.
        public let roleArn: String?
        /// Describes the state of the association between the IAM role and the DB instance. The Status property returns one of the following values:    ACTIVE - The IAM role ARN is associated with the DB instance and can be used to access other Amazon Web Services services on your behalf.    PENDING - The IAM role ARN is being associated with the DB instance.    INVALID - The IAM role ARN is associated with the DB instance. But the DB instance is unable to assume the IAM role in order to access other Amazon Web Services services on your behalf.
        public let status: String?

        public init(featureName: String? = nil, roleArn: String? = nil, status: String? = nil) {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.featureName, name: "featureName", parent: name, pattern: "\\S")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case featureName = "FeatureName"
            case roleArn = "RoleArn"
            case status = "Status"
        }
    }

    public struct AwsRdsDbInstanceDetails: AWSEncodableShape & AWSDecodableShape {
        /// The amount of storage (in gigabytes) to initially allocate for the DB instance.
        public let allocatedStorage: Int?
        /// The IAM roles associated with the DB instance.
        public let associatedRoles: [AwsRdsDbInstanceAssociatedRole]?
        /// Indicates whether minor version patches are applied automatically.
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone where the DB instance will be created.
        public let availabilityZone: String?
        /// The number of days for which to retain automated backups.
        public let backupRetentionPeriod: Int?
        /// The identifier of the CA certificate for this DB instance.
        public let caCertificateIdentifier: String?
        /// The name of the character set that this DB instance is associated with.
        public let characterSetName: String?
        /// Whether to copy resource tags to snapshots of the DB instance.
        public let copyTagsToSnapshot: Bool?
        /// If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.
        public let dbClusterIdentifier: String?
        /// Contains the name of the compute and memory capacity class of the DB instance.
        public let dbInstanceClass: String?
        /// Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.
        public let dbInstanceIdentifier: String?
        /// Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.
        public let dbInstancePort: Int?
        /// The current status of the DB instance.
        public let dbInstanceStatus: String?
        /// The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in CloudTrail log entries whenever the KMS key for the DB instance is accessed.
        public let dbiResourceId: String?
        /// The meaning of this parameter differs according to the database engine you use.  MySQL, MariaDB, SQL Server, PostgreSQL  Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance.  Oracle  Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance.
        public let dbName: String?
        /// A list of the DB parameter groups to assign to the DB instance.
        public let dbParameterGroups: [AwsRdsDbParameterGroup]?
        /// A list of the DB security groups to assign to the DB instance.
        public let dbSecurityGroups: [String]?
        /// Information about the subnet group that is associated with the DB instance.
        public let dbSubnetGroup: AwsRdsDbSubnetGroup?
        /// Indicates whether the DB instance has deletion protection enabled. When deletion protection is enabled, the database cannot be deleted.
        public let deletionProtection: Bool?
        /// The Active Directory domain membership records associated with the DB instance.
        public let domainMemberships: [AwsRdsDbDomainMembership]?
        /// A list of log types that this DB instance is configured to export to CloudWatch Logs.
        public let enabledCloudWatchLogsExports: [String]?
        /// Specifies the connection endpoint.
        public let endpoint: AwsRdsDbInstanceEndpoint?
        /// Provides the name of the database engine to use for this DB instance.
        public let engine: String?
        /// Indicates the database engine version.
        public let engineVersion: String?
        /// The ARN of the CloudWatch Logs log stream that receives the enhanced monitoring metrics data for the DB instance.
        public let enhancedMonitoringResourceArn: String?
        /// True if mapping of IAM accounts to database accounts is enabled, and otherwise false. IAM database authentication can be enabled for the following database engines.   For MySQL 5.6, minor version 5.6.34 or higher   For MySQL 5.7, minor version 5.7.16 or higher   Aurora 5.6 or higher
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// Indicates when the DB instance was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let instanceCreateTime: String?
        /// Specifies the provisioned IOPS (I/O operations per second) for this DB instance.
        public let iops: Int?
        /// If StorageEncrypted is true, the KMS key identifier for the encrypted DB instance.
        public let kmsKeyId: String?
        /// Specifies the latest time to which a database can be restored with point-in-time restore. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let latestRestorableTime: String?
        /// License model information for this DB instance.
        public let licenseModel: String?
        public let listenerEndpoint: AwsRdsDbInstanceEndpoint?
        /// The master user name of the DB instance.
        public let masterUsername: String?
        /// The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.
        public let maxAllocatedStorage: Int?
        /// The interval, in seconds, between points when enhanced monitoring metrics are collected for the DB instance.
        public let monitoringInterval: Int?
        /// The ARN for the IAM role that permits Amazon RDS to send enhanced monitoring metrics to CloudWatch Logs.
        public let monitoringRoleArn: String?
        /// Whether the DB instance is a multiple Availability Zone deployment.
        public let multiAz: Bool?
        /// The list of option group memberships for this DB instance.
        public let optionGroupMemberships: [AwsRdsDbOptionGroupMembership]?
        /// Changes to the DB instance that are currently pending.
        public let pendingModifiedValues: AwsRdsDbPendingModifiedValues?
        /// Indicates whether Performance Insights is enabled for the DB instance.
        public let performanceInsightsEnabled: Bool?
        /// The identifier of the KMS key used to encrypt the Performance Insights data.
        public let performanceInsightsKmsKeyId: String?
        /// The number of days to retain Performance Insights data.
        public let performanceInsightsRetentionPeriod: Int?
        /// The range of time each day when automated backups are created, if automated backups are enabled. Uses the format HH:MM-HH:MM. For example, 04:52-05:22.
        public let preferredBackupWindow: String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Uses the format :HH:MM-:HH:MM. For the day values, use mon|tue|wed|thu|fri|sat|sun. For example, sun:09:32-sun:10:02.
        public let preferredMaintenanceWindow: String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public let processorFeatures: [AwsRdsDbProcessorFeature]?
        /// The order in which to promote an Aurora replica to the primary instance after a failure of the existing primary instance.
        public let promotionTier: Int?
        /// Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address.
        public let publiclyAccessible: Bool?
        /// List of identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica.
        public let readReplicaDBClusterIdentifiers: [String]?
        /// List of identifiers of the read replicas associated with this DB instance.
        public let readReplicaDBInstanceIdentifiers: [String]?
        /// If this DB instance is a read replica, contains the identifier of the source DB instance.
        public let readReplicaSourceDBInstanceIdentifier: String?
        /// For a DB instance with multi-Availability Zone support, the name of the secondary Availability Zone.
        public let secondaryAvailabilityZone: String?
        /// The status of a read replica. If the instance isn't a read replica, this is empty.
        public let statusInfos: [AwsRdsDbStatusInfo]?
        /// Specifies whether the DB instance is encrypted.
        public let storageEncrypted: Bool?
        /// The storage type for the DB instance.
        public let storageType: String?
        /// The ARN from the key store with which the instance is associated for TDE encryption.
        public let tdeCredentialArn: String?
        /// The time zone of the DB instance.
        public let timezone: String?
        /// A list of VPC security groups that the DB instance belongs to.
        public let vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]?

        public init(allocatedStorage: Int? = nil, associatedRoles: [AwsRdsDbInstanceAssociatedRole]? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, backupRetentionPeriod: Int? = nil, caCertificateIdentifier: String? = nil, characterSetName: String? = nil, copyTagsToSnapshot: Bool? = nil, dbClusterIdentifier: String? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbInstancePort: Int? = nil, dbInstanceStatus: String? = nil, dbiResourceId: String? = nil, dbName: String? = nil, dbParameterGroups: [AwsRdsDbParameterGroup]? = nil, dbSecurityGroups: [String]? = nil, dbSubnetGroup: AwsRdsDbSubnetGroup? = nil, deletionProtection: Bool? = nil, domainMemberships: [AwsRdsDbDomainMembership]? = nil, enabledCloudWatchLogsExports: [String]? = nil, endpoint: AwsRdsDbInstanceEndpoint? = nil, engine: String? = nil, engineVersion: String? = nil, enhancedMonitoringResourceArn: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, instanceCreateTime: String? = nil, iops: Int? = nil, kmsKeyId: String? = nil, latestRestorableTime: String? = nil, licenseModel: String? = nil, listenerEndpoint: AwsRdsDbInstanceEndpoint? = nil, masterUsername: String? = nil, maxAllocatedStorage: Int? = nil, monitoringInterval: Int? = nil, monitoringRoleArn: String? = nil, multiAz: Bool? = nil, optionGroupMemberships: [AwsRdsDbOptionGroupMembership]? = nil, pendingModifiedValues: AwsRdsDbPendingModifiedValues? = nil, performanceInsightsEnabled: Bool? = nil, performanceInsightsKmsKeyId: String? = nil, performanceInsightsRetentionPeriod: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, processorFeatures: [AwsRdsDbProcessorFeature]? = nil, promotionTier: Int? = nil, publiclyAccessible: Bool? = nil, readReplicaDBClusterIdentifiers: [String]? = nil, readReplicaDBInstanceIdentifiers: [String]? = nil, readReplicaSourceDBInstanceIdentifier: String? = nil, secondaryAvailabilityZone: String? = nil, statusInfos: [AwsRdsDbStatusInfo]? = nil, storageEncrypted: Bool? = nil, storageType: String? = nil, tdeCredentialArn: String? = nil, timezone: String? = nil, vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbInstancePort = dbInstancePort
            self.dbInstanceStatus = dbInstanceStatus
            self.dbiResourceId = dbiResourceId
            self.dbName = dbName
            self.dbParameterGroups = dbParameterGroups
            self.dbSecurityGroups = dbSecurityGroups
            self.dbSubnetGroup = dbSubnetGroup
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudWatchLogsExports = enabledCloudWatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineVersion = engineVersion
            self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.licenseModel = licenseModel
            self.listenerEndpoint = listenerEndpoint
            self.masterUsername = masterUsername
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAz = multiAz
            self.optionGroupMemberships = optionGroupMemberships
            self.pendingModifiedValues = pendingModifiedValues
            self.performanceInsightsEnabled = performanceInsightsEnabled
            self.performanceInsightsKmsKeyId = performanceInsightsKmsKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.processorFeatures = processorFeatures
            self.promotionTier = promotionTier
            self.publiclyAccessible = publiclyAccessible
            self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
            self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
            self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.statusInfos = statusInfos
            self.storageEncrypted = storageEncrypted
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        public func validate(name: String) throws {
            try self.associatedRoles?.forEach {
                try $0.validate(name: "\(name).associatedRoles[]")
            }
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.caCertificateIdentifier, name: "caCertificateIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.characterSetName, name: "characterSetName", parent: name, pattern: "\\S")
            try self.validate(self.dbClusterIdentifier, name: "dbClusterIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceClass, name: "dbInstanceClass", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceStatus, name: "dbInstanceStatus", parent: name, pattern: "\\S")
            try self.validate(self.dbiResourceId, name: "dbiResourceId", parent: name, pattern: "\\S")
            try self.validate(self.dbName, name: "dbName", parent: name, pattern: "\\S")
            try self.dbParameterGroups?.forEach {
                try $0.validate(name: "\(name).dbParameterGroups[]")
            }
            try self.dbSecurityGroups?.forEach {
                try validate($0, name: "dbSecurityGroups[]", parent: name, pattern: "\\S")
            }
            try self.dbSubnetGroup?.validate(name: "\(name).dbSubnetGroup")
            try self.domainMemberships?.forEach {
                try $0.validate(name: "\(name).domainMemberships[]")
            }
            try self.enabledCloudWatchLogsExports?.forEach {
                try validate($0, name: "enabledCloudWatchLogsExports[]", parent: name, pattern: "\\S")
            }
            try self.endpoint?.validate(name: "\(name).endpoint")
            try self.validate(self.engine, name: "engine", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.enhancedMonitoringResourceArn, name: "enhancedMonitoringResourceArn", parent: name, pattern: "\\S")
            try self.validate(self.instanceCreateTime, name: "instanceCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.latestRestorableTime, name: "latestRestorableTime", parent: name, pattern: "\\S")
            try self.validate(self.licenseModel, name: "licenseModel", parent: name, pattern: "\\S")
            try self.listenerEndpoint?.validate(name: "\(name).listenerEndpoint")
            try self.validate(self.masterUsername, name: "masterUsername", parent: name, pattern: "\\S")
            try self.validate(self.monitoringRoleArn, name: "monitoringRoleArn", parent: name, pattern: "\\S")
            try self.optionGroupMemberships?.forEach {
                try $0.validate(name: "\(name).optionGroupMemberships[]")
            }
            try self.pendingModifiedValues?.validate(name: "\(name).pendingModifiedValues")
            try self.validate(self.performanceInsightsKmsKeyId, name: "performanceInsightsKmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.preferredBackupWindow, name: "preferredBackupWindow", parent: name, pattern: "\\S")
            try self.validate(self.preferredMaintenanceWindow, name: "preferredMaintenanceWindow", parent: name, pattern: "\\S")
            try self.processorFeatures?.forEach {
                try $0.validate(name: "\(name).processorFeatures[]")
            }
            try self.readReplicaDBClusterIdentifiers?.forEach {
                try validate($0, name: "readReplicaDBClusterIdentifiers[]", parent: name, pattern: "\\S")
            }
            try self.readReplicaDBInstanceIdentifiers?.forEach {
                try validate($0, name: "readReplicaDBInstanceIdentifiers[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.readReplicaSourceDBInstanceIdentifier, name: "readReplicaSourceDBInstanceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.secondaryAvailabilityZone, name: "secondaryAvailabilityZone", parent: name, pattern: "\\S")
            try self.statusInfos?.forEach {
                try $0.validate(name: "\(name).statusInfos[]")
            }
            try self.validate(self.storageType, name: "storageType", parent: name, pattern: "\\S")
            try self.validate(self.tdeCredentialArn, name: "tdeCredentialArn", parent: name, pattern: "\\S")
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: "\\S")
            try self.vpcSecurityGroups?.forEach {
                try $0.validate(name: "\(name).vpcSecurityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case associatedRoles = "AssociatedRoles"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case caCertificateIdentifier = "CACertificateIdentifier"
            case characterSetName = "CharacterSetName"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbInstanceClass = "DBInstanceClass"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbInstancePort = "DbInstancePort"
            case dbInstanceStatus = "DbInstanceStatus"
            case dbiResourceId = "DbiResourceId"
            case dbName = "DBName"
            case dbParameterGroups = "DbParameterGroups"
            case dbSecurityGroups = "DbSecurityGroups"
            case dbSubnetGroup = "DbSubnetGroup"
            case deletionProtection = "DeletionProtection"
            case domainMemberships = "DomainMemberships"
            case enabledCloudWatchLogsExports = "EnabledCloudWatchLogsExports"
            case endpoint = "Endpoint"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case enhancedMonitoringResourceArn = "EnhancedMonitoringResourceArn"
            case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case instanceCreateTime = "InstanceCreateTime"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case latestRestorableTime = "LatestRestorableTime"
            case licenseModel = "LicenseModel"
            case listenerEndpoint = "ListenerEndpoint"
            case masterUsername = "MasterUsername"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case monitoringInterval = "MonitoringInterval"
            case monitoringRoleArn = "MonitoringRoleArn"
            case multiAz = "MultiAz"
            case optionGroupMemberships = "OptionGroupMemberships"
            case pendingModifiedValues = "PendingModifiedValues"
            case performanceInsightsEnabled = "PerformanceInsightsEnabled"
            case performanceInsightsKmsKeyId = "PerformanceInsightsKmsKeyId"
            case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case processorFeatures = "ProcessorFeatures"
            case promotionTier = "PromotionTier"
            case publiclyAccessible = "PubliclyAccessible"
            case readReplicaDBClusterIdentifiers = "ReadReplicaDBClusterIdentifiers"
            case readReplicaDBInstanceIdentifiers = "ReadReplicaDBInstanceIdentifiers"
            case readReplicaSourceDBInstanceIdentifier = "ReadReplicaSourceDBInstanceIdentifier"
            case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
            case statusInfos = "StatusInfos"
            case storageEncrypted = "StorageEncrypted"
            case storageType = "StorageType"
            case tdeCredentialArn = "TdeCredentialArn"
            case timezone = "Timezone"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct AwsRdsDbInstanceEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the DNS address of the DB instance.
        public let address: String?
        /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        public let hostedZoneId: String?
        /// Specifies the port that the database engine is listening on.
        public let port: Int?

        public init(address: String? = nil, hostedZoneId: String? = nil, port: Int? = nil) {
            self.address = address
            self.hostedZoneId = hostedZoneId
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, pattern: "\\S")
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case hostedZoneId = "HostedZoneId"
            case port = "Port"
        }
    }

    public struct AwsRdsDbInstanceVpcSecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// The status of the VPC security group.
        public let status: String?
        /// The name of the VPC security group.
        public let vpcSecurityGroupId: String?

        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.vpcSecurityGroupId, name: "vpcSecurityGroupId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }

    public struct AwsRdsDbOptionGroupMembership: AWSEncodableShape & AWSDecodableShape {
        /// The name of the option group.
        public let optionGroupName: String?
        /// The status of the option group membership.
        public let status: String?

        public init(optionGroupName: String? = nil, status: String? = nil) {
            self.optionGroupName = optionGroupName
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.optionGroupName, name: "optionGroupName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case optionGroupName = "OptionGroupName"
            case status = "Status"
        }
    }

    public struct AwsRdsDbParameterGroup: AWSEncodableShape & AWSDecodableShape {
        /// The name of the parameter group.
        public let dbParameterGroupName: String?
        /// The status of parameter updates.
        public let parameterApplyStatus: String?

        public init(dbParameterGroupName: String? = nil, parameterApplyStatus: String? = nil) {
            self.dbParameterGroupName = dbParameterGroupName
            self.parameterApplyStatus = parameterApplyStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.dbParameterGroupName, name: "dbParameterGroupName", parent: name, pattern: "\\S")
            try self.validate(self.parameterApplyStatus, name: "parameterApplyStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupName = "DbParameterGroupName"
            case parameterApplyStatus = "ParameterApplyStatus"
        }
    }

    public struct AwsRdsDbPendingModifiedValues: AWSEncodableShape & AWSDecodableShape {
        /// The new value of the allocated storage for the DB instance.
        public let allocatedStorage: Int?
        /// The new backup retention period for the DB instance.
        public let backupRetentionPeriod: Int?
        /// The new CA certificate identifier for the DB instance.
        public let caCertificateIdentifier: String?
        /// The new DB instance class for the DB instance.
        public let dbInstanceClass: String?
        /// The new DB instance identifier for the DB instance.
        public let dbInstanceIdentifier: String?
        /// The name of the new subnet group for the DB instance.
        public let dbSubnetGroupName: String?
        /// The new engine version for the DB instance.
        public let engineVersion: String?
        /// The new provisioned IOPS value for the DB instance.
        public let iops: Int?
        /// The new license model value for the DB instance.
        public let licenseModel: String?
        /// The new master user password for the DB instance.
        public let masterUserPassword: String?
        /// Indicates that a single Availability Zone DB instance is changing to a multiple Availability Zone deployment.
        public let multiAZ: Bool?
        /// A list of log types that are being enabled or disabled.
        public let pendingCloudWatchLogsExports: AwsRdsPendingCloudWatchLogsExports?
        /// The new port for the DB instance.
        public let port: Int?
        /// Processor features that are being updated.
        public let processorFeatures: [AwsRdsDbProcessorFeature]?
        /// The new storage type for the DB instance.
        public let storageType: String?

        public init(allocatedStorage: Int? = nil, backupRetentionPeriod: Int? = nil, caCertificateIdentifier: String? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbSubnetGroupName: String? = nil, engineVersion: String? = nil, iops: Int? = nil, licenseModel: String? = nil, masterUserPassword: String? = nil, multiAZ: Bool? = nil, pendingCloudWatchLogsExports: AwsRdsPendingCloudWatchLogsExports? = nil, port: Int? = nil, processorFeatures: [AwsRdsDbProcessorFeature]? = nil, storageType: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbSubnetGroupName = dbSubnetGroupName
            self.engineVersion = engineVersion
            self.iops = iops
            self.licenseModel = licenseModel
            self.masterUserPassword = masterUserPassword
            self.multiAZ = multiAZ
            self.pendingCloudWatchLogsExports = pendingCloudWatchLogsExports
            self.port = port
            self.processorFeatures = processorFeatures
            self.storageType = storageType
        }

        public func validate(name: String) throws {
            try self.validate(self.caCertificateIdentifier, name: "caCertificateIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceClass, name: "dbInstanceClass", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbSubnetGroupName, name: "dbSubnetGroupName", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.licenseModel, name: "licenseModel", parent: name, pattern: "\\S")
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, pattern: "\\S")
            try self.pendingCloudWatchLogsExports?.validate(name: "\(name).pendingCloudWatchLogsExports")
            try self.processorFeatures?.forEach {
                try $0.validate(name: "\(name).processorFeatures[]")
            }
            try self.validate(self.storageType, name: "storageType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case caCertificateIdentifier = "CaCertificateIdentifier"
            case dbInstanceClass = "DbInstanceClass"
            case dbInstanceIdentifier = "DbInstanceIdentifier"
            case dbSubnetGroupName = "DbSubnetGroupName"
            case engineVersion = "EngineVersion"
            case iops = "Iops"
            case licenseModel = "LicenseModel"
            case masterUserPassword = "MasterUserPassword"
            case multiAZ = "MultiAZ"
            case pendingCloudWatchLogsExports = "PendingCloudWatchLogsExports"
            case port = "Port"
            case processorFeatures = "ProcessorFeatures"
            case storageType = "StorageType"
        }
    }

    public struct AwsRdsDbProcessorFeature: AWSEncodableShape & AWSDecodableShape {
        /// The name of the processor feature. Valid values are coreCount or threadsPerCore.
        public let name: String?
        /// The value of the processor feature.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsRdsDbSecurityGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN for the DB security group.
        public let dbSecurityGroupArn: String?
        /// Provides the description of the DB security group.
        public let dbSecurityGroupDescription: String?
        /// Specifies the name of the DB security group.
        public let dbSecurityGroupName: String?
        /// Contains a list of EC2 security groups.
        public let ec2SecurityGroups: [AwsRdsDbSecurityGroupEc2SecurityGroup]?
        /// Contains a list of IP ranges.
        public let ipRanges: [AwsRdsDbSecurityGroupIpRange]?
        /// Provides the Amazon Web Services ID of the owner of a specific DB security group.
        public let ownerId: String?
        /// Provides VPC ID associated with the DB security group.
        public let vpcId: String?

        public init(dbSecurityGroupArn: String? = nil, dbSecurityGroupDescription: String? = nil, dbSecurityGroupName: String? = nil, ec2SecurityGroups: [AwsRdsDbSecurityGroupEc2SecurityGroup]? = nil, ipRanges: [AwsRdsDbSecurityGroupIpRange]? = nil, ownerId: String? = nil, vpcId: String? = nil) {
            self.dbSecurityGroupArn = dbSecurityGroupArn
            self.dbSecurityGroupDescription = dbSecurityGroupDescription
            self.dbSecurityGroupName = dbSecurityGroupName
            self.ec2SecurityGroups = ec2SecurityGroups
            self.ipRanges = ipRanges
            self.ownerId = ownerId
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.dbSecurityGroupArn, name: "dbSecurityGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.dbSecurityGroupDescription, name: "dbSecurityGroupDescription", parent: name, pattern: "\\S")
            try self.validate(self.dbSecurityGroupName, name: "dbSecurityGroupName", parent: name, pattern: "\\S")
            try self.ec2SecurityGroups?.forEach {
                try $0.validate(name: "\(name).ec2SecurityGroups[]")
            }
            try self.ipRanges?.forEach {
                try $0.validate(name: "\(name).ipRanges[]")
            }
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroupArn = "DbSecurityGroupArn"
            case dbSecurityGroupDescription = "DbSecurityGroupDescription"
            case dbSecurityGroupName = "DbSecurityGroupName"
            case ec2SecurityGroups = "Ec2SecurityGroups"
            case ipRanges = "IpRanges"
            case ownerId = "OwnerId"
            case vpcId = "VpcId"
        }
    }

    public struct AwsRdsDbSecurityGroupEc2SecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the ID for the EC2 security group.
        public let ec2SecurityGroupId: String?
        /// Specifies the name of the EC2 security group.
        public let ec2SecurityGroupName: String?
        /// Provides the Amazon Web Services ID of the owner of the EC2 security group.
        public let ec2SecurityGroupOwnerId: String?
        /// Provides the status of the EC2 security group.
        public let status: String?

        public init(ec2SecurityGroupId: String? = nil, ec2SecurityGroupName: String? = nil, ec2SecurityGroupOwnerId: String? = nil, status: String? = nil) {
            self.ec2SecurityGroupId = ec2SecurityGroupId
            self.ec2SecurityGroupName = ec2SecurityGroupName
            self.ec2SecurityGroupOwnerId = ec2SecurityGroupOwnerId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.ec2SecurityGroupId, name: "ec2SecurityGroupId", parent: name, pattern: "\\S")
            try self.validate(self.ec2SecurityGroupName, name: "ec2SecurityGroupName", parent: name, pattern: "\\S")
            try self.validate(self.ec2SecurityGroupOwnerId, name: "ec2SecurityGroupOwnerId", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ec2SecurityGroupId = "Ec2SecurityGroupId"
            case ec2SecurityGroupName = "Ec2SecurityGroupName"
            case ec2SecurityGroupOwnerId = "Ec2SecurityGroupOwnerId"
            case status = "Status"
        }
    }

    public struct AwsRdsDbSecurityGroupIpRange: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the IP range.
        public let cidrIp: String?
        /// Specifies the status of the IP range.
        public let status: String?

        public init(cidrIp: String? = nil, status: String? = nil) {
            self.cidrIp = cidrIp
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrIp, name: "cidrIp", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrIp = "CidrIp"
            case status = "Status"
        }
    }

    public struct AwsRdsDbSnapshotDetails: AWSEncodableShape & AWSDecodableShape {
        /// The amount of storage (in gigabytes) to be initially allocated for the database instance.
        public let allocatedStorage: Int?
        /// Specifies the name of the Availability Zone in which the DB instance was located at the time of the DB snapshot.
        public let availabilityZone: String?
        /// A name for the DB instance.
        public let dbInstanceIdentifier: String?
        /// The identifier for the source DB instance.
        public let dbiResourceId: String?
        /// The name or ARN of the DB snapshot that is used to restore the DB instance.
        public let dbSnapshotIdentifier: String?
        /// Whether the DB snapshot is encrypted.
        public let encrypted: Bool?
        /// The name of the database engine to use for this DB instance. Valid values are as follows:    aurora     aurora-mysql     aurora-postgresql     c     mariadb     mysql     oracle-ee     oracle-se     oracle-se1     oracle-se2     sqlserver-ee     sqlserver-ex     sqlserver-se     sqlserver-web
        public let engine: String?
        /// The version of the database engine.
        public let engineVersion: String?
        /// Whether mapping of IAM accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.
        public let instanceCreateTime: String?
        /// The provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.
        public let iops: Int?
        /// If Encrypted is true, the KMS key identifier for the encrypted DB snapshot.
        public let kmsKeyId: String?
        /// License model information for the restored DB instance.
        public let licenseModel: String?
        /// The master user name for the DB snapshot.
        public let masterUsername: String?
        /// The option group name for the DB snapshot.
        public let optionGroupName: String?
        /// The percentage of the estimated data that has been transferred.
        public let percentProgress: Int?
        /// The port that the database engine was listening on at the time of the snapshot.
        public let port: Int?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public let processorFeatures: [AwsRdsDbProcessorFeature]?
        /// When the snapshot was taken in Coordinated Universal Time (UTC).
        public let snapshotCreateTime: String?
        /// The type of the DB snapshot.
        public let snapshotType: String?
        /// The DB snapshot ARN that the DB snapshot was copied from.
        public let sourceDbSnapshotIdentifier: String?
        /// The Amazon Web Services Region that the DB snapshot was created in or copied from.
        public let sourceRegion: String?
        /// The status of this DB snapshot.
        public let status: String?
        /// The storage type associated with the DB snapshot. Valid values are as follows:    gp2     io1     standard
        public let storageType: String?
        /// The ARN from the key store with which to associate the instance for TDE encryption.
        public let tdeCredentialArn: String?
        /// The time zone of the DB snapshot.
        public let timezone: String?
        /// The VPC ID associated with the DB snapshot.
        public let vpcId: String?

        public init(allocatedStorage: Int? = nil, availabilityZone: String? = nil, dbInstanceIdentifier: String? = nil, dbiResourceId: String? = nil, dbSnapshotIdentifier: String? = nil, encrypted: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, instanceCreateTime: String? = nil, iops: Int? = nil, kmsKeyId: String? = nil, licenseModel: String? = nil, masterUsername: String? = nil, optionGroupName: String? = nil, percentProgress: Int? = nil, port: Int? = nil, processorFeatures: [AwsRdsDbProcessorFeature]? = nil, snapshotCreateTime: String? = nil, snapshotType: String? = nil, sourceDbSnapshotIdentifier: String? = nil, sourceRegion: String? = nil, status: String? = nil, storageType: String? = nil, tdeCredentialArn: String? = nil, timezone: String? = nil, vpcId: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.availabilityZone = availabilityZone
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.encrypted = encrypted
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.optionGroupName = optionGroupName
            self.percentProgress = percentProgress
            self.port = port
            self.processorFeatures = processorFeatures
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.sourceDbSnapshotIdentifier = sourceDbSnapshotIdentifier
            self.sourceRegion = sourceRegion
            self.status = status
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbiResourceId, name: "dbiResourceId", parent: name, pattern: "\\S")
            try self.validate(self.dbSnapshotIdentifier, name: "dbSnapshotIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.engine, name: "engine", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.instanceCreateTime, name: "instanceCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.licenseModel, name: "licenseModel", parent: name, pattern: "\\S")
            try self.validate(self.masterUsername, name: "masterUsername", parent: name, pattern: "\\S")
            try self.validate(self.optionGroupName, name: "optionGroupName", parent: name, pattern: "\\S")
            try self.processorFeatures?.forEach {
                try $0.validate(name: "\(name).processorFeatures[]")
            }
            try self.validate(self.snapshotCreateTime, name: "snapshotCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.snapshotType, name: "snapshotType", parent: name, pattern: "\\S")
            try self.validate(self.sourceDbSnapshotIdentifier, name: "sourceDbSnapshotIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.sourceRegion, name: "sourceRegion", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.storageType, name: "storageType", parent: name, pattern: "\\S")
            try self.validate(self.tdeCredentialArn, name: "tdeCredentialArn", parent: name, pattern: "\\S")
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case availabilityZone = "AvailabilityZone"
            case dbInstanceIdentifier = "DbInstanceIdentifier"
            case dbiResourceId = "DbiResourceId"
            case dbSnapshotIdentifier = "DbSnapshotIdentifier"
            case encrypted = "Encrypted"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
            case instanceCreateTime = "InstanceCreateTime"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case licenseModel = "LicenseModel"
            case masterUsername = "MasterUsername"
            case optionGroupName = "OptionGroupName"
            case percentProgress = "PercentProgress"
            case port = "Port"
            case processorFeatures = "ProcessorFeatures"
            case snapshotCreateTime = "SnapshotCreateTime"
            case snapshotType = "SnapshotType"
            case sourceDbSnapshotIdentifier = "SourceDbSnapshotIdentifier"
            case sourceRegion = "SourceRegion"
            case status = "Status"
            case storageType = "StorageType"
            case tdeCredentialArn = "TdeCredentialArn"
            case timezone = "Timezone"
            case vpcId = "VpcId"
        }
    }

    public struct AwsRdsDbStatusInfo: AWSEncodableShape & AWSDecodableShape {
        /// If the read replica is currently in an error state, provides the error details.
        public let message: String?
        /// Whether the read replica instance is operating normally.
        public let normal: Bool?
        /// The status of the read replica instance.
        public let status: String?
        /// The type of status. For a read replica, the status type is read replication.
        public let statusType: String?

        public init(message: String? = nil, normal: Bool? = nil, status: String? = nil, statusType: String? = nil) {
            self.message = message
            self.normal = normal
            self.status = status
            self.statusType = statusType
        }

        public func validate(name: String) throws {
            try self.validate(self.message, name: "message", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.statusType, name: "statusType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case normal = "Normal"
            case status = "Status"
            case statusType = "StatusType"
        }
    }

    public struct AwsRdsDbSubnetGroup: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the subnet group.
        public let dbSubnetGroupArn: String?
        /// The description of the subnet group.
        public let dbSubnetGroupDescription: String?
        /// The name of the subnet group.
        public let dbSubnetGroupName: String?
        /// The status of the subnet group.
        public let subnetGroupStatus: String?
        /// A list of subnets in the subnet group.
        public let subnets: [AwsRdsDbSubnetGroupSubnet]?
        /// The VPC ID of the subnet group.
        public let vpcId: String?

        public init(dbSubnetGroupArn: String? = nil, dbSubnetGroupDescription: String? = nil, dbSubnetGroupName: String? = nil, subnetGroupStatus: String? = nil, subnets: [AwsRdsDbSubnetGroupSubnet]? = nil, vpcId: String? = nil) {
            self.dbSubnetGroupArn = dbSubnetGroupArn
            self.dbSubnetGroupDescription = dbSubnetGroupDescription
            self.dbSubnetGroupName = dbSubnetGroupName
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.dbSubnetGroupArn, name: "dbSubnetGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.dbSubnetGroupDescription, name: "dbSubnetGroupDescription", parent: name, pattern: "\\S")
            try self.validate(self.dbSubnetGroupName, name: "dbSubnetGroupName", parent: name, pattern: "\\S")
            try self.validate(self.subnetGroupStatus, name: "subnetGroupStatus", parent: name, pattern: "\\S")
            try self.subnets?.forEach {
                try $0.validate(name: "\(name).subnets[]")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dbSubnetGroupArn = "DbSubnetGroupArn"
            case dbSubnetGroupDescription = "DbSubnetGroupDescription"
            case dbSubnetGroupName = "DbSubnetGroupName"
            case subnetGroupStatus = "SubnetGroupStatus"
            case subnets = "Subnets"
            case vpcId = "VpcId"
        }
    }

    public struct AwsRdsDbSubnetGroupSubnet: AWSEncodableShape & AWSDecodableShape {
        /// Information about the Availability Zone for a subnet in the subnet group.
        public let subnetAvailabilityZone: AwsRdsDbSubnetGroupSubnetAvailabilityZone?
        /// The identifier of a subnet in the subnet group.
        public let subnetIdentifier: String?
        /// The status of a subnet in the subnet group.
        public let subnetStatus: String?

        public init(subnetAvailabilityZone: AwsRdsDbSubnetGroupSubnetAvailabilityZone? = nil, subnetIdentifier: String? = nil, subnetStatus: String? = nil) {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }

        public func validate(name: String) throws {
            try self.subnetAvailabilityZone?.validate(name: "\(name).subnetAvailabilityZone")
            try self.validate(self.subnetIdentifier, name: "subnetIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.subnetStatus, name: "subnetStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case subnetAvailabilityZone = "SubnetAvailabilityZone"
            case subnetIdentifier = "SubnetIdentifier"
            case subnetStatus = "SubnetStatus"
        }
    }

    public struct AwsRdsDbSubnetGroupSubnetAvailabilityZone: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Availability Zone for a subnet in the subnet group.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct AwsRdsEventSubscriptionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the event notification subscription.
        public let customerAwsId: String?
        /// The identifier of the account that is associated with the event notification subscription.
        public let custSubscriptionId: String?
        /// Whether the event notification subscription is enabled.
        public let enabled: Bool?
        /// The list of event categories for the event notification subscription.
        public let eventCategoriesList: [String]?
        /// The ARN of the event notification subscription.
        public let eventSubscriptionArn: String?
        /// The ARN of the SNS topic to post the event notifications to.
        public let snsTopicArn: String?
        /// A list of source identifiers for the event notification subscription.
        public let sourceIdsList: [String]?
        /// The source type for the event notification subscription.
        public let sourceType: String?
        /// The status of the event notification subscription. Valid values: creating | modifying | deleting | active | no-permission | topic-not-exist
        public let status: String?
        /// The datetime when the event notification subscription was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let subscriptionCreationTime: String?

        public init(customerAwsId: String? = nil, custSubscriptionId: String? = nil, enabled: Bool? = nil, eventCategoriesList: [String]? = nil, eventSubscriptionArn: String? = nil, snsTopicArn: String? = nil, sourceIdsList: [String]? = nil, sourceType: String? = nil, status: String? = nil, subscriptionCreationTime: String? = nil) {
            self.customerAwsId = customerAwsId
            self.custSubscriptionId = custSubscriptionId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.eventSubscriptionArn = eventSubscriptionArn
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }

        public func validate(name: String) throws {
            try self.validate(self.customerAwsId, name: "customerAwsId", parent: name, pattern: "\\S")
            try self.validate(self.custSubscriptionId, name: "custSubscriptionId", parent: name, pattern: "\\S")
            try self.eventCategoriesList?.forEach {
                try validate($0, name: "eventCategoriesList[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.eventSubscriptionArn, name: "eventSubscriptionArn", parent: name, pattern: "\\S")
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "\\S")
            try self.sourceIdsList?.forEach {
                try validate($0, name: "sourceIdsList[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.sourceType, name: "sourceType", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.subscriptionCreationTime, name: "subscriptionCreationTime", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case customerAwsId = "CustomerAwsId"
            case custSubscriptionId = "CustSubscriptionId"
            case enabled = "Enabled"
            case eventCategoriesList = "EventCategoriesList"
            case eventSubscriptionArn = "EventSubscriptionArn"
            case snsTopicArn = "SnsTopicArn"
            case sourceIdsList = "SourceIdsList"
            case sourceType = "SourceType"
            case status = "Status"
            case subscriptionCreationTime = "SubscriptionCreationTime"
        }
    }

    public struct AwsRdsPendingCloudWatchLogsExports: AWSEncodableShape & AWSDecodableShape {
        /// A list of log types that are being disabled.
        public let logTypesToDisable: [String]?
        /// A list of log types that are being enabled.
        public let logTypesToEnable: [String]?

        public init(logTypesToDisable: [String]? = nil, logTypesToEnable: [String]? = nil) {
            self.logTypesToDisable = logTypesToDisable
            self.logTypesToEnable = logTypesToEnable
        }

        public func validate(name: String) throws {
            try self.logTypesToDisable?.forEach {
                try validate($0, name: "logTypesToDisable[]", parent: name, pattern: "\\S")
            }
            try self.logTypesToEnable?.forEach {
                try validate($0, name: "logTypesToEnable[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case logTypesToDisable = "LogTypesToDisable"
            case logTypesToEnable = "LogTypesToEnable"
        }
    }

    public struct AwsRedshiftClusterClusterNode: AWSEncodableShape & AWSDecodableShape {
        /// The role of the node. A node might be a leader node or a compute node.
        public let nodeRole: String?
        /// The private IP address of the node.
        public let privateIpAddress: String?
        /// The public IP address of the node.
        public let publicIpAddress: String?

        public init(nodeRole: String? = nil, privateIpAddress: String? = nil, publicIpAddress: String? = nil) {
            self.nodeRole = nodeRole
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.nodeRole, name: "nodeRole", parent: name, pattern: "\\S")
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "\\S")
            try self.validate(self.publicIpAddress, name: "publicIpAddress", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case nodeRole = "NodeRole"
            case privateIpAddress = "PrivateIpAddress"
            case publicIpAddress = "PublicIpAddress"
        }
    }

    public struct AwsRedshiftClusterClusterParameterGroup: AWSEncodableShape & AWSDecodableShape {
        /// The list of parameter statuses.
        public let clusterParameterStatusList: [AwsRedshiftClusterClusterParameterStatus]?
        /// The status of updates to the parameters.
        public let parameterApplyStatus: String?
        /// The name of the parameter group.
        public let parameterGroupName: String?

        public init(clusterParameterStatusList: [AwsRedshiftClusterClusterParameterStatus]? = nil, parameterApplyStatus: String? = nil, parameterGroupName: String? = nil) {
            self.clusterParameterStatusList = clusterParameterStatusList
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterGroupName = parameterGroupName
        }

        public func validate(name: String) throws {
            try self.clusterParameterStatusList?.forEach {
                try $0.validate(name: "\(name).clusterParameterStatusList[]")
            }
            try self.validate(self.parameterApplyStatus, name: "parameterApplyStatus", parent: name, pattern: "\\S")
            try self.validate(self.parameterGroupName, name: "parameterGroupName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterParameterStatusList = "ClusterParameterStatusList"
            case parameterApplyStatus = "ParameterApplyStatus"
            case parameterGroupName = "ParameterGroupName"
        }
    }

    public struct AwsRedshiftClusterClusterParameterStatus: AWSEncodableShape & AWSDecodableShape {
        /// The error that prevented the parameter from being applied to the database.
        public let parameterApplyErrorDescription: String?
        /// The status of the parameter. Indicates whether the parameter is in sync with the database, waiting for a cluster reboot, or encountered an error when it was applied. Valid values: in-sync | pending-reboot | applying | invalid-parameter | apply-deferred | apply-error | unknown-error
        public let parameterApplyStatus: String?
        /// The name of the parameter.
        public let parameterName: String?

        public init(parameterApplyErrorDescription: String? = nil, parameterApplyStatus: String? = nil, parameterName: String? = nil) {
            self.parameterApplyErrorDescription = parameterApplyErrorDescription
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterName = parameterName
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterApplyErrorDescription, name: "parameterApplyErrorDescription", parent: name, pattern: "\\S")
            try self.validate(self.parameterApplyStatus, name: "parameterApplyStatus", parent: name, pattern: "\\S")
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case parameterApplyErrorDescription = "ParameterApplyErrorDescription"
            case parameterApplyStatus = "ParameterApplyStatus"
            case parameterName = "ParameterName"
        }
    }

    public struct AwsRedshiftClusterClusterSecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// The name of the cluster security group.
        public let clusterSecurityGroupName: String?
        /// The status of the cluster security group.
        public let status: String?

        public init(clusterSecurityGroupName: String? = nil, status: String? = nil) {
            self.clusterSecurityGroupName = clusterSecurityGroupName
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterSecurityGroupName, name: "clusterSecurityGroupName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterSecurityGroupName = "ClusterSecurityGroupName"
            case status = "Status"
        }
    }

    public struct AwsRedshiftClusterClusterSnapshotCopyStatus: AWSEncodableShape & AWSDecodableShape {
        /// The destination Region that snapshots are automatically copied to when cross-Region snapshot copy is enabled.
        public let destinationRegion: String?
        /// The number of days that manual snapshots are retained in the destination region after they are copied from a source region. If the value is -1, then the manual snapshot is retained indefinitely. Valid values: Either -1 or an integer between 1 and 3,653
        public let manualSnapshotRetentionPeriod: Int?
        /// The number of days to retain automated snapshots in the destination Region after they are copied from a source Region.
        public let retentionPeriod: Int?
        /// The name of the snapshot copy grant.
        public let snapshotCopyGrantName: String?

        public init(destinationRegion: String? = nil, manualSnapshotRetentionPeriod: Int? = nil, retentionPeriod: Int? = nil, snapshotCopyGrantName: String? = nil) {
            self.destinationRegion = destinationRegion
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.retentionPeriod = retentionPeriod
            self.snapshotCopyGrantName = snapshotCopyGrantName
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationRegion, name: "destinationRegion", parent: name, pattern: "\\S")
            try self.validate(self.snapshotCopyGrantName, name: "snapshotCopyGrantName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationRegion = "DestinationRegion"
            case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
            case retentionPeriod = "RetentionPeriod"
            case snapshotCopyGrantName = "SnapshotCopyGrantName"
        }
    }

    public struct AwsRedshiftClusterDeferredMaintenanceWindow: AWSEncodableShape & AWSDecodableShape {
        /// The end of the time window for which maintenance was deferred. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let deferMaintenanceEndTime: String?
        /// The identifier of the maintenance window.
        public let deferMaintenanceIdentifier: String?
        /// The start of the time window for which maintenance was deferred. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let deferMaintenanceStartTime: String?

        public init(deferMaintenanceEndTime: String? = nil, deferMaintenanceIdentifier: String? = nil, deferMaintenanceStartTime: String? = nil) {
            self.deferMaintenanceEndTime = deferMaintenanceEndTime
            self.deferMaintenanceIdentifier = deferMaintenanceIdentifier
            self.deferMaintenanceStartTime = deferMaintenanceStartTime
        }

        public func validate(name: String) throws {
            try self.validate(self.deferMaintenanceEndTime, name: "deferMaintenanceEndTime", parent: name, pattern: "\\S")
            try self.validate(self.deferMaintenanceIdentifier, name: "deferMaintenanceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.deferMaintenanceStartTime, name: "deferMaintenanceStartTime", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deferMaintenanceEndTime = "DeferMaintenanceEndTime"
            case deferMaintenanceIdentifier = "DeferMaintenanceIdentifier"
            case deferMaintenanceStartTime = "DeferMaintenanceStartTime"
        }
    }

    public struct AwsRedshiftClusterDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether major version upgrades are applied automatically to the cluster during the maintenance window.
        public let allowVersionUpgrade: Bool?
        /// The number of days that automatic cluster snapshots are retained.
        public let automatedSnapshotRetentionPeriod: Int?
        /// The name of the Availability Zone in which the cluster is located.
        public let availabilityZone: String?
        /// The availability status of the cluster for queries. Possible values are the following:    Available - The cluster is available for queries.    Unavailable - The cluster is not available for queries.    Maintenance - The cluster is intermittently available for queries due to maintenance activities.    Modifying -The cluster is intermittently available for queries due to changes that modify the cluster.    Failed - The cluster failed and is not available for queries.
        public let clusterAvailabilityStatus: String?
        /// Indicates when the cluster was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let clusterCreateTime: String?
        /// The unique identifier of the cluster.
        public let clusterIdentifier: String?
        /// The nodes in the cluster.
        public let clusterNodes: [AwsRedshiftClusterClusterNode]?
        /// The list of cluster parameter groups that are associated with this cluster.
        public let clusterParameterGroups: [AwsRedshiftClusterClusterParameterGroup]?
        /// The public key for the cluster.
        public let clusterPublicKey: String?
        /// The specific revision number of the database in the cluster.
        public let clusterRevisionNumber: String?
        /// A list of cluster security groups that are associated with the cluster.
        public let clusterSecurityGroups: [AwsRedshiftClusterClusterSecurityGroup]?
        /// Information about the destination Region and retention period for the cross-Region snapshot copy.
        public let clusterSnapshotCopyStatus: AwsRedshiftClusterClusterSnapshotCopyStatus?
        /// The current status of the cluster. Valid values: available | available, prep-for-resize | available, resize-cleanup | cancelling-resize | creating | deleting | final-snapshot | hardware-failure | incompatible-hsm | incompatible-network | incompatible-parameters | incompatible-restore | modifying | paused | rebooting | renaming | resizing | rotating-keys | storage-full | updating-hsm
        public let clusterStatus: String?
        /// The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.
        public let clusterSubnetGroupName: String?
        /// The version ID of the Amazon Redshift engine that runs on the cluster.
        public let clusterVersion: String?
        /// The name of the initial database that was created when the cluster was created. The same name is returned for the life of the cluster. If an initial database is not specified, a database named devdev is created by default.
        public let dbName: String?
        /// List of time windows during which maintenance was deferred.
        public let deferredMaintenanceWindows: [AwsRedshiftClusterDeferredMaintenanceWindow]?
        /// Information about the status of the Elastic IP (EIP) address.
        public let elasticIpStatus: AwsRedshiftClusterElasticIpStatus?
        /// The number of nodes that you can use the elastic resize method to resize the cluster to.
        public let elasticResizeNumberOfNodeOptions: String?
        /// Indicates whether the data in the cluster is encrypted at rest.
        public let encrypted: Bool?
        /// The connection endpoint.
        public let endpoint: AwsRedshiftClusterEndpoint?
        /// Indicates whether to create the cluster with enhanced VPC routing enabled.
        public let enhancedVpcRouting: Bool?
        /// Indicates when the next snapshot is expected to be taken. The cluster must have a valid snapshot schedule and have backups enabled. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let expectedNextSnapshotScheduleTime: String?
        /// The status of the next expected snapshot. Valid values: OnTrack | Pending
        public let expectedNextSnapshotScheduleTimeStatus: String?
        /// Information about whether the Amazon Redshift cluster finished applying any changes to hardware security module (HSM) settings that were specified in a modify cluster command.
        public let hsmStatus: AwsRedshiftClusterHsmStatus?
        /// A list of IAM roles that the cluster can use to access other Amazon Web Services services.
        public let iamRoles: [AwsRedshiftClusterIamRole]?
        /// The identifier of the KMS encryption key that is used to encrypt data in the cluster.
        public let kmsKeyId: String?
        /// Information about the logging status of the cluster.
        public let loggingStatus: AwsRedshiftClusterLoggingStatus?
        /// The name of the maintenance track for the cluster.
        public let maintenanceTrackName: String?
        /// The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots. Valid values: Either -1 or an integer between 1 and 3,653
        public let manualSnapshotRetentionPeriod: Int?
        /// The master user name for the cluster. This name is used to connect to the database that is specified in as the value of DBName.
        public let masterUsername: String?
        /// Indicates the start of the next maintenance window. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let nextMaintenanceWindowStartTime: String?
        /// The node type for the nodes in the cluster.
        public let nodeType: String?
        /// The number of compute nodes in the cluster.
        public let numberOfNodes: Int?
        /// A list of cluster operations that are waiting to start.
        public let pendingActions: [String]?
        /// A list of changes to the cluster that are currently pending.
        public let pendingModifiedValues: AwsRedshiftClusterPendingModifiedValues?
        /// The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur. Format:  :HH:MM-:HH:MM  For the day values, use mon | tue | wed | thu | fri | sat | sun  For example, sun:09:32-sun:10:02
        public let preferredMaintenanceWindow: String?
        /// Whether the cluster can be accessed from a public network.
        public let publiclyAccessible: Bool?
        /// Information about the resize operation for the cluster.
        public let resizeInfo: AwsRedshiftClusterResizeInfo?
        /// Information about the status of a cluster restore action. Only applies to a cluster that was created by restoring a snapshot.
        public let restoreStatus: AwsRedshiftClusterRestoreStatus?
        /// A unique identifier for the cluster snapshot schedule.
        public let snapshotScheduleIdentifier: String?
        /// The current state of the cluster snapshot schedule. Valid values: MODIFYING | ACTIVE | FAILED
        public let snapshotScheduleState: String?
        /// The identifier of the VPC that the cluster is in, if the cluster is in a VPC.
        public let vpcId: String?
        /// The list of VPC security groups that the cluster belongs to, if the cluster is in a VPC.
        public let vpcSecurityGroups: [AwsRedshiftClusterVpcSecurityGroup]?

        public init(allowVersionUpgrade: Bool? = nil, automatedSnapshotRetentionPeriod: Int? = nil, availabilityZone: String? = nil, clusterAvailabilityStatus: String? = nil, clusterCreateTime: String? = nil, clusterIdentifier: String? = nil, clusterNodes: [AwsRedshiftClusterClusterNode]? = nil, clusterParameterGroups: [AwsRedshiftClusterClusterParameterGroup]? = nil, clusterPublicKey: String? = nil, clusterRevisionNumber: String? = nil, clusterSecurityGroups: [AwsRedshiftClusterClusterSecurityGroup]? = nil, clusterSnapshotCopyStatus: AwsRedshiftClusterClusterSnapshotCopyStatus? = nil, clusterStatus: String? = nil, clusterSubnetGroupName: String? = nil, clusterVersion: String? = nil, dbName: String? = nil, deferredMaintenanceWindows: [AwsRedshiftClusterDeferredMaintenanceWindow]? = nil, elasticIpStatus: AwsRedshiftClusterElasticIpStatus? = nil, elasticResizeNumberOfNodeOptions: String? = nil, encrypted: Bool? = nil, endpoint: AwsRedshiftClusterEndpoint? = nil, enhancedVpcRouting: Bool? = nil, expectedNextSnapshotScheduleTime: String? = nil, expectedNextSnapshotScheduleTimeStatus: String? = nil, hsmStatus: AwsRedshiftClusterHsmStatus? = nil, iamRoles: [AwsRedshiftClusterIamRole]? = nil, kmsKeyId: String? = nil, loggingStatus: AwsRedshiftClusterLoggingStatus? = nil, maintenanceTrackName: String? = nil, manualSnapshotRetentionPeriod: Int? = nil, masterUsername: String? = nil, nextMaintenanceWindowStartTime: String? = nil, nodeType: String? = nil, numberOfNodes: Int? = nil, pendingActions: [String]? = nil, pendingModifiedValues: AwsRedshiftClusterPendingModifiedValues? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, resizeInfo: AwsRedshiftClusterResizeInfo? = nil, restoreStatus: AwsRedshiftClusterRestoreStatus? = nil, snapshotScheduleIdentifier: String? = nil, snapshotScheduleState: String? = nil, vpcId: String? = nil, vpcSecurityGroups: [AwsRedshiftClusterVpcSecurityGroup]? = nil) {
            self.allowVersionUpgrade = allowVersionUpgrade
            self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
            self.availabilityZone = availabilityZone
            self.clusterAvailabilityStatus = clusterAvailabilityStatus
            self.clusterCreateTime = clusterCreateTime
            self.clusterIdentifier = clusterIdentifier
            self.clusterNodes = clusterNodes
            self.clusterParameterGroups = clusterParameterGroups
            self.clusterPublicKey = clusterPublicKey
            self.clusterRevisionNumber = clusterRevisionNumber
            self.clusterSecurityGroups = clusterSecurityGroups
            self.clusterSnapshotCopyStatus = clusterSnapshotCopyStatus
            self.clusterStatus = clusterStatus
            self.clusterSubnetGroupName = clusterSubnetGroupName
            self.clusterVersion = clusterVersion
            self.dbName = dbName
            self.deferredMaintenanceWindows = deferredMaintenanceWindows
            self.elasticIpStatus = elasticIpStatus
            self.elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions
            self.encrypted = encrypted
            self.endpoint = endpoint
            self.enhancedVpcRouting = enhancedVpcRouting
            self.expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime
            self.expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus
            self.hsmStatus = hsmStatus
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.loggingStatus = loggingStatus
            self.maintenanceTrackName = maintenanceTrackName
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.masterUsername = masterUsername
            self.nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.pendingActions = pendingActions
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.resizeInfo = resizeInfo
            self.restoreStatus = restoreStatus
            self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
            self.snapshotScheduleState = snapshotScheduleState
            self.vpcId = vpcId
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.clusterAvailabilityStatus, name: "clusterAvailabilityStatus", parent: name, pattern: "\\S")
            try self.validate(self.clusterCreateTime, name: "clusterCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "\\S")
            try self.clusterNodes?.forEach {
                try $0.validate(name: "\(name).clusterNodes[]")
            }
            try self.clusterParameterGroups?.forEach {
                try $0.validate(name: "\(name).clusterParameterGroups[]")
            }
            try self.validate(self.clusterPublicKey, name: "clusterPublicKey", parent: name, pattern: "\\S")
            try self.validate(self.clusterRevisionNumber, name: "clusterRevisionNumber", parent: name, pattern: "\\S")
            try self.clusterSecurityGroups?.forEach {
                try $0.validate(name: "\(name).clusterSecurityGroups[]")
            }
            try self.clusterSnapshotCopyStatus?.validate(name: "\(name).clusterSnapshotCopyStatus")
            try self.validate(self.clusterStatus, name: "clusterStatus", parent: name, pattern: "\\S")
            try self.validate(self.clusterSubnetGroupName, name: "clusterSubnetGroupName", parent: name, pattern: "\\S")
            try self.validate(self.clusterVersion, name: "clusterVersion", parent: name, pattern: "\\S")
            try self.validate(self.dbName, name: "dbName", parent: name, pattern: "\\S")
            try self.deferredMaintenanceWindows?.forEach {
                try $0.validate(name: "\(name).deferredMaintenanceWindows[]")
            }
            try self.elasticIpStatus?.validate(name: "\(name).elasticIpStatus")
            try self.validate(self.elasticResizeNumberOfNodeOptions, name: "elasticResizeNumberOfNodeOptions", parent: name, pattern: "\\S")
            try self.endpoint?.validate(name: "\(name).endpoint")
            try self.validate(self.expectedNextSnapshotScheduleTime, name: "expectedNextSnapshotScheduleTime", parent: name, pattern: "\\S")
            try self.validate(self.expectedNextSnapshotScheduleTimeStatus, name: "expectedNextSnapshotScheduleTimeStatus", parent: name, pattern: "\\S")
            try self.hsmStatus?.validate(name: "\(name).hsmStatus")
            try self.iamRoles?.forEach {
                try $0.validate(name: "\(name).iamRoles[]")
            }
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.loggingStatus?.validate(name: "\(name).loggingStatus")
            try self.validate(self.maintenanceTrackName, name: "maintenanceTrackName", parent: name, pattern: "\\S")
            try self.validate(self.masterUsername, name: "masterUsername", parent: name, pattern: "\\S")
            try self.validate(self.nextMaintenanceWindowStartTime, name: "nextMaintenanceWindowStartTime", parent: name, pattern: "\\S")
            try self.validate(self.nodeType, name: "nodeType", parent: name, pattern: "\\S")
            try self.pendingActions?.forEach {
                try validate($0, name: "pendingActions[]", parent: name, pattern: "\\S")
            }
            try self.pendingModifiedValues?.validate(name: "\(name).pendingModifiedValues")
            try self.validate(self.preferredMaintenanceWindow, name: "preferredMaintenanceWindow", parent: name, pattern: "\\S")
            try self.resizeInfo?.validate(name: "\(name).resizeInfo")
            try self.restoreStatus?.validate(name: "\(name).restoreStatus")
            try self.validate(self.snapshotScheduleIdentifier, name: "snapshotScheduleIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.snapshotScheduleState, name: "snapshotScheduleState", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
            try self.vpcSecurityGroups?.forEach {
                try $0.validate(name: "\(name).vpcSecurityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowVersionUpgrade = "AllowVersionUpgrade"
            case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
            case availabilityZone = "AvailabilityZone"
            case clusterAvailabilityStatus = "ClusterAvailabilityStatus"
            case clusterCreateTime = "ClusterCreateTime"
            case clusterIdentifier = "ClusterIdentifier"
            case clusterNodes = "ClusterNodes"
            case clusterParameterGroups = "ClusterParameterGroups"
            case clusterPublicKey = "ClusterPublicKey"
            case clusterRevisionNumber = "ClusterRevisionNumber"
            case clusterSecurityGroups = "ClusterSecurityGroups"
            case clusterSnapshotCopyStatus = "ClusterSnapshotCopyStatus"
            case clusterStatus = "ClusterStatus"
            case clusterSubnetGroupName = "ClusterSubnetGroupName"
            case clusterVersion = "ClusterVersion"
            case dbName = "DBName"
            case deferredMaintenanceWindows = "DeferredMaintenanceWindows"
            case elasticIpStatus = "ElasticIpStatus"
            case elasticResizeNumberOfNodeOptions = "ElasticResizeNumberOfNodeOptions"
            case encrypted = "Encrypted"
            case endpoint = "Endpoint"
            case enhancedVpcRouting = "EnhancedVpcRouting"
            case expectedNextSnapshotScheduleTime = "ExpectedNextSnapshotScheduleTime"
            case expectedNextSnapshotScheduleTimeStatus = "ExpectedNextSnapshotScheduleTimeStatus"
            case hsmStatus = "HsmStatus"
            case iamRoles = "IamRoles"
            case kmsKeyId = "KmsKeyId"
            case loggingStatus = "LoggingStatus"
            case maintenanceTrackName = "MaintenanceTrackName"
            case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
            case masterUsername = "MasterUsername"
            case nextMaintenanceWindowStartTime = "NextMaintenanceWindowStartTime"
            case nodeType = "NodeType"
            case numberOfNodes = "NumberOfNodes"
            case pendingActions = "PendingActions"
            case pendingModifiedValues = "PendingModifiedValues"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case publiclyAccessible = "PubliclyAccessible"
            case resizeInfo = "ResizeInfo"
            case restoreStatus = "RestoreStatus"
            case snapshotScheduleIdentifier = "SnapshotScheduleIdentifier"
            case snapshotScheduleState = "SnapshotScheduleState"
            case vpcId = "VpcId"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct AwsRedshiftClusterElasticIpStatus: AWSEncodableShape & AWSDecodableShape {
        /// The elastic IP address for the cluster.
        public let elasticIp: String?
        /// The status of the elastic IP address.
        public let status: String?

        public init(elasticIp: String? = nil, status: String? = nil) {
            self.elasticIp = elasticIp
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.elasticIp, name: "elasticIp", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case elasticIp = "ElasticIp"
            case status = "Status"
        }
    }

    public struct AwsRedshiftClusterEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// The DNS address of the cluster.
        public let address: String?
        /// The port that the database engine listens on.
        public let port: Int?

        public init(address: String? = nil, port: Int? = nil) {
            self.address = address
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case port = "Port"
        }
    }

    public struct AwsRedshiftClusterHsmStatus: AWSEncodableShape & AWSDecodableShape {
        /// The name of the HSM client certificate that the Amazon Redshift cluster uses to retrieve the data encryption keys that are stored in an HSM.
        public let hsmClientCertificateIdentifier: String?
        /// The name of the HSM configuration that contains the information that the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
        public let hsmConfigurationIdentifier: String?
        /// Indicates whether the Amazon Redshift cluster has finished applying any HSM settings changes specified in a modify cluster command. Type: String Valid values: active | applying
        public let status: String?

        public init(hsmClientCertificateIdentifier: String? = nil, hsmConfigurationIdentifier: String? = nil, status: String? = nil) {
            self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
            self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.hsmClientCertificateIdentifier, name: "hsmClientCertificateIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.hsmConfigurationIdentifier, name: "hsmConfigurationIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hsmClientCertificateIdentifier = "HsmClientCertificateIdentifier"
            case hsmConfigurationIdentifier = "HsmConfigurationIdentifier"
            case status = "Status"
        }
    }

    public struct AwsRedshiftClusterIamRole: AWSEncodableShape & AWSDecodableShape {
        /// The status of the IAM role's association with the cluster. Valid values: in-sync | adding | removing
        public let applyStatus: String?
        /// The ARN of the IAM role.
        public let iamRoleArn: String?

        public init(applyStatus: String? = nil, iamRoleArn: String? = nil) {
            self.applyStatus = applyStatus
            self.iamRoleArn = iamRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.applyStatus, name: "applyStatus", parent: name, pattern: "\\S")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case applyStatus = "ApplyStatus"
            case iamRoleArn = "IamRoleArn"
        }
    }

    public struct AwsRedshiftClusterLoggingStatus: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket where the log files are stored.
        public let bucketName: String?
        /// The message indicating that the logs failed to be delivered.
        public let lastFailureMessage: String?
        /// The last time when logs failed to be delivered. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastFailureTime: String?
        /// The last time that logs were delivered successfully. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastSuccessfulDeliveryTime: String?
        /// Indicates whether logging is enabled.
        public let loggingEnabled: Bool?
        /// Provides the prefix applied to the log file names.
        public let s3KeyPrefix: String?

        public init(bucketName: String? = nil, lastFailureMessage: String? = nil, lastFailureTime: String? = nil, lastSuccessfulDeliveryTime: String? = nil, loggingEnabled: Bool? = nil, s3KeyPrefix: String? = nil) {
            self.bucketName = bucketName
            self.lastFailureMessage = lastFailureMessage
            self.lastFailureTime = lastFailureTime
            self.lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTime
            self.loggingEnabled = loggingEnabled
            self.s3KeyPrefix = s3KeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "\\S")
            try self.validate(self.lastFailureMessage, name: "lastFailureMessage", parent: name, pattern: "\\S")
            try self.validate(self.lastFailureTime, name: "lastFailureTime", parent: name, pattern: "\\S")
            try self.validate(self.lastSuccessfulDeliveryTime, name: "lastSuccessfulDeliveryTime", parent: name, pattern: "\\S")
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case lastFailureMessage = "LastFailureMessage"
            case lastFailureTime = "LastFailureTime"
            case lastSuccessfulDeliveryTime = "LastSuccessfulDeliveryTime"
            case loggingEnabled = "LoggingEnabled"
            case s3KeyPrefix = "S3KeyPrefix"
        }
    }

    public struct AwsRedshiftClusterPendingModifiedValues: AWSEncodableShape & AWSDecodableShape {
        /// The pending or in-progress change to the automated snapshot retention period.
        public let automatedSnapshotRetentionPeriod: Int?
        /// The pending or in-progress change to the identifier for the cluster.
        public let clusterIdentifier: String?
        /// The pending or in-progress change to the cluster type.
        public let clusterType: String?
        /// The pending or in-progress change to the service version.
        public let clusterVersion: String?
        /// The encryption type for a cluster.
        public let encryptionType: String?
        /// Indicates whether to create the cluster with enhanced VPC routing enabled.
        public let enhancedVpcRouting: Bool?
        /// The name of the maintenance track that the cluster changes to during the next maintenance window.
        public let maintenanceTrackName: String?
        /// The pending or in-progress change to the master user password for the cluster.
        public let masterUserPassword: String?
        /// The pending or in-progress change to the cluster's node type.
        public let nodeType: String?
        /// The pending or in-progress change to the number of nodes in the cluster.
        public let numberOfNodes: Int?
        /// The pending or in-progress change to whether the cluster can be connected to from the public network.
        public let publiclyAccessible: Bool?

        public init(automatedSnapshotRetentionPeriod: Int? = nil, clusterIdentifier: String? = nil, clusterType: String? = nil, clusterVersion: String? = nil, encryptionType: String? = nil, enhancedVpcRouting: Bool? = nil, maintenanceTrackName: String? = nil, masterUserPassword: String? = nil, nodeType: String? = nil, numberOfNodes: Int? = nil, publiclyAccessible: Bool? = nil) {
            self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
            self.clusterIdentifier = clusterIdentifier
            self.clusterType = clusterType
            self.clusterVersion = clusterVersion
            self.encryptionType = encryptionType
            self.enhancedVpcRouting = enhancedVpcRouting
            self.maintenanceTrackName = maintenanceTrackName
            self.masterUserPassword = masterUserPassword
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.publiclyAccessible = publiclyAccessible
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.clusterType, name: "clusterType", parent: name, pattern: "\\S")
            try self.validate(self.clusterVersion, name: "clusterVersion", parent: name, pattern: "\\S")
            try self.validate(self.encryptionType, name: "encryptionType", parent: name, pattern: "\\S")
            try self.validate(self.maintenanceTrackName, name: "maintenanceTrackName", parent: name, pattern: "\\S")
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, pattern: "\\S")
            try self.validate(self.nodeType, name: "nodeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
            case clusterIdentifier = "ClusterIdentifier"
            case clusterType = "ClusterType"
            case clusterVersion = "ClusterVersion"
            case encryptionType = "EncryptionType"
            case enhancedVpcRouting = "EnhancedVpcRouting"
            case maintenanceTrackName = "MaintenanceTrackName"
            case masterUserPassword = "MasterUserPassword"
            case nodeType = "NodeType"
            case numberOfNodes = "NumberOfNodes"
            case publiclyAccessible = "PubliclyAccessible"
        }
    }

    public struct AwsRedshiftClusterResizeInfo: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the resize operation can be canceled.
        public let allowCancelResize: Bool?
        /// The type of resize operation. Valid values: ClassicResize
        public let resizeType: String?

        public init(allowCancelResize: Bool? = nil, resizeType: String? = nil) {
            self.allowCancelResize = allowCancelResize
            self.resizeType = resizeType
        }

        public func validate(name: String) throws {
            try self.validate(self.resizeType, name: "resizeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case allowCancelResize = "AllowCancelResize"
            case resizeType = "ResizeType"
        }
    }

    public struct AwsRedshiftClusterRestoreStatus: AWSEncodableShape & AWSDecodableShape {
        /// The number of megabytes per second being transferred from the backup storage. Returns the average rate for a completed backup. This field is only updated when you restore to DC2 and DS2 node types.
        public let currentRestoreRateInMegaBytesPerSecond: Double?
        /// The amount of time an in-progress restore has been running, or the amount of time it took a completed restore to finish. This field is only updated when you restore to DC2 and DS2 node types.
        public let elapsedTimeInSeconds: Int64?
        /// The estimate of the time remaining before the restore is complete. Returns 0 for a completed restore. This field is only updated when you restore to DC2 and DS2 node types.
        public let estimatedTimeToCompletionInSeconds: Int64?
        /// The number of megabytes that were transferred from snapshot storage. This field is only updated when you restore to DC2 and DS2 node types.
        public let progressInMegaBytes: Int64?
        /// The size of the set of snapshot data that was used to restore the cluster. This field is only updated when you restore to DC2 and DS2 node types.
        public let snapshotSizeInMegaBytes: Int64?
        /// The status of the restore action. Valid values: starting | restoring | completed | failed
        public let status: String?

        public init(currentRestoreRateInMegaBytesPerSecond: Double? = nil, elapsedTimeInSeconds: Int64? = nil, estimatedTimeToCompletionInSeconds: Int64? = nil, progressInMegaBytes: Int64? = nil, snapshotSizeInMegaBytes: Int64? = nil, status: String? = nil) {
            self.currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecond
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
            self.progressInMegaBytes = progressInMegaBytes
            self.snapshotSizeInMegaBytes = snapshotSizeInMegaBytes
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case currentRestoreRateInMegaBytesPerSecond = "CurrentRestoreRateInMegaBytesPerSecond"
            case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
            case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
            case progressInMegaBytes = "ProgressInMegaBytes"
            case snapshotSizeInMegaBytes = "SnapshotSizeInMegaBytes"
            case status = "Status"
        }
    }

    public struct AwsRedshiftClusterVpcSecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// The status of the VPC security group.
        public let status: String?
        /// The identifier of the VPC security group.
        public let vpcSecurityGroupId: String?

        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.vpcSecurityGroupId, name: "vpcSecurityGroupId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }

    public struct AwsS3AccountPublicAccessBlockDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether to reject calls to update an S3 bucket if the calls include a public access control list (ACL).
        public let blockPublicAcls: Bool?
        /// Indicates whether to reject calls to update the access policy for an S3 bucket or access point if the policy allows public access.
        public let blockPublicPolicy: Bool?
        /// Indicates whether Amazon S3 ignores public ACLs that are associated with an S3 bucket.
        public let ignorePublicAcls: Bool?
        /// Indicates whether to restrict access to an access point or S3 bucket that has a public policy to only Amazon Web Services service principals and authorized users within the S3 bucket owner's account.
        public let restrictPublicBuckets: Bool?

        public init(blockPublicAcls: Bool? = nil, blockPublicPolicy: Bool? = nil, ignorePublicAcls: Bool? = nil, restrictPublicBuckets: Bool? = nil) {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAcls = "BlockPublicAcls"
            case blockPublicPolicy = "BlockPublicPolicy"
            case ignorePublicAcls = "IgnorePublicAcls"
            case restrictPublicBuckets = "RestrictPublicBuckets"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The lifecycle rules.
        public let rules: [AwsS3BucketBucketLifecycleConfigurationRulesDetails]?

        public init(rules: [AwsS3BucketBucketLifecycleConfigurationRulesDetails]? = nil) {
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of days after which Amazon S3 cancels an incomplete multipart upload.
        public let daysAfterInitiation: Int?

        public init(daysAfterInitiation: Int? = nil) {
            self.daysAfterInitiation = daysAfterInitiation
        }

        private enum CodingKeys: String, CodingKey {
            case daysAfterInitiation = "DaysAfterInitiation"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesDetails: AWSEncodableShape & AWSDecodableShape {
        /// How Amazon S3 responds when a multipart upload is incomplete. Specifically, provides a number of days before Amazon S3 cancels the entire upload.
        public let abortIncompleteMultipartUpload: AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails?
        /// The date when objects are moved or deleted. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let expirationDate: String?
        /// The length in days of the lifetime for objects that are subject to the rule.
        public let expirationInDays: Int?
        /// Whether Amazon S3 removes a delete marker that has no noncurrent versions. If set to true, the delete marker is expired. If set to false, the policy takes no action. If you provide ExpiredObjectDeleteMarker, you cannot provide ExpirationInDays or ExpirationDate.
        public let expiredObjectDeleteMarker: Bool?
        /// Identifies the objects that a rule applies to.
        public let filter: AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails?
        /// The unique identifier of the rule.
        public let id: String?
        /// The number of days that an object is noncurrent before Amazon S3 can perform the associated action.
        public let noncurrentVersionExpirationInDays: Int?
        /// Transition rules that describe when noncurrent objects transition to a specified storage class.
        public let noncurrentVersionTransitions: [AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]?
        /// A prefix that identifies one or more objects that the rule applies to.
        public let prefix: String?
        /// The current status of the rule. Indicates whether the rule is currently being applied.
        public let status: String?
        /// Transition rules that indicate when objects transition to a specified storage class.
        public let transitions: [AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails]?

        public init(abortIncompleteMultipartUpload: AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails? = nil, expirationDate: String? = nil, expirationInDays: Int? = nil, expiredObjectDeleteMarker: Bool? = nil, filter: AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails? = nil, id: String? = nil, noncurrentVersionExpirationInDays: Int? = nil, noncurrentVersionTransitions: [AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]? = nil, prefix: String? = nil, status: String? = nil, transitions: [AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails]? = nil) {
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.expirationDate = expirationDate
            self.expirationInDays = expirationInDays
            self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
            self.filter = filter
            self.id = id
            self.noncurrentVersionExpirationInDays = noncurrentVersionExpirationInDays
            self.noncurrentVersionTransitions = noncurrentVersionTransitions
            self.prefix = prefix
            self.status = status
            self.transitions = transitions
        }

        public func validate(name: String) throws {
            try self.validate(self.expirationDate, name: "expirationDate", parent: name, pattern: "\\S")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.noncurrentVersionTransitions?.forEach {
                try $0.validate(name: "\(name).noncurrentVersionTransitions[]")
            }
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.transitions?.forEach {
                try $0.validate(name: "\(name).transitions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case abortIncompleteMultipartUpload = "AbortIncompleteMultipartUpload"
            case expirationDate = "ExpirationDate"
            case expirationInDays = "ExpirationInDays"
            case expiredObjectDeleteMarker = "ExpiredObjectDeleteMarker"
            case filter = "Filter"
            case id = "ID"
            case noncurrentVersionExpirationInDays = "NoncurrentVersionExpirationInDays"
            case noncurrentVersionTransitions = "NoncurrentVersionTransitions"
            case prefix = "Prefix"
            case status = "Status"
            case transitions = "Transitions"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the filter.
        public let predicate: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails?

        public init(predicate: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails? = nil) {
            self.predicate = predicate
        }

        public func validate(name: String) throws {
            try self.predicate?.validate(name: "\(name).predicate")
        }

        private enum CodingKeys: String, CodingKey {
            case predicate = "Predicate"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails: AWSEncodableShape & AWSDecodableShape {
        /// The values to use for the filter.
        public let operands: [AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]?
        /// A prefix filter.
        public let prefix: String?
        /// A tag filter.
        public let tag: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails?
        /// Whether to use AND or OR to join the operands.
        /// Valid values are LifecycleAndOperator or LifecycleOrOperator.
        public let type: String?

        public init(operands: [AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]? = nil, prefix: String? = nil, tag: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails? = nil, type: String? = nil) {
            self.operands = operands
            self.prefix = prefix
            self.tag = tag
            self.type = type
        }

        public func validate(name: String) throws {
            try self.operands?.forEach {
                try $0.validate(name: "\(name).operands[]")
            }
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "\\S")
            try self.tag?.validate(name: "\(name).tag")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case operands = "Operands"
            case prefix = "Prefix"
            case tag = "Tag"
            case type = "Type"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Prefix text for matching objects.
        public let prefix: String?
        /// A tag that is assigned to matching objects.
        public let tag: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails?
        /// The type of filter value.
        /// Valid values are LifecyclePrefixPredicate or LifecycleTagPredicate.
        public let type: String?

        public init(prefix: String? = nil, tag: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails? = nil, type: String? = nil) {
            self.prefix = prefix
            self.tag = tag
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "\\S")
            try self.tag?.validate(name: "\(name).tag")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case prefix = "Prefix"
            case tag = "Tag"
            case type = "Type"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails: AWSEncodableShape & AWSDecodableShape {
        /// The tag key.
        public let key: String?
        /// The tag value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails: AWSEncodableShape & AWSDecodableShape {
        /// The tag key.
        public let key: String?
        /// The tag value
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of days that an object is noncurrent before Amazon S3 can perform the associated action.
        public let days: Int?
        /// The class of storage to change the object to after the object is noncurrent for the specified number of days.
        public let storageClass: String?

        public init(days: Int? = nil, storageClass: String? = nil) {
            self.days = days
            self.storageClass = storageClass
        }

        public func validate(name: String) throws {
            try self.validate(self.storageClass, name: "storageClass", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case days = "Days"
            case storageClass = "StorageClass"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// A date on which to transition objects to the specified storage class. If you provide Date, you cannot provide Days. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let date: String?
        /// The number of days after which to transition the object to the specified storage class. If you provide Days, you cannot provide Date.
        public let days: Int?
        /// The storage class to transition the object to. Valid values are as follows:    DEEP_ARCHIVE     GLACIER     INTELLIGENT_TIERING     ONEZONE_IA     STANDARD_IA
        public let storageClass: String?

        public init(date: String? = nil, days: Int? = nil, storageClass: String? = nil) {
            self.date = date
            self.days = days
            self.storageClass = storageClass
        }

        public func validate(name: String) throws {
            try self.validate(self.date, name: "date", parent: name, pattern: "\\S")
            try self.validate(self.storageClass, name: "storageClass", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case days = "Days"
            case storageClass = "StorageClass"
        }
    }

    public struct AwsS3BucketBucketVersioningConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether MFA delete is currently enabled in the S3 bucket versioning configuration. If the S3 bucket was never configured with MFA delete, then this attribute is not included.
        public let isMfaDeleteEnabled: Bool?
        /// The versioning status of the S3 bucket. Valid values are Enabled or Suspended.
        public let status: String?

        public init(isMfaDeleteEnabled: Bool? = nil, status: String? = nil) {
            self.isMfaDeleteEnabled = isMfaDeleteEnabled
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case isMfaDeleteEnabled = "IsMfaDeleteEnabled"
            case status = "Status"
        }
    }

    public struct AwsS3BucketDetails: AWSEncodableShape & AWSDecodableShape {
        /// The access control list for the S3 bucket.
        public let accessControlList: String?
        /// The lifecycle configuration for objects in the S3 bucket.
        public let bucketLifecycleConfiguration: AwsS3BucketBucketLifecycleConfigurationDetails?
        /// The logging configuration for the S3 bucket.
        public let bucketLoggingConfiguration: AwsS3BucketLoggingConfiguration?
        /// The notification configuration for the S3 bucket.
        public let bucketNotificationConfiguration: AwsS3BucketNotificationConfiguration?
        /// The versioning state of an S3 bucket.
        public let bucketVersioningConfiguration: AwsS3BucketBucketVersioningConfiguration?
        /// The website configuration parameters for the S3 bucket.
        public let bucketWebsiteConfiguration: AwsS3BucketWebsiteConfiguration?
        /// Indicates when the S3 bucket was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdAt: String?
        /// The Amazon Web Services account identifier of the account that owns the S3 bucket.
        public let ownerAccountId: String?
        /// The canonical user ID of the owner of the S3 bucket.
        public let ownerId: String?
        /// The display name of the owner of the S3 bucket.
        public let ownerName: String?
        /// Provides information about the Amazon S3 Public Access Block configuration for the S3 bucket.
        public let publicAccessBlockConfiguration: AwsS3AccountPublicAccessBlockDetails?
        /// The encryption rules that are applied to the S3 bucket.
        public let serverSideEncryptionConfiguration: AwsS3BucketServerSideEncryptionConfiguration?

        public init(accessControlList: String? = nil, bucketLifecycleConfiguration: AwsS3BucketBucketLifecycleConfigurationDetails? = nil, bucketLoggingConfiguration: AwsS3BucketLoggingConfiguration? = nil, bucketNotificationConfiguration: AwsS3BucketNotificationConfiguration? = nil, bucketVersioningConfiguration: AwsS3BucketBucketVersioningConfiguration? = nil, bucketWebsiteConfiguration: AwsS3BucketWebsiteConfiguration? = nil, createdAt: String? = nil, ownerAccountId: String? = nil, ownerId: String? = nil, ownerName: String? = nil, publicAccessBlockConfiguration: AwsS3AccountPublicAccessBlockDetails? = nil, serverSideEncryptionConfiguration: AwsS3BucketServerSideEncryptionConfiguration? = nil) {
            self.accessControlList = accessControlList
            self.bucketLifecycleConfiguration = bucketLifecycleConfiguration
            self.bucketLoggingConfiguration = bucketLoggingConfiguration
            self.bucketNotificationConfiguration = bucketNotificationConfiguration
            self.bucketVersioningConfiguration = bucketVersioningConfiguration
            self.bucketWebsiteConfiguration = bucketWebsiteConfiguration
            self.createdAt = createdAt
            self.ownerAccountId = ownerAccountId
            self.ownerId = ownerId
            self.ownerName = ownerName
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.accessControlList, name: "accessControlList", parent: name, pattern: "\\S")
            try self.bucketLifecycleConfiguration?.validate(name: "\(name).bucketLifecycleConfiguration")
            try self.bucketLoggingConfiguration?.validate(name: "\(name).bucketLoggingConfiguration")
            try self.bucketNotificationConfiguration?.validate(name: "\(name).bucketNotificationConfiguration")
            try self.bucketVersioningConfiguration?.validate(name: "\(name).bucketVersioningConfiguration")
            try self.bucketWebsiteConfiguration?.validate(name: "\(name).bucketWebsiteConfiguration")
            try self.validate(self.createdAt, name: "createdAt", parent: name, pattern: "\\S")
            try self.validate(self.ownerAccountId, name: "ownerAccountId", parent: name, pattern: "\\S")
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.ownerName, name: "ownerName", parent: name, pattern: "\\S")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlList = "AccessControlList"
            case bucketLifecycleConfiguration = "BucketLifecycleConfiguration"
            case bucketLoggingConfiguration = "BucketLoggingConfiguration"
            case bucketNotificationConfiguration = "BucketNotificationConfiguration"
            case bucketVersioningConfiguration = "BucketVersioningConfiguration"
            case bucketWebsiteConfiguration = "BucketWebsiteConfiguration"
            case createdAt = "CreatedAt"
            case ownerAccountId = "OwnerAccountId"
            case ownerId = "OwnerId"
            case ownerName = "OwnerName"
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
            case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        }
    }

    public struct AwsS3BucketLoggingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket where log files for the S3 bucket are stored.
        public let destinationBucketName: String?
        /// The prefix added to log files for the S3 bucket.
        public let logFilePrefix: String?

        public init(destinationBucketName: String? = nil, logFilePrefix: String? = nil) {
            self.destinationBucketName = destinationBucketName
            self.logFilePrefix = logFilePrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationBucketName, name: "destinationBucketName", parent: name, pattern: "\\S")
            try self.validate(self.logFilePrefix, name: "logFilePrefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationBucketName = "DestinationBucketName"
            case logFilePrefix = "LogFilePrefix"
        }
    }

    public struct AwsS3BucketNotificationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configurations for S3 bucket notifications.
        public let configurations: [AwsS3BucketNotificationConfigurationDetail]?

        public init(configurations: [AwsS3BucketNotificationConfigurationDetail]? = nil) {
            self.configurations = configurations
        }

        public func validate(name: String) throws {
            try self.configurations?.forEach {
                try $0.validate(name: "\(name).configurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurations = "Configurations"
        }
    }

    public struct AwsS3BucketNotificationConfigurationDetail: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function, Amazon SQS queue, or Amazon SNS topic that generates the notification.
        public let destination: String?
        /// The list of events that trigger a notification.
        public let events: [String]?
        /// The filters that determine which S3 buckets generate notifications.
        public let filter: AwsS3BucketNotificationConfigurationFilter?
        /// Indicates the type of notification. Notifications can be generated using Lambda functions, Amazon SQS queues, or Amazon SNS topics, with corresponding valid values as follows:    LambdaConfiguration     QueueConfiguration     TopicConfiguration
        public let type: String?

        public init(destination: String? = nil, events: [String]? = nil, filter: AwsS3BucketNotificationConfigurationFilter? = nil, type: String? = nil) {
            self.destination = destination
            self.events = events
            self.filter = filter
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, pattern: "\\S")
            try self.events?.forEach {
                try validate($0, name: "events[]", parent: name, pattern: "\\S")
            }
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case events = "Events"
            case filter = "Filter"
            case type = "Type"
        }
    }

    public struct AwsS3BucketNotificationConfigurationFilter: AWSEncodableShape & AWSDecodableShape {
        /// Details for an Amazon S3 filter.
        public let s3KeyFilter: AwsS3BucketNotificationConfigurationS3KeyFilter?

        public init(s3KeyFilter: AwsS3BucketNotificationConfigurationS3KeyFilter? = nil) {
            self.s3KeyFilter = s3KeyFilter
        }

        public func validate(name: String) throws {
            try self.s3KeyFilter?.validate(name: "\(name).s3KeyFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case s3KeyFilter = "S3KeyFilter"
        }
    }

    public struct AwsS3BucketNotificationConfigurationS3KeyFilter: AWSEncodableShape & AWSDecodableShape {
        /// The filter rules for the filter.
        public let filterRules: [AwsS3BucketNotificationConfigurationS3KeyFilterRule]?

        public init(filterRules: [AwsS3BucketNotificationConfigurationS3KeyFilterRule]? = nil) {
            self.filterRules = filterRules
        }

        public func validate(name: String) throws {
            try self.filterRules?.forEach {
                try $0.validate(name: "\(name).filterRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filterRules = "FilterRules"
        }
    }

    public struct AwsS3BucketNotificationConfigurationS3KeyFilterRule: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the filter is based on the prefix or suffix of the Amazon S3 key.
        public let name: AwsS3BucketNotificationConfigurationS3KeyFilterRuleName?
        /// The filter value.
        public let value: String?

        public init(name: AwsS3BucketNotificationConfigurationS3KeyFilterRuleName? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsS3BucketServerSideEncryptionByDefault: AWSEncodableShape & AWSDecodableShape {
        /// KMS key ID to use for the default encryption.
        public let kmsMasterKeyID: String?
        /// Server-side encryption algorithm to use for the default encryption. Valid values are
        /// aws: kms or AES256.
        public let sseAlgorithm: String?

        public init(kmsMasterKeyID: String? = nil, sseAlgorithm: String? = nil) {
            self.kmsMasterKeyID = kmsMasterKeyID
            self.sseAlgorithm = sseAlgorithm
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsMasterKeyID, name: "kmsMasterKeyID", parent: name, pattern: "\\S")
            try self.validate(self.sseAlgorithm, name: "sseAlgorithm", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsMasterKeyID = "KMSMasterKeyID"
            case sseAlgorithm = "SSEAlgorithm"
        }
    }

    public struct AwsS3BucketServerSideEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The encryption rules that are applied to the S3 bucket.
        public let rules: [AwsS3BucketServerSideEncryptionRule]?

        public init(rules: [AwsS3BucketServerSideEncryptionRule]? = nil) {
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
        }
    }

    public struct AwsS3BucketServerSideEncryptionRule: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT object request doesn't specify any server-side encryption, this default encryption is applied.
        public let applyServerSideEncryptionByDefault: AwsS3BucketServerSideEncryptionByDefault?

        public init(applyServerSideEncryptionByDefault: AwsS3BucketServerSideEncryptionByDefault? = nil) {
            self.applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault
        }

        public func validate(name: String) throws {
            try self.applyServerSideEncryptionByDefault?.validate(name: "\(name).applyServerSideEncryptionByDefault")
        }

        private enum CodingKeys: String, CodingKey {
            case applyServerSideEncryptionByDefault = "ApplyServerSideEncryptionByDefault"
        }
    }

    public struct AwsS3BucketWebsiteConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the error document for the website.
        public let errorDocument: String?
        /// The name of the index document for the website.
        public let indexDocumentSuffix: String?
        /// The redirect behavior for requests to the website.
        public let redirectAllRequestsTo: AwsS3BucketWebsiteConfigurationRedirectTo?
        /// The rules for applying redirects for requests to the website.
        public let routingRules: [AwsS3BucketWebsiteConfigurationRoutingRule]?

        public init(errorDocument: String? = nil, indexDocumentSuffix: String? = nil, redirectAllRequestsTo: AwsS3BucketWebsiteConfigurationRedirectTo? = nil, routingRules: [AwsS3BucketWebsiteConfigurationRoutingRule]? = nil) {
            self.errorDocument = errorDocument
            self.indexDocumentSuffix = indexDocumentSuffix
            self.redirectAllRequestsTo = redirectAllRequestsTo
            self.routingRules = routingRules
        }

        public func validate(name: String) throws {
            try self.validate(self.errorDocument, name: "errorDocument", parent: name, pattern: "\\S")
            try self.validate(self.indexDocumentSuffix, name: "indexDocumentSuffix", parent: name, pattern: "\\S")
            try self.redirectAllRequestsTo?.validate(name: "\(name).redirectAllRequestsTo")
            try self.routingRules?.forEach {
                try $0.validate(name: "\(name).routingRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case errorDocument = "ErrorDocument"
            case indexDocumentSuffix = "IndexDocumentSuffix"
            case redirectAllRequestsTo = "RedirectAllRequestsTo"
            case routingRules = "RoutingRules"
        }
    }

    public struct AwsS3BucketWebsiteConfigurationRedirectTo: AWSEncodableShape & AWSDecodableShape {
        /// The name of the host to redirect requests to.
        public let hostname: String?
        /// The protocol to use when redirecting requests. By default, this field uses the same protocol as the original request. Valid values are http or https.
        public let `protocol`: String?

        public init(hostname: String? = nil, protocol: String? = nil) {
            self.hostname = hostname
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.hostname, name: "hostname", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "Hostname"
            case `protocol` = "Protocol"
        }
    }

    public struct AwsS3BucketWebsiteConfigurationRoutingRule: AWSEncodableShape & AWSDecodableShape {
        /// Provides the condition that must be met in order to apply the routing rule.
        public let condition: AwsS3BucketWebsiteConfigurationRoutingRuleCondition?
        /// Provides the rules to redirect the request if the condition in Condition is met.
        public let redirect: AwsS3BucketWebsiteConfigurationRoutingRuleRedirect?

        public init(condition: AwsS3BucketWebsiteConfigurationRoutingRuleCondition? = nil, redirect: AwsS3BucketWebsiteConfigurationRoutingRuleRedirect? = nil) {
            self.condition = condition
            self.redirect = redirect
        }

        public func validate(name: String) throws {
            try self.condition?.validate(name: "\(name).condition")
            try self.redirect?.validate(name: "\(name).redirect")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case redirect = "Redirect"
        }
    }

    public struct AwsS3BucketWebsiteConfigurationRoutingRuleCondition: AWSEncodableShape & AWSDecodableShape {
        /// Indicates to redirect the request if the HTTP error code matches this value.
        public let httpErrorCodeReturnedEquals: String?
        /// Indicates to redirect the request if the key prefix matches this value.
        public let keyPrefixEquals: String?

        public init(httpErrorCodeReturnedEquals: String? = nil, keyPrefixEquals: String? = nil) {
            self.httpErrorCodeReturnedEquals = httpErrorCodeReturnedEquals
            self.keyPrefixEquals = keyPrefixEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.httpErrorCodeReturnedEquals, name: "httpErrorCodeReturnedEquals", parent: name, pattern: "\\S")
            try self.validate(self.keyPrefixEquals, name: "keyPrefixEquals", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case httpErrorCodeReturnedEquals = "HttpErrorCodeReturnedEquals"
            case keyPrefixEquals = "KeyPrefixEquals"
        }
    }

    public struct AwsS3BucketWebsiteConfigurationRoutingRuleRedirect: AWSEncodableShape & AWSDecodableShape {
        /// The host name to use in the redirect request.
        public let hostname: String?
        /// The HTTP redirect code to use in the response.
        public let httpRedirectCode: String?
        /// The protocol to use to redirect the request. By default, uses the protocol from the original request.
        public let `protocol`: String?
        /// The object key prefix to use in the redirect request. Cannot be provided if ReplaceKeyWith is present.
        public let replaceKeyPrefixWith: String?
        /// The specific object key to use in the redirect request. Cannot be provided if ReplaceKeyPrefixWith is present.
        public let replaceKeyWith: String?

        public init(hostname: String? = nil, httpRedirectCode: String? = nil, protocol: String? = nil, replaceKeyPrefixWith: String? = nil, replaceKeyWith: String? = nil) {
            self.hostname = hostname
            self.httpRedirectCode = httpRedirectCode
            self.`protocol` = `protocol`
            self.replaceKeyPrefixWith = replaceKeyPrefixWith
            self.replaceKeyWith = replaceKeyWith
        }

        public func validate(name: String) throws {
            try self.validate(self.hostname, name: "hostname", parent: name, pattern: "\\S")
            try self.validate(self.httpRedirectCode, name: "httpRedirectCode", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.validate(self.replaceKeyPrefixWith, name: "replaceKeyPrefixWith", parent: name, pattern: "\\S")
            try self.validate(self.replaceKeyWith, name: "replaceKeyWith", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "Hostname"
            case httpRedirectCode = "HttpRedirectCode"
            case `protocol` = "Protocol"
            case replaceKeyPrefixWith = "ReplaceKeyPrefixWith"
            case replaceKeyWith = "ReplaceKeyWith"
        }
    }

    public struct AwsS3ObjectDetails: AWSEncodableShape & AWSDecodableShape {
        /// A standard MIME type describing the format of the object data.
        public let contentType: String?
        /// The opaque identifier assigned by a web server to a specific version of a resource found at a URL.
        public let eTag: String?
        /// Indicates when the object was last modified. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastModified: String?
        /// If the object is stored using server-side encryption, the value of the server-side encryption algorithm used when storing this object in Amazon S3.
        public let serverSideEncryption: String?
        /// The identifier of the KMS symmetric customer managed key that was used for the object.
        public let ssekmsKeyId: String?
        /// The version of the object.
        public let versionId: String?

        public init(contentType: String? = nil, eTag: String? = nil, lastModified: String? = nil, serverSideEncryption: String? = nil, ssekmsKeyId: String? = nil, versionId: String? = nil) {
            self.contentType = contentType
            self.eTag = eTag
            self.lastModified = lastModified
            self.serverSideEncryption = serverSideEncryption
            self.ssekmsKeyId = ssekmsKeyId
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "\\S")
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "\\S")
            try self.validate(self.lastModified, name: "lastModified", parent: name, pattern: "\\S")
            try self.validate(self.serverSideEncryption, name: "serverSideEncryption", parent: name, pattern: "\\S")
            try self.validate(self.ssekmsKeyId, name: "ssekmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case eTag = "ETag"
            case lastModified = "LastModified"
            case serverSideEncryption = "ServerSideEncryption"
            case ssekmsKeyId = "SSEKMSKeyId"
            case versionId = "VersionId"
        }
    }

    public struct AwsSageMakerNotebookInstanceDetails: AWSEncodableShape & AWSDecodableShape {
        ///  A list of Amazon Elastic Inference instance types to associate with the notebook instance. Currently, only one instance type can be associated with a notebook instance.
        public let acceleratorTypes: [String]?
        ///  An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in AWS CodeCommit or in any other Git repository.  These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see Associating Git repositories with SageMaker notebook instances in the Amazon SageMaker Developer Guide.
        public let additionalCodeRepositories: [String]?
        ///  The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in AWS CodeCommit or in any other Git repository.  When you open a notebook instance, it opens in the directory that contains this repository. For more information, see Associating Git repositories with SageMaker notebook instances in the Amazon SageMaker Developer Guide.
        public let defaultCodeRepository: String?
        ///  Sets whether SageMaker provides internet access to the notebook instance. If you set this to Disabled, this notebook instance is able to access resources only in your VPC, and is not be able to connect to SageMaker training and endpoint services unless you configure a Network Address Translation (NAT) Gateway in your VPC.
        public let directInternetAccess: String?
        ///  If status of the instance is Failed, the reason it failed.
        public let failureReason: String?
        ///  Information on the IMDS configuration of the notebook instance.
        public let instanceMetadataServiceConfiguration: AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails?
        ///  The type of machine learning (ML) compute instance to launch for the notebook instance.
        public let instanceType: String?
        ///  The Amazon Resource Name (ARN) of an Key Management Service (KMS) key that SageMaker uses to encrypt data on the storage volume attached to your notebook instance. The KMS key you provide must be enabled. For information, see  Enabling and disabling keys in the Key Management Service Developer Guide.
        public let kmsKeyId: String?
        ///  The network interface ID that SageMaker created when the instance was created.
        public let networkInterfaceId: String?
        ///  The Amazon Resource Name (ARN) of the notebook instance.
        public let notebookInstanceArn: String?
        ///  The name of a notebook instance lifecycle configuration.
        public let notebookInstanceLifecycleConfigName: String?
        ///  The name of the new notebook instance.
        public let notebookInstanceName: String?
        ///  The status of the notebook instance.
        public let notebookInstanceStatus: String?
        ///  The platform identifier of the notebook instance runtime environment.
        public let platformIdentifier: String?
        ///  The Amazon Resource Name (ARN) of the IAM role associated with the instance.
        public let roleArn: String?
        ///  Whether root access is enabled or disabled for users of the notebook instance.
        public let rootAccess: String?
        ///  The VPC security group IDs.
        public let securityGroups: [String]?
        ///  The ID of the VPC subnet to which you have a connectivity from your ML compute instance.
        public let subnetId: String?
        ///  The URL that you use to connect to the Jupyter notebook that is running in your notebook instance.
        public let url: String?
        ///  The size, in GB, of the ML storage volume to attach to the notebook instance.
        public let volumeSizeInGB: Int?

        public init(acceleratorTypes: [String]? = nil, additionalCodeRepositories: [String]? = nil, defaultCodeRepository: String? = nil, directInternetAccess: String? = nil, failureReason: String? = nil, instanceMetadataServiceConfiguration: AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails? = nil, instanceType: String? = nil, kmsKeyId: String? = nil, networkInterfaceId: String? = nil, notebookInstanceArn: String? = nil, notebookInstanceLifecycleConfigName: String? = nil, notebookInstanceName: String? = nil, notebookInstanceStatus: String? = nil, platformIdentifier: String? = nil, roleArn: String? = nil, rootAccess: String? = nil, securityGroups: [String]? = nil, subnetId: String? = nil, url: String? = nil, volumeSizeInGB: Int? = nil) {
            self.acceleratorTypes = acceleratorTypes
            self.additionalCodeRepositories = additionalCodeRepositories
            self.defaultCodeRepository = defaultCodeRepository
            self.directInternetAccess = directInternetAccess
            self.failureReason = failureReason
            self.instanceMetadataServiceConfiguration = instanceMetadataServiceConfiguration
            self.instanceType = instanceType
            self.kmsKeyId = kmsKeyId
            self.networkInterfaceId = networkInterfaceId
            self.notebookInstanceArn = notebookInstanceArn
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.notebookInstanceName = notebookInstanceName
            self.notebookInstanceStatus = notebookInstanceStatus
            self.platformIdentifier = platformIdentifier
            self.roleArn = roleArn
            self.rootAccess = rootAccess
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.url = url
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.acceleratorTypes?.forEach {
                try validate($0, name: "acceleratorTypes[]", parent: name, pattern: "\\S")
            }
            try self.additionalCodeRepositories?.forEach {
                try validate($0, name: "additionalCodeRepositories[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.defaultCodeRepository, name: "defaultCodeRepository", parent: name, pattern: "\\S")
            try self.validate(self.directInternetAccess, name: "directInternetAccess", parent: name, pattern: "\\S")
            try self.validate(self.failureReason, name: "failureReason", parent: name, pattern: "\\S")
            try self.instanceMetadataServiceConfiguration?.validate(name: "\(name).instanceMetadataServiceConfiguration")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
            try self.validate(self.notebookInstanceArn, name: "notebookInstanceArn", parent: name, pattern: "\\S")
            try self.validate(self.notebookInstanceLifecycleConfigName, name: "notebookInstanceLifecycleConfigName", parent: name, pattern: "\\S")
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, pattern: "\\S")
            try self.validate(self.notebookInstanceStatus, name: "notebookInstanceStatus", parent: name, pattern: "\\S")
            try self.validate(self.platformIdentifier, name: "platformIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.rootAccess, name: "rootAccess", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
            try self.validate(self.url, name: "url", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorTypes = "AcceleratorTypes"
            case additionalCodeRepositories = "AdditionalCodeRepositories"
            case defaultCodeRepository = "DefaultCodeRepository"
            case directInternetAccess = "DirectInternetAccess"
            case failureReason = "FailureReason"
            case instanceMetadataServiceConfiguration = "InstanceMetadataServiceConfiguration"
            case instanceType = "InstanceType"
            case kmsKeyId = "KmsKeyId"
            case networkInterfaceId = "NetworkInterfaceId"
            case notebookInstanceArn = "NotebookInstanceArn"
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case notebookInstanceName = "NotebookInstanceName"
            case notebookInstanceStatus = "NotebookInstanceStatus"
            case platformIdentifier = "PlatformIdentifier"
            case roleArn = "RoleArn"
            case rootAccess = "RootAccess"
            case securityGroups = "SecurityGroups"
            case subnetId = "SubnetId"
            case url = "Url"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates the minimum IMDS version that the notebook instance supports.
        public let minimumInstanceMetadataServiceVersion: String?

        public init(minimumInstanceMetadataServiceVersion: String? = nil) {
            self.minimumInstanceMetadataServiceVersion = minimumInstanceMetadataServiceVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.minimumInstanceMetadataServiceVersion, name: "minimumInstanceMetadataServiceVersion", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case minimumInstanceMetadataServiceVersion = "MinimumInstanceMetadataServiceVersion"
        }
    }

    public struct AwsSecretsManagerSecretDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the secret is deleted.
        public let deleted: Bool?
        /// The user-provided description of the secret.
        public let description: String?
        /// The ARN, Key ID, or alias of the KMS key used to encrypt the SecretString or SecretBinary values for versions of this secret.
        public let kmsKeyId: String?
        /// The name of the secret.
        public let name: String?
        /// Whether rotation is enabled.
        public let rotationEnabled: Bool?
        /// The ARN of the Lambda function that rotates the secret.
        public let rotationLambdaArn: String?
        /// Whether the rotation occurred within the specified rotation frequency.
        public let rotationOccurredWithinFrequency: Bool?
        /// Defines the rotation schedule for the secret.
        public let rotationRules: AwsSecretsManagerSecretRotationRules?

        public init(deleted: Bool? = nil, description: String? = nil, kmsKeyId: String? = nil, name: String? = nil, rotationEnabled: Bool? = nil, rotationLambdaArn: String? = nil, rotationOccurredWithinFrequency: Bool? = nil, rotationRules: AwsSecretsManagerSecretRotationRules? = nil) {
            self.deleted = deleted
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.rotationEnabled = rotationEnabled
            self.rotationLambdaArn = rotationLambdaArn
            self.rotationOccurredWithinFrequency = rotationOccurredWithinFrequency
            self.rotationRules = rotationRules
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.rotationLambdaArn, name: "rotationLambdaArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deleted = "Deleted"
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case rotationEnabled = "RotationEnabled"
            case rotationLambdaArn = "RotationLambdaArn"
            case rotationOccurredWithinFrequency = "RotationOccurredWithinFrequency"
            case rotationRules = "RotationRules"
        }
    }

    public struct AwsSecretsManagerSecretRotationRules: AWSEncodableShape & AWSDecodableShape {
        /// The number of days after the previous rotation to rotate the secret.
        public let automaticallyAfterDays: Int?

        public init(automaticallyAfterDays: Int? = nil) {
            self.automaticallyAfterDays = automaticallyAfterDays
        }

        private enum CodingKeys: String, CodingKey {
            case automaticallyAfterDays = "AutomaticallyAfterDays"
        }
    }

    public struct AwsSecurityFinding: AWSEncodableShape & AWSDecodableShape {
        /// Provides details about an action that affects or that was taken on a resource.
        public let action: Action?
        /// The Amazon Web Services account ID that a finding is generated in.
        public let awsAccountId: String
        /// The name of the company for the product that generated the finding. Security Hub populates this attribute automatically for each finding. You cannot update this attribute with BatchImportFindings or BatchUpdateFindings. The exception to this is a custom integration. When you use the Security Hub console or API to filter findings by company name, you use this attribute.
        public let companyName: String?
        /// This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported security standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.
        public let compliance: Compliance?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: Int?
        /// Indicates when the security-findings provider created the potential security issue that a finding captured. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let createdAt: String
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: Int?
        /// A finding's description.  In this release, Description is a required property.
        public let description: String
        /// In a BatchImportFindings request, finding providers use FindingProviderFields to provide and update their own values for confidence, criticality, related findings, severity, and types.
        public let findingProviderFields: FindingProviderFields?
        /// Indicates when the security-findings provider first observed the potential security issue that a finding captured. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let firstObservedAt: String?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc.
        public let generatorId: String
        /// The security findings provider-specific identifier for a finding.
        public let id: String
        /// Indicates when the security-findings provider most recently observed the potential security issue that a finding captured. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastObservedAt: String?
        /// A list of malware related to a finding.
        public let malware: [Malware]?
        /// The details of network-related information about a finding.
        public let network: Network?
        /// Provides information about a network path that is relevant to a finding. Each entry under NetworkPath represents a component of that path.
        public let networkPath: [NetworkPathComponent]?
        /// A user-defined note added to a finding.
        public let note: Note?
        /// Provides an overview of the patch compliance status for an instance against a selected compliance standard.
        public let patchSummary: PatchSummary?
        /// The details of process-related information about a finding.
        public let process: ProcessDetails?
        /// The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.
        public let productArn: String
        /// A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. Can contain up to 50 key-value pairs. For each key-value pair, the key can contain up to 128 characters, and the value can contain up to 2048 characters.
        public let productFields: [String: String]?
        /// The name of the product that generated the finding. Security Hub populates this attribute automatically for each finding. You cannot update this attribute with BatchImportFindings or BatchUpdateFindings. The exception to this is a custom integration. When you use the Security Hub console or API to filter findings by product name, you use this attribute.
        public let productName: String?
        /// The record state of a finding.
        public let recordState: RecordState?
        /// The Region from which the finding was generated. Security Hub populates this attribute automatically for each finding. You cannot update it using BatchImportFindings or BatchUpdateFindings.
        public let region: String?
        /// A list of related findings.
        public let relatedFindings: [RelatedFinding]?
        /// A data type that describes the remediation options for a finding.
        public let remediation: Remediation?
        /// A set of resource data types that describe the resources that the finding refers to.
        public let resources: [Resource]
        /// Indicates whether the finding is a sample finding.
        public let sample: Bool?
        /// The schema version that a finding is formatted for.
        public let schemaVersion: String
        /// A finding's severity.
        public let severity: Severity?
        /// A URL that links to a page about the current finding in the security-findings provider's solution.
        public let sourceUrl: String?
        /// Threat intelligence details related to a finding.
        public let threatIntelIndicators: [ThreatIntelIndicator]?
        /// Details about the threat detected in a security finding and the file paths that were affected by the threat.
        public let threats: [Threat]?
        /// A finding's title.  In this release, Title is a required property.
        public let title: String
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public let types: [String]?
        /// Indicates when the security-findings provider last updated the finding record. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let updatedAt: String
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
        public let userDefinedFields: [String: String]?
        /// Indicates the veracity of a finding.
        public let verificationState: VerificationState?
        /// Provides a list of vulnerabilities associated with the findings.
        public let vulnerabilities: [Vulnerability]?
        /// Provides information about the status of the investigation into a finding.
        public let workflow: Workflow?
        /// The workflow state of a finding.
        public let workflowState: WorkflowState?

        public init(action: Action? = nil, awsAccountId: String, companyName: String? = nil, compliance: Compliance? = nil, confidence: Int? = nil, createdAt: String, criticality: Int? = nil, description: String, findingProviderFields: FindingProviderFields? = nil, firstObservedAt: String? = nil, generatorId: String, id: String, lastObservedAt: String? = nil, malware: [Malware]? = nil, network: Network? = nil, networkPath: [NetworkPathComponent]? = nil, note: Note? = nil, patchSummary: PatchSummary? = nil, process: ProcessDetails? = nil, productArn: String, productFields: [String: String]? = nil, productName: String? = nil, recordState: RecordState? = nil, region: String? = nil, relatedFindings: [RelatedFinding]? = nil, remediation: Remediation? = nil, resources: [Resource], sample: Bool? = nil, schemaVersion: String, severity: Severity? = nil, sourceUrl: String? = nil, threatIntelIndicators: [ThreatIntelIndicator]? = nil, threats: [Threat]? = nil, title: String, types: [String]? = nil, updatedAt: String, userDefinedFields: [String: String]? = nil, verificationState: VerificationState? = nil, vulnerabilities: [Vulnerability]? = nil, workflow: Workflow? = nil, workflowState: WorkflowState? = nil) {
            self.action = action
            self.awsAccountId = awsAccountId
            self.companyName = companyName
            self.compliance = compliance
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.findingProviderFields = findingProviderFields
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.lastObservedAt = lastObservedAt
            self.malware = malware
            self.network = network
            self.networkPath = networkPath
            self.note = note
            self.patchSummary = patchSummary
            self.process = process
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recordState = recordState
            self.region = region
            self.relatedFindings = relatedFindings
            self.remediation = remediation
            self.resources = resources
            self.sample = sample
            self.schemaVersion = schemaVersion
            self.severity = severity
            self.sourceUrl = sourceUrl
            self.threatIntelIndicators = threatIntelIndicators
            self.threats = threats
            self.title = title
            self.types = types
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.vulnerabilities = vulnerabilities
            self.workflow = workflow
            self.workflowState = workflowState
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "\\S")
            try self.validate(self.companyName, name: "companyName", parent: name, pattern: "\\S")
            try self.compliance?.validate(name: "\(name).compliance")
            try self.validate(self.createdAt, name: "createdAt", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.findingProviderFields?.validate(name: "\(name).findingProviderFields")
            try self.validate(self.firstObservedAt, name: "firstObservedAt", parent: name, pattern: "\\S")
            try self.validate(self.generatorId, name: "generatorId", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.lastObservedAt, name: "lastObservedAt", parent: name, pattern: "\\S")
            try self.malware?.forEach {
                try $0.validate(name: "\(name).malware[]")
            }
            try self.network?.validate(name: "\(name).network")
            try self.networkPath?.forEach {
                try $0.validate(name: "\(name).networkPath[]")
            }
            try self.note?.validate(name: "\(name).note")
            try self.patchSummary?.validate(name: "\(name).patchSummary")
            try self.process?.validate(name: "\(name).process")
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
            try self.productFields?.forEach {
                try validate($0.key, name: "productFields.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "productFields[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.productName, name: "productName", parent: name, pattern: "\\S")
            try self.validate(self.region, name: "region", parent: name, pattern: "\\S")
            try self.relatedFindings?.forEach {
                try $0.validate(name: "\(name).relatedFindings[]")
            }
            try self.remediation?.validate(name: "\(name).remediation")
            try self.resources.forEach {
                try $0.validate(name: "\(name).resources[]")
            }
            try self.validate(self.schemaVersion, name: "schemaVersion", parent: name, pattern: "\\S")
            try self.severity?.validate(name: "\(name).severity")
            try self.validate(self.sourceUrl, name: "sourceUrl", parent: name, pattern: "\\S")
            try self.threatIntelIndicators?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicators[]")
            }
            try self.threats?.forEach {
                try $0.validate(name: "\(name).threats[]")
            }
            try self.validate(self.title, name: "title", parent: name, pattern: "\\S")
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.updatedAt, name: "updatedAt", parent: name, pattern: "\\S")
            try self.userDefinedFields?.forEach {
                try validate($0.key, name: "userDefinedFields.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "userDefinedFields[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.vulnerabilities?.forEach {
                try $0.validate(name: "\(name).vulnerabilities[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case awsAccountId = "AwsAccountId"
            case companyName = "CompanyName"
            case compliance = "Compliance"
            case confidence = "Confidence"
            case createdAt = "CreatedAt"
            case criticality = "Criticality"
            case description = "Description"
            case findingProviderFields = "FindingProviderFields"
            case firstObservedAt = "FirstObservedAt"
            case generatorId = "GeneratorId"
            case id = "Id"
            case lastObservedAt = "LastObservedAt"
            case malware = "Malware"
            case network = "Network"
            case networkPath = "NetworkPath"
            case note = "Note"
            case patchSummary = "PatchSummary"
            case process = "Process"
            case productArn = "ProductArn"
            case productFields = "ProductFields"
            case productName = "ProductName"
            case recordState = "RecordState"
            case region = "Region"
            case relatedFindings = "RelatedFindings"
            case remediation = "Remediation"
            case resources = "Resources"
            case sample = "Sample"
            case schemaVersion = "SchemaVersion"
            case severity = "Severity"
            case sourceUrl = "SourceUrl"
            case threatIntelIndicators = "ThreatIntelIndicators"
            case threats = "Threats"
            case title = "Title"
            case types = "Types"
            case updatedAt = "UpdatedAt"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case vulnerabilities = "Vulnerabilities"
            case workflow = "Workflow"
            case workflowState = "WorkflowState"
        }
    }

    public struct AwsSecurityFindingFilters: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services account ID that a finding is generated in.
        public let awsAccountId: [StringFilter]?
        /// The name of the findings provider (company) that owns the solution (product) that generates findings.
        public let companyName: [StringFilter]?
        /// Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.
        public let complianceStatus: [StringFilter]?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: [NumberFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured.
        public let createdAt: [DateFilter]?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: [NumberFilter]?
        /// A finding's description.
        public let description: [StringFilter]?
        /// The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let findingProviderFieldsConfidence: [NumberFilter]?
        /// The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let findingProviderFieldsCriticality: [NumberFilter]?
        /// The finding identifier of a related finding that is identified by the finding provider.
        public let findingProviderFieldsRelatedFindingsId: [StringFilter]?
        /// The ARN of the solution that generated a related finding that is identified by the finding provider.
        public let findingProviderFieldsRelatedFindingsProductArn: [StringFilter]?
        /// The finding provider value for the severity label.
        public let findingProviderFieldsSeverityLabel: [StringFilter]?
        /// The finding provider's original value for the severity.
        public let findingProviderFieldsSeverityOriginal: [StringFilter]?
        /// One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public let findingProviderFieldsTypes: [StringFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured.
        public let firstObservedAt: [DateFilter]?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc.
        public let generatorId: [StringFilter]?
        /// The security findings provider-specific identifier for a finding.
        public let id: [StringFilter]?
        /// A keyword for a finding.
        public let keyword: [KeywordFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured.
        public let lastObservedAt: [DateFilter]?
        /// The name of the malware that was observed.
        public let malwareName: [StringFilter]?
        /// The filesystem path of the malware that was observed.
        public let malwarePath: [StringFilter]?
        /// The state of the malware that was observed.
        public let malwareState: [StringFilter]?
        /// The type of the malware that was observed.
        public let malwareType: [StringFilter]?
        /// The destination domain of network-related information about a finding.
        public let networkDestinationDomain: [StringFilter]?
        /// The destination IPv4 address of network-related information about a finding.
        public let networkDestinationIpV4: [IpFilter]?
        /// The destination IPv6 address of network-related information about a finding.
        public let networkDestinationIpV6: [IpFilter]?
        /// The destination port of network-related information about a finding.
        public let networkDestinationPort: [NumberFilter]?
        /// Indicates the direction of network traffic associated with a finding.
        public let networkDirection: [StringFilter]?
        /// The protocol of network-related information about a finding.
        public let networkProtocol: [StringFilter]?
        /// The source domain of network-related information about a finding.
        public let networkSourceDomain: [StringFilter]?
        /// The source IPv4 address of network-related information about a finding.
        public let networkSourceIpV4: [IpFilter]?
        /// The source IPv6 address of network-related information about a finding.
        public let networkSourceIpV6: [IpFilter]?
        /// The source media access control (MAC) address of network-related information about a finding.
        public let networkSourceMac: [StringFilter]?
        /// The source port of network-related information about a finding.
        public let networkSourcePort: [NumberFilter]?
        /// The text of a note.
        public let noteText: [StringFilter]?
        /// The timestamp of when the note was updated.
        public let noteUpdatedAt: [DateFilter]?
        /// The principal that created a note.
        public let noteUpdatedBy: [StringFilter]?
        /// The date/time that the process was launched.
        public let processLaunchedAt: [DateFilter]?
        /// The name of the process.
        public let processName: [StringFilter]?
        /// The parent process ID.
        public let processParentPid: [NumberFilter]?
        /// The path to the process executable.
        public let processPath: [StringFilter]?
        /// The process ID.
        public let processPid: [NumberFilter]?
        /// The date/time that the process was terminated.
        public let processTerminatedAt: [DateFilter]?
        /// The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub.
        public let productArn: [StringFilter]?
        /// A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format.
        public let productFields: [MapFilter]?
        /// The name of the solution (product) that generates findings.
        public let productName: [StringFilter]?
        /// The recommendation of what to do about the issue described in a finding.
        public let recommendationText: [StringFilter]?
        /// The updated record state for the finding.
        public let recordState: [StringFilter]?
        /// The Region from which the finding was generated.
        public let region: [StringFilter]?
        /// The solution-generated identifier for a related finding.
        public let relatedFindingsId: [StringFilter]?
        /// The ARN of the solution that generated a related finding.
        public let relatedFindingsProductArn: [StringFilter]?
        /// The IAM profile ARN of the instance.
        public let resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public let resourceAwsEc2InstanceImageId: [StringFilter]?
        /// The IPv4 addresses associated with the instance.
        public let resourceAwsEc2InstanceIpV4Addresses: [IpFilter]?
        /// The IPv6 addresses associated with the instance.
        public let resourceAwsEc2InstanceIpV6Addresses: [IpFilter]?
        /// The key name associated with the instance.
        public let resourceAwsEc2InstanceKeyName: [StringFilter]?
        /// The date and time the instance was launched.
        public let resourceAwsEc2InstanceLaunchedAt: [DateFilter]?
        /// The identifier of the subnet that the instance was launched in.
        public let resourceAwsEc2InstanceSubnetId: [StringFilter]?
        /// The instance type of the instance.
        public let resourceAwsEc2InstanceType: [StringFilter]?
        /// The identifier of the VPC that the instance was launched in.
        public let resourceAwsEc2InstanceVpcId: [StringFilter]?
        /// The creation date/time of the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyCreatedAt: [DateFilter]?
        /// The name of the principal that is associated with an IAM access key.
        public let resourceAwsIamAccessKeyPrincipalName: [StringFilter]?
        /// The status of the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyStatus: [StringFilter]?
        /// The user associated with the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyUserName: [StringFilter]?
        /// The name of an IAM user.
        public let resourceAwsIamUserUserName: [StringFilter]?
        /// The canonical user ID of the owner of the S3 bucket.
        public let resourceAwsS3BucketOwnerId: [StringFilter]?
        /// The display name of the owner of the S3 bucket.
        public let resourceAwsS3BucketOwnerName: [StringFilter]?
        /// The identifier of the image related to a finding.
        public let resourceContainerImageId: [StringFilter]?
        /// The name of the image related to a finding.
        public let resourceContainerImageName: [StringFilter]?
        /// The date/time that the container was started.
        public let resourceContainerLaunchedAt: [DateFilter]?
        /// The name of the container related to a finding.
        public let resourceContainerName: [StringFilter]?
        /// The details of a resource that doesn't have a specific subfield for the resource type defined.
        public let resourceDetailsOther: [MapFilter]?
        /// The canonical identifier for the given resource type.
        public let resourceId: [StringFilter]?
        /// The canonical Amazon Web Services partition name that the Region is assigned to.
        public let resourcePartition: [StringFilter]?
        /// The canonical Amazon Web Services external Region name where this resource is located.
        public let resourceRegion: [StringFilter]?
        /// A list of Amazon Web Services tags associated with a resource at the time the finding was processed.
        public let resourceTags: [MapFilter]?
        /// Specifies the type of the resource that details are provided for.
        public let resourceType: [StringFilter]?
        /// Indicates whether or not sample findings are included in the filter results.
        public let sample: [BooleanFilter]?
        /// The label of a finding's severity.
        public let severityLabel: [StringFilter]?
        /// The normalized severity of a finding.
        public let severityNormalized: [NumberFilter]?
        /// The native severity as defined by the security-findings provider's solution that generated the finding.
        public let severityProduct: [NumberFilter]?
        /// A URL that links to a page about the current finding in the security-findings provider's solution.
        public let sourceUrl: [StringFilter]?
        /// The category of a threat intelligence indicator.
        public let threatIntelIndicatorCategory: [StringFilter]?
        /// The date/time of the last observation of a threat intelligence indicator.
        public let threatIntelIndicatorLastObservedAt: [DateFilter]?
        /// The source of the threat intelligence.
        public let threatIntelIndicatorSource: [StringFilter]?
        /// The URL for more details from the source of the threat intelligence.
        public let threatIntelIndicatorSourceUrl: [StringFilter]?
        /// The type of a threat intelligence indicator.
        public let threatIntelIndicatorType: [StringFilter]?
        /// The value of a threat intelligence indicator.
        public let threatIntelIndicatorValue: [StringFilter]?
        /// A finding's title.
        public let title: [StringFilter]?
        /// A finding type in the format of namespace/category/classifier that classifies a finding.
        public let type: [StringFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record.
        public let updatedAt: [DateFilter]?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
        public let userDefinedFields: [MapFilter]?
        /// The veracity of a finding.
        public let verificationState: [StringFilter]?
        /// The workflow state of a finding. Note that this field is deprecated. To search for a finding based on its workflow status, use WorkflowStatus.
        public let workflowState: [StringFilter]?
        /// The status of the investigation into a finding. Allowed values are the following.    NEW - The initial state of a finding, before it is reviewed. Security Hub also resets the workflow status from NOTIFIED or RESOLVED to NEW in the following cases:    RecordState changes from ARCHIVED to ACTIVE.    Compliance.Status changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.      NOTIFIED - Indicates that the resource owner has been notified about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner. If one of the following occurs, the workflow status is changed automatically from NOTIFIED to NEW:    RecordState changes from ARCHIVED to ACTIVE.    Compliance.Status changes from PASSED to FAILED, WARNING, or NOT_AVAILABLE.      SUPPRESSED - Indicates that you reviewed the finding and do not believe that any action is needed. The workflow status of a SUPPRESSED finding does not change if RecordState changes from ARCHIVED to ACTIVE.    RESOLVED - The finding was reviewed and remediated and is now considered resolved.  The finding remains RESOLVED unless one of the following occurs:    RecordState changes from ARCHIVED to ACTIVE.    Compliance.Status changes from PASSED to FAILED, WARNING, or NOT_AVAILABLE.   In those cases, the workflow status is automatically reset to NEW. For findings from controls, if Compliance.Status is PASSED, then Security Hub automatically sets the workflow status to RESOLVED.
        public let workflowStatus: [StringFilter]?

        public init(awsAccountId: [StringFilter]? = nil, companyName: [StringFilter]? = nil, complianceStatus: [StringFilter]? = nil, confidence: [NumberFilter]? = nil, createdAt: [DateFilter]? = nil, criticality: [NumberFilter]? = nil, description: [StringFilter]? = nil, findingProviderFieldsConfidence: [NumberFilter]? = nil, findingProviderFieldsCriticality: [NumberFilter]? = nil, findingProviderFieldsRelatedFindingsId: [StringFilter]? = nil, findingProviderFieldsRelatedFindingsProductArn: [StringFilter]? = nil, findingProviderFieldsSeverityLabel: [StringFilter]? = nil, findingProviderFieldsSeverityOriginal: [StringFilter]? = nil, findingProviderFieldsTypes: [StringFilter]? = nil, firstObservedAt: [DateFilter]? = nil, generatorId: [StringFilter]? = nil, id: [StringFilter]? = nil, lastObservedAt: [DateFilter]? = nil, malwareName: [StringFilter]? = nil, malwarePath: [StringFilter]? = nil, malwareState: [StringFilter]? = nil, malwareType: [StringFilter]? = nil, networkDestinationDomain: [StringFilter]? = nil, networkDestinationIpV4: [IpFilter]? = nil, networkDestinationIpV6: [IpFilter]? = nil, networkDestinationPort: [NumberFilter]? = nil, networkDirection: [StringFilter]? = nil, networkProtocol: [StringFilter]? = nil, networkSourceDomain: [StringFilter]? = nil, networkSourceIpV4: [IpFilter]? = nil, networkSourceIpV6: [IpFilter]? = nil, networkSourceMac: [StringFilter]? = nil, networkSourcePort: [NumberFilter]? = nil, noteText: [StringFilter]? = nil, noteUpdatedAt: [DateFilter]? = nil, noteUpdatedBy: [StringFilter]? = nil, processLaunchedAt: [DateFilter]? = nil, processName: [StringFilter]? = nil, processParentPid: [NumberFilter]? = nil, processPath: [StringFilter]? = nil, processPid: [NumberFilter]? = nil, processTerminatedAt: [DateFilter]? = nil, productArn: [StringFilter]? = nil, productFields: [MapFilter]? = nil, productName: [StringFilter]? = nil, recommendationText: [StringFilter]? = nil, recordState: [StringFilter]? = nil, region: [StringFilter]? = nil, relatedFindingsId: [StringFilter]? = nil, relatedFindingsProductArn: [StringFilter]? = nil, resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]? = nil, resourceAwsEc2InstanceImageId: [StringFilter]? = nil, resourceAwsEc2InstanceIpV4Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceIpV6Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceKeyName: [StringFilter]? = nil, resourceAwsEc2InstanceLaunchedAt: [DateFilter]? = nil, resourceAwsEc2InstanceSubnetId: [StringFilter]? = nil, resourceAwsEc2InstanceType: [StringFilter]? = nil, resourceAwsEc2InstanceVpcId: [StringFilter]? = nil, resourceAwsIamAccessKeyCreatedAt: [DateFilter]? = nil, resourceAwsIamAccessKeyPrincipalName: [StringFilter]? = nil, resourceAwsIamAccessKeyStatus: [StringFilter]? = nil, resourceAwsIamUserUserName: [StringFilter]? = nil, resourceAwsS3BucketOwnerId: [StringFilter]? = nil, resourceAwsS3BucketOwnerName: [StringFilter]? = nil, resourceContainerImageId: [StringFilter]? = nil, resourceContainerImageName: [StringFilter]? = nil, resourceContainerLaunchedAt: [DateFilter]? = nil, resourceContainerName: [StringFilter]? = nil, resourceDetailsOther: [MapFilter]? = nil, resourceId: [StringFilter]? = nil, resourcePartition: [StringFilter]? = nil, resourceRegion: [StringFilter]? = nil, resourceTags: [MapFilter]? = nil, resourceType: [StringFilter]? = nil, sample: [BooleanFilter]? = nil, severityLabel: [StringFilter]? = nil, sourceUrl: [StringFilter]? = nil, threatIntelIndicatorCategory: [StringFilter]? = nil, threatIntelIndicatorLastObservedAt: [DateFilter]? = nil, threatIntelIndicatorSource: [StringFilter]? = nil, threatIntelIndicatorSourceUrl: [StringFilter]? = nil, threatIntelIndicatorType: [StringFilter]? = nil, threatIntelIndicatorValue: [StringFilter]? = nil, title: [StringFilter]? = nil, type: [StringFilter]? = nil, updatedAt: [DateFilter]? = nil, userDefinedFields: [MapFilter]? = nil, verificationState: [StringFilter]? = nil, workflowState: [StringFilter]? = nil, workflowStatus: [StringFilter]? = nil) {
            self.awsAccountId = awsAccountId
            self.companyName = companyName
            self.complianceStatus = complianceStatus
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.findingProviderFieldsConfidence = findingProviderFieldsConfidence
            self.findingProviderFieldsCriticality = findingProviderFieldsCriticality
            self.findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsId
            self.findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArn
            self.findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabel
            self.findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginal
            self.findingProviderFieldsTypes = findingProviderFieldsTypes
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.keyword = nil
            self.lastObservedAt = lastObservedAt
            self.malwareName = malwareName
            self.malwarePath = malwarePath
            self.malwareState = malwareState
            self.malwareType = malwareType
            self.networkDestinationDomain = networkDestinationDomain
            self.networkDestinationIpV4 = networkDestinationIpV4
            self.networkDestinationIpV6 = networkDestinationIpV6
            self.networkDestinationPort = networkDestinationPort
            self.networkDirection = networkDirection
            self.networkProtocol = networkProtocol
            self.networkSourceDomain = networkSourceDomain
            self.networkSourceIpV4 = networkSourceIpV4
            self.networkSourceIpV6 = networkSourceIpV6
            self.networkSourceMac = networkSourceMac
            self.networkSourcePort = networkSourcePort
            self.noteText = noteText
            self.noteUpdatedAt = noteUpdatedAt
            self.noteUpdatedBy = noteUpdatedBy
            self.processLaunchedAt = processLaunchedAt
            self.processName = processName
            self.processParentPid = processParentPid
            self.processPath = processPath
            self.processPid = processPid
            self.processTerminatedAt = processTerminatedAt
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recommendationText = recommendationText
            self.recordState = recordState
            self.region = region
            self.relatedFindingsId = relatedFindingsId
            self.relatedFindingsProductArn = relatedFindingsProductArn
            self.resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn
            self.resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId
            self.resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses
            self.resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses
            self.resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName
            self.resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt
            self.resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId
            self.resourceAwsEc2InstanceType = resourceAwsEc2InstanceType
            self.resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId
            self.resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt
            self.resourceAwsIamAccessKeyPrincipalName = resourceAwsIamAccessKeyPrincipalName
            self.resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus
            self.resourceAwsIamAccessKeyUserName = nil
            self.resourceAwsIamUserUserName = resourceAwsIamUserUserName
            self.resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId
            self.resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName
            self.resourceContainerImageId = resourceContainerImageId
            self.resourceContainerImageName = resourceContainerImageName
            self.resourceContainerLaunchedAt = resourceContainerLaunchedAt
            self.resourceContainerName = resourceContainerName
            self.resourceDetailsOther = resourceDetailsOther
            self.resourceId = resourceId
            self.resourcePartition = resourcePartition
            self.resourceRegion = resourceRegion
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.sample = sample
            self.severityLabel = severityLabel
            self.severityNormalized = nil
            self.severityProduct = nil
            self.sourceUrl = sourceUrl
            self.threatIntelIndicatorCategory = threatIntelIndicatorCategory
            self.threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt
            self.threatIntelIndicatorSource = threatIntelIndicatorSource
            self.threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl
            self.threatIntelIndicatorType = threatIntelIndicatorType
            self.threatIntelIndicatorValue = threatIntelIndicatorValue
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflowState = workflowState
            self.workflowStatus = workflowStatus
        }

        @available(*, deprecated, message: "Members keyword, resourceAwsIamAccessKeyUserName, severityNormalized, severityProduct have been deprecated")
        public init(awsAccountId: [StringFilter]? = nil, companyName: [StringFilter]? = nil, complianceStatus: [StringFilter]? = nil, confidence: [NumberFilter]? = nil, createdAt: [DateFilter]? = nil, criticality: [NumberFilter]? = nil, description: [StringFilter]? = nil, findingProviderFieldsConfidence: [NumberFilter]? = nil, findingProviderFieldsCriticality: [NumberFilter]? = nil, findingProviderFieldsRelatedFindingsId: [StringFilter]? = nil, findingProviderFieldsRelatedFindingsProductArn: [StringFilter]? = nil, findingProviderFieldsSeverityLabel: [StringFilter]? = nil, findingProviderFieldsSeverityOriginal: [StringFilter]? = nil, findingProviderFieldsTypes: [StringFilter]? = nil, firstObservedAt: [DateFilter]? = nil, generatorId: [StringFilter]? = nil, id: [StringFilter]? = nil, keyword: [KeywordFilter]? = nil, lastObservedAt: [DateFilter]? = nil, malwareName: [StringFilter]? = nil, malwarePath: [StringFilter]? = nil, malwareState: [StringFilter]? = nil, malwareType: [StringFilter]? = nil, networkDestinationDomain: [StringFilter]? = nil, networkDestinationIpV4: [IpFilter]? = nil, networkDestinationIpV6: [IpFilter]? = nil, networkDestinationPort: [NumberFilter]? = nil, networkDirection: [StringFilter]? = nil, networkProtocol: [StringFilter]? = nil, networkSourceDomain: [StringFilter]? = nil, networkSourceIpV4: [IpFilter]? = nil, networkSourceIpV6: [IpFilter]? = nil, networkSourceMac: [StringFilter]? = nil, networkSourcePort: [NumberFilter]? = nil, noteText: [StringFilter]? = nil, noteUpdatedAt: [DateFilter]? = nil, noteUpdatedBy: [StringFilter]? = nil, processLaunchedAt: [DateFilter]? = nil, processName: [StringFilter]? = nil, processParentPid: [NumberFilter]? = nil, processPath: [StringFilter]? = nil, processPid: [NumberFilter]? = nil, processTerminatedAt: [DateFilter]? = nil, productArn: [StringFilter]? = nil, productFields: [MapFilter]? = nil, productName: [StringFilter]? = nil, recommendationText: [StringFilter]? = nil, recordState: [StringFilter]? = nil, region: [StringFilter]? = nil, relatedFindingsId: [StringFilter]? = nil, relatedFindingsProductArn: [StringFilter]? = nil, resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]? = nil, resourceAwsEc2InstanceImageId: [StringFilter]? = nil, resourceAwsEc2InstanceIpV4Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceIpV6Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceKeyName: [StringFilter]? = nil, resourceAwsEc2InstanceLaunchedAt: [DateFilter]? = nil, resourceAwsEc2InstanceSubnetId: [StringFilter]? = nil, resourceAwsEc2InstanceType: [StringFilter]? = nil, resourceAwsEc2InstanceVpcId: [StringFilter]? = nil, resourceAwsIamAccessKeyCreatedAt: [DateFilter]? = nil, resourceAwsIamAccessKeyPrincipalName: [StringFilter]? = nil, resourceAwsIamAccessKeyStatus: [StringFilter]? = nil, resourceAwsIamAccessKeyUserName: [StringFilter]? = nil, resourceAwsIamUserUserName: [StringFilter]? = nil, resourceAwsS3BucketOwnerId: [StringFilter]? = nil, resourceAwsS3BucketOwnerName: [StringFilter]? = nil, resourceContainerImageId: [StringFilter]? = nil, resourceContainerImageName: [StringFilter]? = nil, resourceContainerLaunchedAt: [DateFilter]? = nil, resourceContainerName: [StringFilter]? = nil, resourceDetailsOther: [MapFilter]? = nil, resourceId: [StringFilter]? = nil, resourcePartition: [StringFilter]? = nil, resourceRegion: [StringFilter]? = nil, resourceTags: [MapFilter]? = nil, resourceType: [StringFilter]? = nil, sample: [BooleanFilter]? = nil, severityLabel: [StringFilter]? = nil, severityNormalized: [NumberFilter]? = nil, severityProduct: [NumberFilter]? = nil, sourceUrl: [StringFilter]? = nil, threatIntelIndicatorCategory: [StringFilter]? = nil, threatIntelIndicatorLastObservedAt: [DateFilter]? = nil, threatIntelIndicatorSource: [StringFilter]? = nil, threatIntelIndicatorSourceUrl: [StringFilter]? = nil, threatIntelIndicatorType: [StringFilter]? = nil, threatIntelIndicatorValue: [StringFilter]? = nil, title: [StringFilter]? = nil, type: [StringFilter]? = nil, updatedAt: [DateFilter]? = nil, userDefinedFields: [MapFilter]? = nil, verificationState: [StringFilter]? = nil, workflowState: [StringFilter]? = nil, workflowStatus: [StringFilter]? = nil) {
            self.awsAccountId = awsAccountId
            self.companyName = companyName
            self.complianceStatus = complianceStatus
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.findingProviderFieldsConfidence = findingProviderFieldsConfidence
            self.findingProviderFieldsCriticality = findingProviderFieldsCriticality
            self.findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsId
            self.findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArn
            self.findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabel
            self.findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginal
            self.findingProviderFieldsTypes = findingProviderFieldsTypes
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.keyword = keyword
            self.lastObservedAt = lastObservedAt
            self.malwareName = malwareName
            self.malwarePath = malwarePath
            self.malwareState = malwareState
            self.malwareType = malwareType
            self.networkDestinationDomain = networkDestinationDomain
            self.networkDestinationIpV4 = networkDestinationIpV4
            self.networkDestinationIpV6 = networkDestinationIpV6
            self.networkDestinationPort = networkDestinationPort
            self.networkDirection = networkDirection
            self.networkProtocol = networkProtocol
            self.networkSourceDomain = networkSourceDomain
            self.networkSourceIpV4 = networkSourceIpV4
            self.networkSourceIpV6 = networkSourceIpV6
            self.networkSourceMac = networkSourceMac
            self.networkSourcePort = networkSourcePort
            self.noteText = noteText
            self.noteUpdatedAt = noteUpdatedAt
            self.noteUpdatedBy = noteUpdatedBy
            self.processLaunchedAt = processLaunchedAt
            self.processName = processName
            self.processParentPid = processParentPid
            self.processPath = processPath
            self.processPid = processPid
            self.processTerminatedAt = processTerminatedAt
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recommendationText = recommendationText
            self.recordState = recordState
            self.region = region
            self.relatedFindingsId = relatedFindingsId
            self.relatedFindingsProductArn = relatedFindingsProductArn
            self.resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn
            self.resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId
            self.resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses
            self.resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses
            self.resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName
            self.resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt
            self.resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId
            self.resourceAwsEc2InstanceType = resourceAwsEc2InstanceType
            self.resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId
            self.resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt
            self.resourceAwsIamAccessKeyPrincipalName = resourceAwsIamAccessKeyPrincipalName
            self.resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus
            self.resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserName
            self.resourceAwsIamUserUserName = resourceAwsIamUserUserName
            self.resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId
            self.resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName
            self.resourceContainerImageId = resourceContainerImageId
            self.resourceContainerImageName = resourceContainerImageName
            self.resourceContainerLaunchedAt = resourceContainerLaunchedAt
            self.resourceContainerName = resourceContainerName
            self.resourceDetailsOther = resourceDetailsOther
            self.resourceId = resourceId
            self.resourcePartition = resourcePartition
            self.resourceRegion = resourceRegion
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.sample = sample
            self.severityLabel = severityLabel
            self.severityNormalized = severityNormalized
            self.severityProduct = severityProduct
            self.sourceUrl = sourceUrl
            self.threatIntelIndicatorCategory = threatIntelIndicatorCategory
            self.threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt
            self.threatIntelIndicatorSource = threatIntelIndicatorSource
            self.threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl
            self.threatIntelIndicatorType = threatIntelIndicatorType
            self.threatIntelIndicatorValue = threatIntelIndicatorValue
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflowState = workflowState
            self.workflowStatus = workflowStatus
        }

        public func validate(name: String) throws {
            try self.awsAccountId?.forEach {
                try $0.validate(name: "\(name).awsAccountId[]")
            }
            try self.companyName?.forEach {
                try $0.validate(name: "\(name).companyName[]")
            }
            try self.complianceStatus?.forEach {
                try $0.validate(name: "\(name).complianceStatus[]")
            }
            try self.createdAt?.forEach {
                try $0.validate(name: "\(name).createdAt[]")
            }
            try self.description?.forEach {
                try $0.validate(name: "\(name).description[]")
            }
            try self.findingProviderFieldsRelatedFindingsId?.forEach {
                try $0.validate(name: "\(name).findingProviderFieldsRelatedFindingsId[]")
            }
            try self.findingProviderFieldsRelatedFindingsProductArn?.forEach {
                try $0.validate(name: "\(name).findingProviderFieldsRelatedFindingsProductArn[]")
            }
            try self.findingProviderFieldsSeverityLabel?.forEach {
                try $0.validate(name: "\(name).findingProviderFieldsSeverityLabel[]")
            }
            try self.findingProviderFieldsSeverityOriginal?.forEach {
                try $0.validate(name: "\(name).findingProviderFieldsSeverityOriginal[]")
            }
            try self.findingProviderFieldsTypes?.forEach {
                try $0.validate(name: "\(name).findingProviderFieldsTypes[]")
            }
            try self.firstObservedAt?.forEach {
                try $0.validate(name: "\(name).firstObservedAt[]")
            }
            try self.generatorId?.forEach {
                try $0.validate(name: "\(name).generatorId[]")
            }
            try self.id?.forEach {
                try $0.validate(name: "\(name).id[]")
            }
            try self.keyword?.forEach {
                try $0.validate(name: "\(name).keyword[]")
            }
            try self.lastObservedAt?.forEach {
                try $0.validate(name: "\(name).lastObservedAt[]")
            }
            try self.malwareName?.forEach {
                try $0.validate(name: "\(name).malwareName[]")
            }
            try self.malwarePath?.forEach {
                try $0.validate(name: "\(name).malwarePath[]")
            }
            try self.malwareState?.forEach {
                try $0.validate(name: "\(name).malwareState[]")
            }
            try self.malwareType?.forEach {
                try $0.validate(name: "\(name).malwareType[]")
            }
            try self.networkDestinationDomain?.forEach {
                try $0.validate(name: "\(name).networkDestinationDomain[]")
            }
            try self.networkDestinationIpV4?.forEach {
                try $0.validate(name: "\(name).networkDestinationIpV4[]")
            }
            try self.networkDestinationIpV6?.forEach {
                try $0.validate(name: "\(name).networkDestinationIpV6[]")
            }
            try self.networkDirection?.forEach {
                try $0.validate(name: "\(name).networkDirection[]")
            }
            try self.networkProtocol?.forEach {
                try $0.validate(name: "\(name).networkProtocol[]")
            }
            try self.networkSourceDomain?.forEach {
                try $0.validate(name: "\(name).networkSourceDomain[]")
            }
            try self.networkSourceIpV4?.forEach {
                try $0.validate(name: "\(name).networkSourceIpV4[]")
            }
            try self.networkSourceIpV6?.forEach {
                try $0.validate(name: "\(name).networkSourceIpV6[]")
            }
            try self.networkSourceMac?.forEach {
                try $0.validate(name: "\(name).networkSourceMac[]")
            }
            try self.noteText?.forEach {
                try $0.validate(name: "\(name).noteText[]")
            }
            try self.noteUpdatedAt?.forEach {
                try $0.validate(name: "\(name).noteUpdatedAt[]")
            }
            try self.noteUpdatedBy?.forEach {
                try $0.validate(name: "\(name).noteUpdatedBy[]")
            }
            try self.processLaunchedAt?.forEach {
                try $0.validate(name: "\(name).processLaunchedAt[]")
            }
            try self.processName?.forEach {
                try $0.validate(name: "\(name).processName[]")
            }
            try self.processPath?.forEach {
                try $0.validate(name: "\(name).processPath[]")
            }
            try self.processTerminatedAt?.forEach {
                try $0.validate(name: "\(name).processTerminatedAt[]")
            }
            try self.productArn?.forEach {
                try $0.validate(name: "\(name).productArn[]")
            }
            try self.productFields?.forEach {
                try $0.validate(name: "\(name).productFields[]")
            }
            try self.productName?.forEach {
                try $0.validate(name: "\(name).productName[]")
            }
            try self.recommendationText?.forEach {
                try $0.validate(name: "\(name).recommendationText[]")
            }
            try self.recordState?.forEach {
                try $0.validate(name: "\(name).recordState[]")
            }
            try self.region?.forEach {
                try $0.validate(name: "\(name).region[]")
            }
            try self.relatedFindingsId?.forEach {
                try $0.validate(name: "\(name).relatedFindingsId[]")
            }
            try self.relatedFindingsProductArn?.forEach {
                try $0.validate(name: "\(name).relatedFindingsProductArn[]")
            }
            try self.resourceAwsEc2InstanceIamInstanceProfileArn?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIamInstanceProfileArn[]")
            }
            try self.resourceAwsEc2InstanceImageId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceImageId[]")
            }
            try self.resourceAwsEc2InstanceIpV4Addresses?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIpV4Addresses[]")
            }
            try self.resourceAwsEc2InstanceIpV6Addresses?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIpV6Addresses[]")
            }
            try self.resourceAwsEc2InstanceKeyName?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceKeyName[]")
            }
            try self.resourceAwsEc2InstanceLaunchedAt?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceLaunchedAt[]")
            }
            try self.resourceAwsEc2InstanceSubnetId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceSubnetId[]")
            }
            try self.resourceAwsEc2InstanceType?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceType[]")
            }
            try self.resourceAwsEc2InstanceVpcId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceVpcId[]")
            }
            try self.resourceAwsIamAccessKeyCreatedAt?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyCreatedAt[]")
            }
            try self.resourceAwsIamAccessKeyPrincipalName?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyPrincipalName[]")
            }
            try self.resourceAwsIamAccessKeyStatus?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyStatus[]")
            }
            try self.resourceAwsIamAccessKeyUserName?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyUserName[]")
            }
            try self.resourceAwsIamUserUserName?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamUserUserName[]")
            }
            try self.resourceAwsS3BucketOwnerId?.forEach {
                try $0.validate(name: "\(name).resourceAwsS3BucketOwnerId[]")
            }
            try self.resourceAwsS3BucketOwnerName?.forEach {
                try $0.validate(name: "\(name).resourceAwsS3BucketOwnerName[]")
            }
            try self.resourceContainerImageId?.forEach {
                try $0.validate(name: "\(name).resourceContainerImageId[]")
            }
            try self.resourceContainerImageName?.forEach {
                try $0.validate(name: "\(name).resourceContainerImageName[]")
            }
            try self.resourceContainerLaunchedAt?.forEach {
                try $0.validate(name: "\(name).resourceContainerLaunchedAt[]")
            }
            try self.resourceContainerName?.forEach {
                try $0.validate(name: "\(name).resourceContainerName[]")
            }
            try self.resourceDetailsOther?.forEach {
                try $0.validate(name: "\(name).resourceDetailsOther[]")
            }
            try self.resourceId?.forEach {
                try $0.validate(name: "\(name).resourceId[]")
            }
            try self.resourcePartition?.forEach {
                try $0.validate(name: "\(name).resourcePartition[]")
            }
            try self.resourceRegion?.forEach {
                try $0.validate(name: "\(name).resourceRegion[]")
            }
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.resourceType?.forEach {
                try $0.validate(name: "\(name).resourceType[]")
            }
            try self.severityLabel?.forEach {
                try $0.validate(name: "\(name).severityLabel[]")
            }
            try self.sourceUrl?.forEach {
                try $0.validate(name: "\(name).sourceUrl[]")
            }
            try self.threatIntelIndicatorCategory?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorCategory[]")
            }
            try self.threatIntelIndicatorLastObservedAt?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorLastObservedAt[]")
            }
            try self.threatIntelIndicatorSource?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorSource[]")
            }
            try self.threatIntelIndicatorSourceUrl?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorSourceUrl[]")
            }
            try self.threatIntelIndicatorType?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorType[]")
            }
            try self.threatIntelIndicatorValue?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorValue[]")
            }
            try self.title?.forEach {
                try $0.validate(name: "\(name).title[]")
            }
            try self.type?.forEach {
                try $0.validate(name: "\(name).type[]")
            }
            try self.updatedAt?.forEach {
                try $0.validate(name: "\(name).updatedAt[]")
            }
            try self.userDefinedFields?.forEach {
                try $0.validate(name: "\(name).userDefinedFields[]")
            }
            try self.verificationState?.forEach {
                try $0.validate(name: "\(name).verificationState[]")
            }
            try self.workflowState?.forEach {
                try $0.validate(name: "\(name).workflowState[]")
            }
            try self.workflowStatus?.forEach {
                try $0.validate(name: "\(name).workflowStatus[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case companyName = "CompanyName"
            case complianceStatus = "ComplianceStatus"
            case confidence = "Confidence"
            case createdAt = "CreatedAt"
            case criticality = "Criticality"
            case description = "Description"
            case findingProviderFieldsConfidence = "FindingProviderFieldsConfidence"
            case findingProviderFieldsCriticality = "FindingProviderFieldsCriticality"
            case findingProviderFieldsRelatedFindingsId = "FindingProviderFieldsRelatedFindingsId"
            case findingProviderFieldsRelatedFindingsProductArn = "FindingProviderFieldsRelatedFindingsProductArn"
            case findingProviderFieldsSeverityLabel = "FindingProviderFieldsSeverityLabel"
            case findingProviderFieldsSeverityOriginal = "FindingProviderFieldsSeverityOriginal"
            case findingProviderFieldsTypes = "FindingProviderFieldsTypes"
            case firstObservedAt = "FirstObservedAt"
            case generatorId = "GeneratorId"
            case id = "Id"
            case keyword = "Keyword"
            case lastObservedAt = "LastObservedAt"
            case malwareName = "MalwareName"
            case malwarePath = "MalwarePath"
            case malwareState = "MalwareState"
            case malwareType = "MalwareType"
            case networkDestinationDomain = "NetworkDestinationDomain"
            case networkDestinationIpV4 = "NetworkDestinationIpV4"
            case networkDestinationIpV6 = "NetworkDestinationIpV6"
            case networkDestinationPort = "NetworkDestinationPort"
            case networkDirection = "NetworkDirection"
            case networkProtocol = "NetworkProtocol"
            case networkSourceDomain = "NetworkSourceDomain"
            case networkSourceIpV4 = "NetworkSourceIpV4"
            case networkSourceIpV6 = "NetworkSourceIpV6"
            case networkSourceMac = "NetworkSourceMac"
            case networkSourcePort = "NetworkSourcePort"
            case noteText = "NoteText"
            case noteUpdatedAt = "NoteUpdatedAt"
            case noteUpdatedBy = "NoteUpdatedBy"
            case processLaunchedAt = "ProcessLaunchedAt"
            case processName = "ProcessName"
            case processParentPid = "ProcessParentPid"
            case processPath = "ProcessPath"
            case processPid = "ProcessPid"
            case processTerminatedAt = "ProcessTerminatedAt"
            case productArn = "ProductArn"
            case productFields = "ProductFields"
            case productName = "ProductName"
            case recommendationText = "RecommendationText"
            case recordState = "RecordState"
            case region = "Region"
            case relatedFindingsId = "RelatedFindingsId"
            case relatedFindingsProductArn = "RelatedFindingsProductArn"
            case resourceAwsEc2InstanceIamInstanceProfileArn = "ResourceAwsEc2InstanceIamInstanceProfileArn"
            case resourceAwsEc2InstanceImageId = "ResourceAwsEc2InstanceImageId"
            case resourceAwsEc2InstanceIpV4Addresses = "ResourceAwsEc2InstanceIpV4Addresses"
            case resourceAwsEc2InstanceIpV6Addresses = "ResourceAwsEc2InstanceIpV6Addresses"
            case resourceAwsEc2InstanceKeyName = "ResourceAwsEc2InstanceKeyName"
            case resourceAwsEc2InstanceLaunchedAt = "ResourceAwsEc2InstanceLaunchedAt"
            case resourceAwsEc2InstanceSubnetId = "ResourceAwsEc2InstanceSubnetId"
            case resourceAwsEc2InstanceType = "ResourceAwsEc2InstanceType"
            case resourceAwsEc2InstanceVpcId = "ResourceAwsEc2InstanceVpcId"
            case resourceAwsIamAccessKeyCreatedAt = "ResourceAwsIamAccessKeyCreatedAt"
            case resourceAwsIamAccessKeyPrincipalName = "ResourceAwsIamAccessKeyPrincipalName"
            case resourceAwsIamAccessKeyStatus = "ResourceAwsIamAccessKeyStatus"
            case resourceAwsIamAccessKeyUserName = "ResourceAwsIamAccessKeyUserName"
            case resourceAwsIamUserUserName = "ResourceAwsIamUserUserName"
            case resourceAwsS3BucketOwnerId = "ResourceAwsS3BucketOwnerId"
            case resourceAwsS3BucketOwnerName = "ResourceAwsS3BucketOwnerName"
            case resourceContainerImageId = "ResourceContainerImageId"
            case resourceContainerImageName = "ResourceContainerImageName"
            case resourceContainerLaunchedAt = "ResourceContainerLaunchedAt"
            case resourceContainerName = "ResourceContainerName"
            case resourceDetailsOther = "ResourceDetailsOther"
            case resourceId = "ResourceId"
            case resourcePartition = "ResourcePartition"
            case resourceRegion = "ResourceRegion"
            case resourceTags = "ResourceTags"
            case resourceType = "ResourceType"
            case sample = "Sample"
            case severityLabel = "SeverityLabel"
            case severityNormalized = "SeverityNormalized"
            case severityProduct = "SeverityProduct"
            case sourceUrl = "SourceUrl"
            case threatIntelIndicatorCategory = "ThreatIntelIndicatorCategory"
            case threatIntelIndicatorLastObservedAt = "ThreatIntelIndicatorLastObservedAt"
            case threatIntelIndicatorSource = "ThreatIntelIndicatorSource"
            case threatIntelIndicatorSourceUrl = "ThreatIntelIndicatorSourceUrl"
            case threatIntelIndicatorType = "ThreatIntelIndicatorType"
            case threatIntelIndicatorValue = "ThreatIntelIndicatorValue"
            case title = "Title"
            case type = "Type"
            case updatedAt = "UpdatedAt"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case workflowState = "WorkflowState"
            case workflowStatus = "WorkflowStatus"
        }
    }

    public struct AwsSecurityFindingIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the finding that was specified by the finding provider.
        public let id: String
        /// The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.
        public let productArn: String

        public init(id: String, productArn: String) {
            self.id = id
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case productArn = "ProductArn"
        }
    }

    public struct AwsSnsTopicDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to a platform application endpoint.
        public let applicationSuccessFeedbackRoleArn: String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
        public let firehoseFailureFeedbackRoleArn: String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
        public let firehoseSuccessFeedbackRoleArn: String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
        public let httpFailureFeedbackRoleArn: String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
        public let httpSuccessFeedbackRoleArn: String?
        /// The ID of an Amazon Web Services managed key for Amazon SNS or a customer managed key.
        public let kmsMasterKeyId: String?
        /// The subscription's owner.
        public let owner: String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
        public let sqsFailureFeedbackRoleArn: String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
        public let sqsSuccessFeedbackRoleArn: String?
        /// Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.
        public let subscription: [AwsSnsTopicSubscription]?
        /// The name of the Amazon SNS topic.
        public let topicName: String?

        public init(applicationSuccessFeedbackRoleArn: String? = nil, firehoseFailureFeedbackRoleArn: String? = nil, firehoseSuccessFeedbackRoleArn: String? = nil, httpFailureFeedbackRoleArn: String? = nil, httpSuccessFeedbackRoleArn: String? = nil, kmsMasterKeyId: String? = nil, owner: String? = nil, sqsFailureFeedbackRoleArn: String? = nil, sqsSuccessFeedbackRoleArn: String? = nil, subscription: [AwsSnsTopicSubscription]? = nil, topicName: String? = nil) {
            self.applicationSuccessFeedbackRoleArn = applicationSuccessFeedbackRoleArn
            self.firehoseFailureFeedbackRoleArn = firehoseFailureFeedbackRoleArn
            self.firehoseSuccessFeedbackRoleArn = firehoseSuccessFeedbackRoleArn
            self.httpFailureFeedbackRoleArn = httpFailureFeedbackRoleArn
            self.httpSuccessFeedbackRoleArn = httpSuccessFeedbackRoleArn
            self.kmsMasterKeyId = kmsMasterKeyId
            self.owner = owner
            self.sqsFailureFeedbackRoleArn = sqsFailureFeedbackRoleArn
            self.sqsSuccessFeedbackRoleArn = sqsSuccessFeedbackRoleArn
            self.subscription = subscription
            self.topicName = topicName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationSuccessFeedbackRoleArn, name: "applicationSuccessFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.firehoseFailureFeedbackRoleArn, name: "firehoseFailureFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.firehoseSuccessFeedbackRoleArn, name: "firehoseSuccessFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.httpFailureFeedbackRoleArn, name: "httpFailureFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.httpSuccessFeedbackRoleArn, name: "httpSuccessFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.kmsMasterKeyId, name: "kmsMasterKeyId", parent: name, pattern: "\\S")
            try self.validate(self.owner, name: "owner", parent: name, pattern: "\\S")
            try self.validate(self.sqsFailureFeedbackRoleArn, name: "sqsFailureFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.sqsSuccessFeedbackRoleArn, name: "sqsSuccessFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.subscription?.forEach {
                try $0.validate(name: "\(name).subscription[]")
            }
            try self.validate(self.topicName, name: "topicName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSuccessFeedbackRoleArn = "ApplicationSuccessFeedbackRoleArn"
            case firehoseFailureFeedbackRoleArn = "FirehoseFailureFeedbackRoleArn"
            case firehoseSuccessFeedbackRoleArn = "FirehoseSuccessFeedbackRoleArn"
            case httpFailureFeedbackRoleArn = "HttpFailureFeedbackRoleArn"
            case httpSuccessFeedbackRoleArn = "HttpSuccessFeedbackRoleArn"
            case kmsMasterKeyId = "KmsMasterKeyId"
            case owner = "Owner"
            case sqsFailureFeedbackRoleArn = "SqsFailureFeedbackRoleArn"
            case sqsSuccessFeedbackRoleArn = "SqsSuccessFeedbackRoleArn"
            case subscription = "Subscription"
            case topicName = "TopicName"
        }
    }

    public struct AwsSnsTopicSubscription: AWSEncodableShape & AWSDecodableShape {
        /// The subscription's endpoint (format depends on the protocol).
        public let endpoint: String?
        /// The subscription's protocol.
        public let `protocol`: String?

        public init(endpoint: String? = nil, protocol: String? = nil) {
            self.endpoint = endpoint
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case `protocol` = "Protocol"
        }
    }

    public struct AwsSqsQueueDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the dead-letter queue to which Amazon SQS moves messages after the value of maxReceiveCount is exceeded.
        public let deadLetterTargetArn: String?
        /// The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling KMS again.
        public let kmsDataKeyReusePeriodSeconds: Int?
        /// The ID of an Amazon Web Services managed key for Amazon SQS or a custom KMS key.
        public let kmsMasterKeyId: String?
        /// The name of the new queue.
        public let queueName: String?

        public init(deadLetterTargetArn: String? = nil, kmsDataKeyReusePeriodSeconds: Int? = nil, kmsMasterKeyId: String? = nil, queueName: String? = nil) {
            self.deadLetterTargetArn = deadLetterTargetArn
            self.kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSeconds
            self.kmsMasterKeyId = kmsMasterKeyId
            self.queueName = queueName
        }

        public func validate(name: String) throws {
            try self.validate(self.deadLetterTargetArn, name: "deadLetterTargetArn", parent: name, pattern: "\\S")
            try self.validate(self.kmsMasterKeyId, name: "kmsMasterKeyId", parent: name, pattern: "\\S")
            try self.validate(self.queueName, name: "queueName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deadLetterTargetArn = "DeadLetterTargetArn"
            case kmsDataKeyReusePeriodSeconds = "KmsDataKeyReusePeriodSeconds"
            case kmsMasterKeyId = "KmsMasterKeyId"
            case queueName = "QueueName"
        }
    }

    public struct AwsSsmComplianceSummary: AWSEncodableShape & AWSDecodableShape {
        /// The type of resource for which the compliance was determined. For AwsSsmPatchCompliance, ComplianceType is Patch.
        public let complianceType: String?
        /// For the patches that are compliant, the number that have a severity of CRITICAL.
        public let compliantCriticalCount: Int?
        /// For the patches that are compliant, the number that have a severity of HIGH.
        public let compliantHighCount: Int?
        /// For the patches that are compliant, the number that have a severity of INFORMATIONAL.
        public let compliantInformationalCount: Int?
        /// For the patches that are compliant, the number that have a severity of LOW.
        public let compliantLowCount: Int?
        /// For the patches that are compliant, the number that have a severity of MEDIUM.
        public let compliantMediumCount: Int?
        /// For the patches that are compliant, the number that have a severity of UNSPECIFIED.
        public let compliantUnspecifiedCount: Int?
        /// The type of execution that was used determine compliance.
        public let executionType: String?
        /// For the patch items that are noncompliant, the number of items that have a severity of CRITICAL.
        public let nonCompliantCriticalCount: Int?
        /// For the patches that are noncompliant, the number that have a severity of HIGH.
        public let nonCompliantHighCount: Int?
        /// For the patches that are noncompliant, the number that have a severity of INFORMATIONAL.
        public let nonCompliantInformationalCount: Int?
        /// For the patches that are noncompliant, the number that have a severity of LOW.
        public let nonCompliantLowCount: Int?
        /// For the patches that are noncompliant, the number that have a severity of MEDIUM.
        public let nonCompliantMediumCount: Int?
        /// For the patches that are noncompliant, the number that have a severity of UNSPECIFIED.
        public let nonCompliantUnspecifiedCount: Int?
        /// The highest severity for the patches. Valid values are as follows:    CRITICAL     HIGH     MEDIUM     LOW     INFORMATIONAL     UNSPECIFIED
        public let overallSeverity: String?
        /// The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.
        public let patchBaselineId: String?
        /// The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.
        public let patchGroup: String?
        /// The current patch compliance status. Valid values are as follows:    COMPLIANT     NON_COMPLIANT     UNSPECIFIED_DATA
        public let status: String?

        public init(complianceType: String? = nil, compliantCriticalCount: Int? = nil, compliantHighCount: Int? = nil, compliantInformationalCount: Int? = nil, compliantLowCount: Int? = nil, compliantMediumCount: Int? = nil, compliantUnspecifiedCount: Int? = nil, executionType: String? = nil, nonCompliantCriticalCount: Int? = nil, nonCompliantHighCount: Int? = nil, nonCompliantInformationalCount: Int? = nil, nonCompliantLowCount: Int? = nil, nonCompliantMediumCount: Int? = nil, nonCompliantUnspecifiedCount: Int? = nil, overallSeverity: String? = nil, patchBaselineId: String? = nil, patchGroup: String? = nil, status: String? = nil) {
            self.complianceType = complianceType
            self.compliantCriticalCount = compliantCriticalCount
            self.compliantHighCount = compliantHighCount
            self.compliantInformationalCount = compliantInformationalCount
            self.compliantLowCount = compliantLowCount
            self.compliantMediumCount = compliantMediumCount
            self.compliantUnspecifiedCount = compliantUnspecifiedCount
            self.executionType = executionType
            self.nonCompliantCriticalCount = nonCompliantCriticalCount
            self.nonCompliantHighCount = nonCompliantHighCount
            self.nonCompliantInformationalCount = nonCompliantInformationalCount
            self.nonCompliantLowCount = nonCompliantLowCount
            self.nonCompliantMediumCount = nonCompliantMediumCount
            self.nonCompliantUnspecifiedCount = nonCompliantUnspecifiedCount
            self.overallSeverity = overallSeverity
            self.patchBaselineId = patchBaselineId
            self.patchGroup = patchGroup
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceType, name: "complianceType", parent: name, pattern: "\\S")
            try self.validate(self.executionType, name: "executionType", parent: name, pattern: "\\S")
            try self.validate(self.overallSeverity, name: "overallSeverity", parent: name, pattern: "\\S")
            try self.validate(self.patchBaselineId, name: "patchBaselineId", parent: name, pattern: "\\S")
            try self.validate(self.patchGroup, name: "patchGroup", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "ComplianceType"
            case compliantCriticalCount = "CompliantCriticalCount"
            case compliantHighCount = "CompliantHighCount"
            case compliantInformationalCount = "CompliantInformationalCount"
            case compliantLowCount = "CompliantLowCount"
            case compliantMediumCount = "CompliantMediumCount"
            case compliantUnspecifiedCount = "CompliantUnspecifiedCount"
            case executionType = "ExecutionType"
            case nonCompliantCriticalCount = "NonCompliantCriticalCount"
            case nonCompliantHighCount = "NonCompliantHighCount"
            case nonCompliantInformationalCount = "NonCompliantInformationalCount"
            case nonCompliantLowCount = "NonCompliantLowCount"
            case nonCompliantMediumCount = "NonCompliantMediumCount"
            case nonCompliantUnspecifiedCount = "NonCompliantUnspecifiedCount"
            case overallSeverity = "OverallSeverity"
            case patchBaselineId = "PatchBaselineId"
            case patchGroup = "PatchGroup"
            case status = "Status"
        }
    }

    public struct AwsSsmPatch: AWSEncodableShape & AWSDecodableShape {
        /// The compliance status details for the patch.
        public let complianceSummary: AwsSsmComplianceSummary?

        public init(complianceSummary: AwsSsmComplianceSummary? = nil) {
            self.complianceSummary = complianceSummary
        }

        public func validate(name: String) throws {
            try self.complianceSummary?.validate(name: "\(name).complianceSummary")
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummary = "ComplianceSummary"
        }
    }

    public struct AwsSsmPatchComplianceDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about the status of a patch.
        public let patch: AwsSsmPatch?

        public init(patch: AwsSsmPatch? = nil) {
            self.patch = patch
        }

        public func validate(name: String) throws {
            try self.patch?.validate(name: "\(name).patch")
        }

        private enum CodingKeys: String, CodingKey {
            case patch = "Patch"
        }
    }

    public struct AwsWafRateBasedRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// The predicates to include in the rate-based rule.
        public let matchPredicates: [AwsWafRateBasedRuleMatchPredicate]?
        /// The name of the metrics for the rate-based rule.
        public let metricName: String?
        /// The name of the rate-based rule.
        public let name: String?
        /// The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.
        public let rateKey: String?
        /// The maximum number of requests that have an identical value for the field specified in RateKey that are allowed within a five-minute period. If the number of requests exceeds RateLimit and the other predicates specified in the rule are met, WAF triggers the action for the rule.
        public let rateLimit: Int64?
        /// The unique identifier for the rate-based rule.
        public let ruleId: String?

        public init(matchPredicates: [AwsWafRateBasedRuleMatchPredicate]? = nil, metricName: String? = nil, name: String? = nil, rateKey: String? = nil, rateLimit: Int64? = nil, ruleId: String? = nil) {
            self.matchPredicates = matchPredicates
            self.metricName = metricName
            self.name = name
            self.rateKey = rateKey
            self.rateLimit = rateLimit
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.matchPredicates?.forEach {
                try $0.validate(name: "\(name).matchPredicates[]")
            }
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.rateKey, name: "rateKey", parent: name, pattern: "\\S")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case matchPredicates = "MatchPredicates"
            case metricName = "MetricName"
            case name = "Name"
            case rateKey = "RateKey"
            case rateLimit = "RateLimit"
            case ruleId = "RuleId"
        }
    }

    public struct AwsWafRateBasedRuleMatchPredicate: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the predicate.
        public let dataId: String?
        /// If set to true, then the rule actions are performed on requests that match the predicate settings. If set to false, then the rule actions are performed on all requests except those that match the predicate settings.
        public let negated: Bool?
        /// The type of predicate. Valid values are as follows:    ByteMatch     GeoMatch     IPMatch     RegexMatch     SizeConstraint     SqlInjectionMatch     XssMatch
        public let type: String?

        public init(dataId: String? = nil, negated: Bool? = nil, type: String? = nil) {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.dataId, name: "dataId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataId = "DataId"
            case negated = "Negated"
            case type = "Type"
        }
    }

    public struct AwsWafRegionalRateBasedRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// The predicates to include in the rate-based rule.
        public let matchPredicates: [AwsWafRegionalRateBasedRuleMatchPredicate]?
        /// The name of the metrics for the rate-based rule.
        public let metricName: String?
        /// The name of the rate-based rule.
        public let name: String?
        /// The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.
        public let rateKey: String?
        /// The maximum number of requests that have an identical value for the field specified in RateKey that are allowed within a five-minute period. If the number of requests exceeds RateLimit and the other predicates specified in the rule are met, WAF triggers the action for the rule.
        public let rateLimit: Int64?
        /// The unique identifier for the rate-based rule.
        public let ruleId: String?

        public init(matchPredicates: [AwsWafRegionalRateBasedRuleMatchPredicate]? = nil, metricName: String? = nil, name: String? = nil, rateKey: String? = nil, rateLimit: Int64? = nil, ruleId: String? = nil) {
            self.matchPredicates = matchPredicates
            self.metricName = metricName
            self.name = name
            self.rateKey = rateKey
            self.rateLimit = rateLimit
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.matchPredicates?.forEach {
                try $0.validate(name: "\(name).matchPredicates[]")
            }
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.rateKey, name: "rateKey", parent: name, pattern: "\\S")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case matchPredicates = "MatchPredicates"
            case metricName = "MetricName"
            case name = "Name"
            case rateKey = "RateKey"
            case rateLimit = "RateLimit"
            case ruleId = "RuleId"
        }
    }

    public struct AwsWafRegionalRateBasedRuleMatchPredicate: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the predicate.
        public let dataId: String?
        /// If set to true, then the rule actions are performed on requests that match the predicate settings. If set to false, then the rule actions are performed on all requests except those that match the predicate settings.
        public let negated: Bool?
        /// The type of predicate. Valid values are as follows:    ByteMatch     GeoMatch     IPMatch     RegexMatch     SizeConstraint     SqlInjectionMatch     XssMatch
        public let type: String?

        public init(dataId: String? = nil, negated: Bool? = nil, type: String? = nil) {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.dataId, name: "dataId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataId = "DataId"
            case negated = "Negated"
            case type = "Type"
        }
    }

    public struct AwsWafRegionalRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// A name for the metrics for the rule.
        public let metricName: String?
        /// A descriptive name for the rule.
        public let name: String?
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
        public let predicateList: [AwsWafRegionalRulePredicateListDetails]?
        /// The ID of the rule.
        public let ruleId: String?

        public init(metricName: String? = nil, name: String? = nil, predicateList: [AwsWafRegionalRulePredicateListDetails]? = nil, ruleId: String? = nil) {
            self.metricName = metricName
            self.name = name
            self.predicateList = predicateList
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.predicateList?.forEach {
                try $0.validate(name: "\(name).predicateList[]")
            }
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case name = "Name"
            case predicateList = "PredicateList"
            case ruleId = "RuleId"
        }
    }

    public struct AwsWafRegionalRuleGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// A name for the metrics for this rule group.
        public let metricName: String?
        /// The descriptive name of the rule group.
        public let name: String?
        /// The ID of the rule group.
        public let ruleGroupId: String?
        /// Provides information about the rule statements used to identify the web requests that you want to allow, block, or
        /// count.
        public let rules: [AwsWafRegionalRuleGroupRulesDetails]?

        public init(metricName: String? = nil, name: String? = nil, ruleGroupId: String? = nil, rules: [AwsWafRegionalRuleGroupRulesDetails]? = nil) {
            self.metricName = metricName
            self.name = name
            self.ruleGroupId = ruleGroupId
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.ruleGroupId, name: "ruleGroupId", parent: name, pattern: "\\S")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case name = "Name"
            case ruleGroupId = "RuleGroupId"
            case rules = "Rules"
        }
    }

    public struct AwsWafRegionalRuleGroupRulesActionDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet,
        /// GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsWafRegionalRuleGroupRulesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The action that WAF should take on a web request when it matches the criteria defined in the rule.
        public let action: AwsWafRegionalRuleGroupRulesActionDetails?
        /// If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of Priority.
        public let priority: Int?
        /// The ID for a rule.
        public let ruleId: String?
        /// The type of rule in the rule group.
        public let type: String?

        public init(action: AwsWafRegionalRuleGroupRulesActionDetails? = nil, priority: Int? = nil, ruleId: String? = nil, type: String? = nil) {
            self.action = action
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case priority = "Priority"
            case ruleId = "RuleId"
            case type = "Type"
        }
    }

    public struct AwsWafRegionalRulePredicateListDetails: AWSEncodableShape & AWSDecodableShape {
        /// A unique identifier for a predicate in a rule, such as ByteMatchSetId or IPSetId.
        public let dataId: String?
        /// Specifies if you want WAF to allow, block, or count requests based on the settings in the  ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet,  RegexMatchSet, GeoMatchSet, or SizeConstraintSet.
        public let negated: Bool?
        /// The type of predicate in a rule, such as ByteMatch or IPSet.
        public let type: String?

        public init(dataId: String? = nil, negated: Bool? = nil, type: String? = nil) {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.dataId, name: "dataId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataId = "DataId"
            case negated = "Negated"
            case type = "Type"
        }
    }

    public struct AwsWafRegionalWebAclDetails: AWSEncodableShape & AWSDecodableShape {
        /// The action to perform if none of the rules contained in the web ACL match.
        public let defaultAction: String?
        /// A name for the metrics for this web ACL.
        public let metricName: String?
        /// A descriptive name for the web ACL.
        public let name: String?
        /// An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of
        /// the rule.
        public let rulesList: [AwsWafRegionalWebAclRulesListDetails]?
        /// The ID of the web ACL.
        public let webAclId: String?

        public init(defaultAction: String? = nil, metricName: String? = nil, name: String? = nil, rulesList: [AwsWafRegionalWebAclRulesListDetails]? = nil, webAclId: String? = nil) {
            self.defaultAction = defaultAction
            self.metricName = metricName
            self.name = name
            self.rulesList = rulesList
            self.webAclId = webAclId
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultAction, name: "defaultAction", parent: name, pattern: "\\S")
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.rulesList?.forEach {
                try $0.validate(name: "\(name).rulesList[]")
            }
            try self.validate(self.webAclId, name: "webAclId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "DefaultAction"
            case metricName = "MetricName"
            case name = "Name"
            case rulesList = "RulesList"
            case webAclId = "WebAclId"
        }
    }

    public struct AwsWafRegionalWebAclRulesListActionDetails: AWSEncodableShape & AWSDecodableShape {
        /// For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsWafRegionalWebAclRulesListDetails: AWSEncodableShape & AWSDecodableShape {
        /// The action that WAF takes when a web request matches all conditions in the rule, such as allow,  block, or count the request.
        public let action: AwsWafRegionalWebAclRulesListActionDetails?
        /// Overrides the rule evaluation result in the rule group.
        public let overrideAction: AwsWafRegionalWebAclRulesListOverrideActionDetails?
        /// The order in which WAF evaluates the rules in a web ACL.
        public let priority: Int?
        /// The ID of an WAF Regional rule to associate with a web ACL.
        public let ruleId: String?
        /// For actions that are associated with a rule, the action that WAF takes when a web
        /// request matches all conditions in a rule.
        public let type: String?

        public init(action: AwsWafRegionalWebAclRulesListActionDetails? = nil, overrideAction: AwsWafRegionalWebAclRulesListOverrideActionDetails? = nil, priority: Int? = nil, ruleId: String? = nil, type: String? = nil) {
            self.action = action
            self.overrideAction = overrideAction
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.overrideAction?.validate(name: "\(name).overrideAction")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case overrideAction = "OverrideAction"
            case priority = "Priority"
            case ruleId = "RuleId"
            case type = "Type"
        }
    }

    public struct AwsWafRegionalWebAclRulesListOverrideActionDetails: AWSEncodableShape & AWSDecodableShape {
        /// Overrides the rule evaluation result in the rule group.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsWafRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metrics for this rule.
        public let metricName: String?
        /// A descriptive name for the rule.
        public let name: String?
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet,  RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and,  for each object, indicates whether you want to negate the settings.
        public let predicateList: [AwsWafRulePredicateListDetails]?
        /// The ID of the WAF rule.
        public let ruleId: String?

        public init(metricName: String? = nil, name: String? = nil, predicateList: [AwsWafRulePredicateListDetails]? = nil, ruleId: String? = nil) {
            self.metricName = metricName
            self.name = name
            self.predicateList = predicateList
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.predicateList?.forEach {
                try $0.validate(name: "\(name).predicateList[]")
            }
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case name = "Name"
            case predicateList = "PredicateList"
            case ruleId = "RuleId"
        }
    }

    public struct AwsWafRuleGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metrics for this rule group.
        public let metricName: String?
        /// The name of the rule group.
        public let name: String?
        /// The ID of the rule group.
        public let ruleGroupId: String?
        /// Provides information about the rules attached to the rule group. These rules identify the web requests that you want to
        /// allow, block, or count.
        public let rules: [AwsWafRuleGroupRulesDetails]?

        public init(metricName: String? = nil, name: String? = nil, ruleGroupId: String? = nil, rules: [AwsWafRuleGroupRulesDetails]? = nil) {
            self.metricName = metricName
            self.name = name
            self.ruleGroupId = ruleGroupId
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.ruleGroupId, name: "ruleGroupId", parent: name, pattern: "\\S")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case name = "Name"
            case ruleGroupId = "RuleGroupId"
            case rules = "Rules"
        }
    }

    public struct AwsWafRuleGroupRulesActionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The action that WAF should take on a web request when it matches the rule's statement.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsWafRuleGroupRulesDetails: AWSEncodableShape & AWSDecodableShape {
        /// Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule.
        public let action: AwsWafRuleGroupRulesActionDetails?
        /// If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of Priority.
        public let priority: Int?
        /// The rule ID for a rule.
        public let ruleId: String?
        /// The type of rule.
        public let type: String?

        public init(action: AwsWafRuleGroupRulesActionDetails? = nil, priority: Int? = nil, ruleId: String? = nil, type: String? = nil) {
            self.action = action
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case priority = "Priority"
            case ruleId = "RuleId"
            case type = "Type"
        }
    }

    public struct AwsWafRulePredicateListDetails: AWSEncodableShape & AWSDecodableShape {
        /// A unique identifier for a predicate in a rule, such as ByteMatchSetId or IPSetId.
        public let dataId: String?
        /// Specifies if you want WAF to allow, block, or count requests based on the settings in the  ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet,  RegexMatchSet, GeoMatchSet, or SizeConstraintSet.
        public let negated: Bool?
        /// The type of predicate in a rule, such as ByteMatch or IPSet.
        public let type: String?

        public init(dataId: String? = nil, negated: Bool? = nil, type: String? = nil) {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.dataId, name: "dataId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataId = "DataId"
            case negated = "Negated"
            case type = "Type"
        }
    }

    public struct AwsWafWebAclDetails: AWSEncodableShape & AWSDecodableShape {
        /// The action to perform if none of the rules contained in the web ACL match.
        public let defaultAction: String?
        /// A friendly name or description of the web ACL. You can't change the name of a web ACL  after you create it.
        public let name: String?
        /// An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule.
        public let rules: [AwsWafWebAclRule]?
        /// A unique identifier for a web ACL.
        public let webAclId: String?

        public init(defaultAction: String? = nil, name: String? = nil, rules: [AwsWafWebAclRule]? = nil, webAclId: String? = nil) {
            self.defaultAction = defaultAction
            self.name = name
            self.rules = rules
            self.webAclId = webAclId
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultAction, name: "defaultAction", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.webAclId, name: "webAclId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "DefaultAction"
            case name = "Name"
            case rules = "Rules"
            case webAclId = "WebAclId"
        }
    }

    public struct AwsWafWebAclRule: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the action that CloudFront or WAF takes when a web request matches the conditions in the rule.
        public let action: WafAction?
        /// Rules to exclude from a rule group.
        public let excludedRules: [WafExcludedRule]?
        /// Use the OverrideAction to test your RuleGroup. Any rule in a RuleGroup can potentially block a request. If you set the OverrideAction to None, the RuleGroup blocks a request if any individual rule in the RuleGroup matches the request and is configured to block that request. However, if you first want to test the RuleGroup, set the OverrideAction to Count. The RuleGroup then overrides any block action specified by individual rules contained within the group. Instead of blocking matching requests, those requests are counted.  ActivatedRule|OverrideAction applies only when updating or adding a RuleGroup to a web ACL. In this case you do not use ActivatedRule Action. For all other update requests, ActivatedRule Action is used instead of ActivatedRule OverrideAction.
        public let overrideAction: WafOverrideAction?
        /// Specifies the order in which the rules in a web ACL are evaluated. Rules with a lower value for Priority are evaluated before rules with a higher value. The value must be a unique integer. If you add multiple rules to a web ACL, the values do not need to be consecutive.
        public let priority: Int?
        /// The identifier for a rule.
        public let ruleId: String?
        /// The rule type. Valid values: REGULAR | RATE_BASED | GROUP  The default is REGULAR.
        public let type: String?

        public init(action: WafAction? = nil, excludedRules: [WafExcludedRule]? = nil, overrideAction: WafOverrideAction? = nil, priority: Int? = nil, ruleId: String? = nil, type: String? = nil) {
            self.action = action
            self.excludedRules = excludedRules
            self.overrideAction = overrideAction
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.excludedRules?.forEach {
                try $0.validate(name: "\(name).excludedRules[]")
            }
            try self.overrideAction?.validate(name: "\(name).overrideAction")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case excludedRules = "ExcludedRules"
            case overrideAction = "OverrideAction"
            case priority = "Priority"
            case ruleId = "RuleId"
            case type = "Type"
        }
    }

    public struct AwsWafv2ActionAllowDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Defines custom handling for the web request. For information about customizing web requests and responses, see  Customizing web requests and responses in WAF in the WAF Developer Guide..
        public let customRequestHandling: AwsWafv2CustomRequestHandlingDetails?

        public init(customRequestHandling: AwsWafv2CustomRequestHandlingDetails? = nil) {
            self.customRequestHandling = customRequestHandling
        }

        public func validate(name: String) throws {
            try self.customRequestHandling?.validate(name: "\(name).customRequestHandling")
        }

        private enum CodingKeys: String, CodingKey {
            case customRequestHandling = "CustomRequestHandling"
        }
    }

    public struct AwsWafv2ActionBlockDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Defines a custom response for the web request. For information, see  Customizing web requests and responses in WAF in the WAF Developer Guide..
        public let customResponse: AwsWafv2CustomResponseDetails?

        public init(customResponse: AwsWafv2CustomResponseDetails? = nil) {
            self.customResponse = customResponse
        }

        public func validate(name: String) throws {
            try self.customResponse?.validate(name: "\(name).customResponse")
        }

        private enum CodingKeys: String, CodingKey {
            case customResponse = "CustomResponse"
        }
    }

    public struct AwsWafv2CustomHttpHeader: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the custom header.
        public let name: String?
        ///  The value of the custom header.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsWafv2CustomRequestHandlingDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The HTTP headers to insert into the request.
        public let insertHeaders: [AwsWafv2CustomHttpHeader]?

        public init(insertHeaders: [AwsWafv2CustomHttpHeader]? = nil) {
            self.insertHeaders = insertHeaders
        }

        public func validate(name: String) throws {
            try self.insertHeaders?.forEach {
                try $0.validate(name: "\(name).insertHeaders[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case insertHeaders = "InsertHeaders"
        }
    }

    public struct AwsWafv2CustomResponseDetails: AWSEncodableShape & AWSDecodableShape {
        ///  References the response body that you want WAF to return to the web request client. You can define a custom response for a rule action or a default web ACL action that is set to block.
        public let customResponseBodyKey: String?
        ///  The HTTP status code to return to the client. For a list of status codes that you can use in your custom responses, see  Supported status codes for custom response in the WAF Developer Guide.
        public let responseCode: Int?
        ///  The HTTP headers to use in the response.
        public let responseHeaders: [AwsWafv2CustomHttpHeader]?

        public init(customResponseBodyKey: String? = nil, responseCode: Int? = nil, responseHeaders: [AwsWafv2CustomHttpHeader]? = nil) {
            self.customResponseBodyKey = customResponseBodyKey
            self.responseCode = responseCode
            self.responseHeaders = responseHeaders
        }

        public func validate(name: String) throws {
            try self.validate(self.customResponseBodyKey, name: "customResponseBodyKey", parent: name, pattern: "\\S")
            try self.responseHeaders?.forEach {
                try $0.validate(name: "\(name).responseHeaders[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customResponseBodyKey = "CustomResponseBodyKey"
            case responseCode = "ResponseCode"
            case responseHeaders = "ResponseHeaders"
        }
    }

    public struct AwsWafv2RuleGroupDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the entity.
        public let arn: String?
        ///  The web ACL capacity units (WCUs) required for this rule group.
        public let capacity: Int64?
        ///  A description of the rule group that helps with identification.
        public let description: String?
        ///  A unique identifier for the rule group.
        public let id: String?
        ///  The name of the rule group. You cannot change the name of a rule group after you create it.
        public let name: String?
        ///  The Rule statements used to identify the web requests that you want to allow, block, or count. Each rule includes one  top-level statement that WAF uses to identify matching web requests, and parameters that govern how  WAF handles them.
        public let rules: [AwsWafv2RulesDetails]?
        ///  Specifies whether the rule group is for an Amazon CloudFront distribution or for a regional application.  A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, an AppSync  GraphQL API, or an Amazon Cognito user pool.
        public let scope: String?
        ///  Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public let visibilityConfig: AwsWafv2VisibilityConfigDetails?

        public init(arn: String? = nil, capacity: Int64? = nil, description: String? = nil, id: String? = nil, name: String? = nil, rules: [AwsWafv2RulesDetails]? = nil, scope: String? = nil, visibilityConfig: AwsWafv2VisibilityConfigDetails? = nil) {
            self.arn = arn
            self.capacity = capacity
            self.description = description
            self.id = id
            self.name = name
            self.rules = rules
            self.scope = scope
            self.visibilityConfig = visibilityConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.scope, name: "scope", parent: name, pattern: "\\S")
            try self.visibilityConfig?.validate(name: "\(name).visibilityConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacity = "Capacity"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case rules = "Rules"
            case scope = "Scope"
            case visibilityConfig = "VisibilityConfig"
        }
    }

    public struct AwsWafv2RulesActionCaptchaDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Defines custom handling for the web request, used when the CAPTCHA inspection determines that the request's token is valid and unexpired. For more information,  see Customizing web requests and responses in WAF in the WAF Developer Guide..
        public let customRequestHandling: AwsWafv2CustomRequestHandlingDetails?

        public init(customRequestHandling: AwsWafv2CustomRequestHandlingDetails? = nil) {
            self.customRequestHandling = customRequestHandling
        }

        public func validate(name: String) throws {
            try self.customRequestHandling?.validate(name: "\(name).customRequestHandling")
        }

        private enum CodingKeys: String, CodingKey {
            case customRequestHandling = "CustomRequestHandling"
        }
    }

    public struct AwsWafv2RulesActionCountDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Defines custom handling for the web request. For more information,  see Customizing web requests and responses in WAF in the WAF Developer Guide..
        public let customRequestHandling: AwsWafv2CustomRequestHandlingDetails?

        public init(customRequestHandling: AwsWafv2CustomRequestHandlingDetails? = nil) {
            self.customRequestHandling = customRequestHandling
        }

        public func validate(name: String) throws {
            try self.customRequestHandling?.validate(name: "\(name).customRequestHandling")
        }

        private enum CodingKeys: String, CodingKey {
            case customRequestHandling = "CustomRequestHandling"
        }
    }

    public struct AwsWafv2RulesActionDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Instructs WAF to allow the web request.
        public let allow: AwsWafv2ActionAllowDetails?
        ///  Instructs WAF to block the web request.
        public let block: AwsWafv2ActionBlockDetails?
        ///  Instructs WAF to run a CAPTCHA check against the web request.
        public let captcha: AwsWafv2RulesActionCaptchaDetails?
        ///  Instructs WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
        public let count: AwsWafv2RulesActionCountDetails?

        public init(allow: AwsWafv2ActionAllowDetails? = nil, block: AwsWafv2ActionBlockDetails? = nil, captcha: AwsWafv2RulesActionCaptchaDetails? = nil, count: AwsWafv2RulesActionCountDetails? = nil) {
            self.allow = allow
            self.block = block
            self.captcha = captcha
            self.count = count
        }

        public func validate(name: String) throws {
            try self.allow?.validate(name: "\(name).allow")
            try self.block?.validate(name: "\(name).block")
            try self.captcha?.validate(name: "\(name).captcha")
            try self.count?.validate(name: "\(name).count")
        }

        private enum CodingKeys: String, CodingKey {
            case allow = "Allow"
            case block = "Block"
            case captcha = "Captcha"
            case count = "Count"
        }
    }

    public struct AwsWafv2RulesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The action that WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting.
        public let action: AwsWafv2RulesActionDetails?
        ///  The name of the rule.
        public let name: String?
        ///  The action to use in the place of the action that results from the rule group evaluation.
        public let overrideAction: String?
        ///  If you define more than one Rule in a WebACL, WAF evaluates each request against the Rules in order based on the value of Priority.  WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.
        public let priority: Int?
        ///  Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public let visibilityConfig: AwsWafv2VisibilityConfigDetails?

        public init(action: AwsWafv2RulesActionDetails? = nil, name: String? = nil, overrideAction: String? = nil, priority: Int? = nil, visibilityConfig: AwsWafv2VisibilityConfigDetails? = nil) {
            self.action = action
            self.name = name
            self.overrideAction = overrideAction
            self.priority = priority
            self.visibilityConfig = visibilityConfig
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.overrideAction, name: "overrideAction", parent: name, pattern: "\\S")
            try self.visibilityConfig?.validate(name: "\(name).visibilityConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case name = "Name"
            case overrideAction = "OverrideAction"
            case priority = "Priority"
            case visibilityConfig = "VisibilityConfig"
        }
    }

    public struct AwsWafv2VisibilityConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  A boolean indicating whether the associated resource sends metrics to Amazon CloudWatch. For the list of available  metrics, see WAF metrics and dimensions in the WAF Developer Guide.
        public let cloudWatchMetricsEnabled: Bool?
        ///  A name of the Amazon CloudWatch metric.
        public let metricName: String?
        ///  A boolean indicating whether WAF should store a sampling of the web requests that match the rules.  You can view the sampled requests through the WAF console.
        public let sampledRequestsEnabled: Bool?

        public init(cloudWatchMetricsEnabled: Bool? = nil, metricName: String? = nil, sampledRequestsEnabled: Bool? = nil) {
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.metricName = metricName
            self.sampledRequestsEnabled = sampledRequestsEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
            case metricName = "MetricName"
            case sampledRequestsEnabled = "SampledRequestsEnabled"
        }
    }

    public struct AwsWafv2WebAclActionDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies that WAF should allow requests by default.
        public let allow: AwsWafv2ActionAllowDetails?
        ///  Specifies that WAF should block requests by default.
        public let block: AwsWafv2ActionBlockDetails?

        public init(allow: AwsWafv2ActionAllowDetails? = nil, block: AwsWafv2ActionBlockDetails? = nil) {
            self.allow = allow
            self.block = block
        }

        public func validate(name: String) throws {
            try self.allow?.validate(name: "\(name).allow")
            try self.block?.validate(name: "\(name).block")
        }

        private enum CodingKeys: String, CodingKey {
            case allow = "Allow"
            case block = "Block"
        }
    }

    public struct AwsWafv2WebAclCaptchaConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Determines how long a CAPTCHA timestamp in the token remains valid after the client successfully solves a CAPTCHA puzzle.
        public let immunityTimeProperty: AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails?

        public init(immunityTimeProperty: AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails? = nil) {
            self.immunityTimeProperty = immunityTimeProperty
        }

        private enum CodingKeys: String, CodingKey {
            case immunityTimeProperty = "ImmunityTimeProperty"
        }
    }

    public struct AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by WAF.
        public let immunityTime: Int64?

        public init(immunityTime: Int64? = nil) {
            self.immunityTime = immunityTime
        }

        private enum CodingKeys: String, CodingKey {
            case immunityTime = "ImmunityTime"
        }
    }

    public struct AwsWafv2WebAclDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.
        public let arn: String?
        ///  The web ACL capacity units (WCUs) currently being used by this web ACL.
        public let capacity: Int64?
        ///  Specifies how WAF should handle CAPTCHA evaluations for rules that don't have their own  CaptchaConfig settings.
        public let captchaConfig: AwsWafv2WebAclCaptchaConfigDetails?
        ///  The action to perform if none of the Rules contained in the web ACL match.
        public let defaultAction: AwsWafv2WebAclActionDetails?
        ///  A description of the web ACL that helps with identification.
        public let description: String?
        ///  A unique identifier for the web ACL.
        public let id: String?
        ///  Indicates whether this web ACL is managed by Firewall Manager.
        public let managedbyFirewallManager: Bool?
        ///  The name of the web ACL.
        public let name: String?
        ///  The Rule statements used to identify the web requests that you want to allow, block, or count. Each rule includes one  top-level statement that WAF uses to identify matching web requests, and parameters that govern how  WAF handles them.
        public let rules: [AwsWafv2RulesDetails]?
        ///  Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public let visibilityConfig: AwsWafv2VisibilityConfigDetails?

        public init(arn: String? = nil, capacity: Int64? = nil, captchaConfig: AwsWafv2WebAclCaptchaConfigDetails? = nil, defaultAction: AwsWafv2WebAclActionDetails? = nil, description: String? = nil, id: String? = nil, managedbyFirewallManager: Bool? = nil, name: String? = nil, rules: [AwsWafv2RulesDetails]? = nil, visibilityConfig: AwsWafv2VisibilityConfigDetails? = nil) {
            self.arn = arn
            self.capacity = capacity
            self.captchaConfig = captchaConfig
            self.defaultAction = defaultAction
            self.description = description
            self.id = id
            self.managedbyFirewallManager = managedbyFirewallManager
            self.name = name
            self.rules = rules
            self.visibilityConfig = visibilityConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.defaultAction?.validate(name: "\(name).defaultAction")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.visibilityConfig?.validate(name: "\(name).visibilityConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacity = "Capacity"
            case captchaConfig = "CaptchaConfig"
            case defaultAction = "DefaultAction"
            case description = "Description"
            case id = "Id"
            case managedbyFirewallManager = "ManagedbyFirewallManager"
            case name = "Name"
            case rules = "Rules"
            case visibilityConfig = "VisibilityConfig"
        }
    }

    public struct AwsXrayEncryptionConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the KMS key that is used for encryption. Provided if Type is KMS.
        public let keyId: String?
        /// The current status of the encryption configuration. Valid values are ACTIVE or UPDATING. When Status is equal to UPDATING, X-Ray might use both the old and new encryption.
        public let status: String?
        /// The type of encryption. KMS indicates that the encryption uses KMS keys. NONE indicates the default encryption.
        public let type: String?

        public init(keyId: String? = nil, status: String? = nil, type: String? = nil) {
            self.keyId = keyId
            self.status = status
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.keyId, name: "keyId", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case keyId = "KeyId"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct BatchDisableStandardsRequest: AWSEncodableShape {
        /// The ARNs of the standards subscriptions to disable.
        public let standardsSubscriptionArns: [String]

        public init(standardsSubscriptionArns: [String]) {
            self.standardsSubscriptionArns = standardsSubscriptionArns
        }

        public func validate(name: String) throws {
            try self.standardsSubscriptionArns.forEach {
                try validate($0, name: "standardsSubscriptionArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, max: 25)
            try self.validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptionArns = "StandardsSubscriptionArns"
        }
    }

    public struct BatchDisableStandardsResponse: AWSDecodableShape {
        /// The details of the standards subscriptions that were disabled.
        public let standardsSubscriptions: [StandardsSubscription]?

        public init(standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct BatchEnableStandardsRequest: AWSEncodableShape {
        /// The list of standards checks to enable.
        public let standardsSubscriptionRequests: [StandardsSubscriptionRequest]

        public init(standardsSubscriptionRequests: [StandardsSubscriptionRequest]) {
            self.standardsSubscriptionRequests = standardsSubscriptionRequests
        }

        public func validate(name: String) throws {
            try self.standardsSubscriptionRequests.forEach {
                try $0.validate(name: "\(name).standardsSubscriptionRequests[]")
            }
            try self.validate(self.standardsSubscriptionRequests, name: "standardsSubscriptionRequests", parent: name, max: 25)
            try self.validate(self.standardsSubscriptionRequests, name: "standardsSubscriptionRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptionRequests = "StandardsSubscriptionRequests"
        }
    }

    public struct BatchEnableStandardsResponse: AWSDecodableShape {
        /// The details of the standards subscriptions that were enabled.
        public let standardsSubscriptions: [StandardsSubscription]?

        public init(standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct BatchImportFindingsRequest: AWSEncodableShape {
        /// A list of findings to import. To successfully import a finding, it must follow the Amazon Web Services Security Finding Format. Maximum of 100 findings per request.
        public let findings: [AwsSecurityFinding]

        public init(findings: [AwsSecurityFinding]) {
            self.findings = findings
        }

        public func validate(name: String) throws {
            try self.findings.forEach {
                try $0.validate(name: "\(name).findings[]")
            }
            try self.validate(self.findings, name: "findings", parent: name, max: 100)
            try self.validate(self.findings, name: "findings", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "Findings"
        }
    }

    public struct BatchImportFindingsResponse: AWSDecodableShape {
        /// The number of findings that failed to import.
        public let failedCount: Int
        /// The list of findings that failed to import.
        public let failedFindings: [ImportFindingsError]?
        /// The number of findings that were successfully imported.
        public let successCount: Int

        public init(failedCount: Int, failedFindings: [ImportFindingsError]? = nil, successCount: Int) {
            self.failedCount = failedCount
            self.failedFindings = failedFindings
            self.successCount = successCount
        }

        private enum CodingKeys: String, CodingKey {
            case failedCount = "FailedCount"
            case failedFindings = "FailedFindings"
            case successCount = "SuccessCount"
        }
    }

    public struct BatchUpdateFindingsRequest: AWSEncodableShape {
        /// The updated value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: Int?
        /// The updated value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: Int?
        /// The list of findings to update. BatchUpdateFindings can be used to update up to 100 findings at a time. For each finding, the list provides the finding identifier and the ARN of the finding provider.
        public let findingIdentifiers: [AwsSecurityFindingIdentifier]
        public let note: NoteUpdate?
        /// A list of findings that are related to the updated findings.
        public let relatedFindings: [RelatedFinding]?
        /// Used to update the finding severity.
        public let severity: SeverityUpdate?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are as follows.   Software and Configuration Checks   TTPs   Effects   Unusual Behaviors   Sensitive Data Identifications
        public let types: [String]?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
        public let userDefinedFields: [String: String]?
        /// Indicates the veracity of a finding. The available values for VerificationState are  as follows.    UNKNOWN  The default disposition of a security finding    TRUE_POSITIVE  The security finding is confirmed    FALSE_POSITIVE  The security finding was determined to be a false alarm    BENIGN_POSITIVE  A special case of TRUE_POSITIVE where the finding doesn't pose any threat, is expected, or both
        public let verificationState: VerificationState?
        /// Used to update the workflow status of a finding. The workflow status indicates the progress of the investigation into the finding.
        public let workflow: WorkflowUpdate?

        public init(confidence: Int? = nil, criticality: Int? = nil, findingIdentifiers: [AwsSecurityFindingIdentifier], note: NoteUpdate? = nil, relatedFindings: [RelatedFinding]? = nil, severity: SeverityUpdate? = nil, types: [String]? = nil, userDefinedFields: [String: String]? = nil, verificationState: VerificationState? = nil, workflow: WorkflowUpdate? = nil) {
            self.confidence = confidence
            self.criticality = criticality
            self.findingIdentifiers = findingIdentifiers
            self.note = note
            self.relatedFindings = relatedFindings
            self.severity = severity
            self.types = types
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflow = workflow
        }

        public func validate(name: String) throws {
            try self.validate(self.confidence, name: "confidence", parent: name, max: 100)
            try self.validate(self.confidence, name: "confidence", parent: name, min: 0)
            try self.validate(self.criticality, name: "criticality", parent: name, max: 100)
            try self.validate(self.criticality, name: "criticality", parent: name, min: 0)
            try self.findingIdentifiers.forEach {
                try $0.validate(name: "\(name).findingIdentifiers[]")
            }
            try self.note?.validate(name: "\(name).note")
            try self.relatedFindings?.forEach {
                try $0.validate(name: "\(name).relatedFindings[]")
            }
            try self.severity?.validate(name: "\(name).severity")
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
            try self.userDefinedFields?.forEach {
                try validate($0.key, name: "userDefinedFields.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "userDefinedFields[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case criticality = "Criticality"
            case findingIdentifiers = "FindingIdentifiers"
            case note = "Note"
            case relatedFindings = "RelatedFindings"
            case severity = "Severity"
            case types = "Types"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case workflow = "Workflow"
        }
    }

    public struct BatchUpdateFindingsResponse: AWSDecodableShape {
        /// The list of findings that were updated successfully.
        public let processedFindings: [AwsSecurityFindingIdentifier]
        /// The list of findings that were not updated.
        public let unprocessedFindings: [BatchUpdateFindingsUnprocessedFinding]

        public init(processedFindings: [AwsSecurityFindingIdentifier], unprocessedFindings: [BatchUpdateFindingsUnprocessedFinding]) {
            self.processedFindings = processedFindings
            self.unprocessedFindings = unprocessedFindings
        }

        private enum CodingKeys: String, CodingKey {
            case processedFindings = "ProcessedFindings"
            case unprocessedFindings = "UnprocessedFindings"
        }
    }

    public struct BatchUpdateFindingsUnprocessedFinding: AWSDecodableShape {
        /// The code associated with the error. Possible values are:    ConcurrentUpdateError - Another request attempted to update the finding while this request was being processed.
        /// This error may also occur if you call  BatchUpdateFindings
        /// and  BatchImportFindings at the same time.    DuplicatedFindingIdentifier - The request included two or more findings with the same FindingIdentifier.    FindingNotFound - The FindingIdentifier included in the request did not match an existing finding.    FindingSizeExceeded - The finding size was greater than the permissible value of 240 KB.    InternalFailure - An internal service failure occurred when updating the finding.    InvalidInput - The finding update contained an invalid value that did not satisfy the Amazon Web Services Security Finding Format syntax.
        public let errorCode: String
        /// The message associated with the error. Possible values are:    Concurrent finding updates detected     Finding Identifier is duplicated     Finding Not Found     Finding size exceeded 240 KB     Internal service failure     Invalid Input
        public let errorMessage: String
        /// The identifier of the finding that was not updated.
        public let findingIdentifier: AwsSecurityFindingIdentifier

        public init(errorCode: String, errorMessage: String, findingIdentifier: AwsSecurityFindingIdentifier) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingIdentifier = findingIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case findingIdentifier = "FindingIdentifier"
        }
    }

    public struct BooleanFilter: AWSEncodableShape & AWSDecodableShape {
        /// The value of the boolean.
        public let value: Bool?

        public init(value: Bool? = nil) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct Cell: AWSEncodableShape & AWSDecodableShape {
        /// For a Microsoft Excel workbook, provides the location of the cell, as an absolute cell reference, that contains the data. For example, Sheet2!C5 for cell C5 on Sheet2.
        public let cellReference: String?
        /// The column number of the column that contains the data. For a Microsoft Excel workbook, the column number corresponds to the alphabetical column identifiers. For example, a value of 1 for Column corresponds to the A column in the workbook.
        public let column: Int64?
        /// The name of the column that contains the data.
        public let columnName: String?
        /// The row number of the row that contains the data.
        public let row: Int64?

        public init(cellReference: String? = nil, column: Int64? = nil, columnName: String? = nil, row: Int64? = nil) {
            self.cellReference = cellReference
            self.column = column
            self.columnName = columnName
            self.row = row
        }

        public func validate(name: String) throws {
            try self.validate(self.cellReference, name: "cellReference", parent: name, pattern: "\\S")
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cellReference = "CellReference"
            case column = "Column"
            case columnName = "ColumnName"
            case row = "Row"
        }
    }

    public struct CidrBlockAssociation: AWSEncodableShape & AWSDecodableShape {
        /// The association ID for the IPv4 CIDR block.
        public let associationId: String?
        /// The IPv4 CIDR block.
        public let cidrBlock: String?
        /// Information about the state of the IPv4 CIDR block.
        public let cidrBlockState: String?

        public init(associationId: String? = nil, cidrBlock: String? = nil, cidrBlockState: String? = nil) {
            self.associationId = associationId
            self.cidrBlock = cidrBlock
            self.cidrBlockState = cidrBlockState
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, pattern: "\\S")
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "\\S")
            try self.validate(self.cidrBlockState, name: "cidrBlockState", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
            case cidrBlock = "CidrBlock"
            case cidrBlockState = "CidrBlockState"
        }
    }

    public struct City: AWSEncodableShape & AWSDecodableShape {
        /// The name of the city.
        public let cityName: String?

        public init(cityName: String? = nil) {
            self.cityName = cityName
        }

        public func validate(name: String) throws {
            try self.validate(self.cityName, name: "cityName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cityName = "CityName"
        }
    }

    public struct ClassificationResult: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether there are additional occurrences of sensitive data that are not included in the finding. This occurs when the number of occurrences exceeds the maximum that can be included.
        public let additionalOccurrences: Bool?
        /// Provides details about sensitive data that was identified based on customer-defined configuration.
        public let customDataIdentifiers: CustomDataIdentifiersResult?
        /// The type of content that the finding applies to.
        public let mimeType: String?
        /// Provides details about sensitive data that was identified based on built-in configuration.
        public let sensitiveData: [SensitiveDataResult]?
        /// The total size in bytes of the affected data.
        public let sizeClassified: Int64?
        /// The current status of the sensitive data detection.
        public let status: ClassificationStatus?

        public init(additionalOccurrences: Bool? = nil, customDataIdentifiers: CustomDataIdentifiersResult? = nil, mimeType: String? = nil, sensitiveData: [SensitiveDataResult]? = nil, sizeClassified: Int64? = nil, status: ClassificationStatus? = nil) {
            self.additionalOccurrences = additionalOccurrences
            self.customDataIdentifiers = customDataIdentifiers
            self.mimeType = mimeType
            self.sensitiveData = sensitiveData
            self.sizeClassified = sizeClassified
            self.status = status
        }

        public func validate(name: String) throws {
            try self.customDataIdentifiers?.validate(name: "\(name).customDataIdentifiers")
            try self.validate(self.mimeType, name: "mimeType", parent: name, pattern: "\\S")
            try self.sensitiveData?.forEach {
                try $0.validate(name: "\(name).sensitiveData[]")
            }
            try self.status?.validate(name: "\(name).status")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOccurrences = "AdditionalOccurrences"
            case customDataIdentifiers = "CustomDataIdentifiers"
            case mimeType = "MimeType"
            case sensitiveData = "SensitiveData"
            case sizeClassified = "SizeClassified"
            case status = "Status"
        }
    }

    public struct ClassificationStatus: AWSEncodableShape & AWSDecodableShape {
        /// The code that represents the status of the sensitive data detection.
        public let code: String?
        /// A longer description of the current status of the sensitive data detection.
        public let reason: String?

        public init(code: String? = nil, reason: String? = nil) {
            self.code = code
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, pattern: "\\S")
            try self.validate(self.reason, name: "reason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case reason = "Reason"
        }
    }

    public struct Compliance: AWSEncodableShape & AWSDecodableShape {
        /// For a control, the industry or regulatory framework requirements that are related to the control. The check for that control is aligned with these requirements.
        public let relatedRequirements: [String]?
        /// The result of a standards check. The valid values for Status are as follows.      PASSED - Standards check passed for all evaluated resources.    WARNING - Some information is missing or this check is not supported for your configuration.    FAILED - Standards check failed for at least one evaluated resource.    NOT_AVAILABLE - Check could not be performed due to a service outage, API error, or because the result of the Config evaluation was NOT_APPLICABLE. If the Config evaluation result was NOT_APPLICABLE, then after 3 days, Security Hub automatically archives the finding.
        public let status: ComplianceStatus?
        /// For findings generated from controls, a list of reasons behind the value of Status. For the list of status reason codes and their meanings, see Standards-related information in the ASFF in the Security Hub User Guide.
        public let statusReasons: [StatusReason]?

        public init(relatedRequirements: [String]? = nil, status: ComplianceStatus? = nil, statusReasons: [StatusReason]? = nil) {
            self.relatedRequirements = relatedRequirements
            self.status = status
            self.statusReasons = statusReasons
        }

        public func validate(name: String) throws {
            try self.relatedRequirements?.forEach {
                try validate($0, name: "relatedRequirements[]", parent: name, pattern: "\\S")
            }
            try self.statusReasons?.forEach {
                try $0.validate(name: "\(name).statusReasons[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case relatedRequirements = "RelatedRequirements"
            case status = "Status"
            case statusReasons = "StatusReasons"
        }
    }

    public struct ContainerDetails: AWSEncodableShape & AWSDecodableShape {
        /// The runtime of the container.
        public let containerRuntime: String?
        /// The identifier of the container image related to a finding.
        public let imageId: String?
        /// The name of the container image related to a finding.
        public let imageName: String?
        /// Indicates when the container started. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let launchedAt: String?
        /// The name of the container related to a finding.
        public let name: String?
        /// When this parameter is true, the container is given elevated privileges on the host
        /// container instance (similar to the root user).
        public let privileged: Bool?
        /// Provides information about the mounting of a volume in a container.
        public let volumeMounts: [VolumeMount]?

        public init(containerRuntime: String? = nil, imageId: String? = nil, imageName: String? = nil, launchedAt: String? = nil, name: String? = nil, privileged: Bool? = nil, volumeMounts: [VolumeMount]? = nil) {
            self.containerRuntime = containerRuntime
            self.imageId = imageId
            self.imageName = imageName
            self.launchedAt = launchedAt
            self.name = name
            self.privileged = privileged
            self.volumeMounts = volumeMounts
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRuntime, name: "containerRuntime", parent: name, pattern: "\\S")
            try self.validate(self.imageId, name: "imageId", parent: name, pattern: "\\S")
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "\\S")
            try self.validate(self.launchedAt, name: "launchedAt", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.volumeMounts?.forEach {
                try $0.validate(name: "\(name).volumeMounts[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case containerRuntime = "ContainerRuntime"
            case imageId = "ImageId"
            case imageName = "ImageName"
            case launchedAt = "LaunchedAt"
            case name = "Name"
            case privileged = "Privileged"
            case volumeMounts = "VolumeMounts"
        }
    }

    public struct Country: AWSEncodableShape & AWSDecodableShape {
        /// The 2-letter ISO 3166 country code for the country.
        public let countryCode: String?
        /// The name of the country.
        public let countryName: String?

        public init(countryCode: String? = nil, countryName: String? = nil) {
            self.countryCode = countryCode
            self.countryName = countryName
        }

        public func validate(name: String) throws {
            try self.validate(self.countryCode, name: "countryCode", parent: name, pattern: "\\S")
            try self.validate(self.countryName, name: "countryName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case countryCode = "CountryCode"
            case countryName = "CountryName"
        }
    }

    public struct CreateActionTargetRequest: AWSEncodableShape {
        /// The description for the custom action target.
        public let description: String
        /// The ID for the custom action target. Can contain up to 20 alphanumeric characters.
        public let id: String
        /// The name of the custom action target. Can contain up to 20 characters.
        public let name: String

        public init(description: String, id: String, name: String) {
            self.description = description
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct CreateActionTargetResponse: AWSDecodableShape {
        /// The ARN for the custom action target.
        public let actionTargetArn: String

        public init(actionTargetArn: String) {
            self.actionTargetArn = actionTargetArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
        }
    }

    public struct CreateFindingAggregatorRequest: AWSEncodableShape {
        /// Indicates whether to aggregate findings from all of the available Regions in the current partition. Also determines whether to automatically aggregate findings from new Regions as Security Hub supports them and you opt into them. The selected option also determines how to use the Regions provided in the Regions list. The options are as follows:    ALL_REGIONS - Indicates to aggregate findings from all of the Regions where Security Hub is enabled. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.     ALL_REGIONS_EXCEPT_SPECIFIED - Indicates to aggregate findings from all of the Regions where Security Hub is enabled, except for the Regions listed in the Regions parameter. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.     SPECIFIED_REGIONS - Indicates to aggregate findings only from the Regions listed in the Regions parameter. Security Hub does not automatically aggregate findings from new Regions.
        public let regionLinkingMode: String
        /// If RegionLinkingMode is ALL_REGIONS_EXCEPT_SPECIFIED, then this is a space-separated list of Regions that do not aggregate findings to the aggregation Region. If RegionLinkingMode is SPECIFIED_REGIONS, then this is a space-separated list of Regions that do aggregate findings to the aggregation Region.
        public let regions: [String]?

        public init(regionLinkingMode: String, regions: [String]? = nil) {
            self.regionLinkingMode = regionLinkingMode
            self.regions = regions
        }

        public func validate(name: String) throws {
            try self.validate(self.regionLinkingMode, name: "regionLinkingMode", parent: name, pattern: "\\S")
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case regionLinkingMode = "RegionLinkingMode"
            case regions = "Regions"
        }
    }

    public struct CreateFindingAggregatorResponse: AWSDecodableShape {
        /// The aggregation Region.
        public let findingAggregationRegion: String?
        /// The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and stop finding aggregation.
        public let findingAggregatorArn: String?
        /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
        public let regionLinkingMode: String?
        /// The list of excluded Regions or included Regions.
        public let regions: [String]?

        public init(findingAggregationRegion: String? = nil, findingAggregatorArn: String? = nil, regionLinkingMode: String? = nil, regions: [String]? = nil) {
            self.findingAggregationRegion = findingAggregationRegion
            self.findingAggregatorArn = findingAggregatorArn
            self.regionLinkingMode = regionLinkingMode
            self.regions = regions
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregationRegion = "FindingAggregationRegion"
            case findingAggregatorArn = "FindingAggregatorArn"
            case regionLinkingMode = "RegionLinkingMode"
            case regions = "Regions"
        }
    }

    public struct CreateInsightRequest: AWSEncodableShape {
        /// One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.
        public let filters: AwsSecurityFindingFilters
        /// The attribute used to group the findings for the insight. The grouping attribute identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.
        public let groupByAttribute: String
        /// The name of the custom insight to create.
        public let name: String

        public init(filters: AwsSecurityFindingFilters, groupByAttribute: String, name: String) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.name = name
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.groupByAttribute, name: "groupByAttribute", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case name = "Name"
        }
    }

    public struct CreateInsightResponse: AWSDecodableShape {
        /// The ARN of the insight created.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        private enum CodingKeys: String, CodingKey {
            case insightArn = "InsightArn"
        }
    }

    public struct CreateMembersRequest: AWSEncodableShape {
        /// The list of accounts to associate with the Security Hub administrator account. For each account, the list includes the account ID and optionally the email address.
        public let accountDetails: [AccountDetails]

        public init(accountDetails: [AccountDetails]) {
            self.accountDetails = accountDetails
        }

        public func validate(name: String) throws {
            try self.accountDetails.forEach {
                try $0.validate(name: "\(name).accountDetails[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountDetails = "AccountDetails"
        }
    }

    public struct CreateMembersResponse: AWSDecodableShape {
        /// The list of Amazon Web Services accounts that were not processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct CustomDataIdentifiersDetections: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the custom identifier that was used to detect the sensitive data.
        public let arn: String?
        /// The total number of occurrences of sensitive data that were detected.
        public let count: Int64?
        /// he name of the custom identifier that detected the sensitive data.
        public let name: String?
        /// Details about the sensitive data that was detected.
        public let occurrences: Occurrences?

        public init(arn: String? = nil, count: Int64? = nil, name: String? = nil, occurrences: Occurrences? = nil) {
            self.arn = arn
            self.count = count
            self.name = name
            self.occurrences = occurrences
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.occurrences?.validate(name: "\(name).occurrences")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case count = "Count"
            case name = "Name"
            case occurrences = "Occurrences"
        }
    }

    public struct CustomDataIdentifiersResult: AWSEncodableShape & AWSDecodableShape {
        /// The list of detected instances of sensitive data.
        public let detections: [CustomDataIdentifiersDetections]?
        /// The total number of occurrences of sensitive data.
        public let totalCount: Int64?

        public init(detections: [CustomDataIdentifiersDetections]? = nil, totalCount: Int64? = nil) {
            self.detections = detections
            self.totalCount = totalCount
        }

        public func validate(name: String) throws {
            try self.detections?.forEach {
                try $0.validate(name: "\(name).detections[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case detections = "Detections"
            case totalCount = "TotalCount"
        }
    }

    public struct Cvss: AWSEncodableShape & AWSDecodableShape {
        /// Adjustments to the CVSS metrics.
        public let adjustments: [Adjustment]?
        /// The base CVSS score.
        public let baseScore: Double?
        /// The base scoring vector for the CVSS score.
        public let baseVector: String?
        /// The origin of the original CVSS score and vector.
        public let source: String?
        /// The version of CVSS for the CVSS score.
        public let version: String?

        public init(adjustments: [Adjustment]? = nil, baseScore: Double? = nil, baseVector: String? = nil, source: String? = nil, version: String? = nil) {
            self.adjustments = adjustments
            self.baseScore = baseScore
            self.baseVector = baseVector
            self.source = source
            self.version = version
        }

        public func validate(name: String) throws {
            try self.adjustments?.forEach {
                try $0.validate(name: "\(name).adjustments[]")
            }
            try self.validate(self.baseVector, name: "baseVector", parent: name, pattern: "\\S")
            try self.validate(self.source, name: "source", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case adjustments = "Adjustments"
            case baseScore = "BaseScore"
            case baseVector = "BaseVector"
            case source = "Source"
            case version = "Version"
        }
    }

    public struct DataClassificationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The path to the folder or file that contains the sensitive data.
        public let detailedResultsLocation: String?
        /// The details about the sensitive data that was detected on the resource.
        public let result: ClassificationResult?

        public init(detailedResultsLocation: String? = nil, result: ClassificationResult? = nil) {
            self.detailedResultsLocation = detailedResultsLocation
            self.result = result
        }

        public func validate(name: String) throws {
            try self.validate(self.detailedResultsLocation, name: "detailedResultsLocation", parent: name, pattern: "\\S")
            try self.result?.validate(name: "\(name).result")
        }

        private enum CodingKeys: String, CodingKey {
            case detailedResultsLocation = "DetailedResultsLocation"
            case result = "Result"
        }
    }

    public struct DateFilter: AWSEncodableShape & AWSDecodableShape {
        /// A date range for the date filter.
        public let dateRange: DateRange?
        /// An end date for the date filter.
        public let end: String?
        /// A start date for the date filter.
        public let start: String?

        public init(dateRange: DateRange? = nil, end: String? = nil, start: String? = nil) {
            self.dateRange = dateRange
            self.end = end
            self.start = start
        }

        public func validate(name: String) throws {
            try self.validate(self.end, name: "end", parent: name, pattern: "\\S")
            try self.validate(self.start, name: "start", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dateRange = "DateRange"
            case end = "End"
            case start = "Start"
        }
    }

    public struct DateRange: AWSEncodableShape & AWSDecodableShape {
        /// A date range unit for the date filter.
        public let unit: DateRangeUnit?
        /// A date range value for the date filter.
        public let value: Int?

        public init(unit: DateRangeUnit? = nil, value: Int? = nil) {
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "Unit"
            case value = "Value"
        }
    }

    public struct DeclineInvitationsRequest: AWSEncodableShape {
        /// The list of account IDs for the accounts from which to decline the invitations to Security Hub.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeclineInvitationsResponse: AWSDecodableShape {
        /// The list of Amazon Web Services accounts that were not processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DeleteActionTargetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "actionTargetArn", location: .uri("ActionTargetArn"))
        ]

        /// The ARN of the custom action target to delete.
        public let actionTargetArn: String

        public init(actionTargetArn: String) {
            self.actionTargetArn = actionTargetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.actionTargetArn, name: "actionTargetArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteActionTargetResponse: AWSDecodableShape {
        /// The ARN of the custom action target that was deleted.
        public let actionTargetArn: String

        public init(actionTargetArn: String) {
            self.actionTargetArn = actionTargetArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
        }
    }

    public struct DeleteFindingAggregatorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "findingAggregatorArn", location: .uri("FindingAggregatorArn"))
        ]

        /// The ARN of the finding aggregator to delete. To obtain the ARN, use ListFindingAggregators.
        public let findingAggregatorArn: String

        public init(findingAggregatorArn: String) {
            self.findingAggregatorArn = findingAggregatorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.findingAggregatorArn, name: "findingAggregatorArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFindingAggregatorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteInsightRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "insightArn", location: .uri("InsightArn"))
        ]

        /// The ARN of the insight to delete.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        public func validate(name: String) throws {
            try self.validate(self.insightArn, name: "insightArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInsightResponse: AWSDecodableShape {
        /// The ARN of the insight that was deleted.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        private enum CodingKeys: String, CodingKey {
            case insightArn = "InsightArn"
        }
    }

    public struct DeleteInvitationsRequest: AWSEncodableShape {
        /// The list of the account IDs that sent the invitations to delete.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeleteInvitationsResponse: AWSDecodableShape {
        /// The list of Amazon Web Services accounts for which the invitations were not deleted. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DeleteMembersRequest: AWSEncodableShape {
        /// The list of account IDs for the member accounts to delete.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeleteMembersResponse: AWSDecodableShape {
        /// The list of Amazon Web Services accounts that were not deleted. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DescribeActionTargetsRequest: AWSEncodableShape {
        /// A list of custom action target ARNs for the custom action targets to retrieve.
        public let actionTargetArns: [String]?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeActionTargets operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(actionTargetArns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.actionTargetArns = actionTargetArns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.actionTargetArns?.forEach {
                try validate($0, name: "actionTargetArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArns = "ActionTargetArns"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeActionTargetsResponse: AWSDecodableShape {
        /// A list of ActionTarget objects. Each object includes the ActionTargetArn, Description, and Name of a custom action target available in Security Hub.
        public let actionTargets: [ActionTarget]
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(actionTargets: [ActionTarget], nextToken: String? = nil) {
            self.actionTargets = actionTargets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargets = "ActionTargets"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeHubRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "hubArn", location: .querystring("HubArn"))
        ]

        /// The ARN of the Hub resource to retrieve.
        public let hubArn: String?

        public init(hubArn: String? = nil) {
            self.hubArn = hubArn
        }

        public func validate(name: String) throws {
            try self.validate(self.hubArn, name: "hubArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeHubResponse: AWSDecodableShape {
        /// Whether to automatically enable new controls when they are added to standards that are enabled. If set to true, then new controls for enabled standards are enabled automatically. If set to false, then new controls are not enabled.
        public let autoEnableControls: Bool?
        /// The ARN of the Hub resource that was retrieved.
        public let hubArn: String?
        /// The date and time when Security Hub was enabled in the account.
        public let subscribedAt: String?

        public init(autoEnableControls: Bool? = nil, hubArn: String? = nil, subscribedAt: String? = nil) {
            self.autoEnableControls = autoEnableControls
            self.hubArn = hubArn
            self.subscribedAt = subscribedAt
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnableControls = "AutoEnableControls"
            case hubArn = "HubArn"
            case subscribedAt = "SubscribedAt"
        }
    }

    public struct DescribeOrganizationConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeOrganizationConfigurationResponse: AWSDecodableShape {
        /// Whether to automatically enable Security Hub for new accounts in the organization. If set to true, then Security Hub is enabled for new accounts. If set to false, then new accounts are not added automatically.
        public let autoEnable: Bool?
        /// Whether to automatically enable Security Hub default standards  for new member accounts in the organization. The default value of this parameter is equal to DEFAULT. If equal to DEFAULT, then Security Hub default standards are automatically enabled for new member  accounts. If equal to NONE, then default standards are not automatically enabled for new member  accounts.
        public let autoEnableStandards: AutoEnableStandards?
        /// Whether the maximum number of allowed member accounts are already associated with the Security Hub administrator account.
        public let memberAccountLimitReached: Bool?

        public init(autoEnable: Bool? = nil, autoEnableStandards: AutoEnableStandards? = nil, memberAccountLimitReached: Bool? = nil) {
            self.autoEnable = autoEnable
            self.autoEnableStandards = autoEnableStandards
            self.memberAccountLimitReached = memberAccountLimitReached
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "AutoEnable"
            case autoEnableStandards = "AutoEnableStandards"
            case memberAccountLimitReached = "MemberAccountLimitReached"
        }
    }

    public struct DescribeProductsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "productArn", location: .querystring("ProductArn"))
        ]

        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeProducts operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The ARN of the integration to return.
        public let productArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, productArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProductsResponse: AWSDecodableShape {
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// A list of products, including details for each product.
        public let products: [Product]

        public init(nextToken: String? = nil, products: [Product]) {
            self.nextToken = nextToken
            self.products = products
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case products = "Products"
        }
    }

    public struct DescribeStandardsControlsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "standardsSubscriptionArn", location: .uri("StandardsSubscriptionArn"))
        ]

        /// The maximum number of security standard controls to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeStandardsControls operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The ARN of a resource that represents your subscription to a supported standard. To get the subscription ARNs of the standards you have enabled, use the GetEnabledStandards operation.
        public let standardsSubscriptionArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, standardsSubscriptionArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.standardsSubscriptionArn = standardsSubscriptionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.standardsSubscriptionArn, name: "standardsSubscriptionArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeStandardsControlsResponse: AWSDecodableShape {
        /// A list of security standards controls.
        public let controls: [StandardsControl]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(controls: [StandardsControl]? = nil, nextToken: String? = nil) {
            self.controls = controls
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controls = "Controls"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeStandardsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The maximum number of standards to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeStandardsResponse: AWSDecodableShape {
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// A list of available standards.
        public let standards: [Standard]?

        public init(nextToken: String? = nil, standards: [Standard]? = nil) {
            self.nextToken = nextToken
            self.standards = standards
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case standards = "Standards"
        }
    }

    public struct DisableImportFindingsForProductRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "productSubscriptionArn", location: .uri("ProductSubscriptionArn"))
        ]

        /// The ARN of the integrated product to disable the integration for.
        public let productSubscriptionArn: String

        public init(productSubscriptionArn: String) {
            self.productSubscriptionArn = productSubscriptionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.productSubscriptionArn, name: "productSubscriptionArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisableImportFindingsForProductResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisableOrganizationAdminAccountRequest: AWSEncodableShape {
        /// The Amazon Web Services account identifier of the Security Hub administrator account.
        public let adminAccountId: String

        public init(adminAccountId: String) {
            self.adminAccountId = adminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "AdminAccountId"
        }
    }

    public struct DisableOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisableSecurityHubRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisableSecurityHubResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateFromAdministratorAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisassociateFromAdministratorAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateFromMasterAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisassociateFromMasterAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMembersRequest: AWSEncodableShape {
        /// The account IDs of the member accounts to disassociate from the administrator account.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DisassociateMembersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DnsRequestAction: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the DNS request was blocked.
        public let blocked: Bool?
        /// The DNS domain that is associated with the DNS request.
        public let domain: String?
        /// The protocol that was used for the DNS request.
        public let `protocol`: String?

        public init(blocked: Bool? = nil, domain: String? = nil, protocol: String? = nil) {
            self.blocked = blocked
            self.domain = domain
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "Blocked"
            case domain = "Domain"
            case `protocol` = "Protocol"
        }
    }

    public struct EnableImportFindingsForProductRequest: AWSEncodableShape {
        /// The ARN of the product to enable the integration for.
        public let productArn: String

        public init(productArn: String) {
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case productArn = "ProductArn"
        }
    }

    public struct EnableImportFindingsForProductResponse: AWSDecodableShape {
        /// The ARN of your subscription to the product to enable integrations for.
        public let productSubscriptionArn: String?

        public init(productSubscriptionArn: String? = nil) {
            self.productSubscriptionArn = productSubscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case productSubscriptionArn = "ProductSubscriptionArn"
        }
    }

    public struct EnableOrganizationAdminAccountRequest: AWSEncodableShape {
        /// The Amazon Web Services account identifier of the account to designate as the Security Hub administrator account.
        public let adminAccountId: String

        public init(adminAccountId: String) {
            self.adminAccountId = adminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "AdminAccountId"
        }
    }

    public struct EnableOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EnableSecurityHubRequest: AWSEncodableShape {
        /// Whether to enable the security standards that Security Hub has designated as automatically enabled. If you do not provide a value for EnableDefaultStandards, it is set to true. To not enable the automatically enabled standards, set EnableDefaultStandards to false.
        public let enableDefaultStandards: Bool?
        /// The tags to add to the hub resource when you enable Security Hub.
        public let tags: [String: String]?

        public init(enableDefaultStandards: Bool? = nil, tags: [String: String]? = nil) {
            self.enableDefaultStandards = enableDefaultStandards
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case enableDefaultStandards = "EnableDefaultStandards"
            case tags = "Tags"
        }
    }

    public struct EnableSecurityHubResponse: AWSDecodableShape {
        public init() {}
    }

    public struct FilePaths: AWSEncodableShape & AWSDecodableShape {
        /// The name of the infected or suspicious file corresponding to the hash.
        ///
        public let fileName: String?
        /// Path to the infected or suspicious file on the resource it was detected on.
        ///
        public let filePath: String?
        /// The hash value for the infected or suspicious file.
        ///
        public let hash: String?
        /// The Amazon Resource Name (ARN) of the resource on which the threat was detected.
        ///
        public let resourceId: String?

        public init(fileName: String? = nil, filePath: String? = nil, hash: String? = nil, resourceId: String? = nil) {
            self.fileName = fileName
            self.filePath = filePath
            self.hash = hash
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.fileName, name: "fileName", parent: name, pattern: "\\S")
            try self.validate(self.filePath, name: "filePath", parent: name, pattern: "\\S")
            try self.validate(self.hash, name: "hash", parent: name, pattern: "\\S")
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case fileName = "FileName"
            case filePath = "FilePath"
            case hash = "Hash"
            case resourceId = "ResourceId"
        }
    }

    public struct FindingAggregator: AWSDecodableShape {
        /// The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and delete the finding aggregator.
        public let findingAggregatorArn: String?

        public init(findingAggregatorArn: String? = nil) {
            self.findingAggregatorArn = findingAggregatorArn
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregatorArn = "FindingAggregatorArn"
        }
    }

    public struct FindingProviderFields: AWSEncodableShape & AWSDecodableShape {
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: Int?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: Int?
        /// A list of findings that are related to the current finding.
        public let relatedFindings: [RelatedFinding]?
        /// The severity of a finding.
        public let severity: FindingProviderSeverity?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public let types: [String]?

        public init(confidence: Int? = nil, criticality: Int? = nil, relatedFindings: [RelatedFinding]? = nil, severity: FindingProviderSeverity? = nil, types: [String]? = nil) {
            self.confidence = confidence
            self.criticality = criticality
            self.relatedFindings = relatedFindings
            self.severity = severity
            self.types = types
        }

        public func validate(name: String) throws {
            try self.validate(self.confidence, name: "confidence", parent: name, max: 100)
            try self.validate(self.confidence, name: "confidence", parent: name, min: 0)
            try self.validate(self.criticality, name: "criticality", parent: name, max: 100)
            try self.validate(self.criticality, name: "criticality", parent: name, min: 0)
            try self.relatedFindings?.forEach {
                try $0.validate(name: "\(name).relatedFindings[]")
            }
            try self.severity?.validate(name: "\(name).severity")
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case criticality = "Criticality"
            case relatedFindings = "RelatedFindings"
            case severity = "Severity"
            case types = "Types"
        }
    }

    public struct FindingProviderSeverity: AWSEncodableShape & AWSDecodableShape {
        /// The severity label assigned to the finding by the finding provider.
        public let label: SeverityLabel?
        /// The finding provider's original value for the severity.
        public let original: String?

        public init(label: SeverityLabel? = nil, original: String? = nil) {
            self.label = label
            self.original = original
        }

        public func validate(name: String) throws {
            try self.validate(self.original, name: "original", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case original = "Original"
        }
    }

    public struct FirewallPolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The stateful rule groups that are used in the firewall policy.
        public let statefulRuleGroupReferences: [FirewallPolicyStatefulRuleGroupReferencesDetails]?
        /// The custom action definitions that are available to use in the firewall policy's StatelessDefaultActions setting.
        public let statelessCustomActions: [FirewallPolicyStatelessCustomActionsDetails]?
        /// The actions to take on a packet if it doesn't match any of the stateless rules in the policy. You must specify a standard action (aws:pass, aws:drop, aws:forward_to_sfe), and can optionally include a custom action from StatelessCustomActions.
        public let statelessDefaultActions: [String]?
        /// The actions to take on a fragmented UDP packet if it doesn't match any of the stateless rules in the policy. You must specify a standard action (aws:pass, aws:drop, aws:forward_to_sfe), and can optionally include a custom action from StatelessCustomActions.
        public let statelessFragmentDefaultActions: [String]?
        /// The stateless rule groups that are used in the firewall policy.
        public let statelessRuleGroupReferences: [FirewallPolicyStatelessRuleGroupReferencesDetails]?

        public init(statefulRuleGroupReferences: [FirewallPolicyStatefulRuleGroupReferencesDetails]? = nil, statelessCustomActions: [FirewallPolicyStatelessCustomActionsDetails]? = nil, statelessDefaultActions: [String]? = nil, statelessFragmentDefaultActions: [String]? = nil, statelessRuleGroupReferences: [FirewallPolicyStatelessRuleGroupReferencesDetails]? = nil) {
            self.statefulRuleGroupReferences = statefulRuleGroupReferences
            self.statelessCustomActions = statelessCustomActions
            self.statelessDefaultActions = statelessDefaultActions
            self.statelessFragmentDefaultActions = statelessFragmentDefaultActions
            self.statelessRuleGroupReferences = statelessRuleGroupReferences
        }

        public func validate(name: String) throws {
            try self.statefulRuleGroupReferences?.forEach {
                try $0.validate(name: "\(name).statefulRuleGroupReferences[]")
            }
            try self.statelessCustomActions?.forEach {
                try $0.validate(name: "\(name).statelessCustomActions[]")
            }
            try self.statelessDefaultActions?.forEach {
                try validate($0, name: "statelessDefaultActions[]", parent: name, pattern: "\\S")
            }
            try self.statelessFragmentDefaultActions?.forEach {
                try validate($0, name: "statelessFragmentDefaultActions[]", parent: name, pattern: "\\S")
            }
            try self.statelessRuleGroupReferences?.forEach {
                try $0.validate(name: "\(name).statelessRuleGroupReferences[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case statefulRuleGroupReferences = "StatefulRuleGroupReferences"
            case statelessCustomActions = "StatelessCustomActions"
            case statelessDefaultActions = "StatelessDefaultActions"
            case statelessFragmentDefaultActions = "StatelessFragmentDefaultActions"
            case statelessRuleGroupReferences = "StatelessRuleGroupReferences"
        }
    }

    public struct FirewallPolicyStatefulRuleGroupReferencesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the stateful rule group.
        public let resourceArn: String?

        public init(resourceArn: String? = nil) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct FirewallPolicyStatelessCustomActionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The definition of the custom action.
        public let actionDefinition: StatelessCustomActionDefinition?
        /// The name of the custom action.
        public let actionName: String?

        public init(actionDefinition: StatelessCustomActionDefinition? = nil, actionName: String? = nil) {
            self.actionDefinition = actionDefinition
            self.actionName = actionName
        }

        public func validate(name: String) throws {
            try self.actionDefinition?.validate(name: "\(name).actionDefinition")
            try self.validate(self.actionName, name: "actionName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinition = "ActionDefinition"
            case actionName = "ActionName"
        }
    }

    public struct FirewallPolicyStatelessRuleGroupReferencesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The order in which to run the stateless rule group.
        public let priority: Int?
        /// The ARN of the stateless rule group.
        public let resourceArn: String?

        public init(priority: Int? = nil, resourceArn: String? = nil) {
            self.priority = priority
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case priority = "Priority"
            case resourceArn = "ResourceArn"
        }
    }

    public struct GeoLocation: AWSEncodableShape & AWSDecodableShape {
        /// The latitude of the location.
        public let lat: Double?
        /// The longitude of the location.
        public let lon: Double?

        public init(lat: Double? = nil, lon: Double? = nil) {
            self.lat = lat
            self.lon = lon
        }

        private enum CodingKeys: String, CodingKey {
            case lat = "Lat"
            case lon = "Lon"
        }
    }

    public struct GetAdministratorAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAdministratorAccountResponse: AWSDecodableShape {
        public let administrator: Invitation?

        public init(administrator: Invitation? = nil) {
            self.administrator = administrator
        }

        private enum CodingKeys: String, CodingKey {
            case administrator = "Administrator"
        }
    }

    public struct GetEnabledStandardsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the GetEnabledStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The list of the standards subscription ARNs for the standards to retrieve.
        public let standardsSubscriptionArns: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, standardsSubscriptionArns: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.standardsSubscriptionArns = standardsSubscriptionArns
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.standardsSubscriptionArns?.forEach {
                try validate($0, name: "standardsSubscriptionArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, max: 25)
            try self.validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case standardsSubscriptionArns = "StandardsSubscriptionArns"
        }
    }

    public struct GetEnabledStandardsResponse: AWSDecodableShape {
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// The list of StandardsSubscriptions objects that include information about the enabled standards.
        public let standardsSubscriptions: [StandardsSubscription]?

        public init(nextToken: String? = nil, standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.nextToken = nextToken
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct GetFindingAggregatorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "findingAggregatorArn", location: .uri("FindingAggregatorArn"))
        ]

        /// The ARN of the finding aggregator to return details for. To obtain the ARN, use ListFindingAggregators.
        public let findingAggregatorArn: String

        public init(findingAggregatorArn: String) {
            self.findingAggregatorArn = findingAggregatorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.findingAggregatorArn, name: "findingAggregatorArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingAggregatorResponse: AWSDecodableShape {
        /// The aggregation Region.
        public let findingAggregationRegion: String?
        /// The ARN of the finding aggregator.
        public let findingAggregatorArn: String?
        /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
        public let regionLinkingMode: String?
        /// The list of excluded Regions or included Regions.
        public let regions: [String]?

        public init(findingAggregationRegion: String? = nil, findingAggregatorArn: String? = nil, regionLinkingMode: String? = nil, regions: [String]? = nil) {
            self.findingAggregationRegion = findingAggregationRegion
            self.findingAggregatorArn = findingAggregatorArn
            self.regionLinkingMode = regionLinkingMode
            self.regions = regions
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregationRegion = "FindingAggregationRegion"
            case findingAggregatorArn = "FindingAggregatorArn"
            case regionLinkingMode = "RegionLinkingMode"
            case regions = "Regions"
        }
    }

    public struct GetFindingsRequest: AWSEncodableShape {
        /// The finding attributes used to define a condition to filter the returned findings. You can filter by up to 10 finding attributes. For each attribute, you can provide up to 20 filter values. Note that in the available filter fields, WorkflowState is deprecated. To search for a finding based on its workflow status, use WorkflowStatus.
        public let filters: AwsSecurityFindingFilters?
        /// The maximum number of findings to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the GetFindings operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The finding attributes used to sort the list of returned findings.
        public let sortCriteria: [SortCriterion]?

        public init(filters: AwsSecurityFindingFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [SortCriterion]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct GetFindingsResponse: AWSDecodableShape {
        /// The findings that matched the filters specified in the request.
        public let findings: [AwsSecurityFinding]
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(findings: [AwsSecurityFinding], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "Findings"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightResultsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "insightArn", location: .uri("InsightArn"))
        ]

        /// The ARN of the insight for which to return results.
        public let insightArn: String

        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        public func validate(name: String) throws {
            try self.validate(self.insightArn, name: "insightArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInsightResultsResponse: AWSDecodableShape {
        /// The insight results returned by the operation.
        public let insightResults: InsightResults

        public init(insightResults: InsightResults) {
            self.insightResults = insightResults
        }

        private enum CodingKeys: String, CodingKey {
            case insightResults = "InsightResults"
        }
    }

    public struct GetInsightsRequest: AWSEncodableShape {
        /// The ARNs of the insights to describe. If you do not provide any insight ARNs, then GetInsights returns all of your custom insights. It does not return any managed insights.
        public let insightArns: [String]?
        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the GetInsights operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(insightArns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.insightArns = insightArns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.insightArns?.forEach {
                try validate($0, name: "insightArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case insightArns = "InsightArns"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightsResponse: AWSDecodableShape {
        /// The insights returned by the operation.
        public let insights: [Insight]
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(insights: [Insight], nextToken: String? = nil) {
            self.insights = insights
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case insights = "Insights"
            case nextToken = "NextToken"
        }
    }

    public struct GetInvitationsCountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetInvitationsCountResponse: AWSDecodableShape {
        /// The number of all membership invitations sent to this Security Hub member account, not including the currently accepted invitation.
        public let invitationsCount: Int?

        public init(invitationsCount: Int? = nil) {
            self.invitationsCount = invitationsCount
        }

        private enum CodingKeys: String, CodingKey {
            case invitationsCount = "InvitationsCount"
        }
    }

    public struct GetMasterAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetMasterAccountResponse: AWSDecodableShape {
        /// A list of details about the Security Hub administrator account for the current member account.
        public let master: Invitation?

        public init(master: Invitation? = nil) {
            self.master = master
        }

        private enum CodingKeys: String, CodingKey {
            case master = "Master"
        }
    }

    public struct GetMembersRequest: AWSEncodableShape {
        /// The list of account IDs for the Security Hub member accounts to return the details for.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct GetMembersResponse: AWSDecodableShape {
        /// The list of details about the Security Hub member accounts.
        public let members: [Member]?
        /// The list of Amazon Web Services accounts that could not be processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(members: [Member]? = nil, unprocessedAccounts: [Result]? = nil) {
            self.members = members
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct IcmpTypeCode: AWSEncodableShape & AWSDecodableShape {
        /// The ICMP code for which to deny or allow access. To deny or allow all codes, use the value -1.
        public let code: Int?
        /// The ICMP type for which to deny or allow access. To deny or allow all types, use the value -1.
        public let type: Int?

        public init(code: Int? = nil, type: Int? = nil) {
            self.code = code
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case type = "Type"
        }
    }

    public struct ImportFindingsError: AWSDecodableShape {
        /// The code of the error returned by the BatchImportFindings operation.
        public let errorCode: String
        /// The message of the error returned by the BatchImportFindings operation.
        public let errorMessage: String
        /// The identifier of the finding that could not be updated.
        public let id: String

        public init(errorCode: String, errorMessage: String, id: String) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case id = "Id"
        }
    }

    public struct Insight: AWSDecodableShape {
        /// One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.
        public let filters: AwsSecurityFindingFilters
        /// The grouping attribute for the insight's findings. Indicates how to group the matching findings, and identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.
        public let groupByAttribute: String
        /// The ARN of a Security Hub insight.
        public let insightArn: String
        /// The name of a Security Hub insight.
        public let name: String

        public init(filters: AwsSecurityFindingFilters, groupByAttribute: String, insightArn: String, name: String) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case insightArn = "InsightArn"
            case name = "Name"
        }
    }

    public struct InsightResultValue: AWSDecodableShape {
        /// The number of findings returned for each GroupByAttributeValue.
        public let count: Int
        /// The value of the attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        public let groupByAttributeValue: String

        public init(count: Int, groupByAttributeValue: String) {
            self.count = count
            self.groupByAttributeValue = groupByAttributeValue
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case groupByAttributeValue = "GroupByAttributeValue"
        }
    }

    public struct InsightResults: AWSDecodableShape {
        /// The attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        public let groupByAttribute: String
        /// The ARN of the insight whose results are returned by the GetInsightResults operation.
        public let insightArn: String
        /// The list of insight result values returned by the GetInsightResults operation.
        public let resultValues: [InsightResultValue]

        public init(groupByAttribute: String, insightArn: String, resultValues: [InsightResultValue]) {
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.resultValues = resultValues
        }

        private enum CodingKeys: String, CodingKey {
            case groupByAttribute = "GroupByAttribute"
            case insightArn = "InsightArn"
            case resultValues = "ResultValues"
        }
    }

    public struct Invitation: AWSDecodableShape {
        /// The account ID of the Security Hub administrator account that the invitation was sent from.
        public let accountId: String?
        /// The ID of the invitation sent to the member account.
        public let invitationId: String?
        /// The timestamp of when the invitation was sent.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var invitedAt: Date?
        /// The current status of the association between the member and administrator accounts.
        public let memberStatus: String?

        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: Date? = nil, memberStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.memberStatus = memberStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case invitationId = "InvitationId"
            case invitedAt = "InvitedAt"
            case memberStatus = "MemberStatus"
        }
    }

    public struct InviteMembersRequest: AWSEncodableShape {
        /// The list of account IDs of the Amazon Web Services accounts to invite to Security Hub as members.
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct InviteMembersResponse: AWSDecodableShape {
        /// The list of Amazon Web Services accounts that could not be processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct IpFilter: AWSEncodableShape & AWSDecodableShape {
        /// A finding's CIDR value.
        public let cidr: String?

        public init(cidr: String? = nil) {
            self.cidr = cidr
        }

        public func validate(name: String) throws {
            try self.validate(self.cidr, name: "cidr", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "Cidr"
        }
    }

    public struct IpOrganizationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Autonomous System Number (ASN) of the internet provider
        public let asn: Int?
        /// The name of the organization that registered the ASN.
        public let asnOrg: String?
        /// The ISP information for the internet provider.
        public let isp: String?
        /// The name of the internet provider.
        public let org: String?

        public init(asn: Int? = nil, asnOrg: String? = nil, isp: String? = nil, org: String? = nil) {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }

        public func validate(name: String) throws {
            try self.validate(self.asnOrg, name: "asnOrg", parent: name, pattern: "\\S")
            try self.validate(self.isp, name: "isp", parent: name, pattern: "\\S")
            try self.validate(self.org, name: "org", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case asn = "Asn"
            case asnOrg = "AsnOrg"
            case isp = "Isp"
            case org = "Org"
        }
    }

    public struct Ipv6CidrBlockAssociation: AWSEncodableShape & AWSDecodableShape {
        /// The association ID for the IPv6 CIDR block.
        public let associationId: String?
        /// Information about the state of the CIDR block. Valid values are as follows:    associating     associated     disassociating     disassociated     failed     failing
        public let cidrBlockState: String?
        /// The IPv6 CIDR block.
        public let ipv6CidrBlock: String?

        public init(associationId: String? = nil, cidrBlockState: String? = nil, ipv6CidrBlock: String? = nil) {
            self.associationId = associationId
            self.cidrBlockState = cidrBlockState
            self.ipv6CidrBlock = ipv6CidrBlock
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, pattern: "\\S")
            try self.validate(self.cidrBlockState, name: "cidrBlockState", parent: name, pattern: "\\S")
            try self.validate(self.ipv6CidrBlock, name: "ipv6CidrBlock", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
            case cidrBlockState = "CidrBlockState"
            case ipv6CidrBlock = "Ipv6CidrBlock"
        }
    }

    public struct KeywordFilter: AWSEncodableShape & AWSDecodableShape {
        /// A value for the keyword.
        public let value: String?

        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct ListEnabledProductsForImportRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListEnabledProductsForImport operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnabledProductsForImportResponse: AWSDecodableShape {
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// The list of ARNs for the resources that represent your subscriptions to products.
        public let productSubscriptions: [String]?

        public init(nextToken: String? = nil, productSubscriptions: [String]? = nil) {
            self.nextToken = nextToken
            self.productSubscriptions = productSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case productSubscriptions = "ProductSubscriptions"
        }
    }

    public struct ListFindingAggregatorsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The maximum number of results to return. This operation currently only returns a single result.
        public let maxResults: Int?
        /// The token returned with the previous set of results. Identifies the next set of results to return.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFindingAggregatorsResponse: AWSDecodableShape {
        /// The list of finding aggregators. This operation currently only returns a single result.
        public let findingAggregators: [FindingAggregator]?
        /// If there are more results, this is the token to provide in the next call to ListFindingAggregators. This operation currently only returns a single result.
        public let nextToken: String?

        public init(findingAggregators: [FindingAggregator]? = nil, nextToken: String? = nil) {
            self.findingAggregators = findingAggregators
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregators = "FindingAggregators"
            case nextToken = "NextToken"
        }
    }

    public struct ListInvitationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListInvitations operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInvitationsResponse: AWSDecodableShape {
        /// The details of the invitations returned by the operation.
        public let invitations: [Invitation]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "Invitations"
            case nextToken = "NextToken"
        }
    }

    public struct ListMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "onlyAssociated", location: .querystring("OnlyAssociated"))
        ]

        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListMembers operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// Specifies which member accounts to include in the response based on their relationship status with the administrator account. The default value is TRUE. If OnlyAssociated is set to TRUE, the response includes member accounts whose relationship status with the administrator account is set to ENABLED. If OnlyAssociated is set to FALSE, the response includes all existing member accounts.
        public let onlyAssociated: Bool?

        public init(maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: Bool? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersResponse: AWSDecodableShape {
        /// Member details returned by the operation.
        public let members: [Member]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case nextToken = "NextToken"
        }
    }

    public struct ListOrganizationAdminAccountsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListOrganizationAdminAccounts operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOrganizationAdminAccountsResponse: AWSDecodableShape {
        /// The list of Security Hub administrator accounts.
        public let adminAccounts: [AdminAccount]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        public init(adminAccounts: [AdminAccount]? = nil, nextToken: String? = nil) {
            self.adminAccounts = adminAccounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccounts = "AdminAccounts"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The ARN of the resource to retrieve tags for.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:securityhub:")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LoadBalancerState: AWSEncodableShape & AWSDecodableShape {
        /// The state code. The initial state of the load balancer is provisioning. After the load balancer is fully set up and ready to route traffic, its state is active. If the load balancer could not be set up, its state is failed.
        public let code: String?
        /// A description of the state.
        public let reason: String?

        public init(code: String? = nil, reason: String? = nil) {
            self.code = code
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, pattern: "\\S")
            try self.validate(self.reason, name: "reason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case reason = "Reason"
        }
    }

    public struct Malware: AWSEncodableShape & AWSDecodableShape {
        /// The name of the malware that was observed.
        public let name: String
        /// The file system path of the malware that was observed.
        public let path: String?
        /// The state of the malware that was observed.
        public let state: MalwareState?
        /// The type of the malware that was observed.
        public let type: MalwareType?

        public init(name: String, path: String? = nil, state: MalwareState? = nil, type: MalwareType? = nil) {
            self.name = name
            self.path = path
            self.state = state
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case path = "Path"
            case state = "State"
            case type = "Type"
        }
    }

    public struct MapFilter: AWSEncodableShape & AWSDecodableShape {
        /// The condition to apply to the key value when querying for findings with a map filter. To search for values that exactly match the filter value, use EQUALS. For example, for the ResourceTags field, the filter Department EQUALS Security matches findings that have the value Security for the tag Department. To search for values other than the filter value, use NOT_EQUALS. For example, for the ResourceTags field, the filter Department NOT_EQUALS Finance matches findings that do not have the value Finance for the tag Department.  EQUALS filters on the same field are joined by OR. A finding matches if it matches any one of those filters.  NOT_EQUALS filters on the same field are joined by AND. A finding matches only if it matches all of those filters. You cannot have both an EQUALS filter and a NOT_EQUALS filter on the same field.
        public let comparison: MapFilterComparison?
        /// The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
        public let key: String?
        /// The value for the key in the map filter. Filter values are case sensitive. For example, one of the values for a tag called Department might be Security. If you provide security as the filter value, then there is no match.
        public let value: String?

        public init(comparison: MapFilterComparison? = nil, key: String? = nil, value: String? = nil) {
            self.comparison = comparison
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case key = "Key"
            case value = "Value"
        }
    }

    public struct Member: AWSDecodableShape {
        /// The Amazon Web Services account ID of the member account.
        public let accountId: String?
        /// The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.
        public let administratorId: String?
        /// The email address of the member account.
        public let email: String?
        /// A timestamp for the date and time when the invitation was sent to the member account.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var invitedAt: Date?
        /// This is replaced by AdministratorID. The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.
        public let masterId: String?
        /// The status of the relationship between the member account and its administrator account.  The status can have one of the following values:    CREATED - Indicates that the administrator account added the member account, but has not yet invited the member account.    INVITED - Indicates that the administrator account invited the member account. The member account has not yet responded to the invitation.    ENABLED - Indicates that the member account is currently active. For manually invited member accounts, indicates that the member account accepted the invitation.    REMOVED - Indicates that the administrator account disassociated the member account.    RESIGNED - Indicates that the member account disassociated themselves from the administrator account.    DELETED - Indicates that the administrator account deleted the member account.    ACCOUNT_SUSPENDED - Indicates that an organization account was suspended from Amazon Web Services at the same time that the administrator account tried to enable the organization account as a member account.
        public let memberStatus: String?
        /// The timestamp for the date and time when the member account was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(accountId: String? = nil, administratorId: String? = nil, email: String? = nil, invitedAt: Date? = nil, memberStatus: String? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.administratorId = administratorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = nil
            self.memberStatus = memberStatus
            self.updatedAt = updatedAt
        }

        @available(*, deprecated, message: "Members masterId have been deprecated")
        public init(accountId: String? = nil, administratorId: String? = nil, email: String? = nil, invitedAt: Date? = nil, masterId: String? = nil, memberStatus: String? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.administratorId = administratorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.memberStatus = memberStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case administratorId = "AdministratorId"
            case email = "Email"
            case invitedAt = "InvitedAt"
            case masterId = "MasterId"
            case memberStatus = "MemberStatus"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct Network: AWSEncodableShape & AWSDecodableShape {
        /// The destination domain of network-related information about a finding.
        public let destinationDomain: String?
        /// The destination IPv4 address of network-related information about a finding.
        public let destinationIpV4: String?
        /// The destination IPv6 address of network-related information about a finding.
        public let destinationIpV6: String?
        /// The destination port of network-related information about a finding.
        public let destinationPort: Int?
        /// The direction of network traffic associated with a finding.
        public let direction: NetworkDirection?
        /// The range of open ports that is present on the network.
        public let openPortRange: PortRange?
        /// The protocol of network-related information about a finding.
        public let `protocol`: String?
        /// The source domain of network-related information about a finding.
        public let sourceDomain: String?
        /// The source IPv4 address of network-related information about a finding.
        public let sourceIpV4: String?
        /// The source IPv6 address of network-related information about a finding.
        public let sourceIpV6: String?
        /// The source media access control (MAC) address of network-related information about a finding.
        public let sourceMac: String?
        /// The source port of network-related information about a finding.
        public let sourcePort: Int?

        public init(destinationDomain: String? = nil, destinationIpV4: String? = nil, destinationIpV6: String? = nil, destinationPort: Int? = nil, direction: NetworkDirection? = nil, openPortRange: PortRange? = nil, protocol: String? = nil, sourceDomain: String? = nil, sourceIpV4: String? = nil, sourceIpV6: String? = nil, sourceMac: String? = nil, sourcePort: Int? = nil) {
            self.destinationDomain = destinationDomain
            self.destinationIpV4 = destinationIpV4
            self.destinationIpV6 = destinationIpV6
            self.destinationPort = destinationPort
            self.direction = direction
            self.openPortRange = openPortRange
            self.`protocol` = `protocol`
            self.sourceDomain = sourceDomain
            self.sourceIpV4 = sourceIpV4
            self.sourceIpV6 = sourceIpV6
            self.sourceMac = sourceMac
            self.sourcePort = sourcePort
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationDomain, name: "destinationDomain", parent: name, pattern: "\\S")
            try self.validate(self.destinationIpV4, name: "destinationIpV4", parent: name, pattern: "\\S")
            try self.validate(self.destinationIpV6, name: "destinationIpV6", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.validate(self.sourceDomain, name: "sourceDomain", parent: name, pattern: "\\S")
            try self.validate(self.sourceIpV4, name: "sourceIpV4", parent: name, pattern: "\\S")
            try self.validate(self.sourceIpV6, name: "sourceIpV6", parent: name, pattern: "\\S")
            try self.validate(self.sourceMac, name: "sourceMac", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationDomain = "DestinationDomain"
            case destinationIpV4 = "DestinationIpV4"
            case destinationIpV6 = "DestinationIpV6"
            case destinationPort = "DestinationPort"
            case direction = "Direction"
            case openPortRange = "OpenPortRange"
            case `protocol` = "Protocol"
            case sourceDomain = "SourceDomain"
            case sourceIpV4 = "SourceIpV4"
            case sourceIpV6 = "SourceIpV6"
            case sourceMac = "SourceMac"
            case sourcePort = "SourcePort"
        }
    }

    public struct NetworkConnectionAction: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the network connection attempt was blocked.
        public let blocked: Bool?
        /// The direction of the network connection request (IN or OUT).
        public let connectionDirection: String?
        /// Information about the port on the EC2 instance.
        public let localPortDetails: ActionLocalPortDetails?
        /// The protocol used to make the network connection request.
        public let `protocol`: String?
        /// Information about the remote IP address that issued the network connection request.
        public let remoteIpDetails: ActionRemoteIpDetails?
        /// Information about the port on the remote IP address.
        public let remotePortDetails: ActionRemotePortDetails?

        public init(blocked: Bool? = nil, connectionDirection: String? = nil, localPortDetails: ActionLocalPortDetails? = nil, protocol: String? = nil, remoteIpDetails: ActionRemoteIpDetails? = nil, remotePortDetails: ActionRemotePortDetails? = nil) {
            self.blocked = blocked
            self.connectionDirection = connectionDirection
            self.localPortDetails = localPortDetails
            self.`protocol` = `protocol`
            self.remoteIpDetails = remoteIpDetails
            self.remotePortDetails = remotePortDetails
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionDirection, name: "connectionDirection", parent: name, pattern: "\\S")
            try self.localPortDetails?.validate(name: "\(name).localPortDetails")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.remoteIpDetails?.validate(name: "\(name).remoteIpDetails")
            try self.remotePortDetails?.validate(name: "\(name).remotePortDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "Blocked"
            case connectionDirection = "ConnectionDirection"
            case localPortDetails = "LocalPortDetails"
            case `protocol` = "Protocol"
            case remoteIpDetails = "RemoteIpDetails"
            case remotePortDetails = "RemotePortDetails"
        }
    }

    public struct NetworkHeader: AWSEncodableShape & AWSDecodableShape {
        /// Information about the destination of the component.
        public let destination: NetworkPathComponentDetails?
        /// The protocol used for the component.
        public let `protocol`: String?
        /// Information about the origin of the component.
        public let source: NetworkPathComponentDetails?

        public init(destination: NetworkPathComponentDetails? = nil, protocol: String? = nil, source: NetworkPathComponentDetails? = nil) {
            self.destination = destination
            self.`protocol` = `protocol`
            self.source = source
        }

        public func validate(name: String) throws {
            try self.destination?.validate(name: "\(name).destination")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.source?.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case `protocol` = "Protocol"
            case source = "Source"
        }
    }

    public struct NetworkPathComponent: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of a component in the network path.
        public let componentId: String?
        /// The type of component.
        public let componentType: String?
        /// Information about the component that comes after the current component in the network path.
        public let egress: NetworkHeader?
        /// Information about the component that comes before the current node in the network path.
        public let ingress: NetworkHeader?

        public init(componentId: String? = nil, componentType: String? = nil, egress: NetworkHeader? = nil, ingress: NetworkHeader? = nil) {
            self.componentId = componentId
            self.componentType = componentType
            self.egress = egress
            self.ingress = ingress
        }

        public func validate(name: String) throws {
            try self.validate(self.componentId, name: "componentId", parent: name, pattern: "\\S")
            try self.validate(self.componentType, name: "componentType", parent: name, pattern: "\\S")
            try self.egress?.validate(name: "\(name).egress")
            try self.ingress?.validate(name: "\(name).ingress")
        }

        private enum CodingKeys: String, CodingKey {
            case componentId = "ComponentId"
            case componentType = "ComponentType"
            case egress = "Egress"
            case ingress = "Ingress"
        }
    }

    public struct NetworkPathComponentDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IP addresses of the destination.
        public let address: [String]?
        /// A list of port ranges for the destination.
        public let portRanges: [PortRange]?

        public init(address: [String]? = nil, portRanges: [PortRange]? = nil) {
            self.address = address
            self.portRanges = portRanges
        }

        public func validate(name: String) throws {
            try self.address?.forEach {
                try validate($0, name: "address[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case portRanges = "PortRanges"
        }
    }

    public struct Note: AWSEncodableShape & AWSDecodableShape {
        /// The text of a note.
        public let text: String
        /// The timestamp of when the note was updated. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let updatedAt: String
        /// The principal that created a note.
        public let updatedBy: String

        public init(text: String, updatedAt: String, updatedBy: String) {
            self.text = text
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, pattern: "\\S")
            try self.validate(self.updatedAt, name: "updatedAt", parent: name, pattern: "\\S")
            try self.validate(self.updatedBy, name: "updatedBy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case updatedAt = "UpdatedAt"
            case updatedBy = "UpdatedBy"
        }
    }

    public struct NoteUpdate: AWSEncodableShape {
        /// The updated note text.
        public let text: String
        /// The principal that updated the note.
        public let updatedBy: String

        public init(text: String, updatedBy: String) {
            self.text = text
            self.updatedBy = updatedBy
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, pattern: "\\S")
            try self.validate(self.updatedBy, name: "updatedBy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case updatedBy = "UpdatedBy"
        }
    }

    public struct NumberFilter: AWSEncodableShape & AWSDecodableShape {
        /// The equal-to condition to be applied to a single field when querying for findings.
        public let eq: Double?
        /// The greater-than-equal condition to be applied to a single field when querying for findings.
        public let gte: Double?
        /// The less-than-equal condition to be applied to a single field when querying for findings.
        public let lte: Double?

        public init(eq: Double? = nil, gte: Double? = nil, lte: Double? = nil) {
            self.eq = eq
            self.gte = gte
            self.lte = lte
        }

        private enum CodingKeys: String, CodingKey {
            case eq = "Eq"
            case gte = "Gte"
            case lte = "Lte"
        }
    }

    public struct Occurrences: AWSEncodableShape & AWSDecodableShape {
        /// Occurrences of sensitive data detected in Microsoft Excel workbooks, comma-separated value (CSV) files, or tab-separated value (TSV) files.
        public let cells: [Cell]?
        /// Occurrences of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.
        public let lineRanges: [Range]?
        /// Occurrences of sensitive data detected in a binary text file.
        public let offsetRanges: [Range]?
        /// Occurrences of sensitive data in an Adobe Portable Document Format (PDF) file.
        public let pages: [Page]?
        /// Occurrences of sensitive data in an Apache Avro object container or an Apache Parquet file.
        public let records: [Record]?

        public init(cells: [Cell]? = nil, lineRanges: [Range]? = nil, offsetRanges: [Range]? = nil, pages: [Page]? = nil, records: [Record]? = nil) {
            self.cells = cells
            self.lineRanges = lineRanges
            self.offsetRanges = offsetRanges
            self.pages = pages
            self.records = records
        }

        public func validate(name: String) throws {
            try self.cells?.forEach {
                try $0.validate(name: "\(name).cells[]")
            }
            try self.records?.forEach {
                try $0.validate(name: "\(name).records[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cells = "Cells"
            case lineRanges = "LineRanges"
            case offsetRanges = "OffsetRanges"
            case pages = "Pages"
            case records = "Records"
        }
    }

    public struct Page: AWSEncodableShape & AWSDecodableShape {
        /// An occurrence of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.
        public let lineRange: Range?
        /// An occurrence of sensitive data detected in a binary text file.
        public let offsetRange: Range?
        /// The page number of the page that contains the sensitive data.
        public let pageNumber: Int64?

        public init(lineRange: Range? = nil, offsetRange: Range? = nil, pageNumber: Int64? = nil) {
            self.lineRange = lineRange
            self.offsetRange = offsetRange
            self.pageNumber = pageNumber
        }

        private enum CodingKeys: String, CodingKey {
            case lineRange = "LineRange"
            case offsetRange = "OffsetRange"
            case pageNumber = "PageNumber"
        }
    }

    public struct PatchSummary: AWSEncodableShape & AWSDecodableShape {
        /// The number of patches from the compliance standard that failed to install.
        public let failedCount: Int?
        /// The identifier of the compliance standard that was used to determine the patch compliance status.
        public let id: String
        /// The number of patches from the compliance standard that were installed successfully.
        public let installedCount: Int?
        /// The number of installed patches that are not part of the compliance standard.
        public let installedOtherCount: Int?
        /// The number of patches that were applied, but that require the instance to be rebooted in order to be marked as installed.
        public let installedPendingReboot: Int?
        /// The number of patches that are installed but are also on a list of patches that the customer rejected.
        public let installedRejectedCount: Int?
        /// The number of patches that are part of the compliance standard but are not installed. The count includes patches that failed to install.
        public let missingCount: Int?
        /// The type of patch operation performed. For Patch Manager, the values are SCAN and INSTALL.
        public let operation: String?
        /// Indicates when the operation completed. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let operationEndTime: String?
        /// Indicates when the operation started. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let operationStartTime: String?
        /// The reboot option specified for the instance.
        public let rebootOption: String?

        public init(failedCount: Int? = nil, id: String, installedCount: Int? = nil, installedOtherCount: Int? = nil, installedPendingReboot: Int? = nil, installedRejectedCount: Int? = nil, missingCount: Int? = nil, operation: String? = nil, operationEndTime: String? = nil, operationStartTime: String? = nil, rebootOption: String? = nil) {
            self.failedCount = failedCount
            self.id = id
            self.installedCount = installedCount
            self.installedOtherCount = installedOtherCount
            self.installedPendingReboot = installedPendingReboot
            self.installedRejectedCount = installedRejectedCount
            self.missingCount = missingCount
            self.operation = operation
            self.operationEndTime = operationEndTime
            self.operationStartTime = operationStartTime
            self.rebootOption = rebootOption
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.operation, name: "operation", parent: name, pattern: "\\S")
            try self.validate(self.operationEndTime, name: "operationEndTime", parent: name, pattern: "\\S")
            try self.validate(self.operationStartTime, name: "operationStartTime", parent: name, pattern: "\\S")
            try self.validate(self.rebootOption, name: "rebootOption", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case failedCount = "FailedCount"
            case id = "Id"
            case installedCount = "InstalledCount"
            case installedOtherCount = "InstalledOtherCount"
            case installedPendingReboot = "InstalledPendingReboot"
            case installedRejectedCount = "InstalledRejectedCount"
            case missingCount = "MissingCount"
            case operation = "Operation"
            case operationEndTime = "OperationEndTime"
            case operationStartTime = "OperationStartTime"
            case rebootOption = "RebootOption"
        }
    }

    public struct PortProbeAction: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the port probe was blocked.
        public let blocked: Bool?
        /// Information about the ports affected by the port probe.
        public let portProbeDetails: [PortProbeDetail]?

        public init(blocked: Bool? = nil, portProbeDetails: [PortProbeDetail]? = nil) {
            self.blocked = blocked
            self.portProbeDetails = portProbeDetails
        }

        public func validate(name: String) throws {
            try self.portProbeDetails?.forEach {
                try $0.validate(name: "\(name).portProbeDetails[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "Blocked"
            case portProbeDetails = "PortProbeDetails"
        }
    }

    public struct PortProbeDetail: AWSEncodableShape & AWSDecodableShape {
        /// Provides information about the IP address where the scanned port is located.
        public let localIpDetails: ActionLocalIpDetails?
        /// Provides information about the port that was scanned.
        public let localPortDetails: ActionLocalPortDetails?
        /// Provides information about the remote IP address that performed the scan.
        public let remoteIpDetails: ActionRemoteIpDetails?

        public init(localIpDetails: ActionLocalIpDetails? = nil, localPortDetails: ActionLocalPortDetails? = nil, remoteIpDetails: ActionRemoteIpDetails? = nil) {
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.remoteIpDetails = remoteIpDetails
        }

        public func validate(name: String) throws {
            try self.localIpDetails?.validate(name: "\(name).localIpDetails")
            try self.localPortDetails?.validate(name: "\(name).localPortDetails")
            try self.remoteIpDetails?.validate(name: "\(name).remoteIpDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case localIpDetails = "LocalIpDetails"
            case localPortDetails = "LocalPortDetails"
            case remoteIpDetails = "RemoteIpDetails"
        }
    }

    public struct PortRange: AWSEncodableShape & AWSDecodableShape {
        /// The first port in the port range.
        public let begin: Int?
        /// The last port in the port range.
        public let end: Int?

        public init(begin: Int? = nil, end: Int? = nil) {
            self.begin = begin
            self.end = end
        }

        private enum CodingKeys: String, CodingKey {
            case begin = "Begin"
            case end = "End"
        }
    }

    public struct PortRangeFromTo: AWSEncodableShape & AWSDecodableShape {
        /// The first port in the port range.
        public let from: Int?
        /// The last port in the port range.
        public let to: Int?

        public init(from: Int? = nil, to: Int? = nil) {
            self.from = from
            self.to = to
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case to = "To"
        }
    }

    public struct ProcessDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates when the process was launched. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let launchedAt: String?
        /// The name of the process.
        public let name: String?
        /// The parent process ID.
        public let parentPid: Int?
        /// The path to the process executable.
        public let path: String?
        /// The process ID.
        public let pid: Int?
        /// Indicates when the process was terminated. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let terminatedAt: String?

        public init(launchedAt: String? = nil, name: String? = nil, parentPid: Int? = nil, path: String? = nil, pid: Int? = nil, terminatedAt: String? = nil) {
            self.launchedAt = launchedAt
            self.name = name
            self.parentPid = parentPid
            self.path = path
            self.pid = pid
            self.terminatedAt = terminatedAt
        }

        public func validate(name: String) throws {
            try self.validate(self.launchedAt, name: "launchedAt", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.validate(self.terminatedAt, name: "terminatedAt", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case launchedAt = "LaunchedAt"
            case name = "Name"
            case parentPid = "ParentPid"
            case path = "Path"
            case pid = "Pid"
            case terminatedAt = "TerminatedAt"
        }
    }

    public struct Product: AWSDecodableShape {
        /// The URL to the service or product documentation about the integration with Security Hub, including how to activate the integration.
        public let activationUrl: String?
        /// The categories assigned to the product.
        public let categories: [String]?
        /// The name of the company that provides the product.
        public let companyName: String?
        /// A description of the product.
        public let description: String?
        /// The types of integration that the product supports. Available values are the following.    SEND_FINDINGS_TO_SECURITY_HUB - The integration sends findings to Security Hub.    RECEIVE_FINDINGS_FROM_SECURITY_HUB - The integration receives findings from Security Hub.    UPDATE_FINDINGS_IN_SECURITY_HUB - The integration does not send new findings to Security Hub, but does make updates to the findings that it receives from Security Hub.
        public let integrationTypes: [IntegrationType]?
        /// For integrations with Amazon Web Services services, the Amazon Web Services Console URL from which to activate the service. For integrations with third-party products, the Amazon Web Services Marketplace URL from which to subscribe to or purchase the product.
        public let marketplaceUrl: String?
        /// The ARN assigned to the product.
        public let productArn: String
        /// The name of the product.
        public let productName: String?
        /// The resource policy associated with the product.
        public let productSubscriptionResourcePolicy: String?

        public init(activationUrl: String? = nil, categories: [String]? = nil, companyName: String? = nil, description: String? = nil, integrationTypes: [IntegrationType]? = nil, marketplaceUrl: String? = nil, productArn: String, productName: String? = nil, productSubscriptionResourcePolicy: String? = nil) {
            self.activationUrl = activationUrl
            self.categories = categories
            self.companyName = companyName
            self.description = description
            self.integrationTypes = integrationTypes
            self.marketplaceUrl = marketplaceUrl
            self.productArn = productArn
            self.productName = productName
            self.productSubscriptionResourcePolicy = productSubscriptionResourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case activationUrl = "ActivationUrl"
            case categories = "Categories"
            case companyName = "CompanyName"
            case description = "Description"
            case integrationTypes = "IntegrationTypes"
            case marketplaceUrl = "MarketplaceUrl"
            case productArn = "ProductArn"
            case productName = "ProductName"
            case productSubscriptionResourcePolicy = "ProductSubscriptionResourcePolicy"
        }
    }

    public struct Range: AWSEncodableShape & AWSDecodableShape {
        /// The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.
        public let end: Int64?
        /// The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.
        public let start: Int64?
        /// In the line where the sensitive data starts, the column within the line where the sensitive data starts.
        public let startColumn: Int64?

        public init(end: Int64? = nil, start: Int64? = nil, startColumn: Int64? = nil) {
            self.end = end
            self.start = start
            self.startColumn = startColumn
        }

        private enum CodingKeys: String, CodingKey {
            case end = "End"
            case start = "Start"
            case startColumn = "StartColumn"
        }
    }

    public struct Recommendation: AWSEncodableShape & AWSDecodableShape {
        /// Describes the recommended steps to take to remediate an issue identified in a finding.
        public let text: String?
        /// A URL to a page or site that contains information about how to remediate a finding.
        public let url: String?

        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, pattern: "\\S")
            try self.validate(self.url, name: "url", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case url = "Url"
        }
    }

    public struct Record: AWSEncodableShape & AWSDecodableShape {
        /// The path, as a JSONPath expression, to the field in the record that contains the data. If the field name is longer than 20 characters, it is truncated. If the path is longer than 250 characters, it is truncated.
        public let jsonPath: String?
        /// The record index, starting from 0, for the record that contains the data.
        public let recordIndex: Int64?

        public init(jsonPath: String? = nil, recordIndex: Int64? = nil) {
            self.jsonPath = jsonPath
            self.recordIndex = recordIndex
        }

        public func validate(name: String) throws {
            try self.validate(self.jsonPath, name: "jsonPath", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case jsonPath = "JsonPath"
            case recordIndex = "RecordIndex"
        }
    }

    public struct RelatedFinding: AWSEncodableShape & AWSDecodableShape {
        /// The product-generated identifier for a related finding.
        public let id: String
        /// The ARN of the product that generated a related finding.
        public let productArn: String

        public init(id: String, productArn: String) {
            self.id = id
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case productArn = "ProductArn"
        }
    }

    public struct Remediation: AWSEncodableShape & AWSDecodableShape {
        /// A recommendation on the steps to take to remediate the issue identified by a finding.
        public let recommendation: Recommendation?

        public init(recommendation: Recommendation? = nil) {
            self.recommendation = recommendation
        }

        public func validate(name: String) throws {
            try self.recommendation?.validate(name: "\(name).recommendation")
        }

        private enum CodingKeys: String, CodingKey {
            case recommendation = "Recommendation"
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {
        /// Contains information about sensitive data that was detected on the resource.
        public let dataClassification: DataClassificationDetails?
        /// Additional details about the resource related to a finding.
        public let details: ResourceDetails?
        /// The canonical identifier for the given resource type.
        public let id: String
        /// The canonical Amazon Web Services partition name that the Region is assigned to.
        public let partition: Partition?
        /// The canonical Amazon Web Services external Region name where this resource is located.
        public let region: String?
        /// Identifies the role of the resource in the finding. A resource is either the actor or target of the finding activity,
        public let resourceRole: String?
        /// A list of Amazon Web Services tags associated with a resource at the time the finding was processed.
        public let tags: [String: String]?
        /// The type of the resource that details are provided for. If possible, set Type to one of the supported resource types. For example, if the resource is an EC2 instance, then set Type to AwsEc2Instance. If the resource does not match any of the provided types, then set Type to Other.
        public let type: String

        public init(dataClassification: DataClassificationDetails? = nil, details: ResourceDetails? = nil, id: String, partition: Partition? = nil, region: String? = nil, resourceRole: String? = nil, tags: [String: String]? = nil, type: String) {
            self.dataClassification = dataClassification
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.resourceRole = resourceRole
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.dataClassification?.validate(name: "\(name).dataClassification")
            try self.details?.validate(name: "\(name).details")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.region, name: "region", parent: name, pattern: "\\S")
            try self.validate(self.resourceRole, name: "resourceRole", parent: name, pattern: "\\S")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataClassification = "DataClassification"
            case details = "Details"
            case id = "Id"
            case partition = "Partition"
            case region = "Region"
            case resourceRole = "ResourceRole"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct ResourceDetails: AWSEncodableShape & AWSDecodableShape {
        /// Provides information about a REST API in version 1 of Amazon API Gateway.
        public let awsApiGatewayRestApi: AwsApiGatewayRestApiDetails?
        /// Provides information about a version 1 Amazon API Gateway stage.
        public let awsApiGatewayStage: AwsApiGatewayStageDetails?
        /// Provides information about a version 2 API in Amazon API Gateway.
        public let awsApiGatewayV2Api: AwsApiGatewayV2ApiDetails?
        /// Provides information about a version 2 stage for Amazon API Gateway.
        public let awsApiGatewayV2Stage: AwsApiGatewayV2StageDetails?
        /// Details for an autoscaling group.
        public let awsAutoScalingAutoScalingGroup: AwsAutoScalingAutoScalingGroupDetails?
        /// Provides details about a launch configuration.
        public let awsAutoScalingLaunchConfiguration: AwsAutoScalingLaunchConfigurationDetails?
        /// Provides details about an Backup backup plan.
        public let awsBackupBackupPlan: AwsBackupBackupPlanDetails?
        /// Provides details about an Backup backup vault.
        public let awsBackupBackupVault: AwsBackupBackupVaultDetails?
        /// Provides details about an Backup backup, or recovery point.
        public let awsBackupRecoveryPoint: AwsBackupRecoveryPointDetails?
        /// Provides details about an Certificate Manager certificate.
        public let awsCertificateManagerCertificate: AwsCertificateManagerCertificateDetails?
        /// Details about an CloudFormation stack. A stack is a collection of Amazon Web Services resources that you can manage as a single unit.
        public let awsCloudFormationStack: AwsCloudFormationStackDetails?
        /// Details about a CloudFront distribution.
        public let awsCloudFrontDistribution: AwsCloudFrontDistributionDetails?
        /// Provides details about a CloudTrail trail.
        public let awsCloudTrailTrail: AwsCloudTrailTrailDetails?
        /// Details about an Amazon CloudWatch alarm. An alarm allows you to monitor and receive alerts about your Amazon Web Services resources and applications across multiple Regions.
        public let awsCloudWatchAlarm: AwsCloudWatchAlarmDetails?
        /// Details for an CodeBuild project.
        public let awsCodeBuildProject: AwsCodeBuildProjectDetails?
        /// Details about a DynamoDB table.
        public let awsDynamoDbTable: AwsDynamoDbTableDetails?
        /// Details about an Elastic IP address.
        public let awsEc2Eip: AwsEc2EipDetails?
        /// Details about an EC2 instance related to a finding.
        public let awsEc2Instance: AwsEc2InstanceDetails?
        public let awsEc2LaunchTemplate: AwsEc2LaunchTemplateDetails?
        /// Details about an EC2 network access control list (ACL).
        public let awsEc2NetworkAcl: AwsEc2NetworkAclDetails?
        /// Details for an EC2 network interface.
        public let awsEc2NetworkInterface: AwsEc2NetworkInterfaceDetails?
        /// Details for an EC2 security group.
        public let awsEc2SecurityGroup: AwsEc2SecurityGroupDetails?
        /// Details about a subnet in Amazon EC2.
        public let awsEc2Subnet: AwsEc2SubnetDetails?
        /// Details about an Amazon EC2 transit gateway that interconnects your virtual private clouds (VPC) and on-premises networks.
        public let awsEc2TransitGateway: AwsEc2TransitGatewayDetails?
        /// Details for an Amazon EC2 volume.
        public let awsEc2Volume: AwsEc2VolumeDetails?
        /// Details for an Amazon EC2 VPC.
        public let awsEc2Vpc: AwsEc2VpcDetails?
        /// Details about the service configuration for a VPC endpoint service.
        public let awsEc2VpcEndpointService: AwsEc2VpcEndpointServiceDetails?
        /// Details about an Amazon EC2 VPC peering connection. A VPC peering connection is a networking connection between two VPCs that enables you to route traffic between them privately.
        public let awsEc2VpcPeeringConnection: AwsEc2VpcPeeringConnectionDetails?
        /// Details about an Amazon EC2 VPN connection.
        public let awsEc2VpnConnection: AwsEc2VpnConnectionDetails?
        /// Information about an Amazon ECR image.
        public let awsEcrContainerImage: AwsEcrContainerImageDetails?
        /// Information about an Amazon Elastic Container Registry repository.
        public let awsEcrRepository: AwsEcrRepositoryDetails?
        /// Details about an Amazon ECS cluster.
        public let awsEcsCluster: AwsEcsClusterDetails?
        /// Provides information about a Docker container that's part of a task.
        public let awsEcsContainer: AwsEcsContainerDetails?
        /// Details about a service within an ECS cluster.
        public let awsEcsService: AwsEcsServiceDetails?
        /// Details about a task in a cluster.
        public let awsEcsTask: AwsEcsTaskDetails?
        /// Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.
        public let awsEcsTaskDefinition: AwsEcsTaskDefinitionDetails?
        /// Details about an Amazon EFS access point. An access point is an application-specific view into an EFS file system that
        /// applies an operating system user and group, and a file system path, to any file system request made through the access point.
        public let awsEfsAccessPoint: AwsEfsAccessPointDetails?
        /// Details about an Amazon EKS cluster.
        public let awsEksCluster: AwsEksClusterDetails?
        /// Details about an Elastic Beanstalk environment.
        public let awsElasticBeanstalkEnvironment: AwsElasticBeanstalkEnvironmentDetails?
        /// Details for an Elasticsearch domain.
        public let awsElasticsearchDomain: AwsElasticsearchDomainDetails?
        /// Contains details about a Classic Load Balancer.
        public let awsElbLoadBalancer: AwsElbLoadBalancerDetails?
        /// Details about a load balancer.
        public let awsElbv2LoadBalancer: AwsElbv2LoadBalancerDetails?
        /// Details about an IAM access key related to a finding.
        public let awsIamAccessKey: AwsIamAccessKeyDetails?
        /// Contains details about an IAM group.
        public let awsIamGroup: AwsIamGroupDetails?
        /// Details about an IAM permissions policy.
        public let awsIamPolicy: AwsIamPolicyDetails?
        /// Details about an IAM role.
        public let awsIamRole: AwsIamRoleDetails?
        /// Details about an IAM user.
        public let awsIamUser: AwsIamUserDetails?
        /// Details about an Amazon Kinesis data stream.
        public let awsKinesisStream: AwsKinesisStreamDetails?
        /// Details about an KMS key.
        public let awsKmsKey: AwsKmsKeyDetails?
        /// Details about a Lambda function.
        public let awsLambdaFunction: AwsLambdaFunctionDetails?
        /// Details for a Lambda layer version.
        public let awsLambdaLayerVersion: AwsLambdaLayerVersionDetails?
        /// Details about an Network Firewall firewall.
        public let awsNetworkFirewallFirewall: AwsNetworkFirewallFirewallDetails?
        /// Details about an Network Firewall firewall policy.
        public let awsNetworkFirewallFirewallPolicy: AwsNetworkFirewallFirewallPolicyDetails?
        /// Details about an Network Firewall rule group.
        public let awsNetworkFirewallRuleGroup: AwsNetworkFirewallRuleGroupDetails?
        /// Details about an Amazon OpenSearch Service domain.
        public let awsOpenSearchServiceDomain: AwsOpenSearchServiceDomainDetails?
        /// Details about an Amazon RDS database cluster.
        public let awsRdsDbCluster: AwsRdsDbClusterDetails?
        /// Details about an Amazon RDS database cluster snapshot.
        public let awsRdsDbClusterSnapshot: AwsRdsDbClusterSnapshotDetails?
        /// Details about an Amazon RDS database instance.
        public let awsRdsDbInstance: AwsRdsDbInstanceDetails?
        /// Details about an Amazon RDS DB security group.
        public let awsRdsDbSecurityGroup: AwsRdsDbSecurityGroupDetails?
        /// Details about an Amazon RDS database snapshot.
        public let awsRdsDbSnapshot: AwsRdsDbSnapshotDetails?
        /// Details about an RDS event notification subscription.
        public let awsRdsEventSubscription: AwsRdsEventSubscriptionDetails?
        /// Contains details about an Amazon Redshift cluster.
        public let awsRedshiftCluster: AwsRedshiftClusterDetails?
        /// Details about the Amazon S3 Public Access Block configuration for an account.
        public let awsS3AccountPublicAccessBlock: AwsS3AccountPublicAccessBlockDetails?
        /// Details about an S3 bucket related to a finding.
        public let awsS3Bucket: AwsS3BucketDetails?
        /// Details about an S3 object related to a finding.
        public let awsS3Object: AwsS3ObjectDetails?
        public let awsSageMakerNotebookInstance: AwsSageMakerNotebookInstanceDetails?
        /// Details about a Secrets Manager secret.
        public let awsSecretsManagerSecret: AwsSecretsManagerSecretDetails?
        /// Details about an SNS topic.
        public let awsSnsTopic: AwsSnsTopicDetails?
        /// Details about an SQS queue.
        public let awsSqsQueue: AwsSqsQueueDetails?
        /// Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.
        public let awsSsmPatchCompliance: AwsSsmPatchComplianceDetails?
        /// Details about a rate-based rule for global resources.
        public let awsWafRateBasedRule: AwsWafRateBasedRuleDetails?
        /// Details about a rate-based rule for Regional resources.
        public let awsWafRegionalRateBasedRule: AwsWafRegionalRateBasedRuleDetails?
        /// Details about an WAF rule for Regional resources.
        public let awsWafRegionalRule: AwsWafRegionalRuleDetails?
        /// Details about an WAF rule group for Regional resources.
        public let awsWafRegionalRuleGroup: AwsWafRegionalRuleGroupDetails?
        /// Details about an WAF web access control list (web ACL) for Regional resources.
        public let awsWafRegionalWebAcl: AwsWafRegionalWebAclDetails?
        /// Details about an WAF rule for global resources.
        public let awsWafRule: AwsWafRuleDetails?
        /// Details about an WAF rule group for global resources.
        public let awsWafRuleGroup: AwsWafRuleGroupDetails?
        public let awsWafv2RuleGroup: AwsWafv2RuleGroupDetails?
        public let awsWafv2WebAcl: AwsWafv2WebAclDetails?
        /// Details for an WAF web ACL.
        public let awsWafWebAcl: AwsWafWebAclDetails?
        /// Information about the encryption configuration for X-Ray.
        public let awsXrayEncryptionConfig: AwsXrayEncryptionConfigDetails?
        /// Details about a container resource related to a finding.
        public let container: ContainerDetails?
        /// Details about a resource that are not available in a type-specific details object. Use the Other object in the following cases.   The type-specific object does not contain all of the fields that you want to populate. In this case, first use the type-specific object to populate those fields. Use the Other object to populate the fields that are missing from the type-specific object.   The resource type does not have a corresponding object. This includes resources for which the type is Other.
        public let other: [String: String]?

        public init(awsApiGatewayRestApi: AwsApiGatewayRestApiDetails? = nil, awsApiGatewayStage: AwsApiGatewayStageDetails? = nil, awsApiGatewayV2Api: AwsApiGatewayV2ApiDetails? = nil, awsApiGatewayV2Stage: AwsApiGatewayV2StageDetails? = nil, awsAutoScalingAutoScalingGroup: AwsAutoScalingAutoScalingGroupDetails? = nil, awsAutoScalingLaunchConfiguration: AwsAutoScalingLaunchConfigurationDetails? = nil, awsBackupBackupPlan: AwsBackupBackupPlanDetails? = nil, awsBackupBackupVault: AwsBackupBackupVaultDetails? = nil, awsBackupRecoveryPoint: AwsBackupRecoveryPointDetails? = nil, awsCertificateManagerCertificate: AwsCertificateManagerCertificateDetails? = nil, awsCloudFormationStack: AwsCloudFormationStackDetails? = nil, awsCloudFrontDistribution: AwsCloudFrontDistributionDetails? = nil, awsCloudTrailTrail: AwsCloudTrailTrailDetails? = nil, awsCloudWatchAlarm: AwsCloudWatchAlarmDetails? = nil, awsCodeBuildProject: AwsCodeBuildProjectDetails? = nil, awsDynamoDbTable: AwsDynamoDbTableDetails? = nil, awsEc2Eip: AwsEc2EipDetails? = nil, awsEc2Instance: AwsEc2InstanceDetails? = nil, awsEc2LaunchTemplate: AwsEc2LaunchTemplateDetails? = nil, awsEc2NetworkAcl: AwsEc2NetworkAclDetails? = nil, awsEc2NetworkInterface: AwsEc2NetworkInterfaceDetails? = nil, awsEc2SecurityGroup: AwsEc2SecurityGroupDetails? = nil, awsEc2Subnet: AwsEc2SubnetDetails? = nil, awsEc2TransitGateway: AwsEc2TransitGatewayDetails? = nil, awsEc2Volume: AwsEc2VolumeDetails? = nil, awsEc2Vpc: AwsEc2VpcDetails? = nil, awsEc2VpcEndpointService: AwsEc2VpcEndpointServiceDetails? = nil, awsEc2VpcPeeringConnection: AwsEc2VpcPeeringConnectionDetails? = nil, awsEc2VpnConnection: AwsEc2VpnConnectionDetails? = nil, awsEcrContainerImage: AwsEcrContainerImageDetails? = nil, awsEcrRepository: AwsEcrRepositoryDetails? = nil, awsEcsCluster: AwsEcsClusterDetails? = nil, awsEcsContainer: AwsEcsContainerDetails? = nil, awsEcsService: AwsEcsServiceDetails? = nil, awsEcsTask: AwsEcsTaskDetails? = nil, awsEcsTaskDefinition: AwsEcsTaskDefinitionDetails? = nil, awsEfsAccessPoint: AwsEfsAccessPointDetails? = nil, awsEksCluster: AwsEksClusterDetails? = nil, awsElasticBeanstalkEnvironment: AwsElasticBeanstalkEnvironmentDetails? = nil, awsElasticsearchDomain: AwsElasticsearchDomainDetails? = nil, awsElbLoadBalancer: AwsElbLoadBalancerDetails? = nil, awsElbv2LoadBalancer: AwsElbv2LoadBalancerDetails? = nil, awsIamAccessKey: AwsIamAccessKeyDetails? = nil, awsIamGroup: AwsIamGroupDetails? = nil, awsIamPolicy: AwsIamPolicyDetails? = nil, awsIamRole: AwsIamRoleDetails? = nil, awsIamUser: AwsIamUserDetails? = nil, awsKinesisStream: AwsKinesisStreamDetails? = nil, awsKmsKey: AwsKmsKeyDetails? = nil, awsLambdaFunction: AwsLambdaFunctionDetails? = nil, awsLambdaLayerVersion: AwsLambdaLayerVersionDetails? = nil, awsNetworkFirewallFirewall: AwsNetworkFirewallFirewallDetails? = nil, awsNetworkFirewallFirewallPolicy: AwsNetworkFirewallFirewallPolicyDetails? = nil, awsNetworkFirewallRuleGroup: AwsNetworkFirewallRuleGroupDetails? = nil, awsOpenSearchServiceDomain: AwsOpenSearchServiceDomainDetails? = nil, awsRdsDbCluster: AwsRdsDbClusterDetails? = nil, awsRdsDbClusterSnapshot: AwsRdsDbClusterSnapshotDetails? = nil, awsRdsDbInstance: AwsRdsDbInstanceDetails? = nil, awsRdsDbSecurityGroup: AwsRdsDbSecurityGroupDetails? = nil, awsRdsDbSnapshot: AwsRdsDbSnapshotDetails? = nil, awsRdsEventSubscription: AwsRdsEventSubscriptionDetails? = nil, awsRedshiftCluster: AwsRedshiftClusterDetails? = nil, awsS3AccountPublicAccessBlock: AwsS3AccountPublicAccessBlockDetails? = nil, awsS3Bucket: AwsS3BucketDetails? = nil, awsS3Object: AwsS3ObjectDetails? = nil, awsSageMakerNotebookInstance: AwsSageMakerNotebookInstanceDetails? = nil, awsSecretsManagerSecret: AwsSecretsManagerSecretDetails? = nil, awsSnsTopic: AwsSnsTopicDetails? = nil, awsSqsQueue: AwsSqsQueueDetails? = nil, awsSsmPatchCompliance: AwsSsmPatchComplianceDetails? = nil, awsWafRateBasedRule: AwsWafRateBasedRuleDetails? = nil, awsWafRegionalRateBasedRule: AwsWafRegionalRateBasedRuleDetails? = nil, awsWafRegionalRule: AwsWafRegionalRuleDetails? = nil, awsWafRegionalRuleGroup: AwsWafRegionalRuleGroupDetails? = nil, awsWafRegionalWebAcl: AwsWafRegionalWebAclDetails? = nil, awsWafRule: AwsWafRuleDetails? = nil, awsWafRuleGroup: AwsWafRuleGroupDetails? = nil, awsWafv2RuleGroup: AwsWafv2RuleGroupDetails? = nil, awsWafv2WebAcl: AwsWafv2WebAclDetails? = nil, awsWafWebAcl: AwsWafWebAclDetails? = nil, awsXrayEncryptionConfig: AwsXrayEncryptionConfigDetails? = nil, container: ContainerDetails? = nil, other: [String: String]? = nil) {
            self.awsApiGatewayRestApi = awsApiGatewayRestApi
            self.awsApiGatewayStage = awsApiGatewayStage
            self.awsApiGatewayV2Api = awsApiGatewayV2Api
            self.awsApiGatewayV2Stage = awsApiGatewayV2Stage
            self.awsAutoScalingAutoScalingGroup = awsAutoScalingAutoScalingGroup
            self.awsAutoScalingLaunchConfiguration = awsAutoScalingLaunchConfiguration
            self.awsBackupBackupPlan = awsBackupBackupPlan
            self.awsBackupBackupVault = awsBackupBackupVault
            self.awsBackupRecoveryPoint = awsBackupRecoveryPoint
            self.awsCertificateManagerCertificate = awsCertificateManagerCertificate
            self.awsCloudFormationStack = awsCloudFormationStack
            self.awsCloudFrontDistribution = awsCloudFrontDistribution
            self.awsCloudTrailTrail = awsCloudTrailTrail
            self.awsCloudWatchAlarm = awsCloudWatchAlarm
            self.awsCodeBuildProject = awsCodeBuildProject
            self.awsDynamoDbTable = awsDynamoDbTable
            self.awsEc2Eip = awsEc2Eip
            self.awsEc2Instance = awsEc2Instance
            self.awsEc2LaunchTemplate = awsEc2LaunchTemplate
            self.awsEc2NetworkAcl = awsEc2NetworkAcl
            self.awsEc2NetworkInterface = awsEc2NetworkInterface
            self.awsEc2SecurityGroup = awsEc2SecurityGroup
            self.awsEc2Subnet = awsEc2Subnet
            self.awsEc2TransitGateway = awsEc2TransitGateway
            self.awsEc2Volume = awsEc2Volume
            self.awsEc2Vpc = awsEc2Vpc
            self.awsEc2VpcEndpointService = awsEc2VpcEndpointService
            self.awsEc2VpcPeeringConnection = awsEc2VpcPeeringConnection
            self.awsEc2VpnConnection = awsEc2VpnConnection
            self.awsEcrContainerImage = awsEcrContainerImage
            self.awsEcrRepository = awsEcrRepository
            self.awsEcsCluster = awsEcsCluster
            self.awsEcsContainer = awsEcsContainer
            self.awsEcsService = awsEcsService
            self.awsEcsTask = awsEcsTask
            self.awsEcsTaskDefinition = awsEcsTaskDefinition
            self.awsEfsAccessPoint = awsEfsAccessPoint
            self.awsEksCluster = awsEksCluster
            self.awsElasticBeanstalkEnvironment = awsElasticBeanstalkEnvironment
            self.awsElasticsearchDomain = awsElasticsearchDomain
            self.awsElbLoadBalancer = awsElbLoadBalancer
            self.awsElbv2LoadBalancer = awsElbv2LoadBalancer
            self.awsIamAccessKey = awsIamAccessKey
            self.awsIamGroup = awsIamGroup
            self.awsIamPolicy = awsIamPolicy
            self.awsIamRole = awsIamRole
            self.awsIamUser = awsIamUser
            self.awsKinesisStream = awsKinesisStream
            self.awsKmsKey = awsKmsKey
            self.awsLambdaFunction = awsLambdaFunction
            self.awsLambdaLayerVersion = awsLambdaLayerVersion
            self.awsNetworkFirewallFirewall = awsNetworkFirewallFirewall
            self.awsNetworkFirewallFirewallPolicy = awsNetworkFirewallFirewallPolicy
            self.awsNetworkFirewallRuleGroup = awsNetworkFirewallRuleGroup
            self.awsOpenSearchServiceDomain = awsOpenSearchServiceDomain
            self.awsRdsDbCluster = awsRdsDbCluster
            self.awsRdsDbClusterSnapshot = awsRdsDbClusterSnapshot
            self.awsRdsDbInstance = awsRdsDbInstance
            self.awsRdsDbSecurityGroup = awsRdsDbSecurityGroup
            self.awsRdsDbSnapshot = awsRdsDbSnapshot
            self.awsRdsEventSubscription = awsRdsEventSubscription
            self.awsRedshiftCluster = awsRedshiftCluster
            self.awsS3AccountPublicAccessBlock = awsS3AccountPublicAccessBlock
            self.awsS3Bucket = awsS3Bucket
            self.awsS3Object = awsS3Object
            self.awsSageMakerNotebookInstance = awsSageMakerNotebookInstance
            self.awsSecretsManagerSecret = awsSecretsManagerSecret
            self.awsSnsTopic = awsSnsTopic
            self.awsSqsQueue = awsSqsQueue
            self.awsSsmPatchCompliance = awsSsmPatchCompliance
            self.awsWafRateBasedRule = awsWafRateBasedRule
            self.awsWafRegionalRateBasedRule = awsWafRegionalRateBasedRule
            self.awsWafRegionalRule = awsWafRegionalRule
            self.awsWafRegionalRuleGroup = awsWafRegionalRuleGroup
            self.awsWafRegionalWebAcl = awsWafRegionalWebAcl
            self.awsWafRule = awsWafRule
            self.awsWafRuleGroup = awsWafRuleGroup
            self.awsWafv2RuleGroup = awsWafv2RuleGroup
            self.awsWafv2WebAcl = awsWafv2WebAcl
            self.awsWafWebAcl = awsWafWebAcl
            self.awsXrayEncryptionConfig = awsXrayEncryptionConfig
            self.container = container
            self.other = other
        }

        public func validate(name: String) throws {
            try self.awsApiGatewayRestApi?.validate(name: "\(name).awsApiGatewayRestApi")
            try self.awsApiGatewayStage?.validate(name: "\(name).awsApiGatewayStage")
            try self.awsApiGatewayV2Api?.validate(name: "\(name).awsApiGatewayV2Api")
            try self.awsApiGatewayV2Stage?.validate(name: "\(name).awsApiGatewayV2Stage")
            try self.awsAutoScalingAutoScalingGroup?.validate(name: "\(name).awsAutoScalingAutoScalingGroup")
            try self.awsAutoScalingLaunchConfiguration?.validate(name: "\(name).awsAutoScalingLaunchConfiguration")
            try self.awsBackupBackupPlan?.validate(name: "\(name).awsBackupBackupPlan")
            try self.awsBackupBackupVault?.validate(name: "\(name).awsBackupBackupVault")
            try self.awsBackupRecoveryPoint?.validate(name: "\(name).awsBackupRecoveryPoint")
            try self.awsCertificateManagerCertificate?.validate(name: "\(name).awsCertificateManagerCertificate")
            try self.awsCloudFormationStack?.validate(name: "\(name).awsCloudFormationStack")
            try self.awsCloudFrontDistribution?.validate(name: "\(name).awsCloudFrontDistribution")
            try self.awsCloudTrailTrail?.validate(name: "\(name).awsCloudTrailTrail")
            try self.awsCloudWatchAlarm?.validate(name: "\(name).awsCloudWatchAlarm")
            try self.awsCodeBuildProject?.validate(name: "\(name).awsCodeBuildProject")
            try self.awsDynamoDbTable?.validate(name: "\(name).awsDynamoDbTable")
            try self.awsEc2Eip?.validate(name: "\(name).awsEc2Eip")
            try self.awsEc2Instance?.validate(name: "\(name).awsEc2Instance")
            try self.awsEc2LaunchTemplate?.validate(name: "\(name).awsEc2LaunchTemplate")
            try self.awsEc2NetworkAcl?.validate(name: "\(name).awsEc2NetworkAcl")
            try self.awsEc2NetworkInterface?.validate(name: "\(name).awsEc2NetworkInterface")
            try self.awsEc2SecurityGroup?.validate(name: "\(name).awsEc2SecurityGroup")
            try self.awsEc2Subnet?.validate(name: "\(name).awsEc2Subnet")
            try self.awsEc2TransitGateway?.validate(name: "\(name).awsEc2TransitGateway")
            try self.awsEc2Volume?.validate(name: "\(name).awsEc2Volume")
            try self.awsEc2Vpc?.validate(name: "\(name).awsEc2Vpc")
            try self.awsEc2VpcEndpointService?.validate(name: "\(name).awsEc2VpcEndpointService")
            try self.awsEc2VpcPeeringConnection?.validate(name: "\(name).awsEc2VpcPeeringConnection")
            try self.awsEc2VpnConnection?.validate(name: "\(name).awsEc2VpnConnection")
            try self.awsEcrContainerImage?.validate(name: "\(name).awsEcrContainerImage")
            try self.awsEcrRepository?.validate(name: "\(name).awsEcrRepository")
            try self.awsEcsCluster?.validate(name: "\(name).awsEcsCluster")
            try self.awsEcsContainer?.validate(name: "\(name).awsEcsContainer")
            try self.awsEcsService?.validate(name: "\(name).awsEcsService")
            try self.awsEcsTask?.validate(name: "\(name).awsEcsTask")
            try self.awsEcsTaskDefinition?.validate(name: "\(name).awsEcsTaskDefinition")
            try self.awsEfsAccessPoint?.validate(name: "\(name).awsEfsAccessPoint")
            try self.awsEksCluster?.validate(name: "\(name).awsEksCluster")
            try self.awsElasticBeanstalkEnvironment?.validate(name: "\(name).awsElasticBeanstalkEnvironment")
            try self.awsElasticsearchDomain?.validate(name: "\(name).awsElasticsearchDomain")
            try self.awsElbLoadBalancer?.validate(name: "\(name).awsElbLoadBalancer")
            try self.awsElbv2LoadBalancer?.validate(name: "\(name).awsElbv2LoadBalancer")
            try self.awsIamAccessKey?.validate(name: "\(name).awsIamAccessKey")
            try self.awsIamGroup?.validate(name: "\(name).awsIamGroup")
            try self.awsIamPolicy?.validate(name: "\(name).awsIamPolicy")
            try self.awsIamRole?.validate(name: "\(name).awsIamRole")
            try self.awsIamUser?.validate(name: "\(name).awsIamUser")
            try self.awsKinesisStream?.validate(name: "\(name).awsKinesisStream")
            try self.awsKmsKey?.validate(name: "\(name).awsKmsKey")
            try self.awsLambdaFunction?.validate(name: "\(name).awsLambdaFunction")
            try self.awsLambdaLayerVersion?.validate(name: "\(name).awsLambdaLayerVersion")
            try self.awsNetworkFirewallFirewall?.validate(name: "\(name).awsNetworkFirewallFirewall")
            try self.awsNetworkFirewallFirewallPolicy?.validate(name: "\(name).awsNetworkFirewallFirewallPolicy")
            try self.awsNetworkFirewallRuleGroup?.validate(name: "\(name).awsNetworkFirewallRuleGroup")
            try self.awsOpenSearchServiceDomain?.validate(name: "\(name).awsOpenSearchServiceDomain")
            try self.awsRdsDbCluster?.validate(name: "\(name).awsRdsDbCluster")
            try self.awsRdsDbClusterSnapshot?.validate(name: "\(name).awsRdsDbClusterSnapshot")
            try self.awsRdsDbInstance?.validate(name: "\(name).awsRdsDbInstance")
            try self.awsRdsDbSecurityGroup?.validate(name: "\(name).awsRdsDbSecurityGroup")
            try self.awsRdsDbSnapshot?.validate(name: "\(name).awsRdsDbSnapshot")
            try self.awsRdsEventSubscription?.validate(name: "\(name).awsRdsEventSubscription")
            try self.awsRedshiftCluster?.validate(name: "\(name).awsRedshiftCluster")
            try self.awsS3Bucket?.validate(name: "\(name).awsS3Bucket")
            try self.awsS3Object?.validate(name: "\(name).awsS3Object")
            try self.awsSageMakerNotebookInstance?.validate(name: "\(name).awsSageMakerNotebookInstance")
            try self.awsSecretsManagerSecret?.validate(name: "\(name).awsSecretsManagerSecret")
            try self.awsSnsTopic?.validate(name: "\(name).awsSnsTopic")
            try self.awsSqsQueue?.validate(name: "\(name).awsSqsQueue")
            try self.awsSsmPatchCompliance?.validate(name: "\(name).awsSsmPatchCompliance")
            try self.awsWafRateBasedRule?.validate(name: "\(name).awsWafRateBasedRule")
            try self.awsWafRegionalRateBasedRule?.validate(name: "\(name).awsWafRegionalRateBasedRule")
            try self.awsWafRegionalRule?.validate(name: "\(name).awsWafRegionalRule")
            try self.awsWafRegionalRuleGroup?.validate(name: "\(name).awsWafRegionalRuleGroup")
            try self.awsWafRegionalWebAcl?.validate(name: "\(name).awsWafRegionalWebAcl")
            try self.awsWafRule?.validate(name: "\(name).awsWafRule")
            try self.awsWafRuleGroup?.validate(name: "\(name).awsWafRuleGroup")
            try self.awsWafv2RuleGroup?.validate(name: "\(name).awsWafv2RuleGroup")
            try self.awsWafv2WebAcl?.validate(name: "\(name).awsWafv2WebAcl")
            try self.awsWafWebAcl?.validate(name: "\(name).awsWafWebAcl")
            try self.awsXrayEncryptionConfig?.validate(name: "\(name).awsXrayEncryptionConfig")
            try self.container?.validate(name: "\(name).container")
            try self.other?.forEach {
                try validate($0.key, name: "other.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "other[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsApiGatewayRestApi = "AwsApiGatewayRestApi"
            case awsApiGatewayStage = "AwsApiGatewayStage"
            case awsApiGatewayV2Api = "AwsApiGatewayV2Api"
            case awsApiGatewayV2Stage = "AwsApiGatewayV2Stage"
            case awsAutoScalingAutoScalingGroup = "AwsAutoScalingAutoScalingGroup"
            case awsAutoScalingLaunchConfiguration = "AwsAutoScalingLaunchConfiguration"
            case awsBackupBackupPlan = "AwsBackupBackupPlan"
            case awsBackupBackupVault = "AwsBackupBackupVault"
            case awsBackupRecoveryPoint = "AwsBackupRecoveryPoint"
            case awsCertificateManagerCertificate = "AwsCertificateManagerCertificate"
            case awsCloudFormationStack = "AwsCloudFormationStack"
            case awsCloudFrontDistribution = "AwsCloudFrontDistribution"
            case awsCloudTrailTrail = "AwsCloudTrailTrail"
            case awsCloudWatchAlarm = "AwsCloudWatchAlarm"
            case awsCodeBuildProject = "AwsCodeBuildProject"
            case awsDynamoDbTable = "AwsDynamoDbTable"
            case awsEc2Eip = "AwsEc2Eip"
            case awsEc2Instance = "AwsEc2Instance"
            case awsEc2LaunchTemplate = "AwsEc2LaunchTemplate"
            case awsEc2NetworkAcl = "AwsEc2NetworkAcl"
            case awsEc2NetworkInterface = "AwsEc2NetworkInterface"
            case awsEc2SecurityGroup = "AwsEc2SecurityGroup"
            case awsEc2Subnet = "AwsEc2Subnet"
            case awsEc2TransitGateway = "AwsEc2TransitGateway"
            case awsEc2Volume = "AwsEc2Volume"
            case awsEc2Vpc = "AwsEc2Vpc"
            case awsEc2VpcEndpointService = "AwsEc2VpcEndpointService"
            case awsEc2VpcPeeringConnection = "AwsEc2VpcPeeringConnection"
            case awsEc2VpnConnection = "AwsEc2VpnConnection"
            case awsEcrContainerImage = "AwsEcrContainerImage"
            case awsEcrRepository = "AwsEcrRepository"
            case awsEcsCluster = "AwsEcsCluster"
            case awsEcsContainer = "AwsEcsContainer"
            case awsEcsService = "AwsEcsService"
            case awsEcsTask = "AwsEcsTask"
            case awsEcsTaskDefinition = "AwsEcsTaskDefinition"
            case awsEfsAccessPoint = "AwsEfsAccessPoint"
            case awsEksCluster = "AwsEksCluster"
            case awsElasticBeanstalkEnvironment = "AwsElasticBeanstalkEnvironment"
            case awsElasticsearchDomain = "AwsElasticsearchDomain"
            case awsElbLoadBalancer = "AwsElbLoadBalancer"
            case awsElbv2LoadBalancer = "AwsElbv2LoadBalancer"
            case awsIamAccessKey = "AwsIamAccessKey"
            case awsIamGroup = "AwsIamGroup"
            case awsIamPolicy = "AwsIamPolicy"
            case awsIamRole = "AwsIamRole"
            case awsIamUser = "AwsIamUser"
            case awsKinesisStream = "AwsKinesisStream"
            case awsKmsKey = "AwsKmsKey"
            case awsLambdaFunction = "AwsLambdaFunction"
            case awsLambdaLayerVersion = "AwsLambdaLayerVersion"
            case awsNetworkFirewallFirewall = "AwsNetworkFirewallFirewall"
            case awsNetworkFirewallFirewallPolicy = "AwsNetworkFirewallFirewallPolicy"
            case awsNetworkFirewallRuleGroup = "AwsNetworkFirewallRuleGroup"
            case awsOpenSearchServiceDomain = "AwsOpenSearchServiceDomain"
            case awsRdsDbCluster = "AwsRdsDbCluster"
            case awsRdsDbClusterSnapshot = "AwsRdsDbClusterSnapshot"
            case awsRdsDbInstance = "AwsRdsDbInstance"
            case awsRdsDbSecurityGroup = "AwsRdsDbSecurityGroup"
            case awsRdsDbSnapshot = "AwsRdsDbSnapshot"
            case awsRdsEventSubscription = "AwsRdsEventSubscription"
            case awsRedshiftCluster = "AwsRedshiftCluster"
            case awsS3AccountPublicAccessBlock = "AwsS3AccountPublicAccessBlock"
            case awsS3Bucket = "AwsS3Bucket"
            case awsS3Object = "AwsS3Object"
            case awsSageMakerNotebookInstance = "AwsSageMakerNotebookInstance"
            case awsSecretsManagerSecret = "AwsSecretsManagerSecret"
            case awsSnsTopic = "AwsSnsTopic"
            case awsSqsQueue = "AwsSqsQueue"
            case awsSsmPatchCompliance = "AwsSsmPatchCompliance"
            case awsWafRateBasedRule = "AwsWafRateBasedRule"
            case awsWafRegionalRateBasedRule = "AwsWafRegionalRateBasedRule"
            case awsWafRegionalRule = "AwsWafRegionalRule"
            case awsWafRegionalRuleGroup = "AwsWafRegionalRuleGroup"
            case awsWafRegionalWebAcl = "AwsWafRegionalWebAcl"
            case awsWafRule = "AwsWafRule"
            case awsWafRuleGroup = "AwsWafRuleGroup"
            case awsWafv2RuleGroup = "AwsWafv2RuleGroup"
            case awsWafv2WebAcl = "AwsWafv2WebAcl"
            case awsWafWebAcl = "AwsWafWebAcl"
            case awsXrayEncryptionConfig = "AwsXrayEncryptionConfig"
            case container = "Container"
            case other = "Other"
        }
    }

    public struct Result: AWSDecodableShape {
        /// An Amazon Web Services account ID of the account that was not processed.
        public let accountId: String?
        /// The reason that the account was not processed.
        public let processingResult: String?

        public init(accountId: String? = nil, processingResult: String? = nil) {
            self.accountId = accountId
            self.processingResult = processingResult
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case processingResult = "ProcessingResult"
        }
    }

    public struct RuleGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The rules and actions for the rule group. For stateful rule groups, can contain RulesString, RulesSourceList, or StatefulRules. For stateless rule groups, contains StatelessRulesAndCustomActions.
        public let rulesSource: RuleGroupSource?
        /// Additional settings to use in the specified rules.
        public let ruleVariables: RuleGroupVariables?

        public init(rulesSource: RuleGroupSource? = nil, ruleVariables: RuleGroupVariables? = nil) {
            self.rulesSource = rulesSource
            self.ruleVariables = ruleVariables
        }

        public func validate(name: String) throws {
            try self.rulesSource?.validate(name: "\(name).rulesSource")
            try self.ruleVariables?.validate(name: "\(name).ruleVariables")
        }

        private enum CodingKeys: String, CodingKey {
            case rulesSource = "RulesSource"
            case ruleVariables = "RuleVariables"
        }
    }

    public struct RuleGroupSource: AWSEncodableShape & AWSDecodableShape {
        /// Stateful inspection criteria for a domain list rule group. A domain list rule group determines access by specific protocols to specific domains.
        public let rulesSourceList: RuleGroupSourceListDetails?
        /// Stateful inspection criteria, provided in Suricata compatible intrusion prevention system (IPS) rules.
        public let rulesString: String?
        /// Suricata rule specifications.
        public let statefulRules: [RuleGroupSourceStatefulRulesDetails]?
        /// The stateless rules and custom actions used by a stateless rule group.
        public let statelessRulesAndCustomActions: RuleGroupSourceStatelessRulesAndCustomActionsDetails?

        public init(rulesSourceList: RuleGroupSourceListDetails? = nil, rulesString: String? = nil, statefulRules: [RuleGroupSourceStatefulRulesDetails]? = nil, statelessRulesAndCustomActions: RuleGroupSourceStatelessRulesAndCustomActionsDetails? = nil) {
            self.rulesSourceList = rulesSourceList
            self.rulesString = rulesString
            self.statefulRules = statefulRules
            self.statelessRulesAndCustomActions = statelessRulesAndCustomActions
        }

        public func validate(name: String) throws {
            try self.rulesSourceList?.validate(name: "\(name).rulesSourceList")
            try self.validate(self.rulesString, name: "rulesString", parent: name, pattern: "\\S")
            try self.statefulRules?.forEach {
                try $0.validate(name: "\(name).statefulRules[]")
            }
            try self.statelessRulesAndCustomActions?.validate(name: "\(name).statelessRulesAndCustomActions")
        }

        private enum CodingKeys: String, CodingKey {
            case rulesSourceList = "RulesSourceList"
            case rulesString = "RulesString"
            case statefulRules = "StatefulRules"
            case statelessRulesAndCustomActions = "StatelessRulesAndCustomActions"
        }
    }

    public struct RuleGroupSourceCustomActionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The definition of a custom action.
        public let actionDefinition: StatelessCustomActionDefinition?
        /// A descriptive name of the custom action.
        public let actionName: String?

        public init(actionDefinition: StatelessCustomActionDefinition? = nil, actionName: String? = nil) {
            self.actionDefinition = actionDefinition
            self.actionName = actionName
        }

        public func validate(name: String) throws {
            try self.actionDefinition?.validate(name: "\(name).actionDefinition")
            try self.validate(self.actionName, name: "actionName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinition = "ActionDefinition"
            case actionName = "ActionName"
        }
    }

    public struct RuleGroupSourceListDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether to allow or deny access to the domains listed in Targets.
        public let generatedRulesType: String?
        /// The domains that you want to inspect for in your traffic flows. You can provide full domain names, or use the '.' prefix as a wildcard. For example, .example.com matches all domains that end with example.com.
        public let targets: [String]?
        /// The protocols that you want to inspect. Specify LS_SNI for HTTPS. Specify HTTP_HOST for HTTP. You can specify either or both.
        public let targetTypes: [String]?

        public init(generatedRulesType: String? = nil, targets: [String]? = nil, targetTypes: [String]? = nil) {
            self.generatedRulesType = generatedRulesType
            self.targets = targets
            self.targetTypes = targetTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.generatedRulesType, name: "generatedRulesType", parent: name, pattern: "\\S")
            try self.targets?.forEach {
                try validate($0, name: "targets[]", parent: name, pattern: "\\S")
            }
            try self.targetTypes?.forEach {
                try validate($0, name: "targetTypes[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case generatedRulesType = "GeneratedRulesType"
            case targets = "Targets"
            case targetTypes = "TargetTypes"
        }
    }

    public struct RuleGroupSourceStatefulRulesDetails: AWSEncodableShape & AWSDecodableShape {
        /// Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria.
        public let action: String?
        /// The stateful inspection criteria for the rule.
        public let header: RuleGroupSourceStatefulRulesHeaderDetails?
        /// Additional options for the rule.
        public let ruleOptions: [RuleGroupSourceStatefulRulesOptionsDetails]?

        public init(action: String? = nil, header: RuleGroupSourceStatefulRulesHeaderDetails? = nil, ruleOptions: [RuleGroupSourceStatefulRulesOptionsDetails]? = nil) {
            self.action = action
            self.header = header
            self.ruleOptions = ruleOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.action, name: "action", parent: name, pattern: "\\S")
            try self.header?.validate(name: "\(name).header")
            try self.ruleOptions?.forEach {
                try $0.validate(name: "\(name).ruleOptions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case header = "Header"
            case ruleOptions = "RuleOptions"
        }
    }

    public struct RuleGroupSourceStatefulRulesHeaderDetails: AWSEncodableShape & AWSDecodableShape {
        /// The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify ANY.
        public let destination: String?
        /// The destination port to inspect for. You can specify an individual port, such as 1994. You also can specify a port range, such as 1990:1994. To match with any port, specify ANY.
        public let destinationPort: String?
        /// The direction of traffic flow to inspect. If set to ANY, the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to FORWARD, the inspection only matches traffic going from the source to the destination.
        public let direction: String?
        /// The protocol to inspect for. To inspector for all protocols, use IP.
        public let `protocol`: String?
        /// The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify ANY.
        public let source: String?
        /// The source port to inspect for. You can specify an individual port, such as 1994. You also can specify a port range, such as 1990:1994. To match with any port, specify ANY.
        public let sourcePort: String?

        public init(destination: String? = nil, destinationPort: String? = nil, direction: String? = nil, protocol: String? = nil, source: String? = nil, sourcePort: String? = nil) {
            self.destination = destination
            self.destinationPort = destinationPort
            self.direction = direction
            self.`protocol` = `protocol`
            self.source = source
            self.sourcePort = sourcePort
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, pattern: "\\S")
            try self.validate(self.destinationPort, name: "destinationPort", parent: name, pattern: "\\S")
            try self.validate(self.direction, name: "direction", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.validate(self.source, name: "source", parent: name, pattern: "\\S")
            try self.validate(self.sourcePort, name: "sourcePort", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case destinationPort = "DestinationPort"
            case direction = "Direction"
            case `protocol` = "Protocol"
            case source = "Source"
            case sourcePort = "SourcePort"
        }
    }

    public struct RuleGroupSourceStatefulRulesOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// A keyword to look for.
        public let keyword: String?
        /// A list of settings.
        public let settings: [String]?

        public init(keyword: String? = nil, settings: [String]? = nil) {
            self.keyword = keyword
            self.settings = settings
        }

        public func validate(name: String) throws {
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "\\S")
            try self.settings?.forEach {
                try validate($0, name: "settings[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case settings = "Settings"
        }
    }

    public struct RuleGroupSourceStatelessRuleDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action (aws:pass, aws:drop, or aws:forward_to_sfe). You can then add custom actions.
        public let actions: [String]?
        /// The criteria for Network Firewall to use to inspect an individual packet in a stateless rule inspection.
        public let matchAttributes: RuleGroupSourceStatelessRuleMatchAttributes?

        public init(actions: [String]? = nil, matchAttributes: RuleGroupSourceStatelessRuleMatchAttributes? = nil) {
            self.actions = actions
            self.matchAttributes = matchAttributes
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try validate($0, name: "actions[]", parent: name, pattern: "\\S")
            }
            try self.matchAttributes?.validate(name: "\(name).matchAttributes")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case matchAttributes = "MatchAttributes"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributes: AWSEncodableShape & AWSDecodableShape {
        /// A list of port ranges to specify the destination ports to inspect for.
        public let destinationPorts: [RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts]?
        /// The destination IP addresses and address ranges to inspect for, in CIDR notation.
        public let destinations: [RuleGroupSourceStatelessRuleMatchAttributesDestinations]?
        /// The protocols to inspect for.
        public let protocols: [Int]?
        /// A list of port ranges to specify the source ports to inspect for.
        public let sourcePorts: [RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]?
        /// The source IP addresses and address ranges to inspect for, in CIDR notation.
        public let sources: [RuleGroupSourceStatelessRuleMatchAttributesSources]?
        /// The TCP flags and masks to inspect for.
        public let tcpFlags: [RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]?

        public init(destinationPorts: [RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts]? = nil, destinations: [RuleGroupSourceStatelessRuleMatchAttributesDestinations]? = nil, protocols: [Int]? = nil, sourcePorts: [RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]? = nil, sources: [RuleGroupSourceStatelessRuleMatchAttributesSources]? = nil, tcpFlags: [RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]? = nil) {
            self.destinationPorts = destinationPorts
            self.destinations = destinations
            self.protocols = protocols
            self.sourcePorts = sourcePorts
            self.sources = sources
            self.tcpFlags = tcpFlags
        }

        public func validate(name: String) throws {
            try self.destinations?.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.sources?.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.tcpFlags?.forEach {
                try $0.validate(name: "\(name).tcpFlags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case destinationPorts = "DestinationPorts"
            case destinations = "Destinations"
            case protocols = "Protocols"
            case sourcePorts = "SourcePorts"
            case sources = "Sources"
            case tcpFlags = "TcpFlags"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts: AWSEncodableShape & AWSDecodableShape {
        /// The starting port value for the port range.
        public let fromPort: Int?
        /// The ending port value for the port range.
        public let toPort: Int?

        public init(fromPort: Int? = nil, toPort: Int? = nil) {
            self.fromPort = fromPort
            self.toPort = toPort
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case toPort = "ToPort"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributesDestinations: AWSEncodableShape & AWSDecodableShape {
        /// An IP address or a block of IP addresses.
        public let addressDefinition: String?

        public init(addressDefinition: String? = nil) {
            self.addressDefinition = addressDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.addressDefinition, name: "addressDefinition", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case addressDefinition = "AddressDefinition"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributesSourcePorts: AWSEncodableShape & AWSDecodableShape {
        /// The starting port value for the port range.
        public let fromPort: Int?
        /// The ending port value for the port range.
        public let toPort: Int?

        public init(fromPort: Int? = nil, toPort: Int? = nil) {
            self.fromPort = fromPort
            self.toPort = toPort
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case toPort = "ToPort"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributesSources: AWSEncodableShape & AWSDecodableShape {
        /// An IP address or a block of IP addresses.
        public let addressDefinition: String?

        public init(addressDefinition: String? = nil) {
            self.addressDefinition = addressDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.addressDefinition, name: "addressDefinition", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case addressDefinition = "AddressDefinition"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributesTcpFlags: AWSEncodableShape & AWSDecodableShape {
        /// Defines the flags from the Masks setting that must be set in order for the packet to match. Flags that are listed must be set. Flags that are not listed must not be set.
        public let flags: [String]?
        /// The set of flags to consider in the inspection. If not specified, then all flags are inspected.
        public let masks: [String]?

        public init(flags: [String]? = nil, masks: [String]? = nil) {
            self.flags = flags
            self.masks = masks
        }

        public func validate(name: String) throws {
            try self.flags?.forEach {
                try validate($0, name: "flags[]", parent: name, pattern: "\\S")
            }
            try self.masks?.forEach {
                try validate($0, name: "masks[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case flags = "Flags"
            case masks = "Masks"
        }
    }

    public struct RuleGroupSourceStatelessRulesAndCustomActionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Custom actions for the rule group.
        public let customActions: [RuleGroupSourceCustomActionsDetails]?
        /// Stateless rules for the rule group.
        public let statelessRules: [RuleGroupSourceStatelessRulesDetails]?

        public init(customActions: [RuleGroupSourceCustomActionsDetails]? = nil, statelessRules: [RuleGroupSourceStatelessRulesDetails]? = nil) {
            self.customActions = customActions
            self.statelessRules = statelessRules
        }

        public func validate(name: String) throws {
            try self.customActions?.forEach {
                try $0.validate(name: "\(name).customActions[]")
            }
            try self.statelessRules?.forEach {
                try $0.validate(name: "\(name).statelessRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customActions = "CustomActions"
            case statelessRules = "StatelessRules"
        }
    }

    public struct RuleGroupSourceStatelessRulesDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the order in which to run this rule relative to all of the rules in the stateless rule group.
        public let priority: Int?
        /// Provides the definition of the stateless rule.
        public let ruleDefinition: RuleGroupSourceStatelessRuleDefinition?

        public init(priority: Int? = nil, ruleDefinition: RuleGroupSourceStatelessRuleDefinition? = nil) {
            self.priority = priority
            self.ruleDefinition = ruleDefinition
        }

        public func validate(name: String) throws {
            try self.ruleDefinition?.validate(name: "\(name).ruleDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case priority = "Priority"
            case ruleDefinition = "RuleDefinition"
        }
    }

    public struct RuleGroupVariables: AWSEncodableShape & AWSDecodableShape {
        /// A list of IP addresses and address ranges, in CIDR notation.
        public let ipSets: RuleGroupVariablesIpSetsDetails?
        /// A list of port ranges.
        public let portSets: RuleGroupVariablesPortSetsDetails?

        public init(ipSets: RuleGroupVariablesIpSetsDetails? = nil, portSets: RuleGroupVariablesPortSetsDetails? = nil) {
            self.ipSets = ipSets
            self.portSets = portSets
        }

        public func validate(name: String) throws {
            try self.ipSets?.validate(name: "\(name).ipSets")
            try self.portSets?.validate(name: "\(name).portSets")
        }

        private enum CodingKeys: String, CodingKey {
            case ipSets = "IpSets"
            case portSets = "PortSets"
        }
    }

    public struct RuleGroupVariablesIpSetsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The list of IP addresses and ranges.
        public let definition: [String]?

        public init(definition: [String]? = nil) {
            self.definition = definition
        }

        public func validate(name: String) throws {
            try self.definition?.forEach {
                try validate($0, name: "definition[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
        }
    }

    public struct RuleGroupVariablesPortSetsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The list of port ranges.
        public let definition: [String]?

        public init(definition: [String]? = nil) {
            self.definition = definition
        }

        public func validate(name: String) throws {
            try self.definition?.forEach {
                try validate($0, name: "definition[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
        }
    }

    public struct SensitiveDataDetections: AWSEncodableShape & AWSDecodableShape {
        /// The total number of occurrences of sensitive data that were detected.
        public let count: Int64?
        /// Details about the sensitive data that was detected.
        public let occurrences: Occurrences?
        /// The type of sensitive data that was detected. For example, the type might indicate that the data is an email address.
        public let type: String?

        public init(count: Int64? = nil, occurrences: Occurrences? = nil, type: String? = nil) {
            self.count = count
            self.occurrences = occurrences
            self.type = type
        }

        public func validate(name: String) throws {
            try self.occurrences?.validate(name: "\(name).occurrences")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case occurrences = "Occurrences"
            case type = "Type"
        }
    }

    public struct SensitiveDataResult: AWSEncodableShape & AWSDecodableShape {
        /// The category of sensitive data that was detected. For example, the category can indicate that the sensitive data involved credentials, financial information, or personal information.
        public let category: String?
        /// The list of detected instances of sensitive data.
        public let detections: [SensitiveDataDetections]?
        /// The total number of occurrences of sensitive data.
        public let totalCount: Int64?

        public init(category: String? = nil, detections: [SensitiveDataDetections]? = nil, totalCount: Int64? = nil) {
            self.category = category
            self.detections = detections
            self.totalCount = totalCount
        }

        public func validate(name: String) throws {
            try self.validate(self.category, name: "category", parent: name, pattern: "\\S")
            try self.detections?.forEach {
                try $0.validate(name: "\(name).detections[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case detections = "Detections"
            case totalCount = "TotalCount"
        }
    }

    public struct Severity: AWSEncodableShape & AWSDecodableShape {
        /// The severity value of the finding. The allowed values are the following.    INFORMATIONAL - No issue was found.    LOW - The issue does not require action on its own.    MEDIUM - The issue must be addressed but not urgently.    HIGH - The issue must be addressed as a priority.    CRITICAL - The issue must be remediated immediately to avoid it escalating.   If you provide Normalized and do not provide Label, then Label is set automatically as follows.    0 - INFORMATIONAL    139 - LOW    4069 - MEDIUM    7089 - HIGH    90100 - CRITICAL
        public let label: SeverityLabel?
        /// Deprecated. The normalized severity of a finding. This attribute is being deprecated. Instead of providing Normalized, provide Label. If you provide Label and do not provide Normalized, then Normalized is set automatically as follows.    INFORMATIONAL - 0    LOW - 1    MEDIUM - 40    HIGH - 70    CRITICAL - 90
        public let normalized: Int?
        /// The native severity from the finding product that generated the finding.
        public let original: String?
        /// Deprecated. This attribute is being deprecated. Instead of providing Product, provide Original. The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.
        public let product: Double?

        public init(label: SeverityLabel? = nil, normalized: Int? = nil, original: String? = nil, product: Double? = nil) {
            self.label = label
            self.normalized = normalized
            self.original = original
            self.product = product
        }

        public func validate(name: String) throws {
            try self.validate(self.original, name: "original", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case normalized = "Normalized"
            case original = "Original"
            case product = "Product"
        }
    }

    public struct SeverityUpdate: AWSEncodableShape {
        /// The severity value of the finding. The allowed values are the following.    INFORMATIONAL - No issue was found.    LOW - The issue does not require action on its own.    MEDIUM - The issue must be addressed but not urgently.    HIGH - The issue must be addressed as a priority.    CRITICAL - The issue must be remediated immediately to avoid it escalating.
        public let label: SeverityLabel?
        /// The normalized severity for the finding. This attribute is to be deprecated in favor of Label. If you provide Normalized and do not provide Label, Label is set automatically as follows.   0 - INFORMATIONAL    139 - LOW    4069 - MEDIUM    7089 - HIGH    90100 - CRITICAL
        public let normalized: Int?
        /// The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.
        public let product: Double?

        public init(label: SeverityLabel? = nil, normalized: Int? = nil, product: Double? = nil) {
            self.label = label
            self.normalized = normalized
            self.product = product
        }

        public func validate(name: String) throws {
            try self.validate(self.normalized, name: "normalized", parent: name, max: 100)
            try self.validate(self.normalized, name: "normalized", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case normalized = "Normalized"
            case product = "Product"
        }
    }

    public struct SoftwarePackage: AWSEncodableShape & AWSDecodableShape {
        /// The architecture used for the software package.
        public let architecture: String?
        /// The epoch of the software package.
        public let epoch: String?
        /// The file system path to the package manager inventory file.
        public let filePath: String?
        /// The version of the software package in which the vulnerability has been resolved.
        public let fixedInVersion: String?
        /// The name of the software package.
        public let name: String?
        /// The source of the package.
        public let packageManager: String?
        /// The release of the software package.
        public let release: String?
        /// Describes the actions a customer can take to resolve the vulnerability in the software package.
        public let remediation: String?
        /// The Amazon Resource Name (ARN) of the source layer.
        public let sourceLayerArn: String?
        /// The source layer hash of the vulnerable package.
        public let sourceLayerHash: String?
        /// The version of the software package.
        public let version: String?

        public init(architecture: String? = nil, epoch: String? = nil, filePath: String? = nil, fixedInVersion: String? = nil, name: String? = nil, packageManager: String? = nil, release: String? = nil, remediation: String? = nil, sourceLayerArn: String? = nil, sourceLayerHash: String? = nil, version: String? = nil) {
            self.architecture = architecture
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLayerArn = sourceLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.architecture, name: "architecture", parent: name, pattern: "\\S")
            try self.validate(self.epoch, name: "epoch", parent: name, pattern: "\\S")
            try self.validate(self.filePath, name: "filePath", parent: name, pattern: "\\S")
            try self.validate(self.fixedInVersion, name: "fixedInVersion", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.packageManager, name: "packageManager", parent: name, pattern: "\\S")
            try self.validate(self.release, name: "release", parent: name, pattern: "\\S")
            try self.validate(self.remediation, name: "remediation", parent: name, pattern: "\\S")
            try self.validate(self.sourceLayerArn, name: "sourceLayerArn", parent: name, pattern: "\\S")
            try self.validate(self.sourceLayerHash, name: "sourceLayerHash", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "Architecture"
            case epoch = "Epoch"
            case filePath = "FilePath"
            case fixedInVersion = "FixedInVersion"
            case name = "Name"
            case packageManager = "PackageManager"
            case release = "Release"
            case remediation = "Remediation"
            case sourceLayerArn = "SourceLayerArn"
            case sourceLayerHash = "SourceLayerHash"
            case version = "Version"
        }
    }

    public struct SortCriterion: AWSEncodableShape {
        /// The finding attribute used to sort findings.
        public let field: String?
        /// The order used to sort findings.
        public let sortOrder: SortOrder?

        public init(field: String? = nil, sortOrder: SortOrder? = nil) {
            self.field = field
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.field, name: "field", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case field = "Field"
            case sortOrder = "SortOrder"
        }
    }

    public struct Standard: AWSDecodableShape {
        /// A description of the standard.
        public let description: String?
        /// Whether the standard is enabled by default. When Security Hub is enabled from the console, if a standard is enabled by default, the check box for that standard is selected by default. When Security Hub is enabled using the EnableSecurityHub API operation, the standard is enabled by default unless EnableDefaultStandards is set to false.
        public let enabledByDefault: Bool?
        /// The name of the standard.
        public let name: String?
        /// The ARN of a standard.
        public let standardsArn: String?
        /// Provides details about the management of a standard.
        public let standardsManagedBy: StandardsManagedBy?

        public init(description: String? = nil, enabledByDefault: Bool? = nil, name: String? = nil, standardsArn: String? = nil, standardsManagedBy: StandardsManagedBy? = nil) {
            self.description = description
            self.enabledByDefault = enabledByDefault
            self.name = name
            self.standardsArn = standardsArn
            self.standardsManagedBy = standardsManagedBy
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case enabledByDefault = "EnabledByDefault"
            case name = "Name"
            case standardsArn = "StandardsArn"
            case standardsManagedBy = "StandardsManagedBy"
        }
    }

    public struct StandardsControl: AWSDecodableShape {
        /// The identifier of the security standard control.
        public let controlId: String?
        /// The current status of the security standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.
        public let controlStatus: ControlStatus?
        /// The date and time that the status of the security standard control was most recently updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var controlStatusUpdatedAt: Date?
        /// The longer description of the security standard control. Provides information about what the control is checking for.
        public let description: String?
        /// The reason provided for the most recent change in status for the control.
        public let disabledReason: String?
        /// The list of requirements that are related to this control.
        public let relatedRequirements: [String]?
        /// A link to remediation information for the control in the Security Hub user documentation.
        public let remediationUrl: String?
        /// The severity of findings generated from this security standard control. The finding severity is based on an assessment of how easy it would be to compromise Amazon Web Services resources if the issue is detected.
        public let severityRating: SeverityRating?
        /// The ARN of the security standard control.
        public let standardsControlArn: String?
        /// The title of the security standard control.
        public let title: String?

        public init(controlId: String? = nil, controlStatus: ControlStatus? = nil, controlStatusUpdatedAt: Date? = nil, description: String? = nil, disabledReason: String? = nil, relatedRequirements: [String]? = nil, remediationUrl: String? = nil, severityRating: SeverityRating? = nil, standardsControlArn: String? = nil, title: String? = nil) {
            self.controlId = controlId
            self.controlStatus = controlStatus
            self.controlStatusUpdatedAt = controlStatusUpdatedAt
            self.description = description
            self.disabledReason = disabledReason
            self.relatedRequirements = relatedRequirements
            self.remediationUrl = remediationUrl
            self.severityRating = severityRating
            self.standardsControlArn = standardsControlArn
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case controlId = "ControlId"
            case controlStatus = "ControlStatus"
            case controlStatusUpdatedAt = "ControlStatusUpdatedAt"
            case description = "Description"
            case disabledReason = "DisabledReason"
            case relatedRequirements = "RelatedRequirements"
            case remediationUrl = "RemediationUrl"
            case severityRating = "SeverityRating"
            case standardsControlArn = "StandardsControlArn"
            case title = "Title"
        }
    }

    public struct StandardsManagedBy: AWSDecodableShape {
        /// An identifier for the company that manages a specific security standard. For existing standards, the value is equal to Amazon Web Services.
        public let company: String?
        /// An identifier for the product that manages a specific security standard. For existing standards, the value is equal to the Amazon Web Services service that manages the standard.
        public let product: String?

        public init(company: String? = nil, product: String? = nil) {
            self.company = company
            self.product = product
        }

        private enum CodingKeys: String, CodingKey {
            case company = "Company"
            case product = "Product"
        }
    }

    public struct StandardsStatusReason: AWSDecodableShape {
        /// The reason code that represents the reason for the current status of a standard subscription.
        public let statusReasonCode: StatusReasonCode

        public init(statusReasonCode: StatusReasonCode) {
            self.statusReasonCode = statusReasonCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusReasonCode = "StatusReasonCode"
        }
    }

    public struct StandardsSubscription: AWSDecodableShape {
        /// The ARN of a standard.
        public let standardsArn: String
        /// A key-value pair of input for the standard.
        public let standardsInput: [String: String]
        /// The status of the standard subscription. The status values are as follows:    PENDING - Standard is in the process of being enabled.    READY - Standard is enabled.    INCOMPLETE - Standard could not be enabled completely. Some controls may not be available.    DELETING - Standard is in the process of being disabled.    FAILED - Standard could not be disabled.
        public let standardsStatus: StandardsStatus
        /// The reason for the current status.
        public let standardsStatusReason: StandardsStatusReason?
        /// The ARN of a resource that represents your subscription to a supported standard.
        public let standardsSubscriptionArn: String

        public init(standardsArn: String, standardsInput: [String: String], standardsStatus: StandardsStatus, standardsStatusReason: StandardsStatusReason? = nil, standardsSubscriptionArn: String) {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
            self.standardsStatus = standardsStatus
            self.standardsStatusReason = standardsStatusReason
            self.standardsSubscriptionArn = standardsSubscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case standardsArn = "StandardsArn"
            case standardsInput = "StandardsInput"
            case standardsStatus = "StandardsStatus"
            case standardsStatusReason = "StandardsStatusReason"
            case standardsSubscriptionArn = "StandardsSubscriptionArn"
        }
    }

    public struct StandardsSubscriptionRequest: AWSEncodableShape {
        /// The ARN of the standard that you want to enable. To view the list of available standards and their ARNs, use the DescribeStandards operation.
        public let standardsArn: String
        /// A key-value pair of input for the standard.
        public let standardsInput: [String: String]?

        public init(standardsArn: String, standardsInput: [String: String]? = nil) {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
        }

        public func validate(name: String) throws {
            try self.validate(self.standardsArn, name: "standardsArn", parent: name, pattern: "\\S")
            try self.standardsInput?.forEach {
                try validate($0.key, name: "standardsInput.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "standardsInput[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case standardsArn = "StandardsArn"
            case standardsInput = "StandardsInput"
        }
    }

    public struct StatelessCustomActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// Information about metrics to publish to CloudWatch.
        public let publishMetricAction: StatelessCustomPublishMetricAction?

        public init(publishMetricAction: StatelessCustomPublishMetricAction? = nil) {
            self.publishMetricAction = publishMetricAction
        }

        public func validate(name: String) throws {
            try self.publishMetricAction?.validate(name: "\(name).publishMetricAction")
        }

        private enum CodingKeys: String, CodingKey {
            case publishMetricAction = "PublishMetricAction"
        }
    }

    public struct StatelessCustomPublishMetricAction: AWSEncodableShape & AWSDecodableShape {
        /// Defines CloudWatch dimension values to publish.
        public let dimensions: [StatelessCustomPublishMetricActionDimension]?

        public init(dimensions: [StatelessCustomPublishMetricActionDimension]? = nil) {
            self.dimensions = dimensions
        }

        public func validate(name: String) throws {
            try self.dimensions?.forEach {
                try $0.validate(name: "\(name).dimensions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
        }
    }

    public struct StatelessCustomPublishMetricActionDimension: AWSEncodableShape & AWSDecodableShape {
        /// The value to use for the custom metric dimension.
        public let value: String?

        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct StatusReason: AWSEncodableShape & AWSDecodableShape {
        /// The corresponding description for the status reason code.
        public let description: String?
        /// A code that represents a reason for the control status. For the list of status reason codes and their meanings, see Standards-related information in the ASFF in the Security Hub User Guide.
        public let reasonCode: String

        public init(description: String? = nil, reasonCode: String) {
            self.description = description
            self.reasonCode = reasonCode
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.reasonCode, name: "reasonCode", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case reasonCode = "ReasonCode"
        }
    }

    public struct StringFilter: AWSEncodableShape & AWSDecodableShape {
        /// The condition to apply to a string value when querying for findings. To search for values that contain the filter criteria value, use one of the following comparison operators:   To search for values that exactly match the filter value, use EQUALS. For example, the filter ResourceType EQUALS AwsEc2SecurityGroup only matches findings that have a resource type of AwsEc2SecurityGroup.   To search for values that start with the filter value, use PREFIX. For example, the filter ResourceType PREFIX AwsIam matches findings that have a resource type that starts with AwsIam. Findings with a resource type of AwsIamPolicy, AwsIamRole, or AwsIamUser would all match.    EQUALS and PREFIX filters on the same field are joined by OR. A finding matches if it matches any one of those filters. To search for values that do not contain the filter criteria value, use one of the following comparison operators:   To search for values that do not exactly match the filter value, use NOT_EQUALS. For example, the filter ResourceType NOT_EQUALS AwsIamPolicy matches findings that have a resource type other than AwsIamPolicy.   To search for values that do not start with the filter value, use PREFIX_NOT_EQUALS. For example, the filter ResourceType PREFIX_NOT_EQUALS AwsIam matches findings that have a resource type that does not start with AwsIam. Findings with a resource type of AwsIamPolicy, AwsIamRole, or AwsIamUser would all be excluded from the results.    NOT_EQUALS and PREFIX_NOT_EQUALS filters on the same field are joined by AND. A finding matches only if it matches all of those filters. For filters on the same field, you cannot provide both an EQUALS filter and a NOT_EQUALS or PREFIX_NOT_EQUALS filter. Combining filters in this way always returns an error, even if the provided filter values would return valid results. You can combine PREFIX filters with NOT_EQUALS or PREFIX_NOT_EQUALS filters for the same field. Security Hub first processes the PREFIX filters, then the NOT_EQUALS or PREFIX_NOT_EQUALS filters. For example, for the following filter, Security Hub first identifies findings that have resource types that start with either AwsIAM or AwsEc2. It then excludes findings that have a resource type of AwsIamPolicy and findings that have a resource type of AwsEc2NetworkInterface.    ResourceType PREFIX AwsIam     ResourceType PREFIX AwsEc2     ResourceType NOT_EQUALS AwsIamPolicy     ResourceType NOT_EQUALS AwsEc2NetworkInterface
        public let comparison: StringFilterComparison?
        /// The string filter value. Filter values are case sensitive. For example, the product name for control-based findings is Security Hub. If you provide security hub as the filter text, then there is no match.
        public let value: String?

        public init(comparison: StringFilterComparison? = nil, value: String? = nil) {
            self.comparison = comparison
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The ARN of the resource to apply the tags to.
        public let resourceArn: String
        /// The tags to add to the resource. You can add up to 50 tags at a time. The tag keys can be no longer than 128 characters. The tag values can be no longer than 256 characters.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:securityhub:")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Threat: AWSEncodableShape & AWSDecodableShape {
        /// Provides information about the file paths that were affected by the threat.
        ///
        public let filePaths: [FilePaths]?
        /// This total number of items in which the threat has been detected.
        ///
        public let itemCount: Int?
        /// The name of the threat.
        ///
        public let name: String?
        /// The severity of the threat.
        ///
        public let severity: String?

        public init(filePaths: [FilePaths]? = nil, itemCount: Int? = nil, name: String? = nil, severity: String? = nil) {
            self.filePaths = filePaths
            self.itemCount = itemCount
            self.name = name
            self.severity = severity
        }

        public func validate(name: String) throws {
            try self.filePaths?.forEach {
                try $0.validate(name: "\(name).filePaths[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.severity, name: "severity", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case filePaths = "FilePaths"
            case itemCount = "ItemCount"
            case name = "Name"
            case severity = "Severity"
        }
    }

    public struct ThreatIntelIndicator: AWSEncodableShape & AWSDecodableShape {
        /// The category of a threat intelligence indicator.
        public let category: ThreatIntelIndicatorCategory?
        /// Indicates when the most recent instance of a threat intelligence indicator was observed. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let lastObservedAt: String?
        /// The source of the threat intelligence indicator.
        public let source: String?
        /// The URL to the page or site where you can get more information about the threat intelligence indicator.
        public let sourceUrl: String?
        /// The type of threat intelligence indicator.
        public let type: ThreatIntelIndicatorType?
        /// The value of a threat intelligence indicator.
        public let value: String?

        public init(category: ThreatIntelIndicatorCategory? = nil, lastObservedAt: String? = nil, source: String? = nil, sourceUrl: String? = nil, type: ThreatIntelIndicatorType? = nil, value: String? = nil) {
            self.category = category
            self.lastObservedAt = lastObservedAt
            self.source = source
            self.sourceUrl = sourceUrl
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.lastObservedAt, name: "lastObservedAt", parent: name, pattern: "\\S")
            try self.validate(self.source, name: "source", parent: name, pattern: "\\S")
            try self.validate(self.sourceUrl, name: "sourceUrl", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case lastObservedAt = "LastObservedAt"
            case source = "Source"
            case sourceUrl = "SourceUrl"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The ARN of the resource to remove the tags from.
        public let resourceArn: String
        /// The tag keys associated with the tags to remove from the resource. You can remove up to 50 tags at a time.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:securityhub:")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateActionTargetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "actionTargetArn", location: .uri("ActionTargetArn"))
        ]

        /// The ARN of the custom action target to update.
        public let actionTargetArn: String
        /// The updated description for the custom action target.
        public let description: String?
        /// The updated name of the custom action target.
        public let name: String?

        public init(actionTargetArn: String, description: String? = nil, name: String? = nil) {
            self.actionTargetArn = actionTargetArn
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.actionTargetArn, name: "actionTargetArn", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateActionTargetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFindingAggregatorRequest: AWSEncodableShape {
        /// The ARN of the finding aggregator. To obtain the ARN, use ListFindingAggregators.
        public let findingAggregatorArn: String
        /// Indicates whether to aggregate findings from all of the available Regions in the current partition. Also determines whether to automatically aggregate findings from new Regions as Security Hub supports them and you opt into them. The selected option also determines how to use the Regions provided in the Regions list. The options are as follows:    ALL_REGIONS - Indicates to aggregate findings from all of the Regions where Security Hub is enabled. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.     ALL_REGIONS_EXCEPT_SPECIFIED - Indicates to aggregate findings from all of the Regions where Security Hub is enabled, except for the Regions listed in the Regions parameter. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.     SPECIFIED_REGIONS - Indicates to aggregate findings only from the Regions listed in the Regions parameter. Security Hub does not automatically aggregate findings from new Regions.
        public let regionLinkingMode: String
        /// If RegionLinkingMode is ALL_REGIONS_EXCEPT_SPECIFIED, then this is a space-separated list of Regions that do not aggregate findings to the aggregation Region. If RegionLinkingMode is SPECIFIED_REGIONS, then this is a space-separated list of Regions that do aggregate findings to the aggregation Region.
        public let regions: [String]?

        public init(findingAggregatorArn: String, regionLinkingMode: String, regions: [String]? = nil) {
            self.findingAggregatorArn = findingAggregatorArn
            self.regionLinkingMode = regionLinkingMode
            self.regions = regions
        }

        public func validate(name: String) throws {
            try self.validate(self.findingAggregatorArn, name: "findingAggregatorArn", parent: name, pattern: "\\S")
            try self.validate(self.regionLinkingMode, name: "regionLinkingMode", parent: name, pattern: "\\S")
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregatorArn = "FindingAggregatorArn"
            case regionLinkingMode = "RegionLinkingMode"
            case regions = "Regions"
        }
    }

    public struct UpdateFindingAggregatorResponse: AWSDecodableShape {
        /// The aggregation Region.
        public let findingAggregationRegion: String?
        /// The ARN of the finding aggregator.
        public let findingAggregatorArn: String?
        /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
        public let regionLinkingMode: String?
        /// The list of excluded Regions or included Regions.
        public let regions: [String]?

        public init(findingAggregationRegion: String? = nil, findingAggregatorArn: String? = nil, regionLinkingMode: String? = nil, regions: [String]? = nil) {
            self.findingAggregationRegion = findingAggregationRegion
            self.findingAggregatorArn = findingAggregatorArn
            self.regionLinkingMode = regionLinkingMode
            self.regions = regions
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregationRegion = "FindingAggregationRegion"
            case findingAggregatorArn = "FindingAggregatorArn"
            case regionLinkingMode = "RegionLinkingMode"
            case regions = "Regions"
        }
    }

    public struct UpdateFindingsRequest: AWSEncodableShape {
        /// A collection of attributes that specify which findings you want to update.
        public let filters: AwsSecurityFindingFilters
        /// The updated note for the finding.
        public let note: NoteUpdate?
        /// The updated record state for the finding.
        public let recordState: RecordState?

        public init(filters: AwsSecurityFindingFilters, note: NoteUpdate? = nil, recordState: RecordState? = nil) {
            self.filters = filters
            self.note = note
            self.recordState = recordState
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.note?.validate(name: "\(name).note")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case note = "Note"
            case recordState = "RecordState"
        }
    }

    public struct UpdateFindingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateInsightRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "insightArn", location: .uri("InsightArn"))
        ]

        /// The updated filters that define this insight.
        public let filters: AwsSecurityFindingFilters?
        /// The updated GroupBy attribute that defines this insight.
        public let groupByAttribute: String?
        /// The ARN of the insight that you want to update.
        public let insightArn: String
        /// The updated name for the insight.
        public let name: String?

        public init(filters: AwsSecurityFindingFilters? = nil, groupByAttribute: String? = nil, insightArn: String, name: String? = nil) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.groupByAttribute, name: "groupByAttribute", parent: name, pattern: "\\S")
            try self.validate(self.insightArn, name: "insightArn", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case name = "Name"
        }
    }

    public struct UpdateInsightResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateOrganizationConfigurationRequest: AWSEncodableShape {
        /// Whether to automatically enable Security Hub for new accounts in the organization. By default, this is false, and new accounts are not added automatically. To automatically enable Security Hub for new accounts, set this to true.
        public let autoEnable: Bool
        /// Whether to automatically enable Security Hub default standards  for new member accounts in the organization. By default, this parameter is equal to DEFAULT, and new member accounts are automatically enabled with default Security Hub standards. To opt out of enabling default standards for new member accounts, set this parameter equal to NONE.
        public let autoEnableStandards: AutoEnableStandards?

        public init(autoEnable: Bool = false, autoEnableStandards: AutoEnableStandards? = nil) {
            self.autoEnable = autoEnable
            self.autoEnableStandards = autoEnableStandards
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "AutoEnable"
            case autoEnableStandards = "AutoEnableStandards"
        }
    }

    public struct UpdateOrganizationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateSecurityHubConfigurationRequest: AWSEncodableShape {
        /// Whether to automatically enable new controls when they are added to standards that are enabled. By default, this is set to true, and new controls are enabled automatically. To not automatically enable new controls, set this to false.
        public let autoEnableControls: Bool?

        public init(autoEnableControls: Bool? = nil) {
            self.autoEnableControls = autoEnableControls
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnableControls = "AutoEnableControls"
        }
    }

    public struct UpdateSecurityHubConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateStandardsControlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "standardsControlArn", location: .uri("StandardsControlArn"))
        ]

        /// The updated status of the security standard control.
        public let controlStatus: ControlStatus?
        /// A description of the reason why you are disabling a security standard control. If you are disabling a control, then this is required.
        public let disabledReason: String?
        /// The ARN of the security standard control to enable or disable.
        public let standardsControlArn: String

        public init(controlStatus: ControlStatus? = nil, disabledReason: String? = nil, standardsControlArn: String) {
            self.controlStatus = controlStatus
            self.disabledReason = disabledReason
            self.standardsControlArn = standardsControlArn
        }

        public func validate(name: String) throws {
            try self.validate(self.disabledReason, name: "disabledReason", parent: name, pattern: "\\S")
            try self.validate(self.standardsControlArn, name: "standardsControlArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case controlStatus = "ControlStatus"
            case disabledReason = "DisabledReason"
        }
    }

    public struct UpdateStandardsControlResponse: AWSDecodableShape {
        public init() {}
    }

    public struct VolumeMount: AWSEncodableShape & AWSDecodableShape {
        /// The path in the container at which the volume should be mounted.
        public let mountPath: String?
        /// The name of the volume.
        public let name: String?

        public init(mountPath: String? = nil, name: String? = nil) {
            self.mountPath = mountPath
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.mountPath, name: "mountPath", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case mountPath = "MountPath"
            case name = "Name"
        }
    }

    public struct VpcInfoCidrBlockSetDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IPv4 CIDR block for the VPC.
        public let cidrBlock: String?

        public init(cidrBlock: String? = nil) {
            self.cidrBlock = cidrBlock
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrBlock = "CidrBlock"
        }
    }

    public struct VpcInfoIpv6CidrBlockSetDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IPv6 CIDR block for the VPC.
        public let ipv6CidrBlock: String?

        public init(ipv6CidrBlock: String? = nil) {
            self.ipv6CidrBlock = ipv6CidrBlock
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv6CidrBlock, name: "ipv6CidrBlock", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6CidrBlock = "Ipv6CidrBlock"
        }
    }

    public struct VpcInfoPeeringOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.
        public let allowDnsResolutionFromRemoteVpc: Bool?
        /// Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.
        public let allowEgressFromLocalClassicLinkToRemoteVpc: Bool?
        /// Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.
        public let allowEgressFromLocalVpcToRemoteClassicLink: Bool?

        public init(allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil, allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil) {
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
        }

        private enum CodingKeys: String, CodingKey {
            case allowDnsResolutionFromRemoteVpc = "AllowDnsResolutionFromRemoteVpc"
            case allowEgressFromLocalClassicLinkToRemoteVpc = "AllowEgressFromLocalClassicLinkToRemoteVpc"
            case allowEgressFromLocalVpcToRemoteClassicLink = "AllowEgressFromLocalVpcToRemoteClassicLink"
        }
    }

    public struct Vulnerability: AWSEncodableShape & AWSDecodableShape {
        /// CVSS scores from the advisory related to the vulnerability.
        public let cvss: [Cvss]?
        /// Specifies if all vulnerable packages in a finding have a value for FixedInVersion
        /// and Remediation.
        /// This field is evaluated for each vulnerability Id based on the number of vulnerable packages that have a value for both
        /// FixedInVersion and Remediation. Valid values are as follows:    YES if all vulnerable packages have a value for both FixedInVersion and Remediation     NO if no vulnerable packages have a value for FixedInVersion and Remediation     PARTIAL otherwise
        public let fixAvailable: VulnerabilityFixAvailable?
        /// The identifier of the vulnerability.
        public let id: String
        /// A list of URLs that provide additional information about the vulnerability.
        public let referenceUrls: [String]?
        /// List of vulnerabilities that are related to this vulnerability.
        public let relatedVulnerabilities: [String]?
        /// Information about the vendor that generates the vulnerability report.
        public let vendor: VulnerabilityVendor?
        /// List of software packages that have the vulnerability.
        public let vulnerablePackages: [SoftwarePackage]?

        public init(cvss: [Cvss]? = nil, fixAvailable: VulnerabilityFixAvailable? = nil, id: String, referenceUrls: [String]? = nil, relatedVulnerabilities: [String]? = nil, vendor: VulnerabilityVendor? = nil, vulnerablePackages: [SoftwarePackage]? = nil) {
            self.cvss = cvss
            self.fixAvailable = fixAvailable
            self.id = id
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.vendor = vendor
            self.vulnerablePackages = vulnerablePackages
        }

        public func validate(name: String) throws {
            try self.cvss?.forEach {
                try $0.validate(name: "\(name).cvss[]")
            }
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.referenceUrls?.forEach {
                try validate($0, name: "referenceUrls[]", parent: name, pattern: "\\S")
            }
            try self.relatedVulnerabilities?.forEach {
                try validate($0, name: "relatedVulnerabilities[]", parent: name, pattern: "\\S")
            }
            try self.vendor?.validate(name: "\(name).vendor")
            try self.vulnerablePackages?.forEach {
                try $0.validate(name: "\(name).vulnerablePackages[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cvss = "Cvss"
            case fixAvailable = "FixAvailable"
            case id = "Id"
            case referenceUrls = "ReferenceUrls"
            case relatedVulnerabilities = "RelatedVulnerabilities"
            case vendor = "Vendor"
            case vulnerablePackages = "VulnerablePackages"
        }
    }

    public struct VulnerabilityVendor: AWSEncodableShape & AWSDecodableShape {
        /// The name of the vendor.
        public let name: String
        /// The URL of the vulnerability advisory.
        public let url: String?
        /// Indicates when the vulnerability advisory was created. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let vendorCreatedAt: String?
        /// The severity that the vendor assigned to the vulnerability.
        public let vendorSeverity: String?
        /// Indicates when the vulnerability advisory was last updated. Uses the date-time format specified in RFC 3339 section 5.6, Internet Date/Time Format. The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public let vendorUpdatedAt: String?

        public init(name: String, url: String? = nil, vendorCreatedAt: String? = nil, vendorSeverity: String? = nil, vendorUpdatedAt: String? = nil) {
            self.name = name
            self.url = url
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.url, name: "url", parent: name, pattern: "\\S")
            try self.validate(self.vendorCreatedAt, name: "vendorCreatedAt", parent: name, pattern: "\\S")
            try self.validate(self.vendorSeverity, name: "vendorSeverity", parent: name, pattern: "\\S")
            try self.validate(self.vendorUpdatedAt, name: "vendorUpdatedAt", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case url = "Url"
            case vendorCreatedAt = "VendorCreatedAt"
            case vendorSeverity = "VendorSeverity"
            case vendorUpdatedAt = "VendorUpdatedAt"
        }
    }

    public struct WafAction: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how you want WAF to respond to requests that match the settings in a rule. Valid settings include the following:    ALLOW - WAF allows requests    BLOCK - WAF blocks requests    COUNT - WAF increments a counter of the requests that match all of the conditions in the rule. WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify COUNT for the default action for a web ACL.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct WafExcludedRule: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the rule to exclude from the rule group.
        public let ruleId: String?

        public init(ruleId: String? = nil) {
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ruleId = "RuleId"
        }
    }

    public struct WafOverrideAction: AWSEncodableShape & AWSDecodableShape {
        ///  COUNT overrides the action specified by the individual rule within a RuleGroup . If set to NONE, the rule's action takes place.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct Workflow: AWSEncodableShape & AWSDecodableShape {
        /// The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to SUPPRESSED or RESOLVED does not prevent a new finding for the same issue. The allowed values are the following.    NEW - The initial state of a finding, before it is reviewed. Security Hub also resets the workflow status from NOTIFIED or RESOLVED to NEW in the following cases:    RecordState changes from ARCHIVED to ACTIVE.    ComplianceStatus changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.      NOTIFIED - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.    SUPPRESSED - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.    RESOLVED - The finding was reviewed and remediated and is now considered resolved.
        public let status: WorkflowStatus?

        public init(status: WorkflowStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct WorkflowUpdate: AWSEncodableShape {
        /// The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to SUPPRESSED or RESOLVED does not prevent a new finding for the same issue. The allowed values are the following.    NEW - The initial state of a finding, before it is reviewed. Security Hub also resets WorkFlowStatus from NOTIFIED or RESOLVED to NEW in the following cases:   The record state changes from ARCHIVED to ACTIVE.   The compliance status changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.      NOTIFIED - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.    RESOLVED - The finding was reviewed and remediated and is now considered resolved.    SUPPRESSED - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.
        public let status: WorkflowStatus?

        public init(status: WorkflowStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }
}

// MARK: - Errors

/// Error enum for SecurityHub
public struct SecurityHubErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalException = "InternalException"
        case invalidAccessException = "InvalidAccessException"
        case invalidInputException = "InvalidInputException"
        case limitExceededException = "LimitExceededException"
        case resourceConflictException = "ResourceConflictException"
        case resourceNotFoundException = "ResourceNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SecurityHub
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don&#39;t have permission to perform the action specified in the request.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Internal server error.
    public static var internalException: Self { .init(.internalException) }
    /// The account doesn&#39;t have permission to perform this action.
    public static var invalidAccessException: Self { .init(.invalidAccessException) }
    /// The request was rejected because you supplied an invalid or out-of-range value for an input parameter.
    public static var invalidInputException: Self { .init(.invalidInputException) }
    /// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account or throttling limits. The error code describes the limit exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The resource specified in the request conflicts with an existing resource.
    public static var resourceConflictException: Self { .init(.resourceConflictException) }
    /// The request was rejected because we can&#39;t find the specified resource.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
}

extension SecurityHubErrorType: Equatable {
    public static func == (lhs: SecurityHubErrorType, rhs: SecurityHubErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SecurityHubErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
