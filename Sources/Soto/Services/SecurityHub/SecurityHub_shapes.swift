//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension SecurityHub {
    // MARK: Enums

    public enum ActorSessionMfaStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AdminStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AssociationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case applied = "APPLIED"
        case inherited = "INHERITED"
        public var description: String { return self.rawValue }
    }

    public enum AutoEnableStandards: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum AutomationRulesActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case findingFieldsUpdate = "FINDING_FIELDS_UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum AwsIamAccessKeyStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum AwsS3BucketNotificationConfigurationS3KeyFilterRuleName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case prefix = "Prefix"
        case suffix = "Suffix"
        public var description: String { return self.rawValue }
    }

    public enum ComplianceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case notAvailable = "NOT_AVAILABLE"
        case passed = "PASSED"
        case warning = "WARNING"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationPolicyAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
        public var description: String { return self.rawValue }
    }

    public enum ControlFindingGenerator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case securityControl = "SECURITY_CONTROL"
        case standardControl = "STANDARD_CONTROL"
        public var description: String { return self.rawValue }
    }

    public enum ControlStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DateRangeUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days = "DAYS"
        public var description: String { return self.rawValue }
    }

    public enum FindingHistoryUpdateSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case batchImportFindings = "BATCH_IMPORT_FINDINGS"
        case batchUpdateFindings = "BATCH_UPDATE_FINDINGS"
        public var description: String { return self.rawValue }
    }

    public enum IntegrationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case receiveFindingsFromSecurityHub = "RECEIVE_FINDINGS_FROM_SECURITY_HUB"
        case sendFindingsToSecurityHub = "SEND_FINDINGS_TO_SECURITY_HUB"
        case updateFindingsInSecurityHub = "UPDATE_FINDINGS_IN_SECURITY_HUB"
        public var description: String { return self.rawValue }
    }

    public enum MalwareState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case observed = "OBSERVED"
        case removalFailed = "REMOVAL_FAILED"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum MalwareType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case adware = "ADWARE"
        case blendedThreat = "BLENDED_THREAT"
        case botnetAgent = "BOTNET_AGENT"
        case coinMiner = "COIN_MINER"
        case exploitKit = "EXPLOIT_KIT"
        case keylogger = "KEYLOGGER"
        case macro = "MACRO"
        case potentiallyUnwanted = "POTENTIALLY_UNWANTED"
        case ransomware = "RANSOMWARE"
        case remoteAccess = "REMOTE_ACCESS"
        case rootkit = "ROOTKIT"
        case spyware = "SPYWARE"
        case trojan = "TROJAN"
        case virus = "VIRUS"
        case worm = "WORM"
        public var description: String { return self.rawValue }
    }

    public enum MapFilterComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case equals = "EQUALS"
        case notContains = "NOT_CONTAINS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum NetworkDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `in` = "IN"
        case out = "OUT"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationConfigurationConfigurationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case central = "CENTRAL"
        case local = "LOCAL"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationConfigurationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enabled = "ENABLED"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum ParameterValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum Partition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "aws"
        case awsCn = "aws-cn"
        case awsUsGov = "aws-us-gov"
        public var description: String { return self.rawValue }
    }

    public enum RecordState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum RegionAvailabilityStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case unavailable = "UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum RuleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum SecurityControlProperty: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case parameters = "Parameters"
        public var description: String { return self.rawValue }
    }

    public enum SeverityLabel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case critical = "CRITICAL"
        case high = "HIGH"
        case informational = "INFORMATIONAL"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum SeverityRating: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case critical = "CRITICAL"
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "asc"
        case descending = "desc"
        public var description: String { return self.rawValue }
    }

    public enum StandardsControlsUpdatable: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notReadyForUpdates = "NOT_READY_FOR_UPDATES"
        case readyForUpdates = "READY_FOR_UPDATES"
        public var description: String { return self.rawValue }
    }

    public enum StandardsStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "DELETING"
        case failed = "FAILED"
        case incomplete = "INCOMPLETE"
        case pending = "PENDING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum StatusReasonCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalError = "INTERNAL_ERROR"
        case maximumNumberOfConfigRulesExceeded = "MAXIMUM_NUMBER_OF_CONFIG_RULES_EXCEEDED"
        case noAvailableConfigurationRecorder = "NO_AVAILABLE_CONFIGURATION_RECORDER"
        public var description: String { return self.rawValue }
    }

    public enum StringFilterComparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case equals = "EQUALS"
        case notContains = "NOT_CONTAINS"
        case notEquals = "NOT_EQUALS"
        case prefix = "PREFIX"
        case prefixNotEquals = "PREFIX_NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum TargetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case account = "ACCOUNT"
        case organizationalUnit = "ORGANIZATIONAL_UNIT"
        case root = "ROOT"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelIndicatorCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backdoor = "BACKDOOR"
        case cardStealer = "CARD_STEALER"
        case commandAndControl = "COMMAND_AND_CONTROL"
        case dropSite = "DROP_SITE"
        case exploitSite = "EXPLOIT_SITE"
        case keylogger = "KEYLOGGER"
        public var description: String { return self.rawValue }
    }

    public enum ThreatIntelIndicatorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case domain = "DOMAIN"
        case emailAddress = "EMAIL_ADDRESS"
        case hashMd5 = "HASH_MD5"
        case hashSha1 = "HASH_SHA1"
        case hashSha256 = "HASH_SHA256"
        case hashSha512 = "HASH_SHA512"
        case ipv4Address = "IPV4_ADDRESS"
        case ipv6Address = "IPV6_ADDRESS"
        case mutex = "MUTEX"
        case process = "PROCESS"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public enum UnprocessedErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case invalidInput = "INVALID_INPUT"
        case limitExceeded = "LIMIT_EXCEEDED"
        case notFound = "NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum UpdateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ready = "READY"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum VerificationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case benignPositive = "BENIGN_POSITIVE"
        case falsePositive = "FALSE_POSITIVE"
        case truePositive = "TRUE_POSITIVE"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum VulnerabilityExploitAvailable: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case no = "NO"
        case yes = "YES"
        public var description: String { return self.rawValue }
    }

    public enum VulnerabilityFixAvailable: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case no = "NO"
        case partial = "PARTIAL"
        case yes = "YES"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assigned = "ASSIGNED"
        case deferred = "DEFERRED"
        case inProgress = "IN_PROGRESS"
        case new = "NEW"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum WorkflowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case new = "NEW"
        case notified = "NOTIFIED"
        case resolved = "RESOLVED"
        case suppressed = "SUPPRESSED"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationOptions: AWSDecodableShape, Sendable {
        ///  The options for customizing a security control parameter that is a boolean. For a boolean parameter, the options are  true and false.
        case boolean(BooleanConfigurationOptions)
        ///  The options for customizing a security control parameter that is a double.
        case double(DoubleConfigurationOptions)
        ///  The options for customizing a security control parameter that is an enum.
        case `enum`(EnumConfigurationOptions)
        ///  The options for customizing a security control parameter that is a list of enums.
        case enumList(EnumListConfigurationOptions)
        ///  The options for customizing a security control parameter that is an integer.
        case integer(IntegerConfigurationOptions)
        ///  The options for customizing a security control parameter that is a list of integers.
        case integerList(IntegerListConfigurationOptions)
        ///  The options for customizing a security control parameter that is a string data type.
        case string(StringConfigurationOptions)
        ///  The options for customizing a security control parameter that is a list of strings.
        case stringList(StringListConfigurationOptions)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .boolean:
                let value = try container.decode(BooleanConfigurationOptions.self, forKey: .boolean)
                self = .boolean(value)
            case .double:
                let value = try container.decode(DoubleConfigurationOptions.self, forKey: .double)
                self = .double(value)
            case .`enum`:
                let value = try container.decode(EnumConfigurationOptions.self, forKey: .`enum`)
                self = .`enum`(value)
            case .enumList:
                let value = try container.decode(EnumListConfigurationOptions.self, forKey: .enumList)
                self = .enumList(value)
            case .integer:
                let value = try container.decode(IntegerConfigurationOptions.self, forKey: .integer)
                self = .integer(value)
            case .integerList:
                let value = try container.decode(IntegerListConfigurationOptions.self, forKey: .integerList)
                self = .integerList(value)
            case .string:
                let value = try container.decode(StringConfigurationOptions.self, forKey: .string)
                self = .string(value)
            case .stringList:
                let value = try container.decode(StringListConfigurationOptions.self, forKey: .stringList)
                self = .stringList(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case boolean = "Boolean"
            case double = "Double"
            case `enum` = "Enum"
            case enumList = "EnumList"
            case integer = "Integer"
            case integerList = "IntegerList"
            case string = "String"
            case stringList = "StringList"
        }
    }

    public enum ParameterValue: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  A control parameter that is a boolean.
        case boolean(Bool)
        ///  A control parameter that is a double.
        case double(Double)
        ///  A control parameter that is an enum.
        case `enum`(String)
        ///  A control parameter that is a list of enums.
        case enumList([String])
        ///  A control parameter that is an integer.
        case integer(Int)
        ///  A control parameter that is a list of integers.
        case integerList([Int])
        ///  A control parameter that is a string.
        case string(String)
        ///  A control parameter that is a list of strings.
        case stringList([String])

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .boolean:
                let value = try container.decode(Bool.self, forKey: .boolean)
                self = .boolean(value)
            case .double:
                let value = try container.decode(Double.self, forKey: .double)
                self = .double(value)
            case .`enum`:
                let value = try container.decode(String.self, forKey: .`enum`)
                self = .`enum`(value)
            case .enumList:
                let value = try container.decode([String].self, forKey: .enumList)
                self = .enumList(value)
            case .integer:
                let value = try container.decode(Int.self, forKey: .integer)
                self = .integer(value)
            case .integerList:
                let value = try container.decode([Int].self, forKey: .integerList)
                self = .integerList(value)
            case .string:
                let value = try container.decode(String.self, forKey: .string)
                self = .string(value)
            case .stringList:
                let value = try container.decode([String].self, forKey: .stringList)
                self = .stringList(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .boolean(let value):
                try container.encode(value, forKey: .boolean)
            case .double(let value):
                try container.encode(value, forKey: .double)
            case .`enum`(let value):
                try container.encode(value, forKey: .`enum`)
            case .enumList(let value):
                try container.encode(value, forKey: .enumList)
            case .integer(let value):
                try container.encode(value, forKey: .integer)
            case .integerList(let value):
                try container.encode(value, forKey: .integerList)
            case .string(let value):
                try container.encode(value, forKey: .string)
            case .stringList(let value):
                try container.encode(value, forKey: .stringList)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .`enum`(let value):
                try self.validate(value, name: "`enum`", parent: name, pattern: "\\S")
            case .enumList(let value):
                try value.forEach {
                    try validate($0, name: "enumList[]", parent: name, pattern: "\\S")
                }
            case .string(let value):
                try self.validate(value, name: "string", parent: name, pattern: "\\S")
            case .stringList(let value):
                try value.forEach {
                    try validate($0, name: "stringList[]", parent: name, pattern: "\\S")
                }
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case boolean = "Boolean"
            case double = "Double"
            case `enum` = "Enum"
            case enumList = "EnumList"
            case integer = "Integer"
            case integerList = "IntegerList"
            case string = "String"
            case stringList = "StringList"
        }
    }

    public enum Target: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  The Amazon Web Services account ID of the target account.
        case accountId(String)
        ///  The organizational unit ID of the target organizational unit.
        case organizationalUnitId(String)
        ///  The ID of the organization root.
        case rootId(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accountId:
                let value = try container.decode(String.self, forKey: .accountId)
                self = .accountId(value)
            case .organizationalUnitId:
                let value = try container.decode(String.self, forKey: .organizationalUnitId)
                self = .organizationalUnitId(value)
            case .rootId:
                let value = try container.decode(String.self, forKey: .rootId)
                self = .rootId(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .accountId(let value):
                try container.encode(value, forKey: .accountId)
            case .organizationalUnitId(let value):
                try container.encode(value, forKey: .organizationalUnitId)
            case .rootId(let value):
                try container.encode(value, forKey: .rootId)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .accountId(let value):
                try self.validate(value, name: "accountId", parent: name, pattern: "\\S")
            case .organizationalUnitId(let value):
                try self.validate(value, name: "organizationalUnitId", parent: name, pattern: "\\S")
            case .rootId(let value):
                try self.validate(value, name: "rootId", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case organizationalUnitId = "OrganizationalUnitId"
            case rootId = "RootId"
        }
    }

    // MARK: Shapes

    public struct AcceptAdministratorInvitationRequest: AWSEncodableShape {
        /// The account ID of the Security Hub administrator account that sent the invitation.
        public let administratorId: String?
        /// The identifier of the invitation sent from the Security Hub administrator account.
        public let invitationId: String?

        @inlinable
        public init(administratorId: String? = nil, invitationId: String? = nil) {
            self.administratorId = administratorId
            self.invitationId = invitationId
        }

        public func validate(name: String) throws {
            try self.validate(self.administratorId, name: "administratorId", parent: name, pattern: "\\S")
            try self.validate(self.invitationId, name: "invitationId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case administratorId = "AdministratorId"
            case invitationId = "InvitationId"
        }
    }

    public struct AcceptAdministratorInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AcceptInvitationRequest: AWSEncodableShape {
        /// The identifier of the invitation sent from the Security Hub administrator account.
        public let invitationId: String?
        /// The account ID of the Security Hub administrator account that sent the invitation.
        public let masterId: String?

        @inlinable
        public init(invitationId: String? = nil, masterId: String? = nil) {
            self.invitationId = invitationId
            self.masterId = masterId
        }

        public func validate(name: String) throws {
            try self.validate(self.invitationId, name: "invitationId", parent: name, pattern: "\\S")
            try self.validate(self.masterId, name: "masterId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case invitationId = "InvitationId"
            case masterId = "MasterId"
        }
    }

    public struct AcceptInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AccessDeniedException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct AccountDetails: AWSEncodableShape {
        /// The ID of an Amazon Web Services account.
        public let accountId: String?
        /// The email of an Amazon Web Services account.
        public let email: String?

        @inlinable
        public init(accountId: String? = nil, email: String? = nil) {
            self.accountId = accountId
            self.email = email
        }

        public func validate(name: String) throws {
            try self.validate(self.email, name: "email", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case email = "Email"
        }
    }

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// The type of action that was detected. The possible action types are:    NETWORK_CONNECTION     AWS_API_CALL     DNS_REQUEST     PORT_PROBE
        public let actionType: String?
        /// Included if ActionType is AWS_API_CALL. Provides details about the API call that was detected.
        public let awsApiCallAction: AwsApiCallAction?
        /// Included if ActionType is DNS_REQUEST. Provides details about the DNS request that was detected.
        public let dnsRequestAction: DnsRequestAction?
        /// Included if ActionType is NETWORK_CONNECTION. Provides details about the network connection that was detected.
        public let networkConnectionAction: NetworkConnectionAction?
        /// Included if ActionType is PORT_PROBE. Provides details about the port probe that was detected.
        public let portProbeAction: PortProbeAction?

        @inlinable
        public init(actionType: String? = nil, awsApiCallAction: AwsApiCallAction? = nil, dnsRequestAction: DnsRequestAction? = nil, networkConnectionAction: NetworkConnectionAction? = nil, portProbeAction: PortProbeAction? = nil) {
            self.actionType = actionType
            self.awsApiCallAction = awsApiCallAction
            self.dnsRequestAction = dnsRequestAction
            self.networkConnectionAction = networkConnectionAction
            self.portProbeAction = portProbeAction
        }

        public func validate(name: String) throws {
            try self.validate(self.actionType, name: "actionType", parent: name, pattern: "\\S")
            try self.awsApiCallAction?.validate(name: "\(name).awsApiCallAction")
            try self.dnsRequestAction?.validate(name: "\(name).dnsRequestAction")
            try self.networkConnectionAction?.validate(name: "\(name).networkConnectionAction")
            try self.portProbeAction?.validate(name: "\(name).portProbeAction")
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "ActionType"
            case awsApiCallAction = "AwsApiCallAction"
            case dnsRequestAction = "DnsRequestAction"
            case networkConnectionAction = "NetworkConnectionAction"
            case portProbeAction = "PortProbeAction"
        }
    }

    public struct ActionLocalIpDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IP address.
        public let ipAddressV4: String?

        @inlinable
        public init(ipAddressV4: String? = nil) {
            self.ipAddressV4 = ipAddressV4
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAddressV4, name: "ipAddressV4", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddressV4 = "IpAddressV4"
        }
    }

    public struct ActionLocalPortDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of the port.
        public let port: Int?
        /// The port name of the local connection. Length Constraints: 128.
        public let portName: String?

        @inlinable
        public init(port: Int? = nil, portName: String? = nil) {
            self.port = port
            self.portName = portName
        }

        public func validate(name: String) throws {
            try self.validate(self.portName, name: "portName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case port = "Port"
            case portName = "PortName"
        }
    }

    public struct ActionRemoteIpDetails: AWSEncodableShape & AWSDecodableShape {
        /// The city where the remote IP address is located.
        public let city: City?
        /// The country where the remote IP address is located.
        public let country: Country?
        /// The coordinates of the location of the remote IP address.
        public let geoLocation: GeoLocation?
        /// The IP address.
        public let ipAddressV4: String?
        /// The internet service provider (ISP) organization associated with the remote IP address.
        public let organization: IpOrganizationDetails?

        @inlinable
        public init(city: City? = nil, country: Country? = nil, geoLocation: GeoLocation? = nil, ipAddressV4: String? = nil, organization: IpOrganizationDetails? = nil) {
            self.city = city
            self.country = country
            self.geoLocation = geoLocation
            self.ipAddressV4 = ipAddressV4
            self.organization = organization
        }

        public func validate(name: String) throws {
            try self.city?.validate(name: "\(name).city")
            try self.country?.validate(name: "\(name).country")
            try self.validate(self.ipAddressV4, name: "ipAddressV4", parent: name, pattern: "\\S")
            try self.organization?.validate(name: "\(name).organization")
        }

        private enum CodingKeys: String, CodingKey {
            case city = "City"
            case country = "Country"
            case geoLocation = "GeoLocation"
            case ipAddressV4 = "IpAddressV4"
            case organization = "Organization"
        }
    }

    public struct ActionRemotePortDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of the port.
        public let port: Int?
        /// The port name of the remote connection. Length Constraints: 128.
        public let portName: String?

        @inlinable
        public init(port: Int? = nil, portName: String? = nil) {
            self.port = port
            self.portName = portName
        }

        public func validate(name: String) throws {
            try self.validate(self.portName, name: "portName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case port = "Port"
            case portName = "PortName"
        }
    }

    public struct ActionTarget: AWSDecodableShape {
        /// The ARN for the target action.
        public let actionTargetArn: String?
        /// The description of the target action.
        public let description: String?
        /// The name of the action target.
        public let name: String?

        @inlinable
        public init(actionTargetArn: String? = nil, description: String? = nil, name: String? = nil) {
            self.actionTargetArn = actionTargetArn
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct Actor: AWSEncodableShape & AWSDecodableShape {
        ///  The ID of the threat actor.
        public let id: String?
        ///  Contains information about the user session where the activity initiated.
        public let session: ActorSession?
        ///  Contains information about the user credentials used by the threat actor.
        public let user: ActorUser?

        @inlinable
        public init(id: String? = nil, session: ActorSession? = nil, user: ActorUser? = nil) {
            self.id = id
            self.session = session
            self.user = user
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.session?.validate(name: "\(name).session")
            try self.user?.validate(name: "\(name).user")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case session = "Session"
            case user = "User"
        }
    }

    public struct ActorSession: AWSEncodableShape & AWSDecodableShape {
        /// The timestamp for when the session was created.   In CloudTrail, you can find this value as userIdentity.sessionContext.attributes.creationDate.
        public let createdTime: Int64?
        ///  The issuer of the session.   In CloudTrail, you can find this value as userIdentity.sessionContext.sessionIssuer.arn.
        public let issuer: String?
        ///  Indicates whether multi-factor authentication (MFA) was used for authentication during the session. In CloudTrail, you can find this value as userIdentity.sessionContext.attributes.mfaAuthenticated.
        public let mfaStatus: ActorSessionMfaStatus?
        ///  Unique identifier of the session.
        public let uid: String?

        @inlinable
        public init(createdTime: Int64? = nil, issuer: String? = nil, mfaStatus: ActorSessionMfaStatus? = nil, uid: String? = nil) {
            self.createdTime = createdTime
            self.issuer = issuer
            self.mfaStatus = mfaStatus
            self.uid = uid
        }

        public func validate(name: String) throws {
            try self.validate(self.issuer, name: "issuer", parent: name, pattern: "\\S")
            try self.validate(self.uid, name: "uid", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case issuer = "Issuer"
            case mfaStatus = "MfaStatus"
            case uid = "Uid"
        }
    }

    public struct ActorUser: AWSEncodableShape & AWSDecodableShape {
        ///  The account of the threat actor.
        public let account: UserAccount?
        ///  Unique identifier of the threat actorâ€™s user credentials.
        public let credentialUid: String?
        ///  The name of the threat actor.
        public let name: String?
        ///  The type of user.
        public let type: String?
        ///  The unique identifier of the threat actor.
        public let uid: String?

        @inlinable
        public init(account: UserAccount? = nil, credentialUid: String? = nil, name: String? = nil, type: String? = nil, uid: String? = nil) {
            self.account = account
            self.credentialUid = credentialUid
            self.name = name
            self.type = type
            self.uid = uid
        }

        public func validate(name: String) throws {
            try self.account?.validate(name: "\(name).account")
            try self.validate(self.credentialUid, name: "credentialUid", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.uid, name: "uid", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case account = "Account"
            case credentialUid = "CredentialUid"
            case name = "Name"
            case type = "Type"
            case uid = "Uid"
        }
    }

    public struct Adjustment: AWSEncodableShape & AWSDecodableShape {
        /// The metric to adjust.
        public let metric: String?
        /// The reason for the adjustment.
        public let reason: String?

        @inlinable
        public init(metric: String? = nil, reason: String? = nil) {
            self.metric = metric
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.metric, name: "metric", parent: name, pattern: "\\S")
            try self.validate(self.reason, name: "reason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "Metric"
            case reason = "Reason"
        }
    }

    public struct AdminAccount: AWSDecodableShape {
        /// The Amazon Web Services account identifier of the Security Hub administrator account.
        public let accountId: String?
        /// The current status of the Security Hub administrator account. Indicates whether the account is currently enabled as a Security Hub administrator.
        public let status: AdminStatus?

        @inlinable
        public init(accountId: String? = nil, status: AdminStatus? = nil) {
            self.accountId = accountId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case status = "Status"
        }
    }

    public struct AssociatedStandard: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of a standard in which a control is enabled. This field consists of the resource portion of the  Amazon Resource Name (ARN) returned for a standard in the DescribeStandards API response.
        public let standardsId: String?

        @inlinable
        public init(standardsId: String? = nil) {
            self.standardsId = standardsId
        }

        public func validate(name: String) throws {
            try self.validate(self.standardsId, name: "standardsId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case standardsId = "StandardsId"
        }
    }

    public struct AssociationFilters: AWSEncodableShape {
        ///  The current status of the association between a target and a configuration policy.
        public let associationStatus: ConfigurationPolicyAssociationStatus?
        ///  Indicates whether the association between a target and a configuration was directly applied by the  Security Hub delegated administrator or inherited from a parent.
        public let associationType: AssociationType?
        ///  The ARN or UUID of the configuration policy.
        public let configurationPolicyId: String?

        @inlinable
        public init(associationStatus: ConfigurationPolicyAssociationStatus? = nil, associationType: AssociationType? = nil, configurationPolicyId: String? = nil) {
            self.associationStatus = associationStatus
            self.associationType = associationType
            self.configurationPolicyId = configurationPolicyId
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationPolicyId, name: "configurationPolicyId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associationStatus = "AssociationStatus"
            case associationType = "AssociationType"
            case configurationPolicyId = "ConfigurationPolicyId"
        }
    }

    public struct AssociationSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The state of the association between a route table and a subnet or gateway.
        public let associationState: AssociationStateDetails?
        ///  The ID of the internet gateway or virtual private gateway.
        public let gatewayId: String?
        ///  Indicates whether this is the main route table.
        public let main: Bool?
        ///  The ID of the association.
        public let routeTableAssociationId: String?
        ///  The ID of the route table.
        public let routeTableId: String?
        ///  The ID of the subnet. A subnet ID is not returned for an implicit association.
        public let subnetId: String?

        @inlinable
        public init(associationState: AssociationStateDetails? = nil, gatewayId: String? = nil, main: Bool? = nil, routeTableAssociationId: String? = nil, routeTableId: String? = nil, subnetId: String? = nil) {
            self.associationState = associationState
            self.gatewayId = gatewayId
            self.main = main
            self.routeTableAssociationId = routeTableAssociationId
            self.routeTableId = routeTableId
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.associationState?.validate(name: "\(name).associationState")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "\\S")
            try self.validate(self.routeTableAssociationId, name: "routeTableAssociationId", parent: name, pattern: "\\S")
            try self.validate(self.routeTableId, name: "routeTableId", parent: name, pattern: "\\S")
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associationState = "AssociationState"
            case gatewayId = "GatewayId"
            case main = "Main"
            case routeTableAssociationId = "RouteTableAssociationId"
            case routeTableId = "RouteTableId"
            case subnetId = "SubnetId"
        }
    }

    public struct AssociationStateDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The state of the association.
        public let state: String?
        ///  The status message, if applicable.
        public let statusMessage: String?

        @inlinable
        public init(state: String? = nil, statusMessage: String? = nil) {
            self.state = state
            self.statusMessage = statusMessage
        }

        public func validate(name: String) throws {
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
            try self.validate(self.statusMessage, name: "statusMessage", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case statusMessage = "StatusMessage"
        }
    }

    public struct AutomationRulesAction: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies that the automation rule action is an update to a finding field.
        public let findingFieldsUpdate: AutomationRulesFindingFieldsUpdate?
        ///  Specifies the type of action that Security Hub takes when a finding matches the defined criteria of a rule.
        public let type: AutomationRulesActionType?

        @inlinable
        public init(findingFieldsUpdate: AutomationRulesFindingFieldsUpdate? = nil, type: AutomationRulesActionType? = nil) {
            self.findingFieldsUpdate = findingFieldsUpdate
            self.type = type
        }

        public func validate(name: String) throws {
            try self.findingFieldsUpdate?.validate(name: "\(name).findingFieldsUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case findingFieldsUpdate = "FindingFieldsUpdate"
            case type = "Type"
        }
    }

    public struct AutomationRulesConfig: AWSDecodableShape {
        ///  One or more actions to update finding fields if a finding matches the defined criteria  of the rule.
        public let actions: [AutomationRulesAction]?
        ///  A timestamp that indicates when the rule was created.  For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        ///  The principal that created a rule.
        public let createdBy: String?
        ///  A set of Amazon Web Services  Security Finding Format finding field attributes and corresponding expected values that  Security Hub uses to filter findings. If a rule is enabled and a finding matches the conditions specified in this parameter, Security Hub applies the rule action to the finding.
        public let criteria: AutomationRulesFindingFilters?
        ///  A description of the rule.
        public let description: String?
        /// Specifies whether a rule is the last to be applied with respect to a finding that matches the rule criteria. This is useful when a finding  matches the criteria for multiple rules, and each rule has different actions. If a rule is terminal, Security Hub applies the rule action to a finding that matches  the rule criteria and doesn't evaluate other rules for the finding. By default, a rule isn't terminal.
        public let isTerminal: Bool?
        ///  The Amazon Resource Name (ARN) of a rule.
        public let ruleArn: String?
        ///  The name of the rule.
        public let ruleName: String?
        ///  An integer ranging from 1 to 1000 that represents the order in which the rule action is applied to findings. Security Hub applies rules with lower values for this parameter first.
        public let ruleOrder: Int?
        ///  Whether the rule is active after it is created. If  this parameter is equal to ENABLED, Security Hub starts applying the rule to findings  and finding updates after the rule is created.
        public let ruleStatus: RuleStatus?
        ///  A timestamp that indicates when the rule was most recently updated.  For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(actions: [AutomationRulesAction]? = nil, createdAt: Date? = nil, createdBy: String? = nil, criteria: AutomationRulesFindingFilters? = nil, description: String? = nil, isTerminal: Bool? = nil, ruleArn: String? = nil, ruleName: String? = nil, ruleOrder: Int? = nil, ruleStatus: RuleStatus? = nil, updatedAt: Date? = nil) {
            self.actions = actions
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.criteria = criteria
            self.description = description
            self.isTerminal = isTerminal
            self.ruleArn = ruleArn
            self.ruleName = ruleName
            self.ruleOrder = ruleOrder
            self.ruleStatus = ruleStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case createdAt = "CreatedAt"
            case createdBy = "CreatedBy"
            case criteria = "Criteria"
            case description = "Description"
            case isTerminal = "IsTerminal"
            case ruleArn = "RuleArn"
            case ruleName = "RuleName"
            case ruleOrder = "RuleOrder"
            case ruleStatus = "RuleStatus"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct AutomationRulesFindingFieldsUpdate: AWSEncodableShape & AWSDecodableShape {
        ///  The rule action updates the Confidence field of a finding.
        public let confidence: Int?
        ///  The rule action updates the Criticality field of a finding.
        public let criticality: Int?
        public let note: NoteUpdate?
        ///  The rule action updates the RelatedFindings field of a finding.
        public let relatedFindings: [RelatedFinding]?
        public let severity: SeverityUpdate?
        ///  The rule action updates the Types field of a finding.
        public let types: [String]?
        ///  The rule action updates the UserDefinedFields field of a finding.
        public let userDefinedFields: [String: String]?
        ///  The rule action updates the VerificationState field of a finding.
        public let verificationState: VerificationState?
        public let workflow: WorkflowUpdate?

        @inlinable
        public init(confidence: Int? = nil, criticality: Int? = nil, note: NoteUpdate? = nil, relatedFindings: [RelatedFinding]? = nil, severity: SeverityUpdate? = nil, types: [String]? = nil, userDefinedFields: [String: String]? = nil, verificationState: VerificationState? = nil, workflow: WorkflowUpdate? = nil) {
            self.confidence = confidence
            self.criticality = criticality
            self.note = note
            self.relatedFindings = relatedFindings
            self.severity = severity
            self.types = types
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflow = workflow
        }

        public func validate(name: String) throws {
            try self.validate(self.confidence, name: "confidence", parent: name, max: 100)
            try self.validate(self.confidence, name: "confidence", parent: name, min: 0)
            try self.validate(self.criticality, name: "criticality", parent: name, max: 100)
            try self.validate(self.criticality, name: "criticality", parent: name, min: 0)
            try self.note?.validate(name: "\(name).note")
            try self.relatedFindings?.forEach {
                try $0.validate(name: "\(name).relatedFindings[]")
            }
            try self.severity?.validate(name: "\(name).severity")
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
            try self.userDefinedFields?.forEach {
                try validate($0.key, name: "userDefinedFields.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "userDefinedFields[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case criticality = "Criticality"
            case note = "Note"
            case relatedFindings = "RelatedFindings"
            case severity = "Severity"
            case types = "Types"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case workflow = "Workflow"
        }
    }

    public struct AutomationRulesFindingFilters: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services account ID in which a finding was generated.  		Array Members: Minimum number of 1 item. Maximum number of 100 items.
        public let awsAccountId: [StringFilter]?
        /// The name of the Amazon Web Services account in which a finding was generated.   Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let awsAccountName: [StringFilter]?
        ///  The name of the company for the product that generated the finding.  For control-based findings, the company is Amazon Web Services.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let companyName: [StringFilter]?
        /// The unique identifier of a standard in which a control is enabled. This field consists of the resource portion of  the Amazon Resource Name (ARN) returned for a standard in the DescribeStandards API response.  		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let complianceAssociatedStandardsId: [StringFilter]?
        ///  The security control ID for which a finding was generated. Security control IDs are the same across standards.  		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let complianceSecurityControlId: [StringFilter]?
        ///  The result of a security check. This field is only used for findings generated  from controls.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let complianceStatus: [StringFilter]?
        /// The likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0â€“100 basis using a ratio scale. A value of 0 means 0 percent confidence, and a value of 100 means 100 percent confidence. For example, a data exfiltration detection based on a statistical deviation of network traffic has low confidence because an actual exfiltration hasn't been verified. For more information, see Confidence in the Security Hub User Guide.  		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let confidence: [NumberFilter]?
        ///  A timestamp that indicates when this finding record was created.  For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.  		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let createdAt: [DateFilter]?
        ///  The level of importance that is assigned to the resources that are associated with a  finding. Criticality is scored on a 0â€“100 basis, using a ratio scale that supports  only full integers. A score of 0 means that the underlying resources have no  criticality, and a score of 100 is reserved for the most critical resources. For  more information, see Criticality in the Security Hub User Guide.  		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let criticality: [NumberFilter]?
        ///  A finding's description.    		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let description: [StringFilter]?
        ///  A timestamp that indicates when the potential security issue captured by a  finding was first observed by the security findings product.  For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.  		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let firstObservedAt: [DateFilter]?
        ///  The identifier for the solution-specific component that  generated a finding.   		Array Members: Minimum number of 1 item. Maximum number of 100 items.
        public let generatorId: [StringFilter]?
        ///  The product-specific identifier for a finding.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let id: [StringFilter]?
        ///  A timestamp that indicates when the security findings provider most recently observed a change in the resource that is involved in the finding.  For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.  		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let lastObservedAt: [DateFilter]?
        ///  The text of a user-defined note that's added to a finding.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let noteText: [StringFilter]?
        ///  The timestamp of when the note was updated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.  		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let noteUpdatedAt: [DateFilter]?
        ///  The principal that created a note.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let noteUpdatedBy: [StringFilter]?
        ///  The Amazon Resource Name (ARN) for a third-party product that generated a finding in  Security Hub.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let productArn: [StringFilter]?
        ///  Provides the name of the product that generated the finding. For  control-based findings, the product name is Security Hub.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let productName: [StringFilter]?
        ///  Provides the current state of a finding.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let recordState: [StringFilter]?
        ///  The product-generated identifier for a related finding.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let relatedFindingsId: [StringFilter]?
        ///  The ARN for the product that generated a related finding.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let relatedFindingsProductArn: [StringFilter]?
        ///  The Amazon Resource Name (ARN) of the application that is related to a finding.   Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let resourceApplicationArn: [StringFilter]?
        ///  The name of the application that is related to a finding.   Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let resourceApplicationName: [StringFilter]?
        ///  Custom fields and values about the resource that a finding pertains to.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let resourceDetailsOther: [MapFilter]?
        ///  The identifier for the given resource type. For Amazon Web Services resources that are identified by  Amazon Resource Names (ARNs), this is the ARN. For Amazon Web Services resources that lack ARNs,  this is the identifier as defined by the Amazon Web Services service that created the resource.  For non-Amazon Web Services resources, this is a unique identifier that is associated with the  resource.   		Array Members: Minimum number of 1 item. Maximum number of 100 items.
        public let resourceId: [StringFilter]?
        ///  The partition in which the resource that the finding pertains to is located.  A partition is a group of Amazon Web Services Regions. Each Amazon Web Services account is scoped to one partition.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let resourcePartition: [StringFilter]?
        ///  The Amazon Web Services Region where the resource that a finding pertains to is located.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let resourceRegion: [StringFilter]?
        ///  A list of Amazon Web Services tags associated with a resource at the time the finding was processed.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let resourceTags: [MapFilter]?
        ///  The type of resource that the finding pertains to.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let resourceType: [StringFilter]?
        ///  The severity value of the finding.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let severityLabel: [StringFilter]?
        ///  Provides a URL that links to a page about the current finding in the finding product.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let sourceUrl: [StringFilter]?
        ///  A finding's title.   		Array Members: Minimum number of 1 item. Maximum number of 100 items.
        public let title: [StringFilter]?
        ///  One or more finding types in the format of namespace/category/classifier that classify a finding. For a list of namespaces, classifiers, and categories, see Types taxonomy for ASFF in the Security Hub User Guide.  		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let type: [StringFilter]?
        ///  A timestamp that indicates when the finding record was most recently updated.   For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.  		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let updatedAt: [DateFilter]?
        ///  A list of user-defined name and value string pairs added to a finding.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let userDefinedFields: [MapFilter]?
        ///  Provides the veracity of a finding.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let verificationState: [StringFilter]?
        ///  Provides information about the status of the investigation into a finding.   		Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public let workflowStatus: [StringFilter]?

        @inlinable
        public init(awsAccountId: [StringFilter]? = nil, awsAccountName: [StringFilter]? = nil, companyName: [StringFilter]? = nil, complianceAssociatedStandardsId: [StringFilter]? = nil, complianceSecurityControlId: [StringFilter]? = nil, complianceStatus: [StringFilter]? = nil, confidence: [NumberFilter]? = nil, createdAt: [DateFilter]? = nil, criticality: [NumberFilter]? = nil, description: [StringFilter]? = nil, firstObservedAt: [DateFilter]? = nil, generatorId: [StringFilter]? = nil, id: [StringFilter]? = nil, lastObservedAt: [DateFilter]? = nil, noteText: [StringFilter]? = nil, noteUpdatedAt: [DateFilter]? = nil, noteUpdatedBy: [StringFilter]? = nil, productArn: [StringFilter]? = nil, productName: [StringFilter]? = nil, recordState: [StringFilter]? = nil, relatedFindingsId: [StringFilter]? = nil, relatedFindingsProductArn: [StringFilter]? = nil, resourceApplicationArn: [StringFilter]? = nil, resourceApplicationName: [StringFilter]? = nil, resourceDetailsOther: [MapFilter]? = nil, resourceId: [StringFilter]? = nil, resourcePartition: [StringFilter]? = nil, resourceRegion: [StringFilter]? = nil, resourceTags: [MapFilter]? = nil, resourceType: [StringFilter]? = nil, severityLabel: [StringFilter]? = nil, sourceUrl: [StringFilter]? = nil, title: [StringFilter]? = nil, type: [StringFilter]? = nil, updatedAt: [DateFilter]? = nil, userDefinedFields: [MapFilter]? = nil, verificationState: [StringFilter]? = nil, workflowStatus: [StringFilter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountName = awsAccountName
            self.companyName = companyName
            self.complianceAssociatedStandardsId = complianceAssociatedStandardsId
            self.complianceSecurityControlId = complianceSecurityControlId
            self.complianceStatus = complianceStatus
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.lastObservedAt = lastObservedAt
            self.noteText = noteText
            self.noteUpdatedAt = noteUpdatedAt
            self.noteUpdatedBy = noteUpdatedBy
            self.productArn = productArn
            self.productName = productName
            self.recordState = recordState
            self.relatedFindingsId = relatedFindingsId
            self.relatedFindingsProductArn = relatedFindingsProductArn
            self.resourceApplicationArn = resourceApplicationArn
            self.resourceApplicationName = resourceApplicationName
            self.resourceDetailsOther = resourceDetailsOther
            self.resourceId = resourceId
            self.resourcePartition = resourcePartition
            self.resourceRegion = resourceRegion
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.severityLabel = severityLabel
            self.sourceUrl = sourceUrl
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflowStatus = workflowStatus
        }

        public func validate(name: String) throws {
            try self.awsAccountId?.forEach {
                try $0.validate(name: "\(name).awsAccountId[]")
            }
            try self.awsAccountName?.forEach {
                try $0.validate(name: "\(name).awsAccountName[]")
            }
            try self.companyName?.forEach {
                try $0.validate(name: "\(name).companyName[]")
            }
            try self.complianceAssociatedStandardsId?.forEach {
                try $0.validate(name: "\(name).complianceAssociatedStandardsId[]")
            }
            try self.complianceSecurityControlId?.forEach {
                try $0.validate(name: "\(name).complianceSecurityControlId[]")
            }
            try self.complianceStatus?.forEach {
                try $0.validate(name: "\(name).complianceStatus[]")
            }
            try self.createdAt?.forEach {
                try $0.validate(name: "\(name).createdAt[]")
            }
            try self.description?.forEach {
                try $0.validate(name: "\(name).description[]")
            }
            try self.firstObservedAt?.forEach {
                try $0.validate(name: "\(name).firstObservedAt[]")
            }
            try self.generatorId?.forEach {
                try $0.validate(name: "\(name).generatorId[]")
            }
            try self.id?.forEach {
                try $0.validate(name: "\(name).id[]")
            }
            try self.lastObservedAt?.forEach {
                try $0.validate(name: "\(name).lastObservedAt[]")
            }
            try self.noteText?.forEach {
                try $0.validate(name: "\(name).noteText[]")
            }
            try self.noteUpdatedAt?.forEach {
                try $0.validate(name: "\(name).noteUpdatedAt[]")
            }
            try self.noteUpdatedBy?.forEach {
                try $0.validate(name: "\(name).noteUpdatedBy[]")
            }
            try self.productArn?.forEach {
                try $0.validate(name: "\(name).productArn[]")
            }
            try self.productName?.forEach {
                try $0.validate(name: "\(name).productName[]")
            }
            try self.recordState?.forEach {
                try $0.validate(name: "\(name).recordState[]")
            }
            try self.relatedFindingsId?.forEach {
                try $0.validate(name: "\(name).relatedFindingsId[]")
            }
            try self.relatedFindingsProductArn?.forEach {
                try $0.validate(name: "\(name).relatedFindingsProductArn[]")
            }
            try self.resourceApplicationArn?.forEach {
                try $0.validate(name: "\(name).resourceApplicationArn[]")
            }
            try self.resourceApplicationName?.forEach {
                try $0.validate(name: "\(name).resourceApplicationName[]")
            }
            try self.resourceDetailsOther?.forEach {
                try $0.validate(name: "\(name).resourceDetailsOther[]")
            }
            try self.resourceId?.forEach {
                try $0.validate(name: "\(name).resourceId[]")
            }
            try self.resourcePartition?.forEach {
                try $0.validate(name: "\(name).resourcePartition[]")
            }
            try self.resourceRegion?.forEach {
                try $0.validate(name: "\(name).resourceRegion[]")
            }
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.resourceType?.forEach {
                try $0.validate(name: "\(name).resourceType[]")
            }
            try self.severityLabel?.forEach {
                try $0.validate(name: "\(name).severityLabel[]")
            }
            try self.sourceUrl?.forEach {
                try $0.validate(name: "\(name).sourceUrl[]")
            }
            try self.title?.forEach {
                try $0.validate(name: "\(name).title[]")
            }
            try self.type?.forEach {
                try $0.validate(name: "\(name).type[]")
            }
            try self.updatedAt?.forEach {
                try $0.validate(name: "\(name).updatedAt[]")
            }
            try self.userDefinedFields?.forEach {
                try $0.validate(name: "\(name).userDefinedFields[]")
            }
            try self.verificationState?.forEach {
                try $0.validate(name: "\(name).verificationState[]")
            }
            try self.workflowStatus?.forEach {
                try $0.validate(name: "\(name).workflowStatus[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case awsAccountName = "AwsAccountName"
            case companyName = "CompanyName"
            case complianceAssociatedStandardsId = "ComplianceAssociatedStandardsId"
            case complianceSecurityControlId = "ComplianceSecurityControlId"
            case complianceStatus = "ComplianceStatus"
            case confidence = "Confidence"
            case createdAt = "CreatedAt"
            case criticality = "Criticality"
            case description = "Description"
            case firstObservedAt = "FirstObservedAt"
            case generatorId = "GeneratorId"
            case id = "Id"
            case lastObservedAt = "LastObservedAt"
            case noteText = "NoteText"
            case noteUpdatedAt = "NoteUpdatedAt"
            case noteUpdatedBy = "NoteUpdatedBy"
            case productArn = "ProductArn"
            case productName = "ProductName"
            case recordState = "RecordState"
            case relatedFindingsId = "RelatedFindingsId"
            case relatedFindingsProductArn = "RelatedFindingsProductArn"
            case resourceApplicationArn = "ResourceApplicationArn"
            case resourceApplicationName = "ResourceApplicationName"
            case resourceDetailsOther = "ResourceDetailsOther"
            case resourceId = "ResourceId"
            case resourcePartition = "ResourcePartition"
            case resourceRegion = "ResourceRegion"
            case resourceTags = "ResourceTags"
            case resourceType = "ResourceType"
            case severityLabel = "SeverityLabel"
            case sourceUrl = "SourceUrl"
            case title = "Title"
            case type = "Type"
            case updatedAt = "UpdatedAt"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case workflowStatus = "WorkflowStatus"
        }
    }

    public struct AutomationRulesMetadata: AWSDecodableShape {
        ///  A timestamp that indicates when the rule was created.  For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        ///  The principal that created a rule.
        public let createdBy: String?
        ///  A description of the rule.
        public let description: String?
        /// Specifies whether a rule is the last to be applied with respect to a finding that matches the rule criteria. This is useful when a finding  matches the criteria for multiple rules, and each rule has different actions. If a rule is terminal, Security Hub applies the rule action to a finding that matches  the rule criteria and doesn't evaluate other rules for the finding. By default, a rule isn't terminal.
        public let isTerminal: Bool?
        ///  The Amazon Resource Name (ARN) for the rule.
        public let ruleArn: String?
        ///  The name of the rule.
        public let ruleName: String?
        /// An integer ranging from 1 to 1000 that represents the order in which the rule action is applied to findings. Security Hub applies rules with lower values for this parameter first.
        public let ruleOrder: Int?
        ///  Whether the rule is active after it is created. If  this parameter is equal to ENABLED, Security Hub starts applying the rule to findings  and finding updates after the rule is created. To change the value of this parameter after creating a rule, use  BatchUpdateAutomationRules .
        public let ruleStatus: RuleStatus?
        ///  A timestamp that indicates when the rule was most recently updated.  For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, isTerminal: Bool? = nil, ruleArn: String? = nil, ruleName: String? = nil, ruleOrder: Int? = nil, ruleStatus: RuleStatus? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.isTerminal = isTerminal
            self.ruleArn = ruleArn
            self.ruleName = ruleName
            self.ruleOrder = ruleOrder
            self.ruleStatus = ruleStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case createdBy = "CreatedBy"
            case description = "Description"
            case isTerminal = "IsTerminal"
            case ruleArn = "RuleArn"
            case ruleName = "RuleName"
            case ruleOrder = "RuleOrder"
            case ruleStatus = "RuleStatus"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct AvailabilityZone: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the subnet. You can specify one subnet per Availability Zone.
        public let subnetId: String?
        /// The name of the Availability Zone.
        public let zoneName: String?

        @inlinable
        public init(subnetId: String? = nil, zoneName: String? = nil) {
            self.subnetId = subnetId
            self.zoneName = zoneName
        }

        public func validate(name: String) throws {
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
            try self.validate(self.zoneName, name: "zoneName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case subnetId = "SubnetId"
            case zoneName = "ZoneName"
        }
    }

    public struct AwsAmazonMqBrokerDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The authentication strategy used to secure the broker. The default is SIMPLE.
        public let authenticationStrategy: String?
        ///  Whether automatically upgrade new minor versions for brokers, as new versions are released and supported by Amazon MQ.  Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot.
        public let autoMinorVersionUpgrade: Bool?
        ///  The Amazon Resource Name (ARN) of the broker.
        public let brokerArn: String?
        ///  The unique ID that Amazon MQ generates for the broker.
        public let brokerId: String?
        /// The broker's name.
        public let brokerName: String?
        ///  The broker's deployment mode.
        public let deploymentMode: String?
        ///  Encryption options for the broker. Doesnâ€™t apply to RabbitMQ brokers.
        public let encryptionOptions: AwsAmazonMqBrokerEncryptionOptionsDetails?
        ///  The type of broker engine.
        public let engineType: String?
        ///  The version of the broker engine.
        public let engineVersion: String?
        ///  The broker's instance type.
        public let hostInstanceType: String?
        ///  The metadata of the Lightweight Directory Access Protocol (LDAP) server used to authenticate and authorize connections to the broker. This is an optional failover server.
        public let ldapServerMetadata: AwsAmazonMqBrokerLdapServerMetadataDetails?
        ///  Turns on Amazon CloudWatch logging for brokers.
        public let logs: AwsAmazonMqBrokerLogsDetails?
        ///  The scheduled time period (UTC) during which Amazon MQ begins to apply pending updates or patches to the broker.
        public let maintenanceWindowStartTime: AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails?
        ///  Permits connections from applications outside of the VPC that hosts the broker's subnets.
        public let publiclyAccessible: Bool?
        ///  The list of rules (one minimum, 125 maximum) that authorize connections to brokers.
        public let securityGroups: [String]?
        ///  The broker's storage type.
        public let storageType: String?
        ///  The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones.
        public let subnetIds: [String]?
        ///  The list of all broker usernames for the specified broker. Doesn't apply to RabbitMQ brokers.
        public let users: [AwsAmazonMqBrokerUsersDetails]?

        @inlinable
        public init(authenticationStrategy: String? = nil, autoMinorVersionUpgrade: Bool? = nil, brokerArn: String? = nil, brokerId: String? = nil, brokerName: String? = nil, deploymentMode: String? = nil, encryptionOptions: AwsAmazonMqBrokerEncryptionOptionsDetails? = nil, engineType: String? = nil, engineVersion: String? = nil, hostInstanceType: String? = nil, ldapServerMetadata: AwsAmazonMqBrokerLdapServerMetadataDetails? = nil, logs: AwsAmazonMqBrokerLogsDetails? = nil, maintenanceWindowStartTime: AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails? = nil, publiclyAccessible: Bool? = nil, securityGroups: [String]? = nil, storageType: String? = nil, subnetIds: [String]? = nil, users: [AwsAmazonMqBrokerUsersDetails]? = nil) {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerName = brokerName
            self.deploymentMode = deploymentMode
            self.encryptionOptions = encryptionOptions
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.publiclyAccessible = publiclyAccessible
            self.securityGroups = securityGroups
            self.storageType = storageType
            self.subnetIds = subnetIds
            self.users = users
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationStrategy, name: "authenticationStrategy", parent: name, pattern: "\\S")
            try self.validate(self.brokerArn, name: "brokerArn", parent: name, pattern: "\\S")
            try self.validate(self.brokerId, name: "brokerId", parent: name, pattern: "\\S")
            try self.validate(self.brokerName, name: "brokerName", parent: name, pattern: "\\S")
            try self.validate(self.deploymentMode, name: "deploymentMode", parent: name, pattern: "\\S")
            try self.encryptionOptions?.validate(name: "\(name).encryptionOptions")
            try self.validate(self.engineType, name: "engineType", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.hostInstanceType, name: "hostInstanceType", parent: name, pattern: "\\S")
            try self.ldapServerMetadata?.validate(name: "\(name).ldapServerMetadata")
            try self.logs?.validate(name: "\(name).logs")
            try self.maintenanceWindowStartTime?.validate(name: "\(name).maintenanceWindowStartTime")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.storageType, name: "storageType", parent: name, pattern: "\\S")
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "\\S")
            }
            try self.users?.forEach {
                try $0.validate(name: "\(name).users[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationStrategy = "AuthenticationStrategy"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case brokerArn = "BrokerArn"
            case brokerId = "BrokerId"
            case brokerName = "BrokerName"
            case deploymentMode = "DeploymentMode"
            case encryptionOptions = "EncryptionOptions"
            case engineType = "EngineType"
            case engineVersion = "EngineVersion"
            case hostInstanceType = "HostInstanceType"
            case ldapServerMetadata = "LdapServerMetadata"
            case logs = "Logs"
            case maintenanceWindowStartTime = "MaintenanceWindowStartTime"
            case publiclyAccessible = "PubliclyAccessible"
            case securityGroups = "SecurityGroups"
            case storageType = "StorageType"
            case subnetIds = "SubnetIds"
            case users = "Users"
        }
    }

    public struct AwsAmazonMqBrokerEncryptionOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The KMS key thatâ€™s used to encrypt your data at rest. If not provided, Amazon MQ will use a  default KMS key to encrypt your data.
        public let kmsKeyId: String?
        ///  Specifies that an KMS key should be used for at-rest encryption. Set to true by default  if no value is provided (for example, for RabbitMQ brokers).
        public let useAwsOwnedKey: Bool?

        @inlinable
        public init(kmsKeyId: String? = nil, useAwsOwnedKey: Bool? = nil) {
            self.kmsKeyId = kmsKeyId
            self.useAwsOwnedKey = useAwsOwnedKey
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case useAwsOwnedKey = "UseAwsOwnedKey"
        }
    }

    public struct AwsAmazonMqBrokerLdapServerMetadataDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the location of the LDAP server, such as Amazon Web Services Directory Service for Microsoft Active Directory.
        public let hosts: [String]?
        ///  The distinguished name of the node in the directory information tree (DIT) to search for roles or groups.
        public let roleBase: String?
        ///  The group name attribute in a role entry whose value is the name of that role.
        public let roleName: String?
        ///  The LDAP search filter used to find roles within the roleBase.
        public let roleSearchMatching: String?
        ///  The directory search scope for the role. If set to true, the scope is to search the entire subtree.
        public let roleSearchSubtree: Bool?
        ///  A username for the service account, which is an account in your LDAP server that has access to initiate a connection.
        public let serviceAccountUsername: String?
        ///  Selects a particular subtree of the directory information tree (DIT) to search for user entries.
        public let userBase: String?
        ///  The name of the LDAP attribute in the user's directory entry for the user's group membership.
        public let userRoleName: String?
        ///  The LDAP search filter used to find users within the userBase.
        public let userSearchMatching: String?
        ///  The directory search scope for the user. If set to true, the scope is to search the entire subtree.
        public let userSearchSubtree: Bool?

        @inlinable
        public init(hosts: [String]? = nil, roleBase: String? = nil, roleName: String? = nil, roleSearchMatching: String? = nil, roleSearchSubtree: Bool? = nil, serviceAccountUsername: String? = nil, userBase: String? = nil, userRoleName: String? = nil, userSearchMatching: String? = nil, userSearchSubtree: Bool? = nil) {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }

        public func validate(name: String) throws {
            try self.hosts?.forEach {
                try validate($0, name: "hosts[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.roleBase, name: "roleBase", parent: name, pattern: "\\S")
            try self.validate(self.roleName, name: "roleName", parent: name, pattern: "\\S")
            try self.validate(self.roleSearchMatching, name: "roleSearchMatching", parent: name, pattern: "\\S")
            try self.validate(self.serviceAccountUsername, name: "serviceAccountUsername", parent: name, pattern: "\\S")
            try self.validate(self.userBase, name: "userBase", parent: name, pattern: "\\S")
            try self.validate(self.userRoleName, name: "userRoleName", parent: name, pattern: "\\S")
            try self.validate(self.userSearchMatching, name: "userSearchMatching", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hosts = "Hosts"
            case roleBase = "RoleBase"
            case roleName = "RoleName"
            case roleSearchMatching = "RoleSearchMatching"
            case roleSearchSubtree = "RoleSearchSubtree"
            case serviceAccountUsername = "ServiceAccountUsername"
            case userBase = "UserBase"
            case userRoleName = "UserRoleName"
            case userSearchMatching = "UserSearchMatching"
            case userSearchSubtree = "UserSearchSubtree"
        }
    }

    public struct AwsAmazonMqBrokerLogsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Activates audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Doesn't apply to RabbitMQ brokers.
        public let audit: Bool?
        ///  The location of the CloudWatch Logs log group where audit logs are sent.
        public let auditLogGroup: String?
        ///  Activates general logging.
        public let general: Bool?
        ///  The location of the CloudWatch Logs log group where general logs are sent.
        public let generalLogGroup: String?
        ///  The list of information about logs that are to be turned on for the specified broker.
        public let pending: AwsAmazonMqBrokerLogsPendingDetails?

        @inlinable
        public init(audit: Bool? = nil, auditLogGroup: String? = nil, general: Bool? = nil, generalLogGroup: String? = nil, pending: AwsAmazonMqBrokerLogsPendingDetails? = nil) {
            self.audit = audit
            self.auditLogGroup = auditLogGroup
            self.general = general
            self.generalLogGroup = generalLogGroup
            self.pending = pending
        }

        public func validate(name: String) throws {
            try self.validate(self.auditLogGroup, name: "auditLogGroup", parent: name, pattern: "\\S")
            try self.validate(self.generalLogGroup, name: "generalLogGroup", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case audit = "Audit"
            case auditLogGroup = "AuditLogGroup"
            case general = "General"
            case generalLogGroup = "GeneralLogGroup"
            case pending = "Pending"
        }
    }

    public struct AwsAmazonMqBrokerLogsPendingDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Activates audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Doesn't apply  to RabbitMQ brokers.
        public let audit: Bool?
        ///  Activates general logging.
        public let general: Bool?

        @inlinable
        public init(audit: Bool? = nil, general: Bool? = nil) {
            self.audit = audit
            self.general = general
        }

        private enum CodingKeys: String, CodingKey {
            case audit = "Audit"
            case general = "General"
        }
    }

    public struct AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The day of the week on which the maintenance window falls.
        public let dayOfWeek: String?
        ///  The time, in 24-hour format, on which the maintenance window falls.
        public let timeOfDay: String?
        ///  The time zone in either the Country/City format or the UTC offset format. UTC is the default format.
        public let timeZone: String?

        @inlinable
        public init(dayOfWeek: String? = nil, timeOfDay: String? = nil, timeZone: String? = nil) {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
            self.timeZone = timeZone
        }

        public func validate(name: String) throws {
            try self.validate(self.dayOfWeek, name: "dayOfWeek", parent: name, pattern: "\\S")
            try self.validate(self.timeOfDay, name: "timeOfDay", parent: name, pattern: "\\S")
            try self.validate(self.timeZone, name: "timeZone", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfWeek = "DayOfWeek"
            case timeOfDay = "TimeOfDay"
            case timeZone = "TimeZone"
        }
    }

    public struct AwsAmazonMqBrokerUsersDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The type of change pending for the broker user.
        public let pendingChange: String?
        ///  The username of the broker user.
        public let username: String?

        @inlinable
        public init(pendingChange: String? = nil, username: String? = nil) {
            self.pendingChange = pendingChange
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.pendingChange, name: "pendingChange", parent: name, pattern: "\\S")
            try self.validate(self.username, name: "username", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case pendingChange = "PendingChange"
            case username = "Username"
        }
    }

    public struct AwsApiCallAction: AWSEncodableShape & AWSDecodableShape {
        /// Identifies the resources that were affected by the API call.
        public let affectedResources: [String: String]?
        /// The name of the API method that was issued. Length Constraints: 128.
        public let api: String?
        /// Indicates whether the API call originated from a remote IP address (remoteip) or from a DNS domain (domain).
        public let callerType: String?
        /// Provided if CallerType is domain. Provides information about the DNS domain that the API call originated from.
        public let domainDetails: AwsApiCallActionDomainDetails?
        /// A timestamp that indicates when the API call was first observed. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let firstSeen: String?
        /// A timestamp that indicates when the API call was most recently observed. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastSeen: String?
        /// Provided if CallerType is remoteip. Provides information about the remote IP address that the API call originated from.
        public let remoteIpDetails: ActionRemoteIpDetails?
        /// The name of the Amazon Web Services service that the API method belongs to. Length Constraints: 128.
        public let serviceName: String?

        @inlinable
        public init(affectedResources: [String: String]? = nil, api: String? = nil, callerType: String? = nil, domainDetails: AwsApiCallActionDomainDetails? = nil, firstSeen: String? = nil, lastSeen: String? = nil, remoteIpDetails: ActionRemoteIpDetails? = nil, serviceName: String? = nil) {
            self.affectedResources = affectedResources
            self.api = api
            self.callerType = callerType
            self.domainDetails = domainDetails
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
            self.remoteIpDetails = remoteIpDetails
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.affectedResources?.forEach {
                try validate($0.key, name: "affectedResources.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "affectedResources[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.api, name: "api", parent: name, pattern: "\\S")
            try self.validate(self.callerType, name: "callerType", parent: name, pattern: "\\S")
            try self.domainDetails?.validate(name: "\(name).domainDetails")
            try self.validate(self.firstSeen, name: "firstSeen", parent: name, pattern: "\\S")
            try self.validate(self.lastSeen, name: "lastSeen", parent: name, pattern: "\\S")
            try self.remoteIpDetails?.validate(name: "\(name).remoteIpDetails")
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case affectedResources = "AffectedResources"
            case api = "Api"
            case callerType = "CallerType"
            case domainDetails = "DomainDetails"
            case firstSeen = "FirstSeen"
            case lastSeen = "LastSeen"
            case remoteIpDetails = "RemoteIpDetails"
            case serviceName = "ServiceName"
        }
    }

    public struct AwsApiCallActionDomainDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the DNS domain that issued the API call. Length Constraints: 128.
        public let domain: String?

        @inlinable
        public init(domain: String? = nil) {
            self.domain = domain
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
        }
    }

    public struct AwsApiGatewayAccessLogSettings: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the CloudWatch Logs log group that receives the access logs.
        public let destinationArn: String?
        /// A single-line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public let format: String?

        @inlinable
        public init(destinationArn: String? = nil, format: String? = nil) {
            self.destinationArn = destinationArn
            self.format = format
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "\\S")
            try self.validate(self.format, name: "format", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn = "DestinationArn"
            case format = "Format"
        }
    }

    public struct AwsApiGatewayCanarySettings: AWSEncodableShape & AWSDecodableShape {
        /// The deployment identifier for the canary deployment.
        public let deploymentId: String?
        /// The percentage of traffic that is diverted to a canary deployment.
        public let percentTraffic: Double?
        /// Stage variables that are overridden in the canary release deployment. The variables include new stage variables that are introduced in the canary. Each variable is represented as a string-to-string map between the stage variable name and the variable value.
        public let stageVariableOverrides: [String: String]?
        /// Indicates whether the canary deployment uses the stage cache.
        public let useStageCache: Bool?

        @inlinable
        public init(deploymentId: String? = nil, percentTraffic: Double? = nil, stageVariableOverrides: [String: String]? = nil, useStageCache: Bool? = nil) {
            self.deploymentId = deploymentId
            self.percentTraffic = percentTraffic
            self.stageVariableOverrides = stageVariableOverrides
            self.useStageCache = useStageCache
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "\\S")
            try self.stageVariableOverrides?.forEach {
                try validate($0.key, name: "stageVariableOverrides.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "stageVariableOverrides[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "DeploymentId"
            case percentTraffic = "PercentTraffic"
            case stageVariableOverrides = "StageVariableOverrides"
            case useStageCache = "UseStageCache"
        }
    }

    public struct AwsApiGatewayEndpointConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of endpoint types for the REST API. For an edge-optimized API, the endpoint type is EDGE. For a Regional API, the endpoint type is REGIONAL. For a private API, the endpoint type is PRIVATE.
        public let types: [String]?

        @inlinable
        public init(types: [String]? = nil) {
            self.types = types
        }

        public func validate(name: String) throws {
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case types = "Types"
        }
    }

    public struct AwsApiGatewayMethodSettings: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the cached responses are encrypted.
        public let cacheDataEncrypted: Bool?
        /// Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.
        public let cacheTtlInSeconds: Int?
        /// Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.
        public let cachingEnabled: Bool?
        /// Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.
        public let dataTraceEnabled: Bool?
        /// The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.
        public let httpMethod: String?
        /// The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs. If the logging level is ERROR, then the logs only include error-level entries. If the logging level is INFO, then the logs include both ERROR events and extra informational events. Valid values: OFF | ERROR | INFO
        public let loggingLevel: String?
        /// Indicates whether CloudWatch metrics are enabled for the method.
        public let metricsEnabled: Bool?
        /// Indicates whether authorization is required for a cache invalidation request.
        public let requireAuthorizationForCacheControl: Bool?
        /// The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash. For example, the path value /resource/subresource must be encoded as /~1resource~1subresource. To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.
        public let resourcePath: String?
        /// The throttling burst limit for the method.
        public let throttlingBurstLimit: Int?
        /// The throttling rate limit for the method.
        public let throttlingRateLimit: Double?
        /// Indicates how to handle unauthorized requests for cache invalidation. Valid values: FAIL_WITH_403 | SUCCEED_WITH_RESPONSE_HEADER | SUCCEED_WITHOUT_RESPONSE_HEADER
        public let unauthorizedCacheControlHeaderStrategy: String?

        @inlinable
        public init(cacheDataEncrypted: Bool? = nil, cacheTtlInSeconds: Int? = nil, cachingEnabled: Bool? = nil, dataTraceEnabled: Bool? = nil, httpMethod: String? = nil, loggingLevel: String? = nil, metricsEnabled: Bool? = nil, requireAuthorizationForCacheControl: Bool? = nil, resourcePath: String? = nil, throttlingBurstLimit: Int? = nil, throttlingRateLimit: Double? = nil, unauthorizedCacheControlHeaderStrategy: String? = nil) {
            self.cacheDataEncrypted = cacheDataEncrypted
            self.cacheTtlInSeconds = cacheTtlInSeconds
            self.cachingEnabled = cachingEnabled
            self.dataTraceEnabled = dataTraceEnabled
            self.httpMethod = httpMethod
            self.loggingLevel = loggingLevel
            self.metricsEnabled = metricsEnabled
            self.requireAuthorizationForCacheControl = requireAuthorizationForCacheControl
            self.resourcePath = resourcePath
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
            self.unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy
        }

        public func validate(name: String) throws {
            try self.validate(self.httpMethod, name: "httpMethod", parent: name, pattern: "\\S")
            try self.validate(self.loggingLevel, name: "loggingLevel", parent: name, pattern: "\\S")
            try self.validate(self.resourcePath, name: "resourcePath", parent: name, pattern: "\\S")
            try self.validate(self.unauthorizedCacheControlHeaderStrategy, name: "unauthorizedCacheControlHeaderStrategy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cacheDataEncrypted = "CacheDataEncrypted"
            case cacheTtlInSeconds = "CacheTtlInSeconds"
            case cachingEnabled = "CachingEnabled"
            case dataTraceEnabled = "DataTraceEnabled"
            case httpMethod = "HttpMethod"
            case loggingLevel = "LoggingLevel"
            case metricsEnabled = "MetricsEnabled"
            case requireAuthorizationForCacheControl = "RequireAuthorizationForCacheControl"
            case resourcePath = "ResourcePath"
            case throttlingBurstLimit = "ThrottlingBurstLimit"
            case throttlingRateLimit = "ThrottlingRateLimit"
            case unauthorizedCacheControlHeaderStrategy = "UnauthorizedCacheControlHeaderStrategy"
        }
    }

    public struct AwsApiGatewayRestApiDetails: AWSEncodableShape & AWSDecodableShape {
        /// The source of the API key for metering requests according to a usage plan.  HEADER indicates whether to read the API key from the X-API-Key header of a request.  AUTHORIZER indicates whether to read the API key from the UsageIdentifierKey from a custom authorizer.
        public let apiKeySource: String?
        /// The list of binary media types supported by the REST API.
        public let binaryMediaTypes: [String]?
        /// Indicates when the API was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdDate: String?
        /// A description of the REST API.
        public let description: String?
        /// The endpoint configuration of the REST API.
        public let endpointConfiguration: AwsApiGatewayEndpointConfiguration?
        /// The identifier of the REST API.
        public let id: String?
        /// The minimum size in bytes of a payload before compression is enabled. If null, then compression is disabled. If 0, then all payloads are compressed.
        public let minimumCompressionSize: Int?
        /// The name of the REST API.
        public let name: String?
        /// The version identifier for the REST API.
        public let version: String?

        @inlinable
        public init(apiKeySource: String? = nil, binaryMediaTypes: [String]? = nil, createdDate: String? = nil, description: String? = nil, endpointConfiguration: AwsApiGatewayEndpointConfiguration? = nil, id: String? = nil, minimumCompressionSize: Int? = nil, name: String? = nil, version: String? = nil) {
            self.apiKeySource = apiKeySource
            self.binaryMediaTypes = binaryMediaTypes
            self.createdDate = createdDate
            self.description = description
            self.endpointConfiguration = endpointConfiguration
            self.id = id
            self.minimumCompressionSize = minimumCompressionSize
            self.name = name
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.apiKeySource, name: "apiKeySource", parent: name, pattern: "\\S")
            try self.binaryMediaTypes?.forEach {
                try validate($0, name: "binaryMediaTypes[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.createdDate, name: "createdDate", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.endpointConfiguration?.validate(name: "\(name).endpointConfiguration")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySource = "ApiKeySource"
            case binaryMediaTypes = "BinaryMediaTypes"
            case createdDate = "CreatedDate"
            case description = "Description"
            case endpointConfiguration = "EndpointConfiguration"
            case id = "Id"
            case minimumCompressionSize = "MinimumCompressionSize"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct AwsApiGatewayStageDetails: AWSEncodableShape & AWSDecodableShape {
        /// Settings for logging access for the stage.
        public let accessLogSettings: AwsApiGatewayAccessLogSettings?
        /// Indicates whether a cache cluster is enabled for the stage.
        public let cacheClusterEnabled: Bool?
        /// If a cache cluster is enabled, the size of the cache cluster.
        public let cacheClusterSize: String?
        /// If a cache cluster is enabled, the status of the cache cluster.
        public let cacheClusterStatus: String?
        /// Information about settings for canary deployment in the stage.
        public let canarySettings: AwsApiGatewayCanarySettings?
        /// The identifier of the client certificate for the stage.
        public let clientCertificateId: String?
        /// Indicates when the stage was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdDate: String?
        /// The identifier of the deployment that the stage points to.
        public let deploymentId: String?
        /// A description of the stage.
        public let description: String?
        /// The version of the API documentation that is associated with the stage.
        public let documentationVersion: String?
        /// Indicates when the stage was most recently updated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastUpdatedDate: String?
        /// Defines the method settings for the stage.
        public let methodSettings: [AwsApiGatewayMethodSettings]?
        /// The name of the stage.
        public let stageName: String?
        /// Indicates whether active tracing with X-Ray is enabled for the stage.
        public let tracingEnabled: Bool?
        /// A map that defines the stage variables for the stage. Variable names can have alphanumeric and underscore characters. Variable values can contain the following characters:   Uppercase and lowercase letters   Numbers   Special characters -._~:/?#&=,
        public let variables: [String: String]?
        /// The ARN of the web ACL associated with the stage.
        public let webAclArn: String?

        @inlinable
        public init(accessLogSettings: AwsApiGatewayAccessLogSettings? = nil, cacheClusterEnabled: Bool? = nil, cacheClusterSize: String? = nil, cacheClusterStatus: String? = nil, canarySettings: AwsApiGatewayCanarySettings? = nil, clientCertificateId: String? = nil, createdDate: String? = nil, deploymentId: String? = nil, description: String? = nil, documentationVersion: String? = nil, lastUpdatedDate: String? = nil, methodSettings: [AwsApiGatewayMethodSettings]? = nil, stageName: String? = nil, tracingEnabled: Bool? = nil, variables: [String: String]? = nil, webAclArn: String? = nil) {
            self.accessLogSettings = accessLogSettings
            self.cacheClusterEnabled = cacheClusterEnabled
            self.cacheClusterSize = cacheClusterSize
            self.cacheClusterStatus = cacheClusterStatus
            self.canarySettings = canarySettings
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.description = description
            self.documentationVersion = documentationVersion
            self.lastUpdatedDate = lastUpdatedDate
            self.methodSettings = methodSettings
            self.stageName = stageName
            self.tracingEnabled = tracingEnabled
            self.variables = variables
            self.webAclArn = webAclArn
        }

        public func validate(name: String) throws {
            try self.accessLogSettings?.validate(name: "\(name).accessLogSettings")
            try self.validate(self.cacheClusterSize, name: "cacheClusterSize", parent: name, pattern: "\\S")
            try self.validate(self.cacheClusterStatus, name: "cacheClusterStatus", parent: name, pattern: "\\S")
            try self.canarySettings?.validate(name: "\(name).canarySettings")
            try self.validate(self.clientCertificateId, name: "clientCertificateId", parent: name, pattern: "\\S")
            try self.validate(self.createdDate, name: "createdDate", parent: name, pattern: "\\S")
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.documentationVersion, name: "documentationVersion", parent: name, pattern: "\\S")
            try self.validate(self.lastUpdatedDate, name: "lastUpdatedDate", parent: name, pattern: "\\S")
            try self.methodSettings?.forEach {
                try $0.validate(name: "\(name).methodSettings[]")
            }
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "\\S")
            try self.variables?.forEach {
                try validate($0.key, name: "variables.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "variables[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.webAclArn, name: "webAclArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogSettings = "AccessLogSettings"
            case cacheClusterEnabled = "CacheClusterEnabled"
            case cacheClusterSize = "CacheClusterSize"
            case cacheClusterStatus = "CacheClusterStatus"
            case canarySettings = "CanarySettings"
            case clientCertificateId = "ClientCertificateId"
            case createdDate = "CreatedDate"
            case deploymentId = "DeploymentId"
            case description = "Description"
            case documentationVersion = "DocumentationVersion"
            case lastUpdatedDate = "LastUpdatedDate"
            case methodSettings = "MethodSettings"
            case stageName = "StageName"
            case tracingEnabled = "TracingEnabled"
            case variables = "Variables"
            case webAclArn = "WebAclArn"
        }
    }

    public struct AwsApiGatewayV2ApiDetails: AWSEncodableShape & AWSDecodableShape {
        /// The URI of the API.  Uses the format  .execute-api..amazonaws.com  The stage name is typically appended to the URI to form a complete path to a deployed API stage.
        public let apiEndpoint: String?
        /// The identifier of the API.
        public let apiId: String?
        /// An API key selection expression. Supported only for WebSocket APIs.
        public let apiKeySelectionExpression: String?
        /// A cross-origin resource sharing (CORS) configuration. Supported only for HTTP APIs.
        public let corsConfiguration: AwsCorsConfiguration?
        /// Indicates when the API was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdDate: String?
        /// A description of the API.
        public let description: String?
        /// The name of the API.
        public let name: String?
        /// The API protocol for the API. Valid values: WEBSOCKET | HTTP
        public let protocolType: String?
        /// The route selection expression for the API. For HTTP APIs, must be ${request.method} ${request.path}. This is the default value for HTTP APIs. For WebSocket APIs, there is no default value.
        public let routeSelectionExpression: String?
        /// The version identifier for the API.
        public let version: String?

        @inlinable
        public init(apiEndpoint: String? = nil, apiId: String? = nil, apiKeySelectionExpression: String? = nil, corsConfiguration: AwsCorsConfiguration? = nil, createdDate: String? = nil, description: String? = nil, name: String? = nil, protocolType: String? = nil, routeSelectionExpression: String? = nil, version: String? = nil) {
            self.apiEndpoint = apiEndpoint
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.apiEndpoint, name: "apiEndpoint", parent: name, pattern: "\\S")
            try self.validate(self.apiId, name: "apiId", parent: name, pattern: "\\S")
            try self.validate(self.apiKeySelectionExpression, name: "apiKeySelectionExpression", parent: name, pattern: "\\S")
            try self.corsConfiguration?.validate(name: "\(name).corsConfiguration")
            try self.validate(self.createdDate, name: "createdDate", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.protocolType, name: "protocolType", parent: name, pattern: "\\S")
            try self.validate(self.routeSelectionExpression, name: "routeSelectionExpression", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case apiEndpoint = "ApiEndpoint"
            case apiId = "ApiId"
            case apiKeySelectionExpression = "ApiKeySelectionExpression"
            case corsConfiguration = "CorsConfiguration"
            case createdDate = "CreatedDate"
            case description = "Description"
            case name = "Name"
            case protocolType = "ProtocolType"
            case routeSelectionExpression = "RouteSelectionExpression"
            case version = "Version"
        }
    }

    public struct AwsApiGatewayV2RouteSettings: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether data trace logging is enabled. Data trace logging affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.
        public let dataTraceEnabled: Bool?
        /// Indicates whether detailed metrics are enabled.
        public let detailedMetricsEnabled: Bool?
        /// The logging level. The logging level affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs. If the logging level is ERROR, then the logs only include error-level entries. If the logging level is INFO, then the logs include both ERROR events and extra informational events. Valid values: OFF | ERROR | INFO
        public let loggingLevel: String?
        /// The throttling burst limit.
        public let throttlingBurstLimit: Int?
        /// The throttling rate limit.
        public let throttlingRateLimit: Double?

        @inlinable
        public init(dataTraceEnabled: Bool? = nil, detailedMetricsEnabled: Bool? = nil, loggingLevel: String? = nil, throttlingBurstLimit: Int? = nil, throttlingRateLimit: Double? = nil) {
            self.dataTraceEnabled = dataTraceEnabled
            self.detailedMetricsEnabled = detailedMetricsEnabled
            self.loggingLevel = loggingLevel
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.loggingLevel, name: "loggingLevel", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataTraceEnabled = "DataTraceEnabled"
            case detailedMetricsEnabled = "DetailedMetricsEnabled"
            case loggingLevel = "LoggingLevel"
            case throttlingBurstLimit = "ThrottlingBurstLimit"
            case throttlingRateLimit = "ThrottlingRateLimit"
        }
    }

    public struct AwsApiGatewayV2StageDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about settings for logging access for the stage.
        public let accessLogSettings: AwsApiGatewayAccessLogSettings?
        /// Indicates whether the stage is managed by API Gateway.
        public let apiGatewayManaged: Bool?
        /// Indicates whether updates to an API automatically trigger a new deployment.
        public let autoDeploy: Bool?
        /// The identifier of a client certificate for a stage. Supported only for WebSocket API calls.
        public let clientCertificateId: String?
        /// Indicates when the stage was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdDate: String?
        /// Default route settings for the stage.
        public let defaultRouteSettings: AwsApiGatewayV2RouteSettings?
        /// The identifier of the deployment that the stage is associated with.
        public let deploymentId: String?
        /// The description of the stage.
        public let description: String?
        /// The status of the last deployment of a stage. Supported only if the stage has automatic deployment enabled.
        public let lastDeploymentStatusMessage: String?
        /// Indicates when the stage was most recently updated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastUpdatedDate: String?
        /// The route settings for the stage.
        public let routeSettings: AwsApiGatewayV2RouteSettings?
        /// The name of the stage.
        public let stageName: String?
        /// A map that defines the stage variables for the stage. Variable names can have alphanumeric and underscore characters. Variable values can contain the following characters:   Uppercase and lowercase letters   Numbers   Special characters -._~:/?#&=,
        public let stageVariables: [String: String]?

        @inlinable
        public init(accessLogSettings: AwsApiGatewayAccessLogSettings? = nil, apiGatewayManaged: Bool? = nil, autoDeploy: Bool? = nil, clientCertificateId: String? = nil, createdDate: String? = nil, defaultRouteSettings: AwsApiGatewayV2RouteSettings? = nil, deploymentId: String? = nil, description: String? = nil, lastDeploymentStatusMessage: String? = nil, lastUpdatedDate: String? = nil, routeSettings: AwsApiGatewayV2RouteSettings? = nil, stageName: String? = nil, stageVariables: [String: String]? = nil) {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
        }

        public func validate(name: String) throws {
            try self.accessLogSettings?.validate(name: "\(name).accessLogSettings")
            try self.validate(self.clientCertificateId, name: "clientCertificateId", parent: name, pattern: "\\S")
            try self.validate(self.createdDate, name: "createdDate", parent: name, pattern: "\\S")
            try self.defaultRouteSettings?.validate(name: "\(name).defaultRouteSettings")
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.lastDeploymentStatusMessage, name: "lastDeploymentStatusMessage", parent: name, pattern: "\\S")
            try self.validate(self.lastUpdatedDate, name: "lastUpdatedDate", parent: name, pattern: "\\S")
            try self.routeSettings?.validate(name: "\(name).routeSettings")
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "\\S")
            try self.stageVariables?.forEach {
                try validate($0.key, name: "stageVariables.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "stageVariables[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogSettings = "AccessLogSettings"
            case apiGatewayManaged = "ApiGatewayManaged"
            case autoDeploy = "AutoDeploy"
            case clientCertificateId = "ClientCertificateId"
            case createdDate = "CreatedDate"
            case defaultRouteSettings = "DefaultRouteSettings"
            case deploymentId = "DeploymentId"
            case description = "Description"
            case lastDeploymentStatusMessage = "LastDeploymentStatusMessage"
            case lastUpdatedDate = "LastUpdatedDate"
            case routeSettings = "RouteSettings"
            case stageName = "StageName"
            case stageVariables = "StageVariables"
        }
    }

    public struct AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The type of security configuration for your GraphQL API: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
        public let authenticationType: String?
        ///  The configuration for Lambda function authorization.
        public let lambdaAuthorizerConfig: AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails?
        ///  The OpenID Connect configuration.
        public let openIdConnectConfig: AwsAppSyncGraphQlApiOpenIdConnectConfigDetails?
        ///  The Amazon Cognito user pools configuration.
        public let userPoolConfig: AwsAppSyncGraphQlApiUserPoolConfigDetails?

        @inlinable
        public init(authenticationType: String? = nil, lambdaAuthorizerConfig: AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails? = nil, openIdConnectConfig: AwsAppSyncGraphQlApiOpenIdConnectConfigDetails? = nil, userPoolConfig: AwsAppSyncGraphQlApiUserPoolConfigDetails? = nil) {
            self.authenticationType = authenticationType
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.openIdConnectConfig = openIdConnectConfig
            self.userPoolConfig = userPoolConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationType, name: "authenticationType", parent: name, pattern: "\\S")
            try self.lambdaAuthorizerConfig?.validate(name: "\(name).lambdaAuthorizerConfig")
            try self.openIdConnectConfig?.validate(name: "\(name).openIdConnectConfig")
            try self.userPoolConfig?.validate(name: "\(name).userPoolConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "AuthenticationType"
            case lambdaAuthorizerConfig = "LambdaAuthorizerConfig"
            case openIdConnectConfig = "OpenIdConnectConfig"
            case userPoolConfig = "UserPoolConfig"
        }
    }

    public struct AwsAppSyncGraphQlApiDetails: AWSEncodableShape & AWSDecodableShape {
        ///  A list of additional authentication providers for the GraphQL API.
        public let additionalAuthenticationProviders: [AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails]?
        ///  The unique identifier for the API.
        public let apiId: String?
        /// The Amazon Resource Name (ARN) of the API.
        public let arn: String?
        /// The type of security configuration for your GraphQL API: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
        public let authenticationType: String?
        /// The unique identifier for the API.
        public let id: String?
        /// Specifies the configuration for Lambda function authorization.
        public let lambdaAuthorizerConfig: AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails?
        ///  The Amazon CloudWatch Logs configuration.
        public let logConfig: AwsAppSyncGraphQlApiLogConfigDetails?
        /// The API name.
        public let name: String?
        /// Specifies the authorization configuration for using an OpenID Connect compliant service with an AppSync GraphQL API endpoint.
        public let openIdConnectConfig: AwsAppSyncGraphQlApiOpenIdConnectConfigDetails?
        /// The Amazon Cognito user pools configuration.
        public let userPoolConfig: AwsAppSyncGraphQlApiUserPoolConfigDetails?
        ///  The Amazon Resource Name (ARN) of the WAF web access control list (web ACL) associated with this  GraphQL API, if one exists.
        public let wafWebAclArn: String?
        /// Indicates whether to use X-Ray tracing for the GraphQL API.
        public let xrayEnabled: Bool?

        @inlinable
        public init(additionalAuthenticationProviders: [AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails]? = nil, apiId: String? = nil, arn: String? = nil, authenticationType: String? = nil, id: String? = nil, lambdaAuthorizerConfig: AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails? = nil, logConfig: AwsAppSyncGraphQlApiLogConfigDetails? = nil, name: String? = nil, openIdConnectConfig: AwsAppSyncGraphQlApiOpenIdConnectConfigDetails? = nil, userPoolConfig: AwsAppSyncGraphQlApiUserPoolConfigDetails? = nil, wafWebAclArn: String? = nil, xrayEnabled: Bool? = nil) {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiId = apiId
            self.arn = arn
            self.authenticationType = authenticationType
            self.id = id
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.logConfig = logConfig
            self.name = name
            self.openIdConnectConfig = openIdConnectConfig
            self.userPoolConfig = userPoolConfig
            self.wafWebAclArn = wafWebAclArn
            self.xrayEnabled = xrayEnabled
        }

        public func validate(name: String) throws {
            try self.additionalAuthenticationProviders?.forEach {
                try $0.validate(name: "\(name).additionalAuthenticationProviders[]")
            }
            try self.validate(self.apiId, name: "apiId", parent: name, pattern: "\\S")
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.authenticationType, name: "authenticationType", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.lambdaAuthorizerConfig?.validate(name: "\(name).lambdaAuthorizerConfig")
            try self.logConfig?.validate(name: "\(name).logConfig")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.openIdConnectConfig?.validate(name: "\(name).openIdConnectConfig")
            try self.userPoolConfig?.validate(name: "\(name).userPoolConfig")
            try self.validate(self.wafWebAclArn, name: "wafWebAclArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAuthenticationProviders = "AdditionalAuthenticationProviders"
            case apiId = "ApiId"
            case arn = "Arn"
            case authenticationType = "AuthenticationType"
            case id = "Id"
            case lambdaAuthorizerConfig = "LambdaAuthorizerConfig"
            case logConfig = "LogConfig"
            case name = "Name"
            case openIdConnectConfig = "OpenIdConnectConfig"
            case userPoolConfig = "UserPoolConfig"
            case wafWebAclArn = "WafWebAclArn"
            case xrayEnabled = "XrayEnabled"
        }
    }

    public struct AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The number of seconds a response should be cached for. The default is 5 minutes (300 seconds).
        public let authorizerResultTtlInSeconds: Int?
        ///  The Amazon Resource Name (ARN) of the Lambda function to be called for authorization. This can be a  standard Lambda ARN, a version ARN (.../v3), or an alias ARN.
        public let authorizerUri: String?
        ///  A regular expression for validation of tokens before the Lambda function is called.
        public let identityValidationExpression: String?

        @inlinable
        public init(authorizerResultTtlInSeconds: Int? = nil, authorizerUri: String? = nil, identityValidationExpression: String? = nil) {
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerUri = authorizerUri
            self.identityValidationExpression = identityValidationExpression
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizerUri, name: "authorizerUri", parent: name, pattern: "\\S")
            try self.validate(self.identityValidationExpression, name: "identityValidationExpression", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerResultTtlInSeconds = "AuthorizerResultTtlInSeconds"
            case authorizerUri = "AuthorizerUri"
            case identityValidationExpression = "IdentityValidationExpression"
        }
    }

    public struct AwsAppSyncGraphQlApiLogConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the service role that AppSync assumes to publish to CloudWatch Logs  in your account.
        public let cloudWatchLogsRoleArn: String?
        ///  Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates,  regardless of logging level.
        public let excludeVerboseContent: Bool?
        ///  The field logging level.
        public let fieldLogLevel: String?

        @inlinable
        public init(cloudWatchLogsRoleArn: String? = nil, excludeVerboseContent: Bool? = nil, fieldLogLevel: String? = nil) {
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.excludeVerboseContent = excludeVerboseContent
            self.fieldLogLevel = fieldLogLevel
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogsRoleArn, name: "cloudWatchLogsRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.fieldLogLevel, name: "fieldLogLevel", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
            case excludeVerboseContent = "ExcludeVerboseContent"
            case fieldLogLevel = "FieldLogLevel"
        }
    }

    public struct AwsAppSyncGraphQlApiOpenIdConnectConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The number of milliseconds that a token is valid after being authenticated.
        public let authTtL: Int64?
        ///  The client identifier of the relying party at the OpenID identity provider. This identifier is typically obtained  when the relying party is registered with the OpenID identity provider. You can specify a regular expression so that  AppSync can validate against multiple client identifiers at a time.
        public let clientId: String?
        ///  The number of milliseconds that a token is valid after it's issued to a user.
        public let iatTtL: Int64?
        ///  The issuer for the OIDC configuration. The issuer returned by discovery must exactly match the value of iss  in the ID token.
        public let issuer: String?

        @inlinable
        public init(authTtL: Int64? = nil, clientId: String? = nil, iatTtL: Int64? = nil, issuer: String? = nil) {
            self.authTtL = authTtL
            self.clientId = clientId
            self.iatTtL = iatTtL
            self.issuer = issuer
        }

        public func validate(name: String) throws {
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "\\S")
            try self.validate(self.issuer, name: "issuer", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case authTtL = "AuthTtL"
            case clientId = "ClientId"
            case iatTtL = "IatTtL"
            case issuer = "Issuer"
        }
    }

    public struct AwsAppSyncGraphQlApiUserPoolConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  A regular expression for validating the incoming Amazon Cognito user pools app client ID. If this value isn't set, no  filtering is applied.
        public let appIdClientRegex: String?
        ///  The Amazon Web Services Region in which the user pool was created.
        public let awsRegion: String?
        ///  The action that you want your GraphQL API to take when a request that uses Amazon Cognito user pools  authentication doesn't match the Amazon Cognito user pools configuration.
        public let defaultAction: String?
        ///  The user pool ID.
        public let userPoolId: String?

        @inlinable
        public init(appIdClientRegex: String? = nil, awsRegion: String? = nil, defaultAction: String? = nil, userPoolId: String? = nil) {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.defaultAction = defaultAction
            self.userPoolId = userPoolId
        }

        public func validate(name: String) throws {
            try self.validate(self.appIdClientRegex, name: "appIdClientRegex", parent: name, pattern: "\\S")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, pattern: "\\S")
            try self.validate(self.defaultAction, name: "defaultAction", parent: name, pattern: "\\S")
            try self.validate(self.userPoolId, name: "userPoolId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case appIdClientRegex = "AppIdClientRegex"
            case awsRegion = "AwsRegion"
            case defaultAction = "DefaultAction"
            case userPoolId = "UserPoolId"
        }
    }

    public struct AwsAthenaWorkGroupConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The location in Amazon S3 where query and calculation results are stored and the  encryption option, if any, used for query and calculation results. These are known as client-side settings. If  workgroup settings override client-side settings, then the query uses the workgroup settings.
        public let resultConfiguration: AwsAthenaWorkGroupConfigurationResultConfigurationDetails?

        @inlinable
        public init(resultConfiguration: AwsAthenaWorkGroupConfigurationResultConfigurationDetails? = nil) {
            self.resultConfiguration = resultConfiguration
        }

        public func validate(name: String) throws {
            try self.resultConfiguration?.validate(name: "\(name).resultConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case resultConfiguration = "ResultConfiguration"
        }
    }

    public struct AwsAthenaWorkGroupConfigurationResultConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the method used to encrypt the userâ€™s data stores in the Athena workgroup.
        public let encryptionConfiguration: AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails?

        @inlinable
        public init(encryptionConfiguration: AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails? = nil) {
            self.encryptionConfiguration = encryptionConfiguration
        }

        public func validate(name: String) throws {
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfiguration = "EncryptionConfiguration"
        }
    }

    public struct AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether Amazon Simple Storage Service (Amazon S3) server-side encryption with Amazon S3 managed  keys (SSE_S3), server-side encryption with KMS keys (SSE_KMS), or client-side encryption with  KMS customer managed keys (CSE_KMS) is used.
        public let encryptionOption: String?
        ///  For SSE_KMS and CSE_KMS, this is the KMS key Amazon Resource Name (ARN) or ID.
        public let kmsKey: String?

        @inlinable
        public init(encryptionOption: String? = nil, kmsKey: String? = nil) {
            self.encryptionOption = encryptionOption
            self.kmsKey = kmsKey
        }

        public func validate(name: String) throws {
            try self.validate(self.encryptionOption, name: "encryptionOption", parent: name, pattern: "\\S")
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionOption = "EncryptionOption"
            case kmsKey = "KmsKey"
        }
    }

    public struct AwsAthenaWorkGroupDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The configuration of the workgroup, which includes the location in Amazon Simple Storage Service (Amazon S3)  where query results are stored, the encryption option, if any, used for query results, whether  Amazon CloudWatch metrics are enabled for the workgroup, and the limit for the amount of bytes scanned  (cutoff) per query, if it is specified.
        public let configuration: AwsAthenaWorkGroupConfigurationDetails?
        ///  The workgroup description.
        public let description: String?
        ///  The workgroup name.
        public let name: String?
        ///  Whether the workgroup is enabled or disabled.
        public let state: String?

        @inlinable
        public init(configuration: AwsAthenaWorkGroupConfigurationDetails? = nil, description: String? = nil, name: String? = nil, state: String? = nil) {
            self.configuration = configuration
            self.description = description
            self.name = name
            self.state = state
        }

        public func validate(name: String) throws {
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case description = "Description"
            case name = "Name"
            case state = "State"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Availability Zone.
        public let value: String?

        @inlinable
        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The list of Availability Zones for the automatic scaling group.
        public let availabilityZones: [AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails]?
        /// Indicates whether capacity rebalancing is enabled.
        public let capacityRebalance: Bool?
        /// Indicates when the auto scaling group was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdTime: String?
        /// The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before it checks the health status of an EC2 instance that has come into service.
        public let healthCheckGracePeriod: Int?
        /// The service to use for the health checks. Valid values are EC2 or ELB.
        public let healthCheckType: String?
        /// The name of the launch configuration.
        public let launchConfigurationName: String?
        /// The launch template to use.
        public let launchTemplate: AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification?
        /// The list of load balancers associated with the group.
        public let loadBalancerNames: [String]?
        /// The mixed instances policy for the automatic scaling group.
        public let mixedInstancesPolicy: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails?

        @inlinable
        public init(availabilityZones: [AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails]? = nil, capacityRebalance: Bool? = nil, createdTime: String? = nil, healthCheckGracePeriod: Int? = nil, healthCheckType: String? = nil, launchConfigurationName: String? = nil, launchTemplate: AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification? = nil, loadBalancerNames: [String]? = nil, mixedInstancesPolicy: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails? = nil) {
            self.availabilityZones = availabilityZones
            self.capacityRebalance = capacityRebalance
            self.createdTime = createdTime
            self.healthCheckGracePeriod = healthCheckGracePeriod
            self.healthCheckType = healthCheckType
            self.launchConfigurationName = launchConfigurationName
            self.launchTemplate = launchTemplate
            self.loadBalancerNames = loadBalancerNames
            self.mixedInstancesPolicy = mixedInstancesPolicy
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try $0.validate(name: "\(name).availabilityZones[]")
            }
            try self.validate(self.createdTime, name: "createdTime", parent: name, pattern: "\\S")
            try self.validate(self.healthCheckType, name: "healthCheckType", parent: name, pattern: "\\S")
            try self.validate(self.launchConfigurationName, name: "launchConfigurationName", parent: name, pattern: "\\S")
            try self.launchTemplate?.validate(name: "\(name).launchTemplate")
            try self.loadBalancerNames?.forEach {
                try validate($0, name: "loadBalancerNames[]", parent: name, pattern: "\\S")
            }
            try self.mixedInstancesPolicy?.validate(name: "\(name).mixedInstancesPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case capacityRebalance = "CapacityRebalance"
            case createdTime = "CreatedTime"
            case healthCheckGracePeriod = "HealthCheckGracePeriod"
            case healthCheckType = "HealthCheckType"
            case launchConfigurationName = "LaunchConfigurationName"
            case launchTemplate = "LaunchTemplate"
            case loadBalancerNames = "LoadBalancerNames"
            case mixedInstancesPolicy = "MixedInstancesPolicy"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public let launchTemplateId: String?
        /// The name of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public let launchTemplateName: String?
        /// Identifies the version of the launch template. You can specify a version identifier, or use the values $Latest or $Default.
        public let version: String?

        @inlinable
        public init(launchTemplateId: String? = nil, launchTemplateName: String? = nil, version: String? = nil) {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.launchTemplateId, name: "launchTemplateId", parent: name, pattern: "\\S")
            try self.validate(self.launchTemplateName, name: "launchTemplateName", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case launchTemplateId = "LaunchTemplateId"
            case launchTemplateName = "LaunchTemplateName"
            case version = "Version"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The instances distribution. The instances distribution specifies the distribution of On-Demand Instances and Spot Instances, the maximum price to pay for Spot Instances, and how the Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacity.
        public let instancesDistribution: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails?
        /// The launch template to use and the instance types (overrides) to use to provision EC2 instances to fulfill On-Demand and Spot capacities.
        public let launchTemplate: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails?

        @inlinable
        public init(instancesDistribution: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails? = nil, launchTemplate: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails? = nil) {
            self.instancesDistribution = instancesDistribution
            self.launchTemplate = launchTemplate
        }

        public func validate(name: String) throws {
            try self.instancesDistribution?.validate(name: "\(name).instancesDistribution")
            try self.launchTemplate?.validate(name: "\(name).launchTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case instancesDistribution = "InstancesDistribution"
            case launchTemplate = "LaunchTemplate"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails: AWSEncodableShape & AWSDecodableShape {
        /// How to allocate instance types to fulfill On-Demand capacity. The valid value is prioritized.
        public let onDemandAllocationStrategy: String?
        /// The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances.
        public let onDemandBaseCapacity: Int?
        /// The percentage of On-Demand Instances and Spot Instances for additional capacity beyond OnDemandBaseCapacity.
        public let onDemandPercentageAboveBaseCapacity: Int?
        /// How to allocate instances across Spot Instance pools. Valid values are as follows:    lowest-price     capacity-optimized     capacity-optimized-prioritized
        public let spotAllocationStrategy: String?
        /// The number of Spot Instance pools across which to allocate your Spot Instances.
        public let spotInstancePools: Int?
        /// The maximum price per unit hour that you are willing to pay for a Spot Instance.
        public let spotMaxPrice: String?

        @inlinable
        public init(onDemandAllocationStrategy: String? = nil, onDemandBaseCapacity: Int? = nil, onDemandPercentageAboveBaseCapacity: Int? = nil, spotAllocationStrategy: String? = nil, spotInstancePools: Int? = nil, spotMaxPrice: String? = nil) {
            self.onDemandAllocationStrategy = onDemandAllocationStrategy
            self.onDemandBaseCapacity = onDemandBaseCapacity
            self.onDemandPercentageAboveBaseCapacity = onDemandPercentageAboveBaseCapacity
            self.spotAllocationStrategy = spotAllocationStrategy
            self.spotInstancePools = spotInstancePools
            self.spotMaxPrice = spotMaxPrice
        }

        public func validate(name: String) throws {
            try self.validate(self.onDemandAllocationStrategy, name: "onDemandAllocationStrategy", parent: name, pattern: "\\S")
            try self.validate(self.spotAllocationStrategy, name: "spotAllocationStrategy", parent: name, pattern: "\\S")
            try self.validate(self.spotMaxPrice, name: "spotMaxPrice", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case onDemandAllocationStrategy = "OnDemandAllocationStrategy"
            case onDemandBaseCapacity = "OnDemandBaseCapacity"
            case onDemandPercentageAboveBaseCapacity = "OnDemandPercentageAboveBaseCapacity"
            case spotAllocationStrategy = "SpotAllocationStrategy"
            case spotInstancePools = "SpotInstancePools"
            case spotMaxPrice = "SpotMaxPrice"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails: AWSEncodableShape & AWSDecodableShape {
        /// The launch template to use for a mixed instances policy.
        public let launchTemplateSpecification: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification?
        /// Property values to use to override the values in the launch template.
        public let overrides: [AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]?

        @inlinable
        public init(launchTemplateSpecification: AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification? = nil, overrides: [AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]? = nil) {
            self.launchTemplateSpecification = launchTemplateSpecification
            self.overrides = overrides
        }

        public func validate(name: String) throws {
            try self.launchTemplateSpecification?.validate(name: "\(name).launchTemplateSpecification")
            try self.overrides?.forEach {
                try $0.validate(name: "\(name).overrides[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case launchTemplateSpecification = "LaunchTemplateSpecification"
            case overrides = "Overrides"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public let launchTemplateId: String?
        /// The name of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public let launchTemplateName: String?
        /// Identifies the version of the launch template. You can specify a version identifier, or use the values $Latest or $Default.
        public let version: String?

        @inlinable
        public init(launchTemplateId: String? = nil, launchTemplateName: String? = nil, version: String? = nil) {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.launchTemplateId, name: "launchTemplateId", parent: name, pattern: "\\S")
            try self.validate(self.launchTemplateName, name: "launchTemplateName", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case launchTemplateId = "LaunchTemplateId"
            case launchTemplateName = "LaunchTemplateName"
            case version = "Version"
        }
    }

    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails: AWSEncodableShape & AWSDecodableShape {
        /// The instance type. For example, m3.xlarge.
        public let instanceType: String?
        /// The number of capacity units provided by the specified instance type in terms of virtual CPUs, memory, storage, throughput, or other relative performance characteristic.
        public let weightedCapacity: String?

        @inlinable
        public init(instanceType: String? = nil, weightedCapacity: String? = nil) {
            self.instanceType = instanceType
            self.weightedCapacity = weightedCapacity
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
            try self.validate(self.weightedCapacity, name: "weightedCapacity", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceType = "InstanceType"
            case weightedCapacity = "WeightedCapacity"
        }
    }

    public struct AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The device name that is exposed to the EC2 instance. For example, /dev/sdh or xvdh.
        public let deviceName: String?
        /// Parameters that are used to automatically set up Amazon EBS volumes when an instance is launched.
        public let ebs: AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails?
        /// Whether to suppress the device that is included in the block device mapping of the Amazon Machine Image (AMI). If NoDevice is true, then you cannot specify Ebs.>
        public let noDevice: Bool?
        /// The name of the virtual device (for example, ephemeral0). You can provide either VirtualName or Ebs, but not both.
        public let virtualName: String?

        @inlinable
        public init(deviceName: String? = nil, ebs: AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails? = nil, noDevice: Bool? = nil, virtualName: String? = nil) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "\\S")
            try self.ebs?.validate(name: "\(name).ebs")
            try self.validate(self.virtualName, name: "virtualName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "DeviceName"
            case ebs = "Ebs"
            case noDevice = "NoDevice"
            case virtualName = "VirtualName"
        }
    }

    public struct AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to delete the volume when the instance is terminated.
        public let deleteOnTermination: Bool?
        /// Whether to encrypt the volume.
        public let encrypted: Bool?
        /// The number of input/output (I/O) operations per second (IOPS) to provision for the volume. Only supported for gp3 or io1 volumes. Required for io1 volumes. Not used with standard, gp2, st1, or sc1 volumes.
        public let iops: Int?
        /// The snapshot ID of the volume to use. You must specify either VolumeSize or SnapshotId.
        public let snapshotId: String?
        /// The volume size, in GiBs. The following are the supported volumes sizes for each volume type:   gp2 and gp3: 1-16,384   io1: 4-16,384   st1 and sc1: 125-16,384   standard: 1-1,024   You must specify either SnapshotId or VolumeSize. If you specify both SnapshotId and VolumeSize, the volume size must be equal or greater than the size of the snapshot.
        public let volumeSize: Int?
        /// The volume type. Valid values are as follows:    gp2     gp3     io1     sc1     st1     standard
        public let volumeType: String?

        @inlinable
        public init(deleteOnTermination: Bool? = nil, encrypted: Bool? = nil, iops: Int? = nil, snapshotId: String? = nil, volumeSize: Int? = nil, volumeType: String? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "\\S")
            try self.validate(self.volumeType, name: "volumeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteOnTermination = "DeleteOnTermination"
            case encrypted = "Encrypted"
            case iops = "Iops"
            case snapshotId = "SnapshotId"
            case volumeSize = "VolumeSize"
            case volumeType = "VolumeType"
        }
    }

    public struct AwsAutoScalingLaunchConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// For Auto Scaling groups that run in a VPC, specifies whether to assign a public IP address to the group's instances.
        public let associatePublicIpAddress: Bool?
        /// Specifies the block devices for the instance.
        public let blockDeviceMappings: [AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails]?
        /// The identifier of a ClassicLink-enabled VPC that EC2-Classic instances are linked to.
        public let classicLinkVpcId: String?
        /// The identifiers of one or more security groups for the VPC that is specified in ClassicLinkVPCId.
        public let classicLinkVpcSecurityGroups: [String]?
        /// The creation date and time for the launch configuration. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdTime: String?
        /// Whether the launch configuration is optimized for Amazon EBS I/O.
        public let ebsOptimized: Bool?
        /// The name or the ARN of the instance profile associated with the IAM role for the instance. The instance profile contains the IAM role.
        public let iamInstanceProfile: String?
        /// The identifier of the Amazon Machine Image (AMI) that is used to launch EC2 instances.
        public let imageId: String?
        /// Indicates the type of monitoring for instances in the group.
        public let instanceMonitoring: AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails?
        /// The instance type for the instances.
        public let instanceType: String?
        /// The identifier of the kernel associated with the AMI.
        public let kernelId: String?
        /// The name of the key pair.
        public let keyName: String?
        /// The name of the launch configuration.
        public let launchConfigurationName: String?
        /// The metadata options for the instances.
        public let metadataOptions: AwsAutoScalingLaunchConfigurationMetadataOptions?
        /// The tenancy of the instance. An instance with dedicated tenancy runs on isolated, single-tenant hardware and can only be launched into a VPC.
        public let placementTenancy: String?
        /// The identifier of the RAM disk associated with the AMI.
        public let ramdiskId: String?
        /// The security groups to assign to the instances in the Auto Scaling group.
        public let securityGroups: [String]?
        /// The maximum hourly price to be paid for any Spot Instance that is launched to fulfill the request.
        public let spotPrice: String?
        /// The user data to make available to the launched EC2 instances. Must be base64-encoded text.
        public let userData: String?

        @inlinable
        public init(associatePublicIpAddress: Bool? = nil, blockDeviceMappings: [AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails]? = nil, classicLinkVpcId: String? = nil, classicLinkVpcSecurityGroups: [String]? = nil, createdTime: String? = nil, ebsOptimized: Bool? = nil, iamInstanceProfile: String? = nil, imageId: String? = nil, instanceMonitoring: AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails? = nil, instanceType: String? = nil, kernelId: String? = nil, keyName: String? = nil, launchConfigurationName: String? = nil, metadataOptions: AwsAutoScalingLaunchConfigurationMetadataOptions? = nil, placementTenancy: String? = nil, ramdiskId: String? = nil, securityGroups: [String]? = nil, spotPrice: String? = nil, userData: String? = nil) {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.blockDeviceMappings = blockDeviceMappings
            self.classicLinkVpcId = classicLinkVpcId
            self.classicLinkVpcSecurityGroups = classicLinkVpcSecurityGroups
            self.createdTime = createdTime
            self.ebsOptimized = ebsOptimized
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceMonitoring = instanceMonitoring
            self.instanceType = instanceType
            self.kernelId = kernelId
            self.keyName = keyName
            self.launchConfigurationName = launchConfigurationName
            self.metadataOptions = metadataOptions
            self.placementTenancy = placementTenancy
            self.ramdiskId = ramdiskId
            self.securityGroups = securityGroups
            self.spotPrice = spotPrice
            self.userData = userData
        }

        public func validate(name: String) throws {
            try self.blockDeviceMappings?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappings[]")
            }
            try self.validate(self.classicLinkVpcId, name: "classicLinkVpcId", parent: name, pattern: "\\S")
            try self.classicLinkVpcSecurityGroups?.forEach {
                try validate($0, name: "classicLinkVpcSecurityGroups[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.createdTime, name: "createdTime", parent: name, pattern: "\\S")
            try self.validate(self.iamInstanceProfile, name: "iamInstanceProfile", parent: name, pattern: "\\S")
            try self.validate(self.imageId, name: "imageId", parent: name, pattern: "\\S")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
            try self.validate(self.kernelId, name: "kernelId", parent: name, pattern: "\\S")
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "\\S")
            try self.validate(self.launchConfigurationName, name: "launchConfigurationName", parent: name, pattern: "\\S")
            try self.metadataOptions?.validate(name: "\(name).metadataOptions")
            try self.validate(self.placementTenancy, name: "placementTenancy", parent: name, pattern: "\\S")
            try self.validate(self.ramdiskId, name: "ramdiskId", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.spotPrice, name: "spotPrice", parent: name, pattern: "\\S")
            try self.validate(self.userData, name: "userData", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associatePublicIpAddress = "AssociatePublicIpAddress"
            case blockDeviceMappings = "BlockDeviceMappings"
            case classicLinkVpcId = "ClassicLinkVpcId"
            case classicLinkVpcSecurityGroups = "ClassicLinkVpcSecurityGroups"
            case createdTime = "CreatedTime"
            case ebsOptimized = "EbsOptimized"
            case iamInstanceProfile = "IamInstanceProfile"
            case imageId = "ImageId"
            case instanceMonitoring = "InstanceMonitoring"
            case instanceType = "InstanceType"
            case kernelId = "KernelId"
            case keyName = "KeyName"
            case launchConfigurationName = "LaunchConfigurationName"
            case metadataOptions = "MetadataOptions"
            case placementTenancy = "PlacementTenancy"
            case ramdiskId = "RamdiskId"
            case securityGroups = "SecurityGroups"
            case spotPrice = "SpotPrice"
            case userData = "UserData"
        }
    }

    public struct AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails: AWSEncodableShape & AWSDecodableShape {
        /// If set to true, then instances in the group launch with detailed monitoring. If set to false, then instances in the group launch with basic monitoring.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsAutoScalingLaunchConfigurationMetadataOptions: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the HTTP metadata endpoint on your instances. By default, the metadata endpoint is enabled.
        public let httpEndpoint: String?
        /// The HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
        public let httpPutResponseHopLimit: Int?
        /// Indicates whether token usage is required or optional for metadata requests. By default, token usage is optional.
        public let httpTokens: String?

        @inlinable
        public init(httpEndpoint: String? = nil, httpPutResponseHopLimit: Int? = nil, httpTokens: String? = nil) {
            self.httpEndpoint = httpEndpoint
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
        }

        public func validate(name: String) throws {
            try self.validate(self.httpEndpoint, name: "httpEndpoint", parent: name, pattern: "\\S")
            try self.validate(self.httpTokens, name: "httpTokens", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case httpEndpoint = "HttpEndpoint"
            case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
            case httpTokens = "HttpTokens"
        }
    }

    public struct AwsBackupBackupPlanAdvancedBackupSettingsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the backup option for a selected resource. This option is only available for Windows
        /// Volume Shadow Copy Service (VSS) backup jobs. Valid values are as follows:   Set to WindowsVSS: enabled to enable the WindowsVSS backup option and create a Windows VSS backup.   Set to WindowsVSS: disabled to create a regular backup. The WindowsVSS option is not enabled by default.
        public let backupOptions: [String: String]?
        /// The name of a resource type. The only supported resource type is Amazon EC2 instances with Windows VSS. The only valid value is EC2.
        public let resourceType: String?

        @inlinable
        public init(backupOptions: [String: String]? = nil, resourceType: String? = nil) {
            self.backupOptions = backupOptions
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.backupOptions?.forEach {
                try validate($0.key, name: "backupOptions.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "backupOptions[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case backupOptions = "BackupOptions"
            case resourceType = "ResourceType"
        }
    }

    public struct AwsBackupBackupPlanBackupPlanDetails: AWSEncodableShape & AWSDecodableShape {
        /// A list of backup options for each resource type.
        public let advancedBackupSettings: [AwsBackupBackupPlanAdvancedBackupSettingsDetails]?
        /// The display name of a backup plan.
        public let backupPlanName: String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        public let backupPlanRule: [AwsBackupBackupPlanRuleDetails]?

        @inlinable
        public init(advancedBackupSettings: [AwsBackupBackupPlanAdvancedBackupSettingsDetails]? = nil, backupPlanName: String? = nil, backupPlanRule: [AwsBackupBackupPlanRuleDetails]? = nil) {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.backupPlanRule = backupPlanRule
        }

        public func validate(name: String) throws {
            try self.advancedBackupSettings?.forEach {
                try $0.validate(name: "\(name).advancedBackupSettings[]")
            }
            try self.validate(self.backupPlanName, name: "backupPlanName", parent: name, pattern: "\\S")
            try self.backupPlanRule?.forEach {
                try $0.validate(name: "\(name).backupPlanRule[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case advancedBackupSettings = "AdvancedBackupSettings"
            case backupPlanName = "BackupPlanName"
            case backupPlanRule = "BackupPlanRule"
        }
    }

    public struct AwsBackupBackupPlanDetails: AWSEncodableShape & AWSDecodableShape {
        /// Uniquely identifies the backup plan to be associated with the selection of resources.
        public let backupPlan: AwsBackupBackupPlanBackupPlanDetails?
        /// An Amazon Resource Name (ARN) that uniquely identifies the backup plan.
        public let backupPlanArn: String?
        /// A unique ID for the backup plan.
        public let backupPlanId: String?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings. Version IDs cannot be edited.
        public let versionId: String?

        @inlinable
        public init(backupPlan: AwsBackupBackupPlanBackupPlanDetails? = nil, backupPlanArn: String? = nil, backupPlanId: String? = nil, versionId: String? = nil) {
            self.backupPlan = backupPlan
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.backupPlan?.validate(name: "\(name).backupPlan")
            try self.validate(self.backupPlanArn, name: "backupPlanArn", parent: name, pattern: "\\S")
            try self.validate(self.backupPlanId, name: "backupPlanId", parent: name, pattern: "\\S")
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlan = "BackupPlan"
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case versionId = "VersionId"
        }
    }

    public struct AwsBackupBackupPlanLifecycleDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public let deleteAfterDays: Int64?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public let moveToColdStorageAfterDays: Int64?

        @inlinable
        public init(deleteAfterDays: Int64? = nil, moveToColdStorageAfterDays: Int64? = nil) {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAfterDays = "DeleteAfterDays"
            case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
        }
    }

    public struct AwsBackupBackupPlanRuleCopyActionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup.
        public let destinationBackupVaultArn: String?
        /// Defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. If you don't specify a lifecycle, Backup applies the lifecycle policy of the source backup to the destination backup. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days.
        public let lifecycle: AwsBackupBackupPlanLifecycleDetails?

        @inlinable
        public init(destinationBackupVaultArn: String? = nil, lifecycle: AwsBackupBackupPlanLifecycleDetails? = nil) {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.lifecycle = lifecycle
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationBackupVaultArn, name: "destinationBackupVaultArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationBackupVaultArn = "DestinationBackupVaultArn"
            case lifecycle = "Lifecycle"
        }
    }

    public struct AwsBackupBackupPlanRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// A value in minutes after a backup job is successfully started before it must be completed, or it is canceled by Backup.
        public let completionWindowMinutes: Int64?
        /// An array of CopyAction objects, each of which contains details of the copy operation.
        public let copyActions: [AwsBackupBackupPlanRuleCopyActionsDetails]?
        /// Specifies whether Backup creates continuous backups capable of point-in-time restore (PITR).
        public let enableContinuousBackup: Bool?
        /// Defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. If you don't specify a lifecycle, Backup applies the lifecycle policy of the source backup to the destination backup. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days.
        public let lifecycle: AwsBackupBackupPlanLifecycleDetails?
        /// Uniquely identifies a rule that is used to schedule the backup of a selection of resources.
        public let ruleId: String?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        public let ruleName: String?
        /// A cron expression in UTC specifying when Backup initiates a backup job.
        public let scheduleExpression: String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully.
        public let startWindowMinutes: Int64?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the Amazon Web Services account used to create them and the Amazon Web Services Region  where they are created. They consist of letters, numbers, and hyphens.
        public let targetBackupVault: String?

        @inlinable
        public init(completionWindowMinutes: Int64? = nil, copyActions: [AwsBackupBackupPlanRuleCopyActionsDetails]? = nil, enableContinuousBackup: Bool? = nil, lifecycle: AwsBackupBackupPlanLifecycleDetails? = nil, ruleId: String? = nil, ruleName: String? = nil, scheduleExpression: String? = nil, startWindowMinutes: Int64? = nil, targetBackupVault: String? = nil) {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.ruleId = ruleId
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVault = targetBackupVault
        }

        public func validate(name: String) throws {
            try self.copyActions?.forEach {
                try $0.validate(name: "\(name).copyActions[]")
            }
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "\\S")
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, pattern: "\\S")
            try self.validate(self.targetBackupVault, name: "targetBackupVault", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case completionWindowMinutes = "CompletionWindowMinutes"
            case copyActions = "CopyActions"
            case enableContinuousBackup = "EnableContinuousBackup"
            case lifecycle = "Lifecycle"
            case ruleId = "RuleId"
            case ruleName = "RuleName"
            case scheduleExpression = "ScheduleExpression"
            case startWindowMinutes = "StartWindowMinutes"
            case targetBackupVault = "TargetBackupVault"
        }
    }

    public struct AwsBackupBackupVaultDetails: AWSEncodableShape & AWSDecodableShape {
        /// A resource-based policy that is used to manage access permissions on the target backup vault.
        public let accessPolicy: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the
        /// Amazon Web Services account used to create them and the Amazon Web Services Region where they are created.
        /// They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// The unique ARN associated with the server-side encryption key. You can specify a key to encrypt your backups from services that support
        /// full Backup management. If you don't specify a key, Backup creates an KMS key for you by default.
        public let encryptionKeyArn: String?
        /// The Amazon SNS event notifications for the specified backup vault.
        public let notifications: AwsBackupBackupVaultNotificationsDetails?

        @inlinable
        public init(accessPolicy: String? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, encryptionKeyArn: String? = nil, notifications: AwsBackupBackupVaultNotificationsDetails? = nil) {
            self.accessPolicy = accessPolicy
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.encryptionKeyArn = encryptionKeyArn
            self.notifications = notifications
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicy, name: "accessPolicy", parent: name, pattern: "\\S")
            try self.validate(self.backupVaultArn, name: "backupVaultArn", parent: name, pattern: "\\S")
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "\\S")
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, pattern: "\\S")
            try self.notifications?.validate(name: "\(name).notifications")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicy = "AccessPolicy"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case encryptionKeyArn = "EncryptionKeyArn"
            case notifications = "Notifications"
        }
    }

    public struct AwsBackupBackupVaultNotificationsDetails: AWSEncodableShape & AWSDecodableShape {
        /// An array of events that indicate the status of jobs to back up resources to the backup vault.
        /// The following events are supported:    BACKUP_JOB_STARTED | BACKUP_JOB_COMPLETED     COPY_JOB_STARTED | COPY_JOB_SUCCESSFUL | COPY_JOB_FAILED     RESTORE_JOB_STARTED | RESTORE_JOB_COMPLETED | RECOVERY_POINT_MODIFIED     S3_BACKUP_OBJECT_FAILED | S3_RESTORE_OBJECT_FAILED
        public let backupVaultEvents: [String]?
        /// The Amazon Resource Name (ARN) that uniquely identifies the Amazon SNS topic for a backup vault's events.
        public let snsTopicArn: String?

        @inlinable
        public init(backupVaultEvents: [String]? = nil, snsTopicArn: String? = nil) {
            self.backupVaultEvents = backupVaultEvents
            self.snsTopicArn = snsTopicArn
        }

        public func validate(name: String) throws {
            try self.backupVaultEvents?.forEach {
                try validate($0, name: "backupVaultEvents[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case backupVaultEvents = "BackupVaultEvents"
            case snsTopicArn = "SnsTopicArn"
        }
    }

    public struct AwsBackupRecoveryPointCalculatedLifecycleDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater
        /// than 90 days plus MoveToColdStorageAfterDays.
        public let deleteAt: String?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public let moveToColdStorageAt: String?

        @inlinable
        public init(deleteAt: String? = nil, moveToColdStorageAt: String? = nil) {
            self.deleteAt = deleteAt
            self.moveToColdStorageAt = moveToColdStorageAt
        }

        public func validate(name: String) throws {
            try self.validate(self.deleteAt, name: "deleteAt", parent: name, pattern: "\\S")
            try self.validate(self.moveToColdStorageAt, name: "moveToColdStorageAt", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAt = "DeleteAt"
            case moveToColdStorageAt = "MoveToColdStorageAt"
        }
    }

    public struct AwsBackupRecoveryPointCreatedByDetails: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan.
        public let backupPlanArn: String?
        /// Uniquely identifies a backup plan.
        public let backupPlanId: String?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most
        /// 1,024 bytes long. Version IDs cannot be edited.
        public let backupPlanVersion: String?
        /// Uniquely identifies a rule used to schedule the backup of a selection of resources.
        public let backupRuleId: String?

        @inlinable
        public init(backupPlanArn: String? = nil, backupPlanId: String? = nil, backupPlanVersion: String? = nil, backupRuleId: String? = nil) {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanVersion = backupPlanVersion
            self.backupRuleId = backupRuleId
        }

        public func validate(name: String) throws {
            try self.validate(self.backupPlanArn, name: "backupPlanArn", parent: name, pattern: "\\S")
            try self.validate(self.backupPlanId, name: "backupPlanId", parent: name, pattern: "\\S")
            try self.validate(self.backupPlanVersion, name: "backupPlanVersion", parent: name, pattern: "\\S")
            try self.validate(self.backupRuleId, name: "backupRuleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case backupPlanArn = "BackupPlanArn"
            case backupPlanId = "BackupPlanId"
            case backupPlanVersion = "BackupPlanVersion"
            case backupRuleId = "BackupRuleId"
        }
    }

    public struct AwsBackupRecoveryPointDetails: AWSEncodableShape & AWSDecodableShape {
        /// The size, in bytes, of a backup.
        public let backupSizeInBytes: Int64?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault.
        public let backupVaultArn: String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names
        /// that are unique to the Amazon Web Services account used to create them and the Amazon Web Services Region
        /// where they are created. They consist of lowercase letters, numbers, and hyphens.
        public let backupVaultName: String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public let calculatedLifecycle: AwsBackupRecoveryPointCalculatedLifecycleDetails?
        /// The date and time that a job to create a recovery point is completed, in Unix format and UTC.
        /// The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087
        /// represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionDate: String?
        /// Contains identifying information about the creation of a recovery point, including the
        /// BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId
        /// of the backup plan that is used to create it.
        public let createdBy: AwsBackupRecoveryPointCreatedByDetails?
        /// The date and time a recovery point is created, in Unix format and UTC. The value of CreationDate
        /// is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationDate: String?
        /// The ARN for the server-side encryption key that is used to protect your backups.
        public let encryptionKeyArn: String?
        /// Specifies the IAM role ARN used to create the target recovery point
        public let iamRoleArn: String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is
        /// encrypted, or FALSE if the recovery point is not encrypted.
        public let isEncrypted: Bool?
        /// The date and time that a recovery point was last restored, in Unix format and UTC. The value of
        /// LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents
        /// Friday, January 26, 2018 12:11:30.087 AM.
        public let lastRestoreTime: String?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it
        /// expires. Backup transitions and expires backups automatically according to the lifecycle that
        /// you define
        public let lifecycle: AwsBackupRecoveryPointLifecycleDetails?
        /// An ARN that uniquely identifies a recovery point.
        public let recoveryPointArn: String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public let resourceArn: String?
        /// The type of Amazon Web Services resource saved as a recovery point, such as an Amazon EBS volume or an Amazon RDS database.
        public let resourceType: String?
        /// The ARN for the backup vault where the recovery point was originally copied from. If the recovery
        /// point is restored to the same account, this value will be null.
        public let sourceBackupVaultArn: String?
        /// A status code specifying the state of the recovery point. Valid values are as follows:    COMPLETED     DELETING     EXPIRED     PARTIAL
        public let status: String?
        /// A message explaining the reason of the recovery point deletion failure.
        public let statusMessage: String?
        /// Specifies the storage class of the recovery point. Valid values are as follows:    COLD     DELETED     WARM
        public let storageClass: String?

        @inlinable
        public init(backupSizeInBytes: Int64? = nil, backupVaultArn: String? = nil, backupVaultName: String? = nil, calculatedLifecycle: AwsBackupRecoveryPointCalculatedLifecycleDetails? = nil, completionDate: String? = nil, createdBy: AwsBackupRecoveryPointCreatedByDetails? = nil, creationDate: String? = nil, encryptionKeyArn: String? = nil, iamRoleArn: String? = nil, isEncrypted: Bool? = nil, lastRestoreTime: String? = nil, lifecycle: AwsBackupRecoveryPointLifecycleDetails? = nil, recoveryPointArn: String? = nil, resourceArn: String? = nil, resourceType: String? = nil, sourceBackupVaultArn: String? = nil, status: String? = nil, statusMessage: String? = nil, storageClass: String? = nil) {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.isEncrypted = isEncrypted
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
            self.storageClass = storageClass
        }

        public func validate(name: String) throws {
            try self.validate(self.backupVaultArn, name: "backupVaultArn", parent: name, pattern: "\\S")
            try self.validate(self.backupVaultName, name: "backupVaultName", parent: name, pattern: "\\S")
            try self.calculatedLifecycle?.validate(name: "\(name).calculatedLifecycle")
            try self.validate(self.completionDate, name: "completionDate", parent: name, pattern: "\\S")
            try self.createdBy?.validate(name: "\(name).createdBy")
            try self.validate(self.creationDate, name: "creationDate", parent: name, pattern: "\\S")
            try self.validate(self.encryptionKeyArn, name: "encryptionKeyArn", parent: name, pattern: "\\S")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.lastRestoreTime, name: "lastRestoreTime", parent: name, pattern: "\\S")
            try self.validate(self.recoveryPointArn, name: "recoveryPointArn", parent: name, pattern: "\\S")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "\\S")
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "\\S")
            try self.validate(self.sourceBackupVaultArn, name: "sourceBackupVaultArn", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.statusMessage, name: "statusMessage", parent: name, pattern: "\\S")
            try self.validate(self.storageClass, name: "storageClass", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case backupSizeInBytes = "BackupSizeInBytes"
            case backupVaultArn = "BackupVaultArn"
            case backupVaultName = "BackupVaultName"
            case calculatedLifecycle = "CalculatedLifecycle"
            case completionDate = "CompletionDate"
            case createdBy = "CreatedBy"
            case creationDate = "CreationDate"
            case encryptionKeyArn = "EncryptionKeyArn"
            case iamRoleArn = "IamRoleArn"
            case isEncrypted = "IsEncrypted"
            case lastRestoreTime = "LastRestoreTime"
            case lifecycle = "Lifecycle"
            case recoveryPointArn = "RecoveryPointArn"
            case resourceArn = "ResourceArn"
            case resourceType = "ResourceType"
            case sourceBackupVaultArn = "SourceBackupVaultArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case storageClass = "StorageClass"
        }
    }

    public struct AwsBackupRecoveryPointLifecycleDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater
        /// than 90 days plus MoveToColdStorageAfterDays.
        public let deleteAfterDays: Int64?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public let moveToColdStorageAfterDays: Int64?

        @inlinable
        public init(deleteAfterDays: Int64? = nil, moveToColdStorageAfterDays: Int64? = nil) {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAfterDays = "DeleteAfterDays"
            case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
        }
    }

    public struct AwsCertificateManagerCertificateDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the private certificate authority (CA) that will be used to issue the certificate.
        public let certificateAuthorityArn: String?
        /// Indicates when the certificate was requested. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdAt: String?
        /// The fully qualified domain name (FQDN), such as www.example.com, that is secured by the certificate.
        public let domainName: String?
        /// Contains information about the initial validation of each domain name that occurs as a result of the RequestCertificate request. Only provided if the certificate type is AMAZON_ISSUED.
        public let domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]?
        /// Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a purpose for which the certificate public key can be used and consists of a name and an object identifier (OID).
        public let extendedKeyUsages: [AwsCertificateManagerCertificateExtendedKeyUsage]?
        /// For a failed certificate request, the reason for the failure. Valid values: NO_AVAILABLE_CONTACTS | ADDITIONAL_VERIFICATION_REQUIRED | DOMAIN_NOT_ALLOWED | INVALID_PUBLIC_DOMAIN | DOMAIN_VALIDATION_DENIED | CAA_ERROR | PCA_LIMIT_EXCEEDED | PCA_INVALID_ARN | PCA_INVALID_STATE | PCA_REQUEST_FAILED | PCA_NAME_CONSTRAINTS_VALIDATION | PCA_RESOURCE_NOT_FOUND | PCA_INVALID_ARGS | PCA_INVALID_DURATION | PCA_ACCESS_DENIED | SLR_NOT_FOUND | OTHER
        public let failureReason: String?
        /// Indicates when the certificate was imported. Provided if the certificate type is IMPORTED. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let importedAt: String?
        /// The list of ARNs for the Amazon Web Services resources that use the certificate.
        public let inUseBy: [String]?
        /// Indicates when the certificate was issued. Provided if the certificate type is AMAZON_ISSUED. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let issuedAt: String?
        /// The name of the certificate authority that issued and signed the certificate.
        public let issuer: String?
        /// The algorithm that was used to generate the public-private key pair. Valid values: RSA_2048 | RSA_1024 | RSA_4096 | EC_prime256v1 | EC_secp384r1 | EC_secp521r1
        public let keyAlgorithm: String?
        /// A list of key usage X.509 v3 extension objects.
        public let keyUsages: [AwsCertificateManagerCertificateKeyUsage]?
        /// The time after which the certificate becomes invalid. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let notAfter: String?
        /// The time before which the certificate is not valid. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let notBefore: String?
        /// Provides a value that specifies whether to add the certificate to a transparency log.
        public let options: AwsCertificateManagerCertificateOptions?
        /// Whether the certificate is eligible for renewal. Valid values: ELIGIBLE | INELIGIBLE
        public let renewalEligibility: String?
        /// Information about the status of the Certificate Manager managed renewal for the certificate. Provided only when the certificate type is AMAZON_ISSUED.
        public let renewalSummary: AwsCertificateManagerCertificateRenewalSummary?
        /// The serial number of the certificate.
        public let serial: String?
        /// The algorithm that was used to sign the certificate.
        public let signatureAlgorithm: String?
        /// The status of the certificate. Valid values: PENDING_VALIDATION | ISSUED | INACTIVE | EXPIRED | VALIDATION_TIMED_OUT | REVOKED | FAILED
        public let status: String?
        /// The name of the entity that is associated with the public key contained in the certificate.
        public let subject: String?
        /// One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate. The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website.
        public let subjectAlternativeNames: [String]?
        /// The source of the certificate. For certificates that Certificate Manager provides, Type is AMAZON_ISSUED. For certificates that are imported with ImportCertificate, Type is IMPORTED. Valid values: IMPORTED | AMAZON_ISSUED | PRIVATE
        public let type: String?

        @inlinable
        public init(certificateAuthorityArn: String? = nil, createdAt: String? = nil, domainName: String? = nil, domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]? = nil, extendedKeyUsages: [AwsCertificateManagerCertificateExtendedKeyUsage]? = nil, failureReason: String? = nil, importedAt: String? = nil, inUseBy: [String]? = nil, issuedAt: String? = nil, issuer: String? = nil, keyAlgorithm: String? = nil, keyUsages: [AwsCertificateManagerCertificateKeyUsage]? = nil, notAfter: String? = nil, notBefore: String? = nil, options: AwsCertificateManagerCertificateOptions? = nil, renewalEligibility: String? = nil, renewalSummary: AwsCertificateManagerCertificateRenewalSummary? = nil, serial: String? = nil, signatureAlgorithm: String? = nil, status: String? = nil, subject: String? = nil, subjectAlternativeNames: [String]? = nil, type: String? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.createdAt = createdAt
            self.domainName = domainName
            self.domainValidationOptions = domainValidationOptions
            self.extendedKeyUsages = extendedKeyUsages
            self.failureReason = failureReason
            self.importedAt = importedAt
            self.inUseBy = inUseBy
            self.issuedAt = issuedAt
            self.issuer = issuer
            self.keyAlgorithm = keyAlgorithm
            self.keyUsages = keyUsages
            self.notAfter = notAfter
            self.notBefore = notBefore
            self.options = options
            self.renewalEligibility = renewalEligibility
            self.renewalSummary = renewalSummary
            self.serial = serial
            self.signatureAlgorithm = signatureAlgorithm
            self.status = status
            self.subject = subject
            self.subjectAlternativeNames = subjectAlternativeNames
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateAuthorityArn, name: "certificateAuthorityArn", parent: name, pattern: "\\S")
            try self.validate(self.createdAt, name: "createdAt", parent: name, pattern: "\\S")
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.domainValidationOptions?.forEach {
                try $0.validate(name: "\(name).domainValidationOptions[]")
            }
            try self.extendedKeyUsages?.forEach {
                try $0.validate(name: "\(name).extendedKeyUsages[]")
            }
            try self.validate(self.failureReason, name: "failureReason", parent: name, pattern: "\\S")
            try self.validate(self.importedAt, name: "importedAt", parent: name, pattern: "\\S")
            try self.inUseBy?.forEach {
                try validate($0, name: "inUseBy[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.issuedAt, name: "issuedAt", parent: name, pattern: "\\S")
            try self.validate(self.issuer, name: "issuer", parent: name, pattern: "\\S")
            try self.validate(self.keyAlgorithm, name: "keyAlgorithm", parent: name, pattern: "\\S")
            try self.keyUsages?.forEach {
                try $0.validate(name: "\(name).keyUsages[]")
            }
            try self.validate(self.notAfter, name: "notAfter", parent: name, pattern: "\\S")
            try self.validate(self.notBefore, name: "notBefore", parent: name, pattern: "\\S")
            try self.options?.validate(name: "\(name).options")
            try self.validate(self.renewalEligibility, name: "renewalEligibility", parent: name, pattern: "\\S")
            try self.renewalSummary?.validate(name: "\(name).renewalSummary")
            try self.validate(self.serial, name: "serial", parent: name, pattern: "\\S")
            try self.validate(self.signatureAlgorithm, name: "signatureAlgorithm", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.subject, name: "subject", parent: name, pattern: "\\S")
            try self.subjectAlternativeNames?.forEach {
                try validate($0, name: "subjectAlternativeNames[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case domainValidationOptions = "DomainValidationOptions"
            case extendedKeyUsages = "ExtendedKeyUsages"
            case failureReason = "FailureReason"
            case importedAt = "ImportedAt"
            case inUseBy = "InUseBy"
            case issuedAt = "IssuedAt"
            case issuer = "Issuer"
            case keyAlgorithm = "KeyAlgorithm"
            case keyUsages = "KeyUsages"
            case notAfter = "NotAfter"
            case notBefore = "NotBefore"
            case options = "Options"
            case renewalEligibility = "RenewalEligibility"
            case renewalSummary = "RenewalSummary"
            case serial = "Serial"
            case signatureAlgorithm = "SignatureAlgorithm"
            case status = "Status"
            case subject = "Subject"
            case subjectAlternativeNames = "SubjectAlternativeNames"
            case type = "Type"
        }
    }

    public struct AwsCertificateManagerCertificateDomainValidationOption: AWSEncodableShape & AWSDecodableShape {
        /// A fully qualified domain name (FQDN) in the certificate.
        public let domainName: String?
        /// The CNAME record that is added to the DNS database for domain validation.
        public let resourceRecord: AwsCertificateManagerCertificateResourceRecord?
        /// The domain name that Certificate Manager uses to send domain validation emails.
        public let validationDomain: String?
        /// A list of email addresses that Certificate Manager uses to send domain validation emails.
        public let validationEmails: [String]?
        /// The method used to validate the domain name.
        public let validationMethod: String?
        /// The validation status of the domain name.
        public let validationStatus: String?

        @inlinable
        public init(domainName: String? = nil, resourceRecord: AwsCertificateManagerCertificateResourceRecord? = nil, validationDomain: String? = nil, validationEmails: [String]? = nil, validationMethod: String? = nil, validationStatus: String? = nil) {
            self.domainName = domainName
            self.resourceRecord = resourceRecord
            self.validationDomain = validationDomain
            self.validationEmails = validationEmails
            self.validationMethod = validationMethod
            self.validationStatus = validationStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.resourceRecord?.validate(name: "\(name).resourceRecord")
            try self.validate(self.validationDomain, name: "validationDomain", parent: name, pattern: "\\S")
            try self.validationEmails?.forEach {
                try validate($0, name: "validationEmails[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.validationMethod, name: "validationMethod", parent: name, pattern: "\\S")
            try self.validate(self.validationStatus, name: "validationStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case resourceRecord = "ResourceRecord"
            case validationDomain = "ValidationDomain"
            case validationEmails = "ValidationEmails"
            case validationMethod = "ValidationMethod"
            case validationStatus = "ValidationStatus"
        }
    }

    public struct AwsCertificateManagerCertificateExtendedKeyUsage: AWSEncodableShape & AWSDecodableShape {
        /// The name of an extension value. Indicates the purpose for which the certificate public key can be used.
        public let name: String?
        /// An object identifier (OID) for the extension value. The format is numbers separated by periods.
        public let oId: String?

        @inlinable
        public init(name: String? = nil, oId: String? = nil) {
            self.name = name
            self.oId = oId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.oId, name: "oId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case oId = "OId"
        }
    }

    public struct AwsCertificateManagerCertificateKeyUsage: AWSEncodableShape & AWSDecodableShape {
        /// The key usage extension name.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct AwsCertificateManagerCertificateOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether to add the certificate to a transparency log. Valid values: DISABLED | ENABLED
        public let certificateTransparencyLoggingPreference: String?

        @inlinable
        public init(certificateTransparencyLoggingPreference: String? = nil) {
            self.certificateTransparencyLoggingPreference = certificateTransparencyLoggingPreference
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateTransparencyLoggingPreference, name: "certificateTransparencyLoggingPreference", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateTransparencyLoggingPreference = "CertificateTransparencyLoggingPreference"
        }
    }

    public struct AwsCertificateManagerCertificateRenewalSummary: AWSEncodableShape & AWSDecodableShape {
        /// Information about the validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal. Provided only when the certificate type is AMAZON_ISSUED.
        public let domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]?
        /// The status of the Certificate Manager managed renewal of the certificate. Valid values: PENDING_AUTO_RENEWAL | PENDING_VALIDATION | SUCCESS | FAILED
        public let renewalStatus: String?
        /// The reason that a renewal request was unsuccessful. This attribute is used only when RenewalStatus is FAILED. Valid values: NO_AVAILABLE_CONTACTS | ADDITIONAL_VERIFICATION_REQUIRED | DOMAIN_NOT_ALLOWED | INVALID_PUBLIC_DOMAIN | DOMAIN_VALIDATION_DENIED | CAA_ERROR | PCA_LIMIT_EXCEEDED | PCA_INVALID_ARN | PCA_INVALID_STATE | PCA_REQUEST_FAILED | PCA_NAME_CONSTRAINTS_VALIDATION | PCA_RESOURCE_NOT_FOUND | PCA_INVALID_ARGS | PCA_INVALID_DURATION | PCA_ACCESS_DENIED | SLR_NOT_FOUND | OTHER
        public let renewalStatusReason: String?
        /// Indicates when the renewal summary was last updated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let updatedAt: String?

        @inlinable
        public init(domainValidationOptions: [AwsCertificateManagerCertificateDomainValidationOption]? = nil, renewalStatus: String? = nil, renewalStatusReason: String? = nil, updatedAt: String? = nil) {
            self.domainValidationOptions = domainValidationOptions
            self.renewalStatus = renewalStatus
            self.renewalStatusReason = renewalStatusReason
            self.updatedAt = updatedAt
        }

        public func validate(name: String) throws {
            try self.domainValidationOptions?.forEach {
                try $0.validate(name: "\(name).domainValidationOptions[]")
            }
            try self.validate(self.renewalStatus, name: "renewalStatus", parent: name, pattern: "\\S")
            try self.validate(self.renewalStatusReason, name: "renewalStatusReason", parent: name, pattern: "\\S")
            try self.validate(self.updatedAt, name: "updatedAt", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case domainValidationOptions = "DomainValidationOptions"
            case renewalStatus = "RenewalStatus"
            case renewalStatusReason = "RenewalStatusReason"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct AwsCertificateManagerCertificateResourceRecord: AWSEncodableShape & AWSDecodableShape {
        /// The name of the resource.
        public let name: String?
        /// The type of resource.
        public let type: String?
        /// The value of the resource.
        public let value: String?

        @inlinable
        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct AwsCloudFormationStackDetails: AWSEncodableShape & AWSDecodableShape {
        /// The capabilities allowed in the stack.
        public let capabilities: [String]?
        /// The time at which the stack was created.
        public let creationTime: String?
        /// A user-defined description associated with the stack.
        public let description: String?
        /// Boolean to enable or disable rollback on stack creation failures.
        public let disableRollback: Bool?
        /// Information about whether a stack's actual configuration differs, or has drifted, from its expected
        /// configuration, as defined in the stack template and any values specified as template parameters.
        public let driftInformation: AwsCloudFormationStackDriftInformationDetails?
        /// Whether termination protection is enabled for the stack.
        public let enableTerminationProtection: Bool?
        /// The time the nested stack was last updated. This field will only be returned if the stack has been
        /// updated at least once.
        public let lastUpdatedTime: String?
        /// The Amazon Resource Names (ARNs) of the Amazon SNS topic to which stack-related events are published.
        public let notificationArns: [String]?
        /// A list of output structures.
        public let outputs: [AwsCloudFormationStackOutputsDetails]?
        /// The ARN of an IAM role that's associated with the stack.
        public let roleArn: String?
        /// Unique identifier of the stack.
        public let stackId: String?
        /// The name associated with the stack.
        public let stackName: String?
        /// Current status of the stack.
        public let stackStatus: String?
        /// Success or failure message associated with the stack status.
        public let stackStatusReason: String?
        /// The length of time, in minutes, that CloudFormation waits for the nested stack to reach
        /// the CREATE_COMPLETE state.
        public let timeoutInMinutes: Int?

        @inlinable
        public init(capabilities: [String]? = nil, creationTime: String? = nil, description: String? = nil, disableRollback: Bool? = nil, driftInformation: AwsCloudFormationStackDriftInformationDetails? = nil, enableTerminationProtection: Bool? = nil, lastUpdatedTime: String? = nil, notificationArns: [String]? = nil, outputs: [AwsCloudFormationStackOutputsDetails]? = nil, roleArn: String? = nil, stackId: String? = nil, stackName: String? = nil, stackStatus: String? = nil, stackStatusReason: String? = nil, timeoutInMinutes: Int? = nil) {
            self.capabilities = capabilities
            self.creationTime = creationTime
            self.description = description
            self.disableRollback = disableRollback
            self.driftInformation = driftInformation
            self.enableTerminationProtection = enableTerminationProtection
            self.lastUpdatedTime = lastUpdatedTime
            self.notificationArns = notificationArns
            self.outputs = outputs
            self.roleArn = roleArn
            self.stackId = stackId
            self.stackName = stackName
            self.stackStatus = stackStatus
            self.stackStatusReason = stackStatusReason
            self.timeoutInMinutes = timeoutInMinutes
        }

        public func validate(name: String) throws {
            try self.capabilities?.forEach {
                try validate($0, name: "capabilities[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.creationTime, name: "creationTime", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.driftInformation?.validate(name: "\(name).driftInformation")
            try self.validate(self.lastUpdatedTime, name: "lastUpdatedTime", parent: name, pattern: "\\S")
            try self.notificationArns?.forEach {
                try validate($0, name: "notificationArns[]", parent: name, pattern: "\\S")
            }
            try self.outputs?.forEach {
                try $0.validate(name: "\(name).outputs[]")
            }
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.stackId, name: "stackId", parent: name, pattern: "\\S")
            try self.validate(self.stackName, name: "stackName", parent: name, pattern: "\\S")
            try self.validate(self.stackStatus, name: "stackStatus", parent: name, pattern: "\\S")
            try self.validate(self.stackStatusReason, name: "stackStatusReason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case creationTime = "CreationTime"
            case description = "Description"
            case disableRollback = "DisableRollback"
            case driftInformation = "DriftInformation"
            case enableTerminationProtection = "EnableTerminationProtection"
            case lastUpdatedTime = "LastUpdatedTime"
            case notificationArns = "NotificationArns"
            case outputs = "Outputs"
            case roleArn = "RoleArn"
            case stackId = "StackId"
            case stackName = "StackName"
            case stackStatus = "StackStatus"
            case stackStatusReason = "StackStatusReason"
            case timeoutInMinutes = "TimeoutInMinutes"
        }
    }

    public struct AwsCloudFormationStackDriftInformationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Status of the stack's actual configuration compared to its expected template configuration.
        public let stackDriftStatus: String?

        @inlinable
        public init(stackDriftStatus: String? = nil) {
            self.stackDriftStatus = stackDriftStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.stackDriftStatus, name: "stackDriftStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case stackDriftStatus = "StackDriftStatus"
        }
    }

    public struct AwsCloudFormationStackOutputsDetails: AWSEncodableShape & AWSDecodableShape {
        /// A user-defined description associated with the output.
        public let description: String?
        /// The key associated with the output.
        public let outputKey: String?
        /// The value associated with the output.
        public let outputValue: String?

        @inlinable
        public init(description: String? = nil, outputKey: String? = nil, outputValue: String? = nil) {
            self.description = description
            self.outputKey = outputKey
            self.outputValue = outputValue
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.outputKey, name: "outputKey", parent: name, pattern: "\\S")
            try self.validate(self.outputValue, name: "outputValue", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case outputKey = "OutputKey"
            case outputValue = "OutputValue"
        }
    }

    public struct AwsCloudFrontDistributionCacheBehavior: AWSEncodableShape & AWSDecodableShape {
        /// The protocol that viewers can use to access the files in an origin. You can specify the following options:    allow-all - Viewers can use HTTP or HTTPS.    redirect-to-https - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.    https-only - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).
        public let viewerProtocolPolicy: String?

        @inlinable
        public init(viewerProtocolPolicy: String? = nil) {
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.viewerProtocolPolicy, name: "viewerProtocolPolicy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case viewerProtocolPolicy = "ViewerProtocolPolicy"
        }
    }

    public struct AwsCloudFrontDistributionCacheBehaviors: AWSEncodableShape & AWSDecodableShape {
        /// The cache behaviors for the distribution.
        public let items: [AwsCloudFrontDistributionCacheBehavior]?

        @inlinable
        public init(items: [AwsCloudFrontDistributionCacheBehavior]? = nil) {
            self.items = items
        }

        public func validate(name: String) throws {
            try self.items?.forEach {
                try $0.validate(name: "\(name).items[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
        }
    }

    public struct AwsCloudFrontDistributionDefaultCacheBehavior: AWSEncodableShape & AWSDecodableShape {
        /// The protocol that viewers can use to access the files in an origin. You can specify the following options:    allow-all - Viewers can use HTTP or HTTPS.    redirect-to-https - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.    https-only - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).
        public let viewerProtocolPolicy: String?

        @inlinable
        public init(viewerProtocolPolicy: String? = nil) {
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.viewerProtocolPolicy, name: "viewerProtocolPolicy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case viewerProtocolPolicy = "ViewerProtocolPolicy"
        }
    }

    public struct AwsCloudFrontDistributionDetails: AWSEncodableShape & AWSDecodableShape {
        /// Provides information about the cache configuration for the distribution.
        public let cacheBehaviors: AwsCloudFrontDistributionCacheBehaviors?
        /// The default cache behavior for the configuration.
        public let defaultCacheBehavior: AwsCloudFrontDistributionDefaultCacheBehavior?
        /// The object that CloudFront sends in response to requests from the origin (for example, index.html) when a viewer requests the root URL for the distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/product-description.html).
        public let defaultRootObject: String?
        /// The domain name corresponding to the distribution.
        public let domainName: String?
        /// The entity tag is a hash of the object.
        public let eTag: String?
        /// Indicates when that the distribution was last modified. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastModifiedTime: String?
        /// A complex type that controls whether access logs are written for the distribution.
        public let logging: AwsCloudFrontDistributionLogging?
        /// Provides information about the origin groups in the distribution.
        public let originGroups: AwsCloudFrontDistributionOriginGroups?
        /// A complex type that contains information about origins for this distribution.
        public let origins: AwsCloudFrontDistributionOrigins?
        /// Indicates the current status of the distribution.
        public let status: String?
        /// Provides information about the TLS/SSL configuration that the distribution uses to communicate with viewers.
        public let viewerCertificate: AwsCloudFrontDistributionViewerCertificate?
        /// A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution.
        public let webAclId: String?

        @inlinable
        public init(cacheBehaviors: AwsCloudFrontDistributionCacheBehaviors? = nil, defaultCacheBehavior: AwsCloudFrontDistributionDefaultCacheBehavior? = nil, defaultRootObject: String? = nil, domainName: String? = nil, eTag: String? = nil, lastModifiedTime: String? = nil, logging: AwsCloudFrontDistributionLogging? = nil, originGroups: AwsCloudFrontDistributionOriginGroups? = nil, origins: AwsCloudFrontDistributionOrigins? = nil, status: String? = nil, viewerCertificate: AwsCloudFrontDistributionViewerCertificate? = nil, webAclId: String? = nil) {
            self.cacheBehaviors = cacheBehaviors
            self.defaultCacheBehavior = defaultCacheBehavior
            self.defaultRootObject = defaultRootObject
            self.domainName = domainName
            self.eTag = eTag
            self.lastModifiedTime = lastModifiedTime
            self.logging = logging
            self.originGroups = originGroups
            self.origins = origins
            self.status = status
            self.viewerCertificate = viewerCertificate
            self.webAclId = webAclId
        }

        public func validate(name: String) throws {
            try self.cacheBehaviors?.validate(name: "\(name).cacheBehaviors")
            try self.defaultCacheBehavior?.validate(name: "\(name).defaultCacheBehavior")
            try self.validate(self.defaultRootObject, name: "defaultRootObject", parent: name, pattern: "\\S")
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "\\S")
            try self.validate(self.lastModifiedTime, name: "lastModifiedTime", parent: name, pattern: "\\S")
            try self.logging?.validate(name: "\(name).logging")
            try self.origins?.validate(name: "\(name).origins")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.viewerCertificate?.validate(name: "\(name).viewerCertificate")
            try self.validate(self.webAclId, name: "webAclId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cacheBehaviors = "CacheBehaviors"
            case defaultCacheBehavior = "DefaultCacheBehavior"
            case defaultRootObject = "DefaultRootObject"
            case domainName = "DomainName"
            case eTag = "ETag"
            case lastModifiedTime = "LastModifiedTime"
            case logging = "Logging"
            case originGroups = "OriginGroups"
            case origins = "Origins"
            case status = "Status"
            case viewerCertificate = "ViewerCertificate"
            case webAclId = "WebAclId"
        }
    }

    public struct AwsCloudFrontDistributionLogging: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket to store the access logs in.
        public let bucket: String?
        /// With this field, you can enable or disable the selected distribution.
        public let enabled: Bool?
        /// Specifies whether you want CloudFront to include cookies in access logs.
        public let includeCookies: Bool?
        /// An optional string that you want CloudFront to use as a prefix to the access log filenames for this distribution.
        public let prefix: String?

        @inlinable
        public init(bucket: String? = nil, enabled: Bool? = nil, includeCookies: Bool? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "\\S")
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case enabled = "Enabled"
            case includeCookies = "IncludeCookies"
            case prefix = "Prefix"
        }
    }

    public struct AwsCloudFrontDistributionOriginCustomOriginConfig: AWSEncodableShape & AWSDecodableShape {
        /// The HTTP port that CloudFront uses to connect to the origin.
        public let httpPort: Int?
        /// The HTTPS port that CloudFront uses to connect to the origin.
        public let httpsPort: Int?
        /// Specifies how long, in seconds, CloudFront persists its connection to the origin.
        public let originKeepaliveTimeout: Int?
        /// Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin.
        public let originProtocolPolicy: String?
        /// Specifies how long, in seconds, CloudFront waits for a response from the origin.
        public let originReadTimeout: Int?
        /// Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS.
        public let originSslProtocols: AwsCloudFrontDistributionOriginSslProtocols?

        @inlinable
        public init(httpPort: Int? = nil, httpsPort: Int? = nil, originKeepaliveTimeout: Int? = nil, originProtocolPolicy: String? = nil, originReadTimeout: Int? = nil, originSslProtocols: AwsCloudFrontDistributionOriginSslProtocols? = nil) {
            self.httpPort = httpPort
            self.httpsPort = httpsPort
            self.originKeepaliveTimeout = originKeepaliveTimeout
            self.originProtocolPolicy = originProtocolPolicy
            self.originReadTimeout = originReadTimeout
            self.originSslProtocols = originSslProtocols
        }

        public func validate(name: String) throws {
            try self.validate(self.originProtocolPolicy, name: "originProtocolPolicy", parent: name, pattern: "\\S")
            try self.originSslProtocols?.validate(name: "\(name).originSslProtocols")
        }

        private enum CodingKeys: String, CodingKey {
            case httpPort = "HttpPort"
            case httpsPort = "HttpsPort"
            case originKeepaliveTimeout = "OriginKeepaliveTimeout"
            case originProtocolPolicy = "OriginProtocolPolicy"
            case originReadTimeout = "OriginReadTimeout"
            case originSslProtocols = "OriginSslProtocols"
        }
    }

    public struct AwsCloudFrontDistributionOriginGroup: AWSEncodableShape & AWSDecodableShape {
        /// Provides the criteria for an origin group to fail over.
        public let failoverCriteria: AwsCloudFrontDistributionOriginGroupFailover?

        @inlinable
        public init(failoverCriteria: AwsCloudFrontDistributionOriginGroupFailover? = nil) {
            self.failoverCriteria = failoverCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case failoverCriteria = "FailoverCriteria"
        }
    }

    public struct AwsCloudFrontDistributionOriginGroupFailover: AWSEncodableShape & AWSDecodableShape {
        /// Information about the status codes that cause an origin group to fail over.
        public let statusCodes: AwsCloudFrontDistributionOriginGroupFailoverStatusCodes?

        @inlinable
        public init(statusCodes: AwsCloudFrontDistributionOriginGroupFailoverStatusCodes? = nil) {
            self.statusCodes = statusCodes
        }

        private enum CodingKeys: String, CodingKey {
            case statusCodes = "StatusCodes"
        }
    }

    public struct AwsCloudFrontDistributionOriginGroupFailoverStatusCodes: AWSEncodableShape & AWSDecodableShape {
        /// The list of status code values that can cause a failover to the next origin.
        public let items: [Int]?
        /// The number of status codes that can cause a failover.
        public let quantity: Int?

        @inlinable
        public init(items: [Int]? = nil, quantity: Int? = nil) {
            self.items = items
            self.quantity = quantity
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case quantity = "Quantity"
        }
    }

    public struct AwsCloudFrontDistributionOriginGroups: AWSEncodableShape & AWSDecodableShape {
        /// The list of origin groups.
        public let items: [AwsCloudFrontDistributionOriginGroup]?

        @inlinable
        public init(items: [AwsCloudFrontDistributionOriginGroup]? = nil) {
            self.items = items
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
        }
    }

    public struct AwsCloudFrontDistributionOriginItem: AWSEncodableShape & AWSDecodableShape {
        /// An origin that is not an Amazon S3 bucket, with one exception.
        /// If the Amazon S3 bucket is configured with static website hosting, use this attribute.
        /// If the Amazon S3 bucket is not configured with static website hosting, use the S3OriginConfig type instead.
        public let customOriginConfig: AwsCloudFrontDistributionOriginCustomOriginConfig?
        /// Amazon S3 origins: The DNS name of the S3 bucket from which you want CloudFront to get objects for this origin.
        public let domainName: String?
        /// A unique identifier for the origin or origin group.
        public let id: String?
        /// An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
        public let originPath: String?
        /// An origin that is an S3 bucket that is not configured with static website hosting.
        public let s3OriginConfig: AwsCloudFrontDistributionOriginS3OriginConfig?

        @inlinable
        public init(customOriginConfig: AwsCloudFrontDistributionOriginCustomOriginConfig? = nil, domainName: String? = nil, id: String? = nil, originPath: String? = nil, s3OriginConfig: AwsCloudFrontDistributionOriginS3OriginConfig? = nil) {
            self.customOriginConfig = customOriginConfig
            self.domainName = domainName
            self.id = id
            self.originPath = originPath
            self.s3OriginConfig = s3OriginConfig
        }

        public func validate(name: String) throws {
            try self.customOriginConfig?.validate(name: "\(name).customOriginConfig")
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.originPath, name: "originPath", parent: name, pattern: "\\S")
            try self.s3OriginConfig?.validate(name: "\(name).s3OriginConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case customOriginConfig = "CustomOriginConfig"
            case domainName = "DomainName"
            case id = "Id"
            case originPath = "OriginPath"
            case s3OriginConfig = "S3OriginConfig"
        }
    }

    public struct AwsCloudFrontDistributionOriginS3OriginConfig: AWSEncodableShape & AWSDecodableShape {
        /// The CloudFront origin access identity to associate with the origin.
        public let originAccessIdentity: String?

        @inlinable
        public init(originAccessIdentity: String? = nil) {
            self.originAccessIdentity = originAccessIdentity
        }

        public func validate(name: String) throws {
            try self.validate(self.originAccessIdentity, name: "originAccessIdentity", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case originAccessIdentity = "OriginAccessIdentity"
        }
    }

    public struct AwsCloudFrontDistributionOriginSslProtocols: AWSEncodableShape & AWSDecodableShape {
        /// A list that contains allowed SSL/TLS protocols for this distribution.
        public let items: [String]?
        /// The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing
        /// an HTTPS connection with this origin.
        public let quantity: Int?

        @inlinable
        public init(items: [String]? = nil, quantity: Int? = nil) {
            self.items = items
            self.quantity = quantity
        }

        public func validate(name: String) throws {
            try self.items?.forEach {
                try validate($0, name: "items[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case quantity = "Quantity"
        }
    }

    public struct AwsCloudFrontDistributionOrigins: AWSEncodableShape & AWSDecodableShape {
        /// A complex type that contains origins or origin groups for this distribution.
        public let items: [AwsCloudFrontDistributionOriginItem]?

        @inlinable
        public init(items: [AwsCloudFrontDistributionOriginItem]? = nil) {
            self.items = items
        }

        public func validate(name: String) throws {
            try self.items?.forEach {
                try $0.validate(name: "\(name).items[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
        }
    }

    public struct AwsCloudFrontDistributionViewerCertificate: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the ACM certificate. Used if the certificate is stored in ACM. If you provide an ACM certificate ARN, you must also provide MinimumCertificateVersion and SslSupportMethod.
        public let acmCertificateArn: String?
        /// The identifier of the certificate. Note that in CloudFront, this attribute is deprecated.
        public let certificate: String?
        /// The source of the certificate identified by Certificate. Note that in CloudFront, this attribute is deprecated.
        public let certificateSource: String?
        /// Whether the distribution uses the CloudFront domain name. If set to false, then you provide either AcmCertificateArn or IamCertificateId.
        public let cloudFrontDefaultCertificate: Bool?
        /// The identifier of the IAM certificate. Used if the certificate is stored in IAM. If you provide IamCertificateId, then you also must provide MinimumProtocolVersion and SslSupportMethod.
        public let iamCertificateId: String?
        /// The security policy that CloudFront uses for HTTPS connections with viewers. If SslSupportMethod is sni-only, then MinimumProtocolVersion must be TLSv1 or higher.
        public let minimumProtocolVersion: String?
        /// The viewers that the distribution accepts HTTPS connections from.
        public let sslSupportMethod: String?

        @inlinable
        public init(acmCertificateArn: String? = nil, certificate: String? = nil, certificateSource: String? = nil, cloudFrontDefaultCertificate: Bool? = nil, iamCertificateId: String? = nil, minimumProtocolVersion: String? = nil, sslSupportMethod: String? = nil) {
            self.acmCertificateArn = acmCertificateArn
            self.certificate = certificate
            self.certificateSource = certificateSource
            self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
            self.iamCertificateId = iamCertificateId
            self.minimumProtocolVersion = minimumProtocolVersion
            self.sslSupportMethod = sslSupportMethod
        }

        public func validate(name: String) throws {
            try self.validate(self.acmCertificateArn, name: "acmCertificateArn", parent: name, pattern: "\\S")
            try self.validate(self.certificate, name: "certificate", parent: name, pattern: "\\S")
            try self.validate(self.certificateSource, name: "certificateSource", parent: name, pattern: "\\S")
            try self.validate(self.iamCertificateId, name: "iamCertificateId", parent: name, pattern: "\\S")
            try self.validate(self.minimumProtocolVersion, name: "minimumProtocolVersion", parent: name, pattern: "\\S")
            try self.validate(self.sslSupportMethod, name: "sslSupportMethod", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case acmCertificateArn = "AcmCertificateArn"
            case certificate = "Certificate"
            case certificateSource = "CertificateSource"
            case cloudFrontDefaultCertificate = "CloudFrontDefaultCertificate"
            case iamCertificateId = "IamCertificateId"
            case minimumProtocolVersion = "MinimumProtocolVersion"
            case sslSupportMethod = "SslSupportMethod"
        }
    }

    public struct AwsCloudTrailTrailDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the log group that CloudTrail logs are delivered to.
        public let cloudWatchLogsLogGroupArn: String?
        /// The ARN of the role that the CloudWatch Events endpoint assumes when it writes to the log group.
        public let cloudWatchLogsRoleArn: String?
        /// Indicates whether the trail has custom event selectors.
        public let hasCustomEventSelectors: Bool?
        /// The Region where the trail was created.
        public let homeRegion: String?
        /// Indicates whether the trail publishes events from global services such as IAM to the log files.
        public let includeGlobalServiceEvents: Bool?
        /// Indicates whether the trail applies only to the current Region or to all Regions.
        public let isMultiRegionTrail: Bool?
        /// Whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account.
        public let isOrganizationTrail: Bool?
        /// The KMS key ID to use to encrypt the logs.
        public let kmsKeyId: String?
        /// Indicates whether CloudTrail log file validation is enabled.
        public let logFileValidationEnabled: Bool?
        /// The name of the trail.
        public let name: String?
        /// The name of the S3 bucket where the log files are published.
        public let s3BucketName: String?
        /// The S3 key prefix. The key prefix is added after the name of the S3 bucket where the log files are published.
        public let s3KeyPrefix: String?
        /// The ARN of the SNS topic that is used for notifications of log file delivery.
        public let snsTopicArn: String?
        /// The name of the SNS topic that is used for notifications of log file delivery.
        public let snsTopicName: String?
        /// The ARN of the trail.
        public let trailArn: String?

        @inlinable
        public init(cloudWatchLogsLogGroupArn: String? = nil, cloudWatchLogsRoleArn: String? = nil, hasCustomEventSelectors: Bool? = nil, homeRegion: String? = nil, includeGlobalServiceEvents: Bool? = nil, isMultiRegionTrail: Bool? = nil, isOrganizationTrail: Bool? = nil, kmsKeyId: String? = nil, logFileValidationEnabled: Bool? = nil, name: String? = nil, s3BucketName: String? = nil, s3KeyPrefix: String? = nil, snsTopicArn: String? = nil, snsTopicName: String? = nil, trailArn: String? = nil) {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.hasCustomEventSelectors = hasCustomEventSelectors
            self.homeRegion = homeRegion
            self.includeGlobalServiceEvents = includeGlobalServiceEvents
            self.isMultiRegionTrail = isMultiRegionTrail
            self.isOrganizationTrail = isOrganizationTrail
            self.kmsKeyId = kmsKeyId
            self.logFileValidationEnabled = logFileValidationEnabled
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.snsTopicArn = snsTopicArn
            self.snsTopicName = snsTopicName
            self.trailArn = trailArn
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.cloudWatchLogsRoleArn, name: "cloudWatchLogsRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.homeRegion, name: "homeRegion", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "\\S")
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, pattern: "\\S")
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "\\S")
            try self.validate(self.snsTopicName, name: "snsTopicName", parent: name, pattern: "\\S")
            try self.validate(self.trailArn, name: "trailArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
            case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
            case hasCustomEventSelectors = "HasCustomEventSelectors"
            case homeRegion = "HomeRegion"
            case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
            case isMultiRegionTrail = "IsMultiRegionTrail"
            case isOrganizationTrail = "IsOrganizationTrail"
            case kmsKeyId = "KmsKeyId"
            case logFileValidationEnabled = "LogFileValidationEnabled"
            case name = "Name"
            case s3BucketName = "S3BucketName"
            case s3KeyPrefix = "S3KeyPrefix"
            case snsTopicArn = "SnsTopicArn"
            case snsTopicName = "SnsTopicName"
            case trailArn = "TrailArn"
        }
    }

    public struct AwsCloudWatchAlarmDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether actions should be executed during any changes to the alarm state.
        public let actionsEnabled: Bool?
        /// The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an ALARM state from any other state.
        public let alarmActions: [String]?
        /// The ARN of the alarm.
        public let alarmArn: String?
        /// The time stamp of the last update to the alarm configuration.
        public let alarmConfigurationUpdatedTimestamp: String?
        /// The description of the alarm.
        public let alarmDescription: String?
        /// The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID
        /// and uses that ID for the alarm name.
        public let alarmName: String?
        /// The arithmetic operation to use when comparing the specified statistic and threshold. The specified
        /// statistic value is used as the first operand.
        public let comparisonOperator: String?
        /// The number of datapoints that must be breaching to trigger the alarm.
        public let datapointsToAlarm: Int?
        /// The dimensions for the metric associated with the alarm.
        public let dimensions: [AwsCloudWatchAlarmDimensionsDetails]?
        /// Used only for alarms based on percentiles. If ignore, the alarm state does not change during
        /// periods with too few data points to be statistically significant. If evaluate or this parameter is not used,
        /// the alarm is always evaluated and possibly changes state no matter how many data points are available.
        public let evaluateLowSampleCountPercentile: String?
        /// The number of periods over which data is compared to the specified threshold.
        public let evaluationPeriods: Int?
        /// The percentile statistic for the metric associated with the alarm.
        public let extendedStatistic: String?
        /// The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from
        /// any other state. Each action is specified as an ARN.
        public let insufficientDataActions: [String]?
        /// The name of the metric associated with the alarm. This is required for an alarm based on a metric.
        /// For an alarm based on a math expression, you use Metrics instead and you can't specify MetricName.
        public let metricName: String?
        /// The namespace of the metric associated with the alarm. This is required for an alarm based on a
        /// metric. For an alarm based on a math expression, you can't specify Namespace and you use
        /// Metrics instead.
        public let namespace: String?
        /// The actions to execute when this alarm transitions to the OK state from any other state.
        /// Each action is specified as an ARN.
        public let okActions: [String]?
        /// The period, in seconds, over which the statistic is applied. This is required for an alarm based on a
        /// metric.
        public let period: Int?
        /// The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ExtendedStatistic. For an alarm based on a metric, you must specify either Statistic or ExtendedStatistic but not both. For an alarm based on a math expression, you can't specify Statistic. Instead, you use Metrics.
        public let statistic: String?
        /// The value to compare with the specified statistic.
        public let threshold: Double?
        /// n an alarm based on an anomaly detection model, this is the ID of the ANOMALY_DETECTION_BAND function used as the threshold for the alarm.
        public let thresholdMetricId: String?
        /// Sets how this alarm is to handle missing data points.
        public let treatMissingData: String?
        /// The unit of the metric associated with the alarm.
        public let unit: String?

        @inlinable
        public init(actionsEnabled: Bool? = nil, alarmActions: [String]? = nil, alarmArn: String? = nil, alarmConfigurationUpdatedTimestamp: String? = nil, alarmDescription: String? = nil, alarmName: String? = nil, comparisonOperator: String? = nil, datapointsToAlarm: Int? = nil, dimensions: [AwsCloudWatchAlarmDimensionsDetails]? = nil, evaluateLowSampleCountPercentile: String? = nil, evaluationPeriods: Int? = nil, extendedStatistic: String? = nil, insufficientDataActions: [String]? = nil, metricName: String? = nil, namespace: String? = nil, okActions: [String]? = nil, period: Int? = nil, statistic: String? = nil, threshold: Double? = nil, thresholdMetricId: String? = nil, treatMissingData: String? = nil, unit: String? = nil) {
            self.actionsEnabled = actionsEnabled
            self.alarmActions = alarmActions
            self.alarmArn = alarmArn
            self.alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestamp
            self.alarmDescription = alarmDescription
            self.alarmName = alarmName
            self.comparisonOperator = comparisonOperator
            self.datapointsToAlarm = datapointsToAlarm
            self.dimensions = dimensions
            self.evaluateLowSampleCountPercentile = evaluateLowSampleCountPercentile
            self.evaluationPeriods = evaluationPeriods
            self.extendedStatistic = extendedStatistic
            self.insufficientDataActions = insufficientDataActions
            self.metricName = metricName
            self.namespace = namespace
            self.okActions = okActions
            self.period = period
            self.statistic = statistic
            self.threshold = threshold
            self.thresholdMetricId = thresholdMetricId
            self.treatMissingData = treatMissingData
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.alarmActions?.forEach {
                try validate($0, name: "alarmActions[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.alarmArn, name: "alarmArn", parent: name, pattern: "\\S")
            try self.validate(self.alarmConfigurationUpdatedTimestamp, name: "alarmConfigurationUpdatedTimestamp", parent: name, pattern: "\\S")
            try self.validate(self.alarmDescription, name: "alarmDescription", parent: name, pattern: "\\S")
            try self.validate(self.alarmName, name: "alarmName", parent: name, pattern: "\\S")
            try self.validate(self.comparisonOperator, name: "comparisonOperator", parent: name, pattern: "\\S")
            try self.dimensions?.forEach {
                try $0.validate(name: "\(name).dimensions[]")
            }
            try self.validate(self.evaluateLowSampleCountPercentile, name: "evaluateLowSampleCountPercentile", parent: name, pattern: "\\S")
            try self.validate(self.extendedStatistic, name: "extendedStatistic", parent: name, pattern: "\\S")
            try self.insufficientDataActions?.forEach {
                try validate($0, name: "insufficientDataActions[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "\\S")
            try self.okActions?.forEach {
                try validate($0, name: "okActions[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.statistic, name: "statistic", parent: name, pattern: "\\S")
            try self.validate(self.thresholdMetricId, name: "thresholdMetricId", parent: name, pattern: "\\S")
            try self.validate(self.treatMissingData, name: "treatMissingData", parent: name, pattern: "\\S")
            try self.validate(self.unit, name: "unit", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case actionsEnabled = "ActionsEnabled"
            case alarmActions = "AlarmActions"
            case alarmArn = "AlarmArn"
            case alarmConfigurationUpdatedTimestamp = "AlarmConfigurationUpdatedTimestamp"
            case alarmDescription = "AlarmDescription"
            case alarmName = "AlarmName"
            case comparisonOperator = "ComparisonOperator"
            case datapointsToAlarm = "DatapointsToAlarm"
            case dimensions = "Dimensions"
            case evaluateLowSampleCountPercentile = "EvaluateLowSampleCountPercentile"
            case evaluationPeriods = "EvaluationPeriods"
            case extendedStatistic = "ExtendedStatistic"
            case insufficientDataActions = "InsufficientDataActions"
            case metricName = "MetricName"
            case namespace = "Namespace"
            case okActions = "OkActions"
            case period = "Period"
            case statistic = "Statistic"
            case threshold = "Threshold"
            case thresholdMetricId = "ThresholdMetricId"
            case treatMissingData = "TreatMissingData"
            case unit = "Unit"
        }
    }

    public struct AwsCloudWatchAlarmDimensionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of a dimension.
        public let name: String?
        /// The value of a dimension.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsCodeBuildProjectArtifactsDetails: AWSEncodableShape & AWSDecodableShape {
        /// An identifier for the artifact definition.
        public let artifactIdentifier: String?
        /// Indicates whether to disable encryption on the artifact. Only valid when Type is S3.
        public let encryptionDisabled: Bool?
        /// Only used when Type is S3. The name of the S3 bucket where the artifact is located.
        public let location: String?
        /// Only used when Type is S3. The name of the artifact. Used with NamepaceType and Path to determine the pattern for storing the artifact.
        public let name: String?
        /// Only used when Type is S3. The value to use for the namespace. Used with Name and Path to determine the pattern for storing the artifact.
        public let namespaceType: String?
        /// Whether the name specified in the buildspec file overrides the artifact name.
        public let overrideArtifactName: Bool?
        /// Only used when Type is S3. The type of output artifact to create.
        public let packaging: String?
        /// Only used when Type is S3. The path to the artifact. Used with Name and NamespaceType to determine the pattern for storing the artifact.
        public let path: String?
        /// The type of build artifact.
        public let type: String?

        @inlinable
        public init(artifactIdentifier: String? = nil, encryptionDisabled: Bool? = nil, location: String? = nil, name: String? = nil, namespaceType: String? = nil, overrideArtifactName: Bool? = nil, packaging: String? = nil, path: String? = nil, type: String? = nil) {
            self.artifactIdentifier = artifactIdentifier
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.name = name
            self.namespaceType = namespaceType
            self.overrideArtifactName = overrideArtifactName
            self.packaging = packaging
            self.path = path
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.artifactIdentifier, name: "artifactIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.location, name: "location", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.namespaceType, name: "namespaceType", parent: name, pattern: "\\S")
            try self.validate(self.packaging, name: "packaging", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactIdentifier = "ArtifactIdentifier"
            case encryptionDisabled = "EncryptionDisabled"
            case location = "Location"
            case name = "Name"
            case namespaceType = "NamespaceType"
            case overrideArtifactName = "OverrideArtifactName"
            case packaging = "Packaging"
            case path = "Path"
            case type = "Type"
        }
    }

    public struct AwsCodeBuildProjectDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about the build artifacts for the CodeBuild project.
        public let artifacts: [AwsCodeBuildProjectArtifactsDetails]?
        /// The KMS key used to encrypt the build output artifacts. You can specify either the ARN of the KMS key or, if available, the KMS key alias (using the format alias/alias-name).
        public let encryptionKey: String?
        /// Information about the build environment for this build project.
        public let environment: AwsCodeBuildProjectEnvironment?
        /// Information about logs for the build project.
        public let logsConfig: AwsCodeBuildProjectLogsConfigDetails?
        /// The name of the build project.
        public let name: String?
        /// Information about the secondary artifacts for the CodeBuild project.
        public let secondaryArtifacts: [AwsCodeBuildProjectArtifactsDetails]?
        /// The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.
        public let serviceRole: String?
        /// Information about the build input source code for this build project.
        public let source: AwsCodeBuildProjectSource?
        /// Information about the VPC configuration that CodeBuild accesses.
        public let vpcConfig: AwsCodeBuildProjectVpcConfig?

        @inlinable
        public init(artifacts: [AwsCodeBuildProjectArtifactsDetails]? = nil, encryptionKey: String? = nil, environment: AwsCodeBuildProjectEnvironment? = nil, logsConfig: AwsCodeBuildProjectLogsConfigDetails? = nil, name: String? = nil, secondaryArtifacts: [AwsCodeBuildProjectArtifactsDetails]? = nil, serviceRole: String? = nil, source: AwsCodeBuildProjectSource? = nil, vpcConfig: AwsCodeBuildProjectVpcConfig? = nil) {
            self.artifacts = artifacts
            self.encryptionKey = encryptionKey
            self.environment = environment
            self.logsConfig = logsConfig
            self.name = name
            self.secondaryArtifacts = secondaryArtifacts
            self.serviceRole = serviceRole
            self.source = source
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.artifacts?.forEach {
                try $0.validate(name: "\(name).artifacts[]")
            }
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, pattern: "\\S")
            try self.environment?.validate(name: "\(name).environment")
            try self.logsConfig?.validate(name: "\(name).logsConfig")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.secondaryArtifacts?.forEach {
                try $0.validate(name: "\(name).secondaryArtifacts[]")
            }
            try self.validate(self.serviceRole, name: "serviceRole", parent: name, pattern: "\\S")
            try self.source?.validate(name: "\(name).source")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case artifacts = "Artifacts"
            case encryptionKey = "EncryptionKey"
            case environment = "Environment"
            case logsConfig = "LogsConfig"
            case name = "Name"
            case secondaryArtifacts = "SecondaryArtifacts"
            case serviceRole = "ServiceRole"
            case source = "Source"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct AwsCodeBuildProjectEnvironment: AWSEncodableShape & AWSDecodableShape {
        /// The certificate to use with this build project.
        public let certificate: String?
        /// A set of environment variables to make available to builds for the build project.
        public let environmentVariables: [AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails]?
        /// The type of credentials CodeBuild uses to pull images in your build. Valid values:    CODEBUILD specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust the CodeBuild service principal.    SERVICE_ROLE specifies that CodeBuild uses your build project's service role.   When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an CodeBuild curated image, you must use CODEBUILD credentials.
        public let imagePullCredentialsType: String?
        /// Whether to allow the Docker daemon to run inside a Docker container. Set to true if the build project is used to build Docker images.
        public let privilegedMode: Bool?
        /// The credentials for access to a private registry.
        public let registryCredential: AwsCodeBuildProjectEnvironmentRegistryCredential?
        /// The type of build environment to use for related builds. The environment type ARM_CONTAINER is available only in Regions US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and Europe (Frankfurt). The environment type LINUX_CONTAINER with compute type build.general1.2xlarge is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia). The environment type LINUX_GPU_CONTAINER is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia). Valid values: WINDOWS_CONTAINER | LINUX_CONTAINER | LINUX_GPU_CONTAINER | ARM_CONTAINER
        public let type: String?

        @inlinable
        public init(certificate: String? = nil, environmentVariables: [AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails]? = nil, imagePullCredentialsType: String? = nil, privilegedMode: Bool? = nil, registryCredential: AwsCodeBuildProjectEnvironmentRegistryCredential? = nil, type: String? = nil) {
            self.certificate = certificate
            self.environmentVariables = environmentVariables
            self.imagePullCredentialsType = imagePullCredentialsType
            self.privilegedMode = privilegedMode
            self.registryCredential = registryCredential
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.certificate, name: "certificate", parent: name, pattern: "\\S")
            try self.environmentVariables?.forEach {
                try $0.validate(name: "\(name).environmentVariables[]")
            }
            try self.validate(self.imagePullCredentialsType, name: "imagePullCredentialsType", parent: name, pattern: "\\S")
            try self.registryCredential?.validate(name: "\(name).registryCredential")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
            case environmentVariables = "EnvironmentVariables"
            case imagePullCredentialsType = "ImagePullCredentialsType"
            case privilegedMode = "PrivilegedMode"
            case registryCredential = "RegistryCredential"
            case type = "Type"
        }
    }

    public struct AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the environment variable.
        public let name: String?
        /// The type of environment variable.
        public let type: String?
        /// The value of the environment variable.
        public let value: String?

        @inlinable
        public init(name: String? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct AwsCodeBuildProjectEnvironmentRegistryCredential: AWSEncodableShape & AWSDecodableShape {
        /// The ARN or name of credentials created using Secrets Manager.  The credential can use the name of the credentials only if they exist in your current Amazon Web Services Region.
        public let credential: String?
        /// The service that created the credentials to access a private Docker registry. The valid value, SECRETS_MANAGER, is for Secrets Manager.
        public let credentialProvider: String?

        @inlinable
        public init(credential: String? = nil, credentialProvider: String? = nil) {
            self.credential = credential
            self.credentialProvider = credentialProvider
        }

        public func validate(name: String) throws {
            try self.validate(self.credential, name: "credential", parent: name, pattern: "\\S")
            try self.validate(self.credentialProvider, name: "credentialProvider", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case credential = "Credential"
            case credentialProvider = "CredentialProvider"
        }
    }

    public struct AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The group name of the logs in CloudWatch Logs.
        public let groupName: String?
        /// The current status of the logs in CloudWatch Logs for a build project.
        public let status: String?
        /// The prefix of the stream name of the CloudWatch Logs.
        public let streamName: String?

        @inlinable
        public init(groupName: String? = nil, status: String? = nil, streamName: String? = nil) {
            self.groupName = groupName
            self.status = status
            self.streamName = streamName
        }

        public func validate(name: String) throws {
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.streamName, name: "streamName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case status = "Status"
            case streamName = "StreamName"
        }
    }

    public struct AwsCodeBuildProjectLogsConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about CloudWatch Logs for the build project.
        public let cloudWatchLogs: AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails?
        /// Information about logs built to an S3 bucket for a build project.
        public let s3Logs: AwsCodeBuildProjectLogsConfigS3LogsDetails?

        @inlinable
        public init(cloudWatchLogs: AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails? = nil, s3Logs: AwsCodeBuildProjectLogsConfigS3LogsDetails? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Logs = s3Logs
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogs?.validate(name: "\(name).cloudWatchLogs")
            try self.s3Logs?.validate(name: "\(name).s3Logs")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs = "CloudWatchLogs"
            case s3Logs = "S3Logs"
        }
    }

    public struct AwsCodeBuildProjectLogsConfigS3LogsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to disable encryption of the S3 build log output.
        public let encryptionDisabled: Bool?
        /// The ARN of the S3 bucket and the path prefix for S3 logs.
        public let location: String?
        /// The current status of the S3 build logs.
        public let status: String?

        @inlinable
        public init(encryptionDisabled: Bool? = nil, location: String? = nil, status: String? = nil) {
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.location, name: "location", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionDisabled = "EncryptionDisabled"
            case location = "Location"
            case status = "Status"
        }
    }

    public struct AwsCodeBuildProjectSource: AWSEncodableShape & AWSDecodableShape {
        /// Information about the Git clone depth for the build project.
        public let gitCloneDepth: Int?
        /// Whether to ignore SSL warnings while connecting to the project source code.
        public let insecureSsl: Bool?
        /// Information about the location of the source code to be built. Valid values include:   For source code settings that are specified in the source action of a pipeline in CodePipeline, location should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.   For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the build spec file (for example, https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name ).   For source code in an S3 input bucket, one of the following.   The path to the ZIP file that contains the source code (for example, bucket-name/path/to/object-name.zip).   The path to the folder that contains the source code (for example, bucket-name/path/to/source-code/folder/).     For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the build spec file.   For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the build spec file.
        public let location: String?
        /// The type of repository that contains the source code to be built. Valid values are:    BITBUCKET - The source code is in a Bitbucket repository.    CODECOMMIT - The source code is in an CodeCommit repository.    CODEPIPELINE - The source code settings are specified in the source action of a pipeline in CodePipeline.    GITHUB - The source code is in a GitHub repository.    GITHUB_ENTERPRISE - The source code is in a GitHub Enterprise repository.    NO_SOURCE - The project does not have input source code.    S3 - The source code is in an S3 input bucket.
        public let type: String?

        @inlinable
        public init(gitCloneDepth: Int? = nil, insecureSsl: Bool? = nil, location: String? = nil, type: String? = nil) {
            self.gitCloneDepth = gitCloneDepth
            self.insecureSsl = insecureSsl
            self.location = location
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.location, name: "location", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case gitCloneDepth = "GitCloneDepth"
            case insecureSsl = "InsecureSsl"
            case location = "Location"
            case type = "Type"
        }
    }

    public struct AwsCodeBuildProjectVpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of one or more security group IDs in your VPC.
        public let securityGroupIds: [String]?
        /// A list of one or more subnet IDs in your VPC.
        public let subnets: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        @inlinable
        public init(securityGroupIds: [String]? = nil, subnets: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "\\S")
            }
            try self.subnets?.forEach {
                try validate($0, name: "subnets[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnets = "Subnets"
            case vpcId = "VpcId"
        }
    }

    public struct AwsCorsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the CORS request includes credentials.
        public let allowCredentials: Bool?
        /// The allowed headers for CORS requests.
        public let allowHeaders: [String]?
        /// The allowed methods for CORS requests.
        public let allowMethods: [String]?
        /// The allowed origins for CORS requests.
        public let allowOrigins: [String]?
        /// The exposed headers for CORS requests.
        public let exposeHeaders: [String]?
        /// The number of seconds for which the browser caches preflight request results.
        public let maxAge: Int?

        @inlinable
        public init(allowCredentials: Bool? = nil, allowHeaders: [String]? = nil, allowMethods: [String]? = nil, allowOrigins: [String]? = nil, exposeHeaders: [String]? = nil, maxAge: Int? = nil) {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }

        public func validate(name: String) throws {
            try self.allowHeaders?.forEach {
                try validate($0, name: "allowHeaders[]", parent: name, pattern: "\\S")
            }
            try self.allowMethods?.forEach {
                try validate($0, name: "allowMethods[]", parent: name, pattern: "\\S")
            }
            try self.allowOrigins?.forEach {
                try validate($0, name: "allowOrigins[]", parent: name, pattern: "\\S")
            }
            try self.exposeHeaders?.forEach {
                try validate($0, name: "exposeHeaders[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowCredentials = "AllowCredentials"
            case allowHeaders = "AllowHeaders"
            case allowMethods = "AllowMethods"
            case allowOrigins = "AllowOrigins"
            case exposeHeaders = "ExposeHeaders"
            case maxAge = "MaxAge"
        }
    }

    public struct AwsDmsEndpointDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) for the SSL certificate that encrypts connections between the DMS endpoint and the  replication instance.
        public let certificateArn: String?
        ///  The name of the endpoint database.
        public let databaseName: String?
        ///  The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String?
        ///  The database endpoint identifier.
        public let endpointIdentifier: String?
        ///  The type of endpoint. Valid values are source and target.
        public let endpointType: String?
        ///  The type of engine for the endpoint, depending on the EndpointType value.
        public let engineName: String?
        ///  A value that can be used for cross-account validation.
        public let externalId: String?
        ///  Additional attributes associated with the connection.
        public let extraConnectionAttributes: String?
        ///  An DMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default  encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your  Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        ///  The port used to access the endpoint.
        public let port: Int?
        ///  The name of the server where the endpoint database resides.
        public let serverName: String?
        ///  The SSL mode used to connect to the endpoint. The default is none.
        public let sslMode: String?
        ///  The user name to be used to log in to the endpoint database.
        public let username: String?

        @inlinable
        public init(certificateArn: String? = nil, databaseName: String? = nil, endpointArn: String? = nil, endpointIdentifier: String? = nil, endpointType: String? = nil, engineName: String? = nil, externalId: String? = nil, extraConnectionAttributes: String? = nil, kmsKeyId: String? = nil, port: Int? = nil, serverName: String? = nil, sslMode: String? = nil, username: String? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineName = engineName
            self.externalId = externalId
            self.extraConnectionAttributes = extraConnectionAttributes
            self.kmsKeyId = kmsKeyId
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, pattern: "\\S")
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "\\S")
            try self.validate(self.endpointArn, name: "endpointArn", parent: name, pattern: "\\S")
            try self.validate(self.endpointIdentifier, name: "endpointIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.endpointType, name: "endpointType", parent: name, pattern: "\\S")
            try self.validate(self.engineName, name: "engineName", parent: name, pattern: "\\S")
            try self.validate(self.externalId, name: "externalId", parent: name, pattern: "\\S")
            try self.validate(self.extraConnectionAttributes, name: "extraConnectionAttributes", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.serverName, name: "serverName", parent: name, pattern: "\\S")
            try self.validate(self.sslMode, name: "sslMode", parent: name, pattern: "\\S")
            try self.validate(self.username, name: "username", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case endpointArn = "EndpointArn"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointType = "EndpointType"
            case engineName = "EngineName"
            case externalId = "ExternalId"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case kmsKeyId = "KmsKeyId"
            case port = "Port"
            case serverName = "ServerName"
            case sslMode = "SslMode"
            case username = "Username"
        }
    }

    public struct AwsDmsReplicationInstanceDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let allocatedStorage: Int?
        ///  Indicates whether minor engine upgrades are applied automatically to the replication instance during the maintenance  window.
        public let autoMinorVersionUpgrade: Bool?
        ///  The Availability Zone that the replication instance is created in. The default value is a random, system-chosen  Availability Zone in the endpoint's Amazon Web Services Region, such as us-east-1d.
        public let availabilityZone: String?
        ///  The engine version number of the replication instance. If an engine version number is not specified when a  replication instance is created, the default is the latest engine version available.
        public let engineVersion: String?
        ///  An KMS key identifier that is used to encrypt the data on the replication instance. If you don't  specify a value for the KmsKeyId parameter, DMS uses your default encryption key.  KMS creates the default encryption key for your Amazon Web Services account. Your  Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        ///  Specifies whether the replication instance is deployed across multiple Availability Zones (AZs). You can't set the  AvailabilityZone parameter if the MultiAZ parameter is set to true.
        public let multiAZ: Bool?
        ///  The maintenance window times for the replication instance. Upgrades to the replication instance are performed during  this time.
        public let preferredMaintenanceWindow: String?
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance  with a public IP address. A value of false represents an instance with a private IP address. The default  value is true.
        public let publiclyAccessible: Bool?
        ///  The compute and memory capacity of the replication instance as defined for the specified replication instance class.
        public let replicationInstanceClass: String?
        ///  The replication instance identifier.
        public let replicationInstanceIdentifier: String?
        ///  The subnet group for the replication instance.
        public let replicationSubnetGroup: AwsDmsReplicationInstanceReplicationSubnetGroupDetails?
        ///  The virtual private cloud (VPC) security group for the replication instance.
        public let vpcSecurityGroups: [AwsDmsReplicationInstanceVpcSecurityGroupsDetails]?

        @inlinable
        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, engineVersion: String? = nil, kmsKeyId: String? = nil, multiAZ: Bool? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, replicationInstanceClass: String? = nil, replicationInstanceIdentifier: String? = nil, replicationSubnetGroup: AwsDmsReplicationInstanceReplicationSubnetGroupDetails? = nil, vpcSecurityGroups: [AwsDmsReplicationInstanceVpcSecurityGroupsDetails]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.engineVersion = engineVersion
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationSubnetGroup = replicationSubnetGroup
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.preferredMaintenanceWindow, name: "preferredMaintenanceWindow", parent: name, pattern: "\\S")
            try self.validate(self.replicationInstanceClass, name: "replicationInstanceClass", parent: name, pattern: "\\S")
            try self.validate(self.replicationInstanceIdentifier, name: "replicationInstanceIdentifier", parent: name, pattern: "\\S")
            try self.replicationSubnetGroup?.validate(name: "\(name).replicationSubnetGroup")
            try self.vpcSecurityGroups?.forEach {
                try $0.validate(name: "\(name).vpcSecurityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case engineVersion = "EngineVersion"
            case kmsKeyId = "KmsKeyId"
            case multiAZ = "MultiAZ"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case publiclyAccessible = "PubliclyAccessible"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case replicationSubnetGroup = "ReplicationSubnetGroup"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct AwsDmsReplicationInstanceReplicationSubnetGroupDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The identifier of the replication subnet group.
        public let replicationSubnetGroupIdentifier: String?

        @inlinable
        public init(replicationSubnetGroupIdentifier: String? = nil) {
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.replicationSubnetGroupIdentifier, name: "replicationSubnetGroupIdentifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        }
    }

    public struct AwsDmsReplicationInstanceVpcSecurityGroupsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The identifier of the VPC security group thatâ€™s associated with the replication instance.
        public let vpcSecurityGroupId: String?

        @inlinable
        public init(vpcSecurityGroupId: String? = nil) {
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.vpcSecurityGroupId, name: "vpcSecurityGroupId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }

    public struct AwsDmsReplicationTaskDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates when you want a change data capture (CDC) operation to start. CCdcStartPosition or  CCdcStartTime specifies when you want a CDC operation to start. Only a value for one of these fields  is included.
        public let cdcStartPosition: String?
        ///  Indicates the start time for a CDC operation. CdcStartPosition or CCdcStartTime specifies  when you want a CDC operation to start. Only a value for one of these fields is included.
        public let cdcStartTime: String?
        ///  Indicates when you want a CDC operation to stop. The value can be either server time or commit time.
        public let cdcStopPosition: String?
        ///  The identifier of the replication task.
        public let id: String?
        ///  The migration type.
        public let migrationType: String?
        ///  The Amazon Resource Name (ARN) of a replication instance.
        public let replicationInstanceArn: String?
        ///  The user-defined replication task identifier or name.
        public let replicationTaskIdentifier: String?
        ///  The settings for the replication task.
        public let replicationTaskSettings: String?
        ///  A display name for the resource identifier at the end of the EndpointArn response parameter.  If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for  the end of EndpointArn.
        public let resourceIdentifier: String?
        ///  The ARN of the source endpoint.
        public let sourceEndpointArn: String?
        ///  The table mappings for the replication task, in JSON format.
        public let tableMappings: String?
        ///  The ARN of the target endpoint.
        public let targetEndpointArn: String?
        ///  Supplemental information that the task requires to migrate the data for certain source and target endpoints.
        public let taskData: String?

        @inlinable
        public init(cdcStartPosition: String? = nil, cdcStartTime: String? = nil, cdcStopPosition: String? = nil, id: String? = nil, migrationType: String? = nil, replicationInstanceArn: String? = nil, replicationTaskIdentifier: String? = nil, replicationTaskSettings: String? = nil, resourceIdentifier: String? = nil, sourceEndpointArn: String? = nil, tableMappings: String? = nil, targetEndpointArn: String? = nil, taskData: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.id = id
            self.migrationType = migrationType
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.resourceIdentifier = resourceIdentifier
            self.sourceEndpointArn = sourceEndpointArn
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
            self.taskData = taskData
        }

        public func validate(name: String) throws {
            try self.validate(self.cdcStartPosition, name: "cdcStartPosition", parent: name, pattern: "\\S")
            try self.validate(self.cdcStartTime, name: "cdcStartTime", parent: name, pattern: "\\S")
            try self.validate(self.cdcStopPosition, name: "cdcStopPosition", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.migrationType, name: "migrationType", parent: name, pattern: "\\S")
            try self.validate(self.replicationInstanceArn, name: "replicationInstanceArn", parent: name, pattern: "\\S")
            try self.validate(self.replicationTaskIdentifier, name: "replicationTaskIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.replicationTaskSettings, name: "replicationTaskSettings", parent: name, pattern: "\\S")
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.sourceEndpointArn, name: "sourceEndpointArn", parent: name, pattern: "\\S")
            try self.validate(self.tableMappings, name: "tableMappings", parent: name, pattern: "\\S")
            try self.validate(self.targetEndpointArn, name: "targetEndpointArn", parent: name, pattern: "\\S")
            try self.validate(self.taskData, name: "taskData", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case id = "Id"
            case migrationType = "MigrationType"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskSettings = "ReplicationTaskSettings"
            case resourceIdentifier = "ResourceIdentifier"
            case sourceEndpointArn = "SourceEndpointArn"
            case tableMappings = "TableMappings"
            case targetEndpointArn = "TargetEndpointArn"
            case taskData = "TaskData"
        }
    }

    public struct AwsDynamoDbTableAttributeDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The name of the attribute.
        public let attributeName: String?
        /// The type of the attribute.
        public let attributeType: String?

        @inlinable
        public init(attributeName: String? = nil, attributeType: String? = nil) {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "\\S")
            try self.validate(self.attributeType, name: "attributeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeType = "AttributeType"
        }
    }

    public struct AwsDynamoDbTableBillingModeSummary: AWSEncodableShape & AWSDecodableShape {
        /// The method used to charge for read and write throughput and to manage capacity.
        public let billingMode: String?
        /// If the billing mode is PAY_PER_REQUEST, indicates when the billing mode was set to that value. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastUpdateToPayPerRequestDateTime: String?

        @inlinable
        public init(billingMode: String? = nil, lastUpdateToPayPerRequestDateTime: String? = nil) {
            self.billingMode = billingMode
            self.lastUpdateToPayPerRequestDateTime = lastUpdateToPayPerRequestDateTime
        }

        public func validate(name: String) throws {
            try self.validate(self.billingMode, name: "billingMode", parent: name, pattern: "\\S")
            try self.validate(self.lastUpdateToPayPerRequestDateTime, name: "lastUpdateToPayPerRequestDateTime", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case billingMode = "BillingMode"
            case lastUpdateToPayPerRequestDateTime = "LastUpdateToPayPerRequestDateTime"
        }
    }

    public struct AwsDynamoDbTableDetails: AWSEncodableShape & AWSDecodableShape {
        /// A list of attribute definitions for the table.
        public let attributeDefinitions: [AwsDynamoDbTableAttributeDefinition]?
        /// Information about the billing for read/write capacity on the table.
        public let billingModeSummary: AwsDynamoDbTableBillingModeSummary?
        /// Indicates when the table was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let creationDateTime: String?
        ///  Indicates whether deletion protection is to be enabled (true) or disabled (false) on the table.
        public let deletionProtectionEnabled: Bool?
        /// List of global secondary indexes for the table.
        public let globalSecondaryIndexes: [AwsDynamoDbTableGlobalSecondaryIndex]?
        /// The version of global tables being used.
        public let globalTableVersion: String?
        /// The number of items in the table.
        public let itemCount: Int?
        /// The primary key structure for the table.
        public let keySchema: [AwsDynamoDbTableKeySchema]?
        /// The ARN of the latest stream for the table.
        public let latestStreamArn: String?
        /// The label of the latest stream. The label is not a unique identifier.
        public let latestStreamLabel: String?
        /// The list of local secondary indexes for the table.
        public let localSecondaryIndexes: [AwsDynamoDbTableLocalSecondaryIndex]?
        /// Information about the provisioned throughput for the table.
        public let provisionedThroughput: AwsDynamoDbTableProvisionedThroughput?
        /// The list of replicas of this table.
        public let replicas: [AwsDynamoDbTableReplica]?
        /// Information about the restore for the table.
        public let restoreSummary: AwsDynamoDbTableRestoreSummary?
        /// Information about the server-side encryption for the table.
        public let sseDescription: AwsDynamoDbTableSseDescription?
        /// The current DynamoDB Streams configuration for the table.
        public let streamSpecification: AwsDynamoDbTableStreamSpecification?
        /// The identifier of the table.
        public let tableId: String?
        /// The name of the table.
        public let tableName: String?
        /// The total size of the table in bytes.
        public let tableSizeBytes: Int64?
        /// The current status of the table. Valid values are as follows:    ACTIVE     ARCHIVED     ARCHIVING     CREATING     DELETING     INACCESSIBLE_ENCRYPTION_CREDENTIALS     UPDATING
        public let tableStatus: String?

        @inlinable
        public init(attributeDefinitions: [AwsDynamoDbTableAttributeDefinition]? = nil, billingModeSummary: AwsDynamoDbTableBillingModeSummary? = nil, creationDateTime: String? = nil, deletionProtectionEnabled: Bool? = nil, globalSecondaryIndexes: [AwsDynamoDbTableGlobalSecondaryIndex]? = nil, globalTableVersion: String? = nil, itemCount: Int? = nil, keySchema: [AwsDynamoDbTableKeySchema]? = nil, latestStreamArn: String? = nil, latestStreamLabel: String? = nil, localSecondaryIndexes: [AwsDynamoDbTableLocalSecondaryIndex]? = nil, provisionedThroughput: AwsDynamoDbTableProvisionedThroughput? = nil, replicas: [AwsDynamoDbTableReplica]? = nil, restoreSummary: AwsDynamoDbTableRestoreSummary? = nil, sseDescription: AwsDynamoDbTableSseDescription? = nil, streamSpecification: AwsDynamoDbTableStreamSpecification? = nil, tableId: String? = nil, tableName: String? = nil, tableSizeBytes: Int64? = nil, tableStatus: String? = nil) {
            self.attributeDefinitions = attributeDefinitions
            self.billingModeSummary = billingModeSummary
            self.creationDateTime = creationDateTime
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.globalSecondaryIndexes = globalSecondaryIndexes
            self.globalTableVersion = globalTableVersion
            self.itemCount = itemCount
            self.keySchema = keySchema
            self.latestStreamArn = latestStreamArn
            self.latestStreamLabel = latestStreamLabel
            self.localSecondaryIndexes = localSecondaryIndexes
            self.provisionedThroughput = provisionedThroughput
            self.replicas = replicas
            self.restoreSummary = restoreSummary
            self.sseDescription = sseDescription
            self.streamSpecification = streamSpecification
            self.tableId = tableId
            self.tableName = tableName
            self.tableSizeBytes = tableSizeBytes
            self.tableStatus = tableStatus
        }

        public func validate(name: String) throws {
            try self.attributeDefinitions?.forEach {
                try $0.validate(name: "\(name).attributeDefinitions[]")
            }
            try self.billingModeSummary?.validate(name: "\(name).billingModeSummary")
            try self.validate(self.creationDateTime, name: "creationDateTime", parent: name, pattern: "\\S")
            try self.globalSecondaryIndexes?.forEach {
                try $0.validate(name: "\(name).globalSecondaryIndexes[]")
            }
            try self.validate(self.globalTableVersion, name: "globalTableVersion", parent: name, pattern: "\\S")
            try self.keySchema?.forEach {
                try $0.validate(name: "\(name).keySchema[]")
            }
            try self.validate(self.latestStreamArn, name: "latestStreamArn", parent: name, pattern: "\\S")
            try self.validate(self.latestStreamLabel, name: "latestStreamLabel", parent: name, pattern: "\\S")
            try self.localSecondaryIndexes?.forEach {
                try $0.validate(name: "\(name).localSecondaryIndexes[]")
            }
            try self.provisionedThroughput?.validate(name: "\(name).provisionedThroughput")
            try self.replicas?.forEach {
                try $0.validate(name: "\(name).replicas[]")
            }
            try self.restoreSummary?.validate(name: "\(name).restoreSummary")
            try self.sseDescription?.validate(name: "\(name).sseDescription")
            try self.streamSpecification?.validate(name: "\(name).streamSpecification")
            try self.validate(self.tableId, name: "tableId", parent: name, pattern: "\\S")
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "\\S")
            try self.validate(self.tableStatus, name: "tableStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeDefinitions = "AttributeDefinitions"
            case billingModeSummary = "BillingModeSummary"
            case creationDateTime = "CreationDateTime"
            case deletionProtectionEnabled = "DeletionProtectionEnabled"
            case globalSecondaryIndexes = "GlobalSecondaryIndexes"
            case globalTableVersion = "GlobalTableVersion"
            case itemCount = "ItemCount"
            case keySchema = "KeySchema"
            case latestStreamArn = "LatestStreamArn"
            case latestStreamLabel = "LatestStreamLabel"
            case localSecondaryIndexes = "LocalSecondaryIndexes"
            case provisionedThroughput = "ProvisionedThroughput"
            case replicas = "Replicas"
            case restoreSummary = "RestoreSummary"
            case sseDescription = "SseDescription"
            case streamSpecification = "StreamSpecification"
            case tableId = "TableId"
            case tableName = "TableName"
            case tableSizeBytes = "TableSizeBytes"
            case tableStatus = "TableStatus"
        }
    }

    public struct AwsDynamoDbTableGlobalSecondaryIndex: AWSEncodableShape & AWSDecodableShape {
        /// Whether the index is currently backfilling.
        public let backfilling: Bool?
        /// The ARN of the index.
        public let indexArn: String?
        /// The name of the index.
        public let indexName: String?
        /// The total size in bytes of the index.
        public let indexSizeBytes: Int64?
        /// The current status of the index.    ACTIVE     CREATING     DELETING     UPDATING
        public let indexStatus: String?
        /// The number of items in the index.
        public let itemCount: Int?
        /// The key schema for the index.
        public let keySchema: [AwsDynamoDbTableKeySchema]?
        /// Attributes that are copied from the table into an index.
        public let projection: AwsDynamoDbTableProjection?
        /// Information about the provisioned throughput settings for the indexes.
        public let provisionedThroughput: AwsDynamoDbTableProvisionedThroughput?

        @inlinable
        public init(backfilling: Bool? = nil, indexArn: String? = nil, indexName: String? = nil, indexSizeBytes: Int64? = nil, indexStatus: String? = nil, itemCount: Int? = nil, keySchema: [AwsDynamoDbTableKeySchema]? = nil, projection: AwsDynamoDbTableProjection? = nil, provisionedThroughput: AwsDynamoDbTableProvisionedThroughput? = nil) {
            self.backfilling = backfilling
            self.indexArn = indexArn
            self.indexName = indexName
            self.indexSizeBytes = indexSizeBytes
            self.indexStatus = indexStatus
            self.itemCount = itemCount
            self.keySchema = keySchema
            self.projection = projection
            self.provisionedThroughput = provisionedThroughput
        }

        public func validate(name: String) throws {
            try self.validate(self.indexArn, name: "indexArn", parent: name, pattern: "\\S")
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "\\S")
            try self.validate(self.indexStatus, name: "indexStatus", parent: name, pattern: "\\S")
            try self.keySchema?.forEach {
                try $0.validate(name: "\(name).keySchema[]")
            }
            try self.projection?.validate(name: "\(name).projection")
            try self.provisionedThroughput?.validate(name: "\(name).provisionedThroughput")
        }

        private enum CodingKeys: String, CodingKey {
            case backfilling = "Backfilling"
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case indexSizeBytes = "IndexSizeBytes"
            case indexStatus = "IndexStatus"
            case itemCount = "ItemCount"
            case keySchema = "KeySchema"
            case projection = "Projection"
            case provisionedThroughput = "ProvisionedThroughput"
        }
    }

    public struct AwsDynamoDbTableKeySchema: AWSEncodableShape & AWSDecodableShape {
        /// The name of the key schema attribute.
        public let attributeName: String?
        /// The type of key used for the key schema attribute. Valid values are HASH or RANGE.
        public let keyType: String?

        @inlinable
        public init(attributeName: String? = nil, keyType: String? = nil) {
            self.attributeName = attributeName
            self.keyType = keyType
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "\\S")
            try self.validate(self.keyType, name: "keyType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case keyType = "KeyType"
        }
    }

    public struct AwsDynamoDbTableLocalSecondaryIndex: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the index.
        public let indexArn: String?
        /// The name of the index.
        public let indexName: String?
        /// The complete key schema for the index.
        public let keySchema: [AwsDynamoDbTableKeySchema]?
        /// Attributes that are copied from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        public let projection: AwsDynamoDbTableProjection?

        @inlinable
        public init(indexArn: String? = nil, indexName: String? = nil, keySchema: [AwsDynamoDbTableKeySchema]? = nil, projection: AwsDynamoDbTableProjection? = nil) {
            self.indexArn = indexArn
            self.indexName = indexName
            self.keySchema = keySchema
            self.projection = projection
        }

        public func validate(name: String) throws {
            try self.validate(self.indexArn, name: "indexArn", parent: name, pattern: "\\S")
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "\\S")
            try self.keySchema?.forEach {
                try $0.validate(name: "\(name).keySchema[]")
            }
            try self.projection?.validate(name: "\(name).projection")
        }

        private enum CodingKeys: String, CodingKey {
            case indexArn = "IndexArn"
            case indexName = "IndexName"
            case keySchema = "KeySchema"
            case projection = "Projection"
        }
    }

    public struct AwsDynamoDbTableProjection: AWSEncodableShape & AWSDecodableShape {
        /// The nonkey attributes that are projected into the index. For each attribute, provide the attribute name.
        public let nonKeyAttributes: [String]?
        /// The types of attributes that are projected into the index. Valid values are as follows:    ALL     INCLUDE     KEYS_ONLY
        public let projectionType: String?

        @inlinable
        public init(nonKeyAttributes: [String]? = nil, projectionType: String? = nil) {
            self.nonKeyAttributes = nonKeyAttributes
            self.projectionType = projectionType
        }

        public func validate(name: String) throws {
            try self.nonKeyAttributes?.forEach {
                try validate($0, name: "nonKeyAttributes[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.projectionType, name: "projectionType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case nonKeyAttributes = "NonKeyAttributes"
            case projectionType = "ProjectionType"
        }
    }

    public struct AwsDynamoDbTableProvisionedThroughput: AWSEncodableShape & AWSDecodableShape {
        /// Indicates when the provisioned throughput was last decreased. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastDecreaseDateTime: String?
        /// Indicates when the provisioned throughput was last increased. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastIncreaseDateTime: String?
        /// The number of times during the current UTC calendar day that the provisioned throughput was decreased.
        public let numberOfDecreasesToday: Int?
        /// The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ThrottlingException.
        public let readCapacityUnits: Int?
        /// The maximum number of writes consumed per second before DynamoDB returns a ThrottlingException.
        public let writeCapacityUnits: Int?

        @inlinable
        public init(lastDecreaseDateTime: String? = nil, lastIncreaseDateTime: String? = nil, numberOfDecreasesToday: Int? = nil, readCapacityUnits: Int? = nil, writeCapacityUnits: Int? = nil) {
            self.lastDecreaseDateTime = lastDecreaseDateTime
            self.lastIncreaseDateTime = lastIncreaseDateTime
            self.numberOfDecreasesToday = numberOfDecreasesToday
            self.readCapacityUnits = readCapacityUnits
            self.writeCapacityUnits = writeCapacityUnits
        }

        public func validate(name: String) throws {
            try self.validate(self.lastDecreaseDateTime, name: "lastDecreaseDateTime", parent: name, pattern: "\\S")
            try self.validate(self.lastIncreaseDateTime, name: "lastIncreaseDateTime", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case lastDecreaseDateTime = "LastDecreaseDateTime"
            case lastIncreaseDateTime = "LastIncreaseDateTime"
            case numberOfDecreasesToday = "NumberOfDecreasesToday"
            case readCapacityUnits = "ReadCapacityUnits"
            case writeCapacityUnits = "WriteCapacityUnits"
        }
    }

    public struct AwsDynamoDbTableProvisionedThroughputOverride: AWSEncodableShape & AWSDecodableShape {
        /// The read capacity units for the replica.
        public let readCapacityUnits: Int?

        @inlinable
        public init(readCapacityUnits: Int? = nil) {
            self.readCapacityUnits = readCapacityUnits
        }

        private enum CodingKeys: String, CodingKey {
            case readCapacityUnits = "ReadCapacityUnits"
        }
    }

    public struct AwsDynamoDbTableReplica: AWSEncodableShape & AWSDecodableShape {
        /// List of global secondary indexes for the replica.
        public let globalSecondaryIndexes: [AwsDynamoDbTableReplicaGlobalSecondaryIndex]?
        /// The identifier of the KMS key that will be used for KMS encryption for the replica.
        public let kmsMasterKeyId: String?
        /// Replica-specific configuration for the provisioned throughput.
        public let provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride?
        /// The name of the Region where the replica is located.
        public let regionName: String?
        /// The current status of the replica. Valid values are as follows:    ACTIVE     CREATING     CREATION_FAILED     DELETING     UPDATING
        public let replicaStatus: String?
        /// Detailed information about the replica status.
        public let replicaStatusDescription: String?

        @inlinable
        public init(globalSecondaryIndexes: [AwsDynamoDbTableReplicaGlobalSecondaryIndex]? = nil, kmsMasterKeyId: String? = nil, provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride? = nil, regionName: String? = nil, replicaStatus: String? = nil, replicaStatusDescription: String? = nil) {
            self.globalSecondaryIndexes = globalSecondaryIndexes
            self.kmsMasterKeyId = kmsMasterKeyId
            self.provisionedThroughputOverride = provisionedThroughputOverride
            self.regionName = regionName
            self.replicaStatus = replicaStatus
            self.replicaStatusDescription = replicaStatusDescription
        }

        public func validate(name: String) throws {
            try self.globalSecondaryIndexes?.forEach {
                try $0.validate(name: "\(name).globalSecondaryIndexes[]")
            }
            try self.validate(self.kmsMasterKeyId, name: "kmsMasterKeyId", parent: name, pattern: "\\S")
            try self.validate(self.regionName, name: "regionName", parent: name, pattern: "\\S")
            try self.validate(self.replicaStatus, name: "replicaStatus", parent: name, pattern: "\\S")
            try self.validate(self.replicaStatusDescription, name: "replicaStatusDescription", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case globalSecondaryIndexes = "GlobalSecondaryIndexes"
            case kmsMasterKeyId = "KmsMasterKeyId"
            case provisionedThroughputOverride = "ProvisionedThroughputOverride"
            case regionName = "RegionName"
            case replicaStatus = "ReplicaStatus"
            case replicaStatusDescription = "ReplicaStatusDescription"
        }
    }

    public struct AwsDynamoDbTableReplicaGlobalSecondaryIndex: AWSEncodableShape & AWSDecodableShape {
        /// The name of the index.
        public let indexName: String?
        /// Replica-specific configuration for the provisioned throughput for the index.
        public let provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride?

        @inlinable
        public init(indexName: String? = nil, provisionedThroughputOverride: AwsDynamoDbTableProvisionedThroughputOverride? = nil) {
            self.indexName = indexName
            self.provisionedThroughputOverride = provisionedThroughputOverride
        }

        public func validate(name: String) throws {
            try self.validate(self.indexName, name: "indexName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case indexName = "IndexName"
            case provisionedThroughputOverride = "ProvisionedThroughputOverride"
        }
    }

    public struct AwsDynamoDbTableRestoreSummary: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the point in time that the table was restored to. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let restoreDateTime: String?
        /// Whether a restore is currently in progress.
        public let restoreInProgress: Bool?
        /// The ARN of the source backup from which the table was restored.
        public let sourceBackupArn: String?
        /// The ARN of the source table for the backup.
        public let sourceTableArn: String?

        @inlinable
        public init(restoreDateTime: String? = nil, restoreInProgress: Bool? = nil, sourceBackupArn: String? = nil, sourceTableArn: String? = nil) {
            self.restoreDateTime = restoreDateTime
            self.restoreInProgress = restoreInProgress
            self.sourceBackupArn = sourceBackupArn
            self.sourceTableArn = sourceTableArn
        }

        public func validate(name: String) throws {
            try self.validate(self.restoreDateTime, name: "restoreDateTime", parent: name, pattern: "\\S")
            try self.validate(self.sourceBackupArn, name: "sourceBackupArn", parent: name, pattern: "\\S")
            try self.validate(self.sourceTableArn, name: "sourceTableArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case restoreDateTime = "RestoreDateTime"
            case restoreInProgress = "RestoreInProgress"
            case sourceBackupArn = "SourceBackupArn"
            case sourceTableArn = "SourceTableArn"
        }
    }

    public struct AwsDynamoDbTableSseDescription: AWSEncodableShape & AWSDecodableShape {
        /// If the key is inaccessible, the date and time when DynamoDB detected that the key was inaccessible. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let inaccessibleEncryptionDateTime: String?
        /// The ARN of the KMS key that is used for the KMS encryption.
        public let kmsMasterKeyArn: String?
        /// The type of server-side encryption.
        public let sseType: String?
        /// The status of the server-side encryption.
        public let status: String?

        @inlinable
        public init(inaccessibleEncryptionDateTime: String? = nil, kmsMasterKeyArn: String? = nil, sseType: String? = nil, status: String? = nil) {
            self.inaccessibleEncryptionDateTime = inaccessibleEncryptionDateTime
            self.kmsMasterKeyArn = kmsMasterKeyArn
            self.sseType = sseType
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.inaccessibleEncryptionDateTime, name: "inaccessibleEncryptionDateTime", parent: name, pattern: "\\S")
            try self.validate(self.kmsMasterKeyArn, name: "kmsMasterKeyArn", parent: name, pattern: "\\S")
            try self.validate(self.sseType, name: "sseType", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case inaccessibleEncryptionDateTime = "InaccessibleEncryptionDateTime"
            case kmsMasterKeyArn = "KmsMasterKeyArn"
            case sseType = "SseType"
            case status = "Status"
        }
    }

    public struct AwsDynamoDbTableStreamSpecification: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether DynamoDB Streams is enabled on the table.
        public let streamEnabled: Bool?
        /// Determines the information that is written to the table.
        public let streamViewType: String?

        @inlinable
        public init(streamEnabled: Bool? = nil, streamViewType: String? = nil) {
            self.streamEnabled = streamEnabled
            self.streamViewType = streamViewType
        }

        public func validate(name: String) throws {
            try self.validate(self.streamViewType, name: "streamViewType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case streamEnabled = "StreamEnabled"
            case streamViewType = "StreamViewType"
        }
    }

    public struct AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The ID of the Active Directory used for authentication.
        public let directoryId: String?

        @inlinable
        public init(directoryId: String? = nil) {
            self.directoryId = directoryId
        }

        public func validate(name: String) throws {
            try self.validate(self.directoryId, name: "directoryId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case directoryId = "DirectoryId"
        }
    }

    public struct AwsEc2ClientVpnEndpointAuthenticationOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Information about the Active Directory, if applicable. With Active Directory authentication, clients are authenticated  against existing Active Directory groups.
        public let activeDirectory: AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails?
        ///  Information about the IAM SAML identity provider, if applicable.
        public let federatedAuthentication: AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails?
        ///  Information about the authentication certificates, if applicable.
        public let mutualAuthentication: AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails?
        ///  The authentication type used.
        public let type: String?

        @inlinable
        public init(activeDirectory: AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails? = nil, federatedAuthentication: AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails? = nil, mutualAuthentication: AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails? = nil, type: String? = nil) {
            self.activeDirectory = activeDirectory
            self.federatedAuthentication = federatedAuthentication
            self.mutualAuthentication = mutualAuthentication
            self.type = type
        }

        public func validate(name: String) throws {
            try self.activeDirectory?.validate(name: "\(name).activeDirectory")
            try self.federatedAuthentication?.validate(name: "\(name).federatedAuthentication")
            try self.mutualAuthentication?.validate(name: "\(name).mutualAuthentication")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectory = "ActiveDirectory"
            case federatedAuthentication = "FederatedAuthentication"
            case mutualAuthentication = "MutualAuthentication"
            case type = "Type"
        }
    }

    public struct AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the IAM SAML identity provider.
        public let samlProviderArn: String?
        ///  The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.
        public let selfServiceSamlProviderArn: String?

        @inlinable
        public init(samlProviderArn: String? = nil, selfServiceSamlProviderArn: String? = nil) {
            self.samlProviderArn = samlProviderArn
            self.selfServiceSamlProviderArn = selfServiceSamlProviderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.samlProviderArn, name: "samlProviderArn", parent: name, pattern: "\\S")
            try self.validate(self.selfServiceSamlProviderArn, name: "selfServiceSamlProviderArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case samlProviderArn = "SamlProviderArn"
            case selfServiceSamlProviderArn = "SelfServiceSamlProviderArn"
        }
    }

    public struct AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the client certificate.
        public let clientRootCertificateChain: String?

        @inlinable
        public init(clientRootCertificateChain: String? = nil) {
            self.clientRootCertificateChain = clientRootCertificateChain
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRootCertificateChain, name: "clientRootCertificateChain", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRootCertificateChain = "ClientRootCertificateChain"
        }
    }

    public struct AwsEc2ClientVpnEndpointClientConnectOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether client connect options are enabled.
        public let enabled: Bool?
        ///  The Amazon Resource Name (ARN) of the Lambda function used for connection authorization.
        public let lambdaFunctionArn: String?
        ///  The status of any updates to the client connect options.
        public let status: AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails?

        @inlinable
        public init(enabled: Bool? = nil, lambdaFunctionArn: String? = nil, status: AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails? = nil) {
            self.enabled = enabled
            self.lambdaFunctionArn = lambdaFunctionArn
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaFunctionArn, name: "lambdaFunctionArn", parent: name, pattern: "\\S")
            try self.status?.validate(name: "\(name).status")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case lambdaFunctionArn = "LambdaFunctionArn"
            case status = "Status"
        }
    }

    public struct AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The status code.
        public let code: String?
        ///  The status message.
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, pattern: "\\S")
            try self.validate(self.message, name: "message", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Customizable text that will be displayed in a banner on Amazon Web Services provided clients when a VPN session is  established.
        public let bannerText: String?
        ///  Current state of text banner feature.
        public let enabled: Bool?

        @inlinable
        public init(bannerText: String? = nil, enabled: Bool? = nil) {
            self.bannerText = bannerText
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.validate(self.bannerText, name: "bannerText", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case bannerText = "BannerText"
            case enabled = "Enabled"
        }
    }

    public struct AwsEc2ClientVpnEndpointConnectionLogOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the Amazon CloudWatch Logs log group to which connection logging data is published.
        public let cloudwatchLogGroup: String?
        ///  The name of the Amazon CloudWatch Logs log stream to which connection logging data is published.
        public let cloudwatchLogStream: String?
        ///  Indicates whether client connection logging is enabled for the Client VPN endpoint.
        public let enabled: Bool?

        @inlinable
        public init(cloudwatchLogGroup: String? = nil, cloudwatchLogStream: String? = nil, enabled: Bool? = nil) {
            self.cloudwatchLogGroup = cloudwatchLogGroup
            self.cloudwatchLogStream = cloudwatchLogStream
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudwatchLogGroup, name: "cloudwatchLogGroup", parent: name, pattern: "\\S")
            try self.validate(self.cloudwatchLogStream, name: "cloudwatchLogStream", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudwatchLogGroup = "CloudwatchLogGroup"
            case cloudwatchLogStream = "CloudwatchLogStream"
            case enabled = "Enabled"
        }
    }

    public struct AwsEc2ClientVpnEndpointDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Information about the authentication method used by the Client VPN endpoint.
        public let authenticationOptions: [AwsEc2ClientVpnEndpointAuthenticationOptionsDetails]?
        ///  The IPv4 address range, in CIDR notation, from which client IP addresses are assigned.
        public let clientCidrBlock: String?
        ///  The options for managing connection authorization for new client connections.
        public let clientConnectOptions: AwsEc2ClientVpnEndpointClientConnectOptionsDetails?
        ///  Options for enabling a customizable text banner that will be displayed on Amazon Web Services provided clients when a  VPN session is established.
        public let clientLoginBannerOptions: AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails?
        ///  The ID of the Client VPN endpoint.
        public let clientVpnEndpointId: String?
        ///  Information about the client connection logging options for the Client VPN endpoint.
        public let connectionLogOptions: AwsEc2ClientVpnEndpointConnectionLogOptionsDetails?
        ///  A brief description of the endpoint.
        public let description: String?
        ///  Information about the DNS servers to be used for DNS resolution.
        public let dnsServer: [String]?
        ///  The IDs of the security groups for the target network.
        public let securityGroupIdSet: [String]?
        ///  The URL of the self-service portal.
        public let selfServicePortalUrl: String?
        ///  The Amazon Resource Name (ARN) of the server certificate.
        public let serverCertificateArn: String?
        ///  The maximum VPN session duration time in hours.
        public let sessionTimeoutHours: Int?
        ///  Indicates whether split-tunnel is enabled in the Client VPN endpoint.
        public let splitTunnel: Bool?
        ///  The transport protocol used by the Client VPN endpoint.
        public let transportProtocol: String?
        ///  The ID of the VPC.
        public let vpcId: String?
        ///  The port number for the Client VPN endpoint.
        public let vpnPort: Int?

        @inlinable
        public init(authenticationOptions: [AwsEc2ClientVpnEndpointAuthenticationOptionsDetails]? = nil, clientCidrBlock: String? = nil, clientConnectOptions: AwsEc2ClientVpnEndpointClientConnectOptionsDetails? = nil, clientLoginBannerOptions: AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails? = nil, clientVpnEndpointId: String? = nil, connectionLogOptions: AwsEc2ClientVpnEndpointConnectionLogOptionsDetails? = nil, description: String? = nil, dnsServer: [String]? = nil, securityGroupIdSet: [String]? = nil, selfServicePortalUrl: String? = nil, serverCertificateArn: String? = nil, sessionTimeoutHours: Int? = nil, splitTunnel: Bool? = nil, transportProtocol: String? = nil, vpcId: String? = nil, vpnPort: Int? = nil) {
            self.authenticationOptions = authenticationOptions
            self.clientCidrBlock = clientCidrBlock
            self.clientConnectOptions = clientConnectOptions
            self.clientLoginBannerOptions = clientLoginBannerOptions
            self.clientVpnEndpointId = clientVpnEndpointId
            self.connectionLogOptions = connectionLogOptions
            self.description = description
            self.dnsServer = dnsServer
            self.securityGroupIdSet = securityGroupIdSet
            self.selfServicePortalUrl = selfServicePortalUrl
            self.serverCertificateArn = serverCertificateArn
            self.sessionTimeoutHours = sessionTimeoutHours
            self.splitTunnel = splitTunnel
            self.transportProtocol = transportProtocol
            self.vpcId = vpcId
            self.vpnPort = vpnPort
        }

        public func validate(name: String) throws {
            try self.authenticationOptions?.forEach {
                try $0.validate(name: "\(name).authenticationOptions[]")
            }
            try self.validate(self.clientCidrBlock, name: "clientCidrBlock", parent: name, pattern: "\\S")
            try self.clientConnectOptions?.validate(name: "\(name).clientConnectOptions")
            try self.clientLoginBannerOptions?.validate(name: "\(name).clientLoginBannerOptions")
            try self.validate(self.clientVpnEndpointId, name: "clientVpnEndpointId", parent: name, pattern: "\\S")
            try self.connectionLogOptions?.validate(name: "\(name).connectionLogOptions")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.dnsServer?.forEach {
                try validate($0, name: "dnsServer[]", parent: name, pattern: "\\S")
            }
            try self.securityGroupIdSet?.forEach {
                try validate($0, name: "securityGroupIdSet[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.selfServicePortalUrl, name: "selfServicePortalUrl", parent: name, pattern: "\\S")
            try self.validate(self.serverCertificateArn, name: "serverCertificateArn", parent: name, pattern: "\\S")
            try self.validate(self.transportProtocol, name: "transportProtocol", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationOptions = "AuthenticationOptions"
            case clientCidrBlock = "ClientCidrBlock"
            case clientConnectOptions = "ClientConnectOptions"
            case clientLoginBannerOptions = "ClientLoginBannerOptions"
            case clientVpnEndpointId = "ClientVpnEndpointId"
            case connectionLogOptions = "ConnectionLogOptions"
            case description = "Description"
            case dnsServer = "DnsServer"
            case securityGroupIdSet = "SecurityGroupIdSet"
            case selfServicePortalUrl = "SelfServicePortalUrl"
            case serverCertificateArn = "ServerCertificateArn"
            case sessionTimeoutHours = "SessionTimeoutHours"
            case splitTunnel = "SplitTunnel"
            case transportProtocol = "TransportProtocol"
            case vpcId = "VpcId"
            case vpnPort = "VpnPort"
        }
    }

    public struct AwsEc2EipDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier that Amazon Web Services assigns to represent the allocation of the Elastic IP address for use with Amazon VPC.
        public let allocationId: String?
        /// The identifier that represents the association of the Elastic IP address with an EC2 instance.
        public let associationId: String?
        /// The domain in which to allocate the address. If the address is for use with EC2 instances in a VPC, then Domain is vpc. Otherwise, Domain is standard.
        public let domain: String?
        /// The identifier of the EC2 instance.
        public let instanceId: String?
        /// The name of the location from which the Elastic IP address is advertised.
        public let networkBorderGroup: String?
        /// The identifier of the network interface.
        public let networkInterfaceId: String?
        /// The Amazon Web Services account ID of the owner of the network interface.
        public let networkInterfaceOwnerId: String?
        /// The private IP address that is associated with the Elastic IP address.
        public let privateIpAddress: String?
        /// A public IP address that is associated with the EC2 instance.
        public let publicIp: String?
        /// The identifier of an IP address pool. This parameter allows Amazon EC2 to select an IP address from the address pool.
        public let publicIpv4Pool: String?

        @inlinable
        public init(allocationId: String? = nil, associationId: String? = nil, domain: String? = nil, instanceId: String? = nil, networkBorderGroup: String? = nil, networkInterfaceId: String? = nil, networkInterfaceOwnerId: String? = nil, privateIpAddress: String? = nil, publicIp: String? = nil, publicIpv4Pool: String? = nil) {
            self.allocationId = allocationId
            self.associationId = associationId
            self.domain = domain
            self.instanceId = instanceId
            self.networkBorderGroup = networkBorderGroup
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfaceOwnerId = networkInterfaceOwnerId
            self.privateIpAddress = privateIpAddress
            self.publicIp = publicIp
            self.publicIpv4Pool = publicIpv4Pool
        }

        public func validate(name: String) throws {
            try self.validate(self.allocationId, name: "allocationId", parent: name, pattern: "\\S")
            try self.validate(self.associationId, name: "associationId", parent: name, pattern: "\\S")
            try self.validate(self.domain, name: "domain", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "\\S")
            try self.validate(self.networkBorderGroup, name: "networkBorderGroup", parent: name, pattern: "\\S")
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
            try self.validate(self.networkInterfaceOwnerId, name: "networkInterfaceOwnerId", parent: name, pattern: "\\S")
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "\\S")
            try self.validate(self.publicIp, name: "publicIp", parent: name, pattern: "\\S")
            try self.validate(self.publicIpv4Pool, name: "publicIpv4Pool", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case allocationId = "AllocationId"
            case associationId = "AssociationId"
            case domain = "Domain"
            case instanceId = "InstanceId"
            case networkBorderGroup = "NetworkBorderGroup"
            case networkInterfaceId = "NetworkInterfaceId"
            case networkInterfaceOwnerId = "NetworkInterfaceOwnerId"
            case privateIpAddress = "PrivateIpAddress"
            case publicIp = "PublicIp"
            case publicIpv4Pool = "PublicIpv4Pool"
        }
    }

    public struct AwsEc2InstanceDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IAM profile ARN of the instance.
        public let iamInstanceProfileArn: String?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public let imageId: String?
        /// The IPv4 addresses associated with the instance.
        public let ipV4Addresses: [String]?
        /// The IPv6 addresses associated with the instance.
        public let ipV6Addresses: [String]?
        /// The key name associated with the instance.
        public let keyName: String?
        /// Indicates when the instance was launched. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let launchedAt: String?
        /// Details about the metadata options for the Amazon EC2 instance.
        public let metadataOptions: AwsEc2InstanceMetadataOptions?
        ///  Describes the type of monitoring thatâ€™s turned on for an instance.
        public let monitoring: AwsEc2InstanceMonitoringDetails?
        /// The identifiers of the network interfaces for the EC2 instance. The details for each network interface are in a corresponding AwsEc2NetworkInterfacesDetails object.
        public let networkInterfaces: [AwsEc2InstanceNetworkInterfacesDetails]?
        /// The identifier of the subnet that the instance was launched in.
        public let subnetId: String?
        /// The instance type of the instance.
        public let type: String?
        /// The virtualization type of the Amazon Machine Image (AMI) required to launch the instance.
        public let virtualizationType: String?
        /// The identifier of the VPC that the instance was launched in.
        public let vpcId: String?

        @inlinable
        public init(iamInstanceProfileArn: String? = nil, imageId: String? = nil, ipV4Addresses: [String]? = nil, ipV6Addresses: [String]? = nil, keyName: String? = nil, launchedAt: String? = nil, metadataOptions: AwsEc2InstanceMetadataOptions? = nil, monitoring: AwsEc2InstanceMonitoringDetails? = nil, networkInterfaces: [AwsEc2InstanceNetworkInterfacesDetails]? = nil, subnetId: String? = nil, type: String? = nil, virtualizationType: String? = nil, vpcId: String? = nil) {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.metadataOptions = metadataOptions
            self.monitoring = monitoring
            self.networkInterfaces = networkInterfaces
            self.subnetId = subnetId
            self.type = type
            self.virtualizationType = virtualizationType
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.iamInstanceProfileArn, name: "iamInstanceProfileArn", parent: name, pattern: "\\S")
            try self.validate(self.imageId, name: "imageId", parent: name, pattern: "\\S")
            try self.ipV4Addresses?.forEach {
                try validate($0, name: "ipV4Addresses[]", parent: name, pattern: "\\S")
            }
            try self.ipV6Addresses?.forEach {
                try validate($0, name: "ipV6Addresses[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "\\S")
            try self.validate(self.launchedAt, name: "launchedAt", parent: name, pattern: "\\S")
            try self.metadataOptions?.validate(name: "\(name).metadataOptions")
            try self.monitoring?.validate(name: "\(name).monitoring")
            try self.networkInterfaces?.forEach {
                try $0.validate(name: "\(name).networkInterfaces[]")
            }
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.virtualizationType, name: "virtualizationType", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case iamInstanceProfileArn = "IamInstanceProfileArn"
            case imageId = "ImageId"
            case ipV4Addresses = "IpV4Addresses"
            case ipV6Addresses = "IpV6Addresses"
            case keyName = "KeyName"
            case launchedAt = "LaunchedAt"
            case metadataOptions = "MetadataOptions"
            case monitoring = "Monitoring"
            case networkInterfaces = "NetworkInterfaces"
            case subnetId = "SubnetId"
            case type = "Type"
            case virtualizationType = "VirtualizationType"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2InstanceMetadataOptions: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the HTTP metadata endpoint on the instance.
        public let httpEndpoint: String?
        /// Enables or disables the IPv6 endpoint for the instance metadata service.
        public let httpProtocolIpv6: String?
        /// The desired HTTP PUT response hop limit for instance metadata requests.  The larger the number, the further instance metadata requests can travel.
        public let httpPutResponseHopLimit: Int?
        /// The state of token usage for your instance metadata requests.
        public let httpTokens: String?
        /// Specifies whether to allow access to instance tags from the instance metadata.
        public let instanceMetadataTags: String?

        @inlinable
        public init(httpEndpoint: String? = nil, httpProtocolIpv6: String? = nil, httpPutResponseHopLimit: Int? = nil, httpTokens: String? = nil, instanceMetadataTags: String? = nil) {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }

        public func validate(name: String) throws {
            try self.validate(self.httpEndpoint, name: "httpEndpoint", parent: name, pattern: "\\S")
            try self.validate(self.httpProtocolIpv6, name: "httpProtocolIpv6", parent: name, pattern: "\\S")
            try self.validate(self.httpTokens, name: "httpTokens", parent: name, pattern: "\\S")
            try self.validate(self.instanceMetadataTags, name: "instanceMetadataTags", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case httpEndpoint = "HttpEndpoint"
            case httpProtocolIpv6 = "HttpProtocolIpv6"
            case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
            case httpTokens = "HttpTokens"
            case instanceMetadataTags = "InstanceMetadataTags"
        }
    }

    public struct AwsEc2InstanceMonitoringDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether detailed monitoring is turned on. Otherwise, basic monitoring is turned on.
        public let state: String?

        @inlinable
        public init(state: String? = nil) {
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct AwsEc2InstanceNetworkInterfacesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the network interface. The details are in a corresponding AwsEc2NetworkInterfacesDetails object.
        public let networkInterfaceId: String?

        @inlinable
        public init(networkInterfaceId: String? = nil) {
            self.networkInterfaceId = networkInterfaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case networkInterfaceId = "NetworkInterfaceId"
        }
    }

    public struct AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The device name.
        public let deviceName: String?
        ///  Parameters used to automatically set up Amazon EBS volumes when the instance is  launched.
        public let ebs: AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails?
        ///  Omits the device from the block device mapping when an empty string is specified.
        public let noDevice: String?
        ///  The virtual device name (ephemeralN). Instance store volumes are numbered starting  from 0. An instance type with 2 available instance store volumes can specify mappings  for ephemeral0 and ephemeral1. The number of available instance store volumes depends  on the instance type.
        public let virtualName: String?

        @inlinable
        public init(deviceName: String? = nil, ebs: AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails? = nil, noDevice: String? = nil, virtualName: String? = nil) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "\\S")
            try self.ebs?.validate(name: "\(name).ebs")
            try self.validate(self.noDevice, name: "noDevice", parent: name, pattern: "\\S")
            try self.validate(self.virtualName, name: "virtualName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "DeviceName"
            case ebs = "Ebs"
            case noDevice = "NoDevice"
            case virtualName = "VirtualName"
        }
    }

    public struct AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether the EBS volume is deleted on instance termination.
        public let deleteOnTermination: Bool?
        ///  Indicates whether the EBS volume is encrypted. Encrypted volumes can only be  attached to instances that support Amazon EBS encryption. If you're creating a  volume from a snapshot, you can't specify an encryption value.
        public let encrypted: Bool?
        ///  The number of I/O operations per second (IOPS).
        public let iops: Int?
        ///  The Amazon Resource Name (ARN) of the symmetric Key Management Service (KMS) customer managed key  used for encryption.
        public let kmsKeyId: String?
        ///  The ID of the EBS snapshot.
        public let snapshotId: String?
        ///  The throughput to provision for a gp3 volume, with a maximum of 1,000 MiB/s.
        public let throughput: Int?
        ///  The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.
        public let volumeSize: Int?
        ///  The volume type.
        public let volumeType: String?

        @inlinable
        public init(deleteOnTermination: Bool? = nil, encrypted: Bool? = nil, iops: Int? = nil, kmsKeyId: String? = nil, snapshotId: String? = nil, throughput: Int? = nil, volumeSize: Int? = nil, volumeType: String? = nil) {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "\\S")
            try self.validate(self.volumeType, name: "volumeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteOnTermination = "DeleteOnTermination"
            case encrypted = "Encrypted"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case snapshotId = "SnapshotId"
            case throughput = "Throughput"
            case volumeSize = "VolumeSize"
            case volumeType = "VolumeType"
        }
    }

    public struct AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The ID of the Capacity Reservation in which to run the instance.
        public let capacityReservationId: String?
        ///  The Amazon Resource Name (ARN) of the Capacity Reservation resource group in which to run the instance.
        public let capacityReservationResourceGroupArn: String?

        @inlinable
        public init(capacityReservationId: String? = nil, capacityReservationResourceGroupArn: String? = nil) {
            self.capacityReservationId = capacityReservationId
            self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityReservationId, name: "capacityReservationId", parent: name, pattern: "\\S")
            try self.validate(self.capacityReservationResourceGroupArn, name: "capacityReservationResourceGroupArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityReservationId = "CapacityReservationId"
            case capacityReservationResourceGroupArn = "CapacityReservationResourceGroupArn"
        }
    }

    public struct AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates the instance's Capacity Reservation preferences. If equal to open, the instance can run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). If equal to none, the instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        public let capacityReservationPreference: String?
        ///  Specifies a target Capacity Reservation.
        public let capacityReservationTarget: AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails?

        @inlinable
        public init(capacityReservationPreference: String? = nil, capacityReservationTarget: AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails? = nil) {
            self.capacityReservationPreference = capacityReservationPreference
            self.capacityReservationTarget = capacityReservationTarget
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityReservationPreference, name: "capacityReservationPreference", parent: name, pattern: "\\S")
            try self.capacityReservationTarget?.validate(name: "\(name).capacityReservationTarget")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityReservationPreference = "CapacityReservationPreference"
            case capacityReservationTarget = "CapacityReservationTarget"
        }
    }

    public struct AwsEc2LaunchTemplateDataCpuOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The number of CPU cores for the instance.
        public let coreCount: Int?
        ///  The number of threads per CPU core. A value of 1 disables multithreading for the instance,  The default value is 2.
        public let threadsPerCore: Int?

        @inlinable
        public init(coreCount: Int? = nil, threadsPerCore: Int? = nil) {
            self.coreCount = coreCount
            self.threadsPerCore = threadsPerCore
        }

        private enum CodingKeys: String, CodingKey {
            case coreCount = "CoreCount"
            case threadsPerCore = "ThreadsPerCore"
        }
    }

    public struct AwsEc2LaunchTemplateDataCreditSpecificationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The credit option for CPU usage of a T instance.
        public let cpuCredits: String?

        @inlinable
        public init(cpuCredits: String? = nil) {
            self.cpuCredits = cpuCredits
        }

        public func validate(name: String) throws {
            try self.validate(self.cpuCredits, name: "cpuCredits", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cpuCredits = "CpuCredits"
        }
    }

    public struct AwsEc2LaunchTemplateDataDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Information about a block device mapping for an Amazon EC2 launch template.
        public let blockDeviceMappingSet: [AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails]?
        ///  Specifies an instance's Capacity Reservation targeting option. You can specify only  one option at a time.
        public let capacityReservationSpecification: AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails?
        ///  Specifies the CPU options for an instance. For more information, see  Optimize CPU options in the Amazon Elastic Compute Cloud User Guide.
        public let cpuOptions: AwsEc2LaunchTemplateDataCpuOptionsDetails?
        ///  Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
        public let creditSpecification: AwsEc2LaunchTemplateDataCreditSpecificationDetails?
        ///  Indicates whether to enable the instance for stop protection. For more information,  see Enable stop protection in the Amazon EC2 User Guide.
        public let disableApiStop: Bool?
        ///  If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API. If set to true, you can.
        public let disableApiTermination: Bool?
        ///  Indicates whether the instance is optimized for Amazon EBS I/O.
        public let ebsOptimized: Bool?
        ///  Provides details about Elastic Graphics accelerators to associate with the instance.
        public let elasticGpuSpecificationSet: [AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails]?
        ///  The Amazon Elastic Inference accelerator for the instance.
        public let elasticInferenceAcceleratorSet: [AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails]?
        ///  Indicates whether the Amazon EC2 instance is enabled for Amazon Web Services Nitro Enclaves.
        public let enclaveOptions: AwsEc2LaunchTemplateDataEnclaveOptionsDetails?
        ///  Specifies whether your Amazon EC2 instance is configured for hibernation.
        public let hibernationOptions: AwsEc2LaunchTemplateDataHibernationOptionsDetails?
        ///  The name or Amazon Resource Name (ARN) of an IAM instance profile.
        public let iamInstanceProfile: AwsEc2LaunchTemplateDataIamInstanceProfileDetails?
        ///  The ID of the Amazon Machine Image (AMI).
        public let imageId: String?
        ///  Provides the options for specifying the instance initiated shutdown behavior.
        public let instanceInitiatedShutdownBehavior: String?
        ///  Specifies the market (purchasing) option for an instance.
        public let instanceMarketOptions: AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails?
        ///  The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance  types with these attributes. If you specify InstanceRequirements, you can't specify InstanceType.
        public let instanceRequirements: AwsEc2LaunchTemplateDataInstanceRequirementsDetails?
        ///  The instance type. For more information, see Instance types in the Amazon EC2 User Guide. If you specify InstanceType, you can't  specify InstanceRequirements.
        public let instanceType: String?
        ///  The ID of the kernel.
        public let kernelId: String?
        ///  The name of the key pair that allows users to connect to the instance.
        public let keyName: String?
        ///  Specifies a license configuration for an instance.
        public let licenseSet: [AwsEc2LaunchTemplateDataLicenseSetDetails]?
        ///  The maintenance options of your instance.
        public let maintenanceOptions: AwsEc2LaunchTemplateDataMaintenanceOptionsDetails?
        ///  The metadata options for the instance. For more information, see Instance metadata and user data in the Amazon EC2 User Guide.
        public let metadataOptions: AwsEc2LaunchTemplateDataMetadataOptionsDetails?
        ///  The monitoring for the instance.
        public let monitoring: AwsEc2LaunchTemplateDataMonitoringDetails?
        ///  Specifies the parameters for a network interface that is attached to the instance.
        public let networkInterfaceSet: [AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails]?
        ///  Specifies the placement of an instance.
        public let placement: AwsEc2LaunchTemplateDataPlacementDetails?
        ///  The options for the instance hostname.
        public let privateDnsNameOptions: AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails?
        ///  The ID of the RAM disk.
        public let ramDiskId: String?
        ///  One or more security group IDs.
        public let securityGroupIdSet: [String]?
        ///  One or more security group names. For a nondefault VPC, you must use security group IDs instead. You cannot specify both a security group ID and security name in the same request.
        public let securityGroupSet: [String]?
        ///  The user data to make available to the instance.
        public let userData: String?

        @inlinable
        public init(blockDeviceMappingSet: [AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails]? = nil, capacityReservationSpecification: AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails? = nil, cpuOptions: AwsEc2LaunchTemplateDataCpuOptionsDetails? = nil, creditSpecification: AwsEc2LaunchTemplateDataCreditSpecificationDetails? = nil, disableApiStop: Bool? = nil, disableApiTermination: Bool? = nil, ebsOptimized: Bool? = nil, elasticGpuSpecificationSet: [AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails]? = nil, elasticInferenceAcceleratorSet: [AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails]? = nil, enclaveOptions: AwsEc2LaunchTemplateDataEnclaveOptionsDetails? = nil, hibernationOptions: AwsEc2LaunchTemplateDataHibernationOptionsDetails? = nil, iamInstanceProfile: AwsEc2LaunchTemplateDataIamInstanceProfileDetails? = nil, imageId: String? = nil, instanceInitiatedShutdownBehavior: String? = nil, instanceMarketOptions: AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails? = nil, instanceRequirements: AwsEc2LaunchTemplateDataInstanceRequirementsDetails? = nil, instanceType: String? = nil, kernelId: String? = nil, keyName: String? = nil, licenseSet: [AwsEc2LaunchTemplateDataLicenseSetDetails]? = nil, maintenanceOptions: AwsEc2LaunchTemplateDataMaintenanceOptionsDetails? = nil, metadataOptions: AwsEc2LaunchTemplateDataMetadataOptionsDetails? = nil, monitoring: AwsEc2LaunchTemplateDataMonitoringDetails? = nil, networkInterfaceSet: [AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails]? = nil, placement: AwsEc2LaunchTemplateDataPlacementDetails? = nil, privateDnsNameOptions: AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails? = nil, ramDiskId: String? = nil, securityGroupIdSet: [String]? = nil, securityGroupSet: [String]? = nil, userData: String? = nil) {
            self.blockDeviceMappingSet = blockDeviceMappingSet
            self.capacityReservationSpecification = capacityReservationSpecification
            self.cpuOptions = cpuOptions
            self.creditSpecification = creditSpecification
            self.disableApiStop = disableApiStop
            self.disableApiTermination = disableApiTermination
            self.ebsOptimized = ebsOptimized
            self.elasticGpuSpecificationSet = elasticGpuSpecificationSet
            self.elasticInferenceAcceleratorSet = elasticInferenceAcceleratorSet
            self.enclaveOptions = enclaveOptions
            self.hibernationOptions = hibernationOptions
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.instanceMarketOptions = instanceMarketOptions
            self.instanceRequirements = instanceRequirements
            self.instanceType = instanceType
            self.kernelId = kernelId
            self.keyName = keyName
            self.licenseSet = licenseSet
            self.maintenanceOptions = maintenanceOptions
            self.metadataOptions = metadataOptions
            self.monitoring = monitoring
            self.networkInterfaceSet = networkInterfaceSet
            self.placement = placement
            self.privateDnsNameOptions = privateDnsNameOptions
            self.ramDiskId = ramDiskId
            self.securityGroupIdSet = securityGroupIdSet
            self.securityGroupSet = securityGroupSet
            self.userData = userData
        }

        public func validate(name: String) throws {
            try self.blockDeviceMappingSet?.forEach {
                try $0.validate(name: "\(name).blockDeviceMappingSet[]")
            }
            try self.capacityReservationSpecification?.validate(name: "\(name).capacityReservationSpecification")
            try self.creditSpecification?.validate(name: "\(name).creditSpecification")
            try self.elasticGpuSpecificationSet?.forEach {
                try $0.validate(name: "\(name).elasticGpuSpecificationSet[]")
            }
            try self.elasticInferenceAcceleratorSet?.forEach {
                try $0.validate(name: "\(name).elasticInferenceAcceleratorSet[]")
            }
            try self.iamInstanceProfile?.validate(name: "\(name).iamInstanceProfile")
            try self.validate(self.imageId, name: "imageId", parent: name, pattern: "\\S")
            try self.validate(self.instanceInitiatedShutdownBehavior, name: "instanceInitiatedShutdownBehavior", parent: name, pattern: "\\S")
            try self.instanceMarketOptions?.validate(name: "\(name).instanceMarketOptions")
            try self.instanceRequirements?.validate(name: "\(name).instanceRequirements")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
            try self.validate(self.kernelId, name: "kernelId", parent: name, pattern: "\\S")
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "\\S")
            try self.licenseSet?.forEach {
                try $0.validate(name: "\(name).licenseSet[]")
            }
            try self.maintenanceOptions?.validate(name: "\(name).maintenanceOptions")
            try self.metadataOptions?.validate(name: "\(name).metadataOptions")
            try self.networkInterfaceSet?.forEach {
                try $0.validate(name: "\(name).networkInterfaceSet[]")
            }
            try self.placement?.validate(name: "\(name).placement")
            try self.privateDnsNameOptions?.validate(name: "\(name).privateDnsNameOptions")
            try self.validate(self.ramDiskId, name: "ramDiskId", parent: name, pattern: "\\S")
            try self.securityGroupIdSet?.forEach {
                try validate($0, name: "securityGroupIdSet[]", parent: name, pattern: "\\S")
            }
            try self.securityGroupSet?.forEach {
                try validate($0, name: "securityGroupSet[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.userData, name: "userData", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case blockDeviceMappingSet = "BlockDeviceMappingSet"
            case capacityReservationSpecification = "CapacityReservationSpecification"
            case cpuOptions = "CpuOptions"
            case creditSpecification = "CreditSpecification"
            case disableApiStop = "DisableApiStop"
            case disableApiTermination = "DisableApiTermination"
            case ebsOptimized = "EbsOptimized"
            case elasticGpuSpecificationSet = "ElasticGpuSpecificationSet"
            case elasticInferenceAcceleratorSet = "ElasticInferenceAcceleratorSet"
            case enclaveOptions = "EnclaveOptions"
            case hibernationOptions = "HibernationOptions"
            case iamInstanceProfile = "IamInstanceProfile"
            case imageId = "ImageId"
            case instanceInitiatedShutdownBehavior = "InstanceInitiatedShutdownBehavior"
            case instanceMarketOptions = "InstanceMarketOptions"
            case instanceRequirements = "InstanceRequirements"
            case instanceType = "InstanceType"
            case kernelId = "KernelId"
            case keyName = "KeyName"
            case licenseSet = "LicenseSet"
            case maintenanceOptions = "MaintenanceOptions"
            case metadataOptions = "MetadataOptions"
            case monitoring = "Monitoring"
            case networkInterfaceSet = "NetworkInterfaceSet"
            case placement = "Placement"
            case privateDnsNameOptions = "PrivateDnsNameOptions"
            case ramDiskId = "RamDiskId"
            case securityGroupIdSet = "SecurityGroupIdSet"
            case securityGroupSet = "SecurityGroupSet"
            case userData = "UserData"
        }
    }

    public struct AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The type of Elastic Graphics accelerator.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The number of Elastic Inference accelerators to attach to the instance.
        public let count: Int?
        ///  The type of Elastic Inference accelerator.
        public let type: String?

        @inlinable
        public init(count: Int? = nil, type: String? = nil) {
            self.count = count
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case type = "Type"
        }
    }

    public struct AwsEc2LaunchTemplateDataEnclaveOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  If this parameter is set to true, the instance is enabled for Amazon Web Services Nitro Enclaves.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsEc2LaunchTemplateDataHibernationOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  If you set this parameter to true, the instance is enabled for hibernation.
        public let configured: Bool?

        @inlinable
        public init(configured: Bool? = nil) {
            self.configured = configured
        }

        private enum CodingKeys: String, CodingKey {
            case configured = "Configured"
        }
    }

    public struct AwsEc2LaunchTemplateDataIamInstanceProfileDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the instance profile.
        public let arn: String?
        ///  The name of the instance profile.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The market type.
        public let marketType: String?
        ///  The options for Spot Instances.
        public let spotOptions: AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails?

        @inlinable
        public init(marketType: String? = nil, spotOptions: AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails? = nil) {
            self.marketType = marketType
            self.spotOptions = spotOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.marketType, name: "marketType", parent: name, pattern: "\\S")
            try self.spotOptions?.validate(name: "\(name).spotOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case marketType = "MarketType"
            case spotOptions = "SpotOptions"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Deprecated.
        public let blockDurationMinutes: Int?
        ///  The behavior when a Spot Instance is interrupted.
        public let instanceInterruptionBehavior: String?
        ///  The maximum hourly price you're willing to pay for the Spot Instances.
        public let maxPrice: String?
        ///  The Spot Instance request type.
        public let spotInstanceType: String?
        ///  The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ), for persistent requests.
        public let validUntil: String?

        @inlinable
        public init(blockDurationMinutes: Int? = nil, instanceInterruptionBehavior: String? = nil, maxPrice: String? = nil, spotInstanceType: String? = nil, validUntil: String? = nil) {
            self.blockDurationMinutes = blockDurationMinutes
            self.instanceInterruptionBehavior = instanceInterruptionBehavior
            self.maxPrice = maxPrice
            self.spotInstanceType = spotInstanceType
            self.validUntil = validUntil
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceInterruptionBehavior, name: "instanceInterruptionBehavior", parent: name, pattern: "\\S")
            try self.validate(self.maxPrice, name: "maxPrice", parent: name, pattern: "\\S")
            try self.validate(self.spotInstanceType, name: "spotInstanceType", parent: name, pattern: "\\S")
            try self.validate(self.validUntil, name: "validUntil", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case blockDurationMinutes = "BlockDurationMinutes"
            case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
            case maxPrice = "MaxPrice"
            case spotInstanceType = "SpotInstanceType"
            case validUntil = "ValidUntil"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum number of accelerators. If this parameter isn't specified, there's no maximum limit. To exclude accelerator-enabled instance types, set Max to 0.
        public let max: Int?
        ///  The minimum number of accelerators. If this parameter isn't specified, there's no minimum limit.
        public let min: Int?

        @inlinable
        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum amount of memory, in MiB. If this parameter isn't specified, there's no maximum limit.
        public let max: Int?
        ///  The minimum amount of memory, in MiB. If 0 is specified, there's no maximum limit.
        public let min: Int?

        @inlinable
        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum baseline bandwidth, in Mbps. If this parameter is omitted, there's no maximum limit.
        public let max: Int?
        ///  The minimum baseline bandwidth, in Mbps. If this parameter is omitted, there's no minimum limit.
        public let min: Int?

        @inlinable
        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web Services Inferentia chips) on an instance.
        public let acceleratorCount: AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails?
        /// Indicates whether instance types must have accelerators by specific manufacturers.
        public let acceleratorManufacturers: [String]?
        ///  The accelerators that must be on the instance type.
        public let acceleratorNames: [String]?
        ///  The minimum and maximum amount of total accelerator memory, in MiB.
        public let acceleratorTotalMemoryMiB: AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails?
        /// The accelerator types that must be on the instance type.
        public let acceleratorTypes: [String]?
        /// Indicates whether bare metal instance types must be included, excluded, or required.
        public let bareMetal: String?
        ///  The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see Amazon EBS optimized instances in the Amazon EC2 User Guide.
        public let baselineEbsBandwidthMbps: AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails?
        ///  Indicates whether burstable performance T instance types are included, excluded, or required. For more information, Burstable performance instances in the Amazon EC2 User Guide.
        public let burstablePerformance: String?
        ///  The CPU manufacturers to include.
        public let cpuManufacturers: [String]?
        ///  The instance types to exclude.
        public let excludedInstanceTypes: [String]?
        ///  Indicates whether current or previous generation instance types are included.
        public let instanceGenerations: [String]?
        ///  Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, see Amazon EC2 instance store in the Amazon EC2 User Guide.
        public let localStorage: String?
        ///  The type of local storage that is required.
        public let localStorageTypes: [String]?
        ///  The minimum and maximum amount of memory per vCPU, in GiB.
        public let memoryGiBPerVCpu: AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails?
        ///  The minimum and maximum amount of memory, in MiB.
        public let memoryMiB: AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails?
        ///  The minimum and maximum number of network interfaces.
        public let networkInterfaceCount: AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails?
        ///  The price protection threshold for On-Demand Instances. This is the maximum you'll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. A high value, such as 999999, turns off price protection.
        public let onDemandMaxPricePercentageOverLowestPrice: Int?
        ///  Indicates whether instance types must support hibernation for On-Demand Instances.
        public let requireHibernateSupport: Bool?
        ///  The price protection threshold for Spot Instances. This is the maximum you'll pay for a Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.  The parameter accepts an integer, which Amazon EC2 interprets as a percentage. A high value, such as 999999, turns off price protection.
        public let spotMaxPricePercentageOverLowestPrice: Int?
        ///  The minimum and maximum amount of total local storage, in GB.
        public let totalLocalStorageGB: AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails?
        ///  The minimum and maximum number of vCPUs.
        public let vCpuCount: AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails?

        @inlinable
        public init(acceleratorCount: AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails? = nil, acceleratorManufacturers: [String]? = nil, acceleratorNames: [String]? = nil, acceleratorTotalMemoryMiB: AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails? = nil, acceleratorTypes: [String]? = nil, bareMetal: String? = nil, baselineEbsBandwidthMbps: AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails? = nil, burstablePerformance: String? = nil, cpuManufacturers: [String]? = nil, excludedInstanceTypes: [String]? = nil, instanceGenerations: [String]? = nil, localStorage: String? = nil, localStorageTypes: [String]? = nil, memoryGiBPerVCpu: AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails? = nil, memoryMiB: AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails? = nil, networkInterfaceCount: AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails? = nil, onDemandMaxPricePercentageOverLowestPrice: Int? = nil, requireHibernateSupport: Bool? = nil, spotMaxPricePercentageOverLowestPrice: Int? = nil, totalLocalStorageGB: AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails? = nil, vCpuCount: AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails? = nil) {
            self.acceleratorCount = acceleratorCount
            self.acceleratorManufacturers = acceleratorManufacturers
            self.acceleratorNames = acceleratorNames
            self.acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB
            self.acceleratorTypes = acceleratorTypes
            self.bareMetal = bareMetal
            self.baselineEbsBandwidthMbps = baselineEbsBandwidthMbps
            self.burstablePerformance = burstablePerformance
            self.cpuManufacturers = cpuManufacturers
            self.excludedInstanceTypes = excludedInstanceTypes
            self.instanceGenerations = instanceGenerations
            self.localStorage = localStorage
            self.localStorageTypes = localStorageTypes
            self.memoryGiBPerVCpu = memoryGiBPerVCpu
            self.memoryMiB = memoryMiB
            self.networkInterfaceCount = networkInterfaceCount
            self.onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPrice
            self.requireHibernateSupport = requireHibernateSupport
            self.spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPrice
            self.totalLocalStorageGB = totalLocalStorageGB
            self.vCpuCount = vCpuCount
        }

        public func validate(name: String) throws {
            try self.acceleratorManufacturers?.forEach {
                try validate($0, name: "acceleratorManufacturers[]", parent: name, pattern: "\\S")
            }
            try self.acceleratorNames?.forEach {
                try validate($0, name: "acceleratorNames[]", parent: name, pattern: "\\S")
            }
            try self.acceleratorTypes?.forEach {
                try validate($0, name: "acceleratorTypes[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.bareMetal, name: "bareMetal", parent: name, pattern: "\\S")
            try self.validate(self.burstablePerformance, name: "burstablePerformance", parent: name, pattern: "\\S")
            try self.cpuManufacturers?.forEach {
                try validate($0, name: "cpuManufacturers[]", parent: name, pattern: "\\S")
            }
            try self.excludedInstanceTypes?.forEach {
                try validate($0, name: "excludedInstanceTypes[]", parent: name, pattern: "\\S")
            }
            try self.instanceGenerations?.forEach {
                try validate($0, name: "instanceGenerations[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.localStorage, name: "localStorage", parent: name, pattern: "\\S")
            try self.localStorageTypes?.forEach {
                try validate($0, name: "localStorageTypes[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorCount = "AcceleratorCount"
            case acceleratorManufacturers = "AcceleratorManufacturers"
            case acceleratorNames = "AcceleratorNames"
            case acceleratorTotalMemoryMiB = "AcceleratorTotalMemoryMiB"
            case acceleratorTypes = "AcceleratorTypes"
            case bareMetal = "BareMetal"
            case baselineEbsBandwidthMbps = "BaselineEbsBandwidthMbps"
            case burstablePerformance = "BurstablePerformance"
            case cpuManufacturers = "CpuManufacturers"
            case excludedInstanceTypes = "ExcludedInstanceTypes"
            case instanceGenerations = "InstanceGenerations"
            case localStorage = "LocalStorage"
            case localStorageTypes = "LocalStorageTypes"
            case memoryGiBPerVCpu = "MemoryGiBPerVCpu"
            case memoryMiB = "MemoryMiB"
            case networkInterfaceCount = "NetworkInterfaceCount"
            case onDemandMaxPricePercentageOverLowestPrice = "OnDemandMaxPricePercentageOverLowestPrice"
            case requireHibernateSupport = "RequireHibernateSupport"
            case spotMaxPricePercentageOverLowestPrice = "SpotMaxPricePercentageOverLowestPrice"
            case totalLocalStorageGB = "TotalLocalStorageGB"
            case vCpuCount = "VCpuCount"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum amount of memory per vCPU, in GiB. If this parameter is omitted, there's no maximum limit.
        public let max: Double?
        ///  The minimum amount of memory per vCPU, in GiB. If this parameter is omitted, there's no maximum limit.
        public let min: Double?

        @inlinable
        public init(max: Double? = nil, min: Double? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum amount of memory, in MiB.
        public let max: Int?
        ///  The minimum amount of memory, in MiB.
        public let min: Int?

        @inlinable
        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum number of network interfaces.
        public let max: Int?
        ///  The minimum number of network interfaces.
        public let min: Int?

        @inlinable
        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum amount of total local storage, in GB.
        public let max: Double?
        ///  The minimum amount of total local storage, in GB.
        public let min: Double?

        @inlinable
        public init(max: Double? = nil, min: Double? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The maximum number of vCPUs.
        public let max: Int?
        ///  The minimum number of vCPUs.
        public let min: Int?

        @inlinable
        public init(max: Int? = nil, min: Int? = nil) {
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case max = "Max"
            case min = "Min"
        }
    }

    public struct AwsEc2LaunchTemplateDataLicenseSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the license configuration.
        public let licenseConfigurationArn: String?

        @inlinable
        public init(licenseConfigurationArn: String? = nil) {
            self.licenseConfigurationArn = licenseConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.licenseConfigurationArn, name: "licenseConfigurationArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case licenseConfigurationArn = "LicenseConfigurationArn"
        }
    }

    public struct AwsEc2LaunchTemplateDataMaintenanceOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Disables the automatic recovery behavior of your instance or sets it to default.
        public let autoRecovery: String?

        @inlinable
        public init(autoRecovery: String? = nil) {
            self.autoRecovery = autoRecovery
        }

        public func validate(name: String) throws {
            try self.validate(self.autoRecovery, name: "autoRecovery", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case autoRecovery = "AutoRecovery"
        }
    }

    public struct AwsEc2LaunchTemplateDataMetadataOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is enabled, and you won't be able to access your instance metadata.
        public let httpEndpoint: String?
        ///  Enables or disables the IPv6 endpoint for the instance metadata service.
        public let httpProtocolIpv6: String?
        ///  The desired HTTP PUT response hop limit for instance metadata requests. The larger  the number, the further instance metadata requests can travel.
        public let httpPutResponseHopLimit: Int?
        ///  The state of token usage for your instance metadata requests.
        public let httpTokens: String?
        ///  When set to enabled, this parameter allows access to instance tags from the instance metadata. When set to disabled, it turns off access to instance tags from the instance metadata. For more information, see
        /// Work with instance tags in instance metadata in the Amazon EC2 User Guide.
        public let instanceMetadataTags: String?

        @inlinable
        public init(httpEndpoint: String? = nil, httpProtocolIpv6: String? = nil, httpPutResponseHopLimit: Int? = nil, httpTokens: String? = nil, instanceMetadataTags: String? = nil) {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }

        public func validate(name: String) throws {
            try self.validate(self.httpEndpoint, name: "httpEndpoint", parent: name, pattern: "\\S")
            try self.validate(self.httpProtocolIpv6, name: "httpProtocolIpv6", parent: name, pattern: "\\S")
            try self.validate(self.httpTokens, name: "httpTokens", parent: name, pattern: "\\S")
            try self.validate(self.instanceMetadataTags, name: "instanceMetadataTags", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case httpEndpoint = "HttpEndpoint"
            case httpProtocolIpv6 = "HttpProtocolIpv6"
            case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
            case httpTokens = "HttpTokens"
            case instanceMetadataTags = "InstanceMetadataTags"
        }
    }

    public struct AwsEc2LaunchTemplateDataMonitoringDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Enables detailed monitoring when true is specified. Otherwise, basic monitoring is enabled.  For more information about detailed monitoring, see  Enable or turn off detailed monitoring for your instances in the Amazon EC2 User Guide.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether to associate a Carrier IP address with eth0 for a new network interface.  You use this option when you launch an instance in a Wavelength Zone and want to  associate a Carrier IP address with the network interface. For more information, see  Carrier IP address in the Wavelength Developer Guide.
        public let associateCarrierIpAddress: Bool?
        ///  Associates a public IPv4 address with eth0 for a new network interface.
        public let associatePublicIpAddress: Bool?
        ///  Indicates whether the network interface is deleted when the instance is terminated.
        public let deleteOnTermination: Bool?
        ///  A description for the network interface.
        public let description: String?
        ///  The device index for the network interface attachment.
        public let deviceIndex: Int?
        ///  The IDs of one or more security groups.
        public let groups: [String]?
        ///  The type of network interface.
        public let interfaceType: String?
        ///  The number of IPv4 prefixes to be automatically assigned to the network interface.  You cannot use this option if you use the Ipv4Prefixes option.
        public let ipv4PrefixCount: Int?
        ///  One or more IPv4 prefixes to be assigned to the network interface. You cannot use  this option if you use the Ipv4PrefixCount option.
        public let ipv4Prefixes: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails]?
        ///  The number of IPv6 addresses to assign to a network interface. Amazon EC2  automatically selects the IPv6 addresses from the subnet range. You can't use this  option if you use Ipv6Addresses.
        public let ipv6AddressCount: Int?
        ///  One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.  You can't use this option if you use Ipv6AddressCount.
        public let ipv6Addresses: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails]?
        ///  The number of IPv6 prefixes to be automatically assigned to the network interface.  You cannot use this option if you use the Ipv6Prefix option.
        public let ipv6PrefixCount: Int?
        ///  One or more IPv6 prefixes to be assigned to the network interface. You cannot use  this option if you use the Ipv6PrefixCount option.
        public let ipv6Prefixes: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails]?
        ///  The index of the network card. Some instance types support multiple network cards.  The primary network interface must be assigned to network card index 0. The default  is network card index 0.
        public let networkCardIndex: Int?
        ///  The ID of the network interface.
        public let networkInterfaceId: String?
        ///  The primary private IPv4 address of the network interface.
        public let privateIpAddress: String?
        ///  One or more private IPv4 addresses.
        public let privateIpAddresses: [AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails]?
        ///  The number of secondary private IPv4 addresses to assign to a network interface.
        public let secondaryPrivateIpAddressCount: Int?
        ///  The ID of the subnet for the network interface.
        public let subnetId: String?

        @inlinable
        public init(associateCarrierIpAddress: Bool? = nil, associatePublicIpAddress: Bool? = nil, deleteOnTermination: Bool? = nil, description: String? = nil, deviceIndex: Int? = nil, groups: [String]? = nil, interfaceType: String? = nil, ipv4PrefixCount: Int? = nil, ipv4Prefixes: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails]? = nil, ipv6AddressCount: Int? = nil, ipv6Addresses: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails]? = nil, ipv6PrefixCount: Int? = nil, ipv6Prefixes: [AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails]? = nil, networkCardIndex: Int? = nil, networkInterfaceId: String? = nil, privateIpAddress: String? = nil, privateIpAddresses: [AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails]? = nil, secondaryPrivateIpAddressCount: Int? = nil, subnetId: String? = nil) {
            self.associateCarrierIpAddress = associateCarrierIpAddress
            self.associatePublicIpAddress = associatePublicIpAddress
            self.deleteOnTermination = deleteOnTermination
            self.description = description
            self.deviceIndex = deviceIndex
            self.groups = groups
            self.interfaceType = interfaceType
            self.ipv4PrefixCount = ipv4PrefixCount
            self.ipv4Prefixes = ipv4Prefixes
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.ipv6PrefixCount = ipv6PrefixCount
            self.ipv6Prefixes = ipv6Prefixes
            self.networkCardIndex = networkCardIndex
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.groups?.forEach {
                try validate($0, name: "groups[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.interfaceType, name: "interfaceType", parent: name, pattern: "\\S")
            try self.ipv4Prefixes?.forEach {
                try $0.validate(name: "\(name).ipv4Prefixes[]")
            }
            try self.ipv6Addresses?.forEach {
                try $0.validate(name: "\(name).ipv6Addresses[]")
            }
            try self.ipv6Prefixes?.forEach {
                try $0.validate(name: "\(name).ipv6Prefixes[]")
            }
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "\\S")
            try self.privateIpAddresses?.forEach {
                try $0.validate(name: "\(name).privateIpAddresses[]")
            }
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associateCarrierIpAddress = "AssociateCarrierIpAddress"
            case associatePublicIpAddress = "AssociatePublicIpAddress"
            case deleteOnTermination = "DeleteOnTermination"
            case description = "Description"
            case deviceIndex = "DeviceIndex"
            case groups = "Groups"
            case interfaceType = "InterfaceType"
            case ipv4PrefixCount = "Ipv4PrefixCount"
            case ipv4Prefixes = "Ipv4Prefixes"
            case ipv6AddressCount = "Ipv6AddressCount"
            case ipv6Addresses = "Ipv6Addresses"
            case ipv6PrefixCount = "Ipv6PrefixCount"
            case ipv6Prefixes = "Ipv6Prefixes"
            case networkCardIndex = "NetworkCardIndex"
            case networkInterfaceId = "NetworkInterfaceId"
            case privateIpAddress = "PrivateIpAddress"
            case privateIpAddresses = "PrivateIpAddresses"
            case secondaryPrivateIpAddressCount = "SecondaryPrivateIpAddressCount"
            case subnetId = "SubnetId"
        }
    }

    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The IPv4 prefix. For more information, see Assigning prefixes to Amazon EC2 network interfaces in the Amazon Elastic Compute Cloud User Guide.
        public let ipv4Prefix: String?

        @inlinable
        public init(ipv4Prefix: String? = nil) {
            self.ipv4Prefix = ipv4Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv4Prefix, name: "ipv4Prefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipv4Prefix = "Ipv4Prefix"
        }
    }

    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
        public let ipv6Address: String?

        @inlinable
        public init(ipv6Address: String? = nil) {
            self.ipv6Address = ipv6Address
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv6Address, name: "ipv6Address", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6Address = "Ipv6Address"
        }
    }

    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The IPv6 prefix.
        public let ipv6Prefix: String?

        @inlinable
        public init(ipv6Prefix: String? = nil) {
            self.ipv6Prefix = ipv6Prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv6Prefix, name: "ipv6Prefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6Prefix = "Ipv6Prefix"
        }
    }

    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        public let primary: Bool?
        ///  The private IPv4 address.
        public let privateIpAddress: String?

        @inlinable
        public init(primary: Bool? = nil, privateIpAddress: String? = nil) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case primary = "Primary"
            case privateIpAddress = "PrivateIpAddress"
        }
    }

    public struct AwsEc2LaunchTemplateDataPlacementDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The affinity setting for an instance on an EC2 Dedicated Host.
        public let affinity: String?
        ///  The Availability Zone for the instance.
        public let availabilityZone: String?
        ///  The name of the placement group for the instance.
        public let groupName: String?
        ///  The ID of the Dedicated Host for the instance.
        public let hostId: String?
        ///  The Amazon Resource Name (ARN) of the host resource group in which to launch the instances.
        public let hostResourceGroupArn: String?
        ///  The number of the partition the instance should launch in.
        public let partitionNumber: Int?
        ///  Reserved for future use.
        public let spreadDomain: String?
        ///  The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.
        public let tenancy: String?

        @inlinable
        public init(affinity: String? = nil, availabilityZone: String? = nil, groupName: String? = nil, hostId: String? = nil, hostResourceGroupArn: String? = nil, partitionNumber: Int? = nil, spreadDomain: String? = nil, tenancy: String? = nil) {
            self.affinity = affinity
            self.availabilityZone = availabilityZone
            self.groupName = groupName
            self.hostId = hostId
            self.hostResourceGroupArn = hostResourceGroupArn
            self.partitionNumber = partitionNumber
            self.spreadDomain = spreadDomain
            self.tenancy = tenancy
        }

        public func validate(name: String) throws {
            try self.validate(self.affinity, name: "affinity", parent: name, pattern: "\\S")
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.validate(self.hostId, name: "hostId", parent: name, pattern: "\\S")
            try self.validate(self.hostResourceGroupArn, name: "hostResourceGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.spreadDomain, name: "spreadDomain", parent: name, pattern: "\\S")
            try self.validate(self.tenancy, name: "tenancy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case affinity = "Affinity"
            case availabilityZone = "AvailabilityZone"
            case groupName = "GroupName"
            case hostId = "HostId"
            case hostResourceGroupArn = "HostResourceGroupArn"
            case partitionNumber = "PartitionNumber"
            case spreadDomain = "SpreadDomain"
            case tenancy = "Tenancy"
        }
    }

    public struct AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        public let enableResourceNameDnsAAAARecord: Bool?
        ///  Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        public let enableResourceNameDnsARecord: Bool?
        ///  The type of hostname for EC2 instances.
        public let hostnameType: String?

        @inlinable
        public init(enableResourceNameDnsAAAARecord: Bool? = nil, enableResourceNameDnsARecord: Bool? = nil, hostnameType: String? = nil) {
            self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
            self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
            self.hostnameType = hostnameType
        }

        public func validate(name: String) throws {
            try self.validate(self.hostnameType, name: "hostnameType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case enableResourceNameDnsAAAARecord = "EnableResourceNameDnsAAAARecord"
            case enableResourceNameDnsARecord = "EnableResourceNameDnsARecord"
            case hostnameType = "HostnameType"
        }
    }

    public struct AwsEc2LaunchTemplateDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The default version of the launch template.
        public let defaultVersionNumber: Int64?
        ///  An ID for the launch template.
        public let id: String?
        ///  The latest version of the launch template.
        public let latestVersionNumber: Int64?
        ///  The information to include in the launch template.
        public let launchTemplateData: AwsEc2LaunchTemplateDataDetails?
        ///  A name for the launch template.
        public let launchTemplateName: String?

        @inlinable
        public init(defaultVersionNumber: Int64? = nil, id: String? = nil, latestVersionNumber: Int64? = nil, launchTemplateData: AwsEc2LaunchTemplateDataDetails? = nil, launchTemplateName: String? = nil) {
            self.defaultVersionNumber = defaultVersionNumber
            self.id = id
            self.latestVersionNumber = latestVersionNumber
            self.launchTemplateData = launchTemplateData
            self.launchTemplateName = launchTemplateName
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.launchTemplateData?.validate(name: "\(name).launchTemplateData")
            try self.validate(self.launchTemplateName, name: "launchTemplateName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultVersionNumber = "DefaultVersionNumber"
            case id = "Id"
            case latestVersionNumber = "LatestVersionNumber"
            case launchTemplateData = "LaunchTemplateData"
            case launchTemplateName = "LaunchTemplateName"
        }
    }

    public struct AwsEc2NetworkAclAssociation: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the association between the network ACL and the subnet.
        public let networkAclAssociationId: String?
        /// The identifier of the network ACL.
        public let networkAclId: String?
        /// The identifier of the subnet that is associated with the network ACL.
        public let subnetId: String?

        @inlinable
        public init(networkAclAssociationId: String? = nil, networkAclId: String? = nil, subnetId: String? = nil) {
            self.networkAclAssociationId = networkAclAssociationId
            self.networkAclId = networkAclId
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.validate(self.networkAclAssociationId, name: "networkAclAssociationId", parent: name, pattern: "\\S")
            try self.validate(self.networkAclId, name: "networkAclId", parent: name, pattern: "\\S")
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case networkAclAssociationId = "NetworkAclAssociationId"
            case networkAclId = "NetworkAclId"
            case subnetId = "SubnetId"
        }
    }

    public struct AwsEc2NetworkAclDetails: AWSEncodableShape & AWSDecodableShape {
        /// Associations between the network ACL and subnets.
        public let associations: [AwsEc2NetworkAclAssociation]?
        /// The set of rules in the network ACL.
        public let entries: [AwsEc2NetworkAclEntry]?
        /// Whether this is the default network ACL for the VPC.
        public let isDefault: Bool?
        /// The identifier of the network ACL.
        public let networkAclId: String?
        /// The identifier of the Amazon Web Services account that owns the network ACL.
        public let ownerId: String?
        /// The identifier of the VPC for the network ACL.
        public let vpcId: String?

        @inlinable
        public init(associations: [AwsEc2NetworkAclAssociation]? = nil, entries: [AwsEc2NetworkAclEntry]? = nil, isDefault: Bool? = nil, networkAclId: String? = nil, ownerId: String? = nil, vpcId: String? = nil) {
            self.associations = associations
            self.entries = entries
            self.isDefault = isDefault
            self.networkAclId = networkAclId
            self.ownerId = ownerId
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.associations?.forEach {
                try $0.validate(name: "\(name).associations[]")
            }
            try self.entries?.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
            try self.validate(self.networkAclId, name: "networkAclId", parent: name, pattern: "\\S")
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associations = "Associations"
            case entries = "Entries"
            case isDefault = "IsDefault"
            case networkAclId = "NetworkAclId"
            case ownerId = "OwnerId"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2NetworkAclEntry: AWSEncodableShape & AWSDecodableShape {
        /// The IPV4 network range for which to deny or allow access.
        public let cidrBlock: String?
        /// Whether the rule is an egress rule. An egress rule is a rule that applies to traffic that leaves the subnet.
        public let egress: Bool?
        /// The Internet Control Message Protocol (ICMP) type and code for which to deny or allow access.
        public let icmpTypeCode: IcmpTypeCode?
        /// The IPV6 network range for which to deny or allow access.
        public let ipv6CidrBlock: String?
        /// For TCP or UDP protocols, the range of ports that the rule applies to.
        public let portRange: PortRangeFromTo?
        /// The protocol that the rule applies to. To deny or allow access to all protocols, use the value -1.
        public let `protocol`: String?
        /// Whether the rule is used to allow access or deny access.
        public let ruleAction: String?
        /// The rule number. The rules are processed in order by their number.
        public let ruleNumber: Int?

        @inlinable
        public init(cidrBlock: String? = nil, egress: Bool? = nil, icmpTypeCode: IcmpTypeCode? = nil, ipv6CidrBlock: String? = nil, portRange: PortRangeFromTo? = nil, protocol: String? = nil, ruleAction: String? = nil, ruleNumber: Int? = nil) {
            self.cidrBlock = cidrBlock
            self.egress = egress
            self.icmpTypeCode = icmpTypeCode
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.ruleNumber = ruleNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "\\S")
            try self.validate(self.ipv6CidrBlock, name: "ipv6CidrBlock", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.validate(self.ruleAction, name: "ruleAction", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrBlock = "CidrBlock"
            case egress = "Egress"
            case icmpTypeCode = "IcmpTypeCode"
            case ipv6CidrBlock = "Ipv6CidrBlock"
            case portRange = "PortRange"
            case `protocol` = "Protocol"
            case ruleAction = "RuleAction"
            case ruleNumber = "RuleNumber"
        }
    }

    public struct AwsEc2NetworkInterfaceAttachment: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the network interface attachment
        public let attachmentId: String?
        /// Indicates when the attachment initiated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let attachTime: String?
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public let deleteOnTermination: Bool?
        /// The device index of the network interface attachment on the instance.
        public let deviceIndex: Int?
        /// The ID of the instance.
        public let instanceId: String?
        /// The Amazon Web Services account ID of the owner of the instance.
        public let instanceOwnerId: String?
        /// The attachment state. Valid values: attaching | attached | detaching | detached
        public let status: String?

        @inlinable
        public init(attachmentId: String? = nil, attachTime: String? = nil, deleteOnTermination: Bool? = nil, deviceIndex: Int? = nil, instanceId: String? = nil, instanceOwnerId: String? = nil, status: String? = nil) {
            self.attachmentId = attachmentId
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.deviceIndex = deviceIndex
            self.instanceId = instanceId
            self.instanceOwnerId = instanceOwnerId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "\\S")
            try self.validate(self.attachTime, name: "attachTime", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "\\S")
            try self.validate(self.instanceOwnerId, name: "instanceOwnerId", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case attachTime = "AttachTime"
            case deleteOnTermination = "DeleteOnTermination"
            case deviceIndex = "DeviceIndex"
            case instanceId = "InstanceId"
            case instanceOwnerId = "InstanceOwnerId"
            case status = "Status"
        }
    }

    public struct AwsEc2NetworkInterfaceDetails: AWSEncodableShape & AWSDecodableShape {
        /// The network interface attachment.
        public let attachment: AwsEc2NetworkInterfaceAttachment?
        /// The IPv6 addresses associated with the network interface.
        public let ipV6Addresses: [AwsEc2NetworkInterfaceIpV6AddressDetail]?
        /// The ID of the network interface.
        public let networkInterfaceId: String?
        /// The private IPv4 addresses associated with the network interface.
        public let privateIpAddresses: [AwsEc2NetworkInterfacePrivateIpAddressDetail]?
        /// The public DNS name of the network interface.
        public let publicDnsName: String?
        /// The address of the Elastic IP address bound to the network interface.
        public let publicIp: String?
        /// Security groups for the network interface.
        public let securityGroups: [AwsEc2NetworkInterfaceSecurityGroup]?
        /// Indicates whether traffic to or from the instance is validated.
        public let sourceDestCheck: Bool?

        @inlinable
        public init(attachment: AwsEc2NetworkInterfaceAttachment? = nil, ipV6Addresses: [AwsEc2NetworkInterfaceIpV6AddressDetail]? = nil, networkInterfaceId: String? = nil, privateIpAddresses: [AwsEc2NetworkInterfacePrivateIpAddressDetail]? = nil, publicDnsName: String? = nil, publicIp: String? = nil, securityGroups: [AwsEc2NetworkInterfaceSecurityGroup]? = nil, sourceDestCheck: Bool? = nil) {
            self.attachment = attachment
            self.ipV6Addresses = ipV6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.sourceDestCheck = sourceDestCheck
        }

        public func validate(name: String) throws {
            try self.attachment?.validate(name: "\(name).attachment")
            try self.ipV6Addresses?.forEach {
                try $0.validate(name: "\(name).ipV6Addresses[]")
            }
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
            try self.privateIpAddresses?.forEach {
                try $0.validate(name: "\(name).privateIpAddresses[]")
            }
            try self.validate(self.publicDnsName, name: "publicDnsName", parent: name, pattern: "\\S")
            try self.validate(self.publicIp, name: "publicIp", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try $0.validate(name: "\(name).securityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case ipV6Addresses = "IpV6Addresses"
            case networkInterfaceId = "NetworkInterfaceId"
            case privateIpAddresses = "PrivateIpAddresses"
            case publicDnsName = "PublicDnsName"
            case publicIp = "PublicIp"
            case securityGroups = "SecurityGroups"
            case sourceDestCheck = "SourceDestCheck"
        }
    }

    public struct AwsEc2NetworkInterfaceIpV6AddressDetail: AWSEncodableShape & AWSDecodableShape {
        /// The IPV6 address.
        public let ipV6Address: String?

        @inlinable
        public init(ipV6Address: String? = nil) {
            self.ipV6Address = ipV6Address
        }

        public func validate(name: String) throws {
            try self.validate(self.ipV6Address, name: "ipV6Address", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipV6Address = "IpV6Address"
        }
    }

    public struct AwsEc2NetworkInterfacePrivateIpAddressDetail: AWSEncodableShape & AWSDecodableShape {
        /// The private DNS name for the IP address.
        public let privateDnsName: String?
        /// The IP address.
        public let privateIpAddress: String?

        @inlinable
        public init(privateDnsName: String? = nil, privateIpAddress: String? = nil) {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.privateDnsName, name: "privateDnsName", parent: name, pattern: "\\S")
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case privateDnsName = "PrivateDnsName"
            case privateIpAddress = "PrivateIpAddress"
        }
    }

    public struct AwsEc2NetworkInterfaceSecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the security group.
        public let groupId: String?
        /// The name of the security group.
        public let groupName: String?

        @inlinable
        public init(groupId: String? = nil, groupName: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "\\S")
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
        }
    }

    public struct AwsEc2RouteTableDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The associations between a route table and one or more subnets or a gateway.
        public let associationSet: [AssociationSetDetails]?
        ///  The ID of the Amazon Web Services account that owns the route table.
        public let ownerId: String?
        ///  Describes a virtual private gateway propagating route.
        public let propagatingVgwSet: [PropagatingVgwSetDetails]?
        ///  The routes in the route table.
        public let routeSet: [RouteSetDetails]?
        ///  The ID of the route table.
        public let routeTableId: String?
        ///  The ID of the virtual private cloud (VPC).
        public let vpcId: String?

        @inlinable
        public init(associationSet: [AssociationSetDetails]? = nil, ownerId: String? = nil, propagatingVgwSet: [PropagatingVgwSetDetails]? = nil, routeSet: [RouteSetDetails]? = nil, routeTableId: String? = nil, vpcId: String? = nil) {
            self.associationSet = associationSet
            self.ownerId = ownerId
            self.propagatingVgwSet = propagatingVgwSet
            self.routeSet = routeSet
            self.routeTableId = routeTableId
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.associationSet?.forEach {
                try $0.validate(name: "\(name).associationSet[]")
            }
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.propagatingVgwSet?.forEach {
                try $0.validate(name: "\(name).propagatingVgwSet[]")
            }
            try self.routeSet?.forEach {
                try $0.validate(name: "\(name).routeSet[]")
            }
            try self.validate(self.routeTableId, name: "routeTableId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associationSet = "AssociationSet"
            case ownerId = "OwnerId"
            case propagatingVgwSet = "PropagatingVgwSet"
            case routeSet = "RouteSet"
            case routeTableId = "RouteTableId"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2SecurityGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the security group.
        public let groupId: String?
        /// The name of the security group.
        public let groupName: String?
        /// The inbound rules associated with the security group.
        public let ipPermissions: [AwsEc2SecurityGroupIpPermission]?
        /// [VPC only] The outbound rules associated with the security group.
        public let ipPermissionsEgress: [AwsEc2SecurityGroupIpPermission]?
        /// The Amazon Web Services account ID of the owner of the security group.
        public let ownerId: String?
        /// [VPC only] The ID of the VPC for the security group.
        public let vpcId: String?

        @inlinable
        public init(groupId: String? = nil, groupName: String? = nil, ipPermissions: [AwsEc2SecurityGroupIpPermission]? = nil, ipPermissionsEgress: [AwsEc2SecurityGroupIpPermission]? = nil, ownerId: String? = nil, vpcId: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.ipPermissionsEgress = ipPermissionsEgress
            self.ownerId = ownerId
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "\\S")
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.ipPermissions?.forEach {
                try $0.validate(name: "\(name).ipPermissions[]")
            }
            try self.ipPermissionsEgress?.forEach {
                try $0.validate(name: "\(name).ipPermissionsEgress[]")
            }
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
            case ipPermissions = "IpPermissions"
            case ipPermissionsEgress = "IpPermissionsEgress"
            case ownerId = "OwnerId"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2SecurityGroupIpPermission: AWSEncodableShape & AWSDecodableShape {
        /// The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        public let fromPort: Int?
        /// The IP protocol name (tcp, udp, icmp, icmpv6) or number. [VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or icmpv6 allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For icmpv6, the port range is optional. If you omit the port range, traffic for all types and codes is allowed.
        public let ipProtocol: String?
        /// The IPv4 ranges.
        public let ipRanges: [AwsEc2SecurityGroupIpRange]?
        /// The IPv6 ranges.
        public let ipv6Ranges: [AwsEc2SecurityGroupIpv6Range]?
        /// [VPC only] The prefix list IDs for an Amazon Web Services service. With outbound rules, this is the Amazon Web Services service to access through a VPC endpoint from instances associated with the security group.
        public let prefixListIds: [AwsEc2SecurityGroupPrefixListId]?
        /// The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        public let toPort: Int?
        /// The security group and Amazon Web Services account ID pairs.
        public let userIdGroupPairs: [AwsEc2SecurityGroupUserIdGroupPair]?

        @inlinable
        public init(fromPort: Int? = nil, ipProtocol: String? = nil, ipRanges: [AwsEc2SecurityGroupIpRange]? = nil, ipv6Ranges: [AwsEc2SecurityGroupIpv6Range]? = nil, prefixListIds: [AwsEc2SecurityGroupPrefixListId]? = nil, toPort: Int? = nil, userIdGroupPairs: [AwsEc2SecurityGroupUserIdGroupPair]? = nil) {
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.ipRanges = ipRanges
            self.ipv6Ranges = ipv6Ranges
            self.prefixListIds = prefixListIds
            self.toPort = toPort
            self.userIdGroupPairs = userIdGroupPairs
        }

        public func validate(name: String) throws {
            try self.validate(self.ipProtocol, name: "ipProtocol", parent: name, pattern: "\\S")
            try self.ipRanges?.forEach {
                try $0.validate(name: "\(name).ipRanges[]")
            }
            try self.ipv6Ranges?.forEach {
                try $0.validate(name: "\(name).ipv6Ranges[]")
            }
            try self.prefixListIds?.forEach {
                try $0.validate(name: "\(name).prefixListIds[]")
            }
            try self.userIdGroupPairs?.forEach {
                try $0.validate(name: "\(name).userIdGroupPairs[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case ipProtocol = "IpProtocol"
            case ipRanges = "IpRanges"
            case ipv6Ranges = "Ipv6Ranges"
            case prefixListIds = "PrefixListIds"
            case toPort = "ToPort"
            case userIdGroupPairs = "UserIdGroupPairs"
        }
    }

    public struct AwsEc2SecurityGroupIpRange: AWSEncodableShape & AWSDecodableShape {
        /// The IPv4 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv4 address, use the /32 prefix length.
        public let cidrIp: String?

        @inlinable
        public init(cidrIp: String? = nil) {
            self.cidrIp = cidrIp
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrIp, name: "cidrIp", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrIp = "CidrIp"
        }
    }

    public struct AwsEc2SecurityGroupIpv6Range: AWSEncodableShape & AWSDecodableShape {
        /// The IPv6 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv6 address, use the /128 prefix length.
        public let cidrIpv6: String?

        @inlinable
        public init(cidrIpv6: String? = nil) {
            self.cidrIpv6 = cidrIpv6
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrIpv6, name: "cidrIpv6", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrIpv6 = "CidrIpv6"
        }
    }

    public struct AwsEc2SecurityGroupPrefixListId: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the prefix.
        public let prefixListId: String?

        @inlinable
        public init(prefixListId: String? = nil) {
            self.prefixListId = prefixListId
        }

        public func validate(name: String) throws {
            try self.validate(self.prefixListId, name: "prefixListId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case prefixListId = "PrefixListId"
        }
    }

    public struct AwsEc2SecurityGroupUserIdGroupPair: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the security group.
        public let groupId: String?
        /// The name of the security group.
        public let groupName: String?
        /// The status of a VPC peering connection, if applicable.
        public let peeringStatus: String?
        /// The ID of an Amazon Web Services account. For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned. [EC2-Classic] Required when adding or removing rules that reference a security group in another VPC.
        public let userId: String?
        /// The ID of the VPC for the referenced security group, if applicable.
        public let vpcId: String?
        /// The ID of the VPC peering connection, if applicable.
        public let vpcPeeringConnectionId: String?

        @inlinable
        public init(groupId: String? = nil, groupName: String? = nil, peeringStatus: String? = nil, userId: String? = nil, vpcId: String? = nil, vpcPeeringConnectionId: String? = nil) {
            self.groupId = groupId
            self.groupName = groupName
            self.peeringStatus = peeringStatus
            self.userId = userId
            self.vpcId = vpcId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public func validate(name: String) throws {
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "\\S")
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.validate(self.peeringStatus, name: "peeringStatus", parent: name, pattern: "\\S")
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
            try self.validate(self.vpcPeeringConnectionId, name: "vpcPeeringConnectionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "GroupId"
            case groupName = "GroupName"
            case peeringStatus = "PeeringStatus"
            case userId = "UserId"
            case vpcId = "VpcId"
            case vpcPeeringConnectionId = "VpcPeeringConnectionId"
        }
    }

    public struct AwsEc2SubnetDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to assign an IPV6 address to a network interface that is created in this subnet.
        public let assignIpv6AddressOnCreation: Bool?
        /// The Availability Zone for the subnet.
        public let availabilityZone: String?
        /// The identifier of the Availability Zone for the subnet.
        public let availabilityZoneId: String?
        /// The number of available IPV4 addresses in the subnet. Does not include addresses for stopped instances.
        public let availableIpAddressCount: Int?
        /// The IPV4 CIDR block that is assigned to the subnet.
        public let cidrBlock: String?
        /// Whether this subnet is the default subnet for the Availability Zone.
        public let defaultForAz: Bool?
        /// The IPV6 CIDR blocks that are associated with the subnet.
        public let ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]?
        /// Whether instances in this subnet receive a public IP address.
        public let mapPublicIpOnLaunch: Bool?
        /// The identifier of the Amazon Web Services account that owns the subnet.
        public let ownerId: String?
        /// The current state of the subnet. Valid values are available or pending.
        public let state: String?
        /// The ARN of the subnet.
        public let subnetArn: String?
        /// The identifier of the subnet.
        public let subnetId: String?
        /// The identifier of the VPC that contains the subnet.
        public let vpcId: String?

        @inlinable
        public init(assignIpv6AddressOnCreation: Bool? = nil, availabilityZone: String? = nil, availabilityZoneId: String? = nil, availableIpAddressCount: Int? = nil, cidrBlock: String? = nil, defaultForAz: Bool? = nil, ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]? = nil, mapPublicIpOnLaunch: Bool? = nil, ownerId: String? = nil, state: String? = nil, subnetArn: String? = nil, subnetId: String? = nil, vpcId: String? = nil) {
            self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.availableIpAddressCount = availableIpAddressCount
            self.cidrBlock = cidrBlock
            self.defaultForAz = defaultForAz
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
            self.ownerId = ownerId
            self.state = state
            self.subnetArn = subnetArn
            self.subnetId = subnetId
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, pattern: "\\S")
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "\\S")
            try self.ipv6CidrBlockAssociationSet?.forEach {
                try $0.validate(name: "\(name).ipv6CidrBlockAssociationSet[]")
            }
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
            try self.validate(self.subnetArn, name: "subnetArn", parent: name, pattern: "\\S")
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case assignIpv6AddressOnCreation = "AssignIpv6AddressOnCreation"
            case availabilityZone = "AvailabilityZone"
            case availabilityZoneId = "AvailabilityZoneId"
            case availableIpAddressCount = "AvailableIpAddressCount"
            case cidrBlock = "CidrBlock"
            case defaultForAz = "DefaultForAz"
            case ipv6CidrBlockAssociationSet = "Ipv6CidrBlockAssociationSet"
            case mapPublicIpOnLaunch = "MapPublicIpOnLaunch"
            case ownerId = "OwnerId"
            case state = "State"
            case subnetArn = "SubnetArn"
            case subnetId = "SubnetId"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2TransitGatewayDetails: AWSEncodableShape & AWSDecodableShape {
        /// A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
        public let amazonSideAsn: Int?
        /// The ID of the default association route table.
        public let associationDefaultRouteTableId: String?
        /// Turn on or turn off automatic acceptance of attachment requests.
        public let autoAcceptSharedAttachments: String?
        /// Turn on or turn off automatic association with the default association route table.
        public let defaultRouteTableAssociation: String?
        /// Turn on or turn off automatic propagation of routes to the default propagation route table.
        public let defaultRouteTablePropagation: String?
        /// The description of the transit gateway.
        public let description: String?
        /// Turn on or turn off DNS support.
        public let dnsSupport: String?
        /// The ID of the transit gateway.
        public let id: String?
        /// Indicates whether multicast is supported on the transit gateway.
        public let multicastSupport: String?
        /// The ID of the default propagation route table.
        public let propagationDefaultRouteTableId: String?
        /// The transit gateway Classless Inter-Domain Routing (CIDR) blocks.
        public let transitGatewayCidrBlocks: [String]?
        /// Turn on or turn off Equal Cost Multipath Protocol (ECMP) support.
        public let vpnEcmpSupport: String?

        @inlinable
        public init(amazonSideAsn: Int? = nil, associationDefaultRouteTableId: String? = nil, autoAcceptSharedAttachments: String? = nil, defaultRouteTableAssociation: String? = nil, defaultRouteTablePropagation: String? = nil, description: String? = nil, dnsSupport: String? = nil, id: String? = nil, multicastSupport: String? = nil, propagationDefaultRouteTableId: String? = nil, transitGatewayCidrBlocks: [String]? = nil, vpnEcmpSupport: String? = nil) {
            self.amazonSideAsn = amazonSideAsn
            self.associationDefaultRouteTableId = associationDefaultRouteTableId
            self.autoAcceptSharedAttachments = autoAcceptSharedAttachments
            self.defaultRouteTableAssociation = defaultRouteTableAssociation
            self.defaultRouteTablePropagation = defaultRouteTablePropagation
            self.description = description
            self.dnsSupport = dnsSupport
            self.id = id
            self.multicastSupport = multicastSupport
            self.propagationDefaultRouteTableId = propagationDefaultRouteTableId
            self.transitGatewayCidrBlocks = transitGatewayCidrBlocks
            self.vpnEcmpSupport = vpnEcmpSupport
        }

        public func validate(name: String) throws {
            try self.validate(self.associationDefaultRouteTableId, name: "associationDefaultRouteTableId", parent: name, pattern: "\\S")
            try self.validate(self.autoAcceptSharedAttachments, name: "autoAcceptSharedAttachments", parent: name, pattern: "\\S")
            try self.validate(self.defaultRouteTableAssociation, name: "defaultRouteTableAssociation", parent: name, pattern: "\\S")
            try self.validate(self.defaultRouteTablePropagation, name: "defaultRouteTablePropagation", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.dnsSupport, name: "dnsSupport", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.multicastSupport, name: "multicastSupport", parent: name, pattern: "\\S")
            try self.validate(self.propagationDefaultRouteTableId, name: "propagationDefaultRouteTableId", parent: name, pattern: "\\S")
            try self.transitGatewayCidrBlocks?.forEach {
                try validate($0, name: "transitGatewayCidrBlocks[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.vpnEcmpSupport, name: "vpnEcmpSupport", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case amazonSideAsn = "AmazonSideAsn"
            case associationDefaultRouteTableId = "AssociationDefaultRouteTableId"
            case autoAcceptSharedAttachments = "AutoAcceptSharedAttachments"
            case defaultRouteTableAssociation = "DefaultRouteTableAssociation"
            case defaultRouteTablePropagation = "DefaultRouteTablePropagation"
            case description = "Description"
            case dnsSupport = "DnsSupport"
            case id = "Id"
            case multicastSupport = "MulticastSupport"
            case propagationDefaultRouteTableId = "PropagationDefaultRouteTableId"
            case transitGatewayCidrBlocks = "TransitGatewayCidrBlocks"
            case vpnEcmpSupport = "VpnEcmpSupport"
        }
    }

    public struct AwsEc2VolumeAttachment: AWSEncodableShape & AWSDecodableShape {
        /// The datetime when the attachment initiated.
        public let attachTime: String?
        /// Whether the EBS volume is deleted when the EC2 instance is terminated.
        public let deleteOnTermination: Bool?
        /// The identifier of the EC2 instance.
        public let instanceId: String?
        /// The attachment state of the volume. Valid values are as follows:    attaching     attached     busy     detaching     detached
        public let status: String?

        @inlinable
        public init(attachTime: String? = nil, deleteOnTermination: Bool? = nil, instanceId: String? = nil, status: String? = nil) {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.instanceId = instanceId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.attachTime, name: "attachTime", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attachTime = "AttachTime"
            case deleteOnTermination = "DeleteOnTermination"
            case instanceId = "InstanceId"
            case status = "Status"
        }
    }

    public struct AwsEc2VolumeDetails: AWSEncodableShape & AWSDecodableShape {
        /// The volume attachments.
        public let attachments: [AwsEc2VolumeAttachment]?
        /// Indicates when the volume was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createTime: String?
        /// The device name for the volume that is attached to the instance.
        public let deviceName: String?
        /// Specifies whether the volume is encrypted.
        public let encrypted: Bool?
        /// The ARN of the KMS key that was used to protect the volume encryption key for the volume.
        public let kmsKeyId: String?
        /// The size of the volume, in GiBs.
        public let size: Int?
        /// The snapshot from which the volume was created.
        public let snapshotId: String?
        /// The volume state. Valid values are as follows:    available     creating     deleted     deleting     error     in-use
        public let status: String?
        /// The ID of the volume.
        public let volumeId: String?
        /// Indicates whether the volume was scanned or skipped.
        public let volumeScanStatus: String?
        /// The volume type.
        public let volumeType: String?

        @inlinable
        public init(attachments: [AwsEc2VolumeAttachment]? = nil, createTime: String? = nil, deviceName: String? = nil, encrypted: Bool? = nil, kmsKeyId: String? = nil, size: Int? = nil, snapshotId: String? = nil, status: String? = nil, volumeId: String? = nil, volumeScanStatus: String? = nil, volumeType: String? = nil) {
            self.attachments = attachments
            self.createTime = createTime
            self.deviceName = deviceName
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.size = size
            self.snapshotId = snapshotId
            self.status = status
            self.volumeId = volumeId
            self.volumeScanStatus = volumeScanStatus
            self.volumeType = volumeType
        }

        public func validate(name: String) throws {
            try self.attachments?.forEach {
                try $0.validate(name: "\(name).attachments[]")
            }
            try self.validate(self.createTime, name: "createTime", parent: name, pattern: "\\S")
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.volumeId, name: "volumeId", parent: name, pattern: "\\S")
            try self.validate(self.volumeScanStatus, name: "volumeScanStatus", parent: name, pattern: "\\S")
            try self.validate(self.volumeType, name: "volumeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "Attachments"
            case createTime = "CreateTime"
            case deviceName = "DeviceName"
            case encrypted = "Encrypted"
            case kmsKeyId = "KmsKeyId"
            case size = "Size"
            case snapshotId = "SnapshotId"
            case status = "Status"
            case volumeId = "VolumeId"
            case volumeScanStatus = "VolumeScanStatus"
            case volumeType = "VolumeType"
        }
    }

    public struct AwsEc2VpcDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about the IPv4 CIDR blocks associated with the VPC.
        public let cidrBlockAssociationSet: [CidrBlockAssociation]?
        /// The identifier of the set of Dynamic Host Configuration Protocol (DHCP) options that are associated with the VPC. If the default options are associated with the VPC, then this is default.
        public let dhcpOptionsId: String?
        /// Information about the IPv6 CIDR blocks associated with the VPC.
        public let ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]?
        /// The current state of the VPC. Valid values are available or pending.
        public let state: String?

        @inlinable
        public init(cidrBlockAssociationSet: [CidrBlockAssociation]? = nil, dhcpOptionsId: String? = nil, ipv6CidrBlockAssociationSet: [Ipv6CidrBlockAssociation]? = nil, state: String? = nil) {
            self.cidrBlockAssociationSet = cidrBlockAssociationSet
            self.dhcpOptionsId = dhcpOptionsId
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.state = state
        }

        public func validate(name: String) throws {
            try self.cidrBlockAssociationSet?.forEach {
                try $0.validate(name: "\(name).cidrBlockAssociationSet[]")
            }
            try self.validate(self.dhcpOptionsId, name: "dhcpOptionsId", parent: name, pattern: "\\S")
            try self.ipv6CidrBlockAssociationSet?.forEach {
                try $0.validate(name: "\(name).ipv6CidrBlockAssociationSet[]")
            }
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrBlockAssociationSet = "CidrBlockAssociationSet"
            case dhcpOptionsId = "DhcpOptionsId"
            case ipv6CidrBlockAssociationSet = "Ipv6CidrBlockAssociationSet"
            case state = "State"
        }
    }

    public struct AwsEc2VpcEndpointServiceDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether requests from other Amazon Web Services accounts to create an endpoint to the service must first be accepted.
        public let acceptanceRequired: Bool?
        /// The Availability Zones where the service is available.
        public let availabilityZones: [String]?
        /// The DNS names for the service.
        public let baseEndpointDnsNames: [String]?
        /// The ARNs of the Gateway Load Balancers for the service.
        public let gatewayLoadBalancerArns: [String]?
        /// Whether the service manages its VPC endpoints.
        public let managesVpcEndpoints: Bool?
        /// The ARNs of the Network Load Balancers for the service.
        public let networkLoadBalancerArns: [String]?
        /// The private DNS name for the service.
        public let privateDnsName: String?
        /// The identifier of the service.
        public let serviceId: String?
        /// The name of the service.
        public let serviceName: String?
        /// The current state of the service. Valid values are as follows:    Available     Deleted     Deleting     Failed     Pending
        public let serviceState: String?
        /// The types for the service.
        public let serviceType: [AwsEc2VpcEndpointServiceServiceTypeDetails]?

        @inlinable
        public init(acceptanceRequired: Bool? = nil, availabilityZones: [String]? = nil, baseEndpointDnsNames: [String]? = nil, gatewayLoadBalancerArns: [String]? = nil, managesVpcEndpoints: Bool? = nil, networkLoadBalancerArns: [String]? = nil, privateDnsName: String? = nil, serviceId: String? = nil, serviceName: String? = nil, serviceState: String? = nil, serviceType: [AwsEc2VpcEndpointServiceServiceTypeDetails]? = nil) {
            self.acceptanceRequired = acceptanceRequired
            self.availabilityZones = availabilityZones
            self.baseEndpointDnsNames = baseEndpointDnsNames
            self.gatewayLoadBalancerArns = gatewayLoadBalancerArns
            self.managesVpcEndpoints = managesVpcEndpoints
            self.networkLoadBalancerArns = networkLoadBalancerArns
            self.privateDnsName = privateDnsName
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceState = serviceState
            self.serviceType = serviceType
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "\\S")
            }
            try self.baseEndpointDnsNames?.forEach {
                try validate($0, name: "baseEndpointDnsNames[]", parent: name, pattern: "\\S")
            }
            try self.gatewayLoadBalancerArns?.forEach {
                try validate($0, name: "gatewayLoadBalancerArns[]", parent: name, pattern: "\\S")
            }
            try self.networkLoadBalancerArns?.forEach {
                try validate($0, name: "networkLoadBalancerArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.privateDnsName, name: "privateDnsName", parent: name, pattern: "\\S")
            try self.validate(self.serviceId, name: "serviceId", parent: name, pattern: "\\S")
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "\\S")
            try self.validate(self.serviceState, name: "serviceState", parent: name, pattern: "\\S")
            try self.serviceType?.forEach {
                try $0.validate(name: "\(name).serviceType[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case acceptanceRequired = "AcceptanceRequired"
            case availabilityZones = "AvailabilityZones"
            case baseEndpointDnsNames = "BaseEndpointDnsNames"
            case gatewayLoadBalancerArns = "GatewayLoadBalancerArns"
            case managesVpcEndpoints = "ManagesVpcEndpoints"
            case networkLoadBalancerArns = "NetworkLoadBalancerArns"
            case privateDnsName = "PrivateDnsName"
            case serviceId = "ServiceId"
            case serviceName = "ServiceName"
            case serviceState = "ServiceState"
            case serviceType = "ServiceType"
        }
    }

    public struct AwsEc2VpcEndpointServiceServiceTypeDetails: AWSEncodableShape & AWSDecodableShape {
        /// The type of service.
        public let serviceType: String?

        @inlinable
        public init(serviceType: String? = nil) {
            self.serviceType = serviceType
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceType, name: "serviceType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceType = "ServiceType"
        }
    }

    public struct AwsEc2VpcPeeringConnectionDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about the accepter VPC.
        public let accepterVpcInfo: AwsEc2VpcPeeringConnectionVpcInfoDetails?
        /// The time at which an unaccepted VPC peering connection will expire.
        public let expirationTime: String?
        /// Information about the requester VPC.
        public let requesterVpcInfo: AwsEc2VpcPeeringConnectionVpcInfoDetails?
        /// The status of the VPC peering connection.
        public let status: AwsEc2VpcPeeringConnectionStatusDetails?
        /// The ID of the VPC peering connection.
        public let vpcPeeringConnectionId: String?

        @inlinable
        public init(accepterVpcInfo: AwsEc2VpcPeeringConnectionVpcInfoDetails? = nil, expirationTime: String? = nil, requesterVpcInfo: AwsEc2VpcPeeringConnectionVpcInfoDetails? = nil, status: AwsEc2VpcPeeringConnectionStatusDetails? = nil, vpcPeeringConnectionId: String? = nil) {
            self.accepterVpcInfo = accepterVpcInfo
            self.expirationTime = expirationTime
            self.requesterVpcInfo = requesterVpcInfo
            self.status = status
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public func validate(name: String) throws {
            try self.accepterVpcInfo?.validate(name: "\(name).accepterVpcInfo")
            try self.validate(self.expirationTime, name: "expirationTime", parent: name, pattern: "\\S")
            try self.requesterVpcInfo?.validate(name: "\(name).requesterVpcInfo")
            try self.status?.validate(name: "\(name).status")
            try self.validate(self.vpcPeeringConnectionId, name: "vpcPeeringConnectionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accepterVpcInfo = "AccepterVpcInfo"
            case expirationTime = "ExpirationTime"
            case requesterVpcInfo = "RequesterVpcInfo"
            case status = "Status"
            case vpcPeeringConnectionId = "VpcPeeringConnectionId"
        }
    }

    public struct AwsEc2VpcPeeringConnectionStatusDetails: AWSEncodableShape & AWSDecodableShape {
        /// The status of the VPC peering connection.
        public let code: String?
        /// A message that provides more information about the status, if applicable.
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, pattern: "\\S")
            try self.validate(self.message, name: "message", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct AwsEc2VpcPeeringConnectionVpcInfoDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IPv4 CIDR block for the VPC.
        public let cidrBlock: String?
        /// Information about the IPv4 CIDR blocks for the VPC.
        public let cidrBlockSet: [VpcInfoCidrBlockSetDetails]?
        /// The IPv6 CIDR block for the VPC.
        public let ipv6CidrBlockSet: [VpcInfoIpv6CidrBlockSetDetails]?
        /// The ID of the Amazon Web Services account that owns the VPC.
        public let ownerId: String?
        /// Information about the VPC peering connection options for the accepter or requester VPC.
        public let peeringOptions: VpcInfoPeeringOptionsDetails?
        /// The Amazon Web Services Region in which the VPC is located.
        public let region: String?
        /// The ID of the VPC.
        public let vpcId: String?

        @inlinable
        public init(cidrBlock: String? = nil, cidrBlockSet: [VpcInfoCidrBlockSetDetails]? = nil, ipv6CidrBlockSet: [VpcInfoIpv6CidrBlockSetDetails]? = nil, ownerId: String? = nil, peeringOptions: VpcInfoPeeringOptionsDetails? = nil, region: String? = nil, vpcId: String? = nil) {
            self.cidrBlock = cidrBlock
            self.cidrBlockSet = cidrBlockSet
            self.ipv6CidrBlockSet = ipv6CidrBlockSet
            self.ownerId = ownerId
            self.peeringOptions = peeringOptions
            self.region = region
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "\\S")
            try self.cidrBlockSet?.forEach {
                try $0.validate(name: "\(name).cidrBlockSet[]")
            }
            try self.ipv6CidrBlockSet?.forEach {
                try $0.validate(name: "\(name).ipv6CidrBlockSet[]")
            }
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.region, name: "region", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrBlock = "CidrBlock"
            case cidrBlockSet = "CidrBlockSet"
            case ipv6CidrBlockSet = "Ipv6CidrBlockSet"
            case ownerId = "OwnerId"
            case peeringOptions = "PeeringOptions"
            case region = "Region"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEc2VpnConnectionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The category of the VPN connection. VPN indicates an Amazon Web Services VPN connection. VPN-Classic indicates an Amazon Web Services Classic VPN connection.
        public let category: String?
        /// The configuration information for the VPN connection's customer gateway, in the native XML format.
        public let customerGatewayConfiguration: String?
        /// The identifier of the customer gateway that is at your end of the VPN connection.
        public let customerGatewayId: String?
        /// The VPN connection options.
        public let options: AwsEc2VpnConnectionOptionsDetails?
        /// The static routes that are associated with the VPN connection.
        public let routes: [AwsEc2VpnConnectionRoutesDetails]?
        /// The current state of the VPN connection. Valid values are as follows:    available     deleted     deleting     pending
        public let state: String?
        /// The identifier of the transit gateway that is associated with the VPN connection.
        public let transitGatewayId: String?
        /// The type of VPN connection.
        public let type: String?
        /// Information about the VPN tunnel.
        public let vgwTelemetry: [AwsEc2VpnConnectionVgwTelemetryDetails]?
        /// The identifier of the VPN connection.
        public let vpnConnectionId: String?
        /// The identifier of the virtual private gateway that is at the Amazon Web Services side of the VPN connection.
        public let vpnGatewayId: String?

        @inlinable
        public init(category: String? = nil, customerGatewayConfiguration: String? = nil, customerGatewayId: String? = nil, options: AwsEc2VpnConnectionOptionsDetails? = nil, routes: [AwsEc2VpnConnectionRoutesDetails]? = nil, state: String? = nil, transitGatewayId: String? = nil, type: String? = nil, vgwTelemetry: [AwsEc2VpnConnectionVgwTelemetryDetails]? = nil, vpnConnectionId: String? = nil, vpnGatewayId: String? = nil) {
            self.category = category
            self.customerGatewayConfiguration = customerGatewayConfiguration
            self.customerGatewayId = customerGatewayId
            self.options = options
            self.routes = routes
            self.state = state
            self.transitGatewayId = transitGatewayId
            self.type = type
            self.vgwTelemetry = vgwTelemetry
            self.vpnConnectionId = vpnConnectionId
            self.vpnGatewayId = vpnGatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.category, name: "category", parent: name, pattern: "\\S")
            try self.validate(self.customerGatewayConfiguration, name: "customerGatewayConfiguration", parent: name, pattern: "\\S")
            try self.validate(self.customerGatewayId, name: "customerGatewayId", parent: name, pattern: "\\S")
            try self.options?.validate(name: "\(name).options")
            try self.routes?.forEach {
                try $0.validate(name: "\(name).routes[]")
            }
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
            try self.validate(self.transitGatewayId, name: "transitGatewayId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.vgwTelemetry?.forEach {
                try $0.validate(name: "\(name).vgwTelemetry[]")
            }
            try self.validate(self.vpnConnectionId, name: "vpnConnectionId", parent: name, pattern: "\\S")
            try self.validate(self.vpnGatewayId, name: "vpnGatewayId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case customerGatewayConfiguration = "CustomerGatewayConfiguration"
            case customerGatewayId = "CustomerGatewayId"
            case options = "Options"
            case routes = "Routes"
            case state = "State"
            case transitGatewayId = "TransitGatewayId"
            case type = "Type"
            case vgwTelemetry = "VgwTelemetry"
            case vpnConnectionId = "VpnConnectionId"
            case vpnGatewayId = "VpnGatewayId"
        }
    }

    public struct AwsEc2VpnConnectionOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the VPN connection uses static routes only.
        public let staticRoutesOnly: Bool?
        /// The VPN tunnel options.
        public let tunnelOptions: [AwsEc2VpnConnectionOptionsTunnelOptionsDetails]?

        @inlinable
        public init(staticRoutesOnly: Bool? = nil, tunnelOptions: [AwsEc2VpnConnectionOptionsTunnelOptionsDetails]? = nil) {
            self.staticRoutesOnly = staticRoutesOnly
            self.tunnelOptions = tunnelOptions
        }

        public func validate(name: String) throws {
            try self.tunnelOptions?.forEach {
                try $0.validate(name: "\(name).tunnelOptions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case staticRoutesOnly = "StaticRoutesOnly"
            case tunnelOptions = "TunnelOptions"
        }
    }

    public struct AwsEc2VpnConnectionOptionsTunnelOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of seconds after which a Dead Peer Detection (DPD) timeout occurs.
        public let dpdTimeoutSeconds: Int?
        /// The Internet Key Exchange (IKE) versions that are permitted for the VPN tunnel.
        public let ikeVersions: [String]?
        /// The external IP address of the VPN tunnel.
        public let outsideIpAddress: String?
        /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1 IKE negotiations.
        public let phase1DhGroupNumbers: [Int]?
        /// The permitted encryption algorithms for the VPN tunnel for phase 1 IKE negotiations.
        public let phase1EncryptionAlgorithms: [String]?
        /// The permitted integrity algorithms for the VPN tunnel for phase 1 IKE negotiations.
        public let phase1IntegrityAlgorithms: [String]?
        /// The lifetime for phase 1 of the IKE negotiation, in seconds.
        public let phase1LifetimeSeconds: Int?
        /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2 IKE negotiations.
        public let phase2DhGroupNumbers: [Int]?
        /// The permitted encryption algorithms for the VPN tunnel for phase 2 IKE negotiations.
        public let phase2EncryptionAlgorithms: [String]?
        /// The permitted integrity algorithms for the VPN tunnel for phase 2 IKE negotiations.
        public let phase2IntegrityAlgorithms: [String]?
        /// The lifetime for phase 2 of the IKE negotiation, in seconds.
        public let phase2LifetimeSeconds: Int?
        /// The preshared key to establish initial authentication between the virtual private gateway and the customer gateway.
        public let preSharedKey: String?
        /// The percentage of the rekey window, which is determined by RekeyMarginTimeSeconds during which the rekey time is randomly selected.
        public let rekeyFuzzPercentage: Int?
        /// The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey.
        public let rekeyMarginTimeSeconds: Int?
        /// The number of packets in an IKE replay window.
        public let replayWindowSize: Int?
        /// The range of inside IPv4 addresses for the tunnel.
        public let tunnelInsideCidr: String?

        @inlinable
        public init(dpdTimeoutSeconds: Int? = nil, ikeVersions: [String]? = nil, outsideIpAddress: String? = nil, phase1DhGroupNumbers: [Int]? = nil, phase1EncryptionAlgorithms: [String]? = nil, phase1IntegrityAlgorithms: [String]? = nil, phase1LifetimeSeconds: Int? = nil, phase2DhGroupNumbers: [Int]? = nil, phase2EncryptionAlgorithms: [String]? = nil, phase2IntegrityAlgorithms: [String]? = nil, phase2LifetimeSeconds: Int? = nil, preSharedKey: String? = nil, rekeyFuzzPercentage: Int? = nil, rekeyMarginTimeSeconds: Int? = nil, replayWindowSize: Int? = nil, tunnelInsideCidr: String? = nil) {
            self.dpdTimeoutSeconds = dpdTimeoutSeconds
            self.ikeVersions = ikeVersions
            self.outsideIpAddress = outsideIpAddress
            self.phase1DhGroupNumbers = phase1DhGroupNumbers
            self.phase1EncryptionAlgorithms = phase1EncryptionAlgorithms
            self.phase1IntegrityAlgorithms = phase1IntegrityAlgorithms
            self.phase1LifetimeSeconds = phase1LifetimeSeconds
            self.phase2DhGroupNumbers = phase2DhGroupNumbers
            self.phase2EncryptionAlgorithms = phase2EncryptionAlgorithms
            self.phase2IntegrityAlgorithms = phase2IntegrityAlgorithms
            self.phase2LifetimeSeconds = phase2LifetimeSeconds
            self.preSharedKey = preSharedKey
            self.rekeyFuzzPercentage = rekeyFuzzPercentage
            self.rekeyMarginTimeSeconds = rekeyMarginTimeSeconds
            self.replayWindowSize = replayWindowSize
            self.tunnelInsideCidr = tunnelInsideCidr
        }

        public func validate(name: String) throws {
            try self.ikeVersions?.forEach {
                try validate($0, name: "ikeVersions[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.outsideIpAddress, name: "outsideIpAddress", parent: name, pattern: "\\S")
            try self.phase1EncryptionAlgorithms?.forEach {
                try validate($0, name: "phase1EncryptionAlgorithms[]", parent: name, pattern: "\\S")
            }
            try self.phase1IntegrityAlgorithms?.forEach {
                try validate($0, name: "phase1IntegrityAlgorithms[]", parent: name, pattern: "\\S")
            }
            try self.phase2EncryptionAlgorithms?.forEach {
                try validate($0, name: "phase2EncryptionAlgorithms[]", parent: name, pattern: "\\S")
            }
            try self.phase2IntegrityAlgorithms?.forEach {
                try validate($0, name: "phase2IntegrityAlgorithms[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.preSharedKey, name: "preSharedKey", parent: name, pattern: "\\S")
            try self.validate(self.tunnelInsideCidr, name: "tunnelInsideCidr", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dpdTimeoutSeconds = "DpdTimeoutSeconds"
            case ikeVersions = "IkeVersions"
            case outsideIpAddress = "OutsideIpAddress"
            case phase1DhGroupNumbers = "Phase1DhGroupNumbers"
            case phase1EncryptionAlgorithms = "Phase1EncryptionAlgorithms"
            case phase1IntegrityAlgorithms = "Phase1IntegrityAlgorithms"
            case phase1LifetimeSeconds = "Phase1LifetimeSeconds"
            case phase2DhGroupNumbers = "Phase2DhGroupNumbers"
            case phase2EncryptionAlgorithms = "Phase2EncryptionAlgorithms"
            case phase2IntegrityAlgorithms = "Phase2IntegrityAlgorithms"
            case phase2LifetimeSeconds = "Phase2LifetimeSeconds"
            case preSharedKey = "PreSharedKey"
            case rekeyFuzzPercentage = "RekeyFuzzPercentage"
            case rekeyMarginTimeSeconds = "RekeyMarginTimeSeconds"
            case replayWindowSize = "ReplayWindowSize"
            case tunnelInsideCidr = "TunnelInsideCidr"
        }
    }

    public struct AwsEc2VpnConnectionRoutesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The CIDR block associated with the local subnet of the customer data center.
        public let destinationCidrBlock: String?
        /// The current state of the static route.
        public let state: String?

        @inlinable
        public init(destinationCidrBlock: String? = nil, state: String? = nil) {
            self.destinationCidrBlock = destinationCidrBlock
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationCidrBlock, name: "destinationCidrBlock", parent: name, pattern: "\\S")
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationCidrBlock = "DestinationCidrBlock"
            case state = "State"
        }
    }

    public struct AwsEc2VpnConnectionVgwTelemetryDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of accepted routes.
        public let acceptedRouteCount: Int?
        /// The ARN of the VPN tunnel endpoint certificate.
        public let certificateArn: String?
        /// The date and time of the last change in status. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastStatusChange: String?
        /// The Internet-routable IP address of the virtual private gateway's outside interface.
        public let outsideIpAddress: String?
        /// The status of the VPN tunnel. Valid values are DOWN or UP.
        public let status: String?
        /// If an error occurs, a description of the error.
        public let statusMessage: String?

        @inlinable
        public init(acceptedRouteCount: Int? = nil, certificateArn: String? = nil, lastStatusChange: String? = nil, outsideIpAddress: String? = nil, status: String? = nil, statusMessage: String? = nil) {
            self.acceptedRouteCount = acceptedRouteCount
            self.certificateArn = certificateArn
            self.lastStatusChange = lastStatusChange
            self.outsideIpAddress = outsideIpAddress
            self.status = status
            self.statusMessage = statusMessage
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, pattern: "\\S")
            try self.validate(self.lastStatusChange, name: "lastStatusChange", parent: name, pattern: "\\S")
            try self.validate(self.outsideIpAddress, name: "outsideIpAddress", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.statusMessage, name: "statusMessage", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptedRouteCount = "AcceptedRouteCount"
            case certificateArn = "CertificateArn"
            case lastStatusChange = "LastStatusChange"
            case outsideIpAddress = "OutsideIpAddress"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct AwsEcrContainerImageDetails: AWSEncodableShape & AWSDecodableShape {
        /// The architecture of the image. Valid values are as follows:    arm64     i386     x86_64
        public let architecture: String?
        /// The sha256 digest of the image manifest.
        public let imageDigest: String?
        /// The date and time when the image was pushed to the repository. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let imagePublishedAt: String?
        /// The list of tags that are associated with the image.
        public let imageTags: [String]?
        /// The Amazon Web Services account identifier that is associated with the registry that the image belongs to.
        public let registryId: String?
        /// The name of the repository that the image belongs to.
        public let repositoryName: String?

        @inlinable
        public init(architecture: String? = nil, imageDigest: String? = nil, imagePublishedAt: String? = nil, imageTags: [String]? = nil, registryId: String? = nil, repositoryName: String? = nil) {
            self.architecture = architecture
            self.imageDigest = imageDigest
            self.imagePublishedAt = imagePublishedAt
            self.imageTags = imageTags
            self.registryId = registryId
            self.repositoryName = repositoryName
        }

        public func validate(name: String) throws {
            try self.validate(self.architecture, name: "architecture", parent: name, pattern: "\\S")
            try self.validate(self.imageDigest, name: "imageDigest", parent: name, pattern: "\\S")
            try self.validate(self.imagePublishedAt, name: "imagePublishedAt", parent: name, pattern: "\\S")
            try self.imageTags?.forEach {
                try validate($0, name: "imageTags[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "\\S")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "Architecture"
            case imageDigest = "ImageDigest"
            case imagePublishedAt = "ImagePublishedAt"
            case imageTags = "ImageTags"
            case registryId = "RegistryId"
            case repositoryName = "RepositoryName"
        }
    }

    public struct AwsEcrRepositoryDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the repository.
        public let arn: String?
        /// The image scanning configuration for a repository.
        public let imageScanningConfiguration: AwsEcrRepositoryImageScanningConfigurationDetails?
        /// The tag mutability setting for the repository. Valid values are IMMUTABLE or MUTABLE.
        public let imageTagMutability: String?
        /// Information about the lifecycle policy for the repository.
        public let lifecyclePolicy: AwsEcrRepositoryLifecyclePolicyDetails?
        /// The name of the repository.
        public let repositoryName: String?
        /// The text of the repository policy.
        public let repositoryPolicyText: String?

        @inlinable
        public init(arn: String? = nil, imageScanningConfiguration: AwsEcrRepositoryImageScanningConfigurationDetails? = nil, imageTagMutability: String? = nil, lifecyclePolicy: AwsEcrRepositoryLifecyclePolicyDetails? = nil, repositoryName: String? = nil, repositoryPolicyText: String? = nil) {
            self.arn = arn
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTagMutability = imageTagMutability
            self.lifecyclePolicy = lifecyclePolicy
            self.repositoryName = repositoryName
            self.repositoryPolicyText = repositoryPolicyText
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.imageTagMutability, name: "imageTagMutability", parent: name, pattern: "\\S")
            try self.lifecyclePolicy?.validate(name: "\(name).lifecyclePolicy")
            try self.validate(self.repositoryName, name: "repositoryName", parent: name, pattern: "\\S")
            try self.validate(self.repositoryPolicyText, name: "repositoryPolicyText", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case imageScanningConfiguration = "ImageScanningConfiguration"
            case imageTagMutability = "ImageTagMutability"
            case lifecyclePolicy = "LifecyclePolicy"
            case repositoryName = "RepositoryName"
            case repositoryPolicyText = "RepositoryPolicyText"
        }
    }

    public struct AwsEcrRepositoryImageScanningConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to scan images after they are pushed to a repository.
        public let scanOnPush: Bool?

        @inlinable
        public init(scanOnPush: Bool? = nil) {
            self.scanOnPush = scanOnPush
        }

        private enum CodingKeys: String, CodingKey {
            case scanOnPush = "ScanOnPush"
        }
    }

    public struct AwsEcrRepositoryLifecyclePolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The text of the lifecycle policy.
        public let lifecyclePolicyText: String?
        /// The Amazon Web Services account identifier that is associated with the registry that contains the repository.
        public let registryId: String?

        @inlinable
        public init(lifecyclePolicyText: String? = nil, registryId: String? = nil) {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
        }

        public func validate(name: String) throws {
            try self.validate(self.lifecyclePolicyText, name: "lifecyclePolicyText", parent: name, pattern: "\\S")
            try self.validate(self.registryId, name: "registryId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyText = "LifecyclePolicyText"
            case registryId = "RegistryId"
        }
    }

    public struct AwsEcsClusterClusterSettingsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the setting. The valid value is containerInsights.
        public let name: String?
        /// The value of the setting. Valid values are disabled or enabled.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsEcsClusterConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Contains the run command configuration for the cluster.
        public let executeCommandConfiguration: AwsEcsClusterConfigurationExecuteCommandConfigurationDetails?

        @inlinable
        public init(executeCommandConfiguration: AwsEcsClusterConfigurationExecuteCommandConfigurationDetails? = nil) {
            self.executeCommandConfiguration = executeCommandConfiguration
        }

        public func validate(name: String) throws {
            try self.executeCommandConfiguration?.validate(name: "\(name).executeCommandConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case executeCommandConfiguration = "ExecuteCommandConfiguration"
        }
    }

    public struct AwsEcsClusterConfigurationExecuteCommandConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the KMS key that is used to encrypt the data between the local client and the container.
        public let kmsKeyId: String?
        /// The log configuration for the results of the run command actions. Required if Logging is NONE.
        public let logConfiguration: AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails?
        /// The log setting to use for redirecting logs for run command results.
        public let logging: String?

        @inlinable
        public init(kmsKeyId: String? = nil, logConfiguration: AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails? = nil, logging: String? = nil) {
            self.kmsKeyId = kmsKeyId
            self.logConfiguration = logConfiguration
            self.logging = logging
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.logConfiguration?.validate(name: "\(name).logConfiguration")
            try self.validate(self.logging, name: "logging", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case logConfiguration = "LogConfiguration"
            case logging = "Logging"
        }
    }

    public struct AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to enable encryption on the CloudWatch logs.
        public let cloudWatchEncryptionEnabled: Bool?
        /// The name of the CloudWatch log group to send the logs to.
        public let cloudWatchLogGroupName: String?
        /// The name of the S3 bucket to send logs to.
        public let s3BucketName: String?
        /// Whether to encrypt the logs that are sent to the S3 bucket.
        public let s3EncryptionEnabled: Bool?
        /// Identifies the folder in the S3 bucket to send the logs to.
        public let s3KeyPrefix: String?

        @inlinable
        public init(cloudWatchEncryptionEnabled: Bool? = nil, cloudWatchLogGroupName: String? = nil, s3BucketName: String? = nil, s3EncryptionEnabled: Bool? = nil, s3KeyPrefix: String? = nil) {
            self.cloudWatchEncryptionEnabled = cloudWatchEncryptionEnabled
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.s3BucketName = s3BucketName
            self.s3EncryptionEnabled = s3EncryptionEnabled
            self.s3KeyPrefix = s3KeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogGroupName, name: "cloudWatchLogGroupName", parent: name, pattern: "\\S")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "\\S")
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchEncryptionEnabled = "CloudWatchEncryptionEnabled"
            case cloudWatchLogGroupName = "CloudWatchLogGroupName"
            case s3BucketName = "S3BucketName"
            case s3EncryptionEnabled = "S3EncryptionEnabled"
            case s3KeyPrefix = "S3KeyPrefix"
        }
    }

    public struct AwsEcsClusterDefaultCapacityProviderStrategyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The minimum number of tasks to run on the specified capacity provider.
        public let base: Int?
        /// The name of the capacity provider.
        public let capacityProvider: String?
        /// The relative percentage of the total number of tasks launched that should use the capacity provider.
        public let weight: Int?

        @inlinable
        public init(base: Int? = nil, capacityProvider: String? = nil, weight: Int? = nil) {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityProvider, name: "capacityProvider", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case base = "Base"
            case capacityProvider = "CapacityProvider"
            case weight = "Weight"
        }
    }

    public struct AwsEcsClusterDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of services that are running on the cluster in an ACTIVE state. You can view these services with the Amazon ECS  ListServices API operation.
        public let activeServicesCount: Int?
        /// The short name of one or more capacity providers to associate with the cluster.
        public let capacityProviders: [String]?
        /// The Amazon Resource Name (ARN) that identifies the cluster.
        public let clusterArn: String?
        /// A name that you use to identify your cluster.
        public let clusterName: String?
        /// The setting to use to create the cluster. Specifically used to configure whether to enable CloudWatch Container Insights for the cluster.
        public let clusterSettings: [AwsEcsClusterClusterSettingsDetails]?
        /// The run command configuration for the cluster.
        public let configuration: AwsEcsClusterConfigurationDetails?
        /// The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.
        public let defaultCapacityProviderStrategy: [AwsEcsClusterDefaultCapacityProviderStrategyDetails]?
        /// The number of container instances registered into the cluster. This includes container instances in both ACTIVE and DRAINING status.
        public let registeredContainerInstancesCount: Int?
        /// The number of tasks in the cluster that are in the RUNNING state.
        public let runningTasksCount: Int?
        /// The status of the cluster.
        public let status: String?

        @inlinable
        public init(activeServicesCount: Int? = nil, capacityProviders: [String]? = nil, clusterArn: String? = nil, clusterName: String? = nil, clusterSettings: [AwsEcsClusterClusterSettingsDetails]? = nil, configuration: AwsEcsClusterConfigurationDetails? = nil, defaultCapacityProviderStrategy: [AwsEcsClusterDefaultCapacityProviderStrategyDetails]? = nil, registeredContainerInstancesCount: Int? = nil, runningTasksCount: Int? = nil, status: String? = nil) {
            self.activeServicesCount = activeServicesCount
            self.capacityProviders = capacityProviders
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterSettings = clusterSettings
            self.configuration = configuration
            self.defaultCapacityProviderStrategy = defaultCapacityProviderStrategy
            self.registeredContainerInstancesCount = registeredContainerInstancesCount
            self.runningTasksCount = runningTasksCount
            self.status = status
        }

        public func validate(name: String) throws {
            try self.capacityProviders?.forEach {
                try validate($0, name: "capacityProviders[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.clusterArn, name: "clusterArn", parent: name, pattern: "\\S")
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "\\S")
            try self.clusterSettings?.forEach {
                try $0.validate(name: "\(name).clusterSettings[]")
            }
            try self.configuration?.validate(name: "\(name).configuration")
            try self.defaultCapacityProviderStrategy?.forEach {
                try $0.validate(name: "\(name).defaultCapacityProviderStrategy[]")
            }
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case activeServicesCount = "ActiveServicesCount"
            case capacityProviders = "CapacityProviders"
            case clusterArn = "ClusterArn"
            case clusterName = "ClusterName"
            case clusterSettings = "ClusterSettings"
            case configuration = "Configuration"
            case defaultCapacityProviderStrategy = "DefaultCapacityProviderStrategy"
            case registeredContainerInstancesCount = "RegisteredContainerInstancesCount"
            case runningTasksCount = "RunningTasksCount"
            case status = "Status"
        }
    }

    public struct AwsEcsContainerDetails: AWSEncodableShape & AWSDecodableShape {
        /// The image used for the container.
        public let image: String?
        /// The mount points for data volumes in your container.
        public let mountPoints: [AwsMountPoint]?
        /// The name of the container.
        public let name: String?
        /// When this parameter is true, the container is given elevated privileges on the host container instance
        /// (similar to the root user).
        public let privileged: Bool?

        @inlinable
        public init(image: String? = nil, mountPoints: [AwsMountPoint]? = nil, name: String? = nil, privileged: Bool? = nil) {
            self.image = image
            self.mountPoints = mountPoints
            self.name = name
            self.privileged = privileged
        }

        public func validate(name: String) throws {
            try self.validate(self.image, name: "image", parent: name, pattern: "\\S")
            try self.mountPoints?.forEach {
                try $0.validate(name: "\(name).mountPoints[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case image = "Image"
            case mountPoints = "MountPoints"
            case name = "Name"
            case privileged = "Privileged"
        }
    }

    public struct AwsEcsServiceCapacityProviderStrategyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The minimum number of tasks to run on the capacity provider. Only one strategy item can specify a value for Base. The value must be between 0 and 100000.
        public let base: Int?
        /// The short name of the capacity provider.
        public let capacityProvider: String?
        /// The relative percentage of the total number of tasks that should use the capacity provider. If no weight is specified, the default value is 0. At least one capacity provider must have a weight greater than 0. The value can be between 0 and 1000.
        public let weight: Int?

        @inlinable
        public init(base: Int? = nil, capacityProvider: String? = nil, weight: Int? = nil) {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityProvider, name: "capacityProvider", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case base = "Base"
            case capacityProvider = "CapacityProvider"
            case weight = "Weight"
        }
    }

    public struct AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to enable the deployment circuit breaker logic for the service.
        public let enable: Bool?
        /// Whether to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
        public let rollback: Bool?

        @inlinable
        public init(enable: Bool? = nil, rollback: Bool? = nil) {
            self.enable = enable
            self.rollback = rollback
        }

        private enum CodingKeys: String, CodingKey {
            case enable = "Enable"
            case rollback = "Rollback"
        }
    }

    public struct AwsEcsServiceDeploymentConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Determines whether a service deployment fails if a service cannot reach a steady state.
        public let deploymentCircuitBreaker: AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails?
        /// For a service that uses the rolling update (ECS) deployment type, the maximum number of tasks in a service that are allowed in the RUNNING or PENDING state during a deployment, and for tasks that use the EC2 launch type, when any container instances are in the DRAINING state. Provided as a percentage of the desired number of tasks. The default value is 200%. For a service that uses the blue/green (CODE_DEPLOY) or EXTERNAL deployment types, and tasks that use the EC2 launch type, the maximum number of tasks in the service that remain in the RUNNING state while the container instances are in the DRAINING state. For the Fargate launch type, the maximum percent value is not used.
        public let maximumPercent: Int?
        /// For a service that uses the rolling update (ECS) deployment type, the minimum number of tasks in a service that must remain in the RUNNING state during a deployment, and while any container instances are in the DRAINING state if the service contains tasks using the EC2 launch type. Expressed as a percentage of the desired number of tasks. The default value is 100%. For a service that uses the blue/green (CODE_DEPLOY) or EXTERNAL deployment types and tasks that use the EC2 launch type, the minimum number of the tasks in the service that remain in the RUNNING state while the container instances are in the DRAINING state. For the Fargate launch type, the minimum healthy percent value is not used.
        public let minimumHealthyPercent: Int?

        @inlinable
        public init(deploymentCircuitBreaker: AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails? = nil, maximumPercent: Int? = nil, minimumHealthyPercent: Int? = nil) {
            self.deploymentCircuitBreaker = deploymentCircuitBreaker
            self.maximumPercent = maximumPercent
            self.minimumHealthyPercent = minimumHealthyPercent
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentCircuitBreaker = "DeploymentCircuitBreaker"
            case maximumPercent = "MaximumPercent"
            case minimumHealthyPercent = "MinimumHealthyPercent"
        }
    }

    public struct AwsEcsServiceDeploymentControllerDetails: AWSEncodableShape & AWSDecodableShape {
        /// The rolling update (ECS) deployment type replaces the current running version of the container with the latest version. The blue/green (CODE_DEPLOY) deployment type uses the blue/green deployment model that is powered by CodeDeploy. This deployment model a new deployment of a service can be verified before production traffic is sent to it. The external (EXTERNAL) deployment type allows the use of any third-party deployment controller for full control over the deployment process for an Amazon ECS service. Valid values: ECS | CODE_DEPLOY | EXTERNAL
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsEcsServiceDetails: AWSEncodableShape & AWSDecodableShape {
        /// The capacity provider strategy that the service uses.
        public let capacityProviderStrategy: [AwsEcsServiceCapacityProviderStrategyDetails]?
        /// The ARN of the cluster that hosts the service.
        public let cluster: String?
        /// Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.
        public let deploymentConfiguration: AwsEcsServiceDeploymentConfigurationDetails?
        /// Contains the deployment controller type that the service uses.
        public let deploymentController: AwsEcsServiceDeploymentControllerDetails?
        /// The number of instantiations of the task definition to run on the service.
        public let desiredCount: Int?
        /// Whether to enable Amazon ECS managed tags for the tasks in the service.
        public let enableEcsManagedTags: Bool?
        /// Whether the execute command functionality is enabled for the service.
        public let enableExecuteCommand: Bool?
        /// After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.
        public let healthCheckGracePeriodSeconds: Int?
        /// The launch type that the service uses. Valid values: EC2 | FARGATE | EXTERNAL
        public let launchType: String?
        /// Information about the load balancers that the service uses.
        public let loadBalancers: [AwsEcsServiceLoadBalancersDetails]?
        /// The name of the service.
        public let name: String?
        /// For tasks that use the awsvpc networking mode, the VPC subnet and security group configuration.
        public let networkConfiguration: AwsEcsServiceNetworkConfigurationDetails?
        /// The placement constraints for the tasks in the service.
        public let placementConstraints: [AwsEcsServicePlacementConstraintsDetails]?
        /// Information about how tasks for the service are placed.
        public let placementStrategies: [AwsEcsServicePlacementStrategiesDetails]?
        /// The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the LATEST platform version is used by default.
        public let platformVersion: String?
        /// Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated. Valid values: TASK_DEFINITION | SERVICE
        public let propagateTags: String?
        /// The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.
        public let role: String?
        /// The scheduling strategy to use for the service. The REPLICA scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions. The DAEMON scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that don't meet the placement constraints. Valid values: REPLICA | DAEMON
        public let schedulingStrategy: String?
        /// The ARN of the service.
        public let serviceArn: String?
        /// The name of the service. The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.
        public let serviceName: String?
        /// Information about the service discovery registries to assign to the service.
        public let serviceRegistries: [AwsEcsServiceServiceRegistriesDetails]?
        /// The task definition to use for tasks in the service.
        public let taskDefinition: String?

        @inlinable
        public init(capacityProviderStrategy: [AwsEcsServiceCapacityProviderStrategyDetails]? = nil, cluster: String? = nil, deploymentConfiguration: AwsEcsServiceDeploymentConfigurationDetails? = nil, deploymentController: AwsEcsServiceDeploymentControllerDetails? = nil, desiredCount: Int? = nil, enableEcsManagedTags: Bool? = nil, enableExecuteCommand: Bool? = nil, healthCheckGracePeriodSeconds: Int? = nil, launchType: String? = nil, loadBalancers: [AwsEcsServiceLoadBalancersDetails]? = nil, name: String? = nil, networkConfiguration: AwsEcsServiceNetworkConfigurationDetails? = nil, placementConstraints: [AwsEcsServicePlacementConstraintsDetails]? = nil, placementStrategies: [AwsEcsServicePlacementStrategiesDetails]? = nil, platformVersion: String? = nil, propagateTags: String? = nil, role: String? = nil, schedulingStrategy: String? = nil, serviceArn: String? = nil, serviceName: String? = nil, serviceRegistries: [AwsEcsServiceServiceRegistriesDetails]? = nil, taskDefinition: String? = nil) {
            self.capacityProviderStrategy = capacityProviderStrategy
            self.cluster = cluster
            self.deploymentConfiguration = deploymentConfiguration
            self.deploymentController = deploymentController
            self.desiredCount = desiredCount
            self.enableEcsManagedTags = enableEcsManagedTags
            self.enableExecuteCommand = enableExecuteCommand
            self.healthCheckGracePeriodSeconds = healthCheckGracePeriodSeconds
            self.launchType = launchType
            self.loadBalancers = loadBalancers
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.placementConstraints = placementConstraints
            self.placementStrategies = placementStrategies
            self.platformVersion = platformVersion
            self.propagateTags = propagateTags
            self.role = role
            self.schedulingStrategy = schedulingStrategy
            self.serviceArn = serviceArn
            self.serviceName = serviceName
            self.serviceRegistries = serviceRegistries
            self.taskDefinition = taskDefinition
        }

        public func validate(name: String) throws {
            try self.capacityProviderStrategy?.forEach {
                try $0.validate(name: "\(name).capacityProviderStrategy[]")
            }
            try self.validate(self.cluster, name: "cluster", parent: name, pattern: "\\S")
            try self.deploymentController?.validate(name: "\(name).deploymentController")
            try self.validate(self.launchType, name: "launchType", parent: name, pattern: "\\S")
            try self.loadBalancers?.forEach {
                try $0.validate(name: "\(name).loadBalancers[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.networkConfiguration?.validate(name: "\(name).networkConfiguration")
            try self.placementConstraints?.forEach {
                try $0.validate(name: "\(name).placementConstraints[]")
            }
            try self.placementStrategies?.forEach {
                try $0.validate(name: "\(name).placementStrategies[]")
            }
            try self.validate(self.platformVersion, name: "platformVersion", parent: name, pattern: "\\S")
            try self.validate(self.propagateTags, name: "propagateTags", parent: name, pattern: "\\S")
            try self.validate(self.role, name: "role", parent: name, pattern: "\\S")
            try self.validate(self.schedulingStrategy, name: "schedulingStrategy", parent: name, pattern: "\\S")
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "\\S")
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "\\S")
            try self.serviceRegistries?.forEach {
                try $0.validate(name: "\(name).serviceRegistries[]")
            }
            try self.validate(self.taskDefinition, name: "taskDefinition", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityProviderStrategy = "CapacityProviderStrategy"
            case cluster = "Cluster"
            case deploymentConfiguration = "DeploymentConfiguration"
            case deploymentController = "DeploymentController"
            case desiredCount = "DesiredCount"
            case enableEcsManagedTags = "EnableEcsManagedTags"
            case enableExecuteCommand = "EnableExecuteCommand"
            case healthCheckGracePeriodSeconds = "HealthCheckGracePeriodSeconds"
            case launchType = "LaunchType"
            case loadBalancers = "LoadBalancers"
            case name = "Name"
            case networkConfiguration = "NetworkConfiguration"
            case placementConstraints = "PlacementConstraints"
            case placementStrategies = "PlacementStrategies"
            case platformVersion = "PlatformVersion"
            case propagateTags = "PropagateTags"
            case role = "Role"
            case schedulingStrategy = "SchedulingStrategy"
            case serviceArn = "ServiceArn"
            case serviceName = "ServiceName"
            case serviceRegistries = "ServiceRegistries"
            case taskDefinition = "TaskDefinition"
        }
    }

    public struct AwsEcsServiceLoadBalancersDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the container to associate with the load balancer.
        public let containerName: String?
        /// The port on the container to associate with the load balancer. This port must correspond to a containerPort in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the hostPort of the port mapping.
        public let containerPort: Int?
        /// The name of the load balancer to associate with the Amazon ECS service or task set. Only specified when using a Classic Load Balancer. For an Application Load Balancer or a Network Load Balancer, the load balancer name is omitted.
        public let loadBalancerName: String?
        /// The ARN of the Elastic Load Balancing target group or groups associated with a service or task set. Only specified when using an Application Load Balancer or a Network Load Balancer. For a Classic Load Balancer, the target group ARN is omitted.
        public let targetGroupArn: String?

        @inlinable
        public init(containerName: String? = nil, containerPort: Int? = nil, loadBalancerName: String? = nil, targetGroupArn: String? = nil) {
            self.containerName = containerName
            self.containerPort = containerPort
            self.loadBalancerName = loadBalancerName
            self.targetGroupArn = targetGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.containerName, name: "containerName", parent: name, pattern: "\\S")
            try self.validate(self.loadBalancerName, name: "loadBalancerName", parent: name, pattern: "\\S")
            try self.validate(self.targetGroupArn, name: "targetGroupArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
            case containerPort = "ContainerPort"
            case loadBalancerName = "LoadBalancerName"
            case targetGroupArn = "TargetGroupArn"
        }
    }

    public struct AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the task's elastic network interface receives a public IP address. The default value is DISABLED. Valid values: ENABLED | DISABLED
        public let assignPublicIp: String?
        /// The IDs of the security groups associated with the task or service. You can provide up to five security groups.
        public let securityGroups: [String]?
        /// The IDs of the subnets associated with the task or service. You can provide up to 16 subnets.
        public let subnets: [String]?

        @inlinable
        public init(assignPublicIp: String? = nil, securityGroups: [String]? = nil, subnets: [String]? = nil) {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }

        public func validate(name: String) throws {
            try self.validate(self.assignPublicIp, name: "assignPublicIp", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.subnets?.forEach {
                try validate($0, name: "subnets[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assignPublicIp = "AssignPublicIp"
            case securityGroups = "SecurityGroups"
            case subnets = "Subnets"
        }
    }

    public struct AwsEcsServiceNetworkConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The VPC subnet and security group configuration.
        public let awsVpcConfiguration: AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails?

        @inlinable
        public init(awsVpcConfiguration: AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails? = nil) {
            self.awsVpcConfiguration = awsVpcConfiguration
        }

        public func validate(name: String) throws {
            try self.awsVpcConfiguration?.validate(name: "\(name).awsVpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case awsVpcConfiguration = "AwsVpcConfiguration"
        }
    }

    public struct AwsEcsServicePlacementConstraintsDetails: AWSEncodableShape & AWSDecodableShape {
        /// A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance.
        public let expression: String?
        /// The type of constraint. Use distinctInstance to run each task in a particular group on a different container instance. Use memberOf to restrict the selection to a group of valid candidates. Valid values: distinctInstance | memberOf
        public let type: String?

        @inlinable
        public init(expression: String? = nil, type: String? = nil) {
            self.expression = expression
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case type = "Type"
        }
    }

    public struct AwsEcsServicePlacementStrategiesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this attribute is not used.
        public let field: String?
        /// The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the value of Field. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified in Field. Valid values: random | spread | binpack
        public let type: String?

        @inlinable
        public init(field: String? = nil, type: String? = nil) {
            self.field = field
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.field, name: "field", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case field = "Field"
            case type = "Type"
        }
    }

    public struct AwsEcsServiceServiceRegistriesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The container name value to use for the service discovery service. If the task definition uses the bridge or host network mode, you must specify ContainerName and ContainerPort. If the task definition uses the awsvpc network mode and a type SRV DNS record, you must specify either ContainerName and ContainerPort, or Port , but not both.
        public let containerName: String?
        /// The port value to use for the service discovery service. If the task definition uses the bridge or host network mode, you must specify ContainerName and ContainerPort. If the task definition uses the awsvpc network mode and a type SRV DNS record, you must specify either ContainerName and ContainerPort, or Port , but not both.
        public let containerPort: Int?
        /// The port value to use for a service discovery service that specifies an SRV record. This field can be used if both the awsvpcawsvpc network mode and SRV records are used.
        public let port: Int?
        /// The ARN of the service registry.
        public let registryArn: String?

        @inlinable
        public init(containerName: String? = nil, containerPort: Int? = nil, port: Int? = nil, registryArn: String? = nil) {
            self.containerName = containerName
            self.containerPort = containerPort
            self.port = port
            self.registryArn = registryArn
        }

        public func validate(name: String) throws {
            try self.validate(self.containerName, name: "containerName", parent: name, pattern: "\\S")
            try self.validate(self.registryArn, name: "registryArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
            case containerPort = "ContainerPort"
            case port = "Port"
            case registryArn = "RegistryArn"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails: AWSEncodableShape & AWSDecodableShape {
        /// The dependency condition of the dependent container. Indicates the required status of the dependent container before the current container can start. Valid values are as follows:    COMPLETE     HEALTHY     SUCCESS     START
        public let condition: String?
        /// The name of the dependent container.
        public let containerName: String?

        @inlinable
        public init(condition: String? = nil, containerName: String? = nil) {
            self.condition = condition
            self.containerName = containerName
        }

        public func validate(name: String) throws {
            try self.validate(self.condition, name: "condition", parent: name, pattern: "\\S")
            try self.validate(self.containerName, name: "containerName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case containerName = "ContainerName"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The command that is passed to the container.
        public let command: [String]?
        /// The number of CPU units reserved for the container.
        public let cpu: Int?
        /// The dependencies that are defined for container startup and shutdown.
        public let dependsOn: [AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails]?
        /// Whether to disable networking within the container.
        public let disableNetworking: Bool?
        /// A list of DNS search domains that are presented to the container.
        public let dnsSearchDomains: [String]?
        /// A list of DNS servers that are presented to the container.
        public let dnsServers: [String]?
        /// A key-value map of labels to add to the container.
        public let dockerLabels: [String: String]?
        /// A list of strings to provide custom labels for SELinux and AppArmor multi-level security systems.
        public let dockerSecurityOptions: [String]?
        /// The entry point that is passed to the container.
        public let entryPoint: [String]?
        /// The environment variables to pass to a container.
        public let environment: [AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails]?
        /// A list of files containing the environment variables to pass to a container.
        public let environmentFiles: [AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails]?
        /// Whether the container is essential. All tasks must have at least one essential container.
        public let essential: Bool?
        /// A list of hostnames and IP address mappings to append to the /etc/hosts file on the container.
        public let extraHosts: [AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails]?
        /// The FireLens configuration for the container. Specifies and configures a log router for container logs.
        public let firelensConfiguration: AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails?
        /// The container health check command and associated configuration parameters for the container.
        public let healthCheck: AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails?
        /// The hostname to use for the container.
        public let hostname: String?
        /// The image used to start the container.
        public let image: String?
        /// If set to true, then containerized applications can be deployed that require stdin or a tty to be allocated.
        public let interactive: Bool?
        /// A list of links for the container in the form  container_name:alias . Allows containers to communicate with each other without the need for port mappings.
        public let links: [String]?
        /// Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.
        public let linuxParameters: AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails?
        /// The log configuration specification for the container.
        public let logConfiguration: AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails?
        /// The amount (in MiB) of memory to present to the container. If the container attempts to exceed the memory specified here, the container is shut down. The total amount of memory reserved for all containers within a task must be lower than the task memory value, if one is specified.
        public let memory: Int?
        /// The soft limit (in MiB) of memory to reserve for the container.
        public let memoryReservation: Int?
        /// The mount points for the data volumes in the container.
        public let mountPoints: [AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails]?
        /// The name of the container.
        public let name: String?
        /// The list of port mappings for the container.
        public let portMappings: [AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails]?
        /// Whether the container is given elevated privileges on the host container instance. The elevated privileges are similar to the root user.
        public let privileged: Bool?
        /// Whether to allocate a TTY to the container.
        public let pseudoTerminal: Bool?
        /// Whether the container is given read-only access to its root file system.
        public let readonlyRootFilesystem: Bool?
        /// The private repository authentication credentials to use.
        public let repositoryCredentials: AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails?
        /// The type and amount of a resource to assign to a container. The only supported resource is a GPU.
        public let resourceRequirements: [AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails]?
        /// The secrets to pass to the container.
        public let secrets: [AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]?
        /// The number of seconds to wait before giving up on resolving dependencies for a container.
        public let startTimeout: Int?
        /// The number of seconds to wait before the container is stopped if it doesn't shut down normally on its own.
        public let stopTimeout: Int?
        /// A list of namespaced kernel parameters to set in the container.
        public let systemControls: [AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails]?
        /// A list of ulimits to set in the container.
        public let ulimits: [AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]?
        /// The user to use inside the container. The value can use one of the following formats.     user       user : group       uid       uid : gid       user : gid       uid : group
        public let user: String?
        /// Data volumes to mount from another container.
        public let volumesFrom: [AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails]?
        /// The working directory in which to run commands inside the container.
        public let workingDirectory: String?

        @inlinable
        public init(command: [String]? = nil, cpu: Int? = nil, dependsOn: [AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails]? = nil, disableNetworking: Bool? = nil, dnsSearchDomains: [String]? = nil, dnsServers: [String]? = nil, dockerLabels: [String: String]? = nil, dockerSecurityOptions: [String]? = nil, entryPoint: [String]? = nil, environment: [AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails]? = nil, environmentFiles: [AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails]? = nil, essential: Bool? = nil, extraHosts: [AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails]? = nil, firelensConfiguration: AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails? = nil, healthCheck: AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails? = nil, hostname: String? = nil, image: String? = nil, interactive: Bool? = nil, links: [String]? = nil, linuxParameters: AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails? = nil, logConfiguration: AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails? = nil, memory: Int? = nil, memoryReservation: Int? = nil, mountPoints: [AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails]? = nil, name: String? = nil, portMappings: [AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails]? = nil, privileged: Bool? = nil, pseudoTerminal: Bool? = nil, readonlyRootFilesystem: Bool? = nil, repositoryCredentials: AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails? = nil, resourceRequirements: [AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails]? = nil, secrets: [AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]? = nil, startTimeout: Int? = nil, stopTimeout: Int? = nil, systemControls: [AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails]? = nil, ulimits: [AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]? = nil, user: String? = nil, volumesFrom: [AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails]? = nil, workingDirectory: String? = nil) {
            self.command = command
            self.cpu = cpu
            self.dependsOn = dependsOn
            self.disableNetworking = disableNetworking
            self.dnsSearchDomains = dnsSearchDomains
            self.dnsServers = dnsServers
            self.dockerLabels = dockerLabels
            self.dockerSecurityOptions = dockerSecurityOptions
            self.entryPoint = entryPoint
            self.environment = environment
            self.environmentFiles = environmentFiles
            self.essential = essential
            self.extraHosts = extraHosts
            self.firelensConfiguration = firelensConfiguration
            self.healthCheck = healthCheck
            self.hostname = hostname
            self.image = image
            self.interactive = interactive
            self.links = links
            self.linuxParameters = linuxParameters
            self.logConfiguration = logConfiguration
            self.memory = memory
            self.memoryReservation = memoryReservation
            self.mountPoints = mountPoints
            self.name = name
            self.portMappings = portMappings
            self.privileged = privileged
            self.pseudoTerminal = pseudoTerminal
            self.readonlyRootFilesystem = readonlyRootFilesystem
            self.repositoryCredentials = repositoryCredentials
            self.resourceRequirements = resourceRequirements
            self.secrets = secrets
            self.startTimeout = startTimeout
            self.stopTimeout = stopTimeout
            self.systemControls = systemControls
            self.ulimits = ulimits
            self.user = user
            self.volumesFrom = volumesFrom
            self.workingDirectory = workingDirectory
        }

        public func validate(name: String) throws {
            try self.command?.forEach {
                try validate($0, name: "command[]", parent: name, pattern: "\\S")
            }
            try self.dependsOn?.forEach {
                try $0.validate(name: "\(name).dependsOn[]")
            }
            try self.dnsSearchDomains?.forEach {
                try validate($0, name: "dnsSearchDomains[]", parent: name, pattern: "\\S")
            }
            try self.dnsServers?.forEach {
                try validate($0, name: "dnsServers[]", parent: name, pattern: "\\S")
            }
            try self.dockerLabels?.forEach {
                try validate($0.key, name: "dockerLabels.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "dockerLabels[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.dockerSecurityOptions?.forEach {
                try validate($0, name: "dockerSecurityOptions[]", parent: name, pattern: "\\S")
            }
            try self.entryPoint?.forEach {
                try validate($0, name: "entryPoint[]", parent: name, pattern: "\\S")
            }
            try self.environment?.forEach {
                try $0.validate(name: "\(name).environment[]")
            }
            try self.environmentFiles?.forEach {
                try $0.validate(name: "\(name).environmentFiles[]")
            }
            try self.extraHosts?.forEach {
                try $0.validate(name: "\(name).extraHosts[]")
            }
            try self.firelensConfiguration?.validate(name: "\(name).firelensConfiguration")
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.validate(self.hostname, name: "hostname", parent: name, pattern: "\\S")
            try self.validate(self.image, name: "image", parent: name, pattern: "\\S")
            try self.links?.forEach {
                try validate($0, name: "links[]", parent: name, pattern: "\\S")
            }
            try self.linuxParameters?.validate(name: "\(name).linuxParameters")
            try self.logConfiguration?.validate(name: "\(name).logConfiguration")
            try self.mountPoints?.forEach {
                try $0.validate(name: "\(name).mountPoints[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.portMappings?.forEach {
                try $0.validate(name: "\(name).portMappings[]")
            }
            try self.repositoryCredentials?.validate(name: "\(name).repositoryCredentials")
            try self.resourceRequirements?.forEach {
                try $0.validate(name: "\(name).resourceRequirements[]")
            }
            try self.secrets?.forEach {
                try $0.validate(name: "\(name).secrets[]")
            }
            try self.systemControls?.forEach {
                try $0.validate(name: "\(name).systemControls[]")
            }
            try self.ulimits?.forEach {
                try $0.validate(name: "\(name).ulimits[]")
            }
            try self.validate(self.user, name: "user", parent: name, pattern: "\\S")
            try self.volumesFrom?.forEach {
                try $0.validate(name: "\(name).volumesFrom[]")
            }
            try self.validate(self.workingDirectory, name: "workingDirectory", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case cpu = "Cpu"
            case dependsOn = "DependsOn"
            case disableNetworking = "DisableNetworking"
            case dnsSearchDomains = "DnsSearchDomains"
            case dnsServers = "DnsServers"
            case dockerLabels = "DockerLabels"
            case dockerSecurityOptions = "DockerSecurityOptions"
            case entryPoint = "EntryPoint"
            case environment = "Environment"
            case environmentFiles = "EnvironmentFiles"
            case essential = "Essential"
            case extraHosts = "ExtraHosts"
            case firelensConfiguration = "FirelensConfiguration"
            case healthCheck = "HealthCheck"
            case hostname = "Hostname"
            case image = "Image"
            case interactive = "Interactive"
            case links = "Links"
            case linuxParameters = "LinuxParameters"
            case logConfiguration = "LogConfiguration"
            case memory = "Memory"
            case memoryReservation = "MemoryReservation"
            case mountPoints = "MountPoints"
            case name = "Name"
            case portMappings = "PortMappings"
            case privileged = "Privileged"
            case pseudoTerminal = "PseudoTerminal"
            case readonlyRootFilesystem = "ReadonlyRootFilesystem"
            case repositoryCredentials = "RepositoryCredentials"
            case resourceRequirements = "ResourceRequirements"
            case secrets = "Secrets"
            case startTimeout = "StartTimeout"
            case stopTimeout = "StopTimeout"
            case systemControls = "SystemControls"
            case ulimits = "Ulimits"
            case user = "User"
            case volumesFrom = "VolumesFrom"
            case workingDirectory = "WorkingDirectory"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the environment variable.
        public let name: String?
        /// The value of the environment variable.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The type of environment file. The valid value is s3.
        public let type: String?
        /// The ARN of the S3 object that contains the environment variable file.
        public let value: String?

        @inlinable
        public init(type: String? = nil, value: String? = nil) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The hostname to use in the /etc/hosts entry.
        public let hostname: String?
        /// The IP address to use in the /etc/hosts entry.
        public let ipAddress: String?

        @inlinable
        public init(hostname: String? = nil, ipAddress: String? = nil) {
            self.hostname = hostname
            self.ipAddress = ipAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.hostname, name: "hostname", parent: name, pattern: "\\S")
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "Hostname"
            case ipAddress = "IpAddress"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The options to use to configure the log router. The valid option keys are as follows:    enable-ecs-log-metadata. The value can be true or false.    config-file-type. The value can be s3 or file.    config-file-value. The value is either an S3 ARN or a file path.
        public let options: [String: String]?
        /// The log router to use. Valid values are fluentbit or fluentd.
        public let type: String?

        @inlinable
        public init(options: [String: String]? = nil, type: String? = nil) {
            self.options = options
            self.type = type
        }

        public func validate(name: String) throws {
            try self.options?.forEach {
                try validate($0.key, name: "options.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "options[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case type = "Type"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails: AWSEncodableShape & AWSDecodableShape {
        /// The command that the container runs to determine whether it is healthy.
        public let command: [String]?
        /// The time period in seconds between each health check execution. The default value is 30 seconds.
        public let interval: Int?
        /// The number of times to retry a failed health check before the container is considered unhealthy. The default value is 3.
        public let retries: Int?
        /// The optional grace period in seconds that allows containers time to bootstrap before failed health checks count towards the maximum number of retries.
        public let startPeriod: Int?
        /// The time period in seconds to wait for a health check to succeed before it is considered a failure. The default value is 5.
        public let timeout: Int?

        @inlinable
        public init(command: [String]? = nil, interval: Int? = nil, retries: Int? = nil, startPeriod: Int? = nil, timeout: Int? = nil) {
            self.command = command
            self.interval = interval
            self.retries = retries
            self.startPeriod = startPeriod
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.command?.forEach {
                try validate($0, name: "command[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case command = "Command"
            case interval = "Interval"
            case retries = "Retries"
            case startPeriod = "StartPeriod"
            case timeout = "Timeout"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Linux capabilities for the container that are added to the default configuration provided by Docker. Valid values are as follows: Valid values: "ALL" | "AUDIT_CONTROL" | "AUDIT_WRITE" | 		"BLOCK_SUSPEND" | "CHOWN" | "DAC_OVERRIDE" | 		"DAC_READ_SEARCH" | "FOWNER" | "FSETID" | 		"IPC_LOCK" | "IPC_OWNER" | "KILL" | 		"LEASE" | "LINUX_IMMUTABLE" | "MAC_ADMIN" | 			"MAC_OVERRIDE" | "MKNOD" | "NET_ADMIN" | 		"NET_BIND_SERVICE" | "NET_BROADCAST" | "NET_RAW" | 		"SETFCAP" | "SETGID" | "SETPCAP" | 		"SETUID" | "SYS_ADMIN" | "SYS_BOOT" | 		"SYS_CHROOT" | "SYS_MODULE" | "SYS_NICE" | 		"SYS_PACCT" | "SYS_PTRACE" | "SYS_RAWIO" | 		"SYS_RESOURCE" | "SYS_TIME" | "SYS_TTY_CONFIG" | 		"SYSLOG" | "WAKE_ALARM"
        public let add: [String]?
        /// The Linux capabilities for the container that are dropped from the default configuration provided by Docker. Valid values: "ALL" | "AUDIT_CONTROL" | "AUDIT_WRITE" | 		"BLOCK_SUSPEND" | "CHOWN" | "DAC_OVERRIDE" | 		"DAC_READ_SEARCH" | "FOWNER" | "FSETID" | 		"IPC_LOCK" | "IPC_OWNER" | "KILL" | 		"LEASE" | "LINUX_IMMUTABLE" | "MAC_ADMIN" | 			"MAC_OVERRIDE" | "MKNOD" | "NET_ADMIN" | 		"NET_BIND_SERVICE" | "NET_BROADCAST" | "NET_RAW" | 		"SETFCAP" | "SETGID" | "SETPCAP" | 		"SETUID" | "SYS_ADMIN" | "SYS_BOOT" | 		"SYS_CHROOT" | "SYS_MODULE" | "SYS_NICE" | 		"SYS_PACCT" | "SYS_PTRACE" | "SYS_RAWIO" | 		"SYS_RESOURCE" | "SYS_TIME" | "SYS_TTY_CONFIG" | 		"SYSLOG" | "WAKE_ALARM"
        public let drop: [String]?

        @inlinable
        public init(add: [String]? = nil, drop: [String]? = nil) {
            self.add = add
            self.drop = drop
        }

        public func validate(name: String) throws {
            try self.add?.forEach {
                try validate($0, name: "add[]", parent: name, pattern: "\\S")
            }
            try self.drop?.forEach {
                try validate($0, name: "drop[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case add = "Add"
            case drop = "Drop"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.
        public let capabilities: AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails?
        /// The host devices to expose to the container.
        public let devices: [AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails]?
        /// Whether to run an init process inside the container that forwards signals and reaps processes.
        public let initProcessEnabled: Bool?
        /// The total amount of swap memory (in MiB) that a container can use.
        public let maxSwap: Int?
        /// The value for the size (in MiB) of the /dev/shm volume.
        public let sharedMemorySize: Int?
        /// Configures the container's memory swappiness behavior. Determines how aggressively pages are swapped. The higher the value, the more aggressive the swappiness. The default is 60.
        public let swappiness: Int?
        /// The container path, mount options, and size (in MiB) of the tmpfs mount.
        public let tmpfs: [AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails]?

        @inlinable
        public init(capabilities: AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails? = nil, devices: [AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails]? = nil, initProcessEnabled: Bool? = nil, maxSwap: Int? = nil, sharedMemorySize: Int? = nil, swappiness: Int? = nil, tmpfs: [AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails]? = nil) {
            self.capabilities = capabilities
            self.devices = devices
            self.initProcessEnabled = initProcessEnabled
            self.maxSwap = maxSwap
            self.sharedMemorySize = sharedMemorySize
            self.swappiness = swappiness
            self.tmpfs = tmpfs
        }

        public func validate(name: String) throws {
            try self.capabilities?.validate(name: "\(name).capabilities")
            try self.devices?.forEach {
                try $0.validate(name: "\(name).devices[]")
            }
            try self.tmpfs?.forEach {
                try $0.validate(name: "\(name).tmpfs[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case devices = "Devices"
            case initProcessEnabled = "InitProcessEnabled"
            case maxSwap = "MaxSwap"
            case sharedMemorySize = "SharedMemorySize"
            case swappiness = "Swappiness"
            case tmpfs = "Tmpfs"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The path inside the container at which to expose the host device.
        public let containerPath: String?
        /// The path for the device on the host container instance.
        public let hostPath: String?
        /// The explicit permissions to provide to the container for the device. By default, the container has permissions for read, write, and mknod for the device.
        public let permissions: [String]?

        @inlinable
        public init(containerPath: String? = nil, hostPath: String? = nil, permissions: [String]? = nil) {
            self.containerPath = containerPath
            self.hostPath = hostPath
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.validate(self.containerPath, name: "containerPath", parent: name, pattern: "\\S")
            try self.validate(self.hostPath, name: "hostPath", parent: name, pattern: "\\S")
            try self.permissions?.forEach {
                try validate($0, name: "permissions[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case containerPath = "ContainerPath"
            case hostPath = "HostPath"
            case permissions = "Permissions"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The absolute file path where the tmpfs volume is to be mounted.
        public let containerPath: String?
        /// The list of tmpfs volume mount options. Valid values: "defaults" | "ro" | "rw" | "suid" | 		"nosuid" | "dev" | "nodev" | "exec" | 		"noexec" | "sync" | "async" | "dirsync" 		| "remount" | "mand" | "nomand" | "atime" 		| "noatime" | "diratime" | "nodiratime" | 		"bind" | "rbind" | "unbindable" | 		"runbindable" | "private" | "rprivate" | 		"shared" | "rshared" | "slave" | 		"rslave" | "relatime" | "norelatime" | 		"strictatime" | "nostrictatime" | "mode" | 		"uid" | "gid" | "nr_inodes" | 			"nr_blocks" | "mpol"
        public let mountOptions: [String]?
        /// The maximum size (in MiB) of the tmpfs volume.
        public let size: Int?

        @inlinable
        public init(containerPath: String? = nil, mountOptions: [String]? = nil, size: Int? = nil) {
            self.containerPath = containerPath
            self.mountOptions = mountOptions
            self.size = size
        }

        public func validate(name: String) throws {
            try self.validate(self.containerPath, name: "containerPath", parent: name, pattern: "\\S")
            try self.mountOptions?.forEach {
                try validate($0, name: "mountOptions[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case containerPath = "ContainerPath"
            case mountOptions = "MountOptions"
            case size = "Size"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The log driver to use for the container. Valid values on Fargate are as follows:    awsfirelens     awslogs     splunk    Valid values on Amazon EC2 are as follows:    awsfirelens     awslogs     fluentd     gelf     journald     json-file     logentries     splunk     syslog
        public let logDriver: String?
        /// The configuration options to send to the log driver. Requires version 1.19 of the Docker Remote API or greater on your container instance.
        public let options: [String: String]?
        /// The secrets to pass to the log configuration.
        public let secretOptions: [AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]?

        @inlinable
        public init(logDriver: String? = nil, options: [String: String]? = nil, secretOptions: [AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]? = nil) {
            self.logDriver = logDriver
            self.options = options
            self.secretOptions = secretOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.logDriver, name: "logDriver", parent: name, pattern: "\\S")
            try self.options?.forEach {
                try validate($0.key, name: "options.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "options[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.secretOptions?.forEach {
                try $0.validate(name: "\(name).secretOptions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case logDriver = "LogDriver"
            case options = "Options"
            case secretOptions = "SecretOptions"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the secret.
        public let name: String?
        /// The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.
        public let valueFrom: String?

        @inlinable
        public init(name: String? = nil, valueFrom: String? = nil) {
            self.name = name
            self.valueFrom = valueFrom
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.valueFrom, name: "valueFrom", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case valueFrom = "ValueFrom"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The path on the container to mount the host volume at.
        public let containerPath: String?
        /// Whether the container has read-only access to the volume.
        public let readOnly: Bool?
        /// The name of the volume to mount. Must match the name of a volume listed in VolumeDetails for the task definition.
        public let sourceVolume: String?

        @inlinable
        public init(containerPath: String? = nil, readOnly: Bool? = nil, sourceVolume: String? = nil) {
            self.containerPath = containerPath
            self.readOnly = readOnly
            self.sourceVolume = sourceVolume
        }

        public func validate(name: String) throws {
            try self.validate(self.containerPath, name: "containerPath", parent: name, pattern: "\\S")
            try self.validate(self.sourceVolume, name: "sourceVolume", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerPath = "ContainerPath"
            case readOnly = "ReadOnly"
            case sourceVolume = "SourceVolume"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The port number on the container that is bound to the user-specified or automatically assigned host port.
        public let containerPort: Int?
        /// The port number on the container instance to reserve for the container.
        public let hostPort: Int?
        /// The protocol used for the port mapping. The default is tcp.
        public let `protocol`: String?

        @inlinable
        public init(containerPort: Int? = nil, hostPort: Int? = nil, protocol: String? = nil) {
            self.containerPort = containerPort
            self.hostPort = hostPort
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerPort = "ContainerPort"
            case hostPort = "HostPort"
            case `protocol` = "Protocol"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the secret that contains the private repository credentials.
        public let credentialsParameter: String?

        @inlinable
        public init(credentialsParameter: String? = nil) {
            self.credentialsParameter = credentialsParameter
        }

        public func validate(name: String) throws {
            try self.validate(self.credentialsParameter, name: "credentialsParameter", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case credentialsParameter = "CredentialsParameter"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The type of resource to assign to a container. Valid values are GPU or InferenceAccelerator.
        public let type: String?
        /// The value for the specified resource type. For GPU, the value is the number of physical GPUs the Amazon ECS container agent reserves for the container. For InferenceAccelerator, the value should match the DeviceName attribute of an entry in InferenceAccelerators.
        public let value: String?

        @inlinable
        public init(type: String? = nil, value: String? = nil) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the secret.
        public let name: String?
        /// The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.
        public let valueFrom: String?

        @inlinable
        public init(name: String? = nil, valueFrom: String? = nil) {
            self.name = name
            self.valueFrom = valueFrom
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.valueFrom, name: "valueFrom", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case valueFrom = "ValueFrom"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The namespaced kernel parameter for which to set a value.
        public let namespace: String?
        /// The value of the parameter.
        public let value: String?

        @inlinable
        public init(namespace: String? = nil, value: String? = nil) {
            self.namespace = namespace
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "Namespace"
            case value = "Value"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The hard limit for the ulimit type.
        public let hardLimit: Int?
        /// The type of the ulimit. Valid values are as follows:    core     cpu     data     fsize     locks     memlock     msgqueue     nice     nofile     nproc     rss     rtprio     rttime     sigpending     stack
        public let name: String?
        /// The soft limit for the ulimit type.
        public let softLimit: Int?

        @inlinable
        public init(hardLimit: Int? = nil, name: String? = nil, softLimit: Int? = nil) {
            self.hardLimit = hardLimit
            self.name = name
            self.softLimit = softLimit
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hardLimit = "HardLimit"
            case name = "Name"
            case softLimit = "SoftLimit"
        }
    }

    public struct AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the container has read-only access to the volume.
        public let readOnly: Bool?
        /// The name of another container within the same task definition from which to mount volumes.
        public let sourceContainer: String?

        @inlinable
        public init(readOnly: Bool? = nil, sourceContainer: String? = nil) {
            self.readOnly = readOnly
            self.sourceContainer = sourceContainer
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceContainer, name: "sourceContainer", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case readOnly = "ReadOnly"
            case sourceContainer = "SourceContainer"
        }
    }

    public struct AwsEcsTaskDefinitionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The container definitions that describe the containers that make up the task.
        public let containerDefinitions: [AwsEcsTaskDefinitionContainerDefinitionsDetails]?
        /// The number of CPU units used by the task.Valid values are as follows:    256 (.25 vCPU)     512 (.5 vCPU)     1024 (1 vCPU)     2048 (2 vCPU)     4096 (4 vCPU)
        public let cpu: String?
        /// The ARN of the task execution role that grants the container agent permission to make API calls on behalf of the container user.
        public let executionRoleArn: String?
        /// The name of a family that this task definition is registered to.
        public let family: String?
        /// The Elastic Inference accelerators to use for the containers in the task.
        public let inferenceAccelerators: [AwsEcsTaskDefinitionInferenceAcceleratorsDetails]?
        /// The inter-process communication (IPC) resource namespace to use for the containers in the task. Valid values are as follows:    host     none     task
        public let ipcMode: String?
        /// The amount (in MiB) of memory used by the task.  For tasks that are hosted on Amazon EC2, you can provide a task-level memory value or a container-level memory value. For tasks that are hosted on Fargate, you must use one of the specified values in the  Amazon Elastic Container Service Developer Guide , which determines your range of supported values for the Cpu and Memory parameters.
        public let memory: String?
        /// The Docker networking mode to use for the containers in the task. Valid values are as follows:    awsvpc     bridge     host     none
        public let networkMode: String?
        /// The process namespace to use for the containers in the task. Valid values are host or task.
        public let pidMode: String?
        /// The placement constraint objects to use for tasks.
        public let placementConstraints: [AwsEcsTaskDefinitionPlacementConstraintsDetails]?
        /// The configuration details for the App Mesh proxy.
        public let proxyConfiguration: AwsEcsTaskDefinitionProxyConfigurationDetails?
        /// The task launch types that the task definition was validated against.
        public let requiresCompatibilities: [String]?
        ///  The status of the task definition.
        public let status: String?
        /// The short name or ARN of the IAM role that grants containers in the task permission to call Amazon Web Services API operations on your behalf.
        public let taskRoleArn: String?
        /// The data volume definitions for the task.
        public let volumes: [AwsEcsTaskDefinitionVolumesDetails]?

        @inlinable
        public init(containerDefinitions: [AwsEcsTaskDefinitionContainerDefinitionsDetails]? = nil, cpu: String? = nil, executionRoleArn: String? = nil, family: String? = nil, inferenceAccelerators: [AwsEcsTaskDefinitionInferenceAcceleratorsDetails]? = nil, ipcMode: String? = nil, memory: String? = nil, networkMode: String? = nil, pidMode: String? = nil, placementConstraints: [AwsEcsTaskDefinitionPlacementConstraintsDetails]? = nil, proxyConfiguration: AwsEcsTaskDefinitionProxyConfigurationDetails? = nil, requiresCompatibilities: [String]? = nil, status: String? = nil, taskRoleArn: String? = nil, volumes: [AwsEcsTaskDefinitionVolumesDetails]? = nil) {
            self.containerDefinitions = containerDefinitions
            self.cpu = cpu
            self.executionRoleArn = executionRoleArn
            self.family = family
            self.inferenceAccelerators = inferenceAccelerators
            self.ipcMode = ipcMode
            self.memory = memory
            self.networkMode = networkMode
            self.pidMode = pidMode
            self.placementConstraints = placementConstraints
            self.proxyConfiguration = proxyConfiguration
            self.requiresCompatibilities = requiresCompatibilities
            self.status = status
            self.taskRoleArn = taskRoleArn
            self.volumes = volumes
        }

        public func validate(name: String) throws {
            try self.containerDefinitions?.forEach {
                try $0.validate(name: "\(name).containerDefinitions[]")
            }
            try self.validate(self.cpu, name: "cpu", parent: name, pattern: "\\S")
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.family, name: "family", parent: name, pattern: "\\S")
            try self.inferenceAccelerators?.forEach {
                try $0.validate(name: "\(name).inferenceAccelerators[]")
            }
            try self.validate(self.ipcMode, name: "ipcMode", parent: name, pattern: "\\S")
            try self.validate(self.memory, name: "memory", parent: name, pattern: "\\S")
            try self.validate(self.networkMode, name: "networkMode", parent: name, pattern: "\\S")
            try self.validate(self.pidMode, name: "pidMode", parent: name, pattern: "\\S")
            try self.placementConstraints?.forEach {
                try $0.validate(name: "\(name).placementConstraints[]")
            }
            try self.proxyConfiguration?.validate(name: "\(name).proxyConfiguration")
            try self.requiresCompatibilities?.forEach {
                try validate($0, name: "requiresCompatibilities[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.taskRoleArn, name: "taskRoleArn", parent: name, pattern: "\\S")
            try self.volumes?.forEach {
                try $0.validate(name: "\(name).volumes[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case containerDefinitions = "ContainerDefinitions"
            case cpu = "Cpu"
            case executionRoleArn = "ExecutionRoleArn"
            case family = "Family"
            case inferenceAccelerators = "InferenceAccelerators"
            case ipcMode = "IpcMode"
            case memory = "Memory"
            case networkMode = "NetworkMode"
            case pidMode = "PidMode"
            case placementConstraints = "PlacementConstraints"
            case proxyConfiguration = "ProxyConfiguration"
            case requiresCompatibilities = "RequiresCompatibilities"
            case status = "Status"
            case taskRoleArn = "TaskRoleArn"
            case volumes = "Volumes"
        }
    }

    public struct AwsEcsTaskDefinitionInferenceAcceleratorsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Elastic Inference accelerator device name.
        public let deviceName: String?
        /// The Elastic Inference accelerator type to use.
        public let deviceType: String?

        @inlinable
        public init(deviceName: String? = nil, deviceType: String? = nil) {
            self.deviceName = deviceName
            self.deviceType = deviceType
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "\\S")
            try self.validate(self.deviceType, name: "deviceType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceName = "DeviceName"
            case deviceType = "DeviceType"
        }
    }

    public struct AwsEcsTaskDefinitionPlacementConstraintsDetails: AWSEncodableShape & AWSDecodableShape {
        /// A cluster query language expression to apply to the constraint.
        public let expression: String?
        /// The type of constraint.
        public let type: String?

        @inlinable
        public init(expression: String? = nil, type: String? = nil) {
            self.expression = expression
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case type = "Type"
        }
    }

    public struct AwsEcsTaskDefinitionProxyConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the container that will serve as the App Mesh proxy.
        public let containerName: String?
        /// The set of network configuration parameters to provide to the Container Network Interface (CNI) plugin, specified as key-value pairs.
        public let proxyConfigurationProperties: [AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]?
        /// The proxy type.
        public let type: String?

        @inlinable
        public init(containerName: String? = nil, proxyConfigurationProperties: [AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]? = nil, type: String? = nil) {
            self.containerName = containerName
            self.proxyConfigurationProperties = proxyConfigurationProperties
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.containerName, name: "containerName", parent: name, pattern: "\\S")
            try self.proxyConfigurationProperties?.forEach {
                try $0.validate(name: "\(name).proxyConfigurationProperties[]")
            }
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerName = "ContainerName"
            case proxyConfigurationProperties = "ProxyConfigurationProperties"
            case type = "Type"
        }
    }

    public struct AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the property.
        public let name: String?
        /// The value of the property.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsEcsTaskDefinitionVolumesDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about a Docker volume.
        public let dockerVolumeConfiguration: AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails?
        /// Information about the Amazon Elastic File System file system that is used for task storage.
        public let efsVolumeConfiguration: AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails?
        /// Information about a bind mount host volume.
        public let host: AwsEcsTaskDefinitionVolumesHostDetails?
        /// The name of the data volume.
        public let name: String?

        @inlinable
        public init(dockerVolumeConfiguration: AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails? = nil, efsVolumeConfiguration: AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails? = nil, host: AwsEcsTaskDefinitionVolumesHostDetails? = nil, name: String? = nil) {
            self.dockerVolumeConfiguration = dockerVolumeConfiguration
            self.efsVolumeConfiguration = efsVolumeConfiguration
            self.host = host
            self.name = name
        }

        public func validate(name: String) throws {
            try self.dockerVolumeConfiguration?.validate(name: "\(name).dockerVolumeConfiguration")
            try self.efsVolumeConfiguration?.validate(name: "\(name).efsVolumeConfiguration")
            try self.host?.validate(name: "\(name).host")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dockerVolumeConfiguration = "DockerVolumeConfiguration"
            case efsVolumeConfiguration = "EfsVolumeConfiguration"
            case host = "Host"
            case name = "Name"
        }
    }

    public struct AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether to create the Docker volume automatically if it does not already exist.
        public let autoprovision: Bool?
        /// The Docker volume driver to use.
        public let driver: String?
        /// A map of Docker driver-specific options that are passed through.
        public let driverOpts: [String: String]?
        /// Custom metadata to add to the Docker volume.
        public let labels: [String: String]?
        /// The scope for the Docker volume that determines its lifecycle. Docker volumes that are scoped to a task are provisioned
        /// automatically when the task starts and destroyed when the task stops. Docker volumes that are shared persist after the task stops. Valid values are shared or task.
        public let scope: String?

        @inlinable
        public init(autoprovision: Bool? = nil, driver: String? = nil, driverOpts: [String: String]? = nil, labels: [String: String]? = nil, scope: String? = nil) {
            self.autoprovision = autoprovision
            self.driver = driver
            self.driverOpts = driverOpts
            self.labels = labels
            self.scope = scope
        }

        public func validate(name: String) throws {
            try self.validate(self.driver, name: "driver", parent: name, pattern: "\\S")
            try self.driverOpts?.forEach {
                try validate($0.key, name: "driverOpts.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "driverOpts[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.labels?.forEach {
                try validate($0.key, name: "labels.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "labels[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.scope, name: "scope", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case autoprovision = "Autoprovision"
            case driver = "Driver"
            case driverOpts = "DriverOpts"
            case labels = "Labels"
            case scope = "Scope"
        }
    }

    public struct AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon EFS access point identifier to use.
        public let accessPointId: String?
        /// Whether to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system.
        public let iam: String?

        @inlinable
        public init(accessPointId: String? = nil, iam: String? = nil) {
            self.accessPointId = accessPointId
            self.iam = iam
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPointId, name: "accessPointId", parent: name, pattern: "\\S")
            try self.validate(self.iam, name: "iam", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointId = "AccessPointId"
            case iam = "Iam"
        }
    }

    public struct AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The authorization configuration details for the Amazon EFS file system.
        public let authorizationConfig: AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails?
        /// The Amazon EFS file system identifier to use.
        public let filesystemId: String?
        /// The directory within the Amazon EFS file system to mount as the root directory inside the host.
        public let rootDirectory: String?
        /// Whether to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server.
        public let transitEncryption: String?
        /// The port to use when sending encrypted data between the Amazon ECS host and the Amazon EFS server.
        public let transitEncryptionPort: Int?

        @inlinable
        public init(authorizationConfig: AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails? = nil, filesystemId: String? = nil, rootDirectory: String? = nil, transitEncryption: String? = nil, transitEncryptionPort: Int? = nil) {
            self.authorizationConfig = authorizationConfig
            self.filesystemId = filesystemId
            self.rootDirectory = rootDirectory
            self.transitEncryption = transitEncryption
            self.transitEncryptionPort = transitEncryptionPort
        }

        public func validate(name: String) throws {
            try self.authorizationConfig?.validate(name: "\(name).authorizationConfig")
            try self.validate(self.filesystemId, name: "filesystemId", parent: name, pattern: "\\S")
            try self.validate(self.rootDirectory, name: "rootDirectory", parent: name, pattern: "\\S")
            try self.validate(self.transitEncryption, name: "transitEncryption", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationConfig = "AuthorizationConfig"
            case filesystemId = "FilesystemId"
            case rootDirectory = "RootDirectory"
            case transitEncryption = "TransitEncryption"
            case transitEncryptionPort = "TransitEncryptionPort"
        }
    }

    public struct AwsEcsTaskDefinitionVolumesHostDetails: AWSEncodableShape & AWSDecodableShape {
        /// The path on the host container instance that is presented to the container.
        public let sourcePath: String?

        @inlinable
        public init(sourcePath: String? = nil) {
            self.sourcePath = sourcePath
        }

        public func validate(name: String) throws {
            try self.validate(self.sourcePath, name: "sourcePath", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case sourcePath = "SourcePath"
        }
    }

    public struct AwsEcsTaskDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster that hosts the task.
        public let clusterArn: String?
        /// The containers that are associated with the task.
        public let containers: [AwsEcsContainerDetails]?
        /// The Unix timestamp for the time when the task was created. More specifically, it's for the time when
        /// the task entered the PENDING state.
        public let createdAt: String?
        /// The name of the task group that's associated with the task.
        public let group: String?
        /// The Unix timestamp for the time when the task started. More specifically, it's for the time when the  task transitioned from the PENDING state to the RUNNING state.
        public let startedAt: String?
        /// The tag specified when a task is started. If an Amazon ECS service started the task, the  startedBy parameter contains the deployment ID of that service.
        public let startedBy: String?
        /// The ARN of the task definition that creates the task.
        public let taskDefinitionArn: String?
        /// The version counter for the task.
        public let version: String?
        /// Details about the data volume that is used in a task definition.
        public let volumes: [AwsEcsTaskVolumeDetails]?

        @inlinable
        public init(clusterArn: String? = nil, containers: [AwsEcsContainerDetails]? = nil, createdAt: String? = nil, group: String? = nil, startedAt: String? = nil, startedBy: String? = nil, taskDefinitionArn: String? = nil, version: String? = nil, volumes: [AwsEcsTaskVolumeDetails]? = nil) {
            self.clusterArn = clusterArn
            self.containers = containers
            self.createdAt = createdAt
            self.group = group
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.taskDefinitionArn = taskDefinitionArn
            self.version = version
            self.volumes = volumes
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterArn, name: "clusterArn", parent: name, pattern: "\\S")
            try self.containers?.forEach {
                try $0.validate(name: "\(name).containers[]")
            }
            try self.validate(self.createdAt, name: "createdAt", parent: name, pattern: "\\S")
            try self.validate(self.group, name: "group", parent: name, pattern: "\\S")
            try self.validate(self.startedAt, name: "startedAt", parent: name, pattern: "\\S")
            try self.validate(self.startedBy, name: "startedBy", parent: name, pattern: "\\S")
            try self.validate(self.taskDefinitionArn, name: "taskDefinitionArn", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
            try self.volumes?.forEach {
                try $0.validate(name: "\(name).volumes[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "ClusterArn"
            case containers = "Containers"
            case createdAt = "CreatedAt"
            case group = "Group"
            case startedAt = "StartedAt"
            case startedBy = "StartedBy"
            case taskDefinitionArn = "TaskDefinitionArn"
            case version = "Version"
            case volumes = "Volumes"
        }
    }

    public struct AwsEcsTaskVolumeDetails: AWSEncodableShape & AWSDecodableShape {
        /// This parameter is specified when you use bind mount host volumes. The contents of the host parameter
        /// determine whether your bind mount host volume persists on the host container instance and where it's stored.
        public let host: AwsEcsTaskVolumeHostDetails?
        /// The name of the volume. Up to 255 letters (uppercase and lowercase), numbers, underscores, and
        /// hyphens are allowed. This name is referenced in the sourceVolume parameter of container definition mountPoints.
        public let name: String?

        @inlinable
        public init(host: AwsEcsTaskVolumeHostDetails? = nil, name: String? = nil) {
            self.host = host
            self.name = name
        }

        public func validate(name: String) throws {
            try self.host?.validate(name: "\(name).host")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case host = "Host"
            case name = "Name"
        }
    }

    public struct AwsEcsTaskVolumeHostDetails: AWSEncodableShape & AWSDecodableShape {
        /// When the host parameter is used, specify a sourcePath to declare the path
        /// on the host container instance that's presented to the container.
        public let sourcePath: String?

        @inlinable
        public init(sourcePath: String? = nil) {
            self.sourcePath = sourcePath
        }

        public func validate(name: String) throws {
            try self.validate(self.sourcePath, name: "sourcePath", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case sourcePath = "SourcePath"
        }
    }

    public struct AwsEfsAccessPointDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the Amazon EFS access point.
        public let accessPointId: String?
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point.
        public let arn: String?
        /// The opaque string specified in the request to ensure idempotent creation.
        public let clientToken: String?
        /// The ID of the Amazon EFS file system that the access point applies to.
        public let fileSystemId: String?
        /// The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point,
        /// that is used for all file operations by NFS clients using the access point.
        public let posixUser: AwsEfsAccessPointPosixUserDetails?
        /// The directory on the Amazon EFS file system that the access point exposes as the root
        /// directory to NFS clients using the access point.
        public let rootDirectory: AwsEfsAccessPointRootDirectoryDetails?

        @inlinable
        public init(accessPointId: String? = nil, arn: String? = nil, clientToken: String? = nil, fileSystemId: String? = nil, posixUser: AwsEfsAccessPointPosixUserDetails? = nil, rootDirectory: AwsEfsAccessPointRootDirectoryDetails? = nil) {
            self.accessPointId = accessPointId
            self.arn = arn
            self.clientToken = clientToken
            self.fileSystemId = fileSystemId
            self.posixUser = posixUser
            self.rootDirectory = rootDirectory
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPointId, name: "accessPointId", parent: name, pattern: "\\S")
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.fileSystemId, name: "fileSystemId", parent: name, pattern: "\\S")
            try self.posixUser?.validate(name: "\(name).posixUser")
            try self.rootDirectory?.validate(name: "\(name).rootDirectory")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointId = "AccessPointId"
            case arn = "Arn"
            case clientToken = "ClientToken"
            case fileSystemId = "FileSystemId"
            case posixUser = "PosixUser"
            case rootDirectory = "RootDirectory"
        }
    }

    public struct AwsEfsAccessPointPosixUserDetails: AWSEncodableShape & AWSDecodableShape {
        /// The POSIX group ID used for all file system operations using this access point.
        public let gid: String?
        /// Secondary POSIX group IDs used for all file system operations using this access point.
        public let secondaryGids: [String]?
        /// The POSIX user ID used for all file system operations using this access point.
        public let uid: String?

        @inlinable
        public init(gid: String? = nil, secondaryGids: [String]? = nil, uid: String? = nil) {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }

        public func validate(name: String) throws {
            try self.validate(self.gid, name: "gid", parent: name, pattern: "\\S")
            try self.secondaryGids?.forEach {
                try validate($0, name: "secondaryGids[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.uid, name: "uid", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case gid = "Gid"
            case secondaryGids = "SecondaryGids"
            case uid = "Uid"
        }
    }

    public struct AwsEfsAccessPointRootDirectoryCreationInfoDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the POSIX group ID to apply to the root directory.
        public let ownerGid: String?
        /// Specifies the POSIX user ID to apply to the root directory.
        public let ownerUid: String?
        /// Specifies the POSIX permissions to apply to the root directory, in the format of an octal number
        /// representing the file's mode bits.
        public let permissions: String?

        @inlinable
        public init(ownerGid: String? = nil, ownerUid: String? = nil, permissions: String? = nil) {
            self.ownerGid = ownerGid
            self.ownerUid = ownerUid
            self.permissions = permissions
        }

        public func validate(name: String) throws {
            try self.validate(self.ownerGid, name: "ownerGid", parent: name, pattern: "\\S")
            try self.validate(self.ownerUid, name: "ownerUid", parent: name, pattern: "\\S")
            try self.validate(self.permissions, name: "permissions", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ownerGid = "OwnerGid"
            case ownerUid = "OwnerUid"
            case permissions = "Permissions"
        }
    }

    public struct AwsEfsAccessPointRootDirectoryDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the POSIX IDs and permissions to apply to the access point's root directory.
        public let creationInfo: AwsEfsAccessPointRootDirectoryCreationInfoDetails?
        /// Specifies the path on the Amazon EFS file system to expose as the root directory to NFS clients
        /// using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified
        /// path does not exist, you are required to provide CreationInfo.
        public let path: String?

        @inlinable
        public init(creationInfo: AwsEfsAccessPointRootDirectoryCreationInfoDetails? = nil, path: String? = nil) {
            self.creationInfo = creationInfo
            self.path = path
        }

        public func validate(name: String) throws {
            try self.creationInfo?.validate(name: "\(name).creationInfo")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case creationInfo = "CreationInfo"
            case path = "Path"
        }
    }

    public struct AwsEksClusterDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the cluster.
        public let arn: String?
        /// The certificate authority data for the cluster.
        public let certificateAuthorityData: String?
        /// The status of the cluster. Valid values are as follows:    ACTIVE     CREATING     DELETING     FAILED     PENDING     UPDATING
        public let clusterStatus: String?
        /// The endpoint for the Amazon EKS API server.
        public let endpoint: String?
        /// The logging configuration for the cluster.
        public let logging: AwsEksClusterLoggingDetails?
        /// The name of the cluster.
        public let name: String?
        /// The VPC configuration used by the cluster control plane.
        public let resourcesVpcConfig: AwsEksClusterResourcesVpcConfigDetails?
        /// The ARN of the IAM role that provides permissions for the Amazon EKS control plane to make calls to Amazon Web Services API operations on your behalf.
        public let roleArn: String?
        /// The Amazon EKS server version for the cluster.
        public let version: String?

        @inlinable
        public init(arn: String? = nil, certificateAuthorityData: String? = nil, clusterStatus: String? = nil, endpoint: String? = nil, logging: AwsEksClusterLoggingDetails? = nil, name: String? = nil, resourcesVpcConfig: AwsEksClusterResourcesVpcConfigDetails? = nil, roleArn: String? = nil, version: String? = nil) {
            self.arn = arn
            self.certificateAuthorityData = certificateAuthorityData
            self.clusterStatus = clusterStatus
            self.endpoint = endpoint
            self.logging = logging
            self.name = name
            self.resourcesVpcConfig = resourcesVpcConfig
            self.roleArn = roleArn
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.certificateAuthorityData, name: "certificateAuthorityData", parent: name, pattern: "\\S")
            try self.validate(self.clusterStatus, name: "clusterStatus", parent: name, pattern: "\\S")
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "\\S")
            try self.logging?.validate(name: "\(name).logging")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.resourcesVpcConfig?.validate(name: "\(name).resourcesVpcConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case certificateAuthorityData = "CertificateAuthorityData"
            case clusterStatus = "ClusterStatus"
            case endpoint = "Endpoint"
            case logging = "Logging"
            case name = "Name"
            case resourcesVpcConfig = "ResourcesVpcConfig"
            case roleArn = "RoleArn"
            case version = "Version"
        }
    }

    public struct AwsEksClusterLoggingClusterLoggingDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the logging types that are listed in Types are enabled.
        public let enabled: Bool?
        /// A list of logging types. Valid values are as follows:    api     audit     authenticator     controllerManager     scheduler
        public let types: [String]?

        @inlinable
        public init(enabled: Bool? = nil, types: [String]? = nil) {
            self.enabled = enabled
            self.types = types
        }

        public func validate(name: String) throws {
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case types = "Types"
        }
    }

    public struct AwsEksClusterLoggingDetails: AWSEncodableShape & AWSDecodableShape {
        /// Cluster logging configurations.
        public let clusterLogging: [AwsEksClusterLoggingClusterLoggingDetails]?

        @inlinable
        public init(clusterLogging: [AwsEksClusterLoggingClusterLoggingDetails]? = nil) {
            self.clusterLogging = clusterLogging
        }

        public func validate(name: String) throws {
            try self.clusterLogging?.forEach {
                try $0.validate(name: "\(name).clusterLogging[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clusterLogging = "ClusterLogging"
        }
    }

    public struct AwsEksClusterResourcesVpcConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether the Amazon EKS public API server endpoint is turned on. If the Amazon EKS public API  server endpoint is turned off, your cluster's Kubernetes API server can only receive requests that originate from within  the cluster VPC.
        public let endpointPublicAccess: Bool?
        /// The security groups that are associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Amazon EKS control plane.
        public let securityGroupIds: [String]?
        /// The subnets that are associated with the cluster.
        public let subnetIds: [String]?

        @inlinable
        public init(endpointPublicAccess: Bool? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.endpointPublicAccess = endpointPublicAccess
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "\\S")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case endpointPublicAccess = "EndpointPublicAccess"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct AwsElasticBeanstalkEnvironmentDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the application that is associated with the environment.
        public let applicationName: String?
        /// The URL to the CNAME for this environment.
        public let cname: String?
        /// The creation date for this environment.
        public let dateCreated: String?
        /// The date when this environment was last modified.
        public let dateUpdated: String?
        /// A description of the environment.
        public let description: String?
        /// For load-balanced, autoscaling environments, the URL to the load balancer. For single-instance environments, the IP address of the instance.
        public let endpointUrl: String?
        /// The ARN of the environment.
        public let environmentArn: String?
        /// The identifier of the environment.
        public let environmentId: String?
        /// Links to other environments in the same group.
        public let environmentLinks: [AwsElasticBeanstalkEnvironmentEnvironmentLink]?
        /// The name of the environment.
        public let environmentName: String?
        /// The configuration setting for the environment.
        public let optionSettings: [AwsElasticBeanstalkEnvironmentOptionSetting]?
        /// The ARN of the platform version for the environment.
        public let platformArn: String?
        /// The name of the solution stack that is deployed with the environment.
        public let solutionStackName: String?
        /// The current operational status of the environment. Valid values are as follows:    Aborting     Launching     LinkingFrom     LinkingTo     Ready     Terminated     Terminating     Updating
        public let status: String?
        /// The tier of the environment.
        public let tier: AwsElasticBeanstalkEnvironmentTier?
        /// The application version of the environment.
        public let versionLabel: String?

        @inlinable
        public init(applicationName: String? = nil, cname: String? = nil, dateCreated: String? = nil, dateUpdated: String? = nil, description: String? = nil, endpointUrl: String? = nil, environmentArn: String? = nil, environmentId: String? = nil, environmentLinks: [AwsElasticBeanstalkEnvironmentEnvironmentLink]? = nil, environmentName: String? = nil, optionSettings: [AwsElasticBeanstalkEnvironmentOptionSetting]? = nil, platformArn: String? = nil, solutionStackName: String? = nil, status: String? = nil, tier: AwsElasticBeanstalkEnvironmentTier? = nil, versionLabel: String? = nil) {
            self.applicationName = applicationName
            self.cname = cname
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.endpointUrl = endpointUrl
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentLinks = environmentLinks
            self.environmentName = environmentName
            self.optionSettings = optionSettings
            self.platformArn = platformArn
            self.solutionStackName = solutionStackName
            self.status = status
            self.tier = tier
            self.versionLabel = versionLabel
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "\\S")
            try self.validate(self.cname, name: "cname", parent: name, pattern: "\\S")
            try self.validate(self.dateCreated, name: "dateCreated", parent: name, pattern: "\\S")
            try self.validate(self.dateUpdated, name: "dateUpdated", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.endpointUrl, name: "endpointUrl", parent: name, pattern: "\\S")
            try self.validate(self.environmentArn, name: "environmentArn", parent: name, pattern: "\\S")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "\\S")
            try self.environmentLinks?.forEach {
                try $0.validate(name: "\(name).environmentLinks[]")
            }
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "\\S")
            try self.optionSettings?.forEach {
                try $0.validate(name: "\(name).optionSettings[]")
            }
            try self.validate(self.platformArn, name: "platformArn", parent: name, pattern: "\\S")
            try self.validate(self.solutionStackName, name: "solutionStackName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.tier?.validate(name: "\(name).tier")
            try self.validate(self.versionLabel, name: "versionLabel", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationName = "ApplicationName"
            case cname = "Cname"
            case dateCreated = "DateCreated"
            case dateUpdated = "DateUpdated"
            case description = "Description"
            case endpointUrl = "EndpointUrl"
            case environmentArn = "EnvironmentArn"
            case environmentId = "EnvironmentId"
            case environmentLinks = "EnvironmentLinks"
            case environmentName = "EnvironmentName"
            case optionSettings = "OptionSettings"
            case platformArn = "PlatformArn"
            case solutionStackName = "SolutionStackName"
            case status = "Status"
            case tier = "Tier"
            case versionLabel = "VersionLabel"
        }
    }

    public struct AwsElasticBeanstalkEnvironmentEnvironmentLink: AWSEncodableShape & AWSDecodableShape {
        /// The name of the linked environment.
        public let environmentName: String?
        /// The name of the environment link.
        public let linkName: String?

        @inlinable
        public init(environmentName: String? = nil, linkName: String? = nil) {
            self.environmentName = environmentName
            self.linkName = linkName
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentName, name: "environmentName", parent: name, pattern: "\\S")
            try self.validate(self.linkName, name: "linkName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case environmentName = "EnvironmentName"
            case linkName = "LinkName"
        }
    }

    public struct AwsElasticBeanstalkEnvironmentOptionSetting: AWSEncodableShape & AWSDecodableShape {
        /// The type of resource that the configuration option is associated with.
        public let namespace: String?
        /// The name of the option.
        public let optionName: String?
        /// The name of the resource.
        public let resourceName: String?
        /// The value of the configuration setting.
        public let value: String?

        @inlinable
        public init(namespace: String? = nil, optionName: String? = nil, resourceName: String? = nil, value: String? = nil) {
            self.namespace = namespace
            self.optionName = optionName
            self.resourceName = resourceName
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "\\S")
            try self.validate(self.optionName, name: "optionName", parent: name, pattern: "\\S")
            try self.validate(self.resourceName, name: "resourceName", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "Namespace"
            case optionName = "OptionName"
            case resourceName = "ResourceName"
            case value = "Value"
        }
    }

    public struct AwsElasticBeanstalkEnvironmentTier: AWSEncodableShape & AWSDecodableShape {
        /// The name of the environment tier. Valid values are WebServer or Worker.
        public let name: String?
        /// The type of environment tier. Valid values are Standard or SQS/HTTP.
        public let type: String?
        /// The version of the environment tier.
        public let version: String?

        @inlinable
        public init(name: String? = nil, type: String? = nil, version: String? = nil) {
            self.name = name
            self.type = type
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
            case version = "Version"
        }
    }

    public struct AwsElasticsearchDomainDetails: AWSEncodableShape & AWSDecodableShape {
        /// IAM policy document specifying the access policies for the new Elasticsearch domain.
        public let accessPolicies: String?
        /// Additional options for the domain endpoint.
        public let domainEndpointOptions: AwsElasticsearchDomainDomainEndpointOptions?
        /// Unique identifier for an Elasticsearch domain.
        public let domainId: String?
        /// Name of an Elasticsearch domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region. Domain names must start with a lowercase letter and must be between 3 and 28 characters. Valid characters are a-z (lowercase only), 0-9, and â€“ (hyphen).
        public let domainName: String?
        /// Information about an OpenSearch cluster configuration.
        public let elasticsearchClusterConfig: AwsElasticsearchDomainElasticsearchClusterConfigDetails?
        /// OpenSearch version.
        public let elasticsearchVersion: String?
        /// Details about the configuration for encryption at rest.
        public let encryptionAtRestOptions: AwsElasticsearchDomainEncryptionAtRestOptions?
        /// Domain-specific endpoint used to submit index, search, and data upload requests to an Elasticsearch domain. The endpoint is a service URL.
        public let endpoint: String?
        /// The key-value pair that exists if the Elasticsearch domain uses VPC endpoints.
        public let endpoints: [String: String]?
        /// Configures the CloudWatch Logs to publish for the Elasticsearch domain.
        public let logPublishingOptions: AwsElasticsearchDomainLogPublishingOptions?
        /// Details about the configuration for node-to-node encryption.
        public let nodeToNodeEncryptionOptions: AwsElasticsearchDomainNodeToNodeEncryptionOptions?
        /// Information about the status of a domain relative to the latest service software.
        public let serviceSoftwareOptions: AwsElasticsearchDomainServiceSoftwareOptions?
        /// Information that OpenSearch derives based on VPCOptions for the domain.
        public let vpcOptions: AwsElasticsearchDomainVPCOptions?

        @inlinable
        public init(accessPolicies: String? = nil, domainEndpointOptions: AwsElasticsearchDomainDomainEndpointOptions? = nil, domainId: String? = nil, domainName: String? = nil, elasticsearchClusterConfig: AwsElasticsearchDomainElasticsearchClusterConfigDetails? = nil, elasticsearchVersion: String? = nil, encryptionAtRestOptions: AwsElasticsearchDomainEncryptionAtRestOptions? = nil, endpoint: String? = nil, endpoints: [String: String]? = nil, logPublishingOptions: AwsElasticsearchDomainLogPublishingOptions? = nil, nodeToNodeEncryptionOptions: AwsElasticsearchDomainNodeToNodeEncryptionOptions? = nil, serviceSoftwareOptions: AwsElasticsearchDomainServiceSoftwareOptions? = nil, vpcOptions: AwsElasticsearchDomainVPCOptions? = nil) {
            self.accessPolicies = accessPolicies
            self.domainEndpointOptions = domainEndpointOptions
            self.domainId = domainId
            self.domainName = domainName
            self.elasticsearchClusterConfig = elasticsearchClusterConfig
            self.elasticsearchVersion = elasticsearchVersion
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.endpoint = endpoint
            self.endpoints = endpoints
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.vpcOptions = vpcOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, pattern: "\\S")
            try self.domainEndpointOptions?.validate(name: "\(name).domainEndpointOptions")
            try self.validate(self.domainId, name: "domainId", parent: name, pattern: "\\S")
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.elasticsearchClusterConfig?.validate(name: "\(name).elasticsearchClusterConfig")
            try self.validate(self.elasticsearchVersion, name: "elasticsearchVersion", parent: name, pattern: "\\S")
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "\\S")
            try self.endpoints?.forEach {
                try validate($0.key, name: "endpoints.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "endpoints[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.logPublishingOptions?.validate(name: "\(name).logPublishingOptions")
            try self.serviceSoftwareOptions?.validate(name: "\(name).serviceSoftwareOptions")
            try self.vpcOptions?.validate(name: "\(name).vpcOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case domainEndpointOptions = "DomainEndpointOptions"
            case domainId = "DomainId"
            case domainName = "DomainName"
            case elasticsearchClusterConfig = "ElasticsearchClusterConfig"
            case elasticsearchVersion = "ElasticsearchVersion"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case endpoint = "Endpoint"
            case endpoints = "Endpoints"
            case logPublishingOptions = "LogPublishingOptions"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case serviceSoftwareOptions = "ServiceSoftwareOptions"
            case vpcOptions = "VPCOptions"
        }
    }

    public struct AwsElasticsearchDomainDomainEndpointOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether to require that all traffic to the domain arrive over HTTPS.
        public let enforceHTTPS: Bool?
        /// The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain. Valid values:    Policy-Min-TLS-1-0-2019-07, which supports TLSv1.0 and higher    Policy-Min-TLS-1-2-2019-07, which only supports TLSv1.2
        public let tlsSecurityPolicy: String?

        @inlinable
        public init(enforceHTTPS: Bool? = nil, tlsSecurityPolicy: String? = nil) {
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.tlsSecurityPolicy, name: "tlsSecurityPolicy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case enforceHTTPS = "EnforceHTTPS"
            case tlsSecurityPolicy = "TLSSecurityPolicy"
        }
    }

    public struct AwsElasticsearchDomainElasticsearchClusterConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances to use for the master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public let dedicatedMasterCount: Int?
        /// Whether to use a dedicated master node for the Elasticsearch domain. A dedicated master node performs cluster management tasks, but doesn't hold data or respond to data upload requests.
        public let dedicatedMasterEnabled: Bool?
        /// The hardware configuration of the computer that hosts the dedicated master node. A sample value is m3.medium.elasticsearch. If this attribute is specified, then DedicatedMasterEnabled must be true. For a list of valid values, see Supported instance types in Amazon OpenSearch Service in the Amazon OpenSearch Service Developer Guide.
        public let dedicatedMasterType: String?
        /// The number of data nodes to use in the Elasticsearch domain.
        public let instanceCount: Int?
        /// The instance type for your data nodes. For example, m3.medium.elasticsearch. For a list of valid values, see Supported instance types in Amazon OpenSearch Service in the Amazon OpenSearch Service Developer Guide.
        public let instanceType: String?
        /// Configuration options for zone awareness. Provided if ZoneAwarenessEnabled is true.
        public let zoneAwarenessConfig: AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails?
        /// Whether to enable zone awareness for the Elasticsearch domain. When zone awareness is enabled, OpenSearch allocates the cluster's nodes and replica index shards across Availability Zones in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.
        public let zoneAwarenessEnabled: Bool?

        @inlinable
        public init(dedicatedMasterCount: Int? = nil, dedicatedMasterEnabled: Bool? = nil, dedicatedMasterType: String? = nil, instanceCount: Int? = nil, instanceType: String? = nil, zoneAwarenessConfig: AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails? = nil, zoneAwarenessEnabled: Bool? = nil) {
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.dedicatedMasterType, name: "dedicatedMasterType", parent: name, pattern: "\\S")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dedicatedMasterCount = "DedicatedMasterCount"
            case dedicatedMasterEnabled = "DedicatedMasterEnabled"
            case dedicatedMasterType = "DedicatedMasterType"
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case zoneAwarenessConfig = "ZoneAwarenessConfig"
            case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
        }
    }

    public struct AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// he number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.
        public let availabilityZoneCount: Int?

        @inlinable
        public init(availabilityZoneCount: Int? = nil) {
            self.availabilityZoneCount = availabilityZoneCount
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneCount = "AvailabilityZoneCount"
        }
    }

    public struct AwsElasticsearchDomainEncryptionAtRestOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether encryption at rest is enabled.
        public let enabled: Bool?
        /// The KMS key ID. Takes the form 1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a.
        public let kmsKeyId: String?

        @inlinable
        public init(enabled: Bool? = nil, kmsKeyId: String? = nil) {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct AwsElasticsearchDomainLogPublishingOptions: AWSEncodableShape & AWSDecodableShape {
        public let auditLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig?
        /// Configures the OpenSearch index logs publishing.
        public let indexSlowLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig?
        /// Configures the OpenSearch search slow log publishing.
        public let searchSlowLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig?

        @inlinable
        public init(auditLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil, indexSlowLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil, searchSlowLogs: AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil) {
            self.auditLogs = auditLogs
            self.indexSlowLogs = indexSlowLogs
            self.searchSlowLogs = searchSlowLogs
        }

        public func validate(name: String) throws {
            try self.auditLogs?.validate(name: "\(name).auditLogs")
            try self.indexSlowLogs?.validate(name: "\(name).indexSlowLogs")
            try self.searchSlowLogs?.validate(name: "\(name).searchSlowLogs")
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs = "AuditLogs"
            case indexSlowLogs = "IndexSlowLogs"
            case searchSlowLogs = "SearchSlowLogs"
        }
    }

    public struct AwsElasticsearchDomainLogPublishingOptionsLogConfig: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the CloudWatch Logs group to publish the logs to.
        public let cloudWatchLogsLogGroupArn: String?
        /// Whether the log publishing is enabled.
        public let enabled: Bool?

        @inlinable
        public init(cloudWatchLogsLogGroupArn: String? = nil, enabled: Bool? = nil) {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
            case enabled = "Enabled"
        }
    }

    public struct AwsElasticsearchDomainNodeToNodeEncryptionOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether node-to-node encryption is enabled.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsElasticsearchDomainServiceSoftwareOptions: AWSEncodableShape & AWSDecodableShape {
        /// The epoch time when the deployment window closes for required updates. After this time, Amazon OpenSearch Service schedules the software upgrade automatically.
        public let automatedUpdateDate: String?
        /// Whether a request to update the domain can be canceled.
        public let cancellable: Bool?
        /// The version of the service software that is currently installed on the domain.
        public let currentVersion: String?
        /// A more detailed description of the service software status.
        public let description: String?
        /// The most recent version of the service software.
        public let newVersion: String?
        /// Whether a service software update is available for the domain.
        public let updateAvailable: Bool?
        /// The status of the service software update. Valid values are as follows:    COMPLETED     ELIGIBLE     IN_PROGRESS     NOT_ELIGIBLE     PENDING_UPDATE
        public let updateStatus: String?

        @inlinable
        public init(automatedUpdateDate: String? = nil, cancellable: Bool? = nil, currentVersion: String? = nil, description: String? = nil, newVersion: String? = nil, updateAvailable: Bool? = nil, updateStatus: String? = nil) {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.automatedUpdateDate, name: "automatedUpdateDate", parent: name, pattern: "\\S")
            try self.validate(self.currentVersion, name: "currentVersion", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.newVersion, name: "newVersion", parent: name, pattern: "\\S")
            try self.validate(self.updateStatus, name: "updateStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case automatedUpdateDate = "AutomatedUpdateDate"
            case cancellable = "Cancellable"
            case currentVersion = "CurrentVersion"
            case description = "Description"
            case newVersion = "NewVersion"
            case updateAvailable = "UpdateAvailable"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct AwsElasticsearchDomainVPCOptions: AWSEncodableShape & AWSDecodableShape {
        /// The list of Availability Zones associated with the VPC subnets.
        public let availabilityZones: [String]?
        /// The list of security group IDs associated with the VPC endpoints for the domain.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs associated with the VPC endpoints for the domain.
        public let subnetIds: [String]?
        /// ID for the VPC.
        public let vpcId: String?

        @inlinable
        public init(availabilityZones: [String]? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "\\S")
            }
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "\\S")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcId = "VPCId"
        }
    }

    public struct AwsElbAppCookieStickinessPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The name of the application cookie used for stickiness.
        public let cookieName: String?
        /// The mnemonic name for the policy being created. The name must be unique within the set of policies for the load balancer.
        public let policyName: String?

        @inlinable
        public init(cookieName: String? = nil, policyName: String? = nil) {
            self.cookieName = cookieName
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.cookieName, name: "cookieName", parent: name, pattern: "\\S")
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cookieName = "CookieName"
            case policyName = "PolicyName"
        }
    }

    public struct AwsElbLbCookieStickinessPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The amount of time, in seconds, after which the cookie is considered stale. If an expiration period is not specified, the stickiness session lasts for the duration of the browser session.
        public let cookieExpirationPeriod: Int64?
        /// The name of the policy. The name must be unique within the set of policies for the load balancer.
        public let policyName: String?

        @inlinable
        public init(cookieExpirationPeriod: Int64? = nil, policyName: String? = nil) {
            self.cookieExpirationPeriod = cookieExpirationPeriod
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cookieExpirationPeriod = "CookieExpirationPeriod"
            case policyName = "PolicyName"
        }
    }

    public struct AwsElbLoadBalancerAccessLog: AWSEncodableShape & AWSDecodableShape {
        /// The interval in minutes for publishing the access logs. You can publish access logs either every 5 minutes or every 60 minutes.
        public let emitInterval: Int?
        /// Indicates whether access logs are enabled for the load balancer.
        public let enabled: Bool?
        /// The name of the S3 bucket where the access logs are stored.
        public let s3BucketName: String?
        /// The logical hierarchy that was created for the S3 bucket. If a prefix is not provided, the log is placed at the root level of the bucket.
        public let s3BucketPrefix: String?

        @inlinable
        public init(emitInterval: Int? = nil, enabled: Bool? = nil, s3BucketName: String? = nil, s3BucketPrefix: String? = nil) {
            self.emitInterval = emitInterval
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.s3BucketPrefix = s3BucketPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "\\S")
            try self.validate(self.s3BucketPrefix, name: "s3BucketPrefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case emitInterval = "EmitInterval"
            case enabled = "Enabled"
            case s3BucketName = "S3BucketName"
            case s3BucketPrefix = "S3BucketPrefix"
        }
    }

    public struct AwsElbLoadBalancerAdditionalAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name of the attribute.
        public let key: String?
        /// The value of the attribute.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct AwsElbLoadBalancerAttributes: AWSEncodableShape & AWSDecodableShape {
        /// Information about the access log configuration for the load balancer. If the access log is enabled, the load balancer captures detailed information about all requests. It delivers the information to a specified S3 bucket.
        public let accessLog: AwsElbLoadBalancerAccessLog?
        /// Any additional attributes for a load balancer.
        public let additionalAttributes: [AwsElbLoadBalancerAdditionalAttribute]?
        /// Information about the connection draining configuration for the load balancer. If connection draining is enabled, the load balancer allows existing requests to complete before it shifts traffic away from a deregistered or unhealthy instance.
        public let connectionDraining: AwsElbLoadBalancerConnectionDraining?
        /// Connection settings for the load balancer. If an idle timeout is configured, the load balancer allows connections to remain idle for the specified duration. When a connection is idle, no data is sent over the connection.
        public let connectionSettings: AwsElbLoadBalancerConnectionSettings?
        /// Cross-zone load balancing settings for the load balancer. If cross-zone load balancing is enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones.
        public let crossZoneLoadBalancing: AwsElbLoadBalancerCrossZoneLoadBalancing?

        @inlinable
        public init(accessLog: AwsElbLoadBalancerAccessLog? = nil, additionalAttributes: [AwsElbLoadBalancerAdditionalAttribute]? = nil, connectionDraining: AwsElbLoadBalancerConnectionDraining? = nil, connectionSettings: AwsElbLoadBalancerConnectionSettings? = nil, crossZoneLoadBalancing: AwsElbLoadBalancerCrossZoneLoadBalancing? = nil) {
            self.accessLog = accessLog
            self.additionalAttributes = additionalAttributes
            self.connectionDraining = connectionDraining
            self.connectionSettings = connectionSettings
            self.crossZoneLoadBalancing = crossZoneLoadBalancing
        }

        public func validate(name: String) throws {
            try self.accessLog?.validate(name: "\(name).accessLog")
            try self.additionalAttributes?.forEach {
                try $0.validate(name: "\(name).additionalAttributes[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessLog = "AccessLog"
            case additionalAttributes = "AdditionalAttributes"
            case connectionDraining = "ConnectionDraining"
            case connectionSettings = "ConnectionSettings"
            case crossZoneLoadBalancing = "CrossZoneLoadBalancing"
        }
    }

    public struct AwsElbLoadBalancerBackendServerDescription: AWSEncodableShape & AWSDecodableShape {
        /// The port on which the EC2 instance is listening.
        public let instancePort: Int?
        /// The names of the policies that are enabled for the EC2 instance.
        public let policyNames: [String]?

        @inlinable
        public init(instancePort: Int? = nil, policyNames: [String]? = nil) {
            self.instancePort = instancePort
            self.policyNames = policyNames
        }

        public func validate(name: String) throws {
            try self.policyNames?.forEach {
                try validate($0, name: "policyNames[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case instancePort = "InstancePort"
            case policyNames = "PolicyNames"
        }
    }

    public struct AwsElbLoadBalancerConnectionDraining: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether connection draining is enabled for the load balancer.
        public let enabled: Bool?
        /// The maximum time, in seconds, to keep the existing connections open before deregistering the instances.
        public let timeout: Int?

        @inlinable
        public init(enabled: Bool? = nil, timeout: Int? = nil) {
            self.enabled = enabled
            self.timeout = timeout
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case timeout = "Timeout"
        }
    }

    public struct AwsElbLoadBalancerConnectionSettings: AWSEncodableShape & AWSDecodableShape {
        /// The time, in seconds, that the connection can be idle (no data is sent over the connection) before it is closed by the load balancer.
        public let idleTimeout: Int?

        @inlinable
        public init(idleTimeout: Int? = nil) {
            self.idleTimeout = idleTimeout
        }

        private enum CodingKeys: String, CodingKey {
            case idleTimeout = "IdleTimeout"
        }
    }

    public struct AwsElbLoadBalancerCrossZoneLoadBalancing: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether cross-zone load balancing is enabled for the load balancer.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsElbLoadBalancerDetails: AWSEncodableShape & AWSDecodableShape {
        /// The list of Availability Zones for the load balancer.
        public let availabilityZones: [String]?
        /// Information about the configuration of the EC2 instances.
        public let backendServerDescriptions: [AwsElbLoadBalancerBackendServerDescription]?
        /// The name of the Amazon RouteÂ 53 hosted zone for the load balancer.
        public let canonicalHostedZoneName: String?
        /// The ID of the Amazon RouteÂ 53 hosted zone for the load balancer.
        public let canonicalHostedZoneNameID: String?
        /// Indicates when the load balancer was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdTime: String?
        /// The DNS name of the load balancer.
        public let dnsName: String?
        /// Information about the health checks that are conducted on the load balancer.
        public let healthCheck: AwsElbLoadBalancerHealthCheck?
        /// List of EC2 instances for the load balancer.
        public let instances: [AwsElbLoadBalancerInstance]?
        /// The policies that are enabled for the load balancer listeners.
        public let listenerDescriptions: [AwsElbLoadBalancerListenerDescription]?
        /// The attributes for a load balancer.
        public let loadBalancerAttributes: AwsElbLoadBalancerAttributes?
        /// The name of the load balancer.
        public let loadBalancerName: String?
        /// The policies for a load balancer.
        public let policies: AwsElbLoadBalancerPolicies?
        /// The type of load balancer. Only provided if the load balancer is in a VPC. If Scheme is internet-facing, the load balancer has a public DNS name that resolves to a public IP address. If Scheme is internal, the load balancer has a public DNS name that resolves to a private IP address.
        public let scheme: String?
        /// The security groups for the load balancer. Only provided if the load balancer is in a VPC.
        public let securityGroups: [String]?
        /// Information about the security group for the load balancer. This is the security group that is used for inbound rules.
        public let sourceSecurityGroup: AwsElbLoadBalancerSourceSecurityGroup?
        /// The list of subnet identifiers for the load balancer.
        public let subnets: [String]?
        /// The identifier of the VPC for the load balancer.
        public let vpcId: String?

        @inlinable
        public init(availabilityZones: [String]? = nil, backendServerDescriptions: [AwsElbLoadBalancerBackendServerDescription]? = nil, canonicalHostedZoneName: String? = nil, canonicalHostedZoneNameID: String? = nil, createdTime: String? = nil, dnsName: String? = nil, healthCheck: AwsElbLoadBalancerHealthCheck? = nil, instances: [AwsElbLoadBalancerInstance]? = nil, listenerDescriptions: [AwsElbLoadBalancerListenerDescription]? = nil, loadBalancerAttributes: AwsElbLoadBalancerAttributes? = nil, loadBalancerName: String? = nil, policies: AwsElbLoadBalancerPolicies? = nil, scheme: String? = nil, securityGroups: [String]? = nil, sourceSecurityGroup: AwsElbLoadBalancerSourceSecurityGroup? = nil, subnets: [String]? = nil, vpcId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.backendServerDescriptions = backendServerDescriptions
            self.canonicalHostedZoneName = canonicalHostedZoneName
            self.canonicalHostedZoneNameID = canonicalHostedZoneNameID
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.healthCheck = healthCheck
            self.instances = instances
            self.listenerDescriptions = listenerDescriptions
            self.loadBalancerAttributes = loadBalancerAttributes
            self.loadBalancerName = loadBalancerName
            self.policies = policies
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.sourceSecurityGroup = sourceSecurityGroup
            self.subnets = subnets
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "\\S")
            }
            try self.backendServerDescriptions?.forEach {
                try $0.validate(name: "\(name).backendServerDescriptions[]")
            }
            try self.validate(self.canonicalHostedZoneName, name: "canonicalHostedZoneName", parent: name, pattern: "\\S")
            try self.validate(self.canonicalHostedZoneNameID, name: "canonicalHostedZoneNameID", parent: name, pattern: "\\S")
            try self.validate(self.createdTime, name: "createdTime", parent: name, pattern: "\\S")
            try self.validate(self.dnsName, name: "dnsName", parent: name, pattern: "\\S")
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.instances?.forEach {
                try $0.validate(name: "\(name).instances[]")
            }
            try self.listenerDescriptions?.forEach {
                try $0.validate(name: "\(name).listenerDescriptions[]")
            }
            try self.loadBalancerAttributes?.validate(name: "\(name).loadBalancerAttributes")
            try self.validate(self.loadBalancerName, name: "loadBalancerName", parent: name, pattern: "\\S")
            try self.policies?.validate(name: "\(name).policies")
            try self.validate(self.scheme, name: "scheme", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.sourceSecurityGroup?.validate(name: "\(name).sourceSecurityGroup")
            try self.subnets?.forEach {
                try validate($0, name: "subnets[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case backendServerDescriptions = "BackendServerDescriptions"
            case canonicalHostedZoneName = "CanonicalHostedZoneName"
            case canonicalHostedZoneNameID = "CanonicalHostedZoneNameID"
            case createdTime = "CreatedTime"
            case dnsName = "DnsName"
            case healthCheck = "HealthCheck"
            case instances = "Instances"
            case listenerDescriptions = "ListenerDescriptions"
            case loadBalancerAttributes = "LoadBalancerAttributes"
            case loadBalancerName = "LoadBalancerName"
            case policies = "Policies"
            case scheme = "Scheme"
            case securityGroups = "SecurityGroups"
            case sourceSecurityGroup = "SourceSecurityGroup"
            case subnets = "Subnets"
            case vpcId = "VpcId"
        }
    }

    public struct AwsElbLoadBalancerHealthCheck: AWSEncodableShape & AWSDecodableShape {
        /// The number of consecutive health check successes required before the instance is moved to the Healthy state.
        public let healthyThreshold: Int?
        /// The approximate interval, in seconds, between health checks of an individual instance.
        public let interval: Int?
        /// The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535. For the HTTP and HTTPS protocols, the target also specifies the ping path. For the TCP protocol, the target is specified as TCP:  . For the SSL protocol, the target is specified as SSL. . For the HTTP and HTTPS protocols, the target is specified as  :/ .
        public let target: String?
        /// The amount of time, in seconds, during which no response means a failed health check.
        public let timeout: Int?
        /// The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.
        public let unhealthyThreshold: Int?

        @inlinable
        public init(healthyThreshold: Int? = nil, interval: Int? = nil, target: String? = nil, timeout: Int? = nil, unhealthyThreshold: Int? = nil) {
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.target = target
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try self.validate(self.target, name: "target", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold = "HealthyThreshold"
            case interval = "Interval"
            case target = "Target"
            case timeout = "Timeout"
            case unhealthyThreshold = "UnhealthyThreshold"
        }
    }

    public struct AwsElbLoadBalancerInstance: AWSEncodableShape & AWSDecodableShape {
        /// The instance identifier.
        public let instanceId: String?

        @inlinable
        public init(instanceId: String? = nil) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
        }
    }

    public struct AwsElbLoadBalancerListener: AWSEncodableShape & AWSDecodableShape {
        /// The port on which the instance is listening.
        public let instancePort: Int?
        /// The protocol to use to route traffic to instances. Valid values: HTTP | HTTPS | TCP | SSL
        public let instanceProtocol: String?
        /// The port on which the load balancer is listening. On EC2-VPC, you can specify any port from the range 1-65535. On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.
        public let loadBalancerPort: Int?
        /// The load balancer transport protocol to use for routing. Valid values: HTTP | HTTPS | TCP | SSL
        public let `protocol`: String?
        /// The ARN of the server certificate.
        public let sslCertificateId: String?

        @inlinable
        public init(instancePort: Int? = nil, instanceProtocol: String? = nil, loadBalancerPort: Int? = nil, protocol: String? = nil, sslCertificateId: String? = nil) {
            self.instancePort = instancePort
            self.instanceProtocol = instanceProtocol
            self.loadBalancerPort = loadBalancerPort
            self.`protocol` = `protocol`
            self.sslCertificateId = sslCertificateId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceProtocol, name: "instanceProtocol", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.validate(self.sslCertificateId, name: "sslCertificateId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case instancePort = "InstancePort"
            case instanceProtocol = "InstanceProtocol"
            case loadBalancerPort = "LoadBalancerPort"
            case `protocol` = "Protocol"
            case sslCertificateId = "SslCertificateId"
        }
    }

    public struct AwsElbLoadBalancerListenerDescription: AWSEncodableShape & AWSDecodableShape {
        /// Information about the listener.
        public let listener: AwsElbLoadBalancerListener?
        /// The policies enabled for the listener.
        public let policyNames: [String]?

        @inlinable
        public init(listener: AwsElbLoadBalancerListener? = nil, policyNames: [String]? = nil) {
            self.listener = listener
            self.policyNames = policyNames
        }

        public func validate(name: String) throws {
            try self.listener?.validate(name: "\(name).listener")
            try self.policyNames?.forEach {
                try validate($0, name: "policyNames[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
            case policyNames = "PolicyNames"
        }
    }

    public struct AwsElbLoadBalancerPolicies: AWSEncodableShape & AWSDecodableShape {
        /// The stickiness policies that are created using CreateAppCookieStickinessPolicy.
        public let appCookieStickinessPolicies: [AwsElbAppCookieStickinessPolicy]?
        /// The stickiness policies that are created using CreateLBCookieStickinessPolicy.
        public let lbCookieStickinessPolicies: [AwsElbLbCookieStickinessPolicy]?
        /// The policies other than the stickiness policies.
        public let otherPolicies: [String]?

        @inlinable
        public init(appCookieStickinessPolicies: [AwsElbAppCookieStickinessPolicy]? = nil, lbCookieStickinessPolicies: [AwsElbLbCookieStickinessPolicy]? = nil, otherPolicies: [String]? = nil) {
            self.appCookieStickinessPolicies = appCookieStickinessPolicies
            self.lbCookieStickinessPolicies = lbCookieStickinessPolicies
            self.otherPolicies = otherPolicies
        }

        public func validate(name: String) throws {
            try self.appCookieStickinessPolicies?.forEach {
                try $0.validate(name: "\(name).appCookieStickinessPolicies[]")
            }
            try self.lbCookieStickinessPolicies?.forEach {
                try $0.validate(name: "\(name).lbCookieStickinessPolicies[]")
            }
            try self.otherPolicies?.forEach {
                try validate($0, name: "otherPolicies[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case appCookieStickinessPolicies = "AppCookieStickinessPolicies"
            case lbCookieStickinessPolicies = "LbCookieStickinessPolicies"
            case otherPolicies = "OtherPolicies"
        }
    }

    public struct AwsElbLoadBalancerSourceSecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// The name of the security group.
        public let groupName: String?
        /// The owner of the security group.
        public let ownerAlias: String?

        @inlinable
        public init(groupName: String? = nil, ownerAlias: String? = nil) {
            self.groupName = groupName
            self.ownerAlias = ownerAlias
        }

        public func validate(name: String) throws {
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.validate(self.ownerAlias, name: "ownerAlias", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "GroupName"
            case ownerAlias = "OwnerAlias"
        }
    }

    public struct AwsElbv2LoadBalancerAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name of the load balancer attribute.
        public let key: String?
        /// The value of the load balancer attribute.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct AwsElbv2LoadBalancerDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Availability Zones for the load balancer.
        public let availabilityZones: [AvailabilityZone]?
        /// The ID of the Amazon Route 53 hosted zone associated with the load balancer.
        public let canonicalHostedZoneId: String?
        /// Indicates when the load balancer was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdTime: String?
        /// The public DNS name of the load balancer.
        public let dnsName: String?
        /// The type of IP addresses used by the subnets for your load balancer. The possible values are ipv4 (for IPv4 addresses) and dualstack (for IPv4 and IPv6 addresses).
        public let ipAddressType: String?
        /// Attributes of the load balancer.
        public let loadBalancerAttributes: [AwsElbv2LoadBalancerAttribute]?
        /// The nodes of an Internet-facing load balancer have public IP addresses.
        public let scheme: String?
        /// The IDs of the security groups for the load balancer.
        public let securityGroups: [String]?
        /// The state of the load balancer.
        public let state: LoadBalancerState?
        /// The type of load balancer.
        public let type: String?
        /// The ID of the VPC for the load balancer.
        public let vpcId: String?

        @inlinable
        public init(availabilityZones: [AvailabilityZone]? = nil, canonicalHostedZoneId: String? = nil, createdTime: String? = nil, dnsName: String? = nil, ipAddressType: String? = nil, loadBalancerAttributes: [AwsElbv2LoadBalancerAttribute]? = nil, scheme: String? = nil, securityGroups: [String]? = nil, state: LoadBalancerState? = nil, type: String? = nil, vpcId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.canonicalHostedZoneId = canonicalHostedZoneId
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.ipAddressType = ipAddressType
            self.loadBalancerAttributes = loadBalancerAttributes
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.state = state
            self.type = type
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try $0.validate(name: "\(name).availabilityZones[]")
            }
            try self.validate(self.canonicalHostedZoneId, name: "canonicalHostedZoneId", parent: name, pattern: "\\S")
            try self.validate(self.createdTime, name: "createdTime", parent: name, pattern: "\\S")
            try self.validate(self.dnsName, name: "dnsName", parent: name, pattern: "\\S")
            try self.validate(self.ipAddressType, name: "ipAddressType", parent: name, pattern: "\\S")
            try self.loadBalancerAttributes?.forEach {
                try $0.validate(name: "\(name).loadBalancerAttributes[]")
            }
            try self.validate(self.scheme, name: "scheme", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.state?.validate(name: "\(name).state")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case canonicalHostedZoneId = "CanonicalHostedZoneId"
            case createdTime = "CreatedTime"
            case dnsName = "DNSName"
            case ipAddressType = "IpAddressType"
            case loadBalancerAttributes = "LoadBalancerAttributes"
            case scheme = "Scheme"
            case securityGroups = "SecurityGroups"
            case state = "State"
            case type = "Type"
            case vpcId = "VpcId"
        }
    }

    public struct AwsEventSchemasRegistryDetails: AWSEncodableShape & AWSDecodableShape {
        ///  A description of the registry to be created.
        public let description: String?
        ///  The Amazon Resource Name (ARN) of the registry.
        public let registryArn: String?
        ///  The name of the schema registry.
        public let registryName: String?

        @inlinable
        public init(description: String? = nil, registryArn: String? = nil, registryName: String? = nil) {
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.registryArn, name: "registryArn", parent: name, pattern: "\\S")
            try self.validate(self.registryName, name: "registryName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case registryArn = "RegistryArn"
            case registryName = "RegistryName"
        }
    }

    public struct AwsEventsEndpointDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the endpoint.
        public let arn: String?
        ///  A description of the endpoint.
        public let description: String?
        ///  The URL subdomain of the endpoint. For example, if EndpointUrl is  https://abcde.veo.endpoints.event.amazonaws.com, then the EndpointId is abcde.veo.
        public let endpointId: String?
        ///  The URL of the endpoint.
        public let endpointUrl: String?
        ///  The event buses being used by the endpoint.
        public let eventBuses: [AwsEventsEndpointEventBusesDetails]?
        ///  The name of the endpoint.
        public let name: String?
        ///  Whether event replication was enabled or disabled for this endpoint. The default state is ENABLED, which  means you must supply a RoleArn. If you don't have a RoleArn or you don't want event  replication enabled, set the state to DISABLED.
        public let replicationConfig: AwsEventsEndpointReplicationConfigDetails?
        ///  The ARN of the role used by event replication for the endpoint.
        public let roleArn: String?
        ///  The routing configuration of the endpoint.
        public let routingConfig: AwsEventsEndpointRoutingConfigDetails?
        ///  The current state of the endpoint.
        public let state: String?
        ///  The reason the endpoint is in its current state.
        public let stateReason: String?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, endpointId: String? = nil, endpointUrl: String? = nil, eventBuses: [AwsEventsEndpointEventBusesDetails]? = nil, name: String? = nil, replicationConfig: AwsEventsEndpointReplicationConfigDetails? = nil, roleArn: String? = nil, routingConfig: AwsEventsEndpointRoutingConfigDetails? = nil, state: String? = nil, stateReason: String? = nil) {
            self.arn = arn
            self.description = description
            self.endpointId = endpointId
            self.endpointUrl = endpointUrl
            self.eventBuses = eventBuses
            self.name = name
            self.replicationConfig = replicationConfig
            self.roleArn = roleArn
            self.routingConfig = routingConfig
            self.state = state
            self.stateReason = stateReason
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.endpointId, name: "endpointId", parent: name, pattern: "\\S")
            try self.validate(self.endpointUrl, name: "endpointUrl", parent: name, pattern: "\\S")
            try self.eventBuses?.forEach {
                try $0.validate(name: "\(name).eventBuses[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.replicationConfig?.validate(name: "\(name).replicationConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.routingConfig?.validate(name: "\(name).routingConfig")
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
            try self.validate(self.stateReason, name: "stateReason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case endpointId = "EndpointId"
            case endpointUrl = "EndpointUrl"
            case eventBuses = "EventBuses"
            case name = "Name"
            case replicationConfig = "ReplicationConfig"
            case roleArn = "RoleArn"
            case routingConfig = "RoutingConfig"
            case state = "State"
            case stateReason = "StateReason"
        }
    }

    public struct AwsEventsEndpointEventBusesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the event bus that the endpoint is associated with.
        public let eventBusArn: String?

        @inlinable
        public init(eventBusArn: String? = nil) {
            self.eventBusArn = eventBusArn
        }

        public func validate(name: String) throws {
            try self.validate(self.eventBusArn, name: "eventBusArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case eventBusArn = "EventBusArn"
        }
    }

    public struct AwsEventsEndpointReplicationConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The state of event replication.
        public let state: String?

        @inlinable
        public init(state: String? = nil) {
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct AwsEventsEndpointRoutingConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The failover configuration for an endpoint. This includes what triggers failover and what happens when it's triggered.
        public let failoverConfig: AwsEventsEndpointRoutingConfigFailoverConfigDetails?

        @inlinable
        public init(failoverConfig: AwsEventsEndpointRoutingConfigFailoverConfigDetails? = nil) {
            self.failoverConfig = failoverConfig
        }

        public func validate(name: String) throws {
            try self.failoverConfig?.validate(name: "\(name).failoverConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case failoverConfig = "FailoverConfig"
        }
    }

    public struct AwsEventsEndpointRoutingConfigFailoverConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The main Region of the endpoint.
        public let primary: AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails?
        ///  The Region that events are routed to when failover is triggered or event replication is enabled.
        public let secondary: AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails?

        @inlinable
        public init(primary: AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails? = nil, secondary: AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails? = nil) {
            self.primary = primary
            self.secondary = secondary
        }

        public func validate(name: String) throws {
            try self.primary?.validate(name: "\(name).primary")
            try self.secondary?.validate(name: "\(name).secondary")
        }

        private enum CodingKeys: String, CodingKey {
            case primary = "Primary"
            case secondary = "Secondary"
        }
    }

    public struct AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the health check used by the endpoint to determine whether failover is triggered.
        public let healthCheck: String?

        @inlinable
        public init(healthCheck: String? = nil) {
            self.healthCheck = healthCheck
        }

        public func validate(name: String) throws {
            try self.validate(self.healthCheck, name: "healthCheck", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheck = "HealthCheck"
        }
    }

    public struct AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Defines the secondary Region.
        public let route: String?

        @inlinable
        public init(route: String? = nil) {
            self.route = route
        }

        public func validate(name: String) throws {
            try self.validate(self.route, name: "route", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case route = "Route"
        }
    }

    public struct AwsEventsEventbusDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the account permitted to write events to the current account.
        public let arn: String?
        ///  The name of the event bus.
        public let name: String?
        ///  The policy that enables the external account to send events to your account.
        public let policy: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil, policy: String? = nil) {
            self.arn = arn
            self.name = name
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.policy, name: "policy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
            case policy = "Policy"
        }
    }

    public struct AwsGuardDutyDetectorDataSourcesCloudTrailDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies whether CloudTrail is activated as a data source for the detector.
        public let status: String?

        @inlinable
        public init(status: String? = nil) {
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct AwsGuardDutyDetectorDataSourcesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  An object that contains information on the status of CloudTrail as a data source for the detector.
        public let cloudTrail: AwsGuardDutyDetectorDataSourcesCloudTrailDetails?
        ///  An object that contains information on the status of DNS logs as a data source for the detector.
        public let dnsLogs: AwsGuardDutyDetectorDataSourcesDnsLogsDetails?
        ///  An object that contains information on the status of VPC Flow Logs as a data source for the detector.
        public let flowLogs: AwsGuardDutyDetectorDataSourcesFlowLogsDetails?
        ///  An object that contains information on the status of Kubernetes data sources for the detector.
        public let kubernetes: AwsGuardDutyDetectorDataSourcesKubernetesDetails?
        ///  An object that contains information on the status of Malware Protection as a data source for the detector.
        public let malwareProtection: AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails?
        ///  An object that contains information on the status of S3 Data event logs as a data source for the detector.
        public let s3Logs: AwsGuardDutyDetectorDataSourcesS3LogsDetails?

        @inlinable
        public init(cloudTrail: AwsGuardDutyDetectorDataSourcesCloudTrailDetails? = nil, dnsLogs: AwsGuardDutyDetectorDataSourcesDnsLogsDetails? = nil, flowLogs: AwsGuardDutyDetectorDataSourcesFlowLogsDetails? = nil, kubernetes: AwsGuardDutyDetectorDataSourcesKubernetesDetails? = nil, malwareProtection: AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails? = nil, s3Logs: AwsGuardDutyDetectorDataSourcesS3LogsDetails? = nil) {
            self.cloudTrail = cloudTrail
            self.dnsLogs = dnsLogs
            self.flowLogs = flowLogs
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }

        public func validate(name: String) throws {
            try self.cloudTrail?.validate(name: "\(name).cloudTrail")
            try self.dnsLogs?.validate(name: "\(name).dnsLogs")
            try self.flowLogs?.validate(name: "\(name).flowLogs")
            try self.kubernetes?.validate(name: "\(name).kubernetes")
            try self.malwareProtection?.validate(name: "\(name).malwareProtection")
            try self.s3Logs?.validate(name: "\(name).s3Logs")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudTrail = "CloudTrail"
            case dnsLogs = "DnsLogs"
            case flowLogs = "FlowLogs"
            case kubernetes = "Kubernetes"
            case malwareProtection = "MalwareProtection"
            case s3Logs = "S3Logs"
        }
    }

    public struct AwsGuardDutyDetectorDataSourcesDnsLogsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Describes whether DNS logs is enabled as a data source for the detector.
        public let status: String?

        @inlinable
        public init(status: String? = nil) {
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct AwsGuardDutyDetectorDataSourcesFlowLogsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Describes whether VPC Flow Logs are activated as a data source for the detector.
        public let status: String?

        @inlinable
        public init(status: String? = nil) {
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Describes whether Kubernetes audit logs are activated as a data source for the detector.
        public let status: String?

        @inlinable
        public init(status: String? = nil) {
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct AwsGuardDutyDetectorDataSourcesKubernetesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Describes whether Kubernetes audit logs are activated as a data source for the detector.
        public let auditLogs: AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails?

        @inlinable
        public init(auditLogs: AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails? = nil) {
            self.auditLogs = auditLogs
        }

        public func validate(name: String) throws {
            try self.auditLogs?.validate(name: "\(name).auditLogs")
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs = "AuditLogs"
        }
    }

    public struct AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Describes the configuration of Malware Protection for EC2 instances with findings.
        public let scanEc2InstanceWithFindings: AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails?
        ///  The GuardDuty Malware Protection service role.
        public let serviceRole: String?

        @inlinable
        public init(scanEc2InstanceWithFindings: AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails? = nil, serviceRole: String? = nil) {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
            self.serviceRole = serviceRole
        }

        public func validate(name: String) throws {
            try self.scanEc2InstanceWithFindings?.validate(name: "\(name).scanEc2InstanceWithFindings")
            try self.validate(self.serviceRole, name: "serviceRole", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case scanEc2InstanceWithFindings = "ScanEc2InstanceWithFindings"
            case serviceRole = "ServiceRole"
        }
    }

    public struct AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Describes the configuration of scanning EBS volumes (Malware Protection) as a data source.
        public let ebsVolumes: AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails?

        @inlinable
        public init(ebsVolumes: AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails? = nil) {
            self.ebsVolumes = ebsVolumes
        }

        public func validate(name: String) throws {
            try self.ebsVolumes?.validate(name: "\(name).ebsVolumes")
        }

        private enum CodingKeys: String, CodingKey {
            case ebsVolumes = "EbsVolumes"
        }
    }

    public struct AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies the reason why scanning EBS volumes (Malware Protection) isnâ€™t activated as a data source.
        public let reason: String?
        ///  Describes whether scanning EBS volumes is activated as a data source for the detector.
        public let status: String?

        @inlinable
        public init(reason: String? = nil, status: String? = nil) {
            self.reason = reason
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.reason, name: "reason", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "Reason"
            case status = "Status"
        }
    }

    public struct AwsGuardDutyDetectorDataSourcesS3LogsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  A value that describes whether S3 data event logs are automatically enabled for new members of an organization.
        public let status: String?

        @inlinable
        public init(status: String? = nil) {
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct AwsGuardDutyDetectorDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Describes which data sources are activated for the detector.
        public let dataSources: AwsGuardDutyDetectorDataSourcesDetails?
        ///  Describes which features are activated for the detector.
        public let features: [AwsGuardDutyDetectorFeaturesDetails]?
        ///  The publishing frequency of the finding.
        public let findingPublishingFrequency: String?
        ///  The GuardDuty service role.
        public let serviceRole: String?
        ///  The activation status of the detector.
        public let status: String?

        @inlinable
        public init(dataSources: AwsGuardDutyDetectorDataSourcesDetails? = nil, features: [AwsGuardDutyDetectorFeaturesDetails]? = nil, findingPublishingFrequency: String? = nil, serviceRole: String? = nil, status: String? = nil) {
            self.dataSources = dataSources
            self.features = features
            self.findingPublishingFrequency = findingPublishingFrequency
            self.serviceRole = serviceRole
            self.status = status
        }

        public func validate(name: String) throws {
            try self.dataSources?.validate(name: "\(name).dataSources")
            try self.features?.forEach {
                try $0.validate(name: "\(name).features[]")
            }
            try self.validate(self.findingPublishingFrequency, name: "findingPublishingFrequency", parent: name, pattern: "\\S")
            try self.validate(self.serviceRole, name: "serviceRole", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "DataSources"
            case features = "Features"
            case findingPublishingFrequency = "FindingPublishingFrequency"
            case serviceRole = "ServiceRole"
            case status = "Status"
        }
    }

    public struct AwsGuardDutyDetectorFeaturesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates the name of the feature that is activated for the detector.
        public let name: String?
        ///  Indicates the status of the feature that is activated for the detector.
        public let status: String?

        @inlinable
        public init(name: String? = nil, status: String? = nil) {
            self.name = name
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case status = "Status"
        }
    }

    public struct AwsIamAccessKeyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the access key.
        public let accessKeyId: String?
        /// The Amazon Web Services account ID of the account for the key.
        public let accountId: String?
        /// Indicates when the IAM access key was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdAt: String?
        /// The ID of the principal associated with an access key.
        public let principalId: String?
        /// The name of the principal.
        public let principalName: String?
        /// The type of principal associated with an access key.
        public let principalType: String?
        /// Information about the session that the key was used for.
        public let sessionContext: AwsIamAccessKeySessionContext?
        /// The status of the IAM access key related to a finding.
        public let status: AwsIamAccessKeyStatus?
        /// The user associated with the IAM access key related to a finding. The UserName parameter has been replaced with the PrincipalName parameter because access keys can also be assigned to principals that are not IAM users.
        public let userName: String?

        @inlinable
        public init(accessKeyId: String? = nil, accountId: String? = nil, createdAt: String? = nil, principalId: String? = nil, principalName: String? = nil, principalType: String? = nil, sessionContext: AwsIamAccessKeySessionContext? = nil, status: AwsIamAccessKeyStatus? = nil) {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.createdAt = createdAt
            self.principalId = principalId
            self.principalName = principalName
            self.principalType = principalType
            self.sessionContext = sessionContext
            self.status = status
            self.userName = nil
        }

        @available(*, deprecated, message: "Members userName have been deprecated")
        @inlinable
        public init(accessKeyId: String? = nil, accountId: String? = nil, createdAt: String? = nil, principalId: String? = nil, principalName: String? = nil, principalType: String? = nil, sessionContext: AwsIamAccessKeySessionContext? = nil, status: AwsIamAccessKeyStatus? = nil, userName: String? = nil) {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.createdAt = createdAt
            self.principalId = principalId
            self.principalName = principalName
            self.principalType = principalType
            self.sessionContext = sessionContext
            self.status = status
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.accessKeyId, name: "accessKeyId", parent: name, pattern: "\\S")
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\S")
            try self.validate(self.createdAt, name: "createdAt", parent: name, pattern: "\\S")
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "\\S")
            try self.validate(self.principalName, name: "principalName", parent: name, pattern: "\\S")
            try self.validate(self.principalType, name: "principalType", parent: name, pattern: "\\S")
            try self.sessionContext?.validate(name: "\(name).sessionContext")
            try self.validate(self.userName, name: "userName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "AccessKeyId"
            case accountId = "AccountId"
            case createdAt = "CreatedAt"
            case principalId = "PrincipalId"
            case principalName = "PrincipalName"
            case principalType = "PrincipalType"
            case sessionContext = "SessionContext"
            case status = "Status"
            case userName = "UserName"
        }
    }

    public struct AwsIamAccessKeySessionContext: AWSEncodableShape & AWSDecodableShape {
        /// Attributes of the session that the key was used for.
        public let attributes: AwsIamAccessKeySessionContextAttributes?
        /// Information about the entity that created the session.
        public let sessionIssuer: AwsIamAccessKeySessionContextSessionIssuer?

        @inlinable
        public init(attributes: AwsIamAccessKeySessionContextAttributes? = nil, sessionIssuer: AwsIamAccessKeySessionContextSessionIssuer? = nil) {
            self.attributes = attributes
            self.sessionIssuer = sessionIssuer
        }

        public func validate(name: String) throws {
            try self.attributes?.validate(name: "\(name).attributes")
            try self.sessionIssuer?.validate(name: "\(name).sessionIssuer")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case sessionIssuer = "SessionIssuer"
        }
    }

    public struct AwsIamAccessKeySessionContextAttributes: AWSEncodableShape & AWSDecodableShape {
        /// Indicates when the session was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let creationDate: String?
        /// Indicates whether the session used multi-factor authentication (MFA).
        public let mfaAuthenticated: Bool?

        @inlinable
        public init(creationDate: String? = nil, mfaAuthenticated: Bool? = nil) {
            self.creationDate = creationDate
            self.mfaAuthenticated = mfaAuthenticated
        }

        public func validate(name: String) throws {
            try self.validate(self.creationDate, name: "creationDate", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case mfaAuthenticated = "MfaAuthenticated"
        }
    }

    public struct AwsIamAccessKeySessionContextSessionIssuer: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the Amazon Web Services account that created the session.
        public let accountId: String?
        /// The ARN of the session.
        public let arn: String?
        /// The principal ID of the principal (user, role, or group) that created the session.
        public let principalId: String?
        /// The type of principal (user, role, or group) that created the session.
        public let type: String?
        /// The name of the principal that created the session.
        public let userName: String?

        @inlinable
        public init(accountId: String? = nil, arn: String? = nil, principalId: String? = nil, type: String? = nil, userName: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.type = type
            self.userName = userName
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "\\S")
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.validate(self.userName, name: "userName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case arn = "Arn"
            case principalId = "PrincipalId"
            case type = "Type"
            case userName = "UserName"
        }
    }

    public struct AwsIamAttachedManagedPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the policy.
        public let policyArn: String?
        /// The name of the policy.
        public let policyName: String?

        @inlinable
        public init(policyArn: String? = nil, policyName: String? = nil) {
            self.policyArn = policyArn
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyArn, name: "policyArn", parent: name, pattern: "\\S")
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case policyArn = "PolicyArn"
            case policyName = "PolicyName"
        }
    }

    public struct AwsIamGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// A list of the managed policies that are attached to the IAM group.
        public let attachedManagedPolicies: [AwsIamAttachedManagedPolicy]?
        /// Indicates when the IAM group was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createDate: String?
        /// The identifier of the IAM group.
        public let groupId: String?
        /// The name of the IAM group.
        public let groupName: String?
        /// The list of inline policies that are embedded in the group.
        public let groupPolicyList: [AwsIamGroupPolicy]?
        /// The path to the group.
        public let path: String?

        @inlinable
        public init(attachedManagedPolicies: [AwsIamAttachedManagedPolicy]? = nil, createDate: String? = nil, groupId: String? = nil, groupName: String? = nil, groupPolicyList: [AwsIamGroupPolicy]? = nil, path: String? = nil) {
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.groupPolicyList = groupPolicyList
            self.path = path
        }

        public func validate(name: String) throws {
            try self.attachedManagedPolicies?.forEach {
                try $0.validate(name: "\(name).attachedManagedPolicies[]")
            }
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.validate(self.groupId, name: "groupId", parent: name, pattern: "\\S")
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "\\S")
            try self.groupPolicyList?.forEach {
                try $0.validate(name: "\(name).groupPolicyList[]")
            }
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attachedManagedPolicies = "AttachedManagedPolicies"
            case createDate = "CreateDate"
            case groupId = "GroupId"
            case groupName = "GroupName"
            case groupPolicyList = "GroupPolicyList"
            case path = "Path"
        }
    }

    public struct AwsIamGroupPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The name of the policy.
        public let policyName: String?

        @inlinable
        public init(policyName: String? = nil) {
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "PolicyName"
        }
    }

    public struct AwsIamInstanceProfile: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the instance profile.
        public let arn: String?
        /// Indicates when the instance profile was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createDate: String?
        /// The identifier of the instance profile.
        public let instanceProfileId: String?
        /// The name of the instance profile.
        public let instanceProfileName: String?
        /// The path to the instance profile.
        public let path: String?
        /// The roles associated with the instance profile.
        public let roles: [AwsIamInstanceProfileRole]?

        @inlinable
        public init(arn: String? = nil, createDate: String? = nil, instanceProfileId: String? = nil, instanceProfileName: String? = nil, path: String? = nil, roles: [AwsIamInstanceProfileRole]? = nil) {
            self.arn = arn
            self.createDate = createDate
            self.instanceProfileId = instanceProfileId
            self.instanceProfileName = instanceProfileName
            self.path = path
            self.roles = roles
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.validate(self.instanceProfileId, name: "instanceProfileId", parent: name, pattern: "\\S")
            try self.validate(self.instanceProfileName, name: "instanceProfileName", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.roles?.forEach {
                try $0.validate(name: "\(name).roles[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createDate = "CreateDate"
            case instanceProfileId = "InstanceProfileId"
            case instanceProfileName = "InstanceProfileName"
            case path = "Path"
            case roles = "Roles"
        }
    }

    public struct AwsIamInstanceProfileRole: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the role.
        public let arn: String?
        /// The policy that grants an entity permission to assume the role.
        public let assumeRolePolicyDocument: String?
        /// Indicates when the role was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createDate: String?
        /// The path to the role.
        public let path: String?
        /// The identifier of the role.
        public let roleId: String?
        /// The name of the role.
        public let roleName: String?

        @inlinable
        public init(arn: String? = nil, assumeRolePolicyDocument: String? = nil, createDate: String? = nil, path: String? = nil, roleId: String? = nil, roleName: String? = nil) {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.createDate = createDate
            self.path = path
            self.roleId = roleId
            self.roleName = roleName
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, max: 131072)
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, min: 1)
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+$")
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.validate(self.roleId, name: "roleId", parent: name, pattern: "\\S")
            try self.validate(self.roleName, name: "roleName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
            case createDate = "CreateDate"
            case path = "Path"
            case roleId = "RoleId"
            case roleName = "RoleName"
        }
    }

    public struct AwsIamPermissionsBoundary: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the policy used to set the permissions boundary.
        public let permissionsBoundaryArn: String?
        /// The usage type for the permissions boundary.
        public let permissionsBoundaryType: String?

        @inlinable
        public init(permissionsBoundaryArn: String? = nil, permissionsBoundaryType: String? = nil) {
            self.permissionsBoundaryArn = permissionsBoundaryArn
            self.permissionsBoundaryType = permissionsBoundaryType
        }

        public func validate(name: String) throws {
            try self.validate(self.permissionsBoundaryArn, name: "permissionsBoundaryArn", parent: name, pattern: "\\S")
            try self.validate(self.permissionsBoundaryType, name: "permissionsBoundaryType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case permissionsBoundaryArn = "PermissionsBoundaryArn"
            case permissionsBoundaryType = "PermissionsBoundaryType"
        }
    }

    public struct AwsIamPolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of users, groups, and roles that the policy is attached to.
        public let attachmentCount: Int?
        /// When the policy was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createDate: String?
        /// The identifier of the default version of the policy.
        public let defaultVersionId: String?
        /// A description of the policy.
        public let description: String?
        /// Whether the policy can be attached to a user, group, or role.
        public let isAttachable: Bool?
        /// The path to the policy.
        public let path: String?
        /// The number of users and roles that use the policy to set the permissions boundary.
        public let permissionsBoundaryUsageCount: Int?
        /// The unique identifier of the policy.
        public let policyId: String?
        /// The name of the policy.
        public let policyName: String?
        /// List of versions of the policy.
        public let policyVersionList: [AwsIamPolicyVersion]?
        /// When the policy was most recently updated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let updateDate: String?

        @inlinable
        public init(attachmentCount: Int? = nil, createDate: String? = nil, defaultVersionId: String? = nil, description: String? = nil, isAttachable: Bool? = nil, path: String? = nil, permissionsBoundaryUsageCount: Int? = nil, policyId: String? = nil, policyName: String? = nil, policyVersionList: [AwsIamPolicyVersion]? = nil, updateDate: String? = nil) {
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.policyVersionList = policyVersionList
            self.updateDate = updateDate
        }

        public func validate(name: String) throws {
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.validate(self.defaultVersionId, name: "defaultVersionId", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.validate(self.policyId, name: "policyId", parent: name, pattern: "\\S")
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
            try self.policyVersionList?.forEach {
                try $0.validate(name: "\(name).policyVersionList[]")
            }
            try self.validate(self.updateDate, name: "updateDate", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentCount = "AttachmentCount"
            case createDate = "CreateDate"
            case defaultVersionId = "DefaultVersionId"
            case description = "Description"
            case isAttachable = "IsAttachable"
            case path = "Path"
            case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
            case policyId = "PolicyId"
            case policyName = "PolicyName"
            case policyVersionList = "PolicyVersionList"
            case updateDate = "UpdateDate"
        }
    }

    public struct AwsIamPolicyVersion: AWSEncodableShape & AWSDecodableShape {
        /// Indicates when the version was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createDate: String?
        /// Whether the version is the default version.
        public let isDefaultVersion: Bool?
        /// The identifier of the policy version.
        public let versionId: String?

        @inlinable
        public init(createDate: String? = nil, isDefaultVersion: Bool? = nil, versionId: String? = nil) {
            self.createDate = createDate
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case createDate = "CreateDate"
            case isDefaultVersion = "IsDefaultVersion"
            case versionId = "VersionId"
        }
    }

    public struct AwsIamRoleDetails: AWSEncodableShape & AWSDecodableShape {
        /// The trust policy that grants permission to assume the role.
        public let assumeRolePolicyDocument: String?
        /// The list of the managed policies that are attached to the role.
        public let attachedManagedPolicies: [AwsIamAttachedManagedPolicy]?
        /// Indicates when the role was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createDate: String?
        /// The list of instance profiles that contain this role.
        public let instanceProfileList: [AwsIamInstanceProfile]?
        /// The maximum session duration (in seconds) that you want to set for the specified role.
        public let maxSessionDuration: Int?
        /// The path to the role.
        public let path: String?
        public let permissionsBoundary: AwsIamPermissionsBoundary?
        /// The stable and unique string identifying the role.
        public let roleId: String?
        /// The friendly name that identifies the role.
        public let roleName: String?
        /// The list of inline policies that are embedded in the role.
        public let rolePolicyList: [AwsIamRolePolicy]?

        @inlinable
        public init(assumeRolePolicyDocument: String? = nil, attachedManagedPolicies: [AwsIamAttachedManagedPolicy]? = nil, createDate: String? = nil, instanceProfileList: [AwsIamInstanceProfile]? = nil, maxSessionDuration: Int? = nil, path: String? = nil, permissionsBoundary: AwsIamPermissionsBoundary? = nil, roleId: String? = nil, roleName: String? = nil, rolePolicyList: [AwsIamRolePolicy]? = nil) {
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.instanceProfileList = instanceProfileList
            self.maxSessionDuration = maxSessionDuration
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleName = roleName
            self.rolePolicyList = rolePolicyList
        }

        public func validate(name: String) throws {
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, max: 131072)
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, min: 1)
            try self.validate(self.assumeRolePolicyDocument, name: "assumeRolePolicyDocument", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+$")
            try self.attachedManagedPolicies?.forEach {
                try $0.validate(name: "\(name).attachedManagedPolicies[]")
            }
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.instanceProfileList?.forEach {
                try $0.validate(name: "\(name).instanceProfileList[]")
            }
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.permissionsBoundary?.validate(name: "\(name).permissionsBoundary")
            try self.validate(self.roleId, name: "roleId", parent: name, pattern: "\\S")
            try self.validate(self.roleName, name: "roleName", parent: name, pattern: "\\S")
            try self.rolePolicyList?.forEach {
                try $0.validate(name: "\(name).rolePolicyList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
            case attachedManagedPolicies = "AttachedManagedPolicies"
            case createDate = "CreateDate"
            case instanceProfileList = "InstanceProfileList"
            case maxSessionDuration = "MaxSessionDuration"
            case path = "Path"
            case permissionsBoundary = "PermissionsBoundary"
            case roleId = "RoleId"
            case roleName = "RoleName"
            case rolePolicyList = "RolePolicyList"
        }
    }

    public struct AwsIamRolePolicy: AWSEncodableShape & AWSDecodableShape {
        /// The name of the policy.
        public let policyName: String?

        @inlinable
        public init(policyName: String? = nil) {
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "PolicyName"
        }
    }

    public struct AwsIamUserDetails: AWSEncodableShape & AWSDecodableShape {
        /// A list of the managed policies that are attached to the user.
        public let attachedManagedPolicies: [AwsIamAttachedManagedPolicy]?
        /// Indicates when the user was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createDate: String?
        /// A list of IAM groups that the user belongs to.
        public let groupList: [String]?
        /// The path to the user.
        public let path: String?
        /// The permissions boundary for the user.
        public let permissionsBoundary: AwsIamPermissionsBoundary?
        /// The unique identifier for the user.
        public let userId: String?
        /// The name of the user.
        public let userName: String?
        /// The list of inline policies that are embedded in the user.
        public let userPolicyList: [AwsIamUserPolicy]?

        @inlinable
        public init(attachedManagedPolicies: [AwsIamAttachedManagedPolicy]? = nil, createDate: String? = nil, groupList: [String]? = nil, path: String? = nil, permissionsBoundary: AwsIamPermissionsBoundary? = nil, userId: String? = nil, userName: String? = nil, userPolicyList: [AwsIamUserPolicy]? = nil) {
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupList = groupList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.userId = userId
            self.userName = userName
            self.userPolicyList = userPolicyList
        }

        public func validate(name: String) throws {
            try self.attachedManagedPolicies?.forEach {
                try $0.validate(name: "\(name).attachedManagedPolicies[]")
            }
            try self.validate(self.createDate, name: "createDate", parent: name, pattern: "\\S")
            try self.groupList?.forEach {
                try validate($0, name: "groupList[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.permissionsBoundary?.validate(name: "\(name).permissionsBoundary")
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
            try self.validate(self.userName, name: "userName", parent: name, pattern: "\\S")
            try self.userPolicyList?.forEach {
                try $0.validate(name: "\(name).userPolicyList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attachedManagedPolicies = "AttachedManagedPolicies"
            case createDate = "CreateDate"
            case groupList = "GroupList"
            case path = "Path"
            case permissionsBoundary = "PermissionsBoundary"
            case userId = "UserId"
            case userName = "UserName"
            case userPolicyList = "UserPolicyList"
        }
    }

    public struct AwsIamUserPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The name of the policy.
        public let policyName: String?

        @inlinable
        public init(policyName: String? = nil) {
            self.policyName = policyName
        }

        public func validate(name: String) throws {
            try self.validate(self.policyName, name: "policyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case policyName = "PolicyName"
        }
    }

    public struct AwsKinesisStreamDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        public let arn: String?
        /// The name of the Kinesis stream. If you don't specify a name, CloudFront generates a unique
        /// physical ID and uses that ID for the stream name.
        public let name: String?
        /// The number of hours for the data records that are stored in shards to remain accessible.
        public let retentionPeriodHours: Int?
        /// The number of shards that the stream uses.
        public let shardCount: Int?
        /// When specified, enables or updates server-side encryption using an KMS key for a specified stream.
        /// Removing this property from your stack template and updating your stack disables encryption.
        public let streamEncryption: AwsKinesisStreamStreamEncryptionDetails?

        @inlinable
        public init(arn: String? = nil, name: String? = nil, retentionPeriodHours: Int? = nil, shardCount: Int? = nil, streamEncryption: AwsKinesisStreamStreamEncryptionDetails? = nil) {
            self.arn = arn
            self.name = name
            self.retentionPeriodHours = retentionPeriodHours
            self.shardCount = shardCount
            self.streamEncryption = streamEncryption
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.streamEncryption?.validate(name: "\(name).streamEncryption")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
            case retentionPeriodHours = "RetentionPeriodHours"
            case shardCount = "ShardCount"
            case streamEncryption = "StreamEncryption"
        }
    }

    public struct AwsKinesisStreamStreamEncryptionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The encryption type to use.
        public let encryptionType: String?
        /// The globally unique identifier for the customer-managed KMS key to use for encryption.
        public let keyId: String?

        @inlinable
        public init(encryptionType: String? = nil, keyId: String? = nil) {
            self.encryptionType = encryptionType
            self.keyId = keyId
        }

        public func validate(name: String) throws {
            try self.validate(self.encryptionType, name: "encryptionType", parent: name, pattern: "\\S")
            try self.validate(self.keyId, name: "keyId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "EncryptionType"
            case keyId = "KeyId"
        }
    }

    public struct AwsKmsKeyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The twelve-digit account ID of the Amazon Web Services account that owns the KMS key.
        public let awsAccountId: String?
        /// Indicates when the KMS key was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let creationDate: Double?
        /// A description of the KMS key.
        public let description: String?
        /// The globally unique identifier for the KMS key.
        public let keyId: String?
        /// The manager of the KMS key. KMS keys in your Amazon Web Services account are either customer managed or Amazon Web Services managed.
        public let keyManager: String?
        /// Whether the key has key rotation enabled.
        public let keyRotationStatus: Bool?
        /// The state of the KMS key. Valid values are as follows:    Disabled     Enabled     PendingDeletion     PendingImport     Unavailable
        public let keyState: String?
        /// The source of the KMS key material. When this value is AWS_KMS, KMS created the key material. When this value is EXTERNAL, the key material was imported from your existing key management infrastructure or the KMS key lacks key material. When this value is AWS_CLOUDHSM, the key material was created in the CloudHSM cluster associated with a custom key store.
        public let origin: String?

        @inlinable
        public init(awsAccountId: String? = nil, creationDate: Double? = nil, description: String? = nil, keyId: String? = nil, keyManager: String? = nil, keyRotationStatus: Bool? = nil, keyState: String? = nil, origin: String? = nil) {
            self.awsAccountId = awsAccountId
            self.creationDate = creationDate
            self.description = description
            self.keyId = keyId
            self.keyManager = keyManager
            self.keyRotationStatus = keyRotationStatus
            self.keyState = keyState
            self.origin = origin
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.keyId, name: "keyId", parent: name, pattern: "\\S")
            try self.validate(self.keyManager, name: "keyManager", parent: name, pattern: "\\S")
            try self.validate(self.keyState, name: "keyState", parent: name, pattern: "\\S")
            try self.validate(self.origin, name: "origin", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AWSAccountId"
            case creationDate = "CreationDate"
            case description = "Description"
            case keyId = "KeyId"
            case keyManager = "KeyManager"
            case keyRotationStatus = "KeyRotationStatus"
            case keyState = "KeyState"
            case origin = "Origin"
        }
    }

    public struct AwsLambdaFunctionCode: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public let s3Bucket: String?
        /// The Amazon S3 key of the deployment package.
        public let s3Key: String?
        /// For versioned objects, the version of the deployment package object to use.
        public let s3ObjectVersion: String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public let zipFile: String?

        @inlinable
        public init(s3Bucket: String? = nil, s3Key: String? = nil, s3ObjectVersion: String? = nil, zipFile: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Bucket, name: "s3Bucket", parent: name, pattern: "\\S")
            try self.validate(self.s3Key, name: "s3Key", parent: name, pattern: "\\S")
            try self.validate(self.s3ObjectVersion, name: "s3ObjectVersion", parent: name, pattern: "\\S")
            try self.validate(self.zipFile, name: "zipFile", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket = "S3Bucket"
            case s3Key = "S3Key"
            case s3ObjectVersion = "S3ObjectVersion"
            case zipFile = "ZipFile"
        }
    }

    public struct AwsLambdaFunctionDeadLetterConfig: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of an SQS queue or SNS topic.
        public let targetArn: String?

        @inlinable
        public init(targetArn: String? = nil) {
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.targetArn, name: "targetArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case targetArn = "TargetArn"
        }
    }

    public struct AwsLambdaFunctionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The instruction set architecture that the function uses. Valid values are x86_64 or
        /// arm64.
        public let architectures: [String]?
        /// An AwsLambdaFunctionCode object.
        public let code: AwsLambdaFunctionCode?
        /// The SHA256 hash of the function's deployment package.
        public let codeSha256: String?
        /// The function's dead letter queue.
        public let deadLetterConfig: AwsLambdaFunctionDeadLetterConfig?
        /// The function's environment variables.
        public let environment: AwsLambdaFunctionEnvironment?
        /// The name of the function.
        public let functionName: String?
        /// The function that Lambda calls to begin executing your function.
        public let handler: String?
        /// The KMS key that is used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed customer managed key.
        public let kmsKeyArn: String?
        /// Indicates when the function was last updated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastModified: String?
        /// The function's layers.
        public let layers: [AwsLambdaFunctionLayer]?
        /// For Lambda@Edge functions, the ARN of the master function.
        public let masterArn: String?
        /// The memory that is allocated to the function.
        public let memorySize: Int?
        /// The type of deployment package that's used to deploy the function code to Lambda. Set to Image for a container image and Zip  for a .zip file archive.
        public let packageType: String?
        /// The latest updated revision of the function or alias.
        public let revisionId: String?
        /// The function's execution role.
        public let role: String?
        /// The runtime environment for the Lambda function.
        public let runtime: String?
        /// The amount of time that Lambda allows a function to run before stopping it.
        public let timeout: Int?
        /// The function's X-Ray tracing configuration.
        public let tracingConfig: AwsLambdaFunctionTracingConfig?
        /// The version of the Lambda function.
        public let version: String?
        /// The function's networking configuration.
        public let vpcConfig: AwsLambdaFunctionVpcConfig?

        @inlinable
        public init(architectures: [String]? = nil, code: AwsLambdaFunctionCode? = nil, codeSha256: String? = nil, deadLetterConfig: AwsLambdaFunctionDeadLetterConfig? = nil, environment: AwsLambdaFunctionEnvironment? = nil, functionName: String? = nil, handler: String? = nil, kmsKeyArn: String? = nil, lastModified: String? = nil, layers: [AwsLambdaFunctionLayer]? = nil, masterArn: String? = nil, memorySize: Int? = nil, packageType: String? = nil, revisionId: String? = nil, role: String? = nil, runtime: String? = nil, timeout: Int? = nil, tracingConfig: AwsLambdaFunctionTracingConfig? = nil, version: String? = nil, vpcConfig: AwsLambdaFunctionVpcConfig? = nil) {
            self.architectures = architectures
            self.code = code
            self.codeSha256 = codeSha256
            self.deadLetterConfig = deadLetterConfig
            self.environment = environment
            self.functionName = functionName
            self.handler = handler
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.layers = layers
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.architectures?.forEach {
                try validate($0, name: "architectures[]", parent: name, pattern: "\\S")
            }
            try self.code?.validate(name: "\(name).code")
            try self.validate(self.codeSha256, name: "codeSha256", parent: name, pattern: "\\S")
            try self.deadLetterConfig?.validate(name: "\(name).deadLetterConfig")
            try self.environment?.validate(name: "\(name).environment")
            try self.validate(self.functionName, name: "functionName", parent: name, pattern: "\\S")
            try self.validate(self.handler, name: "handler", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "\\S")
            try self.validate(self.lastModified, name: "lastModified", parent: name, pattern: "\\S")
            try self.layers?.forEach {
                try $0.validate(name: "\(name).layers[]")
            }
            try self.validate(self.masterArn, name: "masterArn", parent: name, pattern: "\\S")
            try self.validate(self.packageType, name: "packageType", parent: name, pattern: "\\S")
            try self.validate(self.revisionId, name: "revisionId", parent: name, pattern: "\\S")
            try self.validate(self.role, name: "role", parent: name, pattern: "\\S")
            try self.validate(self.runtime, name: "runtime", parent: name, pattern: "\\S")
            try self.tracingConfig?.validate(name: "\(name).tracingConfig")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case architectures = "Architectures"
            case code = "Code"
            case codeSha256 = "CodeSha256"
            case deadLetterConfig = "DeadLetterConfig"
            case environment = "Environment"
            case functionName = "FunctionName"
            case handler = "Handler"
            case kmsKeyArn = "KmsKeyArn"
            case lastModified = "LastModified"
            case layers = "Layers"
            case masterArn = "MasterArn"
            case memorySize = "MemorySize"
            case packageType = "PackageType"
            case revisionId = "RevisionId"
            case role = "Role"
            case runtime = "Runtime"
            case timeout = "Timeout"
            case tracingConfig = "TracingConfig"
            case version = "Version"
            case vpcConfig = "VpcConfig"
        }
    }

    public struct AwsLambdaFunctionEnvironment: AWSEncodableShape & AWSDecodableShape {
        /// An AwsLambdaFunctionEnvironmentError object.
        public let error: AwsLambdaFunctionEnvironmentError?
        /// Environment variable key-value pairs.
        public let variables: [String: String]?

        @inlinable
        public init(error: AwsLambdaFunctionEnvironmentError? = nil, variables: [String: String]? = nil) {
            self.error = error
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.error?.validate(name: "\(name).error")
            try self.variables?.forEach {
                try validate($0.key, name: "variables.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "variables[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case variables = "Variables"
        }
    }

    public struct AwsLambdaFunctionEnvironmentError: AWSEncodableShape & AWSDecodableShape {
        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?

        @inlinable
        public init(errorCode: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.message = message
        }

        public func validate(name: String) throws {
            try self.validate(self.errorCode, name: "errorCode", parent: name, pattern: "\\S")
            try self.validate(self.message, name: "message", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
        }
    }

    public struct AwsLambdaFunctionLayer: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the function layer.
        public let arn: String?
        /// The size of the layer archive in bytes.
        public let codeSize: Int?

        @inlinable
        public init(arn: String? = nil, codeSize: Int? = nil) {
            self.arn = arn
            self.codeSize = codeSize
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case codeSize = "CodeSize"
        }
    }

    public struct AwsLambdaFunctionTracingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The tracing mode.
        public let mode: String?

        @inlinable
        public init(mode: String? = nil) {
            self.mode = mode
        }

        public func validate(name: String) throws {
            try self.validate(self.mode, name: "mode", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
        }
    }

    public struct AwsLambdaFunctionVpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of VPC security groups IDs.
        public let securityGroupIds: [String]?
        /// A list of VPC subnet IDs.
        public let subnetIds: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        @inlinable
        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "\\S")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcId = "VpcId"
        }
    }

    public struct AwsLambdaLayerVersionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The layer's compatible function runtimes. The following list includes deprecated runtimes. For more information, see Runtime deprecation policy in the Lambda Developer Guide. Array Members: Maximum number of 5 items. Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21
        public let compatibleRuntimes: [String]?
        /// Indicates when the version was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdDate: String?
        /// The version number.
        public let version: Int64?

        @inlinable
        public init(compatibleRuntimes: [String]? = nil, createdDate: String? = nil, version: Int64? = nil) {
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.version = version
        }

        public func validate(name: String) throws {
            try self.compatibleRuntimes?.forEach {
                try validate($0, name: "compatibleRuntimes[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.createdDate, name: "createdDate", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleRuntimes = "CompatibleRuntimes"
            case createdDate = "CreatedDate"
            case version = "Version"
        }
    }

    public struct AwsMountPoint: AWSEncodableShape & AWSDecodableShape {
        /// The path on the container to mount the host volume at.
        public let containerPath: String?
        /// The name of the volume to mount. Must be a volume name referenced in the name parameter
        /// of task definition volume.
        public let sourceVolume: String?

        @inlinable
        public init(containerPath: String? = nil, sourceVolume: String? = nil) {
            self.containerPath = containerPath
            self.sourceVolume = sourceVolume
        }

        public func validate(name: String) throws {
            try self.validate(self.containerPath, name: "containerPath", parent: name, pattern: "\\S")
            try self.validate(self.sourceVolume, name: "sourceVolume", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case containerPath = "ContainerPath"
            case sourceVolume = "SourceVolume"
        }
    }

    public struct AwsMskClusterClusterInfoClientAuthenticationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Provides details for client authentication using SASL.
        public let sasl: AwsMskClusterClusterInfoClientAuthenticationSaslDetails?
        ///  Provides details for client authentication using TLS.
        public let tls: AwsMskClusterClusterInfoClientAuthenticationTlsDetails?
        ///  Provides details for allowing no client authentication.
        public let unauthenticated: AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails?

        @inlinable
        public init(sasl: AwsMskClusterClusterInfoClientAuthenticationSaslDetails? = nil, tls: AwsMskClusterClusterInfoClientAuthenticationTlsDetails? = nil, unauthenticated: AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails? = nil) {
            self.sasl = sasl
            self.tls = tls
            self.unauthenticated = unauthenticated
        }

        public func validate(name: String) throws {
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case sasl = "Sasl"
            case tls = "Tls"
            case unauthenticated = "Unauthenticated"
        }
    }

    public struct AwsMskClusterClusterInfoClientAuthenticationSaslDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Provides details for SASL client authentication using IAM.
        public let iam: AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails?
        ///  Details for SASL client authentication using SCRAM.
        public let scram: AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails?

        @inlinable
        public init(iam: AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails? = nil, scram: AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails? = nil) {
            self.iam = iam
            self.scram = scram
        }

        private enum CodingKeys: String, CodingKey {
            case iam = "Iam"
            case scram = "Scram"
        }
    }

    public struct AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether SASL/IAM authentication is enabled or not.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether SASL/SCRAM authentication is enabled or not.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsMskClusterClusterInfoClientAuthenticationTlsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  List of Amazon Web Services Private CA Amazon Resource Names (ARNs). Amazon Web Services Private CA enables creation of
        /// private certificate authority (CA) hierarchies, including root and subordinate CAs, without the investment and maintenance costs
        /// of operating an on-premises CA.
        public let certificateAuthorityArnList: [String]?
        ///  Indicates whether TLS authentication is enabled or not.
        public let enabled: Bool?

        @inlinable
        public init(certificateAuthorityArnList: [String]? = nil, enabled: Bool? = nil) {
            self.certificateAuthorityArnList = certificateAuthorityArnList
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.certificateAuthorityArnList?.forEach {
                try validate($0, name: "certificateAuthorityArnList[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArnList = "CertificateAuthorityArnList"
            case enabled = "Enabled"
        }
    }

    public struct AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether unauthenticated is allowed or not.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsMskClusterClusterInfoDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Provides information for different modes of client authentication.
        public let clientAuthentication: AwsMskClusterClusterInfoClientAuthenticationDetails?
        ///  The name of the cluster.
        public let clusterName: String?
        ///  The current version of the cluster.
        public let currentVersion: String?
        ///  Includes encryption-related information, such as the KMS key used for encrypting data at rest and
        /// whether you want Amazon MSK to encrypt your data in transit.
        public let encryptionInfo: AwsMskClusterClusterInfoEncryptionInfoDetails?
        ///  Specifies the level of monitoring for the cluster.
        public let enhancedMonitoring: String?
        ///  The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int?

        @inlinable
        public init(clientAuthentication: AwsMskClusterClusterInfoClientAuthenticationDetails? = nil, clusterName: String? = nil, currentVersion: String? = nil, encryptionInfo: AwsMskClusterClusterInfoEncryptionInfoDetails? = nil, enhancedMonitoring: String? = nil, numberOfBrokerNodes: Int? = nil) {
            self.clientAuthentication = clientAuthentication
            self.clusterName = clusterName
            self.currentVersion = currentVersion
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.numberOfBrokerNodes = numberOfBrokerNodes
        }

        public func validate(name: String) throws {
            try self.clientAuthentication?.validate(name: "\(name).clientAuthentication")
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "\\S")
            try self.validate(self.currentVersion, name: "currentVersion", parent: name, pattern: "\\S")
            try self.encryptionInfo?.validate(name: "\(name).encryptionInfo")
            try self.validate(self.enhancedMonitoring, name: "enhancedMonitoring", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clientAuthentication = "ClientAuthentication"
            case clusterName = "ClusterName"
            case currentVersion = "CurrentVersion"
            case encryptionInfo = "EncryptionInfo"
            case enhancedMonitoring = "EnhancedMonitoring"
            case numberOfBrokerNodes = "NumberOfBrokerNodes"
        }
    }

    public struct AwsMskClusterClusterInfoEncryptionInfoDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The data-volume encryption details. You can't update encryption at rest settings for existing clusters.
        public let encryptionAtRest: AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails?
        ///  The settings for encrypting data in transit.
        public let encryptionInTransit: AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails?

        @inlinable
        public init(encryptionAtRest: AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails? = nil, encryptionInTransit: AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails? = nil) {
            self.encryptionAtRest = encryptionAtRest
            self.encryptionInTransit = encryptionInTransit
        }

        public func validate(name: String) throws {
            try self.encryptionAtRest?.validate(name: "\(name).encryptionAtRest")
            try self.encryptionInTransit?.validate(name: "\(name).encryptionInTransit")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAtRest = "EncryptionAtRest"
            case encryptionInTransit = "EncryptionInTransit"
        }
    }

    public struct AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the KMS key for encrypting data at rest. If you don't specify a
        /// KMS key, MSK creates one for you and uses it.
        public let dataVolumeKMSKeyId: String?

        @inlinable
        public init(dataVolumeKMSKeyId: String? = nil) {
            self.dataVolumeKMSKeyId = dataVolumeKMSKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.dataVolumeKMSKeyId, name: "dataVolumeKMSKeyId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataVolumeKMSKeyId = "DataVolumeKMSKeyId"
        }
    }

    public struct AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates the encryption setting for data in transit between clients and brokers.
        public let clientBroker: String?
        ///  When set to true, it indicates that data communication among the broker nodes of the cluster is  encrypted. When set to false, the communication happens in plain text. The default value is  true.
        public let inCluster: Bool?

        @inlinable
        public init(clientBroker: String? = nil, inCluster: Bool? = nil) {
            self.clientBroker = clientBroker
            self.inCluster = inCluster
        }

        public func validate(name: String) throws {
            try self.validate(self.clientBroker, name: "clientBroker", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clientBroker = "ClientBroker"
            case inCluster = "InCluster"
        }
    }

    public struct AwsMskClusterDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Provides information about a cluster.
        public let clusterInfo: AwsMskClusterClusterInfoDetails?

        @inlinable
        public init(clusterInfo: AwsMskClusterClusterInfoDetails? = nil) {
            self.clusterInfo = clusterInfo
        }

        public func validate(name: String) throws {
            try self.clusterInfo?.validate(name: "\(name).clusterInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfo = "ClusterInfo"
        }
    }

    public struct AwsNetworkFirewallFirewallDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the firewall is protected from deletion. If set to true, then the firewall cannot be deleted.
        public let deleteProtection: Bool?
        /// A description of the firewall.
        public let description: String?
        /// The ARN of the firewall.
        public let firewallArn: String?
        /// The identifier of the firewall.
        public let firewallId: String?
        /// A descriptive name of the firewall.
        public let firewallName: String?
        /// The ARN of the firewall policy.
        public let firewallPolicyArn: String?
        /// Whether the firewall is protected from a change to the firewall policy. If set to true, you cannot associate a different policy with the firewall.
        public let firewallPolicyChangeProtection: Bool?
        /// Whether the firewall is protected from a change to the subnet associations. If set to true, you cannot map different subnets to the firewall.
        public let subnetChangeProtection: Bool?
        /// The public subnets that Network Firewall uses for the firewall. Each subnet must belong to a different Availability Zone.
        public let subnetMappings: [AwsNetworkFirewallFirewallSubnetMappingsDetails]?
        /// The identifier of the VPC where the firewall is used.
        public let vpcId: String?

        @inlinable
        public init(deleteProtection: Bool? = nil, description: String? = nil, firewallArn: String? = nil, firewallId: String? = nil, firewallName: String? = nil, firewallPolicyArn: String? = nil, firewallPolicyChangeProtection: Bool? = nil, subnetChangeProtection: Bool? = nil, subnetMappings: [AwsNetworkFirewallFirewallSubnetMappingsDetails]? = nil, vpcId: String? = nil) {
            self.deleteProtection = deleteProtection
            self.description = description
            self.firewallArn = firewallArn
            self.firewallId = firewallId
            self.firewallName = firewallName
            self.firewallPolicyArn = firewallPolicyArn
            self.firewallPolicyChangeProtection = firewallPolicyChangeProtection
            self.subnetChangeProtection = subnetChangeProtection
            self.subnetMappings = subnetMappings
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.firewallArn, name: "firewallArn", parent: name, pattern: "\\S")
            try self.validate(self.firewallId, name: "firewallId", parent: name, pattern: "\\S")
            try self.validate(self.firewallName, name: "firewallName", parent: name, pattern: "\\S")
            try self.validate(self.firewallPolicyArn, name: "firewallPolicyArn", parent: name, pattern: "\\S")
            try self.subnetMappings?.forEach {
                try $0.validate(name: "\(name).subnetMappings[]")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteProtection = "DeleteProtection"
            case description = "Description"
            case firewallArn = "FirewallArn"
            case firewallId = "FirewallId"
            case firewallName = "FirewallName"
            case firewallPolicyArn = "FirewallPolicyArn"
            case firewallPolicyChangeProtection = "FirewallPolicyChangeProtection"
            case subnetChangeProtection = "SubnetChangeProtection"
            case subnetMappings = "SubnetMappings"
            case vpcId = "VpcId"
        }
    }

    public struct AwsNetworkFirewallFirewallPolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// A description of the firewall policy.
        public let description: String?
        /// The firewall policy configuration.
        public let firewallPolicy: FirewallPolicyDetails?
        /// The ARN of the firewall policy.
        public let firewallPolicyArn: String?
        /// The identifier of the firewall policy.
        public let firewallPolicyId: String?
        /// The name of the firewall policy.
        public let firewallPolicyName: String?

        @inlinable
        public init(description: String? = nil, firewallPolicy: FirewallPolicyDetails? = nil, firewallPolicyArn: String? = nil, firewallPolicyId: String? = nil, firewallPolicyName: String? = nil) {
            self.description = description
            self.firewallPolicy = firewallPolicy
            self.firewallPolicyArn = firewallPolicyArn
            self.firewallPolicyId = firewallPolicyId
            self.firewallPolicyName = firewallPolicyName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.firewallPolicy?.validate(name: "\(name).firewallPolicy")
            try self.validate(self.firewallPolicyArn, name: "firewallPolicyArn", parent: name, pattern: "\\S")
            try self.validate(self.firewallPolicyId, name: "firewallPolicyId", parent: name, pattern: "\\S")
            try self.validate(self.firewallPolicyName, name: "firewallPolicyName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case firewallPolicy = "FirewallPolicy"
            case firewallPolicyArn = "FirewallPolicyArn"
            case firewallPolicyId = "FirewallPolicyId"
            case firewallPolicyName = "FirewallPolicyName"
        }
    }

    public struct AwsNetworkFirewallFirewallSubnetMappingsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the subnet
        public let subnetId: String?

        @inlinable
        public init(subnetId: String? = nil) {
            self.subnetId = subnetId
        }

        public func validate(name: String) throws {
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case subnetId = "SubnetId"
        }
    }

    public struct AwsNetworkFirewallRuleGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of operating resources that this rule group can use.
        public let capacity: Int?
        /// A description of the rule group.
        public let description: String?
        /// Details about the rule group.
        public let ruleGroup: RuleGroupDetails?
        /// The ARN of the rule group.
        public let ruleGroupArn: String?
        /// The identifier of the rule group.
        public let ruleGroupId: String?
        /// The descriptive name of the rule group.
        public let ruleGroupName: String?
        /// The type of rule group. A rule group can be stateful or stateless.
        public let type: String?

        @inlinable
        public init(capacity: Int? = nil, description: String? = nil, ruleGroup: RuleGroupDetails? = nil, ruleGroupArn: String? = nil, ruleGroupId: String? = nil, ruleGroupName: String? = nil, type: String? = nil) {
            self.capacity = capacity
            self.description = description
            self.ruleGroup = ruleGroup
            self.ruleGroupArn = ruleGroupArn
            self.ruleGroupId = ruleGroupId
            self.ruleGroupName = ruleGroupName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.ruleGroup?.validate(name: "\(name).ruleGroup")
            try self.validate(self.ruleGroupArn, name: "ruleGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.ruleGroupId, name: "ruleGroupId", parent: name, pattern: "\\S")
            try self.validate(self.ruleGroupName, name: "ruleGroupName", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "Capacity"
            case description = "Description"
            case ruleGroup = "RuleGroup"
            case ruleGroupArn = "RuleGroupArn"
            case ruleGroupId = "RuleGroupId"
            case ruleGroupName = "RuleGroupName"
            case type = "Type"
        }
    }

    public struct AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Enables fine-grained access control.
        public let enabled: Bool?
        /// Enables the internal user database.
        public let internalUserDatabaseEnabled: Bool?
        /// Specifies information about the master user of the domain.
        public let masterUserOptions: AwsOpenSearchServiceDomainMasterUserOptionsDetails?

        @inlinable
        public init(enabled: Bool? = nil, internalUserDatabaseEnabled: Bool? = nil, masterUserOptions: AwsOpenSearchServiceDomainMasterUserOptionsDetails? = nil) {
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.masterUserOptions = masterUserOptions
        }

        public func validate(name: String) throws {
            try self.masterUserOptions?.validate(name: "\(name).masterUserOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
            case masterUserOptions = "MasterUserOptions"
        }
    }

    public struct AwsOpenSearchServiceDomainClusterConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances to use for the master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public let dedicatedMasterCount: Int?
        /// Whether to use a dedicated master node for the OpenSearch domain. A dedicated master node performs cluster management tasks, but does not hold data or respond to data upload requests.
        public let dedicatedMasterEnabled: Bool?
        /// The hardware configuration of the computer that hosts the dedicated master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public let dedicatedMasterType: String?
        /// The number of data nodes to use in the OpenSearch domain.
        public let instanceCount: Int?
        /// The instance type for your data nodes. For a list of valid values, see Supported instance types in Amazon OpenSearch Service in the Amazon OpenSearch Service Developer Guide.
        public let instanceType: String?
        /// The number of UltraWarm instances.
        public let warmCount: Int?
        /// Whether UltraWarm is enabled.
        public let warmEnabled: Bool?
        /// The type of UltraWarm instance.
        public let warmType: String?
        /// Configuration options for zone awareness. Provided if ZoneAwarenessEnabled is true.
        public let zoneAwarenessConfig: AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails?
        /// Whether to enable zone awareness for the OpenSearch domain. When zone awareness is enabled, OpenSearch Service allocates the cluster's nodes and replica index shards across Availability Zones (AZs) in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.
        public let zoneAwarenessEnabled: Bool?

        @inlinable
        public init(dedicatedMasterCount: Int? = nil, dedicatedMasterEnabled: Bool? = nil, dedicatedMasterType: String? = nil, instanceCount: Int? = nil, instanceType: String? = nil, warmCount: Int? = nil, warmEnabled: Bool? = nil, warmType: String? = nil, zoneAwarenessConfig: AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails? = nil, zoneAwarenessEnabled: Bool? = nil) {
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.warmCount = warmCount
            self.warmEnabled = warmEnabled
            self.warmType = warmType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.dedicatedMasterType, name: "dedicatedMasterType", parent: name, pattern: "\\S")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
            try self.validate(self.warmType, name: "warmType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dedicatedMasterCount = "DedicatedMasterCount"
            case dedicatedMasterEnabled = "DedicatedMasterEnabled"
            case dedicatedMasterType = "DedicatedMasterType"
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case warmCount = "WarmCount"
            case warmEnabled = "WarmEnabled"
            case warmType = "WarmType"
            case zoneAwarenessConfig = "ZoneAwarenessConfig"
            case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
        }
    }

    public struct AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of Availability Zones that the domain uses. Valid values are 2 or 3. The default is 2.
        public let availabilityZoneCount: Int?

        @inlinable
        public init(availabilityZoneCount: Int? = nil) {
            self.availabilityZoneCount = availabilityZoneCount
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneCount = "AvailabilityZoneCount"
        }
    }

    public struct AwsOpenSearchServiceDomainDetails: AWSEncodableShape & AWSDecodableShape {
        /// IAM policy document that specifies the access policies for the OpenSearch Service domain.
        public let accessPolicies: String?
        /// Specifies options for fine-grained access control.
        public let advancedSecurityOptions: AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails?
        /// The ARN of the OpenSearch Service domain.
        public let arn: String?
        /// Details about the configuration of an OpenSearch cluster.
        public let clusterConfig: AwsOpenSearchServiceDomainClusterConfigDetails?
        /// The domain endpoint.
        public let domainEndpoint: String?
        /// Additional options for the domain endpoint.
        public let domainEndpointOptions: AwsOpenSearchServiceDomainDomainEndpointOptionsDetails?
        /// The domain endpoints. Used if the OpenSearch domain resides in a VPC. This is a map of key-value pairs. The key is always vpc. The value is the endpoint.
        public let domainEndpoints: [String: String]?
        /// The name of the endpoint.
        public let domainName: String?
        /// Details about the configuration for encryption at rest.
        public let encryptionAtRestOptions: AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails?
        /// The version of the domain engine.
        public let engineVersion: String?
        /// The identifier of the domain.
        public let id: String?
        /// Configures the CloudWatch Logs to publish for the OpenSearch domain.
        public let logPublishingOptions: AwsOpenSearchServiceDomainLogPublishingOptionsDetails?
        /// Details about the configuration for node-to-node encryption.
        public let nodeToNodeEncryptionOptions: AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails?
        /// Information about the status of a domain relative to the latest service software.
        public let serviceSoftwareOptions: AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails?
        /// Information that OpenSearch Service derives based on VPCOptions for the domain.
        public let vpcOptions: AwsOpenSearchServiceDomainVpcOptionsDetails?

        @inlinable
        public init(accessPolicies: String? = nil, advancedSecurityOptions: AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails? = nil, arn: String? = nil, clusterConfig: AwsOpenSearchServiceDomainClusterConfigDetails? = nil, domainEndpoint: String? = nil, domainEndpointOptions: AwsOpenSearchServiceDomainDomainEndpointOptionsDetails? = nil, domainEndpoints: [String: String]? = nil, domainName: String? = nil, encryptionAtRestOptions: AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails? = nil, engineVersion: String? = nil, id: String? = nil, logPublishingOptions: AwsOpenSearchServiceDomainLogPublishingOptionsDetails? = nil, nodeToNodeEncryptionOptions: AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails? = nil, serviceSoftwareOptions: AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails? = nil, vpcOptions: AwsOpenSearchServiceDomainVpcOptionsDetails? = nil) {
            self.accessPolicies = accessPolicies
            self.advancedSecurityOptions = advancedSecurityOptions
            self.arn = arn
            self.clusterConfig = clusterConfig
            self.domainEndpoint = domainEndpoint
            self.domainEndpointOptions = domainEndpointOptions
            self.domainEndpoints = domainEndpoints
            self.domainName = domainName
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.engineVersion = engineVersion
            self.id = id
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.vpcOptions = vpcOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, pattern: "\\S")
            try self.advancedSecurityOptions?.validate(name: "\(name).advancedSecurityOptions")
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.clusterConfig?.validate(name: "\(name).clusterConfig")
            try self.validate(self.domainEndpoint, name: "domainEndpoint", parent: name, pattern: "\\S")
            try self.domainEndpointOptions?.validate(name: "\(name).domainEndpointOptions")
            try self.domainEndpoints?.forEach {
                try validate($0.key, name: "domainEndpoints.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "domainEndpoints[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "\\S")
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.logPublishingOptions?.validate(name: "\(name).logPublishingOptions")
            try self.serviceSoftwareOptions?.validate(name: "\(name).serviceSoftwareOptions")
            try self.vpcOptions?.validate(name: "\(name).vpcOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case advancedSecurityOptions = "AdvancedSecurityOptions"
            case arn = "Arn"
            case clusterConfig = "ClusterConfig"
            case domainEndpoint = "DomainEndpoint"
            case domainEndpointOptions = "DomainEndpointOptions"
            case domainEndpoints = "DomainEndpoints"
            case domainName = "DomainName"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case engineVersion = "EngineVersion"
            case id = "Id"
            case logPublishingOptions = "LogPublishingOptions"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case serviceSoftwareOptions = "ServiceSoftwareOptions"
            case vpcOptions = "VpcOptions"
        }
    }

    public struct AwsOpenSearchServiceDomainDomainEndpointOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The fully qualified URL for the custom endpoint.
        public let customEndpoint: String?
        /// The ARN for the security certificate. The certificate is managed in ACM.
        public let customEndpointCertificateArn: String?
        /// Whether to enable a custom endpoint for the domain.
        public let customEndpointEnabled: Bool?
        /// Whether to require that all traffic to the domain arrive over HTTPS.
        public let enforceHTTPS: Bool?
        /// The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.
        public let tlsSecurityPolicy: String?

        @inlinable
        public init(customEndpoint: String? = nil, customEndpointCertificateArn: String? = nil, customEndpointEnabled: Bool? = nil, enforceHTTPS: Bool? = nil, tlsSecurityPolicy: String? = nil) {
            self.customEndpoint = customEndpoint
            self.customEndpointCertificateArn = customEndpointCertificateArn
            self.customEndpointEnabled = customEndpointEnabled
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.customEndpoint, name: "customEndpoint", parent: name, pattern: "\\S")
            try self.validate(self.customEndpointCertificateArn, name: "customEndpointCertificateArn", parent: name, pattern: "\\S")
            try self.validate(self.tlsSecurityPolicy, name: "tlsSecurityPolicy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case customEndpoint = "CustomEndpoint"
            case customEndpointCertificateArn = "CustomEndpointCertificateArn"
            case customEndpointEnabled = "CustomEndpointEnabled"
            case enforceHTTPS = "EnforceHTTPS"
            case tlsSecurityPolicy = "TLSSecurityPolicy"
        }
    }

    public struct AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether encryption at rest is enabled.
        public let enabled: Bool?
        /// The KMS key ID.
        public let kmsKeyId: String?

        @inlinable
        public init(enabled: Bool? = nil, kmsKeyId: String? = nil) {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct AwsOpenSearchServiceDomainLogPublishingOption: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the CloudWatch Logs group to publish the logs to.
        public let cloudWatchLogsLogGroupArn: String?
        /// Whether the log publishing is enabled.
        public let enabled: Bool?

        @inlinable
        public init(cloudWatchLogsLogGroupArn: String? = nil, enabled: Bool? = nil) {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
            case enabled = "Enabled"
        }
    }

    public struct AwsOpenSearchServiceDomainLogPublishingOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Configures the OpenSearch audit logs publishing.
        public let auditLogs: AwsOpenSearchServiceDomainLogPublishingOption?
        /// Configures the OpenSearch index logs publishing.
        public let indexSlowLogs: AwsOpenSearchServiceDomainLogPublishingOption?
        /// Configures the OpenSearch search slow log publishing.
        public let searchSlowLogs: AwsOpenSearchServiceDomainLogPublishingOption?

        @inlinable
        public init(auditLogs: AwsOpenSearchServiceDomainLogPublishingOption? = nil, indexSlowLogs: AwsOpenSearchServiceDomainLogPublishingOption? = nil, searchSlowLogs: AwsOpenSearchServiceDomainLogPublishingOption? = nil) {
            self.auditLogs = auditLogs
            self.indexSlowLogs = indexSlowLogs
            self.searchSlowLogs = searchSlowLogs
        }

        public func validate(name: String) throws {
            try self.auditLogs?.validate(name: "\(name).auditLogs")
            try self.indexSlowLogs?.validate(name: "\(name).indexSlowLogs")
            try self.searchSlowLogs?.validate(name: "\(name).searchSlowLogs")
        }

        private enum CodingKeys: String, CodingKey {
            case auditLogs = "AuditLogs"
            case indexSlowLogs = "IndexSlowLogs"
            case searchSlowLogs = "SearchSlowLogs"
        }
    }

    public struct AwsOpenSearchServiceDomainMasterUserOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the master user.
        public let masterUserArn: String?
        /// The username for the master user.
        public let masterUserName: String?
        /// The password for the master user.
        public let masterUserPassword: String?

        @inlinable
        public init(masterUserArn: String? = nil, masterUserName: String? = nil, masterUserPassword: String? = nil) {
            self.masterUserArn = masterUserArn
            self.masterUserName = masterUserName
            self.masterUserPassword = masterUserPassword
        }

        public func validate(name: String) throws {
            try self.validate(self.masterUserArn, name: "masterUserArn", parent: name, pattern: "\\S")
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, pattern: "\\S")
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case masterUserArn = "MasterUserArn"
            case masterUserName = "MasterUserName"
            case masterUserPassword = "MasterUserPassword"
        }
    }

    public struct AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether node-to-node encryption is enabled.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The epoch time when the deployment window closes for required updates. After this time, OpenSearch Service schedules the software upgrade automatically.
        public let automatedUpdateDate: String?
        /// Whether a request to update the domain can be canceled.
        public let cancellable: Bool?
        /// The version of the service software that is currently installed on the domain.
        public let currentVersion: String?
        /// A more detailed description of the service software status.
        public let description: String?
        /// The most recent version of the service software.
        public let newVersion: String?
        /// Whether the service software update is optional.
        public let optionalDeployment: Bool?
        /// Whether a service software update is available for the domain.
        public let updateAvailable: Bool?
        /// The status of the service software update. Valid values are as follows:    COMPLETED     ELIGIBLE     IN_PROGRESS     NOT_ELIGIBLE     PENDING_UPDATE
        public let updateStatus: String?

        @inlinable
        public init(automatedUpdateDate: String? = nil, cancellable: Bool? = nil, currentVersion: String? = nil, description: String? = nil, newVersion: String? = nil, optionalDeployment: Bool? = nil, updateAvailable: Bool? = nil, updateStatus: String? = nil) {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.optionalDeployment = optionalDeployment
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.automatedUpdateDate, name: "automatedUpdateDate", parent: name, pattern: "\\S")
            try self.validate(self.currentVersion, name: "currentVersion", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.newVersion, name: "newVersion", parent: name, pattern: "\\S")
            try self.validate(self.updateStatus, name: "updateStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case automatedUpdateDate = "AutomatedUpdateDate"
            case cancellable = "Cancellable"
            case currentVersion = "CurrentVersion"
            case description = "Description"
            case newVersion = "NewVersion"
            case optionalDeployment = "OptionalDeployment"
            case updateAvailable = "UpdateAvailable"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct AwsOpenSearchServiceDomainVpcOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The list of security group IDs that are associated with the VPC endpoints for the domain.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs that are associated with the VPC endpoints for the domain.
        public let subnetIds: [String]?

        @inlinable
        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "\\S")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct AwsRdsDbClusterAssociatedRole: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role.
        public let roleArn: String?
        /// The status of the association between the IAM role and the DB cluster. Valid values are as follows:    ACTIVE     INVALID     PENDING
        public let status: String?

        @inlinable
        public init(roleArn: String? = nil, status: String? = nil) {
            self.roleArn = roleArn
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
            case status = "Status"
        }
    }

    public struct AwsRdsDbClusterDetails: AWSEncodableShape & AWSDecodableShape {
        /// The status of the database activity stream. Valid values are as follows:    started     starting     stopped     stopping
        public let activityStreamStatus: String?
        /// For all database engines except Aurora, specifies the allocated storage size in gibibytes (GiB).
        public let allocatedStorage: Int?
        /// A list of the IAM roles that are associated with the DB cluster.
        public let associatedRoles: [AwsRdsDbClusterAssociatedRole]?
        ///  Indicates if minor version upgrades are automatically applied to the cluster.
        public let autoMinorVersionUpgrade: Bool?
        /// A list of Availability Zones (AZs) where instances in the DB cluster can be created.
        public let availabilityZones: [String]?
        /// The number of days for which automated backups are retained.
        public let backupRetentionPeriod: Int?
        /// Indicates when the DB cluster was created, in Universal Coordinated Time (UTC). For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let clusterCreateTime: String?
        /// Whether tags are copied from the DB cluster to snapshots of the DB cluster.
        public let copyTagsToSnapshot: Bool?
        /// Whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.
        public let crossAccountClone: Bool?
        /// A list of custom endpoints for the DB cluster.
        public let customEndpoints: [String]?
        /// The name of the database.
        public let databaseName: String?
        /// The DB cluster identifier that the user assigned to the cluster. This identifier is the unique key that identifies a DB cluster.
        public let dbClusterIdentifier: String?
        /// The list of instances that make up the DB cluster.
        public let dbClusterMembers: [AwsRdsDbClusterMember]?
        /// The list of option group memberships for this DB cluster.
        public let dbClusterOptionGroupMemberships: [AwsRdsDbClusterOptionGroupMembership]?
        /// The name of the DB cluster parameter group for the DB cluster.
        public let dbClusterParameterGroup: String?
        /// The identifier of the DB cluster. The identifier must be unique within each Amazon Web Services Region and is immutable.
        public let dbClusterResourceId: String?
        /// The subnet group that is associated with the DB cluster, including the name, description, and subnets in the subnet group.
        public let dbSubnetGroup: String?
        /// Whether the DB cluster has deletion protection enabled.
        public let deletionProtection: Bool?
        /// The Active Directory domain membership records that are associated with the DB cluster.
        public let domainMemberships: [AwsRdsDbDomainMembership]?
        /// A list of log types that this DB cluster is configured to export to CloudWatch Logs.
        public let enabledCloudWatchLogsExports: [String]?
        /// The connection endpoint for the primary instance of the DB cluster.
        public let endpoint: String?
        /// The name of the database engine to use for this DB cluster. Valid values are as follows:    aurora     aurora-mysql     aurora-postgresql
        public let engine: String?
        /// The database engine mode of the DB cluster.Valid values are as follows:    global     multimaster     parallelquery     provisioned     serverless
        public let engineMode: String?
        /// The version number of the database engine to use.
        public let engineVersion: String?
        /// Specifies the identifier that Amazon Route 53 assigns when you create a hosted zone.
        public let hostedZoneId: String?
        /// Whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.
        public let httpEndpointEnabled: Bool?
        /// Whether the mapping of IAM accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.
        public let kmsKeyId: String?
        /// The name of the master user for the DB cluster.
        public let masterUsername: String?
        /// Whether the DB cluster has instances in multiple Availability Zones.
        public let multiAz: Bool?
        /// The port number on which the DB instances in the DB cluster accept connections.
        public let port: Int?
        /// The range of time each day when automated backups are created, if automated backups are enabled. Uses the format HH:MM-HH:MM. For example, 04:52-05:22.
        public let preferredBackupWindow: String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Uses the format :HH:MM-:HH:MM. For the day values, use mon|tue|wed|thu|fri|sat|sun. For example, sun:09:32-sun:10:02.
        public let preferredMaintenanceWindow: String?
        /// The reader endpoint for the DB cluster.
        public let readerEndpoint: String?
        /// The identifiers of the read replicas that are associated with this DB cluster.
        public let readReplicaIdentifiers: [String]?
        /// The current status of this DB cluster.
        public let status: String?
        /// Whether the DB cluster is encrypted.
        public let storageEncrypted: Bool?
        /// A list of VPC security groups that the DB cluster belongs to.
        public let vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]?

        @inlinable
        public init(activityStreamStatus: String? = nil, allocatedStorage: Int? = nil, associatedRoles: [AwsRdsDbClusterAssociatedRole]? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZones: [String]? = nil, backupRetentionPeriod: Int? = nil, clusterCreateTime: String? = nil, copyTagsToSnapshot: Bool? = nil, crossAccountClone: Bool? = nil, customEndpoints: [String]? = nil, databaseName: String? = nil, dbClusterIdentifier: String? = nil, dbClusterMembers: [AwsRdsDbClusterMember]? = nil, dbClusterOptionGroupMemberships: [AwsRdsDbClusterOptionGroupMembership]? = nil, dbClusterParameterGroup: String? = nil, dbClusterResourceId: String? = nil, dbSubnetGroup: String? = nil, deletionProtection: Bool? = nil, domainMemberships: [AwsRdsDbDomainMembership]? = nil, enabledCloudWatchLogsExports: [String]? = nil, endpoint: String? = nil, engine: String? = nil, engineMode: String? = nil, engineVersion: String? = nil, hostedZoneId: String? = nil, httpEndpointEnabled: Bool? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, kmsKeyId: String? = nil, masterUsername: String? = nil, multiAz: Bool? = nil, port: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, readerEndpoint: String? = nil, readReplicaIdentifiers: [String]? = nil, status: String? = nil, storageEncrypted: Bool? = nil, vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]? = nil) {
            self.activityStreamStatus = activityStreamStatus
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZones = availabilityZones
            self.backupRetentionPeriod = backupRetentionPeriod
            self.clusterCreateTime = clusterCreateTime
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.crossAccountClone = crossAccountClone
            self.customEndpoints = customEndpoints
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterMembers = dbClusterMembers
            self.dbClusterOptionGroupMemberships = dbClusterOptionGroupMemberships
            self.dbClusterParameterGroup = dbClusterParameterGroup
            self.dbClusterResourceId = dbClusterResourceId
            self.dbSubnetGroup = dbSubnetGroup
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudWatchLogsExports = enabledCloudWatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.hostedZoneId = hostedZoneId
            self.httpEndpointEnabled = httpEndpointEnabled
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.masterUsername = masterUsername
            self.multiAz = multiAz
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.readerEndpoint = readerEndpoint
            self.readReplicaIdentifiers = readReplicaIdentifiers
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.activityStreamStatus, name: "activityStreamStatus", parent: name, pattern: "\\S")
            try self.associatedRoles?.forEach {
                try $0.validate(name: "\(name).associatedRoles[]")
            }
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.clusterCreateTime, name: "clusterCreateTime", parent: name, pattern: "\\S")
            try self.customEndpoints?.forEach {
                try validate($0, name: "customEndpoints[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "\\S")
            try self.validate(self.dbClusterIdentifier, name: "dbClusterIdentifier", parent: name, pattern: "\\S")
            try self.dbClusterMembers?.forEach {
                try $0.validate(name: "\(name).dbClusterMembers[]")
            }
            try self.dbClusterOptionGroupMemberships?.forEach {
                try $0.validate(name: "\(name).dbClusterOptionGroupMemberships[]")
            }
            try self.validate(self.dbClusterParameterGroup, name: "dbClusterParameterGroup", parent: name, pattern: "\\S")
            try self.validate(self.dbClusterResourceId, name: "dbClusterResourceId", parent: name, pattern: "\\S")
            try self.validate(self.dbSubnetGroup, name: "dbSubnetGroup", parent: name, pattern: "\\S")
            try self.domainMemberships?.forEach {
                try $0.validate(name: "\(name).domainMemberships[]")
            }
            try self.enabledCloudWatchLogsExports?.forEach {
                try validate($0, name: "enabledCloudWatchLogsExports[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "\\S")
            try self.validate(self.engine, name: "engine", parent: name, pattern: "\\S")
            try self.validate(self.engineMode, name: "engineMode", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.masterUsername, name: "masterUsername", parent: name, pattern: "\\S")
            try self.validate(self.preferredBackupWindow, name: "preferredBackupWindow", parent: name, pattern: "\\S")
            try self.validate(self.preferredMaintenanceWindow, name: "preferredMaintenanceWindow", parent: name, pattern: "\\S")
            try self.validate(self.readerEndpoint, name: "readerEndpoint", parent: name, pattern: "\\S")
            try self.readReplicaIdentifiers?.forEach {
                try validate($0, name: "readReplicaIdentifiers[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.vpcSecurityGroups?.forEach {
                try $0.validate(name: "\(name).vpcSecurityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case activityStreamStatus = "ActivityStreamStatus"
            case allocatedStorage = "AllocatedStorage"
            case associatedRoles = "AssociatedRoles"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZones = "AvailabilityZones"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case clusterCreateTime = "ClusterCreateTime"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case crossAccountClone = "CrossAccountClone"
            case customEndpoints = "CustomEndpoints"
            case databaseName = "DatabaseName"
            case dbClusterIdentifier = "DbClusterIdentifier"
            case dbClusterMembers = "DbClusterMembers"
            case dbClusterOptionGroupMemberships = "DbClusterOptionGroupMemberships"
            case dbClusterParameterGroup = "DbClusterParameterGroup"
            case dbClusterResourceId = "DbClusterResourceId"
            case dbSubnetGroup = "DbSubnetGroup"
            case deletionProtection = "DeletionProtection"
            case domainMemberships = "DomainMemberships"
            case enabledCloudWatchLogsExports = "EnabledCloudWatchLogsExports"
            case endpoint = "Endpoint"
            case engine = "Engine"
            case engineMode = "EngineMode"
            case engineVersion = "EngineVersion"
            case hostedZoneId = "HostedZoneId"
            case httpEndpointEnabled = "HttpEndpointEnabled"
            case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
            case kmsKeyId = "KmsKeyId"
            case masterUsername = "MasterUsername"
            case multiAz = "MultiAz"
            case port = "Port"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case readerEndpoint = "ReaderEndpoint"
            case readReplicaIdentifiers = "ReadReplicaIdentifiers"
            case status = "Status"
            case storageEncrypted = "StorageEncrypted"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct AwsRdsDbClusterMember: AWSEncodableShape & AWSDecodableShape {
        /// The status of the DB cluster parameter group for this member of the DB cluster.
        public let dbClusterParameterGroupStatus: String?
        /// The instance identifier for this member of the DB cluster.
        public let dbInstanceIdentifier: String?
        /// Whether the cluster member is the primary instance for the DB cluster.
        public let isClusterWriter: Bool?
        /// Specifies the order in which an Aurora replica is promoted to the primary instance when the existing primary instance fails.
        public let promotionTier: Int?

        @inlinable
        public init(dbClusterParameterGroupStatus: String? = nil, dbInstanceIdentifier: String? = nil, isClusterWriter: Bool? = nil, promotionTier: Int? = nil) {
            self.dbClusterParameterGroupStatus = dbClusterParameterGroupStatus
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.isClusterWriter = isClusterWriter
            self.promotionTier = promotionTier
        }

        public func validate(name: String) throws {
            try self.validate(self.dbClusterParameterGroupStatus, name: "dbClusterParameterGroupStatus", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterParameterGroupStatus = "DbClusterParameterGroupStatus"
            case dbInstanceIdentifier = "DbInstanceIdentifier"
            case isClusterWriter = "IsClusterWriter"
            case promotionTier = "PromotionTier"
        }
    }

    public struct AwsRdsDbClusterOptionGroupMembership: AWSEncodableShape & AWSDecodableShape {
        /// The name of the DB cluster option group.
        public let dbClusterOptionGroupName: String?
        /// The status of the DB cluster option group.
        public let status: String?

        @inlinable
        public init(dbClusterOptionGroupName: String? = nil, status: String? = nil) {
            self.dbClusterOptionGroupName = dbClusterOptionGroupName
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.dbClusterOptionGroupName, name: "dbClusterOptionGroupName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dbClusterOptionGroupName = "DbClusterOptionGroupName"
            case status = "Status"
        }
    }

    public struct AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the manual DB cluster snapshot attribute. The attribute named restore refers to the list of  Amazon Web Services accounts that have permission to copy or restore the manual DB cluster snapshot.
        public let attributeName: String?
        ///  The value(s) for the manual DB cluster snapshot attribute. If the AttributeName field is set to  restore, then this element returns a list of IDs of the Amazon Web Services accounts that are authorized  to copy or restore the manual DB cluster snapshot. If a value of all is in the list, then the manual  DB cluster snapshot is public and available for any Amazon Web Services account to copy or restore.
        public let attributeValues: [String]?

        @inlinable
        public init(attributeName: String? = nil, attributeValues: [String]? = nil) {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "\\S")
            try self.attributeValues?.forEach {
                try validate($0, name: "attributeValues[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeValues = "AttributeValues"
        }
    }

    public struct AwsRdsDbClusterSnapshotDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the allocated storage size in gibibytes (GiB).
        public let allocatedStorage: Int?
        /// A list of Availability Zones where instances in the DB cluster can be created.
        public let availabilityZones: [String]?
        /// Indicates when the DB cluster was created, in Universal Coordinated Time (UTC). For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let clusterCreateTime: String?
        /// The DB cluster identifier.
        public let dbClusterIdentifier: String?
        ///  Contains the name and values of a manual DB cluster snapshot attribute.
        public let dbClusterSnapshotAttributes: [AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute]?
        /// The identifier of the DB cluster snapshot.
        public let dbClusterSnapshotIdentifier: String?
        /// The name of the database engine that you want to use for this DB instance.
        public let engine: String?
        /// The version of the database engine to use.
        public let engineVersion: String?
        /// Whether mapping of IAM accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.
        public let kmsKeyId: String?
        /// The license model information for this DB cluster snapshot.
        public let licenseModel: String?
        /// The name of the master user for the DB cluster.
        public let masterUsername: String?
        /// Specifies the percentage of the estimated data that has been transferred.
        public let percentProgress: Int?
        /// The port number on which the DB instances in the DB cluster accept connections.
        public let port: Int?
        /// Indicates when the snapshot was taken. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let snapshotCreateTime: String?
        /// The type of DB cluster snapshot.
        public let snapshotType: String?
        /// The status of this DB cluster snapshot.
        public let status: String?
        /// Whether the DB cluster is encrypted.
        public let storageEncrypted: Bool?
        /// The VPC ID that is associated with the DB cluster snapshot.
        public let vpcId: String?

        @inlinable
        public init(allocatedStorage: Int? = nil, availabilityZones: [String]? = nil, clusterCreateTime: String? = nil, dbClusterIdentifier: String? = nil, dbClusterSnapshotAttributes: [AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute]? = nil, dbClusterSnapshotIdentifier: String? = nil, engine: String? = nil, engineVersion: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, kmsKeyId: String? = nil, licenseModel: String? = nil, masterUsername: String? = nil, percentProgress: Int? = nil, port: Int? = nil, snapshotCreateTime: String? = nil, snapshotType: String? = nil, status: String? = nil, storageEncrypted: Bool? = nil, vpcId: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.availabilityZones = availabilityZones
            self.clusterCreateTime = clusterCreateTime
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterSnapshotAttributes = dbClusterSnapshotAttributes
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.percentProgress = percentProgress
            self.port = port
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.clusterCreateTime, name: "clusterCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.dbClusterIdentifier, name: "dbClusterIdentifier", parent: name, pattern: "\\S")
            try self.dbClusterSnapshotAttributes?.forEach {
                try $0.validate(name: "\(name).dbClusterSnapshotAttributes[]")
            }
            try self.validate(self.dbClusterSnapshotIdentifier, name: "dbClusterSnapshotIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.engine, name: "engine", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.licenseModel, name: "licenseModel", parent: name, pattern: "\\S")
            try self.validate(self.masterUsername, name: "masterUsername", parent: name, pattern: "\\S")
            try self.validate(self.snapshotCreateTime, name: "snapshotCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.snapshotType, name: "snapshotType", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case availabilityZones = "AvailabilityZones"
            case clusterCreateTime = "ClusterCreateTime"
            case dbClusterIdentifier = "DbClusterIdentifier"
            case dbClusterSnapshotAttributes = "DbClusterSnapshotAttributes"
            case dbClusterSnapshotIdentifier = "DbClusterSnapshotIdentifier"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
            case kmsKeyId = "KmsKeyId"
            case licenseModel = "LicenseModel"
            case masterUsername = "MasterUsername"
            case percentProgress = "PercentProgress"
            case port = "Port"
            case snapshotCreateTime = "SnapshotCreateTime"
            case snapshotType = "SnapshotType"
            case status = "Status"
            case storageEncrypted = "StorageEncrypted"
            case vpcId = "VpcId"
        }
    }

    public struct AwsRdsDbDomainMembership: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the Active Directory domain.
        public let domain: String?
        /// The fully qualified domain name of the Active Directory domain.
        public let fqdn: String?
        /// The name of the IAM role to use when making API calls to the Directory Service.
        public let iamRoleName: String?
        /// The status of the Active Directory Domain membership for the DB instance.
        public let status: String?

        @inlinable
        public init(domain: String? = nil, fqdn: String? = nil, iamRoleName: String? = nil, status: String? = nil) {
            self.domain = domain
            self.fqdn = fqdn
            self.iamRoleName = iamRoleName
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, pattern: "\\S")
            try self.validate(self.fqdn, name: "fqdn", parent: name, pattern: "\\S")
            try self.validate(self.iamRoleName, name: "iamRoleName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case domain = "Domain"
            case fqdn = "Fqdn"
            case iamRoleName = "IamRoleName"
            case status = "Status"
        }
    }

    public struct AwsRdsDbInstanceAssociatedRole: AWSEncodableShape & AWSDecodableShape {
        /// The name of the feature associated with the IAM role.
        public let featureName: String?
        /// The ARN of the IAM role that is associated with the DB instance.
        public let roleArn: String?
        /// Describes the state of the association between the IAM role and the DB instance. The Status property returns one of the following values:    ACTIVE - The IAM role ARN is associated with the DB instance and can be used to access other Amazon Web Services services on your behalf.    PENDING - The IAM role ARN is being associated with the DB instance.    INVALID - The IAM role ARN is associated with the DB instance. But the DB instance is unable to assume the IAM role in order to access other Amazon Web Services services on your behalf.
        public let status: String?

        @inlinable
        public init(featureName: String? = nil, roleArn: String? = nil, status: String? = nil) {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.featureName, name: "featureName", parent: name, pattern: "\\S")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case featureName = "FeatureName"
            case roleArn = "RoleArn"
            case status = "Status"
        }
    }

    public struct AwsRdsDbInstanceDetails: AWSEncodableShape & AWSDecodableShape {
        /// The amount of storage (in gigabytes) to initially allocate for the DB instance.
        public let allocatedStorage: Int?
        /// The IAM roles associated with the DB instance.
        public let associatedRoles: [AwsRdsDbInstanceAssociatedRole]?
        /// Indicates whether minor version patches are applied automatically.
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone where the DB instance will be created.
        public let availabilityZone: String?
        /// The number of days for which to retain automated backups.
        public let backupRetentionPeriod: Int?
        /// The identifier of the CA certificate for this DB instance.
        public let caCertificateIdentifier: String?
        /// The name of the character set that this DB instance is associated with.
        public let characterSetName: String?
        /// Whether to copy resource tags to snapshots of the DB instance.
        public let copyTagsToSnapshot: Bool?
        /// If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.
        public let dbClusterIdentifier: String?
        /// Contains the name of the compute and memory capacity class of the DB instance.
        public let dbInstanceClass: String?
        /// Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.
        public let dbInstanceIdentifier: String?
        /// Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.
        public let dbInstancePort: Int?
        /// The current status of the DB instance.
        public let dbInstanceStatus: String?
        /// The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in CloudTrail log entries whenever the KMS key for the DB instance is accessed.
        public let dbiResourceId: String?
        /// The meaning of this parameter differs according to the database engine you use.  MySQL, MariaDB, SQL Server, PostgreSQL  Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance.  Oracle  Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters don't apply to an Oracle DB instance.
        public let dbName: String?
        /// A list of the DB parameter groups to assign to the DB instance.
        public let dbParameterGroups: [AwsRdsDbParameterGroup]?
        /// A list of the DB security groups to assign to the DB instance.
        public let dbSecurityGroups: [String]?
        /// Information about the subnet group that is associated with the DB instance.
        public let dbSubnetGroup: AwsRdsDbSubnetGroup?
        /// Indicates whether the DB instance has deletion protection enabled. When deletion protection is enabled, the database cannot be deleted.
        public let deletionProtection: Bool?
        /// The Active Directory domain membership records associated with the DB instance.
        public let domainMemberships: [AwsRdsDbDomainMembership]?
        /// A list of log types that this DB instance is configured to export to CloudWatch Logs.
        public let enabledCloudWatchLogsExports: [String]?
        /// Specifies the connection endpoint.
        public let endpoint: AwsRdsDbInstanceEndpoint?
        /// Provides the name of the database engine to use for this DB instance.
        public let engine: String?
        /// Indicates the database engine version.
        public let engineVersion: String?
        /// The ARN of the CloudWatch Logs log stream that receives the enhanced monitoring metrics data for the DB instance.
        public let enhancedMonitoringResourceArn: String?
        /// True if mapping of IAM accounts to database accounts is enabled, and otherwise false. IAM database authentication can be enabled for the following database engines.   For MySQL 5.6, minor version 5.6.34 or higher   For MySQL 5.7, minor version 5.7.16 or higher   Aurora 5.6 or higher
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// Indicates when the DB instance was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let instanceCreateTime: String?
        /// Specifies the provisioned IOPS (I/O operations per second) for this DB instance.
        public let iops: Int?
        /// If StorageEncrypted is true, the KMS key identifier for the encrypted DB instance.
        public let kmsKeyId: String?
        /// Specifies the latest time to which a database can be restored with point-in-time restore. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let latestRestorableTime: String?
        /// License model information for this DB instance.
        public let licenseModel: String?
        public let listenerEndpoint: AwsRdsDbInstanceEndpoint?
        /// The master user name of the DB instance.
        public let masterUsername: String?
        /// The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.
        public let maxAllocatedStorage: Int?
        /// The interval, in seconds, between points when enhanced monitoring metrics are collected for the DB instance.
        public let monitoringInterval: Int?
        /// The ARN for the IAM role that permits Amazon RDS to send enhanced monitoring metrics to CloudWatch Logs.
        public let monitoringRoleArn: String?
        /// Whether the DB instance is a multiple Availability Zone deployment.
        public let multiAz: Bool?
        /// The list of option group memberships for this DB instance.
        public let optionGroupMemberships: [AwsRdsDbOptionGroupMembership]?
        /// Changes to the DB instance that are currently pending.
        public let pendingModifiedValues: AwsRdsDbPendingModifiedValues?
        /// Indicates whether Performance Insights is enabled for the DB instance.
        public let performanceInsightsEnabled: Bool?
        /// The identifier of the KMS key used to encrypt the Performance Insights data.
        public let performanceInsightsKmsKeyId: String?
        /// The number of days to retain Performance Insights data.
        public let performanceInsightsRetentionPeriod: Int?
        /// The range of time each day when automated backups are created, if automated backups are enabled. Uses the format HH:MM-HH:MM. For example, 04:52-05:22.
        public let preferredBackupWindow: String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Uses the format :HH:MM-:HH:MM. For the day values, use mon|tue|wed|thu|fri|sat|sun. For example, sun:09:32-sun:10:02.
        public let preferredMaintenanceWindow: String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public let processorFeatures: [AwsRdsDbProcessorFeature]?
        /// The order in which to promote an Aurora replica to the primary instance after a failure of the existing primary instance.
        public let promotionTier: Int?
        /// Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address.
        public let publiclyAccessible: Bool?
        /// List of identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica.
        public let readReplicaDBClusterIdentifiers: [String]?
        /// List of identifiers of the read replicas associated with this DB instance.
        public let readReplicaDBInstanceIdentifiers: [String]?
        /// If this DB instance is a read replica, contains the identifier of the source DB instance.
        public let readReplicaSourceDBInstanceIdentifier: String?
        /// For a DB instance with multi-Availability Zone support, the name of the secondary Availability Zone.
        public let secondaryAvailabilityZone: String?
        /// The status of a read replica. If the instance isn't a read replica, this is empty.
        public let statusInfos: [AwsRdsDbStatusInfo]?
        /// Specifies whether the DB instance is encrypted.
        public let storageEncrypted: Bool?
        /// The storage type for the DB instance.
        public let storageType: String?
        /// The ARN from the key store with which the instance is associated for TDE encryption.
        public let tdeCredentialArn: String?
        /// The time zone of the DB instance.
        public let timezone: String?
        /// A list of VPC security groups that the DB instance belongs to.
        public let vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]?

        @inlinable
        public init(allocatedStorage: Int? = nil, associatedRoles: [AwsRdsDbInstanceAssociatedRole]? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, backupRetentionPeriod: Int? = nil, caCertificateIdentifier: String? = nil, characterSetName: String? = nil, copyTagsToSnapshot: Bool? = nil, dbClusterIdentifier: String? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbInstancePort: Int? = nil, dbInstanceStatus: String? = nil, dbiResourceId: String? = nil, dbName: String? = nil, dbParameterGroups: [AwsRdsDbParameterGroup]? = nil, dbSecurityGroups: [String]? = nil, dbSubnetGroup: AwsRdsDbSubnetGroup? = nil, deletionProtection: Bool? = nil, domainMemberships: [AwsRdsDbDomainMembership]? = nil, enabledCloudWatchLogsExports: [String]? = nil, endpoint: AwsRdsDbInstanceEndpoint? = nil, engine: String? = nil, engineVersion: String? = nil, enhancedMonitoringResourceArn: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, instanceCreateTime: String? = nil, iops: Int? = nil, kmsKeyId: String? = nil, latestRestorableTime: String? = nil, licenseModel: String? = nil, listenerEndpoint: AwsRdsDbInstanceEndpoint? = nil, masterUsername: String? = nil, maxAllocatedStorage: Int? = nil, monitoringInterval: Int? = nil, monitoringRoleArn: String? = nil, multiAz: Bool? = nil, optionGroupMemberships: [AwsRdsDbOptionGroupMembership]? = nil, pendingModifiedValues: AwsRdsDbPendingModifiedValues? = nil, performanceInsightsEnabled: Bool? = nil, performanceInsightsKmsKeyId: String? = nil, performanceInsightsRetentionPeriod: Int? = nil, preferredBackupWindow: String? = nil, preferredMaintenanceWindow: String? = nil, processorFeatures: [AwsRdsDbProcessorFeature]? = nil, promotionTier: Int? = nil, publiclyAccessible: Bool? = nil, readReplicaDBClusterIdentifiers: [String]? = nil, readReplicaDBInstanceIdentifiers: [String]? = nil, readReplicaSourceDBInstanceIdentifier: String? = nil, secondaryAvailabilityZone: String? = nil, statusInfos: [AwsRdsDbStatusInfo]? = nil, storageEncrypted: Bool? = nil, storageType: String? = nil, tdeCredentialArn: String? = nil, timezone: String? = nil, vpcSecurityGroups: [AwsRdsDbInstanceVpcSecurityGroup]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbInstancePort = dbInstancePort
            self.dbInstanceStatus = dbInstanceStatus
            self.dbiResourceId = dbiResourceId
            self.dbName = dbName
            self.dbParameterGroups = dbParameterGroups
            self.dbSecurityGroups = dbSecurityGroups
            self.dbSubnetGroup = dbSubnetGroup
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudWatchLogsExports = enabledCloudWatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineVersion = engineVersion
            self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.licenseModel = licenseModel
            self.listenerEndpoint = listenerEndpoint
            self.masterUsername = masterUsername
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAz = multiAz
            self.optionGroupMemberships = optionGroupMemberships
            self.pendingModifiedValues = pendingModifiedValues
            self.performanceInsightsEnabled = performanceInsightsEnabled
            self.performanceInsightsKmsKeyId = performanceInsightsKmsKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.processorFeatures = processorFeatures
            self.promotionTier = promotionTier
            self.publiclyAccessible = publiclyAccessible
            self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
            self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
            self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.statusInfos = statusInfos
            self.storageEncrypted = storageEncrypted
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        public func validate(name: String) throws {
            try self.associatedRoles?.forEach {
                try $0.validate(name: "\(name).associatedRoles[]")
            }
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.caCertificateIdentifier, name: "caCertificateIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.characterSetName, name: "characterSetName", parent: name, pattern: "\\S")
            try self.validate(self.dbClusterIdentifier, name: "dbClusterIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceClass, name: "dbInstanceClass", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceStatus, name: "dbInstanceStatus", parent: name, pattern: "\\S")
            try self.validate(self.dbiResourceId, name: "dbiResourceId", parent: name, pattern: "\\S")
            try self.validate(self.dbName, name: "dbName", parent: name, pattern: "\\S")
            try self.dbParameterGroups?.forEach {
                try $0.validate(name: "\(name).dbParameterGroups[]")
            }
            try self.dbSecurityGroups?.forEach {
                try validate($0, name: "dbSecurityGroups[]", parent: name, pattern: "\\S")
            }
            try self.dbSubnetGroup?.validate(name: "\(name).dbSubnetGroup")
            try self.domainMemberships?.forEach {
                try $0.validate(name: "\(name).domainMemberships[]")
            }
            try self.enabledCloudWatchLogsExports?.forEach {
                try validate($0, name: "enabledCloudWatchLogsExports[]", parent: name, pattern: "\\S")
            }
            try self.endpoint?.validate(name: "\(name).endpoint")
            try self.validate(self.engine, name: "engine", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.enhancedMonitoringResourceArn, name: "enhancedMonitoringResourceArn", parent: name, pattern: "\\S")
            try self.validate(self.instanceCreateTime, name: "instanceCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.latestRestorableTime, name: "latestRestorableTime", parent: name, pattern: "\\S")
            try self.validate(self.licenseModel, name: "licenseModel", parent: name, pattern: "\\S")
            try self.listenerEndpoint?.validate(name: "\(name).listenerEndpoint")
            try self.validate(self.masterUsername, name: "masterUsername", parent: name, pattern: "\\S")
            try self.validate(self.monitoringRoleArn, name: "monitoringRoleArn", parent: name, pattern: "\\S")
            try self.optionGroupMemberships?.forEach {
                try $0.validate(name: "\(name).optionGroupMemberships[]")
            }
            try self.pendingModifiedValues?.validate(name: "\(name).pendingModifiedValues")
            try self.validate(self.performanceInsightsKmsKeyId, name: "performanceInsightsKmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.preferredBackupWindow, name: "preferredBackupWindow", parent: name, pattern: "\\S")
            try self.validate(self.preferredMaintenanceWindow, name: "preferredMaintenanceWindow", parent: name, pattern: "\\S")
            try self.processorFeatures?.forEach {
                try $0.validate(name: "\(name).processorFeatures[]")
            }
            try self.readReplicaDBClusterIdentifiers?.forEach {
                try validate($0, name: "readReplicaDBClusterIdentifiers[]", parent: name, pattern: "\\S")
            }
            try self.readReplicaDBInstanceIdentifiers?.forEach {
                try validate($0, name: "readReplicaDBInstanceIdentifiers[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.readReplicaSourceDBInstanceIdentifier, name: "readReplicaSourceDBInstanceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.secondaryAvailabilityZone, name: "secondaryAvailabilityZone", parent: name, pattern: "\\S")
            try self.statusInfos?.forEach {
                try $0.validate(name: "\(name).statusInfos[]")
            }
            try self.validate(self.storageType, name: "storageType", parent: name, pattern: "\\S")
            try self.validate(self.tdeCredentialArn, name: "tdeCredentialArn", parent: name, pattern: "\\S")
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: "\\S")
            try self.vpcSecurityGroups?.forEach {
                try $0.validate(name: "\(name).vpcSecurityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case associatedRoles = "AssociatedRoles"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case caCertificateIdentifier = "CACertificateIdentifier"
            case characterSetName = "CharacterSetName"
            case copyTagsToSnapshot = "CopyTagsToSnapshot"
            case dbClusterIdentifier = "DBClusterIdentifier"
            case dbInstanceClass = "DBInstanceClass"
            case dbInstanceIdentifier = "DBInstanceIdentifier"
            case dbInstancePort = "DbInstancePort"
            case dbInstanceStatus = "DbInstanceStatus"
            case dbiResourceId = "DbiResourceId"
            case dbName = "DBName"
            case dbParameterGroups = "DbParameterGroups"
            case dbSecurityGroups = "DbSecurityGroups"
            case dbSubnetGroup = "DbSubnetGroup"
            case deletionProtection = "DeletionProtection"
            case domainMemberships = "DomainMemberships"
            case enabledCloudWatchLogsExports = "EnabledCloudWatchLogsExports"
            case endpoint = "Endpoint"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case enhancedMonitoringResourceArn = "EnhancedMonitoringResourceArn"
            case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
            case instanceCreateTime = "InstanceCreateTime"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case latestRestorableTime = "LatestRestorableTime"
            case licenseModel = "LicenseModel"
            case listenerEndpoint = "ListenerEndpoint"
            case masterUsername = "MasterUsername"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case monitoringInterval = "MonitoringInterval"
            case monitoringRoleArn = "MonitoringRoleArn"
            case multiAz = "MultiAz"
            case optionGroupMemberships = "OptionGroupMemberships"
            case pendingModifiedValues = "PendingModifiedValues"
            case performanceInsightsEnabled = "PerformanceInsightsEnabled"
            case performanceInsightsKmsKeyId = "PerformanceInsightsKmsKeyId"
            case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
            case preferredBackupWindow = "PreferredBackupWindow"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case processorFeatures = "ProcessorFeatures"
            case promotionTier = "PromotionTier"
            case publiclyAccessible = "PubliclyAccessible"
            case readReplicaDBClusterIdentifiers = "ReadReplicaDBClusterIdentifiers"
            case readReplicaDBInstanceIdentifiers = "ReadReplicaDBInstanceIdentifiers"
            case readReplicaSourceDBInstanceIdentifier = "ReadReplicaSourceDBInstanceIdentifier"
            case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
            case statusInfos = "StatusInfos"
            case storageEncrypted = "StorageEncrypted"
            case storageType = "StorageType"
            case tdeCredentialArn = "TdeCredentialArn"
            case timezone = "Timezone"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct AwsRdsDbInstanceEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the DNS address of the DB instance.
        public let address: String?
        /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        public let hostedZoneId: String?
        /// Specifies the port that the database engine is listening on.
        public let port: Int?

        @inlinable
        public init(address: String? = nil, hostedZoneId: String? = nil, port: Int? = nil) {
            self.address = address
            self.hostedZoneId = hostedZoneId
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, pattern: "\\S")
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case hostedZoneId = "HostedZoneId"
            case port = "Port"
        }
    }

    public struct AwsRdsDbInstanceVpcSecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// The status of the VPC security group.
        public let status: String?
        /// The name of the VPC security group.
        public let vpcSecurityGroupId: String?

        @inlinable
        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.vpcSecurityGroupId, name: "vpcSecurityGroupId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }

    public struct AwsRdsDbOptionGroupMembership: AWSEncodableShape & AWSDecodableShape {
        /// The name of the option group.
        public let optionGroupName: String?
        /// The status of the option group membership.
        public let status: String?

        @inlinable
        public init(optionGroupName: String? = nil, status: String? = nil) {
            self.optionGroupName = optionGroupName
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.optionGroupName, name: "optionGroupName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case optionGroupName = "OptionGroupName"
            case status = "Status"
        }
    }

    public struct AwsRdsDbParameterGroup: AWSEncodableShape & AWSDecodableShape {
        /// The name of the parameter group.
        public let dbParameterGroupName: String?
        /// The status of parameter updates.
        public let parameterApplyStatus: String?

        @inlinable
        public init(dbParameterGroupName: String? = nil, parameterApplyStatus: String? = nil) {
            self.dbParameterGroupName = dbParameterGroupName
            self.parameterApplyStatus = parameterApplyStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.dbParameterGroupName, name: "dbParameterGroupName", parent: name, pattern: "\\S")
            try self.validate(self.parameterApplyStatus, name: "parameterApplyStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dbParameterGroupName = "DbParameterGroupName"
            case parameterApplyStatus = "ParameterApplyStatus"
        }
    }

    public struct AwsRdsDbPendingModifiedValues: AWSEncodableShape & AWSDecodableShape {
        /// The new value of the allocated storage for the DB instance.
        public let allocatedStorage: Int?
        /// The new backup retention period for the DB instance.
        public let backupRetentionPeriod: Int?
        /// The new CA certificate identifier for the DB instance.
        public let caCertificateIdentifier: String?
        /// The new DB instance class for the DB instance.
        public let dbInstanceClass: String?
        /// The new DB instance identifier for the DB instance.
        public let dbInstanceIdentifier: String?
        /// The name of the new subnet group for the DB instance.
        public let dbSubnetGroupName: String?
        /// The new engine version for the DB instance.
        public let engineVersion: String?
        /// The new provisioned IOPS value for the DB instance.
        public let iops: Int?
        /// The new license model value for the DB instance.
        public let licenseModel: String?
        /// The new master user password for the DB instance.
        public let masterUserPassword: String?
        /// Indicates that a single Availability Zone DB instance is changing to a multiple Availability Zone deployment.
        public let multiAZ: Bool?
        /// A list of log types that are being enabled or disabled.
        public let pendingCloudWatchLogsExports: AwsRdsPendingCloudWatchLogsExports?
        /// The new port for the DB instance.
        public let port: Int?
        /// Processor features that are being updated.
        public let processorFeatures: [AwsRdsDbProcessorFeature]?
        /// The new storage type for the DB instance.
        public let storageType: String?

        @inlinable
        public init(allocatedStorage: Int? = nil, backupRetentionPeriod: Int? = nil, caCertificateIdentifier: String? = nil, dbInstanceClass: String? = nil, dbInstanceIdentifier: String? = nil, dbSubnetGroupName: String? = nil, engineVersion: String? = nil, iops: Int? = nil, licenseModel: String? = nil, masterUserPassword: String? = nil, multiAZ: Bool? = nil, pendingCloudWatchLogsExports: AwsRdsPendingCloudWatchLogsExports? = nil, port: Int? = nil, processorFeatures: [AwsRdsDbProcessorFeature]? = nil, storageType: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbSubnetGroupName = dbSubnetGroupName
            self.engineVersion = engineVersion
            self.iops = iops
            self.licenseModel = licenseModel
            self.masterUserPassword = masterUserPassword
            self.multiAZ = multiAZ
            self.pendingCloudWatchLogsExports = pendingCloudWatchLogsExports
            self.port = port
            self.processorFeatures = processorFeatures
            self.storageType = storageType
        }

        public func validate(name: String) throws {
            try self.validate(self.caCertificateIdentifier, name: "caCertificateIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceClass, name: "dbInstanceClass", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbSubnetGroupName, name: "dbSubnetGroupName", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.licenseModel, name: "licenseModel", parent: name, pattern: "\\S")
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, pattern: "\\S")
            try self.pendingCloudWatchLogsExports?.validate(name: "\(name).pendingCloudWatchLogsExports")
            try self.processorFeatures?.forEach {
                try $0.validate(name: "\(name).processorFeatures[]")
            }
            try self.validate(self.storageType, name: "storageType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case backupRetentionPeriod = "BackupRetentionPeriod"
            case caCertificateIdentifier = "CaCertificateIdentifier"
            case dbInstanceClass = "DbInstanceClass"
            case dbInstanceIdentifier = "DbInstanceIdentifier"
            case dbSubnetGroupName = "DbSubnetGroupName"
            case engineVersion = "EngineVersion"
            case iops = "Iops"
            case licenseModel = "LicenseModel"
            case masterUserPassword = "MasterUserPassword"
            case multiAZ = "MultiAZ"
            case pendingCloudWatchLogsExports = "PendingCloudWatchLogsExports"
            case port = "Port"
            case processorFeatures = "ProcessorFeatures"
            case storageType = "StorageType"
        }
    }

    public struct AwsRdsDbProcessorFeature: AWSEncodableShape & AWSDecodableShape {
        /// The name of the processor feature. Valid values are coreCount or threadsPerCore.
        public let name: String?
        /// The value of the processor feature.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsRdsDbSecurityGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN for the DB security group.
        public let dbSecurityGroupArn: String?
        /// Provides the description of the DB security group.
        public let dbSecurityGroupDescription: String?
        /// Specifies the name of the DB security group.
        public let dbSecurityGroupName: String?
        /// Contains a list of EC2 security groups.
        public let ec2SecurityGroups: [AwsRdsDbSecurityGroupEc2SecurityGroup]?
        /// Contains a list of IP ranges.
        public let ipRanges: [AwsRdsDbSecurityGroupIpRange]?
        /// Provides the Amazon Web Services ID of the owner of a specific DB security group.
        public let ownerId: String?
        /// Provides VPC ID associated with the DB security group.
        public let vpcId: String?

        @inlinable
        public init(dbSecurityGroupArn: String? = nil, dbSecurityGroupDescription: String? = nil, dbSecurityGroupName: String? = nil, ec2SecurityGroups: [AwsRdsDbSecurityGroupEc2SecurityGroup]? = nil, ipRanges: [AwsRdsDbSecurityGroupIpRange]? = nil, ownerId: String? = nil, vpcId: String? = nil) {
            self.dbSecurityGroupArn = dbSecurityGroupArn
            self.dbSecurityGroupDescription = dbSecurityGroupDescription
            self.dbSecurityGroupName = dbSecurityGroupName
            self.ec2SecurityGroups = ec2SecurityGroups
            self.ipRanges = ipRanges
            self.ownerId = ownerId
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.dbSecurityGroupArn, name: "dbSecurityGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.dbSecurityGroupDescription, name: "dbSecurityGroupDescription", parent: name, pattern: "\\S")
            try self.validate(self.dbSecurityGroupName, name: "dbSecurityGroupName", parent: name, pattern: "\\S")
            try self.ec2SecurityGroups?.forEach {
                try $0.validate(name: "\(name).ec2SecurityGroups[]")
            }
            try self.ipRanges?.forEach {
                try $0.validate(name: "\(name).ipRanges[]")
            }
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dbSecurityGroupArn = "DbSecurityGroupArn"
            case dbSecurityGroupDescription = "DbSecurityGroupDescription"
            case dbSecurityGroupName = "DbSecurityGroupName"
            case ec2SecurityGroups = "Ec2SecurityGroups"
            case ipRanges = "IpRanges"
            case ownerId = "OwnerId"
            case vpcId = "VpcId"
        }
    }

    public struct AwsRdsDbSecurityGroupEc2SecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the ID for the EC2 security group.
        public let ec2SecurityGroupId: String?
        /// Specifies the name of the EC2 security group.
        public let ec2SecurityGroupName: String?
        /// Provides the Amazon Web Services ID of the owner of the EC2 security group.
        public let ec2SecurityGroupOwnerId: String?
        /// Provides the status of the EC2 security group.
        public let status: String?

        @inlinable
        public init(ec2SecurityGroupId: String? = nil, ec2SecurityGroupName: String? = nil, ec2SecurityGroupOwnerId: String? = nil, status: String? = nil) {
            self.ec2SecurityGroupId = ec2SecurityGroupId
            self.ec2SecurityGroupName = ec2SecurityGroupName
            self.ec2SecurityGroupOwnerId = ec2SecurityGroupOwnerId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.ec2SecurityGroupId, name: "ec2SecurityGroupId", parent: name, pattern: "\\S")
            try self.validate(self.ec2SecurityGroupName, name: "ec2SecurityGroupName", parent: name, pattern: "\\S")
            try self.validate(self.ec2SecurityGroupOwnerId, name: "ec2SecurityGroupOwnerId", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ec2SecurityGroupId = "Ec2SecurityGroupId"
            case ec2SecurityGroupName = "Ec2SecurityGroupName"
            case ec2SecurityGroupOwnerId = "Ec2SecurityGroupOwnerId"
            case status = "Status"
        }
    }

    public struct AwsRdsDbSecurityGroupIpRange: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the IP range.
        public let cidrIp: String?
        /// Specifies the status of the IP range.
        public let status: String?

        @inlinable
        public init(cidrIp: String? = nil, status: String? = nil) {
            self.cidrIp = cidrIp
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrIp, name: "cidrIp", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrIp = "CidrIp"
            case status = "Status"
        }
    }

    public struct AwsRdsDbSnapshotDetails: AWSEncodableShape & AWSDecodableShape {
        /// The amount of storage (in gigabytes) to be initially allocated for the database instance.
        public let allocatedStorage: Int?
        /// Specifies the name of the Availability Zone in which the DB instance was located at the time of the DB snapshot.
        public let availabilityZone: String?
        /// A name for the DB instance.
        public let dbInstanceIdentifier: String?
        /// The identifier for the source DB instance.
        public let dbiResourceId: String?
        /// The name or ARN of the DB snapshot that is used to restore the DB instance.
        public let dbSnapshotIdentifier: String?
        /// Whether the DB snapshot is encrypted.
        public let encrypted: Bool?
        /// The name of the database engine to use for this DB instance. Valid values are as follows:    aurora     aurora-mysql     aurora-postgresql     c     mariadb     mysql     oracle-ee     oracle-se     oracle-se1     oracle-se2     sqlserver-ee     sqlserver-ex     sqlserver-se     sqlserver-web
        public let engine: String?
        /// The version of the database engine.
        public let engineVersion: String?
        /// Whether mapping of IAM accounts to database accounts is enabled.
        public let iamDatabaseAuthenticationEnabled: Bool?
        /// Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.
        public let instanceCreateTime: String?
        /// The provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.
        public let iops: Int?
        /// If Encrypted is true, the KMS key identifier for the encrypted DB snapshot.
        public let kmsKeyId: String?
        /// License model information for the restored DB instance.
        public let licenseModel: String?
        /// The master user name for the DB snapshot.
        public let masterUsername: String?
        /// The option group name for the DB snapshot.
        public let optionGroupName: String?
        /// The percentage of the estimated data that has been transferred.
        public let percentProgress: Int?
        /// The port that the database engine was listening on at the time of the snapshot.
        public let port: Int?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public let processorFeatures: [AwsRdsDbProcessorFeature]?
        /// When the snapshot was taken in Coordinated Universal Time (UTC).
        public let snapshotCreateTime: String?
        /// The type of the DB snapshot.
        public let snapshotType: String?
        /// The DB snapshot ARN that the DB snapshot was copied from.
        public let sourceDbSnapshotIdentifier: String?
        /// The Amazon Web Services Region that the DB snapshot was created in or copied from.
        public let sourceRegion: String?
        /// The status of this DB snapshot.
        public let status: String?
        /// The storage type associated with the DB snapshot. Valid values are as follows:    gp2     io1     standard
        public let storageType: String?
        /// The ARN from the key store with which to associate the instance for TDE encryption.
        public let tdeCredentialArn: String?
        /// The time zone of the DB snapshot.
        public let timezone: String?
        /// The VPC ID associated with the DB snapshot.
        public let vpcId: String?

        @inlinable
        public init(allocatedStorage: Int? = nil, availabilityZone: String? = nil, dbInstanceIdentifier: String? = nil, dbiResourceId: String? = nil, dbSnapshotIdentifier: String? = nil, encrypted: Bool? = nil, engine: String? = nil, engineVersion: String? = nil, iamDatabaseAuthenticationEnabled: Bool? = nil, instanceCreateTime: String? = nil, iops: Int? = nil, kmsKeyId: String? = nil, licenseModel: String? = nil, masterUsername: String? = nil, optionGroupName: String? = nil, percentProgress: Int? = nil, port: Int? = nil, processorFeatures: [AwsRdsDbProcessorFeature]? = nil, snapshotCreateTime: String? = nil, snapshotType: String? = nil, sourceDbSnapshotIdentifier: String? = nil, sourceRegion: String? = nil, status: String? = nil, storageType: String? = nil, tdeCredentialArn: String? = nil, timezone: String? = nil, vpcId: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.availabilityZone = availabilityZone
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.encrypted = encrypted
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.optionGroupName = optionGroupName
            self.percentProgress = percentProgress
            self.port = port
            self.processorFeatures = processorFeatures
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.sourceDbSnapshotIdentifier = sourceDbSnapshotIdentifier
            self.sourceRegion = sourceRegion
            self.status = status
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.dbInstanceIdentifier, name: "dbInstanceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.dbiResourceId, name: "dbiResourceId", parent: name, pattern: "\\S")
            try self.validate(self.dbSnapshotIdentifier, name: "dbSnapshotIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.engine, name: "engine", parent: name, pattern: "\\S")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "\\S")
            try self.validate(self.instanceCreateTime, name: "instanceCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.licenseModel, name: "licenseModel", parent: name, pattern: "\\S")
            try self.validate(self.masterUsername, name: "masterUsername", parent: name, pattern: "\\S")
            try self.validate(self.optionGroupName, name: "optionGroupName", parent: name, pattern: "\\S")
            try self.processorFeatures?.forEach {
                try $0.validate(name: "\(name).processorFeatures[]")
            }
            try self.validate(self.snapshotCreateTime, name: "snapshotCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.snapshotType, name: "snapshotType", parent: name, pattern: "\\S")
            try self.validate(self.sourceDbSnapshotIdentifier, name: "sourceDbSnapshotIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.sourceRegion, name: "sourceRegion", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.storageType, name: "storageType", parent: name, pattern: "\\S")
            try self.validate(self.tdeCredentialArn, name: "tdeCredentialArn", parent: name, pattern: "\\S")
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case availabilityZone = "AvailabilityZone"
            case dbInstanceIdentifier = "DbInstanceIdentifier"
            case dbiResourceId = "DbiResourceId"
            case dbSnapshotIdentifier = "DbSnapshotIdentifier"
            case encrypted = "Encrypted"
            case engine = "Engine"
            case engineVersion = "EngineVersion"
            case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
            case instanceCreateTime = "InstanceCreateTime"
            case iops = "Iops"
            case kmsKeyId = "KmsKeyId"
            case licenseModel = "LicenseModel"
            case masterUsername = "MasterUsername"
            case optionGroupName = "OptionGroupName"
            case percentProgress = "PercentProgress"
            case port = "Port"
            case processorFeatures = "ProcessorFeatures"
            case snapshotCreateTime = "SnapshotCreateTime"
            case snapshotType = "SnapshotType"
            case sourceDbSnapshotIdentifier = "SourceDbSnapshotIdentifier"
            case sourceRegion = "SourceRegion"
            case status = "Status"
            case storageType = "StorageType"
            case tdeCredentialArn = "TdeCredentialArn"
            case timezone = "Timezone"
            case vpcId = "VpcId"
        }
    }

    public struct AwsRdsDbStatusInfo: AWSEncodableShape & AWSDecodableShape {
        /// If the read replica is currently in an error state, provides the error details.
        public let message: String?
        /// Whether the read replica instance is operating normally.
        public let normal: Bool?
        /// The status of the read replica instance.
        public let status: String?
        /// The type of status. For a read replica, the status type is read replication.
        public let statusType: String?

        @inlinable
        public init(message: String? = nil, normal: Bool? = nil, status: String? = nil, statusType: String? = nil) {
            self.message = message
            self.normal = normal
            self.status = status
            self.statusType = statusType
        }

        public func validate(name: String) throws {
            try self.validate(self.message, name: "message", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.statusType, name: "statusType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case normal = "Normal"
            case status = "Status"
            case statusType = "StatusType"
        }
    }

    public struct AwsRdsDbSubnetGroup: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the subnet group.
        public let dbSubnetGroupArn: String?
        /// The description of the subnet group.
        public let dbSubnetGroupDescription: String?
        /// The name of the subnet group.
        public let dbSubnetGroupName: String?
        /// The status of the subnet group.
        public let subnetGroupStatus: String?
        /// A list of subnets in the subnet group.
        public let subnets: [AwsRdsDbSubnetGroupSubnet]?
        /// The VPC ID of the subnet group.
        public let vpcId: String?

        @inlinable
        public init(dbSubnetGroupArn: String? = nil, dbSubnetGroupDescription: String? = nil, dbSubnetGroupName: String? = nil, subnetGroupStatus: String? = nil, subnets: [AwsRdsDbSubnetGroupSubnet]? = nil, vpcId: String? = nil) {
            self.dbSubnetGroupArn = dbSubnetGroupArn
            self.dbSubnetGroupDescription = dbSubnetGroupDescription
            self.dbSubnetGroupName = dbSubnetGroupName
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.dbSubnetGroupArn, name: "dbSubnetGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.dbSubnetGroupDescription, name: "dbSubnetGroupDescription", parent: name, pattern: "\\S")
            try self.validate(self.dbSubnetGroupName, name: "dbSubnetGroupName", parent: name, pattern: "\\S")
            try self.validate(self.subnetGroupStatus, name: "subnetGroupStatus", parent: name, pattern: "\\S")
            try self.subnets?.forEach {
                try $0.validate(name: "\(name).subnets[]")
            }
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dbSubnetGroupArn = "DbSubnetGroupArn"
            case dbSubnetGroupDescription = "DbSubnetGroupDescription"
            case dbSubnetGroupName = "DbSubnetGroupName"
            case subnetGroupStatus = "SubnetGroupStatus"
            case subnets = "Subnets"
            case vpcId = "VpcId"
        }
    }

    public struct AwsRdsDbSubnetGroupSubnet: AWSEncodableShape & AWSDecodableShape {
        /// Information about the Availability Zone for a subnet in the subnet group.
        public let subnetAvailabilityZone: AwsRdsDbSubnetGroupSubnetAvailabilityZone?
        /// The identifier of a subnet in the subnet group.
        public let subnetIdentifier: String?
        /// The status of a subnet in the subnet group.
        public let subnetStatus: String?

        @inlinable
        public init(subnetAvailabilityZone: AwsRdsDbSubnetGroupSubnetAvailabilityZone? = nil, subnetIdentifier: String? = nil, subnetStatus: String? = nil) {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }

        public func validate(name: String) throws {
            try self.subnetAvailabilityZone?.validate(name: "\(name).subnetAvailabilityZone")
            try self.validate(self.subnetIdentifier, name: "subnetIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.subnetStatus, name: "subnetStatus", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case subnetAvailabilityZone = "SubnetAvailabilityZone"
            case subnetIdentifier = "SubnetIdentifier"
            case subnetStatus = "SubnetStatus"
        }
    }

    public struct AwsRdsDbSubnetGroupSubnetAvailabilityZone: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Availability Zone for a subnet in the subnet group.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct AwsRdsEventSubscriptionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the event notification subscription.
        public let customerAwsId: String?
        /// The identifier of the account that is associated with the event notification subscription.
        public let custSubscriptionId: String?
        /// Whether the event notification subscription is enabled.
        public let enabled: Bool?
        /// The list of event categories for the event notification subscription.
        public let eventCategoriesList: [String]?
        /// The ARN of the event notification subscription.
        public let eventSubscriptionArn: String?
        /// The ARN of the SNS topic to post the event notifications to.
        public let snsTopicArn: String?
        /// A list of source identifiers for the event notification subscription.
        public let sourceIdsList: [String]?
        /// The source type for the event notification subscription.
        public let sourceType: String?
        /// The status of the event notification subscription. Valid values: creating | modifying | deleting | active | no-permission | topic-not-exist
        public let status: String?
        /// The datetime when the event notification subscription was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let subscriptionCreationTime: String?

        @inlinable
        public init(customerAwsId: String? = nil, custSubscriptionId: String? = nil, enabled: Bool? = nil, eventCategoriesList: [String]? = nil, eventSubscriptionArn: String? = nil, snsTopicArn: String? = nil, sourceIdsList: [String]? = nil, sourceType: String? = nil, status: String? = nil, subscriptionCreationTime: String? = nil) {
            self.customerAwsId = customerAwsId
            self.custSubscriptionId = custSubscriptionId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.eventSubscriptionArn = eventSubscriptionArn
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }

        public func validate(name: String) throws {
            try self.validate(self.customerAwsId, name: "customerAwsId", parent: name, pattern: "\\S")
            try self.validate(self.custSubscriptionId, name: "custSubscriptionId", parent: name, pattern: "\\S")
            try self.eventCategoriesList?.forEach {
                try validate($0, name: "eventCategoriesList[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.eventSubscriptionArn, name: "eventSubscriptionArn", parent: name, pattern: "\\S")
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "\\S")
            try self.sourceIdsList?.forEach {
                try validate($0, name: "sourceIdsList[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.sourceType, name: "sourceType", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.subscriptionCreationTime, name: "subscriptionCreationTime", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case customerAwsId = "CustomerAwsId"
            case custSubscriptionId = "CustSubscriptionId"
            case enabled = "Enabled"
            case eventCategoriesList = "EventCategoriesList"
            case eventSubscriptionArn = "EventSubscriptionArn"
            case snsTopicArn = "SnsTopicArn"
            case sourceIdsList = "SourceIdsList"
            case sourceType = "SourceType"
            case status = "Status"
            case subscriptionCreationTime = "SubscriptionCreationTime"
        }
    }

    public struct AwsRdsPendingCloudWatchLogsExports: AWSEncodableShape & AWSDecodableShape {
        /// A list of log types that are being disabled.
        public let logTypesToDisable: [String]?
        /// A list of log types that are being enabled.
        public let logTypesToEnable: [String]?

        @inlinable
        public init(logTypesToDisable: [String]? = nil, logTypesToEnable: [String]? = nil) {
            self.logTypesToDisable = logTypesToDisable
            self.logTypesToEnable = logTypesToEnable
        }

        public func validate(name: String) throws {
            try self.logTypesToDisable?.forEach {
                try validate($0, name: "logTypesToDisable[]", parent: name, pattern: "\\S")
            }
            try self.logTypesToEnable?.forEach {
                try validate($0, name: "logTypesToEnable[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case logTypesToDisable = "LogTypesToDisable"
            case logTypesToEnable = "LogTypesToEnable"
        }
    }

    public struct AwsRedshiftClusterClusterNode: AWSEncodableShape & AWSDecodableShape {
        /// The role of the node. A node might be a leader node or a compute node.
        public let nodeRole: String?
        /// The private IP address of the node.
        public let privateIpAddress: String?
        /// The public IP address of the node.
        public let publicIpAddress: String?

        @inlinable
        public init(nodeRole: String? = nil, privateIpAddress: String? = nil, publicIpAddress: String? = nil) {
            self.nodeRole = nodeRole
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.nodeRole, name: "nodeRole", parent: name, pattern: "\\S")
            try self.validate(self.privateIpAddress, name: "privateIpAddress", parent: name, pattern: "\\S")
            try self.validate(self.publicIpAddress, name: "publicIpAddress", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case nodeRole = "NodeRole"
            case privateIpAddress = "PrivateIpAddress"
            case publicIpAddress = "PublicIpAddress"
        }
    }

    public struct AwsRedshiftClusterClusterParameterGroup: AWSEncodableShape & AWSDecodableShape {
        /// The list of parameter statuses.
        public let clusterParameterStatusList: [AwsRedshiftClusterClusterParameterStatus]?
        /// The status of updates to the parameters.
        public let parameterApplyStatus: String?
        /// The name of the parameter group.
        public let parameterGroupName: String?

        @inlinable
        public init(clusterParameterStatusList: [AwsRedshiftClusterClusterParameterStatus]? = nil, parameterApplyStatus: String? = nil, parameterGroupName: String? = nil) {
            self.clusterParameterStatusList = clusterParameterStatusList
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterGroupName = parameterGroupName
        }

        public func validate(name: String) throws {
            try self.clusterParameterStatusList?.forEach {
                try $0.validate(name: "\(name).clusterParameterStatusList[]")
            }
            try self.validate(self.parameterApplyStatus, name: "parameterApplyStatus", parent: name, pattern: "\\S")
            try self.validate(self.parameterGroupName, name: "parameterGroupName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterParameterStatusList = "ClusterParameterStatusList"
            case parameterApplyStatus = "ParameterApplyStatus"
            case parameterGroupName = "ParameterGroupName"
        }
    }

    public struct AwsRedshiftClusterClusterParameterStatus: AWSEncodableShape & AWSDecodableShape {
        /// The error that prevented the parameter from being applied to the database.
        public let parameterApplyErrorDescription: String?
        /// The status of the parameter. Indicates whether the parameter is in sync with the database, waiting for a cluster reboot, or encountered an error when it was applied. Valid values: in-sync | pending-reboot | applying | invalid-parameter | apply-deferred | apply-error | unknown-error
        public let parameterApplyStatus: String?
        /// The name of the parameter.
        public let parameterName: String?

        @inlinable
        public init(parameterApplyErrorDescription: String? = nil, parameterApplyStatus: String? = nil, parameterName: String? = nil) {
            self.parameterApplyErrorDescription = parameterApplyErrorDescription
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterName = parameterName
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterApplyErrorDescription, name: "parameterApplyErrorDescription", parent: name, pattern: "\\S")
            try self.validate(self.parameterApplyStatus, name: "parameterApplyStatus", parent: name, pattern: "\\S")
            try self.validate(self.parameterName, name: "parameterName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case parameterApplyErrorDescription = "ParameterApplyErrorDescription"
            case parameterApplyStatus = "ParameterApplyStatus"
            case parameterName = "ParameterName"
        }
    }

    public struct AwsRedshiftClusterClusterSecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// The name of the cluster security group.
        public let clusterSecurityGroupName: String?
        /// The status of the cluster security group.
        public let status: String?

        @inlinable
        public init(clusterSecurityGroupName: String? = nil, status: String? = nil) {
            self.clusterSecurityGroupName = clusterSecurityGroupName
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterSecurityGroupName, name: "clusterSecurityGroupName", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterSecurityGroupName = "ClusterSecurityGroupName"
            case status = "Status"
        }
    }

    public struct AwsRedshiftClusterClusterSnapshotCopyStatus: AWSEncodableShape & AWSDecodableShape {
        /// The destination Region that snapshots are automatically copied to when cross-Region snapshot copy is enabled.
        public let destinationRegion: String?
        /// The number of days that manual snapshots are retained in the destination Region after they are copied from a source Region. If the value is -1, then the manual snapshot is retained indefinitely. Valid values: Either -1 or an integer between 1 and 3,653
        public let manualSnapshotRetentionPeriod: Int?
        /// The number of days to retain automated snapshots in the destination Region after they are copied from a source Region.
        public let retentionPeriod: Int?
        /// The name of the snapshot copy grant.
        public let snapshotCopyGrantName: String?

        @inlinable
        public init(destinationRegion: String? = nil, manualSnapshotRetentionPeriod: Int? = nil, retentionPeriod: Int? = nil, snapshotCopyGrantName: String? = nil) {
            self.destinationRegion = destinationRegion
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.retentionPeriod = retentionPeriod
            self.snapshotCopyGrantName = snapshotCopyGrantName
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationRegion, name: "destinationRegion", parent: name, pattern: "\\S")
            try self.validate(self.snapshotCopyGrantName, name: "snapshotCopyGrantName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationRegion = "DestinationRegion"
            case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
            case retentionPeriod = "RetentionPeriod"
            case snapshotCopyGrantName = "SnapshotCopyGrantName"
        }
    }

    public struct AwsRedshiftClusterDeferredMaintenanceWindow: AWSEncodableShape & AWSDecodableShape {
        /// The end of the time window for which maintenance was deferred. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let deferMaintenanceEndTime: String?
        /// The identifier of the maintenance window.
        public let deferMaintenanceIdentifier: String?
        /// The start of the time window for which maintenance was deferred. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let deferMaintenanceStartTime: String?

        @inlinable
        public init(deferMaintenanceEndTime: String? = nil, deferMaintenanceIdentifier: String? = nil, deferMaintenanceStartTime: String? = nil) {
            self.deferMaintenanceEndTime = deferMaintenanceEndTime
            self.deferMaintenanceIdentifier = deferMaintenanceIdentifier
            self.deferMaintenanceStartTime = deferMaintenanceStartTime
        }

        public func validate(name: String) throws {
            try self.validate(self.deferMaintenanceEndTime, name: "deferMaintenanceEndTime", parent: name, pattern: "\\S")
            try self.validate(self.deferMaintenanceIdentifier, name: "deferMaintenanceIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.deferMaintenanceStartTime, name: "deferMaintenanceStartTime", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deferMaintenanceEndTime = "DeferMaintenanceEndTime"
            case deferMaintenanceIdentifier = "DeferMaintenanceIdentifier"
            case deferMaintenanceStartTime = "DeferMaintenanceStartTime"
        }
    }

    public struct AwsRedshiftClusterDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether major version upgrades are applied automatically to the cluster during the maintenance window.
        public let allowVersionUpgrade: Bool?
        /// The number of days that automatic cluster snapshots are retained.
        public let automatedSnapshotRetentionPeriod: Int?
        /// The name of the Availability Zone in which the cluster is located.
        public let availabilityZone: String?
        /// The availability status of the cluster for queries. Possible values are the following:    Available - The cluster is available for queries.    Unavailable - The cluster is not available for queries.    Maintenance - The cluster is intermittently available for queries due to maintenance activities.    Modifying -The cluster is intermittently available for queries due to changes that modify the cluster.    Failed - The cluster failed and is not available for queries.
        public let clusterAvailabilityStatus: String?
        /// Indicates when the cluster was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let clusterCreateTime: String?
        /// The unique identifier of the cluster.
        public let clusterIdentifier: String?
        /// The nodes in the cluster.
        public let clusterNodes: [AwsRedshiftClusterClusterNode]?
        /// The list of cluster parameter groups that are associated with this cluster.
        public let clusterParameterGroups: [AwsRedshiftClusterClusterParameterGroup]?
        /// The public key for the cluster.
        public let clusterPublicKey: String?
        /// The specific revision number of the database in the cluster.
        public let clusterRevisionNumber: String?
        /// A list of cluster security groups that are associated with the cluster.
        public let clusterSecurityGroups: [AwsRedshiftClusterClusterSecurityGroup]?
        /// Information about the destination Region and retention period for the cross-Region snapshot copy.
        public let clusterSnapshotCopyStatus: AwsRedshiftClusterClusterSnapshotCopyStatus?
        /// The current status of the cluster. Valid values: available | available, prep-for-resize | available, resize-cleanup | cancelling-resize | creating | deleting | final-snapshot | hardware-failure | incompatible-hsm | incompatible-network | incompatible-parameters | incompatible-restore | modifying | paused | rebooting | renaming | resizing | rotating-keys | storage-full | updating-hsm
        public let clusterStatus: String?
        /// The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.
        public let clusterSubnetGroupName: String?
        /// The version ID of the Amazon Redshift engine that runs on the cluster.
        public let clusterVersion: String?
        /// The name of the initial database that was created when the cluster was created. The same name is returned for the life of the cluster. If an initial database is not specified, a database named devdev is created by default.
        public let dbName: String?
        /// List of time windows during which maintenance was deferred.
        public let deferredMaintenanceWindows: [AwsRedshiftClusterDeferredMaintenanceWindow]?
        /// Information about the status of the Elastic IP (EIP) address.
        public let elasticIpStatus: AwsRedshiftClusterElasticIpStatus?
        /// The number of nodes that you can use the elastic resize method to resize the cluster to.
        public let elasticResizeNumberOfNodeOptions: String?
        /// Indicates whether the data in the cluster is encrypted at rest.
        public let encrypted: Bool?
        /// The connection endpoint.
        public let endpoint: AwsRedshiftClusterEndpoint?
        /// Indicates whether to create the cluster with enhanced VPC routing enabled.
        public let enhancedVpcRouting: Bool?
        /// Indicates when the next snapshot is expected to be taken. The cluster must have a valid snapshot schedule and have backups enabled. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let expectedNextSnapshotScheduleTime: String?
        /// The status of the next expected snapshot. Valid values: OnTrack | Pending
        public let expectedNextSnapshotScheduleTimeStatus: String?
        /// Information about whether the Amazon Redshift cluster finished applying any changes to hardware security module (HSM) settings that were specified in a modify cluster command.
        public let hsmStatus: AwsRedshiftClusterHsmStatus?
        /// A list of IAM roles that the cluster can use to access other Amazon Web Services services.
        public let iamRoles: [AwsRedshiftClusterIamRole]?
        /// The identifier of the KMS encryption key that is used to encrypt data in the cluster.
        public let kmsKeyId: String?
        /// Information about the logging status of the cluster.
        public let loggingStatus: AwsRedshiftClusterLoggingStatus?
        /// The name of the maintenance track for the cluster.
        public let maintenanceTrackName: String?
        /// The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots. Valid values: Either -1 or an integer between 1 and 3,653
        public let manualSnapshotRetentionPeriod: Int?
        /// The master user name for the cluster. This name is used to connect to the database that is specified in as the value of DBName.
        public let masterUsername: String?
        /// Indicates the start of the next maintenance window. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let nextMaintenanceWindowStartTime: String?
        /// The node type for the nodes in the cluster.
        public let nodeType: String?
        /// The number of compute nodes in the cluster.
        public let numberOfNodes: Int?
        /// A list of cluster operations that are waiting to start.
        public let pendingActions: [String]?
        /// A list of changes to the cluster that are currently pending.
        public let pendingModifiedValues: AwsRedshiftClusterPendingModifiedValues?
        /// The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur. Format:  :HH:MM-:HH:MM  For the day values, use mon | tue | wed | thu | fri | sat | sun  For example, sun:09:32-sun:10:02
        public let preferredMaintenanceWindow: String?
        /// Whether the cluster can be accessed from a public network.
        public let publiclyAccessible: Bool?
        /// Information about the resize operation for the cluster.
        public let resizeInfo: AwsRedshiftClusterResizeInfo?
        /// Information about the status of a cluster restore action. Only applies to a cluster that was created by restoring a snapshot.
        public let restoreStatus: AwsRedshiftClusterRestoreStatus?
        /// A unique identifier for the cluster snapshot schedule.
        public let snapshotScheduleIdentifier: String?
        /// The current state of the cluster snapshot schedule. Valid values: MODIFYING | ACTIVE | FAILED
        public let snapshotScheduleState: String?
        /// The identifier of the VPC that the cluster is in, if the cluster is in a VPC.
        public let vpcId: String?
        /// The list of VPC security groups that the cluster belongs to, if the cluster is in a VPC.
        public let vpcSecurityGroups: [AwsRedshiftClusterVpcSecurityGroup]?

        @inlinable
        public init(allowVersionUpgrade: Bool? = nil, automatedSnapshotRetentionPeriod: Int? = nil, availabilityZone: String? = nil, clusterAvailabilityStatus: String? = nil, clusterCreateTime: String? = nil, clusterIdentifier: String? = nil, clusterNodes: [AwsRedshiftClusterClusterNode]? = nil, clusterParameterGroups: [AwsRedshiftClusterClusterParameterGroup]? = nil, clusterPublicKey: String? = nil, clusterRevisionNumber: String? = nil, clusterSecurityGroups: [AwsRedshiftClusterClusterSecurityGroup]? = nil, clusterSnapshotCopyStatus: AwsRedshiftClusterClusterSnapshotCopyStatus? = nil, clusterStatus: String? = nil, clusterSubnetGroupName: String? = nil, clusterVersion: String? = nil, dbName: String? = nil, deferredMaintenanceWindows: [AwsRedshiftClusterDeferredMaintenanceWindow]? = nil, elasticIpStatus: AwsRedshiftClusterElasticIpStatus? = nil, elasticResizeNumberOfNodeOptions: String? = nil, encrypted: Bool? = nil, endpoint: AwsRedshiftClusterEndpoint? = nil, enhancedVpcRouting: Bool? = nil, expectedNextSnapshotScheduleTime: String? = nil, expectedNextSnapshotScheduleTimeStatus: String? = nil, hsmStatus: AwsRedshiftClusterHsmStatus? = nil, iamRoles: [AwsRedshiftClusterIamRole]? = nil, kmsKeyId: String? = nil, loggingStatus: AwsRedshiftClusterLoggingStatus? = nil, maintenanceTrackName: String? = nil, manualSnapshotRetentionPeriod: Int? = nil, masterUsername: String? = nil, nextMaintenanceWindowStartTime: String? = nil, nodeType: String? = nil, numberOfNodes: Int? = nil, pendingActions: [String]? = nil, pendingModifiedValues: AwsRedshiftClusterPendingModifiedValues? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, resizeInfo: AwsRedshiftClusterResizeInfo? = nil, restoreStatus: AwsRedshiftClusterRestoreStatus? = nil, snapshotScheduleIdentifier: String? = nil, snapshotScheduleState: String? = nil, vpcId: String? = nil, vpcSecurityGroups: [AwsRedshiftClusterVpcSecurityGroup]? = nil) {
            self.allowVersionUpgrade = allowVersionUpgrade
            self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
            self.availabilityZone = availabilityZone
            self.clusterAvailabilityStatus = clusterAvailabilityStatus
            self.clusterCreateTime = clusterCreateTime
            self.clusterIdentifier = clusterIdentifier
            self.clusterNodes = clusterNodes
            self.clusterParameterGroups = clusterParameterGroups
            self.clusterPublicKey = clusterPublicKey
            self.clusterRevisionNumber = clusterRevisionNumber
            self.clusterSecurityGroups = clusterSecurityGroups
            self.clusterSnapshotCopyStatus = clusterSnapshotCopyStatus
            self.clusterStatus = clusterStatus
            self.clusterSubnetGroupName = clusterSubnetGroupName
            self.clusterVersion = clusterVersion
            self.dbName = dbName
            self.deferredMaintenanceWindows = deferredMaintenanceWindows
            self.elasticIpStatus = elasticIpStatus
            self.elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions
            self.encrypted = encrypted
            self.endpoint = endpoint
            self.enhancedVpcRouting = enhancedVpcRouting
            self.expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime
            self.expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus
            self.hsmStatus = hsmStatus
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.loggingStatus = loggingStatus
            self.maintenanceTrackName = maintenanceTrackName
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.masterUsername = masterUsername
            self.nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.pendingActions = pendingActions
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.resizeInfo = resizeInfo
            self.restoreStatus = restoreStatus
            self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
            self.snapshotScheduleState = snapshotScheduleState
            self.vpcId = vpcId
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "\\S")
            try self.validate(self.clusterAvailabilityStatus, name: "clusterAvailabilityStatus", parent: name, pattern: "\\S")
            try self.validate(self.clusterCreateTime, name: "clusterCreateTime", parent: name, pattern: "\\S")
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "\\S")
            try self.clusterNodes?.forEach {
                try $0.validate(name: "\(name).clusterNodes[]")
            }
            try self.clusterParameterGroups?.forEach {
                try $0.validate(name: "\(name).clusterParameterGroups[]")
            }
            try self.validate(self.clusterPublicKey, name: "clusterPublicKey", parent: name, pattern: "\\S")
            try self.validate(self.clusterRevisionNumber, name: "clusterRevisionNumber", parent: name, pattern: "\\S")
            try self.clusterSecurityGroups?.forEach {
                try $0.validate(name: "\(name).clusterSecurityGroups[]")
            }
            try self.clusterSnapshotCopyStatus?.validate(name: "\(name).clusterSnapshotCopyStatus")
            try self.validate(self.clusterStatus, name: "clusterStatus", parent: name, pattern: "\\S")
            try self.validate(self.clusterSubnetGroupName, name: "clusterSubnetGroupName", parent: name, pattern: "\\S")
            try self.validate(self.clusterVersion, name: "clusterVersion", parent: name, pattern: "\\S")
            try self.validate(self.dbName, name: "dbName", parent: name, pattern: "\\S")
            try self.deferredMaintenanceWindows?.forEach {
                try $0.validate(name: "\(name).deferredMaintenanceWindows[]")
            }
            try self.elasticIpStatus?.validate(name: "\(name).elasticIpStatus")
            try self.validate(self.elasticResizeNumberOfNodeOptions, name: "elasticResizeNumberOfNodeOptions", parent: name, pattern: "\\S")
            try self.endpoint?.validate(name: "\(name).endpoint")
            try self.validate(self.expectedNextSnapshotScheduleTime, name: "expectedNextSnapshotScheduleTime", parent: name, pattern: "\\S")
            try self.validate(self.expectedNextSnapshotScheduleTimeStatus, name: "expectedNextSnapshotScheduleTimeStatus", parent: name, pattern: "\\S")
            try self.hsmStatus?.validate(name: "\(name).hsmStatus")
            try self.iamRoles?.forEach {
                try $0.validate(name: "\(name).iamRoles[]")
            }
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.loggingStatus?.validate(name: "\(name).loggingStatus")
            try self.validate(self.maintenanceTrackName, name: "maintenanceTrackName", parent: name, pattern: "\\S")
            try self.validate(self.masterUsername, name: "masterUsername", parent: name, pattern: "\\S")
            try self.validate(self.nextMaintenanceWindowStartTime, name: "nextMaintenanceWindowStartTime", parent: name, pattern: "\\S")
            try self.validate(self.nodeType, name: "nodeType", parent: name, pattern: "\\S")
            try self.pendingActions?.forEach {
                try validate($0, name: "pendingActions[]", parent: name, pattern: "\\S")
            }
            try self.pendingModifiedValues?.validate(name: "\(name).pendingModifiedValues")
            try self.validate(self.preferredMaintenanceWindow, name: "preferredMaintenanceWindow", parent: name, pattern: "\\S")
            try self.resizeInfo?.validate(name: "\(name).resizeInfo")
            try self.restoreStatus?.validate(name: "\(name).restoreStatus")
            try self.validate(self.snapshotScheduleIdentifier, name: "snapshotScheduleIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.snapshotScheduleState, name: "snapshotScheduleState", parent: name, pattern: "\\S")
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
            try self.vpcSecurityGroups?.forEach {
                try $0.validate(name: "\(name).vpcSecurityGroups[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowVersionUpgrade = "AllowVersionUpgrade"
            case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
            case availabilityZone = "AvailabilityZone"
            case clusterAvailabilityStatus = "ClusterAvailabilityStatus"
            case clusterCreateTime = "ClusterCreateTime"
            case clusterIdentifier = "ClusterIdentifier"
            case clusterNodes = "ClusterNodes"
            case clusterParameterGroups = "ClusterParameterGroups"
            case clusterPublicKey = "ClusterPublicKey"
            case clusterRevisionNumber = "ClusterRevisionNumber"
            case clusterSecurityGroups = "ClusterSecurityGroups"
            case clusterSnapshotCopyStatus = "ClusterSnapshotCopyStatus"
            case clusterStatus = "ClusterStatus"
            case clusterSubnetGroupName = "ClusterSubnetGroupName"
            case clusterVersion = "ClusterVersion"
            case dbName = "DBName"
            case deferredMaintenanceWindows = "DeferredMaintenanceWindows"
            case elasticIpStatus = "ElasticIpStatus"
            case elasticResizeNumberOfNodeOptions = "ElasticResizeNumberOfNodeOptions"
            case encrypted = "Encrypted"
            case endpoint = "Endpoint"
            case enhancedVpcRouting = "EnhancedVpcRouting"
            case expectedNextSnapshotScheduleTime = "ExpectedNextSnapshotScheduleTime"
            case expectedNextSnapshotScheduleTimeStatus = "ExpectedNextSnapshotScheduleTimeStatus"
            case hsmStatus = "HsmStatus"
            case iamRoles = "IamRoles"
            case kmsKeyId = "KmsKeyId"
            case loggingStatus = "LoggingStatus"
            case maintenanceTrackName = "MaintenanceTrackName"
            case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
            case masterUsername = "MasterUsername"
            case nextMaintenanceWindowStartTime = "NextMaintenanceWindowStartTime"
            case nodeType = "NodeType"
            case numberOfNodes = "NumberOfNodes"
            case pendingActions = "PendingActions"
            case pendingModifiedValues = "PendingModifiedValues"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case publiclyAccessible = "PubliclyAccessible"
            case resizeInfo = "ResizeInfo"
            case restoreStatus = "RestoreStatus"
            case snapshotScheduleIdentifier = "SnapshotScheduleIdentifier"
            case snapshotScheduleState = "SnapshotScheduleState"
            case vpcId = "VpcId"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct AwsRedshiftClusterElasticIpStatus: AWSEncodableShape & AWSDecodableShape {
        /// The elastic IP address for the cluster.
        public let elasticIp: String?
        /// The status of the elastic IP address.
        public let status: String?

        @inlinable
        public init(elasticIp: String? = nil, status: String? = nil) {
            self.elasticIp = elasticIp
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.elasticIp, name: "elasticIp", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case elasticIp = "ElasticIp"
            case status = "Status"
        }
    }

    public struct AwsRedshiftClusterEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// The DNS address of the cluster.
        public let address: String?
        /// The port that the database engine listens on.
        public let port: Int?

        @inlinable
        public init(address: String? = nil, port: Int? = nil) {
            self.address = address
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case port = "Port"
        }
    }

    public struct AwsRedshiftClusterHsmStatus: AWSEncodableShape & AWSDecodableShape {
        /// The name of the HSM client certificate that the Amazon Redshift cluster uses to retrieve the data encryption keys that are stored in an HSM.
        public let hsmClientCertificateIdentifier: String?
        /// The name of the HSM configuration that contains the information that the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
        public let hsmConfigurationIdentifier: String?
        /// Indicates whether the Amazon Redshift cluster has finished applying any HSM settings changes specified in a modify cluster command. Type: String Valid values: active | applying
        public let status: String?

        @inlinable
        public init(hsmClientCertificateIdentifier: String? = nil, hsmConfigurationIdentifier: String? = nil, status: String? = nil) {
            self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
            self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.hsmClientCertificateIdentifier, name: "hsmClientCertificateIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.hsmConfigurationIdentifier, name: "hsmConfigurationIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hsmClientCertificateIdentifier = "HsmClientCertificateIdentifier"
            case hsmConfigurationIdentifier = "HsmConfigurationIdentifier"
            case status = "Status"
        }
    }

    public struct AwsRedshiftClusterIamRole: AWSEncodableShape & AWSDecodableShape {
        /// The status of the IAM role's association with the cluster. Valid values: in-sync | adding | removing
        public let applyStatus: String?
        /// The ARN of the IAM role.
        public let iamRoleArn: String?

        @inlinable
        public init(applyStatus: String? = nil, iamRoleArn: String? = nil) {
            self.applyStatus = applyStatus
            self.iamRoleArn = iamRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.applyStatus, name: "applyStatus", parent: name, pattern: "\\S")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case applyStatus = "ApplyStatus"
            case iamRoleArn = "IamRoleArn"
        }
    }

    public struct AwsRedshiftClusterLoggingStatus: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket where the log files are stored.
        public let bucketName: String?
        /// The message indicating that the logs failed to be delivered.
        public let lastFailureMessage: String?
        /// The last time when logs failed to be delivered. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastFailureTime: String?
        /// The last time that logs were delivered successfully. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastSuccessfulDeliveryTime: String?
        /// Indicates whether logging is enabled.
        public let loggingEnabled: Bool?
        /// Provides the prefix applied to the log file names.
        public let s3KeyPrefix: String?

        @inlinable
        public init(bucketName: String? = nil, lastFailureMessage: String? = nil, lastFailureTime: String? = nil, lastSuccessfulDeliveryTime: String? = nil, loggingEnabled: Bool? = nil, s3KeyPrefix: String? = nil) {
            self.bucketName = bucketName
            self.lastFailureMessage = lastFailureMessage
            self.lastFailureTime = lastFailureTime
            self.lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTime
            self.loggingEnabled = loggingEnabled
            self.s3KeyPrefix = s3KeyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "\\S")
            try self.validate(self.lastFailureMessage, name: "lastFailureMessage", parent: name, pattern: "\\S")
            try self.validate(self.lastFailureTime, name: "lastFailureTime", parent: name, pattern: "\\S")
            try self.validate(self.lastSuccessfulDeliveryTime, name: "lastSuccessfulDeliveryTime", parent: name, pattern: "\\S")
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case lastFailureMessage = "LastFailureMessage"
            case lastFailureTime = "LastFailureTime"
            case lastSuccessfulDeliveryTime = "LastSuccessfulDeliveryTime"
            case loggingEnabled = "LoggingEnabled"
            case s3KeyPrefix = "S3KeyPrefix"
        }
    }

    public struct AwsRedshiftClusterPendingModifiedValues: AWSEncodableShape & AWSDecodableShape {
        /// The pending or in-progress change to the automated snapshot retention period.
        public let automatedSnapshotRetentionPeriod: Int?
        /// The pending or in-progress change to the identifier for the cluster.
        public let clusterIdentifier: String?
        /// The pending or in-progress change to the cluster type.
        public let clusterType: String?
        /// The pending or in-progress change to the service version.
        public let clusterVersion: String?
        /// The encryption type for a cluster.
        public let encryptionType: String?
        /// Indicates whether to create the cluster with enhanced VPC routing enabled.
        public let enhancedVpcRouting: Bool?
        /// The name of the maintenance track that the cluster changes to during the next maintenance window.
        public let maintenanceTrackName: String?
        /// The pending or in-progress change to the master user password for the cluster.
        public let masterUserPassword: String?
        /// The pending or in-progress change to the cluster's node type.
        public let nodeType: String?
        /// The pending or in-progress change to the number of nodes in the cluster.
        public let numberOfNodes: Int?
        /// The pending or in-progress change to whether the cluster can be connected to from the public network.
        public let publiclyAccessible: Bool?

        @inlinable
        public init(automatedSnapshotRetentionPeriod: Int? = nil, clusterIdentifier: String? = nil, clusterType: String? = nil, clusterVersion: String? = nil, encryptionType: String? = nil, enhancedVpcRouting: Bool? = nil, maintenanceTrackName: String? = nil, masterUserPassword: String? = nil, nodeType: String? = nil, numberOfNodes: Int? = nil, publiclyAccessible: Bool? = nil) {
            self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
            self.clusterIdentifier = clusterIdentifier
            self.clusterType = clusterType
            self.clusterVersion = clusterVersion
            self.encryptionType = encryptionType
            self.enhancedVpcRouting = enhancedVpcRouting
            self.maintenanceTrackName = maintenanceTrackName
            self.masterUserPassword = masterUserPassword
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.publiclyAccessible = publiclyAccessible
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.clusterType, name: "clusterType", parent: name, pattern: "\\S")
            try self.validate(self.clusterVersion, name: "clusterVersion", parent: name, pattern: "\\S")
            try self.validate(self.encryptionType, name: "encryptionType", parent: name, pattern: "\\S")
            try self.validate(self.maintenanceTrackName, name: "maintenanceTrackName", parent: name, pattern: "\\S")
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, pattern: "\\S")
            try self.validate(self.nodeType, name: "nodeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
            case clusterIdentifier = "ClusterIdentifier"
            case clusterType = "ClusterType"
            case clusterVersion = "ClusterVersion"
            case encryptionType = "EncryptionType"
            case enhancedVpcRouting = "EnhancedVpcRouting"
            case maintenanceTrackName = "MaintenanceTrackName"
            case masterUserPassword = "MasterUserPassword"
            case nodeType = "NodeType"
            case numberOfNodes = "NumberOfNodes"
            case publiclyAccessible = "PubliclyAccessible"
        }
    }

    public struct AwsRedshiftClusterResizeInfo: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the resize operation can be canceled.
        public let allowCancelResize: Bool?
        /// The type of resize operation. Valid values: ClassicResize
        public let resizeType: String?

        @inlinable
        public init(allowCancelResize: Bool? = nil, resizeType: String? = nil) {
            self.allowCancelResize = allowCancelResize
            self.resizeType = resizeType
        }

        public func validate(name: String) throws {
            try self.validate(self.resizeType, name: "resizeType", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case allowCancelResize = "AllowCancelResize"
            case resizeType = "ResizeType"
        }
    }

    public struct AwsRedshiftClusterRestoreStatus: AWSEncodableShape & AWSDecodableShape {
        /// The number of megabytes per second being transferred from the backup storage. Returns the average rate for a completed backup. This field is only updated when you restore to DC2 and DS2 node types.
        public let currentRestoreRateInMegaBytesPerSecond: Double?
        /// The amount of time an in-progress restore has been running, or the amount of time it took a completed restore to finish. This field is only updated when you restore to DC2 and DS2 node types.
        public let elapsedTimeInSeconds: Int64?
        /// The estimate of the time remaining before the restore is complete. Returns 0 for a completed restore. This field is only updated when you restore to DC2 and DS2 node types.
        public let estimatedTimeToCompletionInSeconds: Int64?
        /// The number of megabytes that were transferred from snapshot storage. This field is only updated when you restore to DC2 and DS2 node types.
        public let progressInMegaBytes: Int64?
        /// The size of the set of snapshot data that was used to restore the cluster. This field is only updated when you restore to DC2 and DS2 node types.
        public let snapshotSizeInMegaBytes: Int64?
        /// The status of the restore action. Valid values: starting | restoring | completed | failed
        public let status: String?

        @inlinable
        public init(currentRestoreRateInMegaBytesPerSecond: Double? = nil, elapsedTimeInSeconds: Int64? = nil, estimatedTimeToCompletionInSeconds: Int64? = nil, progressInMegaBytes: Int64? = nil, snapshotSizeInMegaBytes: Int64? = nil, status: String? = nil) {
            self.currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecond
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
            self.progressInMegaBytes = progressInMegaBytes
            self.snapshotSizeInMegaBytes = snapshotSizeInMegaBytes
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case currentRestoreRateInMegaBytesPerSecond = "CurrentRestoreRateInMegaBytesPerSecond"
            case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
            case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
            case progressInMegaBytes = "ProgressInMegaBytes"
            case snapshotSizeInMegaBytes = "SnapshotSizeInMegaBytes"
            case status = "Status"
        }
    }

    public struct AwsRedshiftClusterVpcSecurityGroup: AWSEncodableShape & AWSDecodableShape {
        /// The status of the VPC security group.
        public let status: String?
        /// The identifier of the VPC security group.
        public let vpcSecurityGroupId: String?

        @inlinable
        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.vpcSecurityGroupId, name: "vpcSecurityGroupId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }

    public struct AwsRoute53HostedZoneConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Any comments that you include about the hosted zone.
        public let comment: String?

        @inlinable
        public init(comment: String? = nil) {
            self.comment = comment
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "Comment"
        }
    }

    public struct AwsRoute53HostedZoneDetails: AWSEncodableShape & AWSDecodableShape {
        ///  An object that contains information about the specified hosted zone.
        public let hostedZone: AwsRoute53HostedZoneObjectDetails?
        ///  An object that contains a list of the authoritative name servers for a hosted zone or for a reusable delegation set.
        public let nameServers: [String]?
        ///  An array that contains one QueryLoggingConfig element for each DNS query logging configuration that is
        /// associated with the current Amazon Web Services account.
        public let queryLoggingConfig: AwsRoute53QueryLoggingConfigDetails?
        ///  An object that contains information about the Amazon Virtual Private Clouds (Amazon VPCs) that are associated with
        /// the specified hosted zone.
        public let vpcs: [AwsRoute53HostedZoneVpcDetails]?

        @inlinable
        public init(hostedZone: AwsRoute53HostedZoneObjectDetails? = nil, nameServers: [String]? = nil, queryLoggingConfig: AwsRoute53QueryLoggingConfigDetails? = nil, vpcs: [AwsRoute53HostedZoneVpcDetails]? = nil) {
            self.hostedZone = hostedZone
            self.nameServers = nameServers
            self.queryLoggingConfig = queryLoggingConfig
            self.vpcs = vpcs
        }

        public func validate(name: String) throws {
            try self.hostedZone?.validate(name: "\(name).hostedZone")
            try self.nameServers?.forEach {
                try validate($0, name: "nameServers[]", parent: name, pattern: "\\S")
            }
            try self.queryLoggingConfig?.validate(name: "\(name).queryLoggingConfig")
            try self.vpcs?.forEach {
                try $0.validate(name: "\(name).vpcs[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case hostedZone = "HostedZone"
            case nameServers = "NameServers"
            case queryLoggingConfig = "QueryLoggingConfig"
            case vpcs = "Vpcs"
        }
    }

    public struct AwsRoute53HostedZoneObjectDetails: AWSEncodableShape & AWSDecodableShape {
        ///  An object that includes the Comment element.
        public let config: AwsRoute53HostedZoneConfigDetails?
        ///  The ID that RouteÂ 53 assigns to the hosted zone when you create it.
        public let id: String?
        ///  The name of the domain. For public hosted zones, this is the name that you have registered with your DNS registrar.
        public let name: String?

        @inlinable
        public init(config: AwsRoute53HostedZoneConfigDetails? = nil, id: String? = nil, name: String? = nil) {
            self.config = config
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.config?.validate(name: "\(name).config")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct AwsRoute53HostedZoneVpcDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The identifier of an Amazon VPC.
        public let id: String?
        ///  The Amazon Web Services Region that an Amazon VPC was created in.
        public let region: String?

        @inlinable
        public init(id: String? = nil, region: String? = nil) {
            self.id = id
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.region, name: "region", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case region = "Region"
        }
    }

    public struct AwsRoute53QueryLoggingConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log group that RouteÂ 53 is publishing logs to.
        public let cloudWatchLogsLogGroupArn: CloudWatchLogsLogGroupArnConfigDetails?

        @inlinable
        public init(cloudWatchLogsLogGroupArn: CloudWatchLogsLogGroupArnConfigDetails? = nil) {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogsLogGroupArn?.validate(name: "\(name).cloudWatchLogsLogGroupArn")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        }
    }

    public struct AwsS3AccessPointDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the access point.
        public let accessPointArn: String?
        ///  The name or alias of the access point.
        public let alias: String?
        ///  The name of the S3 bucket associated with the specified access point.
        public let bucket: String?
        ///  The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
        public let bucketAccountId: String?
        ///  The name of the specified access point.
        public let name: String?
        ///  Indicates whether this access point allows access from the public internet.
        public let networkOrigin: String?
        public let publicAccessBlockConfiguration: AwsS3AccountPublicAccessBlockDetails?
        ///  Contains the virtual private cloud (VPC) configuration for the specified access point.
        public let vpcConfiguration: AwsS3AccessPointVpcConfigurationDetails?

        @inlinable
        public init(accessPointArn: String? = nil, alias: String? = nil, bucket: String? = nil, bucketAccountId: String? = nil, name: String? = nil, networkOrigin: String? = nil, publicAccessBlockConfiguration: AwsS3AccountPublicAccessBlockDetails? = nil, vpcConfiguration: AwsS3AccessPointVpcConfigurationDetails? = nil) {
            self.accessPointArn = accessPointArn
            self.alias = alias
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
            self.name = name
            self.networkOrigin = networkOrigin
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
            self.vpcConfiguration = vpcConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPointArn, name: "accessPointArn", parent: name, pattern: "\\S")
            try self.validate(self.alias, name: "alias", parent: name, pattern: "\\S")
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "\\S")
            try self.validate(self.bucketAccountId, name: "bucketAccountId", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.networkOrigin, name: "networkOrigin", parent: name, pattern: "\\S")
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointArn = "AccessPointArn"
            case alias = "Alias"
            case bucket = "Bucket"
            case bucketAccountId = "BucketAccountId"
            case name = "Name"
            case networkOrigin = "NetworkOrigin"
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct AwsS3AccessPointVpcConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  If this field is specified, this access point will only allow connections from the specified VPC ID.
        public let vpcId: String?

        @inlinable
        public init(vpcId: String? = nil) {
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case vpcId = "VpcId"
        }
    }

    public struct AwsS3AccountPublicAccessBlockDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether to reject calls to update an S3 bucket if the calls include a public access control list (ACL).
        public let blockPublicAcls: Bool?
        /// Indicates whether to reject calls to update the access policy for an S3 bucket or access point if the policy allows public access.
        public let blockPublicPolicy: Bool?
        /// Indicates whether Amazon S3 ignores public ACLs that are associated with an S3 bucket.
        public let ignorePublicAcls: Bool?
        /// Indicates whether to restrict access to an access point or S3 bucket that has a public policy to only Amazon Web Services service principals and authorized users within the S3 bucket owner's account.
        public let restrictPublicBuckets: Bool?

        @inlinable
        public init(blockPublicAcls: Bool? = nil, blockPublicPolicy: Bool? = nil, ignorePublicAcls: Bool? = nil, restrictPublicBuckets: Bool? = nil) {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAcls = "BlockPublicAcls"
            case blockPublicPolicy = "BlockPublicPolicy"
            case ignorePublicAcls = "IgnorePublicAcls"
            case restrictPublicBuckets = "RestrictPublicBuckets"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The lifecycle rules.
        public let rules: [AwsS3BucketBucketLifecycleConfigurationRulesDetails]?

        @inlinable
        public init(rules: [AwsS3BucketBucketLifecycleConfigurationRulesDetails]? = nil) {
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of days after which Amazon S3 cancels an incomplete multipart upload.
        public let daysAfterInitiation: Int?

        @inlinable
        public init(daysAfterInitiation: Int? = nil) {
            self.daysAfterInitiation = daysAfterInitiation
        }

        private enum CodingKeys: String, CodingKey {
            case daysAfterInitiation = "DaysAfterInitiation"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesDetails: AWSEncodableShape & AWSDecodableShape {
        /// How Amazon S3 responds when a multipart upload is incomplete. Specifically, provides a number of days before Amazon S3 cancels the entire upload.
        public let abortIncompleteMultipartUpload: AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails?
        /// The date when objects are moved or deleted. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let expirationDate: String?
        /// The length in days of the lifetime for objects that are subject to the rule.
        public let expirationInDays: Int?
        /// Whether Amazon S3 removes a delete marker that has no noncurrent versions. If set to true, the delete marker is expired. If set to false, the policy takes no action. If you provide ExpiredObjectDeleteMarker, you cannot provide ExpirationInDays or ExpirationDate.
        public let expiredObjectDeleteMarker: Bool?
        /// Identifies the objects that a rule applies to.
        public let filter: AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails?
        /// The unique identifier of the rule.
        public let id: String?
        /// The number of days that an object is noncurrent before Amazon S3 can perform the associated action.
        public let noncurrentVersionExpirationInDays: Int?
        /// Transition rules that describe when noncurrent objects transition to a specified storage class.
        public let noncurrentVersionTransitions: [AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]?
        /// A prefix that identifies one or more objects that the rule applies to.
        public let prefix: String?
        /// The current status of the rule. Indicates whether the rule is currently being applied.
        public let status: String?
        /// Transition rules that indicate when objects transition to a specified storage class.
        public let transitions: [AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails]?

        @inlinable
        public init(abortIncompleteMultipartUpload: AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails? = nil, expirationDate: String? = nil, expirationInDays: Int? = nil, expiredObjectDeleteMarker: Bool? = nil, filter: AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails? = nil, id: String? = nil, noncurrentVersionExpirationInDays: Int? = nil, noncurrentVersionTransitions: [AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]? = nil, prefix: String? = nil, status: String? = nil, transitions: [AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails]? = nil) {
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.expirationDate = expirationDate
            self.expirationInDays = expirationInDays
            self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
            self.filter = filter
            self.id = id
            self.noncurrentVersionExpirationInDays = noncurrentVersionExpirationInDays
            self.noncurrentVersionTransitions = noncurrentVersionTransitions
            self.prefix = prefix
            self.status = status
            self.transitions = transitions
        }

        public func validate(name: String) throws {
            try self.validate(self.expirationDate, name: "expirationDate", parent: name, pattern: "\\S")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.noncurrentVersionTransitions?.forEach {
                try $0.validate(name: "\(name).noncurrentVersionTransitions[]")
            }
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.transitions?.forEach {
                try $0.validate(name: "\(name).transitions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case abortIncompleteMultipartUpload = "AbortIncompleteMultipartUpload"
            case expirationDate = "ExpirationDate"
            case expirationInDays = "ExpirationInDays"
            case expiredObjectDeleteMarker = "ExpiredObjectDeleteMarker"
            case filter = "Filter"
            case id = "ID"
            case noncurrentVersionExpirationInDays = "NoncurrentVersionExpirationInDays"
            case noncurrentVersionTransitions = "NoncurrentVersionTransitions"
            case prefix = "Prefix"
            case status = "Status"
            case transitions = "Transitions"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the filter.
        public let predicate: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails?

        @inlinable
        public init(predicate: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails? = nil) {
            self.predicate = predicate
        }

        public func validate(name: String) throws {
            try self.predicate?.validate(name: "\(name).predicate")
        }

        private enum CodingKeys: String, CodingKey {
            case predicate = "Predicate"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails: AWSEncodableShape & AWSDecodableShape {
        /// The values to use for the filter.
        public let operands: [AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]?
        /// A prefix filter.
        public let prefix: String?
        /// A tag filter.
        public let tag: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails?
        /// Whether to use AND or OR to join the operands.
        /// Valid values are LifecycleAndOperator or LifecycleOrOperator.
        public let type: String?

        @inlinable
        public init(operands: [AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]? = nil, prefix: String? = nil, tag: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails? = nil, type: String? = nil) {
            self.operands = operands
            self.prefix = prefix
            self.tag = tag
            self.type = type
        }

        public func validate(name: String) throws {
            try self.operands?.forEach {
                try $0.validate(name: "\(name).operands[]")
            }
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "\\S")
            try self.tag?.validate(name: "\(name).tag")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case operands = "Operands"
            case prefix = "Prefix"
            case tag = "Tag"
            case type = "Type"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Prefix text for matching objects.
        public let prefix: String?
        /// A tag that is assigned to matching objects.
        public let tag: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails?
        /// The type of filter value.
        /// Valid values are LifecyclePrefixPredicate or LifecycleTagPredicate.
        public let type: String?

        @inlinable
        public init(prefix: String? = nil, tag: AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails? = nil, type: String? = nil) {
            self.prefix = prefix
            self.tag = tag
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "\\S")
            try self.tag?.validate(name: "\(name).tag")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case prefix = "Prefix"
            case tag = "Tag"
            case type = "Type"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails: AWSEncodableShape & AWSDecodableShape {
        /// The tag key.
        public let key: String?
        /// The tag value.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails: AWSEncodableShape & AWSDecodableShape {
        /// The tag key.
        public let key: String?
        /// The tag value
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The number of days that an object is noncurrent before Amazon S3 can perform the associated action.
        public let days: Int?
        /// The class of storage to change the object to after the object is noncurrent for the specified number of days.
        public let storageClass: String?

        @inlinable
        public init(days: Int? = nil, storageClass: String? = nil) {
            self.days = days
            self.storageClass = storageClass
        }

        public func validate(name: String) throws {
            try self.validate(self.storageClass, name: "storageClass", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case days = "Days"
            case storageClass = "StorageClass"
        }
    }

    public struct AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// A date on which to transition objects to the specified storage class. If you provide Date, you cannot provide Days. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let date: String?
        /// The number of days after which to transition the object to the specified storage class. If you provide Days, you cannot provide Date.
        public let days: Int?
        /// The storage class to transition the object to. Valid values are as follows:    DEEP_ARCHIVE     GLACIER     INTELLIGENT_TIERING     ONEZONE_IA     STANDARD_IA
        public let storageClass: String?

        @inlinable
        public init(date: String? = nil, days: Int? = nil, storageClass: String? = nil) {
            self.date = date
            self.days = days
            self.storageClass = storageClass
        }

        public func validate(name: String) throws {
            try self.validate(self.date, name: "date", parent: name, pattern: "\\S")
            try self.validate(self.storageClass, name: "storageClass", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case days = "Days"
            case storageClass = "StorageClass"
        }
    }

    public struct AwsS3BucketBucketVersioningConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether MFA delete is currently enabled in the S3 bucket versioning configuration. If the S3 bucket was never configured with MFA delete, then this attribute is not included.
        public let isMfaDeleteEnabled: Bool?
        /// The versioning status of the S3 bucket. Valid values are Enabled or Suspended.
        public let status: String?

        @inlinable
        public init(isMfaDeleteEnabled: Bool? = nil, status: String? = nil) {
            self.isMfaDeleteEnabled = isMfaDeleteEnabled
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case isMfaDeleteEnabled = "IsMfaDeleteEnabled"
            case status = "Status"
        }
    }

    public struct AwsS3BucketDetails: AWSEncodableShape & AWSDecodableShape {
        /// The access control list for the S3 bucket.
        public let accessControlList: String?
        /// The lifecycle configuration for objects in the specified bucket.
        public let bucketLifecycleConfiguration: AwsS3BucketBucketLifecycleConfigurationDetails?
        /// The logging configuration for the S3 bucket.
        public let bucketLoggingConfiguration: AwsS3BucketLoggingConfiguration?
        /// The notification configuration for the S3 bucket.
        public let bucketNotificationConfiguration: AwsS3BucketNotificationConfiguration?
        /// The versioning state of an S3 bucket.
        public let bucketVersioningConfiguration: AwsS3BucketBucketVersioningConfiguration?
        /// The website configuration parameters for the S3 bucket.
        public let bucketWebsiteConfiguration: AwsS3BucketWebsiteConfiguration?
        /// Indicates when the S3 bucket was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdAt: String?
        ///  The name of the bucket.
        public let name: String?
        ///  Specifies which rule Amazon S3 applies by default to every new object placed in the bucket.
        public let objectLockConfiguration: AwsS3BucketObjectLockConfiguration?
        /// The Amazon Web Services account identifier of the account that owns the S3 bucket.
        public let ownerAccountId: String?
        /// The canonical user ID of the owner of the S3 bucket.
        public let ownerId: String?
        /// The display name of the owner of the S3 bucket.
        public let ownerName: String?
        /// Provides information about the Amazon S3 Public Access Block configuration for the S3 bucket.
        public let publicAccessBlockConfiguration: AwsS3AccountPublicAccessBlockDetails?
        /// The encryption rules that are applied to the S3 bucket.
        public let serverSideEncryptionConfiguration: AwsS3BucketServerSideEncryptionConfiguration?

        @inlinable
        public init(accessControlList: String? = nil, bucketLifecycleConfiguration: AwsS3BucketBucketLifecycleConfigurationDetails? = nil, bucketLoggingConfiguration: AwsS3BucketLoggingConfiguration? = nil, bucketNotificationConfiguration: AwsS3BucketNotificationConfiguration? = nil, bucketVersioningConfiguration: AwsS3BucketBucketVersioningConfiguration? = nil, bucketWebsiteConfiguration: AwsS3BucketWebsiteConfiguration? = nil, createdAt: String? = nil, name: String? = nil, objectLockConfiguration: AwsS3BucketObjectLockConfiguration? = nil, ownerAccountId: String? = nil, ownerId: String? = nil, ownerName: String? = nil, publicAccessBlockConfiguration: AwsS3AccountPublicAccessBlockDetails? = nil, serverSideEncryptionConfiguration: AwsS3BucketServerSideEncryptionConfiguration? = nil) {
            self.accessControlList = accessControlList
            self.bucketLifecycleConfiguration = bucketLifecycleConfiguration
            self.bucketLoggingConfiguration = bucketLoggingConfiguration
            self.bucketNotificationConfiguration = bucketNotificationConfiguration
            self.bucketVersioningConfiguration = bucketVersioningConfiguration
            self.bucketWebsiteConfiguration = bucketWebsiteConfiguration
            self.createdAt = createdAt
            self.name = name
            self.objectLockConfiguration = objectLockConfiguration
            self.ownerAccountId = ownerAccountId
            self.ownerId = ownerId
            self.ownerName = ownerName
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.accessControlList, name: "accessControlList", parent: name, pattern: "\\S")
            try self.bucketLifecycleConfiguration?.validate(name: "\(name).bucketLifecycleConfiguration")
            try self.bucketLoggingConfiguration?.validate(name: "\(name).bucketLoggingConfiguration")
            try self.bucketNotificationConfiguration?.validate(name: "\(name).bucketNotificationConfiguration")
            try self.bucketVersioningConfiguration?.validate(name: "\(name).bucketVersioningConfiguration")
            try self.bucketWebsiteConfiguration?.validate(name: "\(name).bucketWebsiteConfiguration")
            try self.validate(self.createdAt, name: "createdAt", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.objectLockConfiguration?.validate(name: "\(name).objectLockConfiguration")
            try self.validate(self.ownerAccountId, name: "ownerAccountId", parent: name, pattern: "\\S")
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "\\S")
            try self.validate(self.ownerName, name: "ownerName", parent: name, pattern: "\\S")
            try self.serverSideEncryptionConfiguration?.validate(name: "\(name).serverSideEncryptionConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlList = "AccessControlList"
            case bucketLifecycleConfiguration = "BucketLifecycleConfiguration"
            case bucketLoggingConfiguration = "BucketLoggingConfiguration"
            case bucketNotificationConfiguration = "BucketNotificationConfiguration"
            case bucketVersioningConfiguration = "BucketVersioningConfiguration"
            case bucketWebsiteConfiguration = "BucketWebsiteConfiguration"
            case createdAt = "CreatedAt"
            case name = "Name"
            case objectLockConfiguration = "ObjectLockConfiguration"
            case ownerAccountId = "OwnerAccountId"
            case ownerId = "OwnerId"
            case ownerName = "OwnerName"
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
            case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        }
    }

    public struct AwsS3BucketLoggingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket where log files for the S3 bucket are stored.
        public let destinationBucketName: String?
        /// The prefix added to log files for the S3 bucket.
        public let logFilePrefix: String?

        @inlinable
        public init(destinationBucketName: String? = nil, logFilePrefix: String? = nil) {
            self.destinationBucketName = destinationBucketName
            self.logFilePrefix = logFilePrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationBucketName, name: "destinationBucketName", parent: name, pattern: "\\S")
            try self.validate(self.logFilePrefix, name: "logFilePrefix", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationBucketName = "DestinationBucketName"
            case logFilePrefix = "LogFilePrefix"
        }
    }

    public struct AwsS3BucketNotificationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configurations for S3 bucket notifications.
        public let configurations: [AwsS3BucketNotificationConfigurationDetail]?

        @inlinable
        public init(configurations: [AwsS3BucketNotificationConfigurationDetail]? = nil) {
            self.configurations = configurations
        }

        public func validate(name: String) throws {
            try self.configurations?.forEach {
                try $0.validate(name: "\(name).configurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurations = "Configurations"
        }
    }

    public struct AwsS3BucketNotificationConfigurationDetail: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the Lambda function, Amazon SQS queue, or Amazon SNS topic that generates the notification.
        public let destination: String?
        /// The list of events that trigger a notification.
        public let events: [String]?
        /// The filters that determine which S3 buckets generate notifications.
        public let filter: AwsS3BucketNotificationConfigurationFilter?
        /// Indicates the type of notification. Notifications can be generated using Lambda functions, Amazon SQS queues, or Amazon SNS topics, with corresponding valid values as follows:    LambdaConfiguration     QueueConfiguration     TopicConfiguration
        public let type: String?

        @inlinable
        public init(destination: String? = nil, events: [String]? = nil, filter: AwsS3BucketNotificationConfigurationFilter? = nil, type: String? = nil) {
            self.destination = destination
            self.events = events
            self.filter = filter
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, pattern: "\\S")
            try self.events?.forEach {
                try validate($0, name: "events[]", parent: name, pattern: "\\S")
            }
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case events = "Events"
            case filter = "Filter"
            case type = "Type"
        }
    }

    public struct AwsS3BucketNotificationConfigurationFilter: AWSEncodableShape & AWSDecodableShape {
        /// Details for an Amazon S3 filter.
        public let s3KeyFilter: AwsS3BucketNotificationConfigurationS3KeyFilter?

        @inlinable
        public init(s3KeyFilter: AwsS3BucketNotificationConfigurationS3KeyFilter? = nil) {
            self.s3KeyFilter = s3KeyFilter
        }

        public func validate(name: String) throws {
            try self.s3KeyFilter?.validate(name: "\(name).s3KeyFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case s3KeyFilter = "S3KeyFilter"
        }
    }

    public struct AwsS3BucketNotificationConfigurationS3KeyFilter: AWSEncodableShape & AWSDecodableShape {
        /// The filter rules for the filter.
        public let filterRules: [AwsS3BucketNotificationConfigurationS3KeyFilterRule]?

        @inlinable
        public init(filterRules: [AwsS3BucketNotificationConfigurationS3KeyFilterRule]? = nil) {
            self.filterRules = filterRules
        }

        public func validate(name: String) throws {
            try self.filterRules?.forEach {
                try $0.validate(name: "\(name).filterRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filterRules = "FilterRules"
        }
    }

    public struct AwsS3BucketNotificationConfigurationS3KeyFilterRule: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the filter is based on the prefix or suffix of the Amazon S3 key.
        public let name: AwsS3BucketNotificationConfigurationS3KeyFilterRuleName?
        /// The filter value.
        public let value: String?

        @inlinable
        public init(name: AwsS3BucketNotificationConfigurationS3KeyFilterRuleName? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsS3BucketObjectLockConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether the bucket has an Object Lock configuration enabled.
        public let objectLockEnabled: String?
        ///  Specifies the Object Lock rule for the specified object.
        public let rule: AwsS3BucketObjectLockConfigurationRuleDetails?

        @inlinable
        public init(objectLockEnabled: String? = nil, rule: AwsS3BucketObjectLockConfigurationRuleDetails? = nil) {
            self.objectLockEnabled = objectLockEnabled
            self.rule = rule
        }

        public func validate(name: String) throws {
            try self.validate(self.objectLockEnabled, name: "objectLockEnabled", parent: name, pattern: "\\S")
            try self.rule?.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case objectLockEnabled = "ObjectLockEnabled"
            case rule = "Rule"
        }
    }

    public struct AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The number of days that you want to specify for the default retention period.
        public let days: Int?
        ///  The default Object Lock retention mode you want to apply to new objects placed in the specified bucket.
        public let mode: String?
        ///  The number of years that you want to specify for the default retention period.
        public let years: Int?

        @inlinable
        public init(days: Int? = nil, mode: String? = nil, years: Int? = nil) {
            self.days = days
            self.mode = mode
            self.years = years
        }

        public func validate(name: String) throws {
            try self.validate(self.mode, name: "mode", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case days = "Days"
            case mode = "Mode"
            case years = "Years"
        }
    }

    public struct AwsS3BucketObjectLockConfigurationRuleDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The default Object Lock retention mode and period that you want to apply to new objects placed in the specified bucket.
        public let defaultRetention: AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails?

        @inlinable
        public init(defaultRetention: AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails? = nil) {
            self.defaultRetention = defaultRetention
        }

        public func validate(name: String) throws {
            try self.defaultRetention?.validate(name: "\(name).defaultRetention")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultRetention = "DefaultRetention"
        }
    }

    public struct AwsS3BucketServerSideEncryptionByDefault: AWSEncodableShape & AWSDecodableShape {
        /// KMS key ID to use for the default encryption.
        public let kmsMasterKeyID: String?
        /// Server-side encryption algorithm to use for the default encryption. Valid values are
        /// aws: kms or AES256.
        public let sseAlgorithm: String?

        @inlinable
        public init(kmsMasterKeyID: String? = nil, sseAlgorithm: String? = nil) {
            self.kmsMasterKeyID = kmsMasterKeyID
            self.sseAlgorithm = sseAlgorithm
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsMasterKeyID, name: "kmsMasterKeyID", parent: name, pattern: "\\S")
            try self.validate(self.sseAlgorithm, name: "sseAlgorithm", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsMasterKeyID = "KMSMasterKeyID"
            case sseAlgorithm = "SSEAlgorithm"
        }
    }

    public struct AwsS3BucketServerSideEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The encryption rules that are applied to the S3 bucket.
        public let rules: [AwsS3BucketServerSideEncryptionRule]?

        @inlinable
        public init(rules: [AwsS3BucketServerSideEncryptionRule]? = nil) {
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
        }
    }

    public struct AwsS3BucketServerSideEncryptionRule: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT object request doesn't specify any server-side encryption, this default encryption is applied.
        public let applyServerSideEncryptionByDefault: AwsS3BucketServerSideEncryptionByDefault?

        @inlinable
        public init(applyServerSideEncryptionByDefault: AwsS3BucketServerSideEncryptionByDefault? = nil) {
            self.applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault
        }

        public func validate(name: String) throws {
            try self.applyServerSideEncryptionByDefault?.validate(name: "\(name).applyServerSideEncryptionByDefault")
        }

        private enum CodingKeys: String, CodingKey {
            case applyServerSideEncryptionByDefault = "ApplyServerSideEncryptionByDefault"
        }
    }

    public struct AwsS3BucketWebsiteConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the error document for the website.
        public let errorDocument: String?
        /// The name of the index document for the website.
        public let indexDocumentSuffix: String?
        /// The redirect behavior for requests to the website.
        public let redirectAllRequestsTo: AwsS3BucketWebsiteConfigurationRedirectTo?
        /// The rules for applying redirects for requests to the website.
        public let routingRules: [AwsS3BucketWebsiteConfigurationRoutingRule]?

        @inlinable
        public init(errorDocument: String? = nil, indexDocumentSuffix: String? = nil, redirectAllRequestsTo: AwsS3BucketWebsiteConfigurationRedirectTo? = nil, routingRules: [AwsS3BucketWebsiteConfigurationRoutingRule]? = nil) {
            self.errorDocument = errorDocument
            self.indexDocumentSuffix = indexDocumentSuffix
            self.redirectAllRequestsTo = redirectAllRequestsTo
            self.routingRules = routingRules
        }

        public func validate(name: String) throws {
            try self.validate(self.errorDocument, name: "errorDocument", parent: name, pattern: "\\S")
            try self.validate(self.indexDocumentSuffix, name: "indexDocumentSuffix", parent: name, pattern: "\\S")
            try self.redirectAllRequestsTo?.validate(name: "\(name).redirectAllRequestsTo")
            try self.routingRules?.forEach {
                try $0.validate(name: "\(name).routingRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case errorDocument = "ErrorDocument"
            case indexDocumentSuffix = "IndexDocumentSuffix"
            case redirectAllRequestsTo = "RedirectAllRequestsTo"
            case routingRules = "RoutingRules"
        }
    }

    public struct AwsS3BucketWebsiteConfigurationRedirectTo: AWSEncodableShape & AWSDecodableShape {
        /// The name of the host to redirect requests to.
        public let hostname: String?
        /// The protocol to use when redirecting requests. By default, this field uses the same protocol as the original request. Valid values are http or https.
        public let `protocol`: String?

        @inlinable
        public init(hostname: String? = nil, protocol: String? = nil) {
            self.hostname = hostname
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.hostname, name: "hostname", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "Hostname"
            case `protocol` = "Protocol"
        }
    }

    public struct AwsS3BucketWebsiteConfigurationRoutingRule: AWSEncodableShape & AWSDecodableShape {
        /// Provides the condition that must be met in order to apply the routing rule.
        public let condition: AwsS3BucketWebsiteConfigurationRoutingRuleCondition?
        /// Provides the rules to redirect the request if the condition in Condition is met.
        public let redirect: AwsS3BucketWebsiteConfigurationRoutingRuleRedirect?

        @inlinable
        public init(condition: AwsS3BucketWebsiteConfigurationRoutingRuleCondition? = nil, redirect: AwsS3BucketWebsiteConfigurationRoutingRuleRedirect? = nil) {
            self.condition = condition
            self.redirect = redirect
        }

        public func validate(name: String) throws {
            try self.condition?.validate(name: "\(name).condition")
            try self.redirect?.validate(name: "\(name).redirect")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case redirect = "Redirect"
        }
    }

    public struct AwsS3BucketWebsiteConfigurationRoutingRuleCondition: AWSEncodableShape & AWSDecodableShape {
        /// Indicates to redirect the request if the HTTP error code matches this value.
        public let httpErrorCodeReturnedEquals: String?
        /// Indicates to redirect the request if the key prefix matches this value.
        public let keyPrefixEquals: String?

        @inlinable
        public init(httpErrorCodeReturnedEquals: String? = nil, keyPrefixEquals: String? = nil) {
            self.httpErrorCodeReturnedEquals = httpErrorCodeReturnedEquals
            self.keyPrefixEquals = keyPrefixEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.httpErrorCodeReturnedEquals, name: "httpErrorCodeReturnedEquals", parent: name, pattern: "\\S")
            try self.validate(self.keyPrefixEquals, name: "keyPrefixEquals", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case httpErrorCodeReturnedEquals = "HttpErrorCodeReturnedEquals"
            case keyPrefixEquals = "KeyPrefixEquals"
        }
    }

    public struct AwsS3BucketWebsiteConfigurationRoutingRuleRedirect: AWSEncodableShape & AWSDecodableShape {
        /// The host name to use in the redirect request.
        public let hostname: String?
        /// The HTTP redirect code to use in the response.
        public let httpRedirectCode: String?
        /// The protocol to use to redirect the request. By default, uses the protocol from the original request.
        public let `protocol`: String?
        /// The object key prefix to use in the redirect request. Cannot be provided if ReplaceKeyWith is present.
        public let replaceKeyPrefixWith: String?
        /// The specific object key to use in the redirect request. Cannot be provided if ReplaceKeyPrefixWith is present.
        public let replaceKeyWith: String?

        @inlinable
        public init(hostname: String? = nil, httpRedirectCode: String? = nil, protocol: String? = nil, replaceKeyPrefixWith: String? = nil, replaceKeyWith: String? = nil) {
            self.hostname = hostname
            self.httpRedirectCode = httpRedirectCode
            self.`protocol` = `protocol`
            self.replaceKeyPrefixWith = replaceKeyPrefixWith
            self.replaceKeyWith = replaceKeyWith
        }

        public func validate(name: String) throws {
            try self.validate(self.hostname, name: "hostname", parent: name, pattern: "\\S")
            try self.validate(self.httpRedirectCode, name: "httpRedirectCode", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.validate(self.replaceKeyPrefixWith, name: "replaceKeyPrefixWith", parent: name, pattern: "\\S")
            try self.validate(self.replaceKeyWith, name: "replaceKeyWith", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "Hostname"
            case httpRedirectCode = "HttpRedirectCode"
            case `protocol` = "Protocol"
            case replaceKeyPrefixWith = "ReplaceKeyPrefixWith"
            case replaceKeyWith = "ReplaceKeyWith"
        }
    }

    public struct AwsS3ObjectDetails: AWSEncodableShape & AWSDecodableShape {
        /// A standard MIME type describing the format of the object data.
        public let contentType: String?
        /// The opaque identifier assigned by a web server to a specific version of a resource found at a URL.
        public let eTag: String?
        /// Indicates when the object was last modified. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastModified: String?
        /// If the object is stored using server-side encryption, the value of the server-side encryption algorithm used when storing this object in Amazon S3.
        public let serverSideEncryption: String?
        /// The identifier of the KMS symmetric customer managed key that was used for the object.
        public let ssekmsKeyId: String?
        /// The version of the object.
        public let versionId: String?

        @inlinable
        public init(contentType: String? = nil, eTag: String? = nil, lastModified: String? = nil, serverSideEncryption: String? = nil, ssekmsKeyId: String? = nil, versionId: String? = nil) {
            self.contentType = contentType
            self.eTag = eTag
            self.lastModified = lastModified
            self.serverSideEncryption = serverSideEncryption
            self.ssekmsKeyId = ssekmsKeyId
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "\\S")
            try self.validate(self.eTag, name: "eTag", parent: name, pattern: "\\S")
            try self.validate(self.lastModified, name: "lastModified", parent: name, pattern: "\\S")
            try self.validate(self.serverSideEncryption, name: "serverSideEncryption", parent: name, pattern: "\\S")
            try self.validate(self.ssekmsKeyId, name: "ssekmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case eTag = "ETag"
            case lastModified = "LastModified"
            case serverSideEncryption = "ServerSideEncryption"
            case ssekmsKeyId = "SSEKMSKeyId"
            case versionId = "VersionId"
        }
    }

    public struct AwsSageMakerNotebookInstanceDetails: AWSEncodableShape & AWSDecodableShape {
        ///  A list of Amazon Elastic Inference instance types to associate with the notebook instance. Currently, only one instance type can be associated with a notebook instance.
        public let acceleratorTypes: [String]?
        ///  An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in CodeCommit or in any other Git repository.  These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see Associating Git repositories with SageMaker AI notebook instances in the Amazon SageMaker AI Developer Guide.
        public let additionalCodeRepositories: [String]?
        ///  The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in CodeCommit or in any other Git repository.  When you open a notebook instance, it opens in the directory that contains this repository. For more information, see Associating Git repositories with SageMaker AI notebook instances in the Amazon SageMaker AI Developer Guide.
        public let defaultCodeRepository: String?
        ///  Sets whether SageMaker AI provides internet access to the notebook instance. If you set this to Disabled, this notebook instance is able to access resources only in your VPC, and is not be able to connect to SageMaker AI training and endpoint services unless you configure a Network Address Translation (NAT) Gateway in your VPC.
        public let directInternetAccess: String?
        ///  If status of the instance is Failed, the reason it failed.
        public let failureReason: String?
        ///  Information on the IMDS configuration of the notebook instance.
        public let instanceMetadataServiceConfiguration: AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails?
        ///  The type of machine learning (ML) compute instance to launch for the notebook instance.
        public let instanceType: String?
        ///  The Amazon Resource Name (ARN) of an Key Management Service (KMS) key that SageMaker AI uses to encrypt data on the storage volume attached to your notebook instance. The KMS key you provide must be enabled. For information, see  Enabling and disabling keys in the Key Management Service Developer Guide.
        public let kmsKeyId: String?
        ///  The network interface ID that SageMaker AI created when the instance was created.
        public let networkInterfaceId: String?
        ///  The Amazon Resource Name (ARN) of the notebook instance.
        public let notebookInstanceArn: String?
        ///  The name of a notebook instance lifecycle configuration.
        public let notebookInstanceLifecycleConfigName: String?
        ///  The name of the new notebook instance.
        public let notebookInstanceName: String?
        ///  The status of the notebook instance.
        public let notebookInstanceStatus: String?
        ///  The platform identifier of the notebook instance runtime environment.
        public let platformIdentifier: String?
        ///  The Amazon Resource Name (ARN) of the IAM role associated with the instance.
        public let roleArn: String?
        ///  Whether root access is enabled or disabled for users of the notebook instance.
        public let rootAccess: String?
        ///  The VPC security group IDs.
        public let securityGroups: [String]?
        ///  The ID of the VPC subnet to which you have a connectivity from your ML compute instance.
        public let subnetId: String?
        ///  The URL that you use to connect to the Jupyter notebook that is running in your notebook instance.
        public let url: String?
        ///  The size, in GB, of the ML storage volume to attach to the notebook instance.
        public let volumeSizeInGB: Int?

        @inlinable
        public init(acceleratorTypes: [String]? = nil, additionalCodeRepositories: [String]? = nil, defaultCodeRepository: String? = nil, directInternetAccess: String? = nil, failureReason: String? = nil, instanceMetadataServiceConfiguration: AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails? = nil, instanceType: String? = nil, kmsKeyId: String? = nil, networkInterfaceId: String? = nil, notebookInstanceArn: String? = nil, notebookInstanceLifecycleConfigName: String? = nil, notebookInstanceName: String? = nil, notebookInstanceStatus: String? = nil, platformIdentifier: String? = nil, roleArn: String? = nil, rootAccess: String? = nil, securityGroups: [String]? = nil, subnetId: String? = nil, url: String? = nil, volumeSizeInGB: Int? = nil) {
            self.acceleratorTypes = acceleratorTypes
            self.additionalCodeRepositories = additionalCodeRepositories
            self.defaultCodeRepository = defaultCodeRepository
            self.directInternetAccess = directInternetAccess
            self.failureReason = failureReason
            self.instanceMetadataServiceConfiguration = instanceMetadataServiceConfiguration
            self.instanceType = instanceType
            self.kmsKeyId = kmsKeyId
            self.networkInterfaceId = networkInterfaceId
            self.notebookInstanceArn = notebookInstanceArn
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.notebookInstanceName = notebookInstanceName
            self.notebookInstanceStatus = notebookInstanceStatus
            self.platformIdentifier = platformIdentifier
            self.roleArn = roleArn
            self.rootAccess = rootAccess
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.url = url
            self.volumeSizeInGB = volumeSizeInGB
        }

        public func validate(name: String) throws {
            try self.acceleratorTypes?.forEach {
                try validate($0, name: "acceleratorTypes[]", parent: name, pattern: "\\S")
            }
            try self.additionalCodeRepositories?.forEach {
                try validate($0, name: "additionalCodeRepositories[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.defaultCodeRepository, name: "defaultCodeRepository", parent: name, pattern: "\\S")
            try self.validate(self.directInternetAccess, name: "directInternetAccess", parent: name, pattern: "\\S")
            try self.validate(self.failureReason, name: "failureReason", parent: name, pattern: "\\S")
            try self.instanceMetadataServiceConfiguration?.validate(name: "\(name).instanceMetadataServiceConfiguration")
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
            try self.validate(self.notebookInstanceArn, name: "notebookInstanceArn", parent: name, pattern: "\\S")
            try self.validate(self.notebookInstanceLifecycleConfigName, name: "notebookInstanceLifecycleConfigName", parent: name, pattern: "\\S")
            try self.validate(self.notebookInstanceName, name: "notebookInstanceName", parent: name, pattern: "\\S")
            try self.validate(self.notebookInstanceStatus, name: "notebookInstanceStatus", parent: name, pattern: "\\S")
            try self.validate(self.platformIdentifier, name: "platformIdentifier", parent: name, pattern: "\\S")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.rootAccess, name: "rootAccess", parent: name, pattern: "\\S")
            try self.securityGroups?.forEach {
                try validate($0, name: "securityGroups[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "\\S")
            try self.validate(self.url, name: "url", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorTypes = "AcceleratorTypes"
            case additionalCodeRepositories = "AdditionalCodeRepositories"
            case defaultCodeRepository = "DefaultCodeRepository"
            case directInternetAccess = "DirectInternetAccess"
            case failureReason = "FailureReason"
            case instanceMetadataServiceConfiguration = "InstanceMetadataServiceConfiguration"
            case instanceType = "InstanceType"
            case kmsKeyId = "KmsKeyId"
            case networkInterfaceId = "NetworkInterfaceId"
            case notebookInstanceArn = "NotebookInstanceArn"
            case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
            case notebookInstanceName = "NotebookInstanceName"
            case notebookInstanceStatus = "NotebookInstanceStatus"
            case platformIdentifier = "PlatformIdentifier"
            case roleArn = "RoleArn"
            case rootAccess = "RootAccess"
            case securityGroups = "SecurityGroups"
            case subnetId = "SubnetId"
            case url = "Url"
            case volumeSizeInGB = "VolumeSizeInGB"
        }
    }

    public struct AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates the minimum IMDS version that the notebook instance supports.
        public let minimumInstanceMetadataServiceVersion: String?

        @inlinable
        public init(minimumInstanceMetadataServiceVersion: String? = nil) {
            self.minimumInstanceMetadataServiceVersion = minimumInstanceMetadataServiceVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.minimumInstanceMetadataServiceVersion, name: "minimumInstanceMetadataServiceVersion", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case minimumInstanceMetadataServiceVersion = "MinimumInstanceMetadataServiceVersion"
        }
    }

    public struct AwsSecretsManagerSecretDetails: AWSEncodableShape & AWSDecodableShape {
        /// Whether the secret is deleted.
        public let deleted: Bool?
        /// The user-provided description of the secret.
        public let description: String?
        /// The ARN, Key ID, or alias of the KMS key used to encrypt the SecretString or SecretBinary values for versions of this secret.
        public let kmsKeyId: String?
        /// The name of the secret.
        public let name: String?
        /// Whether rotation is enabled.
        public let rotationEnabled: Bool?
        /// The ARN of the Lambda function that rotates the secret.
        public let rotationLambdaArn: String?
        /// Whether the rotation occurred within the specified rotation frequency.
        public let rotationOccurredWithinFrequency: Bool?
        /// Defines the rotation schedule for the secret.
        public let rotationRules: AwsSecretsManagerSecretRotationRules?

        @inlinable
        public init(deleted: Bool? = nil, description: String? = nil, kmsKeyId: String? = nil, name: String? = nil, rotationEnabled: Bool? = nil, rotationLambdaArn: String? = nil, rotationOccurredWithinFrequency: Bool? = nil, rotationRules: AwsSecretsManagerSecretRotationRules? = nil) {
            self.deleted = deleted
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.rotationEnabled = rotationEnabled
            self.rotationLambdaArn = rotationLambdaArn
            self.rotationOccurredWithinFrequency = rotationOccurredWithinFrequency
            self.rotationRules = rotationRules
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.rotationLambdaArn, name: "rotationLambdaArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deleted = "Deleted"
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case rotationEnabled = "RotationEnabled"
            case rotationLambdaArn = "RotationLambdaArn"
            case rotationOccurredWithinFrequency = "RotationOccurredWithinFrequency"
            case rotationRules = "RotationRules"
        }
    }

    public struct AwsSecretsManagerSecretRotationRules: AWSEncodableShape & AWSDecodableShape {
        /// The number of days after the previous rotation to rotate the secret.
        public let automaticallyAfterDays: Int?

        @inlinable
        public init(automaticallyAfterDays: Int? = nil) {
            self.automaticallyAfterDays = automaticallyAfterDays
        }

        private enum CodingKeys: String, CodingKey {
            case automaticallyAfterDays = "AutomaticallyAfterDays"
        }
    }

    public struct AwsSecurityFinding: AWSEncodableShape & AWSDecodableShape {
        /// Provides details about an action that affects or that was taken on a resource.
        public let action: Action?
        /// The Amazon Web Services account ID that a finding is generated in. Length Constraints: 12.
        public let awsAccountId: String?
        /// The name of the Amazon Web Services account from which a finding was generated.  Length Constraints: Minimum length of 1. Maximum length of 50.
        public let awsAccountName: String?
        /// The name of the company for the product that generated the finding. Security Hub populates this attribute automatically for each finding. You cannot update this attribute with BatchImportFindings or BatchUpdateFindings. The exception to this is a custom integration. When you use the Security Hub console or API to filter findings by company name, you use this attribute. Length Constraints: Minimum length of 1. Maximum length of 128.
        public let companyName: String?
        /// This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported security standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.
        public let compliance: Compliance?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: Int?
        /// Indicates when the security findings provider created the potential security issue that a finding captured. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdAt: String?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: Int?
        /// A finding's description. Description is a required property. Length Constraints: Minimum length of 1. Maximum length of 1024.
        public let description: String?
        ///  Provides details about an Amazon GuardDuty Extended Threat Detection attack sequence. GuardDuty generates an attack  sequence finding when multiple events align to a potentially suspicious activity. To receive GuardDuty attack sequence findings in Security Hub, you
        /// 				must have GuardDuty enabled. For more information, see GuardDuty Extended Threat Detection  in the Amazon GuardDuty User Guide.
        public let detection: Detection?
        /// In a BatchImportFindings request, finding providers use FindingProviderFields to provide and update their own values for confidence, criticality, related findings, severity, and types.
        public let findingProviderFields: FindingProviderFields?
        /// Indicates when the security findings provider first observed the potential security issue that a finding captured. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let firstObservedAt: String?
        /// Provides metadata for the Amazon CodeGuru detector associated with a finding. This field pertains to
        /// findings that relate to Lambda functions. Amazon Inspector identifies policy violations and
        /// vulnerabilities in Lambda function code based on internal detectors developed
        /// in collaboration with Amazon CodeGuru. Security Hub receives those findings.
        public let generatorDetails: GeneratorDetails?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, or something else. Length Constraints: Minimum length of 1. Maximum length of 512.
        public let generatorId: String?
        /// The security findings provider-specific identifier for a finding. Length Constraints: Minimum length of 1. Maximum length of 512.
        public let id: String?
        /// Indicates when the security findings provider most recently observed a change in the resource that is involved in the finding. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastObservedAt: String?
        /// A list of malware related to a finding. Array Members: Maximum number of 5 items.
        public let malware: [Malware]?
        /// The details of network-related information about a finding.
        public let network: Network?
        /// Provides information about a network path that is relevant to a finding. Each entry under NetworkPath represents a component of that path.
        public let networkPath: [NetworkPathComponent]?
        /// A user-defined note added to a finding.
        public let note: Note?
        /// Provides an overview of the patch compliance status for an instance against a selected compliance standard.
        public let patchSummary: PatchSummary?
        /// The details of process-related information about a finding.
        public let process: ProcessDetails?
        /// A timestamp that indicates when Security Hub received a finding and begins to process it. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let processedAt: String?
        /// The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration. Length Constraints: Minimum length of 12. Maximum length of 2048.
        public let productArn: String?
        /// A data type where security findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. Can contain up to 50 key-value pairs. For each key-value pair, the key can contain up to 128 characters, and the value can contain up to 2048 characters.
        public let productFields: [String: String]?
        /// The name of the product that generated the finding. Security Hub populates this attribute automatically for each finding. You cannot update this attribute with BatchImportFindings or BatchUpdateFindings. The exception to this is a custom integration. When you use the Security Hub console or API to filter findings by product name, you use this attribute. Length Constraints: Minimum length of 1. Maximum length of 128.
        public let productName: String?
        /// The record state of a finding.
        public let recordState: RecordState?
        /// The Region from which the finding was generated. Security Hub populates this attribute automatically for each finding. You cannot update it using BatchImportFindings or BatchUpdateFindings. Length Constraints: Minimum length of 1. Maximum length of 16.
        public let region: String?
        /// A list of related findings. Array Members: Minimum number of 1 item. Maximum number of 10 items.
        public let relatedFindings: [RelatedFinding]?
        /// A data type that describes the remediation options for a finding.
        public let remediation: Remediation?
        /// A set of resource data types that describe the resources that the finding refers to. Array Members: Minimum number of 1 item. Maximum number of 32 items.
        public let resources: [Resource]?
        /// Indicates whether the finding is a sample finding.
        public let sample: Bool?
        /// The schema version that a finding is formatted for. The value is 2018-10-08.
        public let schemaVersion: String?
        /// A finding's severity.
        public let severity: Severity?
        /// A URL that links to a page about the current finding in the security findings provider's solution.
        public let sourceUrl: String?
        /// Threat intelligence details related to a finding. Array Members: Minimum number of 1 item. Maximum number of 5 items.
        public let threatIntelIndicators: [ThreatIntelIndicator]?
        /// Details about the threat detected in a security finding and the file paths that were affected by the threat.  Array Members: Minimum number of 1 item. Maximum number of 32 items.
        public let threats: [Threat]?
        /// A finding's title. Title is a required property. Length Constraints: Minimum length of 1. Maximum length of 256.
        public let title: String?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications Array Members: Maximum number of 50 items.
        public let types: [String]?
        /// Indicates when the security findings provider last updated the finding record. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let updatedAt: String?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. Can contain up to 50 key-value pairs. For each key-value pair, the key can contain up to 128 characters, and the value can contain up to 1024 characters.
        public let userDefinedFields: [String: String]?
        /// Indicates the veracity of a finding.
        public let verificationState: VerificationState?
        /// Provides a list of vulnerabilities associated with the findings.
        public let vulnerabilities: [Vulnerability]?
        /// Provides information about the status of the investigation into a finding.
        public let workflow: Workflow?
        /// The workflow state of a finding.
        public let workflowState: WorkflowState?

        @inlinable
        public init(action: Action? = nil, awsAccountId: String? = nil, awsAccountName: String? = nil, companyName: String? = nil, compliance: Compliance? = nil, confidence: Int? = nil, createdAt: String? = nil, criticality: Int? = nil, description: String? = nil, detection: Detection? = nil, findingProviderFields: FindingProviderFields? = nil, firstObservedAt: String? = nil, generatorDetails: GeneratorDetails? = nil, generatorId: String? = nil, id: String? = nil, lastObservedAt: String? = nil, malware: [Malware]? = nil, network: Network? = nil, networkPath: [NetworkPathComponent]? = nil, note: Note? = nil, patchSummary: PatchSummary? = nil, process: ProcessDetails? = nil, processedAt: String? = nil, productArn: String? = nil, productFields: [String: String]? = nil, productName: String? = nil, recordState: RecordState? = nil, region: String? = nil, relatedFindings: [RelatedFinding]? = nil, remediation: Remediation? = nil, resources: [Resource]? = nil, sample: Bool? = nil, schemaVersion: String? = nil, severity: Severity? = nil, sourceUrl: String? = nil, threatIntelIndicators: [ThreatIntelIndicator]? = nil, threats: [Threat]? = nil, title: String? = nil, types: [String]? = nil, updatedAt: String? = nil, userDefinedFields: [String: String]? = nil, verificationState: VerificationState? = nil, vulnerabilities: [Vulnerability]? = nil, workflow: Workflow? = nil, workflowState: WorkflowState? = nil) {
            self.action = action
            self.awsAccountId = awsAccountId
            self.awsAccountName = awsAccountName
            self.companyName = companyName
            self.compliance = compliance
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.detection = detection
            self.findingProviderFields = findingProviderFields
            self.firstObservedAt = firstObservedAt
            self.generatorDetails = generatorDetails
            self.generatorId = generatorId
            self.id = id
            self.lastObservedAt = lastObservedAt
            self.malware = malware
            self.network = network
            self.networkPath = networkPath
            self.note = note
            self.patchSummary = patchSummary
            self.process = process
            self.processedAt = processedAt
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recordState = recordState
            self.region = region
            self.relatedFindings = relatedFindings
            self.remediation = remediation
            self.resources = resources
            self.sample = sample
            self.schemaVersion = schemaVersion
            self.severity = severity
            self.sourceUrl = sourceUrl
            self.threatIntelIndicators = threatIntelIndicators
            self.threats = threats
            self.title = title
            self.types = types
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.vulnerabilities = vulnerabilities
            self.workflow = workflow
            self.workflowState = workflowState
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "\\S")
            try self.validate(self.awsAccountName, name: "awsAccountName", parent: name, pattern: "\\S")
            try self.validate(self.companyName, name: "companyName", parent: name, pattern: "\\S")
            try self.compliance?.validate(name: "\(name).compliance")
            try self.validate(self.createdAt, name: "createdAt", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.detection?.validate(name: "\(name).detection")
            try self.findingProviderFields?.validate(name: "\(name).findingProviderFields")
            try self.validate(self.firstObservedAt, name: "firstObservedAt", parent: name, pattern: "\\S")
            try self.generatorDetails?.validate(name: "\(name).generatorDetails")
            try self.validate(self.generatorId, name: "generatorId", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.lastObservedAt, name: "lastObservedAt", parent: name, pattern: "\\S")
            try self.malware?.forEach {
                try $0.validate(name: "\(name).malware[]")
            }
            try self.network?.validate(name: "\(name).network")
            try self.networkPath?.forEach {
                try $0.validate(name: "\(name).networkPath[]")
            }
            try self.note?.validate(name: "\(name).note")
            try self.patchSummary?.validate(name: "\(name).patchSummary")
            try self.process?.validate(name: "\(name).process")
            try self.validate(self.processedAt, name: "processedAt", parent: name, pattern: "\\S")
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
            try self.productFields?.forEach {
                try validate($0.key, name: "productFields.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "productFields[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.productName, name: "productName", parent: name, pattern: "\\S")
            try self.validate(self.region, name: "region", parent: name, pattern: "\\S")
            try self.relatedFindings?.forEach {
                try $0.validate(name: "\(name).relatedFindings[]")
            }
            try self.remediation?.validate(name: "\(name).remediation")
            try self.resources?.forEach {
                try $0.validate(name: "\(name).resources[]")
            }
            try self.validate(self.schemaVersion, name: "schemaVersion", parent: name, pattern: "\\S")
            try self.severity?.validate(name: "\(name).severity")
            try self.validate(self.sourceUrl, name: "sourceUrl", parent: name, pattern: "\\S")
            try self.threatIntelIndicators?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicators[]")
            }
            try self.threats?.forEach {
                try $0.validate(name: "\(name).threats[]")
            }
            try self.validate(self.title, name: "title", parent: name, pattern: "\\S")
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.updatedAt, name: "updatedAt", parent: name, pattern: "\\S")
            try self.userDefinedFields?.forEach {
                try validate($0.key, name: "userDefinedFields.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "userDefinedFields[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.vulnerabilities?.forEach {
                try $0.validate(name: "\(name).vulnerabilities[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case awsAccountId = "AwsAccountId"
            case awsAccountName = "AwsAccountName"
            case companyName = "CompanyName"
            case compliance = "Compliance"
            case confidence = "Confidence"
            case createdAt = "CreatedAt"
            case criticality = "Criticality"
            case description = "Description"
            case detection = "Detection"
            case findingProviderFields = "FindingProviderFields"
            case firstObservedAt = "FirstObservedAt"
            case generatorDetails = "GeneratorDetails"
            case generatorId = "GeneratorId"
            case id = "Id"
            case lastObservedAt = "LastObservedAt"
            case malware = "Malware"
            case network = "Network"
            case networkPath = "NetworkPath"
            case note = "Note"
            case patchSummary = "PatchSummary"
            case process = "Process"
            case processedAt = "ProcessedAt"
            case productArn = "ProductArn"
            case productFields = "ProductFields"
            case productName = "ProductName"
            case recordState = "RecordState"
            case region = "Region"
            case relatedFindings = "RelatedFindings"
            case remediation = "Remediation"
            case resources = "Resources"
            case sample = "Sample"
            case schemaVersion = "SchemaVersion"
            case severity = "Severity"
            case sourceUrl = "SourceUrl"
            case threatIntelIndicators = "ThreatIntelIndicators"
            case threats = "Threats"
            case title = "Title"
            case types = "Types"
            case updatedAt = "UpdatedAt"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case vulnerabilities = "Vulnerabilities"
            case workflow = "Workflow"
            case workflowState = "WorkflowState"
        }
    }

    public struct AwsSecurityFindingFilters: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services account ID in which a finding is generated.
        public let awsAccountId: [StringFilter]?
        /// The name of the Amazon Web Services account in which a finding is generated.
        public let awsAccountName: [StringFilter]?
        /// The name of the findings provider (company) that owns the solution (product) that generates findings.
        public let companyName: [StringFilter]?
        ///  The unique identifier of a standard in which a control is enabled. This field consists of the resource portion of the  Amazon Resource Name (ARN) returned for a standard in the DescribeStandards API response.
        public let complianceAssociatedStandardsId: [StringFilter]?
        ///  The unique identifier of a control across standards. Values for this field typically consist of an  Amazon Web Services service and a number, such as APIGateway.5.
        public let complianceSecurityControlId: [StringFilter]?
        ///  The name of a security control parameter.
        public let complianceSecurityControlParametersName: [StringFilter]?
        ///  The current value of a security control parameter.
        public let complianceSecurityControlParametersValue: [StringFilter]?
        /// Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.
        public let complianceStatus: [StringFilter]?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: [NumberFilter]?
        /// A timestamp that indicates when the security findings provider created the potential security issue that a finding reflects. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let createdAt: [DateFilter]?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: [NumberFilter]?
        /// A finding's description.
        public let description: [StringFilter]?
        /// The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let findingProviderFieldsConfidence: [NumberFilter]?
        /// The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let findingProviderFieldsCriticality: [NumberFilter]?
        /// The finding identifier of a related finding that is identified by the finding provider.
        public let findingProviderFieldsRelatedFindingsId: [StringFilter]?
        /// The ARN of the solution that generated a related finding that is identified by the finding provider.
        public let findingProviderFieldsRelatedFindingsProductArn: [StringFilter]?
        /// The finding provider value for the severity label.
        public let findingProviderFieldsSeverityLabel: [StringFilter]?
        /// The finding provider's original value for the severity.
        public let findingProviderFieldsSeverityOriginal: [StringFilter]?
        /// One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public let findingProviderFieldsTypes: [StringFilter]?
        /// A timestamp that indicates when the security findings provider first observed the potential security issue that a finding captured. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let firstObservedAt: [DateFilter]?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc.
        public let generatorId: [StringFilter]?
        /// The security findings provider-specific identifier for a finding.
        public let id: [StringFilter]?
        /// A keyword for a finding.
        public let keyword: [KeywordFilter]?
        /// A timestamp that indicates when the security findings provider most recently observed a change in the resource that is involved in the finding. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastObservedAt: [DateFilter]?
        /// The name of the malware that was observed.
        public let malwareName: [StringFilter]?
        /// The filesystem path of the malware that was observed.
        public let malwarePath: [StringFilter]?
        /// The state of the malware that was observed.
        public let malwareState: [StringFilter]?
        /// The type of the malware that was observed.
        public let malwareType: [StringFilter]?
        /// The destination domain of network-related information about a finding.
        public let networkDestinationDomain: [StringFilter]?
        /// The destination IPv4 address of network-related information about a finding.
        public let networkDestinationIpV4: [IpFilter]?
        /// The destination IPv6 address of network-related information about a finding.
        public let networkDestinationIpV6: [IpFilter]?
        /// The destination port of network-related information about a finding.
        public let networkDestinationPort: [NumberFilter]?
        /// Indicates the direction of network traffic associated with a finding.
        public let networkDirection: [StringFilter]?
        /// The protocol of network-related information about a finding.
        public let networkProtocol: [StringFilter]?
        /// The source domain of network-related information about a finding.
        public let networkSourceDomain: [StringFilter]?
        /// The source IPv4 address of network-related information about a finding.
        public let networkSourceIpV4: [IpFilter]?
        /// The source IPv6 address of network-related information about a finding.
        public let networkSourceIpV6: [IpFilter]?
        /// The source media access control (MAC) address of network-related information about a finding.
        public let networkSourceMac: [StringFilter]?
        /// The source port of network-related information about a finding.
        public let networkSourcePort: [NumberFilter]?
        /// The text of a note.
        public let noteText: [StringFilter]?
        /// The timestamp of when the note was updated.
        public let noteUpdatedAt: [DateFilter]?
        /// The principal that created a note.
        public let noteUpdatedBy: [StringFilter]?
        /// A timestamp that identifies when the process was launched. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let processLaunchedAt: [DateFilter]?
        /// The name of the process.
        public let processName: [StringFilter]?
        /// The parent process ID. This field accepts positive integers between O and 2147483647.
        public let processParentPid: [NumberFilter]?
        /// The path to the process executable.
        public let processPath: [StringFilter]?
        /// The process ID.
        public let processPid: [NumberFilter]?
        /// A timestamp that identifies when the process was terminated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let processTerminatedAt: [DateFilter]?
        /// The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub.
        public let productArn: [StringFilter]?
        /// A data type where security findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format.
        public let productFields: [MapFilter]?
        /// The name of the solution (product) that generates findings.
        public let productName: [StringFilter]?
        /// The recommendation of what to do about the issue described in a finding.
        public let recommendationText: [StringFilter]?
        /// The updated record state for the finding.
        public let recordState: [StringFilter]?
        /// The Region from which the finding was generated.
        public let region: [StringFilter]?
        /// The solution-generated identifier for a related finding.
        public let relatedFindingsId: [StringFilter]?
        /// The ARN of the solution that generated a related finding.
        public let relatedFindingsProductArn: [StringFilter]?
        ///  The ARN of the application that is related to a finding.
        public let resourceApplicationArn: [StringFilter]?
        ///  The name of the application that is related to a finding.
        public let resourceApplicationName: [StringFilter]?
        /// The IAM profile ARN of the instance.
        public let resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public let resourceAwsEc2InstanceImageId: [StringFilter]?
        /// The IPv4 addresses associated with the instance.
        public let resourceAwsEc2InstanceIpV4Addresses: [IpFilter]?
        /// The IPv6 addresses associated with the instance.
        public let resourceAwsEc2InstanceIpV6Addresses: [IpFilter]?
        /// The key name associated with the instance.
        public let resourceAwsEc2InstanceKeyName: [StringFilter]?
        /// The date and time the instance was launched.
        public let resourceAwsEc2InstanceLaunchedAt: [DateFilter]?
        /// The identifier of the subnet that the instance was launched in.
        public let resourceAwsEc2InstanceSubnetId: [StringFilter]?
        /// The instance type of the instance.
        public let resourceAwsEc2InstanceType: [StringFilter]?
        /// The identifier of the VPC that the instance was launched in.
        public let resourceAwsEc2InstanceVpcId: [StringFilter]?
        /// The creation date/time of the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyCreatedAt: [DateFilter]?
        /// The name of the principal that is associated with an IAM access key.
        public let resourceAwsIamAccessKeyPrincipalName: [StringFilter]?
        /// The status of the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyStatus: [StringFilter]?
        /// The user associated with the IAM access key related to a finding.
        public let resourceAwsIamAccessKeyUserName: [StringFilter]?
        /// The name of an IAM user.
        public let resourceAwsIamUserUserName: [StringFilter]?
        /// The canonical user ID of the owner of the S3 bucket.
        public let resourceAwsS3BucketOwnerId: [StringFilter]?
        /// The display name of the owner of the S3 bucket.
        public let resourceAwsS3BucketOwnerName: [StringFilter]?
        /// The identifier of the image related to a finding.
        public let resourceContainerImageId: [StringFilter]?
        /// The name of the image related to a finding.
        public let resourceContainerImageName: [StringFilter]?
        /// A timestamp that identifies when the container was started. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let resourceContainerLaunchedAt: [DateFilter]?
        /// The name of the container related to a finding.
        public let resourceContainerName: [StringFilter]?
        /// The details of a resource that doesn't have a specific subfield for the resource type defined.
        public let resourceDetailsOther: [MapFilter]?
        /// The canonical identifier for the given resource type.
        public let resourceId: [StringFilter]?
        /// The canonical Amazon Web Services partition name that the Region is assigned to.
        public let resourcePartition: [StringFilter]?
        /// The canonical Amazon Web Services external Region name where this resource is located.
        public let resourceRegion: [StringFilter]?
        /// A list of Amazon Web Services tags associated with a resource at the time the finding was processed.
        public let resourceTags: [MapFilter]?
        /// Specifies the type of the resource that details are provided for.
        public let resourceType: [StringFilter]?
        /// Indicates whether or not sample findings are included in the filter results.
        public let sample: [BooleanFilter]?
        /// The label of a finding's severity.
        public let severityLabel: [StringFilter]?
        /// The normalized severity of a finding.
        public let severityNormalized: [NumberFilter]?
        /// The native severity as defined by the security findings provider's solution that generated the finding.
        public let severityProduct: [NumberFilter]?
        /// A URL that links to a page about the current finding in the security findings provider's solution.
        public let sourceUrl: [StringFilter]?
        /// The category of a threat intelligence indicator.
        public let threatIntelIndicatorCategory: [StringFilter]?
        /// A timestamp that identifies the last observation of a threat intelligence indicator. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let threatIntelIndicatorLastObservedAt: [DateFilter]?
        /// The source of the threat intelligence.
        public let threatIntelIndicatorSource: [StringFilter]?
        /// The URL for more details from the source of the threat intelligence.
        public let threatIntelIndicatorSourceUrl: [StringFilter]?
        /// The type of a threat intelligence indicator.
        public let threatIntelIndicatorType: [StringFilter]?
        /// The value of a threat intelligence indicator.
        public let threatIntelIndicatorValue: [StringFilter]?
        /// A finding's title.
        public let title: [StringFilter]?
        /// A finding type in the format of namespace/category/classifier that classifies a finding.
        public let type: [StringFilter]?
        /// A timestamp that indicates when the security findings provider last updated the finding record. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let updatedAt: [DateFilter]?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
        public let userDefinedFields: [MapFilter]?
        /// The veracity of a finding.
        public let verificationState: [StringFilter]?
        ///  Indicates whether a software vulnerability in your environment has a known exploit. You can filter findings by this  field only if you use Security Hub and Amazon Inspector.
        public let vulnerabilitiesExploitAvailable: [StringFilter]?
        ///  Indicates whether a vulnerability is fixed in a newer version of the affected software packages. You can filter  findings by this field only if you use Security Hub and Amazon Inspector.
        public let vulnerabilitiesFixAvailable: [StringFilter]?
        /// The workflow state of a finding. Note that this field is deprecated. To search for a finding based on its workflow status, use WorkflowStatus.
        public let workflowState: [StringFilter]?
        /// The status of the investigation into a finding. Allowed values are the following.    NEW - The initial state of a finding, before it is reviewed. Security Hub also resets the workflow status from NOTIFIED or RESOLVED to NEW in the following cases:    RecordState changes from ARCHIVED to ACTIVE.    Compliance.Status changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.      NOTIFIED - Indicates that the resource owner has been notified about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner. If one of the following occurs, the workflow status is changed automatically from NOTIFIED to NEW:    RecordState changes from ARCHIVED to ACTIVE.    Compliance.Status changes from PASSED to FAILED, WARNING, or NOT_AVAILABLE.      SUPPRESSED - Indicates that you reviewed the finding and don't believe that any action is needed. The workflow status of a SUPPRESSED finding does not change if RecordState changes from ARCHIVED to ACTIVE.    RESOLVED - The finding was reviewed and remediated and is now considered resolved.  The finding remains RESOLVED unless one of the following occurs:    RecordState changes from ARCHIVED to ACTIVE.    Compliance.Status changes from PASSED to FAILED, WARNING, or NOT_AVAILABLE.   In those cases, the workflow status is automatically reset to NEW. For findings from controls, if Compliance.Status is PASSED, then Security Hub automatically sets the workflow status to RESOLVED.
        public let workflowStatus: [StringFilter]?

        @inlinable
        public init(awsAccountId: [StringFilter]? = nil, awsAccountName: [StringFilter]? = nil, companyName: [StringFilter]? = nil, complianceAssociatedStandardsId: [StringFilter]? = nil, complianceSecurityControlId: [StringFilter]? = nil, complianceSecurityControlParametersName: [StringFilter]? = nil, complianceSecurityControlParametersValue: [StringFilter]? = nil, complianceStatus: [StringFilter]? = nil, confidence: [NumberFilter]? = nil, createdAt: [DateFilter]? = nil, criticality: [NumberFilter]? = nil, description: [StringFilter]? = nil, findingProviderFieldsConfidence: [NumberFilter]? = nil, findingProviderFieldsCriticality: [NumberFilter]? = nil, findingProviderFieldsRelatedFindingsId: [StringFilter]? = nil, findingProviderFieldsRelatedFindingsProductArn: [StringFilter]? = nil, findingProviderFieldsSeverityLabel: [StringFilter]? = nil, findingProviderFieldsSeverityOriginal: [StringFilter]? = nil, findingProviderFieldsTypes: [StringFilter]? = nil, firstObservedAt: [DateFilter]? = nil, generatorId: [StringFilter]? = nil, id: [StringFilter]? = nil, lastObservedAt: [DateFilter]? = nil, malwareName: [StringFilter]? = nil, malwarePath: [StringFilter]? = nil, malwareState: [StringFilter]? = nil, malwareType: [StringFilter]? = nil, networkDestinationDomain: [StringFilter]? = nil, networkDestinationIpV4: [IpFilter]? = nil, networkDestinationIpV6: [IpFilter]? = nil, networkDestinationPort: [NumberFilter]? = nil, networkDirection: [StringFilter]? = nil, networkProtocol: [StringFilter]? = nil, networkSourceDomain: [StringFilter]? = nil, networkSourceIpV4: [IpFilter]? = nil, networkSourceIpV6: [IpFilter]? = nil, networkSourceMac: [StringFilter]? = nil, networkSourcePort: [NumberFilter]? = nil, noteText: [StringFilter]? = nil, noteUpdatedAt: [DateFilter]? = nil, noteUpdatedBy: [StringFilter]? = nil, processLaunchedAt: [DateFilter]? = nil, processName: [StringFilter]? = nil, processParentPid: [NumberFilter]? = nil, processPath: [StringFilter]? = nil, processPid: [NumberFilter]? = nil, processTerminatedAt: [DateFilter]? = nil, productArn: [StringFilter]? = nil, productFields: [MapFilter]? = nil, productName: [StringFilter]? = nil, recommendationText: [StringFilter]? = nil, recordState: [StringFilter]? = nil, region: [StringFilter]? = nil, relatedFindingsId: [StringFilter]? = nil, relatedFindingsProductArn: [StringFilter]? = nil, resourceApplicationArn: [StringFilter]? = nil, resourceApplicationName: [StringFilter]? = nil, resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]? = nil, resourceAwsEc2InstanceImageId: [StringFilter]? = nil, resourceAwsEc2InstanceIpV4Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceIpV6Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceKeyName: [StringFilter]? = nil, resourceAwsEc2InstanceLaunchedAt: [DateFilter]? = nil, resourceAwsEc2InstanceSubnetId: [StringFilter]? = nil, resourceAwsEc2InstanceType: [StringFilter]? = nil, resourceAwsEc2InstanceVpcId: [StringFilter]? = nil, resourceAwsIamAccessKeyCreatedAt: [DateFilter]? = nil, resourceAwsIamAccessKeyPrincipalName: [StringFilter]? = nil, resourceAwsIamAccessKeyStatus: [StringFilter]? = nil, resourceAwsIamUserUserName: [StringFilter]? = nil, resourceAwsS3BucketOwnerId: [StringFilter]? = nil, resourceAwsS3BucketOwnerName: [StringFilter]? = nil, resourceContainerImageId: [StringFilter]? = nil, resourceContainerImageName: [StringFilter]? = nil, resourceContainerLaunchedAt: [DateFilter]? = nil, resourceContainerName: [StringFilter]? = nil, resourceDetailsOther: [MapFilter]? = nil, resourceId: [StringFilter]? = nil, resourcePartition: [StringFilter]? = nil, resourceRegion: [StringFilter]? = nil, resourceTags: [MapFilter]? = nil, resourceType: [StringFilter]? = nil, sample: [BooleanFilter]? = nil, severityLabel: [StringFilter]? = nil, sourceUrl: [StringFilter]? = nil, threatIntelIndicatorCategory: [StringFilter]? = nil, threatIntelIndicatorLastObservedAt: [DateFilter]? = nil, threatIntelIndicatorSource: [StringFilter]? = nil, threatIntelIndicatorSourceUrl: [StringFilter]? = nil, threatIntelIndicatorType: [StringFilter]? = nil, threatIntelIndicatorValue: [StringFilter]? = nil, title: [StringFilter]? = nil, type: [StringFilter]? = nil, updatedAt: [DateFilter]? = nil, userDefinedFields: [MapFilter]? = nil, verificationState: [StringFilter]? = nil, vulnerabilitiesExploitAvailable: [StringFilter]? = nil, vulnerabilitiesFixAvailable: [StringFilter]? = nil, workflowState: [StringFilter]? = nil, workflowStatus: [StringFilter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountName = awsAccountName
            self.companyName = companyName
            self.complianceAssociatedStandardsId = complianceAssociatedStandardsId
            self.complianceSecurityControlId = complianceSecurityControlId
            self.complianceSecurityControlParametersName = complianceSecurityControlParametersName
            self.complianceSecurityControlParametersValue = complianceSecurityControlParametersValue
            self.complianceStatus = complianceStatus
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.findingProviderFieldsConfidence = findingProviderFieldsConfidence
            self.findingProviderFieldsCriticality = findingProviderFieldsCriticality
            self.findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsId
            self.findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArn
            self.findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabel
            self.findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginal
            self.findingProviderFieldsTypes = findingProviderFieldsTypes
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.keyword = nil
            self.lastObservedAt = lastObservedAt
            self.malwareName = malwareName
            self.malwarePath = malwarePath
            self.malwareState = malwareState
            self.malwareType = malwareType
            self.networkDestinationDomain = networkDestinationDomain
            self.networkDestinationIpV4 = networkDestinationIpV4
            self.networkDestinationIpV6 = networkDestinationIpV6
            self.networkDestinationPort = networkDestinationPort
            self.networkDirection = networkDirection
            self.networkProtocol = networkProtocol
            self.networkSourceDomain = networkSourceDomain
            self.networkSourceIpV4 = networkSourceIpV4
            self.networkSourceIpV6 = networkSourceIpV6
            self.networkSourceMac = networkSourceMac
            self.networkSourcePort = networkSourcePort
            self.noteText = noteText
            self.noteUpdatedAt = noteUpdatedAt
            self.noteUpdatedBy = noteUpdatedBy
            self.processLaunchedAt = processLaunchedAt
            self.processName = processName
            self.processParentPid = processParentPid
            self.processPath = processPath
            self.processPid = processPid
            self.processTerminatedAt = processTerminatedAt
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recommendationText = recommendationText
            self.recordState = recordState
            self.region = region
            self.relatedFindingsId = relatedFindingsId
            self.relatedFindingsProductArn = relatedFindingsProductArn
            self.resourceApplicationArn = resourceApplicationArn
            self.resourceApplicationName = resourceApplicationName
            self.resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn
            self.resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId
            self.resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses
            self.resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses
            self.resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName
            self.resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt
            self.resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId
            self.resourceAwsEc2InstanceType = resourceAwsEc2InstanceType
            self.resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId
            self.resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt
            self.resourceAwsIamAccessKeyPrincipalName = resourceAwsIamAccessKeyPrincipalName
            self.resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus
            self.resourceAwsIamAccessKeyUserName = nil
            self.resourceAwsIamUserUserName = resourceAwsIamUserUserName
            self.resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId
            self.resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName
            self.resourceContainerImageId = resourceContainerImageId
            self.resourceContainerImageName = resourceContainerImageName
            self.resourceContainerLaunchedAt = resourceContainerLaunchedAt
            self.resourceContainerName = resourceContainerName
            self.resourceDetailsOther = resourceDetailsOther
            self.resourceId = resourceId
            self.resourcePartition = resourcePartition
            self.resourceRegion = resourceRegion
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.sample = sample
            self.severityLabel = severityLabel
            self.severityNormalized = nil
            self.severityProduct = nil
            self.sourceUrl = sourceUrl
            self.threatIntelIndicatorCategory = threatIntelIndicatorCategory
            self.threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt
            self.threatIntelIndicatorSource = threatIntelIndicatorSource
            self.threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl
            self.threatIntelIndicatorType = threatIntelIndicatorType
            self.threatIntelIndicatorValue = threatIntelIndicatorValue
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.vulnerabilitiesExploitAvailable = vulnerabilitiesExploitAvailable
            self.vulnerabilitiesFixAvailable = vulnerabilitiesFixAvailable
            self.workflowState = workflowState
            self.workflowStatus = workflowStatus
        }

        @available(*, deprecated, message: "Members keyword, resourceAwsIamAccessKeyUserName, severityNormalized, severityProduct have been deprecated")
        @inlinable
        public init(awsAccountId: [StringFilter]? = nil, awsAccountName: [StringFilter]? = nil, companyName: [StringFilter]? = nil, complianceAssociatedStandardsId: [StringFilter]? = nil, complianceSecurityControlId: [StringFilter]? = nil, complianceSecurityControlParametersName: [StringFilter]? = nil, complianceSecurityControlParametersValue: [StringFilter]? = nil, complianceStatus: [StringFilter]? = nil, confidence: [NumberFilter]? = nil, createdAt: [DateFilter]? = nil, criticality: [NumberFilter]? = nil, description: [StringFilter]? = nil, findingProviderFieldsConfidence: [NumberFilter]? = nil, findingProviderFieldsCriticality: [NumberFilter]? = nil, findingProviderFieldsRelatedFindingsId: [StringFilter]? = nil, findingProviderFieldsRelatedFindingsProductArn: [StringFilter]? = nil, findingProviderFieldsSeverityLabel: [StringFilter]? = nil, findingProviderFieldsSeverityOriginal: [StringFilter]? = nil, findingProviderFieldsTypes: [StringFilter]? = nil, firstObservedAt: [DateFilter]? = nil, generatorId: [StringFilter]? = nil, id: [StringFilter]? = nil, keyword: [KeywordFilter]? = nil, lastObservedAt: [DateFilter]? = nil, malwareName: [StringFilter]? = nil, malwarePath: [StringFilter]? = nil, malwareState: [StringFilter]? = nil, malwareType: [StringFilter]? = nil, networkDestinationDomain: [StringFilter]? = nil, networkDestinationIpV4: [IpFilter]? = nil, networkDestinationIpV6: [IpFilter]? = nil, networkDestinationPort: [NumberFilter]? = nil, networkDirection: [StringFilter]? = nil, networkProtocol: [StringFilter]? = nil, networkSourceDomain: [StringFilter]? = nil, networkSourceIpV4: [IpFilter]? = nil, networkSourceIpV6: [IpFilter]? = nil, networkSourceMac: [StringFilter]? = nil, networkSourcePort: [NumberFilter]? = nil, noteText: [StringFilter]? = nil, noteUpdatedAt: [DateFilter]? = nil, noteUpdatedBy: [StringFilter]? = nil, processLaunchedAt: [DateFilter]? = nil, processName: [StringFilter]? = nil, processParentPid: [NumberFilter]? = nil, processPath: [StringFilter]? = nil, processPid: [NumberFilter]? = nil, processTerminatedAt: [DateFilter]? = nil, productArn: [StringFilter]? = nil, productFields: [MapFilter]? = nil, productName: [StringFilter]? = nil, recommendationText: [StringFilter]? = nil, recordState: [StringFilter]? = nil, region: [StringFilter]? = nil, relatedFindingsId: [StringFilter]? = nil, relatedFindingsProductArn: [StringFilter]? = nil, resourceApplicationArn: [StringFilter]? = nil, resourceApplicationName: [StringFilter]? = nil, resourceAwsEc2InstanceIamInstanceProfileArn: [StringFilter]? = nil, resourceAwsEc2InstanceImageId: [StringFilter]? = nil, resourceAwsEc2InstanceIpV4Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceIpV6Addresses: [IpFilter]? = nil, resourceAwsEc2InstanceKeyName: [StringFilter]? = nil, resourceAwsEc2InstanceLaunchedAt: [DateFilter]? = nil, resourceAwsEc2InstanceSubnetId: [StringFilter]? = nil, resourceAwsEc2InstanceType: [StringFilter]? = nil, resourceAwsEc2InstanceVpcId: [StringFilter]? = nil, resourceAwsIamAccessKeyCreatedAt: [DateFilter]? = nil, resourceAwsIamAccessKeyPrincipalName: [StringFilter]? = nil, resourceAwsIamAccessKeyStatus: [StringFilter]? = nil, resourceAwsIamAccessKeyUserName: [StringFilter]? = nil, resourceAwsIamUserUserName: [StringFilter]? = nil, resourceAwsS3BucketOwnerId: [StringFilter]? = nil, resourceAwsS3BucketOwnerName: [StringFilter]? = nil, resourceContainerImageId: [StringFilter]? = nil, resourceContainerImageName: [StringFilter]? = nil, resourceContainerLaunchedAt: [DateFilter]? = nil, resourceContainerName: [StringFilter]? = nil, resourceDetailsOther: [MapFilter]? = nil, resourceId: [StringFilter]? = nil, resourcePartition: [StringFilter]? = nil, resourceRegion: [StringFilter]? = nil, resourceTags: [MapFilter]? = nil, resourceType: [StringFilter]? = nil, sample: [BooleanFilter]? = nil, severityLabel: [StringFilter]? = nil, severityNormalized: [NumberFilter]? = nil, severityProduct: [NumberFilter]? = nil, sourceUrl: [StringFilter]? = nil, threatIntelIndicatorCategory: [StringFilter]? = nil, threatIntelIndicatorLastObservedAt: [DateFilter]? = nil, threatIntelIndicatorSource: [StringFilter]? = nil, threatIntelIndicatorSourceUrl: [StringFilter]? = nil, threatIntelIndicatorType: [StringFilter]? = nil, threatIntelIndicatorValue: [StringFilter]? = nil, title: [StringFilter]? = nil, type: [StringFilter]? = nil, updatedAt: [DateFilter]? = nil, userDefinedFields: [MapFilter]? = nil, verificationState: [StringFilter]? = nil, vulnerabilitiesExploitAvailable: [StringFilter]? = nil, vulnerabilitiesFixAvailable: [StringFilter]? = nil, workflowState: [StringFilter]? = nil, workflowStatus: [StringFilter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountName = awsAccountName
            self.companyName = companyName
            self.complianceAssociatedStandardsId = complianceAssociatedStandardsId
            self.complianceSecurityControlId = complianceSecurityControlId
            self.complianceSecurityControlParametersName = complianceSecurityControlParametersName
            self.complianceSecurityControlParametersValue = complianceSecurityControlParametersValue
            self.complianceStatus = complianceStatus
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.findingProviderFieldsConfidence = findingProviderFieldsConfidence
            self.findingProviderFieldsCriticality = findingProviderFieldsCriticality
            self.findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsId
            self.findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArn
            self.findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabel
            self.findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginal
            self.findingProviderFieldsTypes = findingProviderFieldsTypes
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.keyword = keyword
            self.lastObservedAt = lastObservedAt
            self.malwareName = malwareName
            self.malwarePath = malwarePath
            self.malwareState = malwareState
            self.malwareType = malwareType
            self.networkDestinationDomain = networkDestinationDomain
            self.networkDestinationIpV4 = networkDestinationIpV4
            self.networkDestinationIpV6 = networkDestinationIpV6
            self.networkDestinationPort = networkDestinationPort
            self.networkDirection = networkDirection
            self.networkProtocol = networkProtocol
            self.networkSourceDomain = networkSourceDomain
            self.networkSourceIpV4 = networkSourceIpV4
            self.networkSourceIpV6 = networkSourceIpV6
            self.networkSourceMac = networkSourceMac
            self.networkSourcePort = networkSourcePort
            self.noteText = noteText
            self.noteUpdatedAt = noteUpdatedAt
            self.noteUpdatedBy = noteUpdatedBy
            self.processLaunchedAt = processLaunchedAt
            self.processName = processName
            self.processParentPid = processParentPid
            self.processPath = processPath
            self.processPid = processPid
            self.processTerminatedAt = processTerminatedAt
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recommendationText = recommendationText
            self.recordState = recordState
            self.region = region
            self.relatedFindingsId = relatedFindingsId
            self.relatedFindingsProductArn = relatedFindingsProductArn
            self.resourceApplicationArn = resourceApplicationArn
            self.resourceApplicationName = resourceApplicationName
            self.resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn
            self.resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId
            self.resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses
            self.resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses
            self.resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName
            self.resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt
            self.resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId
            self.resourceAwsEc2InstanceType = resourceAwsEc2InstanceType
            self.resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId
            self.resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt
            self.resourceAwsIamAccessKeyPrincipalName = resourceAwsIamAccessKeyPrincipalName
            self.resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus
            self.resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserName
            self.resourceAwsIamUserUserName = resourceAwsIamUserUserName
            self.resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId
            self.resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName
            self.resourceContainerImageId = resourceContainerImageId
            self.resourceContainerImageName = resourceContainerImageName
            self.resourceContainerLaunchedAt = resourceContainerLaunchedAt
            self.resourceContainerName = resourceContainerName
            self.resourceDetailsOther = resourceDetailsOther
            self.resourceId = resourceId
            self.resourcePartition = resourcePartition
            self.resourceRegion = resourceRegion
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.sample = sample
            self.severityLabel = severityLabel
            self.severityNormalized = severityNormalized
            self.severityProduct = severityProduct
            self.sourceUrl = sourceUrl
            self.threatIntelIndicatorCategory = threatIntelIndicatorCategory
            self.threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt
            self.threatIntelIndicatorSource = threatIntelIndicatorSource
            self.threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl
            self.threatIntelIndicatorType = threatIntelIndicatorType
            self.threatIntelIndicatorValue = threatIntelIndicatorValue
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.vulnerabilitiesExploitAvailable = vulnerabilitiesExploitAvailable
            self.vulnerabilitiesFixAvailable = vulnerabilitiesFixAvailable
            self.workflowState = workflowState
            self.workflowStatus = workflowStatus
        }

        public func validate(name: String) throws {
            try self.awsAccountId?.forEach {
                try $0.validate(name: "\(name).awsAccountId[]")
            }
            try self.awsAccountName?.forEach {
                try $0.validate(name: "\(name).awsAccountName[]")
            }
            try self.companyName?.forEach {
                try $0.validate(name: "\(name).companyName[]")
            }
            try self.complianceAssociatedStandardsId?.forEach {
                try $0.validate(name: "\(name).complianceAssociatedStandardsId[]")
            }
            try self.complianceSecurityControlId?.forEach {
                try $0.validate(name: "\(name).complianceSecurityControlId[]")
            }
            try self.complianceSecurityControlParametersName?.forEach {
                try $0.validate(name: "\(name).complianceSecurityControlParametersName[]")
            }
            try self.complianceSecurityControlParametersValue?.forEach {
                try $0.validate(name: "\(name).complianceSecurityControlParametersValue[]")
            }
            try self.complianceStatus?.forEach {
                try $0.validate(name: "\(name).complianceStatus[]")
            }
            try self.createdAt?.forEach {
                try $0.validate(name: "\(name).createdAt[]")
            }
            try self.description?.forEach {
                try $0.validate(name: "\(name).description[]")
            }
            try self.findingProviderFieldsRelatedFindingsId?.forEach {
                try $0.validate(name: "\(name).findingProviderFieldsRelatedFindingsId[]")
            }
            try self.findingProviderFieldsRelatedFindingsProductArn?.forEach {
                try $0.validate(name: "\(name).findingProviderFieldsRelatedFindingsProductArn[]")
            }
            try self.findingProviderFieldsSeverityLabel?.forEach {
                try $0.validate(name: "\(name).findingProviderFieldsSeverityLabel[]")
            }
            try self.findingProviderFieldsSeverityOriginal?.forEach {
                try $0.validate(name: "\(name).findingProviderFieldsSeverityOriginal[]")
            }
            try self.findingProviderFieldsTypes?.forEach {
                try $0.validate(name: "\(name).findingProviderFieldsTypes[]")
            }
            try self.firstObservedAt?.forEach {
                try $0.validate(name: "\(name).firstObservedAt[]")
            }
            try self.generatorId?.forEach {
                try $0.validate(name: "\(name).generatorId[]")
            }
            try self.id?.forEach {
                try $0.validate(name: "\(name).id[]")
            }
            try self.keyword?.forEach {
                try $0.validate(name: "\(name).keyword[]")
            }
            try self.lastObservedAt?.forEach {
                try $0.validate(name: "\(name).lastObservedAt[]")
            }
            try self.malwareName?.forEach {
                try $0.validate(name: "\(name).malwareName[]")
            }
            try self.malwarePath?.forEach {
                try $0.validate(name: "\(name).malwarePath[]")
            }
            try self.malwareState?.forEach {
                try $0.validate(name: "\(name).malwareState[]")
            }
            try self.malwareType?.forEach {
                try $0.validate(name: "\(name).malwareType[]")
            }
            try self.networkDestinationDomain?.forEach {
                try $0.validate(name: "\(name).networkDestinationDomain[]")
            }
            try self.networkDestinationIpV4?.forEach {
                try $0.validate(name: "\(name).networkDestinationIpV4[]")
            }
            try self.networkDestinationIpV6?.forEach {
                try $0.validate(name: "\(name).networkDestinationIpV6[]")
            }
            try self.networkDirection?.forEach {
                try $0.validate(name: "\(name).networkDirection[]")
            }
            try self.networkProtocol?.forEach {
                try $0.validate(name: "\(name).networkProtocol[]")
            }
            try self.networkSourceDomain?.forEach {
                try $0.validate(name: "\(name).networkSourceDomain[]")
            }
            try self.networkSourceIpV4?.forEach {
                try $0.validate(name: "\(name).networkSourceIpV4[]")
            }
            try self.networkSourceIpV6?.forEach {
                try $0.validate(name: "\(name).networkSourceIpV6[]")
            }
            try self.networkSourceMac?.forEach {
                try $0.validate(name: "\(name).networkSourceMac[]")
            }
            try self.noteText?.forEach {
                try $0.validate(name: "\(name).noteText[]")
            }
            try self.noteUpdatedAt?.forEach {
                try $0.validate(name: "\(name).noteUpdatedAt[]")
            }
            try self.noteUpdatedBy?.forEach {
                try $0.validate(name: "\(name).noteUpdatedBy[]")
            }
            try self.processLaunchedAt?.forEach {
                try $0.validate(name: "\(name).processLaunchedAt[]")
            }
            try self.processName?.forEach {
                try $0.validate(name: "\(name).processName[]")
            }
            try self.processPath?.forEach {
                try $0.validate(name: "\(name).processPath[]")
            }
            try self.processTerminatedAt?.forEach {
                try $0.validate(name: "\(name).processTerminatedAt[]")
            }
            try self.productArn?.forEach {
                try $0.validate(name: "\(name).productArn[]")
            }
            try self.productFields?.forEach {
                try $0.validate(name: "\(name).productFields[]")
            }
            try self.productName?.forEach {
                try $0.validate(name: "\(name).productName[]")
            }
            try self.recommendationText?.forEach {
                try $0.validate(name: "\(name).recommendationText[]")
            }
            try self.recordState?.forEach {
                try $0.validate(name: "\(name).recordState[]")
            }
            try self.region?.forEach {
                try $0.validate(name: "\(name).region[]")
            }
            try self.relatedFindingsId?.forEach {
                try $0.validate(name: "\(name).relatedFindingsId[]")
            }
            try self.relatedFindingsProductArn?.forEach {
                try $0.validate(name: "\(name).relatedFindingsProductArn[]")
            }
            try self.resourceApplicationArn?.forEach {
                try $0.validate(name: "\(name).resourceApplicationArn[]")
            }
            try self.resourceApplicationName?.forEach {
                try $0.validate(name: "\(name).resourceApplicationName[]")
            }
            try self.resourceAwsEc2InstanceIamInstanceProfileArn?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIamInstanceProfileArn[]")
            }
            try self.resourceAwsEc2InstanceImageId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceImageId[]")
            }
            try self.resourceAwsEc2InstanceIpV4Addresses?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIpV4Addresses[]")
            }
            try self.resourceAwsEc2InstanceIpV6Addresses?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceIpV6Addresses[]")
            }
            try self.resourceAwsEc2InstanceKeyName?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceKeyName[]")
            }
            try self.resourceAwsEc2InstanceLaunchedAt?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceLaunchedAt[]")
            }
            try self.resourceAwsEc2InstanceSubnetId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceSubnetId[]")
            }
            try self.resourceAwsEc2InstanceType?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceType[]")
            }
            try self.resourceAwsEc2InstanceVpcId?.forEach {
                try $0.validate(name: "\(name).resourceAwsEc2InstanceVpcId[]")
            }
            try self.resourceAwsIamAccessKeyCreatedAt?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyCreatedAt[]")
            }
            try self.resourceAwsIamAccessKeyPrincipalName?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyPrincipalName[]")
            }
            try self.resourceAwsIamAccessKeyStatus?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyStatus[]")
            }
            try self.resourceAwsIamAccessKeyUserName?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamAccessKeyUserName[]")
            }
            try self.resourceAwsIamUserUserName?.forEach {
                try $0.validate(name: "\(name).resourceAwsIamUserUserName[]")
            }
            try self.resourceAwsS3BucketOwnerId?.forEach {
                try $0.validate(name: "\(name).resourceAwsS3BucketOwnerId[]")
            }
            try self.resourceAwsS3BucketOwnerName?.forEach {
                try $0.validate(name: "\(name).resourceAwsS3BucketOwnerName[]")
            }
            try self.resourceContainerImageId?.forEach {
                try $0.validate(name: "\(name).resourceContainerImageId[]")
            }
            try self.resourceContainerImageName?.forEach {
                try $0.validate(name: "\(name).resourceContainerImageName[]")
            }
            try self.resourceContainerLaunchedAt?.forEach {
                try $0.validate(name: "\(name).resourceContainerLaunchedAt[]")
            }
            try self.resourceContainerName?.forEach {
                try $0.validate(name: "\(name).resourceContainerName[]")
            }
            try self.resourceDetailsOther?.forEach {
                try $0.validate(name: "\(name).resourceDetailsOther[]")
            }
            try self.resourceId?.forEach {
                try $0.validate(name: "\(name).resourceId[]")
            }
            try self.resourcePartition?.forEach {
                try $0.validate(name: "\(name).resourcePartition[]")
            }
            try self.resourceRegion?.forEach {
                try $0.validate(name: "\(name).resourceRegion[]")
            }
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.resourceType?.forEach {
                try $0.validate(name: "\(name).resourceType[]")
            }
            try self.severityLabel?.forEach {
                try $0.validate(name: "\(name).severityLabel[]")
            }
            try self.sourceUrl?.forEach {
                try $0.validate(name: "\(name).sourceUrl[]")
            }
            try self.threatIntelIndicatorCategory?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorCategory[]")
            }
            try self.threatIntelIndicatorLastObservedAt?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorLastObservedAt[]")
            }
            try self.threatIntelIndicatorSource?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorSource[]")
            }
            try self.threatIntelIndicatorSourceUrl?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorSourceUrl[]")
            }
            try self.threatIntelIndicatorType?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorType[]")
            }
            try self.threatIntelIndicatorValue?.forEach {
                try $0.validate(name: "\(name).threatIntelIndicatorValue[]")
            }
            try self.title?.forEach {
                try $0.validate(name: "\(name).title[]")
            }
            try self.type?.forEach {
                try $0.validate(name: "\(name).type[]")
            }
            try self.updatedAt?.forEach {
                try $0.validate(name: "\(name).updatedAt[]")
            }
            try self.userDefinedFields?.forEach {
                try $0.validate(name: "\(name).userDefinedFields[]")
            }
            try self.verificationState?.forEach {
                try $0.validate(name: "\(name).verificationState[]")
            }
            try self.vulnerabilitiesExploitAvailable?.forEach {
                try $0.validate(name: "\(name).vulnerabilitiesExploitAvailable[]")
            }
            try self.vulnerabilitiesFixAvailable?.forEach {
                try $0.validate(name: "\(name).vulnerabilitiesFixAvailable[]")
            }
            try self.workflowState?.forEach {
                try $0.validate(name: "\(name).workflowState[]")
            }
            try self.workflowStatus?.forEach {
                try $0.validate(name: "\(name).workflowStatus[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "AwsAccountId"
            case awsAccountName = "AwsAccountName"
            case companyName = "CompanyName"
            case complianceAssociatedStandardsId = "ComplianceAssociatedStandardsId"
            case complianceSecurityControlId = "ComplianceSecurityControlId"
            case complianceSecurityControlParametersName = "ComplianceSecurityControlParametersName"
            case complianceSecurityControlParametersValue = "ComplianceSecurityControlParametersValue"
            case complianceStatus = "ComplianceStatus"
            case confidence = "Confidence"
            case createdAt = "CreatedAt"
            case criticality = "Criticality"
            case description = "Description"
            case findingProviderFieldsConfidence = "FindingProviderFieldsConfidence"
            case findingProviderFieldsCriticality = "FindingProviderFieldsCriticality"
            case findingProviderFieldsRelatedFindingsId = "FindingProviderFieldsRelatedFindingsId"
            case findingProviderFieldsRelatedFindingsProductArn = "FindingProviderFieldsRelatedFindingsProductArn"
            case findingProviderFieldsSeverityLabel = "FindingProviderFieldsSeverityLabel"
            case findingProviderFieldsSeverityOriginal = "FindingProviderFieldsSeverityOriginal"
            case findingProviderFieldsTypes = "FindingProviderFieldsTypes"
            case firstObservedAt = "FirstObservedAt"
            case generatorId = "GeneratorId"
            case id = "Id"
            case keyword = "Keyword"
            case lastObservedAt = "LastObservedAt"
            case malwareName = "MalwareName"
            case malwarePath = "MalwarePath"
            case malwareState = "MalwareState"
            case malwareType = "MalwareType"
            case networkDestinationDomain = "NetworkDestinationDomain"
            case networkDestinationIpV4 = "NetworkDestinationIpV4"
            case networkDestinationIpV6 = "NetworkDestinationIpV6"
            case networkDestinationPort = "NetworkDestinationPort"
            case networkDirection = "NetworkDirection"
            case networkProtocol = "NetworkProtocol"
            case networkSourceDomain = "NetworkSourceDomain"
            case networkSourceIpV4 = "NetworkSourceIpV4"
            case networkSourceIpV6 = "NetworkSourceIpV6"
            case networkSourceMac = "NetworkSourceMac"
            case networkSourcePort = "NetworkSourcePort"
            case noteText = "NoteText"
            case noteUpdatedAt = "NoteUpdatedAt"
            case noteUpdatedBy = "NoteUpdatedBy"
            case processLaunchedAt = "ProcessLaunchedAt"
            case processName = "ProcessName"
            case processParentPid = "ProcessParentPid"
            case processPath = "ProcessPath"
            case processPid = "ProcessPid"
            case processTerminatedAt = "ProcessTerminatedAt"
            case productArn = "ProductArn"
            case productFields = "ProductFields"
            case productName = "ProductName"
            case recommendationText = "RecommendationText"
            case recordState = "RecordState"
            case region = "Region"
            case relatedFindingsId = "RelatedFindingsId"
            case relatedFindingsProductArn = "RelatedFindingsProductArn"
            case resourceApplicationArn = "ResourceApplicationArn"
            case resourceApplicationName = "ResourceApplicationName"
            case resourceAwsEc2InstanceIamInstanceProfileArn = "ResourceAwsEc2InstanceIamInstanceProfileArn"
            case resourceAwsEc2InstanceImageId = "ResourceAwsEc2InstanceImageId"
            case resourceAwsEc2InstanceIpV4Addresses = "ResourceAwsEc2InstanceIpV4Addresses"
            case resourceAwsEc2InstanceIpV6Addresses = "ResourceAwsEc2InstanceIpV6Addresses"
            case resourceAwsEc2InstanceKeyName = "ResourceAwsEc2InstanceKeyName"
            case resourceAwsEc2InstanceLaunchedAt = "ResourceAwsEc2InstanceLaunchedAt"
            case resourceAwsEc2InstanceSubnetId = "ResourceAwsEc2InstanceSubnetId"
            case resourceAwsEc2InstanceType = "ResourceAwsEc2InstanceType"
            case resourceAwsEc2InstanceVpcId = "ResourceAwsEc2InstanceVpcId"
            case resourceAwsIamAccessKeyCreatedAt = "ResourceAwsIamAccessKeyCreatedAt"
            case resourceAwsIamAccessKeyPrincipalName = "ResourceAwsIamAccessKeyPrincipalName"
            case resourceAwsIamAccessKeyStatus = "ResourceAwsIamAccessKeyStatus"
            case resourceAwsIamAccessKeyUserName = "ResourceAwsIamAccessKeyUserName"
            case resourceAwsIamUserUserName = "ResourceAwsIamUserUserName"
            case resourceAwsS3BucketOwnerId = "ResourceAwsS3BucketOwnerId"
            case resourceAwsS3BucketOwnerName = "ResourceAwsS3BucketOwnerName"
            case resourceContainerImageId = "ResourceContainerImageId"
            case resourceContainerImageName = "ResourceContainerImageName"
            case resourceContainerLaunchedAt = "ResourceContainerLaunchedAt"
            case resourceContainerName = "ResourceContainerName"
            case resourceDetailsOther = "ResourceDetailsOther"
            case resourceId = "ResourceId"
            case resourcePartition = "ResourcePartition"
            case resourceRegion = "ResourceRegion"
            case resourceTags = "ResourceTags"
            case resourceType = "ResourceType"
            case sample = "Sample"
            case severityLabel = "SeverityLabel"
            case severityNormalized = "SeverityNormalized"
            case severityProduct = "SeverityProduct"
            case sourceUrl = "SourceUrl"
            case threatIntelIndicatorCategory = "ThreatIntelIndicatorCategory"
            case threatIntelIndicatorLastObservedAt = "ThreatIntelIndicatorLastObservedAt"
            case threatIntelIndicatorSource = "ThreatIntelIndicatorSource"
            case threatIntelIndicatorSourceUrl = "ThreatIntelIndicatorSourceUrl"
            case threatIntelIndicatorType = "ThreatIntelIndicatorType"
            case threatIntelIndicatorValue = "ThreatIntelIndicatorValue"
            case title = "Title"
            case type = "Type"
            case updatedAt = "UpdatedAt"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case vulnerabilitiesExploitAvailable = "VulnerabilitiesExploitAvailable"
            case vulnerabilitiesFixAvailable = "VulnerabilitiesFixAvailable"
            case workflowState = "WorkflowState"
            case workflowStatus = "WorkflowStatus"
        }
    }

    public struct AwsSecurityFindingIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the finding that was specified by the finding provider.
        public let id: String?
        /// The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.
        public let productArn: String?

        @inlinable
        public init(id: String? = nil, productArn: String? = nil) {
            self.id = id
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case productArn = "ProductArn"
        }
    }

    public struct AwsSnsTopicDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to a platform application endpoint.
        public let applicationSuccessFeedbackRoleArn: String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
        public let firehoseFailureFeedbackRoleArn: String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
        public let firehoseSuccessFeedbackRoleArn: String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
        public let httpFailureFeedbackRoleArn: String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
        public let httpSuccessFeedbackRoleArn: String?
        /// The ID of an Amazon Web Services managed key for Amazon SNS or a customer managed key.
        public let kmsMasterKeyId: String?
        /// The subscription's owner.
        public let owner: String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
        public let sqsFailureFeedbackRoleArn: String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
        public let sqsSuccessFeedbackRoleArn: String?
        /// Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.
        public let subscription: [AwsSnsTopicSubscription]?
        /// The name of the Amazon SNS topic.
        public let topicName: String?

        @inlinable
        public init(applicationSuccessFeedbackRoleArn: String? = nil, firehoseFailureFeedbackRoleArn: String? = nil, firehoseSuccessFeedbackRoleArn: String? = nil, httpFailureFeedbackRoleArn: String? = nil, httpSuccessFeedbackRoleArn: String? = nil, kmsMasterKeyId: String? = nil, owner: String? = nil, sqsFailureFeedbackRoleArn: String? = nil, sqsSuccessFeedbackRoleArn: String? = nil, subscription: [AwsSnsTopicSubscription]? = nil, topicName: String? = nil) {
            self.applicationSuccessFeedbackRoleArn = applicationSuccessFeedbackRoleArn
            self.firehoseFailureFeedbackRoleArn = firehoseFailureFeedbackRoleArn
            self.firehoseSuccessFeedbackRoleArn = firehoseSuccessFeedbackRoleArn
            self.httpFailureFeedbackRoleArn = httpFailureFeedbackRoleArn
            self.httpSuccessFeedbackRoleArn = httpSuccessFeedbackRoleArn
            self.kmsMasterKeyId = kmsMasterKeyId
            self.owner = owner
            self.sqsFailureFeedbackRoleArn = sqsFailureFeedbackRoleArn
            self.sqsSuccessFeedbackRoleArn = sqsSuccessFeedbackRoleArn
            self.subscription = subscription
            self.topicName = topicName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationSuccessFeedbackRoleArn, name: "applicationSuccessFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.firehoseFailureFeedbackRoleArn, name: "firehoseFailureFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.firehoseSuccessFeedbackRoleArn, name: "firehoseSuccessFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.httpFailureFeedbackRoleArn, name: "httpFailureFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.httpSuccessFeedbackRoleArn, name: "httpSuccessFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.kmsMasterKeyId, name: "kmsMasterKeyId", parent: name, pattern: "\\S")
            try self.validate(self.owner, name: "owner", parent: name, pattern: "\\S")
            try self.validate(self.sqsFailureFeedbackRoleArn, name: "sqsFailureFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.validate(self.sqsSuccessFeedbackRoleArn, name: "sqsSuccessFeedbackRoleArn", parent: name, pattern: "\\S")
            try self.subscription?.forEach {
                try $0.validate(name: "\(name).subscription[]")
            }
            try self.validate(self.topicName, name: "topicName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationSuccessFeedbackRoleArn = "ApplicationSuccessFeedbackRoleArn"
            case firehoseFailureFeedbackRoleArn = "FirehoseFailureFeedbackRoleArn"
            case firehoseSuccessFeedbackRoleArn = "FirehoseSuccessFeedbackRoleArn"
            case httpFailureFeedbackRoleArn = "HttpFailureFeedbackRoleArn"
            case httpSuccessFeedbackRoleArn = "HttpSuccessFeedbackRoleArn"
            case kmsMasterKeyId = "KmsMasterKeyId"
            case owner = "Owner"
            case sqsFailureFeedbackRoleArn = "SqsFailureFeedbackRoleArn"
            case sqsSuccessFeedbackRoleArn = "SqsSuccessFeedbackRoleArn"
            case subscription = "Subscription"
            case topicName = "TopicName"
        }
    }

    public struct AwsSnsTopicSubscription: AWSEncodableShape & AWSDecodableShape {
        /// The subscription's endpoint (format depends on the protocol).
        public let endpoint: String?
        /// The subscription's protocol.
        public let `protocol`: String?

        @inlinable
        public init(endpoint: String? = nil, protocol: String? = nil) {
            self.endpoint = endpoint
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
            case `protocol` = "Protocol"
        }
    }

    public struct AwsSqsQueueDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the dead-letter queue to which Amazon SQS moves messages after the value of maxReceiveCount is exceeded.
        public let deadLetterTargetArn: String?
        /// The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling KMS again.
        public let kmsDataKeyReusePeriodSeconds: Int?
        /// The ID of an Amazon Web Services managed key for Amazon SQS or a custom KMS key.
        public let kmsMasterKeyId: String?
        /// The name of the new queue.
        public let queueName: String?

        @inlinable
        public init(deadLetterTargetArn: String? = nil, kmsDataKeyReusePeriodSeconds: Int? = nil, kmsMasterKeyId: String? = nil, queueName: String? = nil) {
            self.deadLetterTargetArn = deadLetterTargetArn
            self.kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSeconds
            self.kmsMasterKeyId = kmsMasterKeyId
            self.queueName = queueName
        }

        public func validate(name: String) throws {
            try self.validate(self.deadLetterTargetArn, name: "deadLetterTargetArn", parent: name, pattern: "\\S")
            try self.validate(self.kmsMasterKeyId, name: "kmsMasterKeyId", parent: name, pattern: "\\S")
            try self.validate(self.queueName, name: "queueName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case deadLetterTargetArn = "DeadLetterTargetArn"
            case kmsDataKeyReusePeriodSeconds = "KmsDataKeyReusePeriodSeconds"
            case kmsMasterKeyId = "KmsMasterKeyId"
            case queueName = "QueueName"
        }
    }

    public struct AwsSsmComplianceSummary: AWSEncodableShape & AWSDecodableShape {
        /// The type of resource for which the compliance was determined. For AwsSsmPatchCompliance, ComplianceType is Patch.
        public let complianceType: String?
        /// For the patches that are compliant, the number that have a severity of CRITICAL.
        public let compliantCriticalCount: Int?
        /// For the patches that are compliant, the number that have a severity of HIGH.
        public let compliantHighCount: Int?
        /// For the patches that are compliant, the number that have a severity of INFORMATIONAL.
        public let compliantInformationalCount: Int?
        /// For the patches that are compliant, the number that have a severity of LOW.
        public let compliantLowCount: Int?
        /// For the patches that are compliant, the number that have a severity of MEDIUM.
        public let compliantMediumCount: Int?
        /// For the patches that are compliant, the number that have a severity of UNSPECIFIED.
        public let compliantUnspecifiedCount: Int?
        /// The type of execution that was used determine compliance.
        public let executionType: String?
        /// For the patch items that are noncompliant, the number of items that have a severity of CRITICAL.
        public let nonCompliantCriticalCount: Int?
        /// For the patches that are noncompliant, the number that have a severity of HIGH.
        public let nonCompliantHighCount: Int?
        /// For the patches that are noncompliant, the number that have a severity of INFORMATIONAL.
        public let nonCompliantInformationalCount: Int?
        /// For the patches that are noncompliant, the number that have a severity of LOW.
        public let nonCompliantLowCount: Int?
        /// For the patches that are noncompliant, the number that have a severity of MEDIUM.
        public let nonCompliantMediumCount: Int?
        /// For the patches that are noncompliant, the number that have a severity of UNSPECIFIED.
        public let nonCompliantUnspecifiedCount: Int?
        /// The highest severity for the patches. Valid values are as follows:    CRITICAL     HIGH     MEDIUM     LOW     INFORMATIONAL     UNSPECIFIED
        public let overallSeverity: String?
        /// The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.
        public let patchBaselineId: String?
        /// The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.
        public let patchGroup: String?
        /// The current patch compliance status. Valid values are as follows:    COMPLIANT     NON_COMPLIANT     UNSPECIFIED_DATA
        public let status: String?

        @inlinable
        public init(complianceType: String? = nil, compliantCriticalCount: Int? = nil, compliantHighCount: Int? = nil, compliantInformationalCount: Int? = nil, compliantLowCount: Int? = nil, compliantMediumCount: Int? = nil, compliantUnspecifiedCount: Int? = nil, executionType: String? = nil, nonCompliantCriticalCount: Int? = nil, nonCompliantHighCount: Int? = nil, nonCompliantInformationalCount: Int? = nil, nonCompliantLowCount: Int? = nil, nonCompliantMediumCount: Int? = nil, nonCompliantUnspecifiedCount: Int? = nil, overallSeverity: String? = nil, patchBaselineId: String? = nil, patchGroup: String? = nil, status: String? = nil) {
            self.complianceType = complianceType
            self.compliantCriticalCount = compliantCriticalCount
            self.compliantHighCount = compliantHighCount
            self.compliantInformationalCount = compliantInformationalCount
            self.compliantLowCount = compliantLowCount
            self.compliantMediumCount = compliantMediumCount
            self.compliantUnspecifiedCount = compliantUnspecifiedCount
            self.executionType = executionType
            self.nonCompliantCriticalCount = nonCompliantCriticalCount
            self.nonCompliantHighCount = nonCompliantHighCount
            self.nonCompliantInformationalCount = nonCompliantInformationalCount
            self.nonCompliantLowCount = nonCompliantLowCount
            self.nonCompliantMediumCount = nonCompliantMediumCount
            self.nonCompliantUnspecifiedCount = nonCompliantUnspecifiedCount
            self.overallSeverity = overallSeverity
            self.patchBaselineId = patchBaselineId
            self.patchGroup = patchGroup
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.complianceType, name: "complianceType", parent: name, pattern: "\\S")
            try self.validate(self.executionType, name: "executionType", parent: name, pattern: "\\S")
            try self.validate(self.overallSeverity, name: "overallSeverity", parent: name, pattern: "\\S")
            try self.validate(self.patchBaselineId, name: "patchBaselineId", parent: name, pattern: "\\S")
            try self.validate(self.patchGroup, name: "patchGroup", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case complianceType = "ComplianceType"
            case compliantCriticalCount = "CompliantCriticalCount"
            case compliantHighCount = "CompliantHighCount"
            case compliantInformationalCount = "CompliantInformationalCount"
            case compliantLowCount = "CompliantLowCount"
            case compliantMediumCount = "CompliantMediumCount"
            case compliantUnspecifiedCount = "CompliantUnspecifiedCount"
            case executionType = "ExecutionType"
            case nonCompliantCriticalCount = "NonCompliantCriticalCount"
            case nonCompliantHighCount = "NonCompliantHighCount"
            case nonCompliantInformationalCount = "NonCompliantInformationalCount"
            case nonCompliantLowCount = "NonCompliantLowCount"
            case nonCompliantMediumCount = "NonCompliantMediumCount"
            case nonCompliantUnspecifiedCount = "NonCompliantUnspecifiedCount"
            case overallSeverity = "OverallSeverity"
            case patchBaselineId = "PatchBaselineId"
            case patchGroup = "PatchGroup"
            case status = "Status"
        }
    }

    public struct AwsSsmPatch: AWSEncodableShape & AWSDecodableShape {
        /// The compliance status details for the patch.
        public let complianceSummary: AwsSsmComplianceSummary?

        @inlinable
        public init(complianceSummary: AwsSsmComplianceSummary? = nil) {
            self.complianceSummary = complianceSummary
        }

        public func validate(name: String) throws {
            try self.complianceSummary?.validate(name: "\(name).complianceSummary")
        }

        private enum CodingKeys: String, CodingKey {
            case complianceSummary = "ComplianceSummary"
        }
    }

    public struct AwsSsmPatchComplianceDetails: AWSEncodableShape & AWSDecodableShape {
        /// Information about the status of a patch.
        public let patch: AwsSsmPatch?

        @inlinable
        public init(patch: AwsSsmPatch? = nil) {
            self.patch = patch
        }

        public func validate(name: String) throws {
            try self.patch?.validate(name: "\(name).patch")
        }

        private enum CodingKeys: String, CodingKey {
            case patch = "Patch"
        }
    }

    public struct AwsStepFunctionStateMachineDetails: AWSEncodableShape & AWSDecodableShape {
        ///  A user-defined or an auto-generated string that identifies a Map state. This parameter is present only if  the stateMachineArn specified in input is a qualified state machine ARN.
        public let label: String?
        ///  Used to set CloudWatch Logs options.
        public let loggingConfiguration: AwsStepFunctionStateMachineLoggingConfigurationDetails?
        ///  The name of the state machine.
        public let name: String?
        ///  The Amazon Resource Name (ARN) of the IAM role used when creating this state machine.
        public let roleArn: String?
        ///  The ARN that identifies the state machine.
        public let stateMachineArn: String?
        ///  The current status of the state machine.
        public let status: String?
        ///  Specifies whether X-Ray tracing is enabled.
        public let tracingConfiguration: AwsStepFunctionStateMachineTracingConfigurationDetails?
        ///  The type of the state machine (STANDARD or EXPRESS).
        public let type: String?

        @inlinable
        public init(label: String? = nil, loggingConfiguration: AwsStepFunctionStateMachineLoggingConfigurationDetails? = nil, name: String? = nil, roleArn: String? = nil, stateMachineArn: String? = nil, status: String? = nil, tracingConfiguration: AwsStepFunctionStateMachineTracingConfigurationDetails? = nil, type: String? = nil) {
            self.label = label
            self.loggingConfiguration = loggingConfiguration
            self.name = name
            self.roleArn = roleArn
            self.stateMachineArn = stateMachineArn
            self.status = status
            self.tracingConfiguration = tracingConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.label, name: "label", parent: name, pattern: "\\S")
            try self.loggingConfiguration?.validate(name: "\(name).loggingConfiguration")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "\\S")
            try self.validate(self.stateMachineArn, name: "stateMachineArn", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case loggingConfiguration = "LoggingConfiguration"
            case name = "Name"
            case roleArn = "RoleArn"
            case stateMachineArn = "StateMachineArn"
            case status = "Status"
            case tracingConfiguration = "TracingConfiguration"
            case type = "Type"
        }
    }

    public struct AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN (ends with :*) of the CloudWatch Logs log group to which you want your logs emitted.
        public let logGroupArn: String?

        @inlinable
        public init(logGroupArn: String? = nil) {
            self.logGroupArn = logGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupArn = "LogGroupArn"
        }
    }

    public struct AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails: AWSEncodableShape & AWSDecodableShape {
        ///  An object describing a CloudWatch Logs log group. For more information, see   Amazon Web Services::Logs::LogGroup in the CloudFormation User Guide.
        public let cloudWatchLogsLogGroup: AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails?

        @inlinable
        public init(cloudWatchLogsLogGroup: AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails? = nil) {
            self.cloudWatchLogsLogGroup = cloudWatchLogsLogGroup
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogsLogGroup?.validate(name: "\(name).cloudWatchLogsLogGroup")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroup = "CloudWatchLogsLogGroup"
        }
    }

    public struct AwsStepFunctionStateMachineLoggingConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  An array of objects that describes where your execution history events will be logged.
        public let destinations: [AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails]?
        ///  Determines whether execution data is included in your log. When set to false, data is excluded.
        public let includeExecutionData: Bool?
        ///  Defines which category of execution history events are logged.
        public let level: String?

        @inlinable
        public init(destinations: [AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails]? = nil, includeExecutionData: Bool? = nil, level: String? = nil) {
            self.destinations = destinations
            self.includeExecutionData = includeExecutionData
            self.level = level
        }

        public func validate(name: String) throws {
            try self.destinations?.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.validate(self.level, name: "level", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "Destinations"
            case includeExecutionData = "IncludeExecutionData"
            case level = "Level"
        }
    }

    public struct AwsStepFunctionStateMachineTracingConfigurationDetails: AWSEncodableShape & AWSDecodableShape {
        ///  When set to true, X-Ray tracing is enabled.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct AwsWafRateBasedRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// The predicates to include in the rate-based rule.
        public let matchPredicates: [AwsWafRateBasedRuleMatchPredicate]?
        /// The name of the metrics for the rate-based rule.
        public let metricName: String?
        /// The name of the rate-based rule.
        public let name: String?
        /// The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.
        public let rateKey: String?
        /// The maximum number of requests that have an identical value for the field specified in RateKey that are allowed within a five-minute period. If the number of requests exceeds RateLimit and the other predicates specified in the rule are met, WAF triggers the action for the rule.
        public let rateLimit: Int64?
        /// The unique identifier for the rate-based rule.
        public let ruleId: String?

        @inlinable
        public init(matchPredicates: [AwsWafRateBasedRuleMatchPredicate]? = nil, metricName: String? = nil, name: String? = nil, rateKey: String? = nil, rateLimit: Int64? = nil, ruleId: String? = nil) {
            self.matchPredicates = matchPredicates
            self.metricName = metricName
            self.name = name
            self.rateKey = rateKey
            self.rateLimit = rateLimit
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.matchPredicates?.forEach {
                try $0.validate(name: "\(name).matchPredicates[]")
            }
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.rateKey, name: "rateKey", parent: name, pattern: "\\S")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case matchPredicates = "MatchPredicates"
            case metricName = "MetricName"
            case name = "Name"
            case rateKey = "RateKey"
            case rateLimit = "RateLimit"
            case ruleId = "RuleId"
        }
    }

    public struct AwsWafRateBasedRuleMatchPredicate: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the predicate.
        public let dataId: String?
        /// If set to true, then the rule actions are performed on requests that match the predicate settings. If set to false, then the rule actions are performed on all requests except those that match the predicate settings.
        public let negated: Bool?
        /// The type of predicate. Valid values are as follows:    ByteMatch     GeoMatch     IPMatch     RegexMatch     SizeConstraint     SqlInjectionMatch     XssMatch
        public let type: String?

        @inlinable
        public init(dataId: String? = nil, negated: Bool? = nil, type: String? = nil) {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.dataId, name: "dataId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataId = "DataId"
            case negated = "Negated"
            case type = "Type"
        }
    }

    public struct AwsWafRegionalRateBasedRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// The predicates to include in the rate-based rule.
        public let matchPredicates: [AwsWafRegionalRateBasedRuleMatchPredicate]?
        /// The name of the metrics for the rate-based rule.
        public let metricName: String?
        /// The name of the rate-based rule.
        public let name: String?
        /// The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.
        public let rateKey: String?
        /// The maximum number of requests that have an identical value for the field specified in RateKey that are allowed within a five-minute period. If the number of requests exceeds RateLimit and the other predicates specified in the rule are met, WAF triggers the action for the rule.
        public let rateLimit: Int64?
        /// The unique identifier for the rate-based rule.
        public let ruleId: String?

        @inlinable
        public init(matchPredicates: [AwsWafRegionalRateBasedRuleMatchPredicate]? = nil, metricName: String? = nil, name: String? = nil, rateKey: String? = nil, rateLimit: Int64? = nil, ruleId: String? = nil) {
            self.matchPredicates = matchPredicates
            self.metricName = metricName
            self.name = name
            self.rateKey = rateKey
            self.rateLimit = rateLimit
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.matchPredicates?.forEach {
                try $0.validate(name: "\(name).matchPredicates[]")
            }
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.rateKey, name: "rateKey", parent: name, pattern: "\\S")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case matchPredicates = "MatchPredicates"
            case metricName = "MetricName"
            case name = "Name"
            case rateKey = "RateKey"
            case rateLimit = "RateLimit"
            case ruleId = "RuleId"
        }
    }

    public struct AwsWafRegionalRateBasedRuleMatchPredicate: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the predicate.
        public let dataId: String?
        /// If set to true, then the rule actions are performed on requests that match the predicate settings. If set to false, then the rule actions are performed on all requests except those that match the predicate settings.
        public let negated: Bool?
        /// The type of predicate. Valid values are as follows:    ByteMatch     GeoMatch     IPMatch     RegexMatch     SizeConstraint     SqlInjectionMatch     XssMatch
        public let type: String?

        @inlinable
        public init(dataId: String? = nil, negated: Bool? = nil, type: String? = nil) {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.dataId, name: "dataId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataId = "DataId"
            case negated = "Negated"
            case type = "Type"
        }
    }

    public struct AwsWafRegionalRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// A name for the metrics for the rule.
        public let metricName: String?
        /// A descriptive name for the rule.
        public let name: String?
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
        public let predicateList: [AwsWafRegionalRulePredicateListDetails]?
        /// The ID of the rule.
        public let ruleId: String?

        @inlinable
        public init(metricName: String? = nil, name: String? = nil, predicateList: [AwsWafRegionalRulePredicateListDetails]? = nil, ruleId: String? = nil) {
            self.metricName = metricName
            self.name = name
            self.predicateList = predicateList
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.predicateList?.forEach {
                try $0.validate(name: "\(name).predicateList[]")
            }
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case name = "Name"
            case predicateList = "PredicateList"
            case ruleId = "RuleId"
        }
    }

    public struct AwsWafRegionalRuleGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// A name for the metrics for this rule group.
        public let metricName: String?
        /// The descriptive name of the rule group.
        public let name: String?
        /// The ID of the rule group.
        public let ruleGroupId: String?
        /// Provides information about the rule statements used to identify the web requests that you want to allow, block, or
        /// count.
        public let rules: [AwsWafRegionalRuleGroupRulesDetails]?

        @inlinable
        public init(metricName: String? = nil, name: String? = nil, ruleGroupId: String? = nil, rules: [AwsWafRegionalRuleGroupRulesDetails]? = nil) {
            self.metricName = metricName
            self.name = name
            self.ruleGroupId = ruleGroupId
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.ruleGroupId, name: "ruleGroupId", parent: name, pattern: "\\S")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case name = "Name"
            case ruleGroupId = "RuleGroupId"
            case rules = "Rules"
        }
    }

    public struct AwsWafRegionalRuleGroupRulesActionDetails: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet,
        /// GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsWafRegionalRuleGroupRulesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The action that WAF should take on a web request when it matches the criteria defined in the rule.
        public let action: AwsWafRegionalRuleGroupRulesActionDetails?
        /// If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of Priority.
        public let priority: Int?
        /// The ID for a rule.
        public let ruleId: String?
        /// The type of rule in the rule group.
        public let type: String?

        @inlinable
        public init(action: AwsWafRegionalRuleGroupRulesActionDetails? = nil, priority: Int? = nil, ruleId: String? = nil, type: String? = nil) {
            self.action = action
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case priority = "Priority"
            case ruleId = "RuleId"
            case type = "Type"
        }
    }

    public struct AwsWafRegionalRulePredicateListDetails: AWSEncodableShape & AWSDecodableShape {
        /// A unique identifier for a predicate in a rule, such as ByteMatchSetId or IPSetId.
        public let dataId: String?
        /// Specifies if you want WAF to allow, block, or count requests based on the settings in the  ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet,  RegexMatchSet, GeoMatchSet, or SizeConstraintSet.
        public let negated: Bool?
        /// The type of predicate in a rule, such as ByteMatch or IPSet.
        public let type: String?

        @inlinable
        public init(dataId: String? = nil, negated: Bool? = nil, type: String? = nil) {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.dataId, name: "dataId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataId = "DataId"
            case negated = "Negated"
            case type = "Type"
        }
    }

    public struct AwsWafRegionalWebAclDetails: AWSEncodableShape & AWSDecodableShape {
        /// The action to perform if none of the rules contained in the web ACL match.
        public let defaultAction: String?
        /// A name for the metrics for this web ACL.
        public let metricName: String?
        /// A descriptive name for the web ACL.
        public let name: String?
        /// An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of
        /// the rule.
        public let rulesList: [AwsWafRegionalWebAclRulesListDetails]?
        /// The ID of the web ACL.
        public let webAclId: String?

        @inlinable
        public init(defaultAction: String? = nil, metricName: String? = nil, name: String? = nil, rulesList: [AwsWafRegionalWebAclRulesListDetails]? = nil, webAclId: String? = nil) {
            self.defaultAction = defaultAction
            self.metricName = metricName
            self.name = name
            self.rulesList = rulesList
            self.webAclId = webAclId
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultAction, name: "defaultAction", parent: name, pattern: "\\S")
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.rulesList?.forEach {
                try $0.validate(name: "\(name).rulesList[]")
            }
            try self.validate(self.webAclId, name: "webAclId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "DefaultAction"
            case metricName = "MetricName"
            case name = "Name"
            case rulesList = "RulesList"
            case webAclId = "WebAclId"
        }
    }

    public struct AwsWafRegionalWebAclRulesListActionDetails: AWSEncodableShape & AWSDecodableShape {
        /// For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsWafRegionalWebAclRulesListDetails: AWSEncodableShape & AWSDecodableShape {
        /// The action that WAF takes when a web request matches all conditions in the rule, such as allow,  block, or count the request.
        public let action: AwsWafRegionalWebAclRulesListActionDetails?
        /// Overrides the rule evaluation result in the rule group.
        public let overrideAction: AwsWafRegionalWebAclRulesListOverrideActionDetails?
        /// The order in which WAF evaluates the rules in a web ACL.
        public let priority: Int?
        /// The ID of an WAF Regional rule to associate with a web ACL.
        public let ruleId: String?
        /// For actions that are associated with a rule, the action that WAF takes when a web
        /// request matches all conditions in a rule.
        public let type: String?

        @inlinable
        public init(action: AwsWafRegionalWebAclRulesListActionDetails? = nil, overrideAction: AwsWafRegionalWebAclRulesListOverrideActionDetails? = nil, priority: Int? = nil, ruleId: String? = nil, type: String? = nil) {
            self.action = action
            self.overrideAction = overrideAction
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.overrideAction?.validate(name: "\(name).overrideAction")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case overrideAction = "OverrideAction"
            case priority = "Priority"
            case ruleId = "RuleId"
            case type = "Type"
        }
    }

    public struct AwsWafRegionalWebAclRulesListOverrideActionDetails: AWSEncodableShape & AWSDecodableShape {
        /// Overrides the rule evaluation result in the rule group.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsWafRuleDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metrics for this rule.
        public let metricName: String?
        /// A descriptive name for the rule.
        public let name: String?
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet,  RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and,  for each object, indicates whether you want to negate the settings.
        public let predicateList: [AwsWafRulePredicateListDetails]?
        /// The ID of the WAF rule.
        public let ruleId: String?

        @inlinable
        public init(metricName: String? = nil, name: String? = nil, predicateList: [AwsWafRulePredicateListDetails]? = nil, ruleId: String? = nil) {
            self.metricName = metricName
            self.name = name
            self.predicateList = predicateList
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.predicateList?.forEach {
                try $0.validate(name: "\(name).predicateList[]")
            }
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case name = "Name"
            case predicateList = "PredicateList"
            case ruleId = "RuleId"
        }
    }

    public struct AwsWafRuleGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metrics for this rule group.
        public let metricName: String?
        /// The name of the rule group.
        public let name: String?
        /// The ID of the rule group.
        public let ruleGroupId: String?
        /// Provides information about the rules attached to the rule group. These rules identify the web requests that you want to
        /// allow, block, or count.
        public let rules: [AwsWafRuleGroupRulesDetails]?

        @inlinable
        public init(metricName: String? = nil, name: String? = nil, ruleGroupId: String? = nil, rules: [AwsWafRuleGroupRulesDetails]? = nil) {
            self.metricName = metricName
            self.name = name
            self.ruleGroupId = ruleGroupId
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.ruleGroupId, name: "ruleGroupId", parent: name, pattern: "\\S")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case name = "Name"
            case ruleGroupId = "RuleGroupId"
            case rules = "Rules"
        }
    }

    public struct AwsWafRuleGroupRulesActionDetails: AWSEncodableShape & AWSDecodableShape {
        /// The action that WAF should take on a web request when it matches the rule's statement.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct AwsWafRuleGroupRulesDetails: AWSEncodableShape & AWSDecodableShape {
        /// Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule.
        public let action: AwsWafRuleGroupRulesActionDetails?
        /// If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of Priority.
        public let priority: Int?
        /// The rule ID for a rule.
        public let ruleId: String?
        /// The type of rule.
        public let type: String?

        @inlinable
        public init(action: AwsWafRuleGroupRulesActionDetails? = nil, priority: Int? = nil, ruleId: String? = nil, type: String? = nil) {
            self.action = action
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case priority = "Priority"
            case ruleId = "RuleId"
            case type = "Type"
        }
    }

    public struct AwsWafRulePredicateListDetails: AWSEncodableShape & AWSDecodableShape {
        /// A unique identifier for a predicate in a rule, such as ByteMatchSetId or IPSetId.
        public let dataId: String?
        /// Specifies if you want WAF to allow, block, or count requests based on the settings in the  ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet,  RegexMatchSet, GeoMatchSet, or SizeConstraintSet.
        public let negated: Bool?
        /// The type of predicate in a rule, such as ByteMatch or IPSet.
        public let type: String?

        @inlinable
        public init(dataId: String? = nil, negated: Bool? = nil, type: String? = nil) {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.dataId, name: "dataId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dataId = "DataId"
            case negated = "Negated"
            case type = "Type"
        }
    }

    public struct AwsWafWebAclDetails: AWSEncodableShape & AWSDecodableShape {
        /// The action to perform if none of the rules contained in the web ACL match.
        public let defaultAction: String?
        /// A friendly name or description of the web ACL. You can't change the name of a web ACL  after you create it.
        public let name: String?
        /// An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule.
        public let rules: [AwsWafWebAclRule]?
        /// A unique identifier for a web ACL.
        public let webAclId: String?

        @inlinable
        public init(defaultAction: String? = nil, name: String? = nil, rules: [AwsWafWebAclRule]? = nil, webAclId: String? = nil) {
            self.defaultAction = defaultAction
            self.name = name
            self.rules = rules
            self.webAclId = webAclId
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultAction, name: "defaultAction", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.webAclId, name: "webAclId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "DefaultAction"
            case name = "Name"
            case rules = "Rules"
            case webAclId = "WebAclId"
        }
    }

    public struct AwsWafWebAclRule: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the action that CloudFront or WAF takes when a web request matches the conditions in the rule.
        public let action: WafAction?
        /// Rules to exclude from a rule group.
        public let excludedRules: [WafExcludedRule]?
        /// Use the OverrideAction to test your RuleGroup. Any rule in a RuleGroup can potentially block a request. If you set the OverrideAction to None, the RuleGroup blocks a request if any individual rule in the RuleGroup matches the request and is configured to block that request. However, if you first want to test the RuleGroup, set the OverrideAction to Count. The RuleGroup then overrides any block action specified by individual rules contained within the group. Instead of blocking matching requests, those requests are counted.  ActivatedRule|OverrideAction applies only when updating or adding a RuleGroup to a web ACL. In this case you don't use ActivatedRule Action. For all other update requests, ActivatedRule Action is used instead of ActivatedRule OverrideAction.
        public let overrideAction: WafOverrideAction?
        /// Specifies the order in which the rules in a web ACL are evaluated. Rules with a lower value for Priority are evaluated before rules with a higher value. The value must be a unique integer. If you add multiple rules to a web ACL, the values don't need to be consecutive.
        public let priority: Int?
        /// The identifier for a rule.
        public let ruleId: String?
        /// The rule type. Valid values: REGULAR | RATE_BASED | GROUP  The default is REGULAR.
        public let type: String?

        @inlinable
        public init(action: WafAction? = nil, excludedRules: [WafExcludedRule]? = nil, overrideAction: WafOverrideAction? = nil, priority: Int? = nil, ruleId: String? = nil, type: String? = nil) {
            self.action = action
            self.excludedRules = excludedRules
            self.overrideAction = overrideAction
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.excludedRules?.forEach {
                try $0.validate(name: "\(name).excludedRules[]")
            }
            try self.overrideAction?.validate(name: "\(name).overrideAction")
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case excludedRules = "ExcludedRules"
            case overrideAction = "OverrideAction"
            case priority = "Priority"
            case ruleId = "RuleId"
            case type = "Type"
        }
    }

    public struct AwsWafv2ActionAllowDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Defines custom handling for the web request. For information about customizing web requests and responses, see  Customizing web requests and responses in WAF in the WAF Developer Guide..
        public let customRequestHandling: AwsWafv2CustomRequestHandlingDetails?

        @inlinable
        public init(customRequestHandling: AwsWafv2CustomRequestHandlingDetails? = nil) {
            self.customRequestHandling = customRequestHandling
        }

        public func validate(name: String) throws {
            try self.customRequestHandling?.validate(name: "\(name).customRequestHandling")
        }

        private enum CodingKeys: String, CodingKey {
            case customRequestHandling = "CustomRequestHandling"
        }
    }

    public struct AwsWafv2ActionBlockDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Defines a custom response for the web request. For information, see  Customizing web requests and responses in WAF in the WAF Developer Guide..
        public let customResponse: AwsWafv2CustomResponseDetails?

        @inlinable
        public init(customResponse: AwsWafv2CustomResponseDetails? = nil) {
            self.customResponse = customResponse
        }

        public func validate(name: String) throws {
            try self.customResponse?.validate(name: "\(name).customResponse")
        }

        private enum CodingKeys: String, CodingKey {
            case customResponse = "CustomResponse"
        }
    }

    public struct AwsWafv2CustomHttpHeader: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the custom header.
        public let name: String?
        ///  The value of the custom header.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct AwsWafv2CustomRequestHandlingDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The HTTP headers to insert into the request.
        public let insertHeaders: [AwsWafv2CustomHttpHeader]?

        @inlinable
        public init(insertHeaders: [AwsWafv2CustomHttpHeader]? = nil) {
            self.insertHeaders = insertHeaders
        }

        public func validate(name: String) throws {
            try self.insertHeaders?.forEach {
                try $0.validate(name: "\(name).insertHeaders[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case insertHeaders = "InsertHeaders"
        }
    }

    public struct AwsWafv2CustomResponseDetails: AWSEncodableShape & AWSDecodableShape {
        ///  References the response body that you want WAF to return to the web request client. You can define a custom response for a rule action or a default web ACL action that is set to block.
        public let customResponseBodyKey: String?
        ///  The HTTP status code to return to the client. For a list of status codes that you can use in your custom responses, see  Supported status codes for custom response in the WAF Developer Guide.
        public let responseCode: Int?
        ///  The HTTP headers to use in the response.
        public let responseHeaders: [AwsWafv2CustomHttpHeader]?

        @inlinable
        public init(customResponseBodyKey: String? = nil, responseCode: Int? = nil, responseHeaders: [AwsWafv2CustomHttpHeader]? = nil) {
            self.customResponseBodyKey = customResponseBodyKey
            self.responseCode = responseCode
            self.responseHeaders = responseHeaders
        }

        public func validate(name: String) throws {
            try self.validate(self.customResponseBodyKey, name: "customResponseBodyKey", parent: name, pattern: "\\S")
            try self.responseHeaders?.forEach {
                try $0.validate(name: "\(name).responseHeaders[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customResponseBodyKey = "CustomResponseBodyKey"
            case responseCode = "ResponseCode"
            case responseHeaders = "ResponseHeaders"
        }
    }

    public struct AwsWafv2RuleGroupDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the entity.
        public let arn: String?
        ///  The web ACL capacity units (WCUs) required for this rule group.
        public let capacity: Int64?
        ///  A description of the rule group that helps with identification.
        public let description: String?
        ///  A unique identifier for the rule group.
        public let id: String?
        ///  The name of the rule group. You cannot change the name of a rule group after you create it.
        public let name: String?
        ///  The Rule statements used to identify the web requests that you want to allow, block, or count. Each rule includes one  top-level statement that WAF uses to identify matching web requests, and parameters that govern how  WAF handles them.
        public let rules: [AwsWafv2RulesDetails]?
        ///  Specifies whether the rule group is for an Amazon CloudFront distribution or for a regional application.  A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, an AppSync  GraphQL API, or an Amazon Cognito user pool.
        public let scope: String?
        ///  Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public let visibilityConfig: AwsWafv2VisibilityConfigDetails?

        @inlinable
        public init(arn: String? = nil, capacity: Int64? = nil, description: String? = nil, id: String? = nil, name: String? = nil, rules: [AwsWafv2RulesDetails]? = nil, scope: String? = nil, visibilityConfig: AwsWafv2VisibilityConfigDetails? = nil) {
            self.arn = arn
            self.capacity = capacity
            self.description = description
            self.id = id
            self.name = name
            self.rules = rules
            self.scope = scope
            self.visibilityConfig = visibilityConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.scope, name: "scope", parent: name, pattern: "\\S")
            try self.visibilityConfig?.validate(name: "\(name).visibilityConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacity = "Capacity"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case rules = "Rules"
            case scope = "Scope"
            case visibilityConfig = "VisibilityConfig"
        }
    }

    public struct AwsWafv2RulesActionCaptchaDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Defines custom handling for the web request, used when the CAPTCHA inspection determines that the request's token is valid and unexpired. For more information,  see Customizing web requests and responses in WAF in the WAF Developer Guide..
        public let customRequestHandling: AwsWafv2CustomRequestHandlingDetails?

        @inlinable
        public init(customRequestHandling: AwsWafv2CustomRequestHandlingDetails? = nil) {
            self.customRequestHandling = customRequestHandling
        }

        public func validate(name: String) throws {
            try self.customRequestHandling?.validate(name: "\(name).customRequestHandling")
        }

        private enum CodingKeys: String, CodingKey {
            case customRequestHandling = "CustomRequestHandling"
        }
    }

    public struct AwsWafv2RulesActionCountDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Defines custom handling for the web request. For more information,  see Customizing web requests and responses in WAF in the WAF Developer Guide..
        public let customRequestHandling: AwsWafv2CustomRequestHandlingDetails?

        @inlinable
        public init(customRequestHandling: AwsWafv2CustomRequestHandlingDetails? = nil) {
            self.customRequestHandling = customRequestHandling
        }

        public func validate(name: String) throws {
            try self.customRequestHandling?.validate(name: "\(name).customRequestHandling")
        }

        private enum CodingKeys: String, CodingKey {
            case customRequestHandling = "CustomRequestHandling"
        }
    }

    public struct AwsWafv2RulesActionDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Instructs WAF to allow the web request.
        public let allow: AwsWafv2ActionAllowDetails?
        ///  Instructs WAF to block the web request.
        public let block: AwsWafv2ActionBlockDetails?
        ///  Instructs WAF to run a CAPTCHA check against the web request.
        public let captcha: AwsWafv2RulesActionCaptchaDetails?
        ///  Instructs WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
        public let count: AwsWafv2RulesActionCountDetails?

        @inlinable
        public init(allow: AwsWafv2ActionAllowDetails? = nil, block: AwsWafv2ActionBlockDetails? = nil, captcha: AwsWafv2RulesActionCaptchaDetails? = nil, count: AwsWafv2RulesActionCountDetails? = nil) {
            self.allow = allow
            self.block = block
            self.captcha = captcha
            self.count = count
        }

        public func validate(name: String) throws {
            try self.allow?.validate(name: "\(name).allow")
            try self.block?.validate(name: "\(name).block")
            try self.captcha?.validate(name: "\(name).captcha")
            try self.count?.validate(name: "\(name).count")
        }

        private enum CodingKeys: String, CodingKey {
            case allow = "Allow"
            case block = "Block"
            case captcha = "Captcha"
            case count = "Count"
        }
    }

    public struct AwsWafv2RulesDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The action that WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting.
        public let action: AwsWafv2RulesActionDetails?
        ///  The name of the rule.
        public let name: String?
        ///  The action to use in the place of the action that results from the rule group evaluation.
        public let overrideAction: String?
        ///  If you define more than one Rule in a WebACL, WAF evaluates each request against the Rules in order based on the value of Priority.  WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.
        public let priority: Int?
        ///  Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public let visibilityConfig: AwsWafv2VisibilityConfigDetails?

        @inlinable
        public init(action: AwsWafv2RulesActionDetails? = nil, name: String? = nil, overrideAction: String? = nil, priority: Int? = nil, visibilityConfig: AwsWafv2VisibilityConfigDetails? = nil) {
            self.action = action
            self.name = name
            self.overrideAction = overrideAction
            self.priority = priority
            self.visibilityConfig = visibilityConfig
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.overrideAction, name: "overrideAction", parent: name, pattern: "\\S")
            try self.visibilityConfig?.validate(name: "\(name).visibilityConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case name = "Name"
            case overrideAction = "OverrideAction"
            case priority = "Priority"
            case visibilityConfig = "VisibilityConfig"
        }
    }

    public struct AwsWafv2VisibilityConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  A boolean indicating whether the associated resource sends metrics to Amazon CloudWatch. For the list of available  metrics, see WAF metrics and dimensions in the WAF Developer Guide.
        public let cloudWatchMetricsEnabled: Bool?
        ///  A name of the Amazon CloudWatch metric.
        public let metricName: String?
        ///  A boolean indicating whether WAF should store a sampling of the web requests that match the rules.  You can view the sampled requests through the WAF console.
        public let sampledRequestsEnabled: Bool?

        @inlinable
        public init(cloudWatchMetricsEnabled: Bool? = nil, metricName: String? = nil, sampledRequestsEnabled: Bool? = nil) {
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.metricName = metricName
            self.sampledRequestsEnabled = sampledRequestsEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.metricName, name: "metricName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
            case metricName = "MetricName"
            case sampledRequestsEnabled = "SampledRequestsEnabled"
        }
    }

    public struct AwsWafv2WebAclActionDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Specifies that WAF should allow requests by default.
        public let allow: AwsWafv2ActionAllowDetails?
        ///  Specifies that WAF should block requests by default.
        public let block: AwsWafv2ActionBlockDetails?

        @inlinable
        public init(allow: AwsWafv2ActionAllowDetails? = nil, block: AwsWafv2ActionBlockDetails? = nil) {
            self.allow = allow
            self.block = block
        }

        public func validate(name: String) throws {
            try self.allow?.validate(name: "\(name).allow")
            try self.block?.validate(name: "\(name).block")
        }

        private enum CodingKeys: String, CodingKey {
            case allow = "Allow"
            case block = "Block"
        }
    }

    public struct AwsWafv2WebAclCaptchaConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Determines how long a CAPTCHA timestamp in the token remains valid after the client successfully solves a CAPTCHA puzzle.
        public let immunityTimeProperty: AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails?

        @inlinable
        public init(immunityTimeProperty: AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails? = nil) {
            self.immunityTimeProperty = immunityTimeProperty
        }

        private enum CodingKeys: String, CodingKey {
            case immunityTimeProperty = "ImmunityTimeProperty"
        }
    }

    public struct AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by WAF.
        public let immunityTime: Int64?

        @inlinable
        public init(immunityTime: Int64? = nil) {
            self.immunityTime = immunityTime
        }

        private enum CodingKeys: String, CodingKey {
            case immunityTime = "ImmunityTime"
        }
    }

    public struct AwsWafv2WebAclDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.
        public let arn: String?
        ///  The web ACL capacity units (WCUs) currently being used by this web ACL.
        public let capacity: Int64?
        ///  Specifies how WAF should handle CAPTCHA evaluations for rules that don't have their own  CaptchaConfig settings.
        public let captchaConfig: AwsWafv2WebAclCaptchaConfigDetails?
        ///  The action to perform if none of the Rules contained in the web ACL match.
        public let defaultAction: AwsWafv2WebAclActionDetails?
        ///  A description of the web ACL that helps with identification.
        public let description: String?
        ///  A unique identifier for the web ACL.
        public let id: String?
        ///  Indicates whether this web ACL is managed by Firewall Manager.
        public let managedbyFirewallManager: Bool?
        ///  The name of the web ACL.
        public let name: String?
        ///  The Rule statements used to identify the web requests that you want to allow, block, or count. Each rule includes one  top-level statement that WAF uses to identify matching web requests, and parameters that govern how  WAF handles them.
        public let rules: [AwsWafv2RulesDetails]?
        ///  Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public let visibilityConfig: AwsWafv2VisibilityConfigDetails?

        @inlinable
        public init(arn: String? = nil, capacity: Int64? = nil, captchaConfig: AwsWafv2WebAclCaptchaConfigDetails? = nil, defaultAction: AwsWafv2WebAclActionDetails? = nil, description: String? = nil, id: String? = nil, managedbyFirewallManager: Bool? = nil, name: String? = nil, rules: [AwsWafv2RulesDetails]? = nil, visibilityConfig: AwsWafv2VisibilityConfigDetails? = nil) {
            self.arn = arn
            self.capacity = capacity
            self.captchaConfig = captchaConfig
            self.defaultAction = defaultAction
            self.description = description
            self.id = id
            self.managedbyFirewallManager = managedbyFirewallManager
            self.name = name
            self.rules = rules
            self.visibilityConfig = visibilityConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.defaultAction?.validate(name: "\(name).defaultAction")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.visibilityConfig?.validate(name: "\(name).visibilityConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case capacity = "Capacity"
            case captchaConfig = "CaptchaConfig"
            case defaultAction = "DefaultAction"
            case description = "Description"
            case id = "Id"
            case managedbyFirewallManager = "ManagedbyFirewallManager"
            case name = "Name"
            case rules = "Rules"
            case visibilityConfig = "VisibilityConfig"
        }
    }

    public struct AwsXrayEncryptionConfigDetails: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the KMS key that is used for encryption. Provided if Type is KMS.
        public let keyId: String?
        /// The current status of the encryption configuration. Valid values are ACTIVE or UPDATING. When Status is equal to UPDATING, X-Ray might use both the old and new encryption.
        public let status: String?
        /// The type of encryption. KMS indicates that the encryption uses KMS keys. NONE indicates the default encryption.
        public let type: String?

        @inlinable
        public init(keyId: String? = nil, status: String? = nil, type: String? = nil) {
            self.keyId = keyId
            self.status = status
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.keyId, name: "keyId", parent: name, pattern: "\\S")
            try self.validate(self.status, name: "status", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case keyId = "KeyId"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct BatchDeleteAutomationRulesRequest: AWSEncodableShape {
        ///  A list of Amazon Resource Names (ARNs) for the rules that are to be deleted.
        public let automationRulesArns: [String]?

        @inlinable
        public init(automationRulesArns: [String]? = nil) {
            self.automationRulesArns = automationRulesArns
        }

        public func validate(name: String) throws {
            try self.automationRulesArns?.forEach {
                try validate($0, name: "automationRulesArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.automationRulesArns, name: "automationRulesArns", parent: name, max: 100)
            try self.validate(self.automationRulesArns, name: "automationRulesArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case automationRulesArns = "AutomationRulesArns"
        }
    }

    public struct BatchDeleteAutomationRulesResponse: AWSDecodableShape {
        ///  A list of properly processed rule ARNs.
        public let processedAutomationRules: [String]?
        ///  A list of objects containing RuleArn, ErrorCode, and ErrorMessage. This parameter  tells you which automation rules the request didn't delete and why.
        public let unprocessedAutomationRules: [UnprocessedAutomationRule]?

        @inlinable
        public init(processedAutomationRules: [String]? = nil, unprocessedAutomationRules: [UnprocessedAutomationRule]? = nil) {
            self.processedAutomationRules = processedAutomationRules
            self.unprocessedAutomationRules = unprocessedAutomationRules
        }

        private enum CodingKeys: String, CodingKey {
            case processedAutomationRules = "ProcessedAutomationRules"
            case unprocessedAutomationRules = "UnprocessedAutomationRules"
        }
    }

    public struct BatchDisableStandardsRequest: AWSEncodableShape {
        /// The ARNs of the standards subscriptions to disable.
        public let standardsSubscriptionArns: [String]?

        @inlinable
        public init(standardsSubscriptionArns: [String]? = nil) {
            self.standardsSubscriptionArns = standardsSubscriptionArns
        }

        public func validate(name: String) throws {
            try self.standardsSubscriptionArns?.forEach {
                try validate($0, name: "standardsSubscriptionArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, max: 25)
            try self.validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptionArns = "StandardsSubscriptionArns"
        }
    }

    public struct BatchDisableStandardsResponse: AWSDecodableShape {
        /// The details of the standards subscriptions that were disabled.
        public let standardsSubscriptions: [StandardsSubscription]?

        @inlinable
        public init(standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct BatchEnableStandardsRequest: AWSEncodableShape {
        /// The list of standards checks to enable.
        public let standardsSubscriptionRequests: [StandardsSubscriptionRequest]?

        @inlinable
        public init(standardsSubscriptionRequests: [StandardsSubscriptionRequest]? = nil) {
            self.standardsSubscriptionRequests = standardsSubscriptionRequests
        }

        public func validate(name: String) throws {
            try self.standardsSubscriptionRequests?.forEach {
                try $0.validate(name: "\(name).standardsSubscriptionRequests[]")
            }
            try self.validate(self.standardsSubscriptionRequests, name: "standardsSubscriptionRequests", parent: name, max: 25)
            try self.validate(self.standardsSubscriptionRequests, name: "standardsSubscriptionRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptionRequests = "StandardsSubscriptionRequests"
        }
    }

    public struct BatchEnableStandardsResponse: AWSDecodableShape {
        /// The details of the standards subscriptions that were enabled.
        public let standardsSubscriptions: [StandardsSubscription]?

        @inlinable
        public init(standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct BatchGetAutomationRulesRequest: AWSEncodableShape {
        ///  A list of rule ARNs to get details for.
        public let automationRulesArns: [String]?

        @inlinable
        public init(automationRulesArns: [String]? = nil) {
            self.automationRulesArns = automationRulesArns
        }

        public func validate(name: String) throws {
            try self.automationRulesArns?.forEach {
                try validate($0, name: "automationRulesArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.automationRulesArns, name: "automationRulesArns", parent: name, max: 100)
            try self.validate(self.automationRulesArns, name: "automationRulesArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case automationRulesArns = "AutomationRulesArns"
        }
    }

    public struct BatchGetAutomationRulesResponse: AWSDecodableShape {
        ///  A list of rule details for the provided rule ARNs.
        public let rules: [AutomationRulesConfig]?
        ///  A list of objects containing RuleArn, ErrorCode, and ErrorMessage. This parameter  tells you which automation rules the request didn't retrieve and why.
        public let unprocessedAutomationRules: [UnprocessedAutomationRule]?

        @inlinable
        public init(rules: [AutomationRulesConfig]? = nil, unprocessedAutomationRules: [UnprocessedAutomationRule]? = nil) {
            self.rules = rules
            self.unprocessedAutomationRules = unprocessedAutomationRules
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
            case unprocessedAutomationRules = "UnprocessedAutomationRules"
        }
    }

    public struct BatchGetConfigurationPolicyAssociationsRequest: AWSEncodableShape {
        ///  Specifies one or more target account IDs, organizational unit (OU) IDs, or the root ID to retrieve associations for.
        public let configurationPolicyAssociationIdentifiers: [ConfigurationPolicyAssociation]?

        @inlinable
        public init(configurationPolicyAssociationIdentifiers: [ConfigurationPolicyAssociation]? = nil) {
            self.configurationPolicyAssociationIdentifiers = configurationPolicyAssociationIdentifiers
        }

        public func validate(name: String) throws {
            try self.configurationPolicyAssociationIdentifiers?.forEach {
                try $0.validate(name: "\(name).configurationPolicyAssociationIdentifiers[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurationPolicyAssociationIdentifiers = "ConfigurationPolicyAssociationIdentifiers"
        }
    }

    public struct BatchGetConfigurationPolicyAssociationsResponse: AWSDecodableShape {
        ///  Describes associations for the target accounts, OUs, or the root.
        public let configurationPolicyAssociations: [ConfigurationPolicyAssociationSummary]?
        ///  An array of configuration policy associations, one for each configuration policy association identifier, that was  specified in the request but couldnâ€™t be processed due to an error.
        public let unprocessedConfigurationPolicyAssociations: [UnprocessedConfigurationPolicyAssociation]?

        @inlinable
        public init(configurationPolicyAssociations: [ConfigurationPolicyAssociationSummary]? = nil, unprocessedConfigurationPolicyAssociations: [UnprocessedConfigurationPolicyAssociation]? = nil) {
            self.configurationPolicyAssociations = configurationPolicyAssociations
            self.unprocessedConfigurationPolicyAssociations = unprocessedConfigurationPolicyAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case configurationPolicyAssociations = "ConfigurationPolicyAssociations"
            case unprocessedConfigurationPolicyAssociations = "UnprocessedConfigurationPolicyAssociations"
        }
    }

    public struct BatchGetSecurityControlsRequest: AWSEncodableShape {
        ///  A list of security controls (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters). The security control ID or Amazon Resource Name (ARN) is the same across standards.
        public let securityControlIds: [String]?

        @inlinable
        public init(securityControlIds: [String]? = nil) {
            self.securityControlIds = securityControlIds
        }

        public func validate(name: String) throws {
            try self.securityControlIds?.forEach {
                try validate($0, name: "securityControlIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case securityControlIds = "SecurityControlIds"
        }
    }

    public struct BatchGetSecurityControlsResponse: AWSDecodableShape {
        ///  An array that returns the identifier, Amazon Resource Name (ARN), and other details about a security control.  The same information is returned whether the request includes SecurityControlId or SecurityControlArn.
        public let securityControls: [SecurityControl]?
        ///  A security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) for which  details cannot be returned.
        public let unprocessedIds: [UnprocessedSecurityControl]?

        @inlinable
        public init(securityControls: [SecurityControl]? = nil, unprocessedIds: [UnprocessedSecurityControl]? = nil) {
            self.securityControls = securityControls
            self.unprocessedIds = unprocessedIds
        }

        private enum CodingKeys: String, CodingKey {
            case securityControls = "SecurityControls"
            case unprocessedIds = "UnprocessedIds"
        }
    }

    public struct BatchGetStandardsControlAssociationsRequest: AWSEncodableShape {
        ///  An array with one or more objects that includes a security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) and the Amazon Resource Name (ARN) of a standard.  This field is used to query the enablement status of a control in a specified standard. The security control ID or ARN is the same across standards.
        public let standardsControlAssociationIds: [StandardsControlAssociationId]?

        @inlinable
        public init(standardsControlAssociationIds: [StandardsControlAssociationId]? = nil) {
            self.standardsControlAssociationIds = standardsControlAssociationIds
        }

        public func validate(name: String) throws {
            try self.standardsControlAssociationIds?.forEach {
                try $0.validate(name: "\(name).standardsControlAssociationIds[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case standardsControlAssociationIds = "StandardsControlAssociationIds"
        }
    }

    public struct BatchGetStandardsControlAssociationsResponse: AWSDecodableShape {
        /// Provides the enablement status of a security control in a specified standard and other details for the control in relation to  the specified standard.
        public let standardsControlAssociationDetails: [StandardsControlAssociationDetail]?
        ///  A security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) whose enablement  status in a specified standard cannot be returned.
        public let unprocessedAssociations: [UnprocessedStandardsControlAssociation]?

        @inlinable
        public init(standardsControlAssociationDetails: [StandardsControlAssociationDetail]? = nil, unprocessedAssociations: [UnprocessedStandardsControlAssociation]? = nil) {
            self.standardsControlAssociationDetails = standardsControlAssociationDetails
            self.unprocessedAssociations = unprocessedAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case standardsControlAssociationDetails = "StandardsControlAssociationDetails"
            case unprocessedAssociations = "UnprocessedAssociations"
        }
    }

    public struct BatchImportFindingsRequest: AWSEncodableShape {
        /// A list of findings to import. To successfully import a finding, it must follow the Amazon Web Services Security Finding Format. Maximum of 100 findings per request.
        public let findings: [AwsSecurityFinding]?

        @inlinable
        public init(findings: [AwsSecurityFinding]? = nil) {
            self.findings = findings
        }

        public func validate(name: String) throws {
            try self.findings?.forEach {
                try $0.validate(name: "\(name).findings[]")
            }
            try self.validate(self.findings, name: "findings", parent: name, max: 100)
            try self.validate(self.findings, name: "findings", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "Findings"
        }
    }

    public struct BatchImportFindingsResponse: AWSDecodableShape {
        /// The number of findings that failed to import.
        public let failedCount: Int?
        /// The list of findings that failed to import.
        public let failedFindings: [ImportFindingsError]?
        /// The number of findings that were successfully imported.
        public let successCount: Int?

        @inlinable
        public init(failedCount: Int? = nil, failedFindings: [ImportFindingsError]? = nil, successCount: Int? = nil) {
            self.failedCount = failedCount
            self.failedFindings = failedFindings
            self.successCount = successCount
        }

        private enum CodingKeys: String, CodingKey {
            case failedCount = "FailedCount"
            case failedFindings = "FailedFindings"
            case successCount = "SuccessCount"
        }
    }

    public struct BatchUpdateAutomationRulesRequest: AWSEncodableShape {
        ///  An array of ARNs for the rules that are to be updated. Optionally, you can also include  RuleStatus and RuleOrder.
        public let updateAutomationRulesRequestItems: [UpdateAutomationRulesRequestItem]?

        @inlinable
        public init(updateAutomationRulesRequestItems: [UpdateAutomationRulesRequestItem]? = nil) {
            self.updateAutomationRulesRequestItems = updateAutomationRulesRequestItems
        }

        public func validate(name: String) throws {
            try self.updateAutomationRulesRequestItems?.forEach {
                try $0.validate(name: "\(name).updateAutomationRulesRequestItems[]")
            }
            try self.validate(self.updateAutomationRulesRequestItems, name: "updateAutomationRulesRequestItems", parent: name, max: 100)
            try self.validate(self.updateAutomationRulesRequestItems, name: "updateAutomationRulesRequestItems", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case updateAutomationRulesRequestItems = "UpdateAutomationRulesRequestItems"
        }
    }

    public struct BatchUpdateAutomationRulesResponse: AWSDecodableShape {
        ///  A list of properly processed rule ARNs.
        public let processedAutomationRules: [String]?
        ///  A list of objects containing RuleArn, ErrorCode, and ErrorMessage. This parameter  tells you which automation rules the request didn't update and why.
        public let unprocessedAutomationRules: [UnprocessedAutomationRule]?

        @inlinable
        public init(processedAutomationRules: [String]? = nil, unprocessedAutomationRules: [UnprocessedAutomationRule]? = nil) {
            self.processedAutomationRules = processedAutomationRules
            self.unprocessedAutomationRules = unprocessedAutomationRules
        }

        private enum CodingKeys: String, CodingKey {
            case processedAutomationRules = "ProcessedAutomationRules"
            case unprocessedAutomationRules = "UnprocessedAutomationRules"
        }
    }

    public struct BatchUpdateFindingsRequest: AWSEncodableShape {
        /// The updated value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: Int?
        /// The updated value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: Int?
        /// The list of findings to update. BatchUpdateFindings can be used to update up to 100 findings at a time. For each finding, the list provides the finding identifier and the ARN of the finding provider.
        public let findingIdentifiers: [AwsSecurityFindingIdentifier]?
        public let note: NoteUpdate?
        /// A list of findings that are related to the updated findings.
        public let relatedFindings: [RelatedFinding]?
        /// Used to update the finding severity.
        public let severity: SeverityUpdate?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are as follows.   Software and Configuration Checks   TTPs   Effects   Unusual Behaviors   Sensitive Data Identifications
        public let types: [String]?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
        public let userDefinedFields: [String: String]?
        /// Indicates the veracity of a finding. The available values for VerificationState are  as follows.    UNKNOWN â€“ The default disposition of a security finding    TRUE_POSITIVE â€“ The security finding is confirmed    FALSE_POSITIVE â€“ The security finding was determined to be a false alarm    BENIGN_POSITIVE â€“ A special case of TRUE_POSITIVE where the finding doesn't pose any threat, is expected, or both
        public let verificationState: VerificationState?
        /// Used to update the workflow status of a finding. The workflow status indicates the progress of the investigation into the finding.
        public let workflow: WorkflowUpdate?

        @inlinable
        public init(confidence: Int? = nil, criticality: Int? = nil, findingIdentifiers: [AwsSecurityFindingIdentifier]? = nil, note: NoteUpdate? = nil, relatedFindings: [RelatedFinding]? = nil, severity: SeverityUpdate? = nil, types: [String]? = nil, userDefinedFields: [String: String]? = nil, verificationState: VerificationState? = nil, workflow: WorkflowUpdate? = nil) {
            self.confidence = confidence
            self.criticality = criticality
            self.findingIdentifiers = findingIdentifiers
            self.note = note
            self.relatedFindings = relatedFindings
            self.severity = severity
            self.types = types
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflow = workflow
        }

        public func validate(name: String) throws {
            try self.validate(self.confidence, name: "confidence", parent: name, max: 100)
            try self.validate(self.confidence, name: "confidence", parent: name, min: 0)
            try self.validate(self.criticality, name: "criticality", parent: name, max: 100)
            try self.validate(self.criticality, name: "criticality", parent: name, min: 0)
            try self.findingIdentifiers?.forEach {
                try $0.validate(name: "\(name).findingIdentifiers[]")
            }
            try self.note?.validate(name: "\(name).note")
            try self.relatedFindings?.forEach {
                try $0.validate(name: "\(name).relatedFindings[]")
            }
            try self.severity?.validate(name: "\(name).severity")
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
            try self.userDefinedFields?.forEach {
                try validate($0.key, name: "userDefinedFields.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "userDefinedFields[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case criticality = "Criticality"
            case findingIdentifiers = "FindingIdentifiers"
            case note = "Note"
            case relatedFindings = "RelatedFindings"
            case severity = "Severity"
            case types = "Types"
            case userDefinedFields = "UserDefinedFields"
            case verificationState = "VerificationState"
            case workflow = "Workflow"
        }
    }

    public struct BatchUpdateFindingsResponse: AWSDecodableShape {
        /// The list of findings that were updated successfully.
        public let processedFindings: [AwsSecurityFindingIdentifier]?
        /// The list of findings that were not updated.
        public let unprocessedFindings: [BatchUpdateFindingsUnprocessedFinding]?

        @inlinable
        public init(processedFindings: [AwsSecurityFindingIdentifier]? = nil, unprocessedFindings: [BatchUpdateFindingsUnprocessedFinding]? = nil) {
            self.processedFindings = processedFindings
            self.unprocessedFindings = unprocessedFindings
        }

        private enum CodingKeys: String, CodingKey {
            case processedFindings = "ProcessedFindings"
            case unprocessedFindings = "UnprocessedFindings"
        }
    }

    public struct BatchUpdateFindingsUnprocessedFinding: AWSDecodableShape {
        /// The code associated with the error. Possible values are:    ConcurrentUpdateError - Another request attempted to update the finding while this request was being processed.
        /// This error may also occur if you call  BatchUpdateFindings
        /// and  BatchImportFindings at the same time.    DuplicatedFindingIdentifier - The request included two or more findings with the same FindingIdentifier.    FindingNotFound - The FindingIdentifier included in the request did not match an existing finding.    FindingSizeExceeded - The finding size was greater than the permissible value of 240 KB.    InternalFailure - An internal service failure occurred when updating the finding.    InvalidInput - The finding update contained an invalid value that did not satisfy the Amazon Web Services Security Finding Format syntax.
        public let errorCode: String?
        /// The message associated with the error. Possible values are:    Concurrent finding updates detected     Finding Identifier is duplicated     Finding Not Found     Finding size exceeded 240 KB     Internal service failure     Invalid Input
        public let errorMessage: String?
        /// The identifier of the finding that was not updated.
        public let findingIdentifier: AwsSecurityFindingIdentifier?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil, findingIdentifier: AwsSecurityFindingIdentifier? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingIdentifier = findingIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case findingIdentifier = "FindingIdentifier"
        }
    }

    public struct BatchUpdateStandardsControlAssociationsRequest: AWSEncodableShape {
        ///  Updates the enablement status of a security control in a specified standard.   Calls to this operation return a RESOURCE_NOT_FOUND_EXCEPTION error when the standard subscription for the control has StandardsControlsUpdatable value NOT_READY_FOR_UPDATES.
        public let standardsControlAssociationUpdates: [StandardsControlAssociationUpdate]?

        @inlinable
        public init(standardsControlAssociationUpdates: [StandardsControlAssociationUpdate]? = nil) {
            self.standardsControlAssociationUpdates = standardsControlAssociationUpdates
        }

        public func validate(name: String) throws {
            try self.standardsControlAssociationUpdates?.forEach {
                try $0.validate(name: "\(name).standardsControlAssociationUpdates[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case standardsControlAssociationUpdates = "StandardsControlAssociationUpdates"
        }
    }

    public struct BatchUpdateStandardsControlAssociationsResponse: AWSDecodableShape {
        ///  A security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) whose enablement status in a specified standard couldn't be updated.
        public let unprocessedAssociationUpdates: [UnprocessedStandardsControlAssociationUpdate]?

        @inlinable
        public init(unprocessedAssociationUpdates: [UnprocessedStandardsControlAssociationUpdate]? = nil) {
            self.unprocessedAssociationUpdates = unprocessedAssociationUpdates
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAssociationUpdates = "UnprocessedAssociationUpdates"
        }
    }

    public struct BooleanConfigurationOptions: AWSDecodableShape {
        ///  The Security Hub default value for a boolean parameter.
        public let defaultValue: Bool?

        @inlinable
        public init(defaultValue: Bool? = nil) {
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
        }
    }

    public struct BooleanFilter: AWSEncodableShape & AWSDecodableShape {
        /// The value of the boolean.
        public let value: Bool?

        @inlinable
        public init(value: Bool? = nil) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct Cell: AWSEncodableShape & AWSDecodableShape {
        /// For a Microsoft Excel workbook, provides the location of the cell, as an absolute cell reference, that contains the data. For example, Sheet2!C5 for cell C5 on Sheet2.
        public let cellReference: String?
        /// The column number of the column that contains the data. For a Microsoft Excel workbook, the column number corresponds to the alphabetical column identifiers. For example, a value of 1 for Column corresponds to the A column in the workbook.
        public let column: Int64?
        /// The name of the column that contains the data.
        public let columnName: String?
        /// The row number of the row that contains the data.
        public let row: Int64?

        @inlinable
        public init(cellReference: String? = nil, column: Int64? = nil, columnName: String? = nil, row: Int64? = nil) {
            self.cellReference = cellReference
            self.column = column
            self.columnName = columnName
            self.row = row
        }

        public func validate(name: String) throws {
            try self.validate(self.cellReference, name: "cellReference", parent: name, pattern: "\\S")
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cellReference = "CellReference"
            case column = "Column"
            case columnName = "ColumnName"
            case row = "Row"
        }
    }

    public struct CidrBlockAssociation: AWSEncodableShape & AWSDecodableShape {
        /// The association ID for the IPv4 CIDR block.
        public let associationId: String?
        /// The IPv4 CIDR block.
        public let cidrBlock: String?
        /// Information about the state of the IPv4 CIDR block.
        public let cidrBlockState: String?

        @inlinable
        public init(associationId: String? = nil, cidrBlock: String? = nil, cidrBlockState: String? = nil) {
            self.associationId = associationId
            self.cidrBlock = cidrBlock
            self.cidrBlockState = cidrBlockState
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, pattern: "\\S")
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "\\S")
            try self.validate(self.cidrBlockState, name: "cidrBlockState", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
            case cidrBlock = "CidrBlock"
            case cidrBlockState = "CidrBlockState"
        }
    }

    public struct City: AWSEncodableShape & AWSDecodableShape {
        /// The name of the city.
        public let cityName: String?

        @inlinable
        public init(cityName: String? = nil) {
            self.cityName = cityName
        }

        public func validate(name: String) throws {
            try self.validate(self.cityName, name: "cityName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cityName = "CityName"
        }
    }

    public struct ClassificationResult: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether there are additional occurrences of sensitive data that are not included in the finding. This occurs when the number of occurrences exceeds the maximum that can be included.
        public let additionalOccurrences: Bool?
        /// Provides details about sensitive data that was identified based on customer-defined configuration.
        public let customDataIdentifiers: CustomDataIdentifiersResult?
        /// The type of content that the finding applies to.
        public let mimeType: String?
        /// Provides details about sensitive data that was identified based on built-in configuration.
        public let sensitiveData: [SensitiveDataResult]?
        /// The total size in bytes of the affected data.
        public let sizeClassified: Int64?
        /// The current status of the sensitive data detection.
        public let status: ClassificationStatus?

        @inlinable
        public init(additionalOccurrences: Bool? = nil, customDataIdentifiers: CustomDataIdentifiersResult? = nil, mimeType: String? = nil, sensitiveData: [SensitiveDataResult]? = nil, sizeClassified: Int64? = nil, status: ClassificationStatus? = nil) {
            self.additionalOccurrences = additionalOccurrences
            self.customDataIdentifiers = customDataIdentifiers
            self.mimeType = mimeType
            self.sensitiveData = sensitiveData
            self.sizeClassified = sizeClassified
            self.status = status
        }

        public func validate(name: String) throws {
            try self.customDataIdentifiers?.validate(name: "\(name).customDataIdentifiers")
            try self.validate(self.mimeType, name: "mimeType", parent: name, pattern: "\\S")
            try self.sensitiveData?.forEach {
                try $0.validate(name: "\(name).sensitiveData[]")
            }
            try self.status?.validate(name: "\(name).status")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOccurrences = "AdditionalOccurrences"
            case customDataIdentifiers = "CustomDataIdentifiers"
            case mimeType = "MimeType"
            case sensitiveData = "SensitiveData"
            case sizeClassified = "SizeClassified"
            case status = "Status"
        }
    }

    public struct ClassificationStatus: AWSEncodableShape & AWSDecodableShape {
        /// The code that represents the status of the sensitive data detection.
        public let code: String?
        /// A longer description of the current status of the sensitive data detection.
        public let reason: String?

        @inlinable
        public init(code: String? = nil, reason: String? = nil) {
            self.code = code
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, pattern: "\\S")
            try self.validate(self.reason, name: "reason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case reason = "Reason"
        }
    }

    public struct CloudWatchLogsLogGroupArnConfigDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The ARN of the CloudWatch Logs log group that RouteÂ 53 is publishing logs to.
        public let cloudWatchLogsLogGroupArn: String?
        ///  The ID of the hosted zone that CloudWatch Logs is logging queries for.
        public let hostedZoneId: String?
        ///  The ID for a DNS query logging configuration.
        public let id: String?

        @inlinable
        public init(cloudWatchLogsLogGroupArn: String? = nil, hostedZoneId: String? = nil, id: String? = nil) {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.hostedZoneId = hostedZoneId
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, pattern: "\\S")
            try self.validate(self.hostedZoneId, name: "hostedZoneId", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
            case hostedZoneId = "HostedZoneId"
            case id = "Id"
        }
    }

    public struct CodeVulnerabilitiesFilePath: AWSEncodableShape & AWSDecodableShape {
        ///  	The line number of the last line of code in which the vulnerability is located.
        public let endLine: Int?
        ///  The name of the file in which the code vulnerability is located.
        public let fileName: String?
        ///  The file path to the code in which the vulnerability is located.
        public let filePath: String?
        ///  The line number of the first line of code in which the vulnerability is located.
        public let startLine: Int?

        @inlinable
        public init(endLine: Int? = nil, fileName: String? = nil, filePath: String? = nil, startLine: Int? = nil) {
            self.endLine = endLine
            self.fileName = fileName
            self.filePath = filePath
            self.startLine = startLine
        }

        public func validate(name: String) throws {
            try self.validate(self.fileName, name: "fileName", parent: name, pattern: "\\S")
            try self.validate(self.filePath, name: "filePath", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case endLine = "EndLine"
            case fileName = "FileName"
            case filePath = "FilePath"
            case startLine = "StartLine"
        }
    }

    public struct Compliance: AWSEncodableShape & AWSDecodableShape {
        /// Typically provides an array of enabled security standards in which a security control is currently enabled.
        public let associatedStandards: [AssociatedStandard]?
        /// Typically provides the industry or regulatory framework requirements that are related to a control. The check for that control is aligned with these requirements. Array Members: Maximum number of 32 items.
        public let relatedRequirements: [String]?
        ///  Typically provides the unique identifier of a control across standards. For Security Hub controls, this field consists of an  Amazon Web Services service and a unique number, such as APIGateway.5.
        public let securityControlId: String?
        ///  Typically an object that includes security control parameter names and values.
        public let securityControlParameters: [SecurityControlParameter]?
        /// Typically summarizes the result of a control check. For Security Hub controls, valid values for Status are as follows.      PASSED - Standards check passed for all evaluated resources.    WARNING - Some information is missing or this check is not supported for your configuration.    FAILED - Standards check failed for at least one evaluated resource.    NOT_AVAILABLE - Check could not be performed due to a service outage, API error, or because the result of the Config evaluation was NOT_APPLICABLE. If the Config evaluation result was NOT_APPLICABLE for a Security Hub control, Security Hub automatically archives the finding after 3 days.
        public let status: ComplianceStatus?
        /// Typically used to provide a list of reasons for the value of Status.
        public let statusReasons: [StatusReason]?

        @inlinable
        public init(associatedStandards: [AssociatedStandard]? = nil, relatedRequirements: [String]? = nil, securityControlId: String? = nil, securityControlParameters: [SecurityControlParameter]? = nil, status: ComplianceStatus? = nil, statusReasons: [StatusReason]? = nil) {
            self.associatedStandards = associatedStandards
            self.relatedRequirements = relatedRequirements
            self.securityControlId = securityControlId
            self.securityControlParameters = securityControlParameters
            self.status = status
            self.statusReasons = statusReasons
        }

        public func validate(name: String) throws {
            try self.associatedStandards?.forEach {
                try $0.validate(name: "\(name).associatedStandards[]")
            }
            try self.relatedRequirements?.forEach {
                try validate($0, name: "relatedRequirements[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.securityControlId, name: "securityControlId", parent: name, pattern: "\\S")
            try self.securityControlParameters?.forEach {
                try $0.validate(name: "\(name).securityControlParameters[]")
            }
            try self.statusReasons?.forEach {
                try $0.validate(name: "\(name).statusReasons[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case associatedStandards = "AssociatedStandards"
            case relatedRequirements = "RelatedRequirements"
            case securityControlId = "SecurityControlId"
            case securityControlParameters = "SecurityControlParameters"
            case status = "Status"
            case statusReasons = "StatusReasons"
        }
    }

    public struct ConfigurationPolicyAssociation: AWSEncodableShape & AWSDecodableShape {
        ///  The target account, organizational unit, or the root.
        public let target: Target?

        @inlinable
        public init(target: Target? = nil) {
            self.target = target
        }

        public func validate(name: String) throws {
            try self.target?.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case target = "Target"
        }
    }

    public struct ConfigurationPolicyAssociationSummary: AWSDecodableShape {
        ///  The current status of the association between the specified target and the configuration.
        public let associationStatus: ConfigurationPolicyAssociationStatus?
        ///  The explanation for a FAILED value for AssociationStatus.
        public let associationStatusMessage: String?
        ///  Indicates whether the association between the specified target and the configuration was directly applied by the  Security Hub delegated administrator or inherited from a parent.
        public let associationType: AssociationType?
        ///  The universally unique identifier (UUID) of the configuration policy.
        public let configurationPolicyId: String?
        ///  The identifier of the target account, organizational unit, or the root.
        public let targetId: String?
        ///  Specifies whether the target is an Amazon Web Services account, organizational unit, or the root.
        public let targetType: TargetType?
        ///  The date and time, in UTC and ISO 8601 format, that the configuration policy association was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(associationStatus: ConfigurationPolicyAssociationStatus? = nil, associationStatusMessage: String? = nil, associationType: AssociationType? = nil, configurationPolicyId: String? = nil, targetId: String? = nil, targetType: TargetType? = nil, updatedAt: Date? = nil) {
            self.associationStatus = associationStatus
            self.associationStatusMessage = associationStatusMessage
            self.associationType = associationType
            self.configurationPolicyId = configurationPolicyId
            self.targetId = targetId
            self.targetType = targetType
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case associationStatus = "AssociationStatus"
            case associationStatusMessage = "AssociationStatusMessage"
            case associationType = "AssociationType"
            case configurationPolicyId = "ConfigurationPolicyId"
            case targetId = "TargetId"
            case targetType = "TargetType"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ConfigurationPolicySummary: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the configuration policy.
        public let arn: String?
        ///  The description of the configuration policy.
        public let description: String?
        ///  The universally unique identifier (UUID) of the configuration policy.
        public let id: String?
        ///  The name of the configuration policy. Alphanumeric characters and the following ASCII characters are permitted:  -, ., !, *, /.
        public let name: String?
        ///  Indicates whether the service that the configuration policy applies to is enabled in the policy.
        public let serviceEnabled: Bool?
        ///  The date and time, in UTC and ISO 8601 format, that the configuration policy was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, serviceEnabled: Bool? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.serviceEnabled = serviceEnabled
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case serviceEnabled = "ServiceEnabled"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ContainerDetails: AWSEncodableShape & AWSDecodableShape {
        /// The runtime of the container.
        public let containerRuntime: String?
        /// The identifier of the container image related to a finding.
        public let imageId: String?
        /// The name of the container image related to a finding.
        public let imageName: String?
        /// Indicates when the container started. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let launchedAt: String?
        /// The name of the container related to a finding.
        public let name: String?
        /// When this parameter is true, the container is given elevated privileges on the host
        /// container instance (similar to the root user).
        public let privileged: Bool?
        /// Provides information about the mounting of a volume in a container.
        public let volumeMounts: [VolumeMount]?

        @inlinable
        public init(containerRuntime: String? = nil, imageId: String? = nil, imageName: String? = nil, launchedAt: String? = nil, name: String? = nil, privileged: Bool? = nil, volumeMounts: [VolumeMount]? = nil) {
            self.containerRuntime = containerRuntime
            self.imageId = imageId
            self.imageName = imageName
            self.launchedAt = launchedAt
            self.name = name
            self.privileged = privileged
            self.volumeMounts = volumeMounts
        }

        public func validate(name: String) throws {
            try self.validate(self.containerRuntime, name: "containerRuntime", parent: name, pattern: "\\S")
            try self.validate(self.imageId, name: "imageId", parent: name, pattern: "\\S")
            try self.validate(self.imageName, name: "imageName", parent: name, pattern: "\\S")
            try self.validate(self.launchedAt, name: "launchedAt", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.volumeMounts?.forEach {
                try $0.validate(name: "\(name).volumeMounts[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case containerRuntime = "ContainerRuntime"
            case imageId = "ImageId"
            case imageName = "ImageName"
            case launchedAt = "LaunchedAt"
            case name = "Name"
            case privileged = "Privileged"
            case volumeMounts = "VolumeMounts"
        }
    }

    public struct Country: AWSEncodableShape & AWSDecodableShape {
        /// The 2-letter ISO 3166 country code for the country.
        public let countryCode: String?
        /// The name of the country.
        public let countryName: String?

        @inlinable
        public init(countryCode: String? = nil, countryName: String? = nil) {
            self.countryCode = countryCode
            self.countryName = countryName
        }

        public func validate(name: String) throws {
            try self.validate(self.countryCode, name: "countryCode", parent: name, pattern: "\\S")
            try self.validate(self.countryName, name: "countryName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case countryCode = "CountryCode"
            case countryName = "CountryName"
        }
    }

    public struct CreateActionTargetRequest: AWSEncodableShape {
        /// The description for the custom action target.
        public let description: String?
        /// The ID for the custom action target. Can contain up to 20 alphanumeric characters.
        public let id: String?
        /// The name of the custom action target. Can contain up to 20 characters.
        public let name: String?

        @inlinable
        public init(description: String? = nil, id: String? = nil, name: String? = nil) {
            self.description = description
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct CreateActionTargetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the custom action target.
        public let actionTargetArn: String?

        @inlinable
        public init(actionTargetArn: String? = nil) {
            self.actionTargetArn = actionTargetArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
        }
    }

    public struct CreateAutomationRuleRequest: AWSEncodableShape {
        ///  One or more actions to update finding fields if a finding matches the conditions  specified in Criteria.
        public let actions: [AutomationRulesAction]?
        ///  A set of ASFF finding field attributes and corresponding expected values that  Security Hub uses to filter findings. If a rule is enabled and a finding matches the conditions specified in this parameter, Security Hub applies the rule action to the finding.
        public let criteria: AutomationRulesFindingFilters?
        ///  A description of the rule.
        public let description: String?
        /// Specifies whether a rule is the last to be applied with respect to a finding that matches the rule criteria. This is useful when a finding  matches the criteria for multiple rules, and each rule has different actions. If a rule is terminal, Security Hub applies the rule action to a finding that matches  the rule criteria and doesn't evaluate other rules for the finding. By default, a rule isn't terminal.
        public let isTerminal: Bool?
        ///  The name of the rule.
        public let ruleName: String?
        /// An integer ranging from 1 to 1000 that represents the order in which the rule action is applied to findings. Security Hub applies rules with lower values for this parameter first.
        public let ruleOrder: Int?
        ///  Whether the rule is active after it is created. If  this parameter is equal to ENABLED, Security Hub starts applying the rule to findings  and finding updates after the rule is created. To change the value of this parameter after creating a rule, use  BatchUpdateAutomationRules .
        public let ruleStatus: RuleStatus?
        ///  User-defined tags associated with an automation rule.
        public let tags: [String: String]?

        @inlinable
        public init(actions: [AutomationRulesAction]? = nil, criteria: AutomationRulesFindingFilters? = nil, description: String? = nil, isTerminal: Bool? = nil, ruleName: String? = nil, ruleOrder: Int? = nil, ruleStatus: RuleStatus? = nil, tags: [String: String]? = nil) {
            self.actions = actions
            self.criteria = criteria
            self.description = description
            self.isTerminal = isTerminal
            self.ruleName = ruleName
            self.ruleOrder = ruleOrder
            self.ruleStatus = ruleStatus
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 1)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.criteria?.validate(name: "\(name).criteria")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "\\S")
            try self.validate(self.ruleOrder, name: "ruleOrder", parent: name, max: 1000)
            try self.validate(self.ruleOrder, name: "ruleOrder", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case criteria = "Criteria"
            case description = "Description"
            case isTerminal = "IsTerminal"
            case ruleName = "RuleName"
            case ruleOrder = "RuleOrder"
            case ruleStatus = "RuleStatus"
            case tags = "Tags"
        }
    }

    public struct CreateAutomationRuleResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the automation rule that you created.
        public let ruleArn: String?

        @inlinable
        public init(ruleArn: String? = nil) {
            self.ruleArn = ruleArn
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "RuleArn"
        }
    }

    public struct CreateConfigurationPolicyRequest: AWSEncodableShape {
        ///  An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or  disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls.  If you provide a list of security controls that are enabled in the configuration policy, Security Hub disables all other controls (including newly  released controls). If you provide a list of security controls that are disabled in the configuration policy, Security Hub  enables all other controls (including newly released controls).
        public let configurationPolicy: Policy?
        ///  The description of the configuration policy.
        public let description: String?
        ///  The name of the configuration policy. Alphanumeric characters and the following ASCII characters are permitted:  -, ., !, *, /.
        public let name: String?
        ///  User-defined tags associated with a configuration policy. For more information, see  Tagging Security Hub resources  in the Security Hub user guide.
        public let tags: [String: String]?

        @inlinable
        public init(configurationPolicy: Policy? = nil, description: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.configurationPolicy = configurationPolicy
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configurationPolicy?.validate(name: "\(name).configurationPolicy")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationPolicy = "ConfigurationPolicy"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateConfigurationPolicyResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the configuration policy.
        public let arn: String?
        ///  An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or disabled, a  list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls.  If the request included a list of security controls that are enabled in the configuration policy, Security Hub disables all other controls (including newly  released controls). If the request included a list of security controls that are disabled in the configuration policy,  Security Hub enables all other controls (including newly released controls).
        public let configurationPolicy: Policy?
        ///  The date and time, in UTC and ISO 8601 format, that the configuration policy was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        ///  The description of the configuration policy.
        public let description: String?
        ///  The universally unique identifier (UUID) of the configuration policy.
        public let id: String?
        ///  The name of the configuration policy.
        public let name: String?
        ///  The date and time, in UTC and ISO 8601 format, that the configuration policy was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, configurationPolicy: Policy? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.configurationPolicy = configurationPolicy
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case configurationPolicy = "ConfigurationPolicy"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CreateFindingAggregatorRequest: AWSEncodableShape {
        /// Indicates whether to aggregate findings from all of the available Regions in the current partition. Also determines whether to automatically aggregate findings from new Regions as Security Hub supports them and you opt into them. The selected option also determines how to use the Regions provided in the Regions list. The options are as follows:    ALL_REGIONS - Aggregates findings from all of the Regions where Security Hub is enabled. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.     ALL_REGIONS_EXCEPT_SPECIFIED - Aggregates findings from all of the Regions where Security Hub is enabled, except for the Regions listed in the Regions parameter. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.     SPECIFIED_REGIONS - Aggregates findings only from the Regions listed in the Regions parameter. Security Hub does not automatically aggregate findings from new Regions.     NO_REGIONS - Aggregates no data because no Regions are selected as linked Regions.
        public let regionLinkingMode: String?
        /// If RegionLinkingMode is ALL_REGIONS_EXCEPT_SPECIFIED, then this is a space-separated list of Regions that don't replicate and send findings to the home Region. If RegionLinkingMode is SPECIFIED_REGIONS, then this is a space-separated list of Regions that do replicate and send findings to the home Region.  An InvalidInputException error results if you populate this field while RegionLinkingMode is  NO_REGIONS.
        public let regions: [String]?

        @inlinable
        public init(regionLinkingMode: String? = nil, regions: [String]? = nil) {
            self.regionLinkingMode = regionLinkingMode
            self.regions = regions
        }

        public func validate(name: String) throws {
            try self.validate(self.regionLinkingMode, name: "regionLinkingMode", parent: name, pattern: "\\S")
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case regionLinkingMode = "RegionLinkingMode"
            case regions = "Regions"
        }
    }

    public struct CreateFindingAggregatorResponse: AWSDecodableShape {
        /// The home Region. Findings generated in linked Regions are replicated and sent to the home Region.
        public let findingAggregationRegion: String?
        /// The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and stop cross-Region aggregation.
        public let findingAggregatorArn: String?
        /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
        public let regionLinkingMode: String?
        /// The list of excluded Regions or included Regions.
        public let regions: [String]?

        @inlinable
        public init(findingAggregationRegion: String? = nil, findingAggregatorArn: String? = nil, regionLinkingMode: String? = nil, regions: [String]? = nil) {
            self.findingAggregationRegion = findingAggregationRegion
            self.findingAggregatorArn = findingAggregatorArn
            self.regionLinkingMode = regionLinkingMode
            self.regions = regions
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregationRegion = "FindingAggregationRegion"
            case findingAggregatorArn = "FindingAggregatorArn"
            case regionLinkingMode = "RegionLinkingMode"
            case regions = "Regions"
        }
    }

    public struct CreateInsightRequest: AWSEncodableShape {
        /// One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.
        public let filters: AwsSecurityFindingFilters?
        /// The attribute used to group the findings for the insight. The grouping attribute identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.
        public let groupByAttribute: String?
        /// The name of the custom insight to create.
        public let name: String?

        @inlinable
        public init(filters: AwsSecurityFindingFilters? = nil, groupByAttribute: String? = nil, name: String? = nil) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.name = name
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.groupByAttribute, name: "groupByAttribute", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case name = "Name"
        }
    }

    public struct CreateInsightResponse: AWSDecodableShape {
        /// The ARN of the insight created.
        public let insightArn: String?

        @inlinable
        public init(insightArn: String? = nil) {
            self.insightArn = insightArn
        }

        private enum CodingKeys: String, CodingKey {
            case insightArn = "InsightArn"
        }
    }

    public struct CreateMembersRequest: AWSEncodableShape {
        /// The list of accounts to associate with the Security Hub administrator account. For each account, the list includes the account ID and optionally the email address.
        public let accountDetails: [AccountDetails]?

        @inlinable
        public init(accountDetails: [AccountDetails]? = nil) {
            self.accountDetails = accountDetails
        }

        public func validate(name: String) throws {
            try self.accountDetails?.forEach {
                try $0.validate(name: "\(name).accountDetails[]")
            }
            try self.validate(self.accountDetails, name: "accountDetails", parent: name, max: 50)
            try self.validate(self.accountDetails, name: "accountDetails", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountDetails = "AccountDetails"
        }
    }

    public struct CreateMembersResponse: AWSDecodableShape {
        /// The list of Amazon Web Services accounts that were not processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        @inlinable
        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct CustomDataIdentifiersDetections: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the custom identifier that was used to detect the sensitive data.
        public let arn: String?
        /// The total number of occurrences of sensitive data that were detected.
        public let count: Int64?
        /// he name of the custom identifier that detected the sensitive data.
        public let name: String?
        /// Details about the sensitive data that was detected.
        public let occurrences: Occurrences?

        @inlinable
        public init(arn: String? = nil, count: Int64? = nil, name: String? = nil, occurrences: Occurrences? = nil) {
            self.arn = arn
            self.count = count
            self.name = name
            self.occurrences = occurrences
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.occurrences?.validate(name: "\(name).occurrences")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case count = "Count"
            case name = "Name"
            case occurrences = "Occurrences"
        }
    }

    public struct CustomDataIdentifiersResult: AWSEncodableShape & AWSDecodableShape {
        /// The list of detected instances of sensitive data.
        public let detections: [CustomDataIdentifiersDetections]?
        /// The total number of occurrences of sensitive data.
        public let totalCount: Int64?

        @inlinable
        public init(detections: [CustomDataIdentifiersDetections]? = nil, totalCount: Int64? = nil) {
            self.detections = detections
            self.totalCount = totalCount
        }

        public func validate(name: String) throws {
            try self.detections?.forEach {
                try $0.validate(name: "\(name).detections[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case detections = "Detections"
            case totalCount = "TotalCount"
        }
    }

    public struct Cvss: AWSEncodableShape & AWSDecodableShape {
        /// Adjustments to the CVSS metrics.
        public let adjustments: [Adjustment]?
        /// The base CVSS score.
        public let baseScore: Double?
        /// The base scoring vector for the CVSS score.
        public let baseVector: String?
        /// The origin of the original CVSS score and vector.
        public let source: String?
        /// The version of CVSS for the CVSS score.
        public let version: String?

        @inlinable
        public init(adjustments: [Adjustment]? = nil, baseScore: Double? = nil, baseVector: String? = nil, source: String? = nil, version: String? = nil) {
            self.adjustments = adjustments
            self.baseScore = baseScore
            self.baseVector = baseVector
            self.source = source
            self.version = version
        }

        public func validate(name: String) throws {
            try self.adjustments?.forEach {
                try $0.validate(name: "\(name).adjustments[]")
            }
            try self.validate(self.baseVector, name: "baseVector", parent: name, pattern: "\\S")
            try self.validate(self.source, name: "source", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case adjustments = "Adjustments"
            case baseScore = "BaseScore"
            case baseVector = "BaseVector"
            case source = "Source"
            case version = "Version"
        }
    }

    public struct DataClassificationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The path to the folder or file that contains the sensitive data.
        public let detailedResultsLocation: String?
        /// The details about the sensitive data that was detected on the resource.
        public let result: ClassificationResult?

        @inlinable
        public init(detailedResultsLocation: String? = nil, result: ClassificationResult? = nil) {
            self.detailedResultsLocation = detailedResultsLocation
            self.result = result
        }

        public func validate(name: String) throws {
            try self.validate(self.detailedResultsLocation, name: "detailedResultsLocation", parent: name, pattern: "\\S")
            try self.result?.validate(name: "\(name).result")
        }

        private enum CodingKeys: String, CodingKey {
            case detailedResultsLocation = "DetailedResultsLocation"
            case result = "Result"
        }
    }

    public struct DateFilter: AWSEncodableShape & AWSDecodableShape {
        /// A date range for the date filter.
        public let dateRange: DateRange?
        /// A timestamp that provides the end date for the date filter. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let end: String?
        /// A timestamp that provides the start date for the date filter. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let start: String?

        @inlinable
        public init(dateRange: DateRange? = nil, end: String? = nil, start: String? = nil) {
            self.dateRange = dateRange
            self.end = end
            self.start = start
        }

        public func validate(name: String) throws {
            try self.validate(self.end, name: "end", parent: name, pattern: "\\S")
            try self.validate(self.start, name: "start", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case dateRange = "DateRange"
            case end = "End"
            case start = "Start"
        }
    }

    public struct DateRange: AWSEncodableShape & AWSDecodableShape {
        /// A date range unit for the date filter.
        public let unit: DateRangeUnit?
        /// A date range value for the date filter.
        public let value: Int?

        @inlinable
        public init(unit: DateRangeUnit? = nil, value: Int? = nil) {
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "Unit"
            case value = "Value"
        }
    }

    public struct DeclineInvitationsRequest: AWSEncodableShape {
        /// The list of prospective member account IDs for which to decline an invitation.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeclineInvitationsResponse: AWSDecodableShape {
        /// The list of Amazon Web Services accounts that were not processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        @inlinable
        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DeleteActionTargetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the custom action target to delete.
        public let actionTargetArn: String

        @inlinable
        public init(actionTargetArn: String) {
            self.actionTargetArn = actionTargetArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionTargetArn, key: "ActionTargetArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.actionTargetArn, name: "actionTargetArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteActionTargetResponse: AWSDecodableShape {
        /// The ARN of the custom action target that was deleted.
        public let actionTargetArn: String?

        @inlinable
        public init(actionTargetArn: String? = nil) {
            self.actionTargetArn = actionTargetArn
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArn = "ActionTargetArn"
        }
    }

    public struct DeleteConfigurationPolicyRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) or universally unique identifier (UUID) of the configuration policy.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfigurationPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFindingAggregatorRequest: AWSEncodableShape {
        /// The ARN of the finding aggregator to delete. To obtain the ARN, use ListFindingAggregators.
        public let findingAggregatorArn: String

        @inlinable
        public init(findingAggregatorArn: String) {
            self.findingAggregatorArn = findingAggregatorArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.findingAggregatorArn, key: "FindingAggregatorArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.findingAggregatorArn, name: "findingAggregatorArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFindingAggregatorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteInsightRequest: AWSEncodableShape {
        /// The ARN of the insight to delete.
        public let insightArn: String

        @inlinable
        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.insightArn, key: "InsightArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.insightArn, name: "insightArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInsightResponse: AWSDecodableShape {
        /// The ARN of the insight that was deleted.
        public let insightArn: String?

        @inlinable
        public init(insightArn: String? = nil) {
            self.insightArn = insightArn
        }

        private enum CodingKeys: String, CodingKey {
            case insightArn = "InsightArn"
        }
    }

    public struct DeleteInvitationsRequest: AWSEncodableShape {
        /// The list of member account IDs that received the invitations you want to delete.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeleteInvitationsResponse: AWSDecodableShape {
        /// The list of Amazon Web Services accounts for which the invitations were not deleted. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        @inlinable
        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DeleteMembersRequest: AWSEncodableShape {
        /// The list of account IDs for the member accounts to delete.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DeleteMembersResponse: AWSDecodableShape {
        /// The list of Amazon Web Services accounts that were not deleted. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        @inlinable
        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct DescribeActionTargetsRequest: AWSEncodableShape {
        /// A list of custom action target ARNs for the custom action targets to retrieve.
        public let actionTargetArns: [String]?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeActionTargets operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        @inlinable
        public init(actionTargetArns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.actionTargetArns = actionTargetArns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.actionTargetArns?.forEach {
                try validate($0, name: "actionTargetArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargetArns = "ActionTargetArns"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeActionTargetsResponse: AWSDecodableShape {
        /// A list of ActionTarget objects. Each object includes the ActionTargetArn, Description, and Name of a custom action target available in Security Hub.
        public let actionTargets: [ActionTarget]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(actionTargets: [ActionTarget]? = nil, nextToken: String? = nil) {
            self.actionTargets = actionTargets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actionTargets = "ActionTargets"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeHubRequest: AWSEncodableShape {
        /// The ARN of the Hub resource to retrieve.
        public let hubArn: String?

        @inlinable
        public init(hubArn: String? = nil) {
            self.hubArn = hubArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.hubArn, key: "HubArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.hubArn, name: "hubArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeHubResponse: AWSDecodableShape {
        /// Whether to automatically enable new controls when they are added to standards that are enabled. If set to true, then new controls for enabled standards are enabled automatically. If set to false, then new controls are not enabled. When you automatically enable new controls, you can interact with the controls in  the console and programmatically immediately after release. However, automatically enabled controls have a temporary default status of  DISABLED. It can take up to several days for Security Hub to process the control release and designate the  control as ENABLED in your account. During the processing period, you can manually enable or disable a  control, and Security Hub will maintain that designation regardless of whether you have AutoEnableControls set to  true.
        public let autoEnableControls: Bool?
        /// Specifies whether the calling account has consolidated control findings turned on. If the value for this field is set to  SECURITY_CONTROL, Security Hub generates a single finding for a control check even when the check  applies to multiple enabled standards. If the value for this field is set to STANDARD_CONTROL, Security Hub generates separate findings  for a control check when the check applies to multiple enabled standards. The value for this field in a member account matches the value in the administrator account. For accounts that aren't part of an organization, the default value of this field is SECURITY_CONTROL if you enabled Security Hub on or after February 23, 2023.
        public let controlFindingGenerator: ControlFindingGenerator?
        /// The ARN of the Hub resource that was retrieved.
        public let hubArn: String?
        /// The date and time when Security Hub was enabled in the account.
        public let subscribedAt: String?

        @inlinable
        public init(autoEnableControls: Bool? = nil, controlFindingGenerator: ControlFindingGenerator? = nil, hubArn: String? = nil, subscribedAt: String? = nil) {
            self.autoEnableControls = autoEnableControls
            self.controlFindingGenerator = controlFindingGenerator
            self.hubArn = hubArn
            self.subscribedAt = subscribedAt
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnableControls = "AutoEnableControls"
            case controlFindingGenerator = "ControlFindingGenerator"
            case hubArn = "HubArn"
            case subscribedAt = "SubscribedAt"
        }
    }

    public struct DescribeOrganizationConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeOrganizationConfigurationResponse: AWSDecodableShape {
        /// Whether to automatically enable Security Hub in new member accounts when they join the organization. If set to true, then Security Hub is automatically enabled in new accounts. If set to false, then Security Hub isn't enabled in new accounts automatically. The default value is false. If the ConfigurationType of your organization is set to CENTRAL, then this field is set  to false and can't be changed in the home Region and linked Regions. However, in that case, the delegated administrator can create a configuration  policy in which Security Hub is enabled and associate the policy with new organization accounts.
        public let autoEnable: Bool?
        /// Whether to automatically enable Security Hub default standards  in new member accounts when they join the organization. If equal to DEFAULT, then Security Hub default standards are automatically enabled for new member  accounts. If equal to NONE, then default standards are not automatically enabled for new member  accounts. The default value of this parameter is equal to DEFAULT. If the ConfigurationType of your organization is set to CENTRAL, then this field is set  to NONE and can't be changed in the home Region and linked Regions. However, in that case, the delegated administrator can create a configuration  policy in which specific security standards are enabled and associate the policy with new organization accounts.
        public let autoEnableStandards: AutoEnableStandards?
        /// Whether the maximum number of allowed member accounts are already associated with the Security Hub administrator account.
        public let memberAccountLimitReached: Bool?
        public let organizationConfiguration: OrganizationConfiguration?

        @inlinable
        public init(autoEnable: Bool? = nil, autoEnableStandards: AutoEnableStandards? = nil, memberAccountLimitReached: Bool? = nil, organizationConfiguration: OrganizationConfiguration? = nil) {
            self.autoEnable = autoEnable
            self.autoEnableStandards = autoEnableStandards
            self.memberAccountLimitReached = memberAccountLimitReached
            self.organizationConfiguration = organizationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "AutoEnable"
            case autoEnableStandards = "AutoEnableStandards"
            case memberAccountLimitReached = "MemberAccountLimitReached"
            case organizationConfiguration = "OrganizationConfiguration"
        }
    }

    public struct DescribeProductsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeProducts operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The ARN of the integration to return.
        public let productArn: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, productArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.productArn = productArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.productArn, key: "ProductArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProductsResponse: AWSDecodableShape {
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// A list of products, including details for each product.
        public let products: [Product]?

        @inlinable
        public init(nextToken: String? = nil, products: [Product]? = nil) {
            self.nextToken = nextToken
            self.products = products
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case products = "Products"
        }
    }

    public struct DescribeStandardsControlsRequest: AWSEncodableShape {
        /// The maximum number of security standard controls to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeStandardsControls operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The ARN of a resource that represents your subscription to a supported standard. To get the subscription ARNs of the standards you have enabled, use the GetEnabledStandards operation.
        public let standardsSubscriptionArn: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, standardsSubscriptionArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.standardsSubscriptionArn = standardsSubscriptionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.standardsSubscriptionArn, key: "StandardsSubscriptionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.standardsSubscriptionArn, name: "standardsSubscriptionArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeStandardsControlsResponse: AWSDecodableShape {
        /// A list of security standards controls.
        public let controls: [StandardsControl]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(controls: [StandardsControl]? = nil, nextToken: String? = nil) {
            self.controls = controls
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case controls = "Controls"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeStandardsRequest: AWSEncodableShape {
        /// The maximum number of standards to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the DescribeStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeStandardsResponse: AWSDecodableShape {
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// A list of available standards.
        public let standards: [Standard]?

        @inlinable
        public init(nextToken: String? = nil, standards: [Standard]? = nil) {
            self.nextToken = nextToken
            self.standards = standards
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case standards = "Standards"
        }
    }

    public struct Detection: AWSEncodableShape & AWSDecodableShape {
        ///  Provides details about an attack sequence.
        public let sequence: Sequence?

        @inlinable
        public init(sequence: Sequence? = nil) {
            self.sequence = sequence
        }

        public func validate(name: String) throws {
            try self.sequence?.validate(name: "\(name).sequence")
        }

        private enum CodingKeys: String, CodingKey {
            case sequence = "Sequence"
        }
    }

    public struct DisableImportFindingsForProductRequest: AWSEncodableShape {
        /// The ARN of the integrated product to disable the integration for.
        public let productSubscriptionArn: String

        @inlinable
        public init(productSubscriptionArn: String) {
            self.productSubscriptionArn = productSubscriptionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.productSubscriptionArn, key: "ProductSubscriptionArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.productSubscriptionArn, name: "productSubscriptionArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisableImportFindingsForProductResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisableOrganizationAdminAccountRequest: AWSEncodableShape {
        /// The Amazon Web Services account identifier of the Security Hub administrator account.
        public let adminAccountId: String?

        @inlinable
        public init(adminAccountId: String? = nil) {
            self.adminAccountId = adminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "AdminAccountId"
        }
    }

    public struct DisableOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisableSecurityHubRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisableSecurityHubResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateFromAdministratorAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisassociateFromAdministratorAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateFromMasterAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisassociateFromMasterAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMembersRequest: AWSEncodableShape {
        /// The account IDs of the member accounts to disassociate from the administrator account.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct DisassociateMembersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DnsRequestAction: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the DNS request was blocked.
        public let blocked: Bool?
        /// The DNS domain that is associated with the DNS request. Length Constraints: 128.
        public let domain: String?
        /// The protocol that was used for the DNS request. Length Constraints: Minimum length of 1. Maximum length of 64.
        public let `protocol`: String?

        @inlinable
        public init(blocked: Bool? = nil, domain: String? = nil, protocol: String? = nil) {
            self.blocked = blocked
            self.domain = domain
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.domain, name: "domain", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "Blocked"
            case domain = "Domain"
            case `protocol` = "Protocol"
        }
    }

    public struct DoubleConfigurationOptions: AWSDecodableShape {
        ///  The Security Hub default value for a control parameter that is a double.
        public let defaultValue: Double?
        ///  The maximum valid value for a control parameter that is a double.
        public let max: Double?
        ///  The minimum valid value for a control parameter that is a double.
        public let min: Double?

        @inlinable
        public init(defaultValue: Double? = nil, max: Double? = nil, min: Double? = nil) {
            self.defaultValue = defaultValue
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case max = "Max"
            case min = "Min"
        }
    }

    public struct EnableImportFindingsForProductRequest: AWSEncodableShape {
        /// The ARN of the product to enable the integration for.
        public let productArn: String?

        @inlinable
        public init(productArn: String? = nil) {
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case productArn = "ProductArn"
        }
    }

    public struct EnableImportFindingsForProductResponse: AWSDecodableShape {
        /// The ARN of your subscription to the product to enable integrations for.
        public let productSubscriptionArn: String?

        @inlinable
        public init(productSubscriptionArn: String? = nil) {
            self.productSubscriptionArn = productSubscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case productSubscriptionArn = "ProductSubscriptionArn"
        }
    }

    public struct EnableOrganizationAdminAccountRequest: AWSEncodableShape {
        /// The Amazon Web Services account identifier of the account to designate as the Security Hub administrator account.
        public let adminAccountId: String?

        @inlinable
        public init(adminAccountId: String? = nil) {
            self.adminAccountId = adminAccountId
        }

        public func validate(name: String) throws {
            try self.validate(self.adminAccountId, name: "adminAccountId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId = "AdminAccountId"
        }
    }

    public struct EnableOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EnableSecurityHubRequest: AWSEncodableShape {
        /// This field, used when enabling Security Hub, specifies whether the calling account has consolidated control findings turned on.  If the value for this field is set to  SECURITY_CONTROL, Security Hub generates a single finding for a control check even when the check  applies to multiple enabled standards. If the value for this field is set to STANDARD_CONTROL, Security Hub generates separate findings  for a control check when the check applies to multiple enabled standards. The value for this field in a member account matches the value in the administrator account. For accounts that aren't part of an organization, the default value of this field is SECURITY_CONTROL if you enabled Security Hub on or after February 23, 2023.
        public let controlFindingGenerator: ControlFindingGenerator?
        /// Whether to enable the security standards that Security Hub has designated as automatically enabled. If you don't provide a value for EnableDefaultStandards, it is set to true. To not enable the automatically enabled standards, set EnableDefaultStandards to false.
        public let enableDefaultStandards: Bool?
        /// The tags to add to the hub resource when you enable Security Hub.
        public let tags: [String: String]?

        @inlinable
        public init(controlFindingGenerator: ControlFindingGenerator? = nil, enableDefaultStandards: Bool? = nil, tags: [String: String]? = nil) {
            self.controlFindingGenerator = controlFindingGenerator
            self.enableDefaultStandards = enableDefaultStandards
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case controlFindingGenerator = "ControlFindingGenerator"
            case enableDefaultStandards = "EnableDefaultStandards"
            case tags = "Tags"
        }
    }

    public struct EnableSecurityHubResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EnumConfigurationOptions: AWSDecodableShape {
        ///  The valid values for a control parameter that is an enum.
        public let allowedValues: [String]?
        ///  The Security Hub default value for a control parameter that is an enum.
        public let defaultValue: String?

        @inlinable
        public init(allowedValues: [String]? = nil, defaultValue: String? = nil) {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "AllowedValues"
            case defaultValue = "DefaultValue"
        }
    }

    public struct EnumListConfigurationOptions: AWSDecodableShape {
        ///  The valid values for a control parameter that is a list of enums.
        public let allowedValues: [String]?
        ///  The Security Hub default value for a control parameter that is a list of enums.
        public let defaultValue: [String]?
        ///  The maximum number of list items that an enum list control parameter can accept.
        public let maxItems: Int?

        @inlinable
        public init(allowedValues: [String]? = nil, defaultValue: [String]? = nil, maxItems: Int? = nil) {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
            self.maxItems = maxItems
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "AllowedValues"
            case defaultValue = "DefaultValue"
            case maxItems = "MaxItems"
        }
    }

    public struct FilePaths: AWSEncodableShape & AWSDecodableShape {
        /// The name of the infected or suspicious file corresponding to the hash.
        /// 		 Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public let fileName: String?
        /// Path to the infected or suspicious file on the resource it was detected on.
        /// 		 Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public let filePath: String?
        /// The hash value for the infected or suspicious file.
        /// 		 Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public let hash: String?
        /// The Amazon Resource Name (ARN) of the resource on which the threat was detected.
        /// 		 Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public let resourceId: String?

        @inlinable
        public init(fileName: String? = nil, filePath: String? = nil, hash: String? = nil, resourceId: String? = nil) {
            self.fileName = fileName
            self.filePath = filePath
            self.hash = hash
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.fileName, name: "fileName", parent: name, pattern: "\\S")
            try self.validate(self.filePath, name: "filePath", parent: name, pattern: "\\S")
            try self.validate(self.hash, name: "hash", parent: name, pattern: "\\S")
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case fileName = "FileName"
            case filePath = "FilePath"
            case hash = "Hash"
            case resourceId = "ResourceId"
        }
    }

    public struct FindingAggregator: AWSDecodableShape {
        /// The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and delete the finding aggregator.
        public let findingAggregatorArn: String?

        @inlinable
        public init(findingAggregatorArn: String? = nil) {
            self.findingAggregatorArn = findingAggregatorArn
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregatorArn = "FindingAggregatorArn"
        }
    }

    public struct FindingHistoryRecord: AWSDecodableShape {
        ///  Identifies whether the event marks the creation of a new finding. A value of True means that the finding is  newly created. A value of False means that the finding isnâ€™t newly created.
        public let findingCreated: Bool?
        public let findingIdentifier: AwsSecurityFindingIdentifier?
        ///  A token for pagination purposes. Provide this token in the subsequent request to  GetFindingsHistory to get  up to an additional 100 results of history for the same finding that you specified in your initial request.
        public let nextToken: String?
        ///  An array of objects that provides details about the finding change event, including the Amazon Web Services Security  Finding Format (ASFF) field that changed, the value of the field before the change, and the value of the field after  the change.
        public let updates: [FindingHistoryUpdate]?
        ///  Identifies the source of the event that changed the finding. For example, an integrated Amazon Web Services service or third-party partner integration may call  BatchImportFindings , or an Security Hub customer may call  BatchUpdateFindings .
        public let updateSource: FindingHistoryUpdateSource?
        ///  A timestamp that indicates when Security Hub  processed the updated finding record. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updateTime: Date?

        @inlinable
        public init(findingCreated: Bool? = nil, findingIdentifier: AwsSecurityFindingIdentifier? = nil, nextToken: String? = nil, updates: [FindingHistoryUpdate]? = nil, updateSource: FindingHistoryUpdateSource? = nil, updateTime: Date? = nil) {
            self.findingCreated = findingCreated
            self.findingIdentifier = findingIdentifier
            self.nextToken = nextToken
            self.updates = updates
            self.updateSource = updateSource
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case findingCreated = "FindingCreated"
            case findingIdentifier = "FindingIdentifier"
            case nextToken = "NextToken"
            case updates = "Updates"
            case updateSource = "UpdateSource"
            case updateTime = "UpdateTime"
        }
    }

    public struct FindingHistoryUpdate: AWSDecodableShape {
        ///  The value of the ASFF field after the finding change event. To preserve storage and readability, Security Hub omits this value  if  FindingHistoryRecord exceeds database limits.
        public let newValue: String?
        ///  The value of the ASFF field before the finding change event.
        public let oldValue: String?
        ///  The ASFF field that changed during the finding change event.
        public let updatedField: String?

        @inlinable
        public init(newValue: String? = nil, oldValue: String? = nil, updatedField: String? = nil) {
            self.newValue = newValue
            self.oldValue = oldValue
            self.updatedField = updatedField
        }

        private enum CodingKeys: String, CodingKey {
            case newValue = "NewValue"
            case oldValue = "OldValue"
            case updatedField = "UpdatedField"
        }
    }

    public struct FindingHistoryUpdateSource: AWSDecodableShape {
        ///  The identity of the source that initiated the finding change event. For example, the Amazon Resource Name (ARN) of a partner that calls BatchImportFindings or of a customer that calls BatchUpdateFindings.
        public let identity: String?
        ///  Describes the type of finding change event, such as a call to  BatchImportFindings (by an integrated Amazon Web Services service or third party partner integration) or  BatchUpdateFindings (by a Security Hub customer).
        public let type: FindingHistoryUpdateSourceType?

        @inlinable
        public init(identity: String? = nil, type: FindingHistoryUpdateSourceType? = nil) {
            self.identity = identity
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case identity = "Identity"
            case type = "Type"
        }
    }

    public struct FindingProviderFields: AWSEncodableShape & AWSDecodableShape {
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public let confidence: Int?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public let criticality: Int?
        /// A list of findings that are related to the current finding.
        public let relatedFindings: [RelatedFinding]?
        /// The severity of a finding.
        public let severity: FindingProviderSeverity?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public let types: [String]?

        @inlinable
        public init(confidence: Int? = nil, criticality: Int? = nil, relatedFindings: [RelatedFinding]? = nil, severity: FindingProviderSeverity? = nil, types: [String]? = nil) {
            self.confidence = confidence
            self.criticality = criticality
            self.relatedFindings = relatedFindings
            self.severity = severity
            self.types = types
        }

        public func validate(name: String) throws {
            try self.validate(self.confidence, name: "confidence", parent: name, max: 100)
            try self.validate(self.confidence, name: "confidence", parent: name, min: 0)
            try self.validate(self.criticality, name: "criticality", parent: name, max: 100)
            try self.validate(self.criticality, name: "criticality", parent: name, min: 0)
            try self.relatedFindings?.forEach {
                try $0.validate(name: "\(name).relatedFindings[]")
            }
            try self.severity?.validate(name: "\(name).severity")
            try self.types?.forEach {
                try validate($0, name: "types[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case criticality = "Criticality"
            case relatedFindings = "RelatedFindings"
            case severity = "Severity"
            case types = "Types"
        }
    }

    public struct FindingProviderSeverity: AWSEncodableShape & AWSDecodableShape {
        /// The severity label assigned to the finding by the finding provider.
        public let label: SeverityLabel?
        /// The finding provider's original value for the severity. Length Constraints: Minimum length of 1. Maximum length of 64.
        public let original: String?

        @inlinable
        public init(label: SeverityLabel? = nil, original: String? = nil) {
            self.label = label
            self.original = original
        }

        public func validate(name: String) throws {
            try self.validate(self.original, name: "original", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case original = "Original"
        }
    }

    public struct FirewallPolicyDetails: AWSEncodableShape & AWSDecodableShape {
        /// The stateful rule groups that are used in the firewall policy.
        public let statefulRuleGroupReferences: [FirewallPolicyStatefulRuleGroupReferencesDetails]?
        /// The custom action definitions that are available to use in the firewall policy's StatelessDefaultActions setting.
        public let statelessCustomActions: [FirewallPolicyStatelessCustomActionsDetails]?
        /// The actions to take on a packet if it doesn't match any of the stateless rules in the policy. You must specify a standard action (aws:pass, aws:drop, aws:forward_to_sfe), and can optionally include a custom action from StatelessCustomActions.
        public let statelessDefaultActions: [String]?
        /// The actions to take on a fragmented UDP packet if it doesn't match any of the stateless rules in the policy. You must specify a standard action (aws:pass, aws:drop, aws:forward_to_sfe), and can optionally include a custom action from StatelessCustomActions.
        public let statelessFragmentDefaultActions: [String]?
        /// The stateless rule groups that are used in the firewall policy.
        public let statelessRuleGroupReferences: [FirewallPolicyStatelessRuleGroupReferencesDetails]?

        @inlinable
        public init(statefulRuleGroupReferences: [FirewallPolicyStatefulRuleGroupReferencesDetails]? = nil, statelessCustomActions: [FirewallPolicyStatelessCustomActionsDetails]? = nil, statelessDefaultActions: [String]? = nil, statelessFragmentDefaultActions: [String]? = nil, statelessRuleGroupReferences: [FirewallPolicyStatelessRuleGroupReferencesDetails]? = nil) {
            self.statefulRuleGroupReferences = statefulRuleGroupReferences
            self.statelessCustomActions = statelessCustomActions
            self.statelessDefaultActions = statelessDefaultActions
            self.statelessFragmentDefaultActions = statelessFragmentDefaultActions
            self.statelessRuleGroupReferences = statelessRuleGroupReferences
        }

        public func validate(name: String) throws {
            try self.statefulRuleGroupReferences?.forEach {
                try $0.validate(name: "\(name).statefulRuleGroupReferences[]")
            }
            try self.statelessCustomActions?.forEach {
                try $0.validate(name: "\(name).statelessCustomActions[]")
            }
            try self.statelessDefaultActions?.forEach {
                try validate($0, name: "statelessDefaultActions[]", parent: name, pattern: "\\S")
            }
            try self.statelessFragmentDefaultActions?.forEach {
                try validate($0, name: "statelessFragmentDefaultActions[]", parent: name, pattern: "\\S")
            }
            try self.statelessRuleGroupReferences?.forEach {
                try $0.validate(name: "\(name).statelessRuleGroupReferences[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case statefulRuleGroupReferences = "StatefulRuleGroupReferences"
            case statelessCustomActions = "StatelessCustomActions"
            case statelessDefaultActions = "StatelessDefaultActions"
            case statelessFragmentDefaultActions = "StatelessFragmentDefaultActions"
            case statelessRuleGroupReferences = "StatelessRuleGroupReferences"
        }
    }

    public struct FirewallPolicyStatefulRuleGroupReferencesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the stateful rule group.
        public let resourceArn: String?

        @inlinable
        public init(resourceArn: String? = nil) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct FirewallPolicyStatelessCustomActionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The definition of the custom action.
        public let actionDefinition: StatelessCustomActionDefinition?
        /// The name of the custom action.
        public let actionName: String?

        @inlinable
        public init(actionDefinition: StatelessCustomActionDefinition? = nil, actionName: String? = nil) {
            self.actionDefinition = actionDefinition
            self.actionName = actionName
        }

        public func validate(name: String) throws {
            try self.actionDefinition?.validate(name: "\(name).actionDefinition")
            try self.validate(self.actionName, name: "actionName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinition = "ActionDefinition"
            case actionName = "ActionName"
        }
    }

    public struct FirewallPolicyStatelessRuleGroupReferencesDetails: AWSEncodableShape & AWSDecodableShape {
        /// The order in which to run the stateless rule group.
        public let priority: Int?
        /// The ARN of the stateless rule group.
        public let resourceArn: String?

        @inlinable
        public init(priority: Int? = nil, resourceArn: String? = nil) {
            self.priority = priority
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case priority = "Priority"
            case resourceArn = "ResourceArn"
        }
    }

    public struct GeneratorDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The description of the detector used to identify the code vulnerability.
        public let description: String?
        ///  An array of tags used to identify the detector associated with the finding.  Array Members: Minimum number of 0 items. Maximum number of 10 items.
        public let labels: [String]?
        ///  The name of the detector used to identify the code vulnerability.
        public let name: String?

        @inlinable
        public init(description: String? = nil, labels: [String]? = nil, name: String? = nil) {
            self.description = description
            self.labels = labels
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.labels?.forEach {
                try validate($0, name: "labels[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case labels = "Labels"
            case name = "Name"
        }
    }

    public struct GeoLocation: AWSEncodableShape & AWSDecodableShape {
        /// The latitude of the location.
        public let lat: Double?
        /// The longitude of the location.
        public let lon: Double?

        @inlinable
        public init(lat: Double? = nil, lon: Double? = nil) {
            self.lat = lat
            self.lon = lon
        }

        private enum CodingKeys: String, CodingKey {
            case lat = "Lat"
            case lon = "Lon"
        }
    }

    public struct GetAdministratorAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAdministratorAccountResponse: AWSDecodableShape {
        public let administrator: Invitation?

        @inlinable
        public init(administrator: Invitation? = nil) {
            self.administrator = administrator
        }

        private enum CodingKeys: String, CodingKey {
            case administrator = "Administrator"
        }
    }

    public struct GetConfigurationPolicyAssociationRequest: AWSEncodableShape {
        ///  The target account ID, organizational unit ID, or the root ID to retrieve the association for.
        public let target: Target?

        @inlinable
        public init(target: Target? = nil) {
            self.target = target
        }

        public func validate(name: String) throws {
            try self.target?.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case target = "Target"
        }
    }

    public struct GetConfigurationPolicyAssociationResponse: AWSDecodableShape {
        ///  The current status of the association between the specified target and the configuration.
        public let associationStatus: ConfigurationPolicyAssociationStatus?
        ///  The explanation for a FAILED value for AssociationStatus.
        public let associationStatusMessage: String?
        ///  Indicates whether the association between the specified target and the configuration was directly applied by the  Security Hub delegated administrator or inherited from a parent.
        public let associationType: AssociationType?
        ///  The universally unique identifier (UUID) of a configuration policy. For self-managed behavior, the value is  SELF_MANAGED_SECURITY_HUB.
        public let configurationPolicyId: String?
        ///  The target account ID, organizational unit ID, or the root ID for which the association is retrieved.
        public let targetId: String?
        ///  Specifies whether the target is an Amazon Web Services account, organizational unit, or the organization root.
        public let targetType: TargetType?
        ///  The date and time, in UTC and ISO 8601 format, that the configuration policy association was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(associationStatus: ConfigurationPolicyAssociationStatus? = nil, associationStatusMessage: String? = nil, associationType: AssociationType? = nil, configurationPolicyId: String? = nil, targetId: String? = nil, targetType: TargetType? = nil, updatedAt: Date? = nil) {
            self.associationStatus = associationStatus
            self.associationStatusMessage = associationStatusMessage
            self.associationType = associationType
            self.configurationPolicyId = configurationPolicyId
            self.targetId = targetId
            self.targetType = targetType
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case associationStatus = "AssociationStatus"
            case associationStatusMessage = "AssociationStatusMessage"
            case associationType = "AssociationType"
            case configurationPolicyId = "ConfigurationPolicyId"
            case targetId = "TargetId"
            case targetType = "TargetType"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetConfigurationPolicyRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) or universally unique identifier (UUID) of the configuration policy.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfigurationPolicyResponse: AWSDecodableShape {
        ///  The ARN of the configuration policy.
        public let arn: String?
        ///  An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or  disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls.  If the policy includes a list of security controls that are enabled, Security Hub disables all other controls (including newly released controls).  If the policy includes a list of security controls that are disabled, Security Hub enables all other controls (including  newly released controls).
        public let configurationPolicy: Policy?
        ///  The date and time, in UTC and ISO 8601 format, that the configuration policy was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        ///  The description of the configuration policy.
        public let description: String?
        ///  The UUID of the configuration policy.
        public let id: String?
        ///  The name of the configuration policy.
        public let name: String?
        ///  The date and time, in UTC and ISO 8601 format, that the configuration policy was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, configurationPolicy: Policy? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.configurationPolicy = configurationPolicy
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case configurationPolicy = "ConfigurationPolicy"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetEnabledStandardsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the GetEnabledStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The list of the standards subscription ARNs for the standards to retrieve.
        public let standardsSubscriptionArns: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, standardsSubscriptionArns: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.standardsSubscriptionArns = standardsSubscriptionArns
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.standardsSubscriptionArns?.forEach {
                try validate($0, name: "standardsSubscriptionArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, max: 25)
            try self.validate(self.standardsSubscriptionArns, name: "standardsSubscriptionArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case standardsSubscriptionArns = "StandardsSubscriptionArns"
        }
    }

    public struct GetEnabledStandardsResponse: AWSDecodableShape {
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// The list of StandardsSubscriptions objects that include information about the enabled standards.
        public let standardsSubscriptions: [StandardsSubscription]?

        @inlinable
        public init(nextToken: String? = nil, standardsSubscriptions: [StandardsSubscription]? = nil) {
            self.nextToken = nextToken
            self.standardsSubscriptions = standardsSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case standardsSubscriptions = "StandardsSubscriptions"
        }
    }

    public struct GetFindingAggregatorRequest: AWSEncodableShape {
        /// The ARN of the finding aggregator to return details for. To obtain the ARN, use ListFindingAggregators.
        public let findingAggregatorArn: String

        @inlinable
        public init(findingAggregatorArn: String) {
            self.findingAggregatorArn = findingAggregatorArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.findingAggregatorArn, key: "FindingAggregatorArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.findingAggregatorArn, name: "findingAggregatorArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingAggregatorResponse: AWSDecodableShape {
        /// The home Region. Findings generated in linked Regions are replicated and sent to the home Region.
        public let findingAggregationRegion: String?
        /// The ARN of the finding aggregator.
        public let findingAggregatorArn: String?
        /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
        public let regionLinkingMode: String?
        /// The list of excluded Regions or included Regions.
        public let regions: [String]?

        @inlinable
        public init(findingAggregationRegion: String? = nil, findingAggregatorArn: String? = nil, regionLinkingMode: String? = nil, regions: [String]? = nil) {
            self.findingAggregationRegion = findingAggregationRegion
            self.findingAggregatorArn = findingAggregatorArn
            self.regionLinkingMode = regionLinkingMode
            self.regions = regions
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregationRegion = "FindingAggregationRegion"
            case findingAggregatorArn = "FindingAggregatorArn"
            case regionLinkingMode = "RegionLinkingMode"
            case regions = "Regions"
        }
    }

    public struct GetFindingHistoryRequest: AWSEncodableShape {
        ///  An ISO 8601-formatted timestamp that indicates the end time of the requested finding history. If you provide values for both StartTime and EndTime, Security Hub returns finding history for the specified time period. If you provide a value for StartTime but not for EndTime, Security Hub returns finding history from the StartTime to the time at which the API is called. If you provide a value for EndTime but not for StartTime, Security Hub returns finding history from the CreatedAt timestamp of the finding to the EndTime. If you provide neither StartTime nor EndTime, Security Hub returns finding history from the CreatedAt timestamp of the finding to the time at which the API is called. In all of these scenarios, the response is limited to 100 results, and the maximum time period is  limited to 90 days. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        public let findingIdentifier: AwsSecurityFindingIdentifier?
        ///  The maximum number of results to be returned. If you donâ€™t provide it, Security Hub returns up to 100 results of finding history.
        public let maxResults: Int?
        ///  A token for pagination purposes. Provide NULL as the initial value. In subsequent requests, provide the  token included in the response to get up to an additional 100 results of finding history. If you donâ€™t provide  NextToken, Security Hub returns up to 100 results of finding history for each request.
        public let nextToken: String?
        /// A timestamp that indicates the start time of the requested finding history. If you provide values for both StartTime and EndTime, Security Hub returns finding history for the specified time period. If you provide a value for StartTime but not for EndTime, Security Hub returns finding history from the StartTime to the time at which the API is called. If you provide a value for EndTime but not for StartTime, Security Hub returns finding history from the CreatedAt timestamp of the finding to the EndTime. If you provide neither StartTime nor EndTime, Security Hub returns finding history from the CreatedAt timestamp of the finding to the time at which the API is called. In all of these scenarios, the response is limited to 100 results, and the maximum time period is  limited to 90 days. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, findingIdentifier: AwsSecurityFindingIdentifier? = nil, maxResults: Int? = nil, nextToken: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.findingIdentifier = findingIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.findingIdentifier?.validate(name: "\(name).findingIdentifier")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case findingIdentifier = "FindingIdentifier"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTime = "StartTime"
        }
    }

    public struct GetFindingHistoryResponse: AWSDecodableShape {
        ///  A token for pagination purposes. Provide this token in the subsequent request to GetFindingsHistory to  get up to an additional 100 results of history for the same finding that you specified in your initial request.
        public let nextToken: String?
        ///  A list of events that altered the specified finding during the specified time period.
        public let records: [FindingHistoryRecord]?

        @inlinable
        public init(nextToken: String? = nil, records: [FindingHistoryRecord]? = nil) {
            self.nextToken = nextToken
            self.records = records
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case records = "Records"
        }
    }

    public struct GetFindingsRequest: AWSEncodableShape {
        /// The finding attributes used to define a condition to filter the returned findings. You can filter by up to 10 finding attributes. For each attribute, you can provide up to 20 filter values. Note that in the available filter fields, WorkflowState is deprecated. To search for a finding based on its workflow status, use WorkflowStatus.
        public let filters: AwsSecurityFindingFilters?
        /// The maximum number of findings to return.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the GetFindings operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// The finding attributes used to sort the list of returned findings.
        public let sortCriteria: [SortCriterion]?

        @inlinable
        public init(filters: AwsSecurityFindingFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [SortCriterion]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct GetFindingsResponse: AWSDecodableShape {
        /// The findings that matched the filters specified in the request.
        public let findings: [AwsSecurityFinding]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(findings: [AwsSecurityFinding]? = nil, nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "Findings"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightResultsRequest: AWSEncodableShape {
        /// The ARN of the insight for which to return results.
        public let insightArn: String

        @inlinable
        public init(insightArn: String) {
            self.insightArn = insightArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.insightArn, key: "InsightArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.insightArn, name: "insightArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInsightResultsResponse: AWSDecodableShape {
        /// The insight results returned by the operation.
        public let insightResults: InsightResults?

        @inlinable
        public init(insightResults: InsightResults? = nil) {
            self.insightResults = insightResults
        }

        private enum CodingKeys: String, CodingKey {
            case insightResults = "InsightResults"
        }
    }

    public struct GetInsightsRequest: AWSEncodableShape {
        /// The ARNs of the insights to describe. If you don't provide any insight ARNs, then GetInsights returns all of your custom insights. It does not return any managed insights.
        public let insightArns: [String]?
        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the GetInsights operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        @inlinable
        public init(insightArns: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.insightArns = insightArns
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.insightArns?.forEach {
                try validate($0, name: "insightArns[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case insightArns = "InsightArns"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetInsightsResponse: AWSDecodableShape {
        /// The insights returned by the operation.
        public let insights: [Insight]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(insights: [Insight]? = nil, nextToken: String? = nil) {
            self.insights = insights
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case insights = "Insights"
            case nextToken = "NextToken"
        }
    }

    public struct GetInvitationsCountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetInvitationsCountResponse: AWSDecodableShape {
        /// The number of all membership invitations sent to this Security Hub member account, not including the currently accepted invitation.
        public let invitationsCount: Int?

        @inlinable
        public init(invitationsCount: Int? = nil) {
            self.invitationsCount = invitationsCount
        }

        private enum CodingKeys: String, CodingKey {
            case invitationsCount = "InvitationsCount"
        }
    }

    public struct GetMasterAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetMasterAccountResponse: AWSDecodableShape {
        /// A list of details about the Security Hub administrator account for the current member account.
        public let master: Invitation?

        @inlinable
        public init(master: Invitation? = nil) {
            self.master = master
        }

        private enum CodingKeys: String, CodingKey {
            case master = "Master"
        }
    }

    public struct GetMembersRequest: AWSEncodableShape {
        /// The list of account IDs for the Security Hub member accounts to return the details for.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct GetMembersResponse: AWSDecodableShape {
        /// The list of details about the Security Hub member accounts.
        public let members: [Member]?
        /// The list of Amazon Web Services accounts that could not be processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        @inlinable
        public init(members: [Member]? = nil, unprocessedAccounts: [Result]? = nil) {
            self.members = members
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct GetSecurityControlDefinitionRequest: AWSEncodableShape {
        ///  The ID of the security control to retrieve the definition for. This field doesnâ€™t accept an Amazon Resource Name (ARN).
        public let securityControlId: String?

        @inlinable
        public init(securityControlId: String? = nil) {
            self.securityControlId = securityControlId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.securityControlId, key: "SecurityControlId")
        }

        public func validate(name: String) throws {
            try self.validate(self.securityControlId, name: "securityControlId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSecurityControlDefinitionResponse: AWSDecodableShape {
        public let securityControlDefinition: SecurityControlDefinition?

        @inlinable
        public init(securityControlDefinition: SecurityControlDefinition? = nil) {
            self.securityControlDefinition = securityControlDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case securityControlDefinition = "SecurityControlDefinition"
        }
    }

    public struct IcmpTypeCode: AWSEncodableShape & AWSDecodableShape {
        /// The ICMP code for which to deny or allow access. To deny or allow all codes, use the value -1.
        public let code: Int?
        /// The ICMP type for which to deny or allow access. To deny or allow all types, use the value -1.
        public let type: Int?

        @inlinable
        public init(code: Int? = nil, type: Int? = nil) {
            self.code = code
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case type = "Type"
        }
    }

    public struct ImportFindingsError: AWSDecodableShape {
        /// The code of the error returned by the BatchImportFindings operation.
        public let errorCode: String?
        /// The message of the error returned by the BatchImportFindings operation.
        public let errorMessage: String?
        /// The identifier of the finding that could not be updated.
        public let id: String?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil, id: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case id = "Id"
        }
    }

    public struct Indicator: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the indicator thatâ€™s present in the attack sequence finding.
        public let key: String?
        ///  The title describing the indicator.
        public let title: String?
        ///  The type of indicator.
        public let type: String?
        /// Values associated with each indicator key. For example, if the indicator key is SUSPICIOUS_NETWORK, then the value will be the name of the network. If the indicator key is ATTACK_TACTIC, then the value will be one of the MITRE tactics.
        public let values: [String]?

        @inlinable
        public init(key: String? = nil, title: String? = nil, type: String? = nil, values: [String]? = nil) {
            self.key = key
            self.title = title
            self.type = type
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.title, name: "title", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case title = "Title"
            case type = "Type"
            case values = "Values"
        }
    }

    public struct Insight: AWSDecodableShape {
        /// One or more attributes used to filter the findings included in the insight. You can filter by up to ten finding attributes. For each attribute, you can provide up to 20 filter values.  The insight only includes findings that match the criteria defined in the filters.
        public let filters: AwsSecurityFindingFilters?
        /// The grouping attribute for the insight's findings. Indicates how to group the matching findings, and identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.
        public let groupByAttribute: String?
        /// The ARN of a Security Hub insight.
        public let insightArn: String?
        /// The name of a Security Hub insight.
        public let name: String?

        @inlinable
        public init(filters: AwsSecurityFindingFilters? = nil, groupByAttribute: String? = nil, insightArn: String? = nil, name: String? = nil) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case insightArn = "InsightArn"
            case name = "Name"
        }
    }

    public struct InsightResultValue: AWSDecodableShape {
        /// The number of findings returned for each GroupByAttributeValue.
        public let count: Int?
        /// The value of the attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        public let groupByAttributeValue: String?

        @inlinable
        public init(count: Int? = nil, groupByAttributeValue: String? = nil) {
            self.count = count
            self.groupByAttributeValue = groupByAttributeValue
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case groupByAttributeValue = "GroupByAttributeValue"
        }
    }

    public struct InsightResults: AWSDecodableShape {
        /// The attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        public let groupByAttribute: String?
        /// The ARN of the insight whose results are returned by the GetInsightResults operation.
        public let insightArn: String?
        /// The list of insight result values returned by the GetInsightResults operation.
        public let resultValues: [InsightResultValue]?

        @inlinable
        public init(groupByAttribute: String? = nil, insightArn: String? = nil, resultValues: [InsightResultValue]? = nil) {
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.resultValues = resultValues
        }

        private enum CodingKeys: String, CodingKey {
            case groupByAttribute = "GroupByAttribute"
            case insightArn = "InsightArn"
            case resultValues = "ResultValues"
        }
    }

    public struct IntegerConfigurationOptions: AWSDecodableShape {
        ///  The Security Hub default value for a control parameter that is an integer.
        public let defaultValue: Int?
        ///  The maximum valid value for a control parameter that is an integer.
        public let max: Int?
        ///  The minimum valid value for a control parameter that is an integer.
        public let min: Int?

        @inlinable
        public init(defaultValue: Int? = nil, max: Int? = nil, min: Int? = nil) {
            self.defaultValue = defaultValue
            self.max = max
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case max = "Max"
            case min = "Min"
        }
    }

    public struct IntegerListConfigurationOptions: AWSDecodableShape {
        ///  The Security Hub default value for a control parameter that is a list of integers.
        public let defaultValue: [Int]?
        ///  The maximum valid value for a control parameter that is a list of integers.
        public let max: Int?
        ///  The maximum number of list items that an interger list control parameter can accept.
        public let maxItems: Int?
        ///  The minimum valid value for a control parameter that is a list of integers.
        public let min: Int?

        @inlinable
        public init(defaultValue: [Int]? = nil, max: Int? = nil, maxItems: Int? = nil, min: Int? = nil) {
            self.defaultValue = defaultValue
            self.max = max
            self.maxItems = maxItems
            self.min = min
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case max = "Max"
            case maxItems = "MaxItems"
            case min = "Min"
        }
    }

    public struct InternalException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct InvalidAccessException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct InvalidInputException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct Invitation: AWSDecodableShape {
        /// The account ID of the Security Hub administrator account that the invitation was sent from.
        public let accountId: String?
        /// The ID of the invitation sent to the member account.
        public let invitationId: String?
        /// The timestamp of when the invitation was sent.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var invitedAt: Date?
        /// The current status of the association between the member and administrator accounts.
        public let memberStatus: String?

        @inlinable
        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: Date? = nil, memberStatus: String? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.memberStatus = memberStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case invitationId = "InvitationId"
            case invitedAt = "InvitedAt"
            case memberStatus = "MemberStatus"
        }
    }

    public struct InviteMembersRequest: AWSEncodableShape {
        /// The list of account IDs of the Amazon Web Services accounts to invite to Security Hub as members.
        public let accountIds: [String]?

        @inlinable
        public init(accountIds: [String]? = nil) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct InviteMembersResponse: AWSDecodableShape {
        /// The list of Amazon Web Services accounts that could not be processed. For each account, the list includes the account ID and the email address.
        public let unprocessedAccounts: [Result]?

        @inlinable
        public init(unprocessedAccounts: [Result]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts = "UnprocessedAccounts"
        }
    }

    public struct IpFilter: AWSEncodableShape & AWSDecodableShape {
        /// A finding's CIDR value.
        public let cidr: String?

        @inlinable
        public init(cidr: String? = nil) {
            self.cidr = cidr
        }

        public func validate(name: String) throws {
            try self.validate(self.cidr, name: "cidr", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "Cidr"
        }
    }

    public struct IpOrganizationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The Autonomous System Number (ASN) of the internet provider
        public let asn: Int?
        /// The name of the organization that registered the ASN.
        public let asnOrg: String?
        /// The ISP information for the internet provider.
        public let isp: String?
        /// The name of the internet provider.
        public let org: String?

        @inlinable
        public init(asn: Int? = nil, asnOrg: String? = nil, isp: String? = nil, org: String? = nil) {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }

        public func validate(name: String) throws {
            try self.validate(self.asnOrg, name: "asnOrg", parent: name, pattern: "\\S")
            try self.validate(self.isp, name: "isp", parent: name, pattern: "\\S")
            try self.validate(self.org, name: "org", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case asn = "Asn"
            case asnOrg = "AsnOrg"
            case isp = "Isp"
            case org = "Org"
        }
    }

    public struct Ipv6CidrBlockAssociation: AWSEncodableShape & AWSDecodableShape {
        /// The association ID for the IPv6 CIDR block.
        public let associationId: String?
        /// Information about the state of the CIDR block. Valid values are as follows:    associating     associated     disassociating     disassociated     failed     failing
        public let cidrBlockState: String?
        /// The IPv6 CIDR block.
        public let ipv6CidrBlock: String?

        @inlinable
        public init(associationId: String? = nil, cidrBlockState: String? = nil, ipv6CidrBlock: String? = nil) {
            self.associationId = associationId
            self.cidrBlockState = cidrBlockState
            self.ipv6CidrBlock = ipv6CidrBlock
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, pattern: "\\S")
            try self.validate(self.cidrBlockState, name: "cidrBlockState", parent: name, pattern: "\\S")
            try self.validate(self.ipv6CidrBlock, name: "ipv6CidrBlock", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
            case cidrBlockState = "CidrBlockState"
            case ipv6CidrBlock = "Ipv6CidrBlock"
        }
    }

    public struct KeywordFilter: AWSEncodableShape & AWSDecodableShape {
        /// A value for the keyword.
        public let value: String?

        @inlinable
        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct LimitExceededException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct ListAutomationRulesRequest: AWSEncodableShape {
        ///  The maximum number of rules to return in the response. This currently ranges from 1 to 100.
        public let maxResults: Int?
        ///  A token to specify where to start paginating the response. This is the NextToken  from a previously truncated response. On your first call to the ListAutomationRules  API, set the value of this parameter to NULL.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAutomationRulesResponse: AWSDecodableShape {
        ///  Metadata for rules in the calling account. The response includes rules with a  RuleStatus of ENABLED and DISABLED.
        public let automationRulesMetadata: [AutomationRulesMetadata]?
        ///  A pagination token for the response.
        public let nextToken: String?

        @inlinable
        public init(automationRulesMetadata: [AutomationRulesMetadata]? = nil, nextToken: String? = nil) {
            self.automationRulesMetadata = automationRulesMetadata
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case automationRulesMetadata = "AutomationRulesMetadata"
            case nextToken = "NextToken"
        }
    }

    public struct ListConfigurationPoliciesRequest: AWSEncodableShape {
        ///  The maximum number of results that's returned by ListConfigurationPolicies in each page of the response.  When this parameter is used, ListConfigurationPolicies returns the specified number of results in a  single page and a NextToken response element. You can see the remaining results of the initial request  by sending another ListConfigurationPolicies request with the returned NextToken value. A  valid range for MaxResults is between 1 and 100.
        public let maxResults: Int?
        ///  The NextToken value that's returned from a previous paginated ListConfigurationPolicies request where  MaxResults was used but the results exceeded the value of that parameter. Pagination continues from the  MaxResults was used but the results exceeded the value of that parameter. Pagination continues from the  end of the previous response that returned the NextToken value. This value is null when  there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationPoliciesResponse: AWSDecodableShape {
        ///  Provides metadata for each of your configuration policies.
        public let configurationPolicySummaries: [ConfigurationPolicySummary]?
        ///  The NextToken value to include in the next ListConfigurationPolicies request. When the  results of a ListConfigurationPolicies request exceed MaxResults, this value can be used to  retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(configurationPolicySummaries: [ConfigurationPolicySummary]? = nil, nextToken: String? = nil) {
            self.configurationPolicySummaries = configurationPolicySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationPolicySummaries = "ConfigurationPolicySummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListConfigurationPolicyAssociationsRequest: AWSEncodableShape {
        ///  Options for filtering the ListConfigurationPolicyAssociations response. You can filter by the Amazon Resource Name (ARN) or  universally unique identifier (UUID) of a configuration, AssociationType, or AssociationStatus.
        public let filters: AssociationFilters?
        ///  The maximum number of results that's returned by ListConfigurationPolicies in each page of the response.  When this parameter is used, ListConfigurationPolicyAssociations returns the specified number of results  in a single page and a NextToken response element. You can see the remaining results of the initial  request by sending another ListConfigurationPolicyAssociations request with the returned NextToken  value. A valid range for MaxResults is between 1 and 100.
        public let maxResults: Int?
        ///  The NextToken value that's returned from a previous paginated ListConfigurationPolicyAssociations  request where MaxResults was used but the results exceeded the value of that parameter. Pagination  continues from the end of the previous response that returned the NextToken value. This value is null  when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(filters: AssociationFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListConfigurationPolicyAssociationsResponse: AWSDecodableShape {
        ///  An object that contains the details of each configuration policy association thatâ€™s returned in a  ListConfigurationPolicyAssociations request.
        public let configurationPolicyAssociationSummaries: [ConfigurationPolicyAssociationSummary]?
        ///  The NextToken value to include in the next ListConfigurationPolicyAssociations request. When  the results of a ListConfigurationPolicyAssociations request exceed MaxResults, this value  can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(configurationPolicyAssociationSummaries: [ConfigurationPolicyAssociationSummary]? = nil, nextToken: String? = nil) {
            self.configurationPolicyAssociationSummaries = configurationPolicyAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationPolicyAssociationSummaries = "ConfigurationPolicyAssociationSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListEnabledProductsForImportRequest: AWSEncodableShape {
        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListEnabledProductsForImport operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnabledProductsForImportResponse: AWSDecodableShape {
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?
        /// The list of ARNs for the resources that represent your subscriptions to products.
        public let productSubscriptions: [String]?

        @inlinable
        public init(nextToken: String? = nil, productSubscriptions: [String]? = nil) {
            self.nextToken = nextToken
            self.productSubscriptions = productSubscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case productSubscriptions = "ProductSubscriptions"
        }
    }

    public struct ListFindingAggregatorsRequest: AWSEncodableShape {
        /// The maximum number of results to return. This operation currently only returns a single result.
        public let maxResults: Int?
        /// The token returned with the previous set of results. Identifies the next set of results to return.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFindingAggregatorsResponse: AWSDecodableShape {
        /// The list of finding aggregators. This operation currently only returns a single result.
        public let findingAggregators: [FindingAggregator]?
        /// If there are more results, this is the token to provide in the next call to ListFindingAggregators. This operation currently only returns a single result.
        public let nextToken: String?

        @inlinable
        public init(findingAggregators: [FindingAggregator]? = nil, nextToken: String? = nil) {
            self.findingAggregators = findingAggregators
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregators = "FindingAggregators"
            case nextToken = "NextToken"
        }
    }

    public struct ListInvitationsRequest: AWSEncodableShape {
        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListInvitations operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInvitationsResponse: AWSDecodableShape {
        /// The details of the invitations returned by the operation.
        public let invitations: [Invitation]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations = "Invitations"
            case nextToken = "NextToken"
        }
    }

    public struct ListMembersRequest: AWSEncodableShape {
        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListMembers operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?
        /// Specifies which member accounts to include in the response based on their relationship status with the administrator account. The default value is TRUE. If OnlyAssociated is set to TRUE, the response includes member accounts whose relationship status with the administrator account is set to ENABLED. If OnlyAssociated is set to FALSE, the response includes all existing member accounts.
        public let onlyAssociated: Bool?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: Bool? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.onlyAssociated, key: "OnlyAssociated")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersResponse: AWSDecodableShape {
        /// Member details returned by the operation.
        public let members: [Member]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "Members"
            case nextToken = "NextToken"
        }
    }

    public struct ListOrganizationAdminAccountsRequest: AWSEncodableShape {
        /// The maximum number of items to return in the response.
        public let maxResults: Int?
        /// The token that is required for pagination. On your first call to the ListOrganizationAdminAccounts operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOrganizationAdminAccountsResponse: AWSDecodableShape {
        /// The list of Security Hub administrator accounts.
        public let adminAccounts: [AdminAccount]?
        /// The pagination token to use to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(adminAccounts: [AdminAccount]? = nil, nextToken: String? = nil) {
            self.adminAccounts = adminAccounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccounts = "AdminAccounts"
            case nextToken = "NextToken"
        }
    }

    public struct ListSecurityControlDefinitionsRequest: AWSEncodableShape {
        ///  An optional parameter that limits the total results of the API response to the specified number. If this parameter isn't provided in the request, the results include the first 25 security controls that apply to the specified standard. The results also include a NextToken parameter that you can use in a subsequent API call to get the next 25 controls. This repeats until all controls for the standard are returned.
        public let maxResults: Int?
        ///  Optional pagination parameter.
        public let nextToken: String?
        ///  The Amazon Resource Name (ARN) of the standard that you want to view controls for.
        public let standardsArn: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, standardsArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.standardsArn = standardsArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.standardsArn, key: "StandardsArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.standardsArn, name: "standardsArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSecurityControlDefinitionsResponse: AWSDecodableShape {
        ///  A pagination parameter that's included in the response only if it was included in the request.
        public let nextToken: String?
        ///  An array of controls that apply to the specified standard.
        public let securityControlDefinitions: [SecurityControlDefinition]?

        @inlinable
        public init(nextToken: String? = nil, securityControlDefinitions: [SecurityControlDefinition]? = nil) {
            self.nextToken = nextToken
            self.securityControlDefinitions = securityControlDefinitions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case securityControlDefinitions = "SecurityControlDefinitions"
        }
    }

    public struct ListStandardsControlAssociationsRequest: AWSEncodableShape {
        ///  An optional parameter that limits the total results of the API response to the specified number. If this parameter isn't provided in the request, the results include the first 25 standard and control associations. The results also include a NextToken parameter that you can use in a subsequent API call to get the next 25 associations. This repeats until all associations for the specified control are returned. The number of results is limited by the number of supported Security Hub standards that you've enabled in the calling account.
        public let maxResults: Int?
        ///  Optional pagination parameter.
        public let nextToken: String?
        ///  The identifier of the control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) that you  want to determine the enablement status of in each enabled standard.
        public let securityControlId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, securityControlId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.securityControlId = securityControlId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.securityControlId, key: "SecurityControlId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.securityControlId, name: "securityControlId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStandardsControlAssociationsResponse: AWSDecodableShape {
        ///  A pagination parameter that's included in the response only if it was included in the request.
        public let nextToken: String?
        ///  An array that provides the enablement status and other details for each security control that applies to each enabled standard.
        public let standardsControlAssociationSummaries: [StandardsControlAssociationSummary]?

        @inlinable
        public init(nextToken: String? = nil, standardsControlAssociationSummaries: [StandardsControlAssociationSummary]? = nil) {
            self.nextToken = nextToken
            self.standardsControlAssociationSummaries = standardsControlAssociationSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case standardsControlAssociationSummaries = "StandardsControlAssociationSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to retrieve tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:securityhub:")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with a resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LoadBalancerState: AWSEncodableShape & AWSDecodableShape {
        /// The state code. The initial state of the load balancer is provisioning. After the load balancer is fully set up and ready to route traffic, its state is active. If the load balancer could not be set up, its state is failed.
        public let code: String?
        /// A description of the state.
        public let reason: String?

        @inlinable
        public init(code: String? = nil, reason: String? = nil) {
            self.code = code
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, pattern: "\\S")
            try self.validate(self.reason, name: "reason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case reason = "Reason"
        }
    }

    public struct Malware: AWSEncodableShape & AWSDecodableShape {
        /// The name of the malware that was observed. Length Constraints: Minimum of 1. Maximum of 64.
        public let name: String?
        /// The file system path of the malware that was observed. Length Constraints: Minimum of 1. Maximum of 512.
        public let path: String?
        /// The state of the malware that was observed.
        public let state: MalwareState?
        /// The type of the malware that was observed.
        public let type: MalwareType?

        @inlinable
        public init(name: String? = nil, path: String? = nil, state: MalwareState? = nil, type: MalwareType? = nil) {
            self.name = name
            self.path = path
            self.state = state
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case path = "Path"
            case state = "State"
            case type = "Type"
        }
    }

    public struct MapFilter: AWSEncodableShape & AWSDecodableShape {
        /// The condition to apply to the key value when filtering Security Hub findings with a map filter. To search for values that have the filter value, use one of the following comparison operators:   To search for values that include the filter value, use CONTAINS. For example, for the  ResourceTags field, the filter Department CONTAINS Security matches findings that  include the value Security for the Department tag. In the same example, a finding with a value of Security team for the Department tag is a match.   To search for values that exactly match the filter value, use EQUALS. For example, for  the ResourceTags field, the filter Department EQUALS Security matches findings that  have the value Security for the Department tag.    CONTAINS and EQUALS filters on the same field are joined by OR. A  finding matches if it matches any one of those filters. For example, the filters Department CONTAINS Security OR  Department CONTAINS Finance match a finding that includes either Security,  Finance, or both values. To search for values that don't have the filter value, use one of the following comparison operators:   To search for values that exclude the filter value, use NOT_CONTAINS. For example, for  the ResourceTags field, the filter Department NOT_CONTAINS Finance matches findings  that exclude the value Finance for the Department tag.   To search for values other than the filter value, use NOT_EQUALS. For example, for the  ResourceTags field, the filter Department NOT_EQUALS Finance matches findings that  donâ€™t have the value Finance for the Department tag.    NOT_CONTAINS and NOT_EQUALS filters on the same field are joined by AND.  A finding matches only if it matches all of those filters. For example, the filters Department NOT_CONTAINS Security AND  Department NOT_CONTAINS Finance match a finding that excludes both the Security and  Finance values.  CONTAINS filters can only be used with other CONTAINS filters. NOT_CONTAINS  filters can only be used with other NOT_CONTAINS filters. You canâ€™t have both a CONTAINS filter and a NOT_CONTAINS filter on the same field.  Similarly, you canâ€™t have both an EQUALS filter and a NOT_EQUALS filter on the same field.  Combining filters in this way returns an error.   CONTAINS and NOT_CONTAINS operators can be used only with automation rules. For more information,  see Automation rules in the Security Hub User Guide.
        public let comparison: MapFilterComparison?
        /// The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
        public let key: String?
        /// The value for the key in the map filter. Filter values are case sensitive. For example, one of the values for a tag called Department might be Security. If you provide security as the filter value, then there's no match.
        public let value: String?

        @inlinable
        public init(comparison: MapFilterComparison? = nil, key: String? = nil, value: String? = nil) {
            self.comparison = comparison
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case key = "Key"
            case value = "Value"
        }
    }

    public struct Member: AWSDecodableShape {
        /// The Amazon Web Services account ID of the member account.
        public let accountId: String?
        /// The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.
        public let administratorId: String?
        /// The email address of the member account.
        public let email: String?
        /// A timestamp for the date and time when the invitation was sent to the member account.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var invitedAt: Date?
        /// This is replaced by AdministratorID. The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.
        public let masterId: String?
        /// The status of the relationship between the member account and its administrator account.  The status can have one of the following values:    Created - Indicates that the administrator account added the member account, but has not yet invited the member account.    Invited - Indicates that the administrator account invited the member account. The member account has not yet responded to the invitation.    Enabled - Indicates that the member account is currently active. For manually invited member accounts, indicates that the member account accepted the invitation.    Removed - Indicates that the administrator account disassociated the member account.    Resigned - Indicates that the member account disassociated themselves from the administrator account.    Deleted - Indicates that the administrator account deleted the member account.    AccountSuspended - Indicates that an organization account was suspended from Amazon Web Services at the same time that the administrator account tried to enable the organization account as a member account.
        public let memberStatus: String?
        /// The timestamp for the date and time when the member account was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(accountId: String? = nil, administratorId: String? = nil, email: String? = nil, invitedAt: Date? = nil, memberStatus: String? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.administratorId = administratorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = nil
            self.memberStatus = memberStatus
            self.updatedAt = updatedAt
        }

        @available(*, deprecated, message: "Members masterId have been deprecated")
        @inlinable
        public init(accountId: String? = nil, administratorId: String? = nil, email: String? = nil, invitedAt: Date? = nil, masterId: String? = nil, memberStatus: String? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.administratorId = administratorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.memberStatus = memberStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case administratorId = "AdministratorId"
            case email = "Email"
            case invitedAt = "InvitedAt"
            case masterId = "MasterId"
            case memberStatus = "MemberStatus"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct Network: AWSEncodableShape & AWSDecodableShape {
        /// The destination domain of network-related information about a finding. Length Constraints: Minimum of 1. Maximum of 128.
        public let destinationDomain: String?
        /// The destination IPv4 address of network-related information about a finding.
        public let destinationIpV4: String?
        /// The destination IPv6 address of network-related information about a finding.
        public let destinationIpV6: String?
        /// The destination port of network-related information about a finding.
        public let destinationPort: Int?
        /// The direction of network traffic associated with a finding.
        public let direction: NetworkDirection?
        /// The range of open ports that is present on the network.
        public let openPortRange: PortRange?
        /// The protocol of network-related information about a finding. Length Constraints: Minimum of 1. Maximum of 16.
        public let `protocol`: String?
        /// The source domain of network-related information about a finding. Length Constraints: Minimum of 1. Maximum of 128.
        public let sourceDomain: String?
        /// The source IPv4 address of network-related information about a finding.
        public let sourceIpV4: String?
        /// The source IPv6 address of network-related information about a finding.
        public let sourceIpV6: String?
        /// The source media access control (MAC) address of network-related information about a finding.
        public let sourceMac: String?
        /// The source port of network-related information about a finding.
        public let sourcePort: Int?

        @inlinable
        public init(destinationDomain: String? = nil, destinationIpV4: String? = nil, destinationIpV6: String? = nil, destinationPort: Int? = nil, direction: NetworkDirection? = nil, openPortRange: PortRange? = nil, protocol: String? = nil, sourceDomain: String? = nil, sourceIpV4: String? = nil, sourceIpV6: String? = nil, sourceMac: String? = nil, sourcePort: Int? = nil) {
            self.destinationDomain = destinationDomain
            self.destinationIpV4 = destinationIpV4
            self.destinationIpV6 = destinationIpV6
            self.destinationPort = destinationPort
            self.direction = direction
            self.openPortRange = openPortRange
            self.`protocol` = `protocol`
            self.sourceDomain = sourceDomain
            self.sourceIpV4 = sourceIpV4
            self.sourceIpV6 = sourceIpV6
            self.sourceMac = sourceMac
            self.sourcePort = sourcePort
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationDomain, name: "destinationDomain", parent: name, pattern: "\\S")
            try self.validate(self.destinationIpV4, name: "destinationIpV4", parent: name, pattern: "\\S")
            try self.validate(self.destinationIpV6, name: "destinationIpV6", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.validate(self.sourceDomain, name: "sourceDomain", parent: name, pattern: "\\S")
            try self.validate(self.sourceIpV4, name: "sourceIpV4", parent: name, pattern: "\\S")
            try self.validate(self.sourceIpV6, name: "sourceIpV6", parent: name, pattern: "\\S")
            try self.validate(self.sourceMac, name: "sourceMac", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationDomain = "DestinationDomain"
            case destinationIpV4 = "DestinationIpV4"
            case destinationIpV6 = "DestinationIpV6"
            case destinationPort = "DestinationPort"
            case direction = "Direction"
            case openPortRange = "OpenPortRange"
            case `protocol` = "Protocol"
            case sourceDomain = "SourceDomain"
            case sourceIpV4 = "SourceIpV4"
            case sourceIpV6 = "SourceIpV6"
            case sourceMac = "SourceMac"
            case sourcePort = "SourcePort"
        }
    }

    public struct NetworkAutonomousSystem: AWSEncodableShape & AWSDecodableShape {
        ///  The name associated with the AS.
        public let name: String?
        ///  The unique number that identifies the AS.
        public let number: Int?

        @inlinable
        public init(name: String? = nil, number: Int? = nil) {
            self.name = name
            self.number = number
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case number = "Number"
        }
    }

    public struct NetworkConnection: AWSEncodableShape & AWSDecodableShape {
        ///  The direction in which the network traffic is flowing.
        public let direction: ConnectionDirection?

        @inlinable
        public init(direction: ConnectionDirection? = nil) {
            self.direction = direction
        }

        private enum CodingKeys: String, CodingKey {
            case direction = "Direction"
        }
    }

    public struct NetworkConnectionAction: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the network connection attempt was blocked.
        public let blocked: Bool?
        /// The direction of the network connection request (IN or OUT).
        public let connectionDirection: String?
        /// Information about the port on the EC2 instance.
        public let localPortDetails: ActionLocalPortDetails?
        /// The protocol used to make the network connection request. Length Constraints: Minimum length of 1. Maximum length of 64.
        public let `protocol`: String?
        /// Information about the remote IP address that issued the network connection request.
        public let remoteIpDetails: ActionRemoteIpDetails?
        /// Information about the port on the remote IP address.
        public let remotePortDetails: ActionRemotePortDetails?

        @inlinable
        public init(blocked: Bool? = nil, connectionDirection: String? = nil, localPortDetails: ActionLocalPortDetails? = nil, protocol: String? = nil, remoteIpDetails: ActionRemoteIpDetails? = nil, remotePortDetails: ActionRemotePortDetails? = nil) {
            self.blocked = blocked
            self.connectionDirection = connectionDirection
            self.localPortDetails = localPortDetails
            self.`protocol` = `protocol`
            self.remoteIpDetails = remoteIpDetails
            self.remotePortDetails = remotePortDetails
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionDirection, name: "connectionDirection", parent: name, pattern: "\\S")
            try self.localPortDetails?.validate(name: "\(name).localPortDetails")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.remoteIpDetails?.validate(name: "\(name).remoteIpDetails")
            try self.remotePortDetails?.validate(name: "\(name).remotePortDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "Blocked"
            case connectionDirection = "ConnectionDirection"
            case localPortDetails = "LocalPortDetails"
            case `protocol` = "Protocol"
            case remoteIpDetails = "RemoteIpDetails"
            case remotePortDetails = "RemotePortDetails"
        }
    }

    public struct NetworkEndpoint: AWSEncodableShape & AWSDecodableShape {
        ///  The Autonomous System Number (ASN) of the network endpoint.
        public let autonomousSystem: NetworkAutonomousSystem?
        ///  Information about the network connection.
        public let connection: NetworkConnection?
        ///  The domain information for the network endpoint.
        public let domain: String?
        ///  The identifier of the network endpoint involved in the attack sequence.
        public let id: String?
        ///  The IP address used in the network endpoint.
        public let ip: String?
        ///  Information about the location of the network endpoint.
        public let location: NetworkGeoLocation?
        ///  The port number associated with the network endpoint.
        public let port: Int?

        @inlinable
        public init(autonomousSystem: NetworkAutonomousSystem? = nil, connection: NetworkConnection? = nil, domain: String? = nil, id: String? = nil, ip: String? = nil, location: NetworkGeoLocation? = nil, port: Int? = nil) {
            self.autonomousSystem = autonomousSystem
            self.connection = connection
            self.domain = domain
            self.id = id
            self.ip = ip
            self.location = location
            self.port = port
        }

        public func validate(name: String) throws {
            try self.autonomousSystem?.validate(name: "\(name).autonomousSystem")
            try self.validate(self.domain, name: "domain", parent: name, pattern: "\\S")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.ip, name: "ip", parent: name, pattern: "\\S")
            try self.location?.validate(name: "\(name).location")
        }

        private enum CodingKeys: String, CodingKey {
            case autonomousSystem = "AutonomousSystem"
            case connection = "Connection"
            case domain = "Domain"
            case id = "Id"
            case ip = "Ip"
            case location = "Location"
            case port = "Port"
        }
    }

    public struct NetworkGeoLocation: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the city.
        public let city: String?
        ///  The name of the country.
        public let country: String?
        ///  The latitude information of the endpoint location.
        public let lat: Double?
        ///  The longitude information of the endpoint location.
        public let lon: Double?

        @inlinable
        public init(city: String? = nil, country: String? = nil, lat: Double? = nil, lon: Double? = nil) {
            self.city = city
            self.country = country
            self.lat = lat
            self.lon = lon
        }

        public func validate(name: String) throws {
            try self.validate(self.city, name: "city", parent: name, pattern: "\\S")
            try self.validate(self.country, name: "country", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case city = "City"
            case country = "Country"
            case lat = "Lat"
            case lon = "Lon"
        }
    }

    public struct NetworkHeader: AWSEncodableShape & AWSDecodableShape {
        /// Information about the destination of the component.
        public let destination: NetworkPathComponentDetails?
        /// The protocol used for the component. Length Constraints: Minimum of 1. Maximum of 16.
        public let `protocol`: String?
        /// Information about the origin of the component.
        public let source: NetworkPathComponentDetails?

        @inlinable
        public init(destination: NetworkPathComponentDetails? = nil, protocol: String? = nil, source: NetworkPathComponentDetails? = nil) {
            self.destination = destination
            self.`protocol` = `protocol`
            self.source = source
        }

        public func validate(name: String) throws {
            try self.destination?.validate(name: "\(name).destination")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.source?.validate(name: "\(name).source")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case `protocol` = "Protocol"
            case source = "Source"
        }
    }

    public struct NetworkPathComponent: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of a component in the network path. Length Constraints: Minimum of 1. Maximum of 32.
        public let componentId: String?
        /// The type of component. Length Constraints: Minimum of 1. Maximum of 32.
        public let componentType: String?
        /// Information about the component that comes after the current component in the network path.
        public let egress: NetworkHeader?
        /// Information about the component that comes before the current node in the network path.
        public let ingress: NetworkHeader?

        @inlinable
        public init(componentId: String? = nil, componentType: String? = nil, egress: NetworkHeader? = nil, ingress: NetworkHeader? = nil) {
            self.componentId = componentId
            self.componentType = componentType
            self.egress = egress
            self.ingress = ingress
        }

        public func validate(name: String) throws {
            try self.validate(self.componentId, name: "componentId", parent: name, pattern: "\\S")
            try self.validate(self.componentType, name: "componentType", parent: name, pattern: "\\S")
            try self.egress?.validate(name: "\(name).egress")
            try self.ingress?.validate(name: "\(name).ingress")
        }

        private enum CodingKeys: String, CodingKey {
            case componentId = "ComponentId"
            case componentType = "ComponentType"
            case egress = "Egress"
            case ingress = "Ingress"
        }
    }

    public struct NetworkPathComponentDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IP addresses of the destination.
        public let address: [String]?
        /// A list of port ranges for the destination.
        public let portRanges: [PortRange]?

        @inlinable
        public init(address: [String]? = nil, portRanges: [PortRange]? = nil) {
            self.address = address
            self.portRanges = portRanges
        }

        public func validate(name: String) throws {
            try self.address?.forEach {
                try validate($0, name: "address[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case portRanges = "PortRanges"
        }
    }

    public struct Note: AWSEncodableShape & AWSDecodableShape {
        /// The text of a note. Length Constraints: Minimum of 1. Maximum of 512.
        public let text: String?
        /// A timestamp that indicates when the note was updated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let updatedAt: String?
        /// The principal that created a note.
        public let updatedBy: String?

        @inlinable
        public init(text: String? = nil, updatedAt: String? = nil, updatedBy: String? = nil) {
            self.text = text
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, pattern: "\\S")
            try self.validate(self.updatedAt, name: "updatedAt", parent: name, pattern: "\\S")
            try self.validate(self.updatedBy, name: "updatedBy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case updatedAt = "UpdatedAt"
            case updatedBy = "UpdatedBy"
        }
    }

    public struct NoteUpdate: AWSEncodableShape & AWSDecodableShape {
        /// The updated note text.
        public let text: String?
        /// The principal that updated the note.
        public let updatedBy: String?

        @inlinable
        public init(text: String? = nil, updatedBy: String? = nil) {
            self.text = text
            self.updatedBy = updatedBy
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, pattern: "\\S")
            try self.validate(self.updatedBy, name: "updatedBy", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case updatedBy = "UpdatedBy"
        }
    }

    public struct NumberFilter: AWSEncodableShape & AWSDecodableShape {
        /// The equal-to condition to be applied to a single field when querying for findings.
        public let eq: Double?
        ///  The greater-than condition to be applied to a single field when querying for findings.
        public let gt: Double?
        /// The greater-than-equal condition to be applied to a single field when querying for findings.
        public let gte: Double?
        ///  The less-than condition to be applied to a single field when querying for findings.
        public let lt: Double?
        /// The less-than-equal condition to be applied to a single field when querying for findings.
        public let lte: Double?

        @inlinable
        public init(eq: Double? = nil, gt: Double? = nil, gte: Double? = nil, lt: Double? = nil, lte: Double? = nil) {
            self.eq = eq
            self.gt = gt
            self.gte = gte
            self.lt = lt
            self.lte = lte
        }

        private enum CodingKeys: String, CodingKey {
            case eq = "Eq"
            case gt = "Gt"
            case gte = "Gte"
            case lt = "Lt"
            case lte = "Lte"
        }
    }

    public struct Occurrences: AWSEncodableShape & AWSDecodableShape {
        /// Occurrences of sensitive data detected in Microsoft Excel workbooks, comma-separated value (CSV) files, or tab-separated value (TSV) files.
        public let cells: [Cell]?
        /// Occurrences of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.
        public let lineRanges: [Range]?
        /// Occurrences of sensitive data detected in a binary text file.
        public let offsetRanges: [Range]?
        /// Occurrences of sensitive data in an Adobe Portable Document Format (PDF) file.
        public let pages: [Page]?
        /// Occurrences of sensitive data in an Apache Avro object container or an Apache Parquet file.
        public let records: [Record]?

        @inlinable
        public init(cells: [Cell]? = nil, lineRanges: [Range]? = nil, offsetRanges: [Range]? = nil, pages: [Page]? = nil, records: [Record]? = nil) {
            self.cells = cells
            self.lineRanges = lineRanges
            self.offsetRanges = offsetRanges
            self.pages = pages
            self.records = records
        }

        public func validate(name: String) throws {
            try self.cells?.forEach {
                try $0.validate(name: "\(name).cells[]")
            }
            try self.records?.forEach {
                try $0.validate(name: "\(name).records[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cells = "Cells"
            case lineRanges = "LineRanges"
            case offsetRanges = "OffsetRanges"
            case pages = "Pages"
            case records = "Records"
        }
    }

    public struct OrganizationConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  Indicates whether the organization uses local or central configuration.  If you use local configuration, the  Security Hub delegated administrator can set AutoEnable to true and  AutoEnableStandards to DEFAULT. This automatically enables Security Hub and  default security standards in new organization accounts. These new account settings must be set separately in  each Amazon Web Services Region, and settings may be different in each Region.   If you use central configuration, the delegated administrator can create configuration policies. Configuration  policies can be used to configure Security Hub, security standards, and security controls in multiple  accounts and Regions. If you want new organization accounts to use a specific configuration, you can create a  configuration policy and associate it with the root or specific organizational units (OUs). New accounts will  inherit the policy from the root or their assigned OU.
        public let configurationType: OrganizationConfigurationConfigurationType?
        ///  Describes whether central configuration could be enabled as the ConfigurationType for the  organization. If your ConfigurationType is local configuration, then the value of Status  is always ENABLED.
        public let status: OrganizationConfigurationStatus?
        ///  Provides an explanation if the value of Status is equal to FAILED when ConfigurationType  is equal to CENTRAL.
        public let statusMessage: String?

        @inlinable
        public init(configurationType: OrganizationConfigurationConfigurationType? = nil, status: OrganizationConfigurationStatus? = nil, statusMessage: String? = nil) {
            self.configurationType = configurationType
            self.status = status
            self.statusMessage = statusMessage
        }

        public func validate(name: String) throws {
            try self.validate(self.statusMessage, name: "statusMessage", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationType = "ConfigurationType"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct Page: AWSEncodableShape & AWSDecodableShape {
        /// An occurrence of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.
        public let lineRange: Range?
        /// An occurrence of sensitive data detected in a binary text file.
        public let offsetRange: Range?
        /// The page number of the page that contains the sensitive data.
        public let pageNumber: Int64?

        @inlinable
        public init(lineRange: Range? = nil, offsetRange: Range? = nil, pageNumber: Int64? = nil) {
            self.lineRange = lineRange
            self.offsetRange = offsetRange
            self.pageNumber = pageNumber
        }

        private enum CodingKeys: String, CodingKey {
            case lineRange = "LineRange"
            case offsetRange = "OffsetRange"
            case pageNumber = "PageNumber"
        }
    }

    public struct ParameterConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The current value of a control parameter.
        public let value: ParameterValue?
        ///  Identifies whether a control parameter uses a custom user-defined value or subscribes to the default  Security Hub behavior. When ValueType is set equal to DEFAULT, the default  behavior can be a specific Security Hub default value, or the default behavior can be to ignore a specific parameter.  When ValueType is set equal to DEFAULT, Security Hub ignores user-provided input for  the Value field. When ValueType is set equal to CUSTOM, the Value field can't be empty.
        public let valueType: ParameterValueType?

        @inlinable
        public init(value: ParameterValue? = nil, valueType: ParameterValueType? = nil) {
            self.value = value
            self.valueType = valueType
        }

        public func validate(name: String) throws {
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
            case valueType = "ValueType"
        }
    }

    public struct ParameterDefinition: AWSDecodableShape {
        ///  The options for customizing a control parameter. Customization options vary based on the data type of the parameter.
        public let configurationOptions: ConfigurationOptions?
        ///  Description of a control parameter.
        public let description: String?

        @inlinable
        public init(configurationOptions: ConfigurationOptions? = nil, description: String? = nil) {
            self.configurationOptions = configurationOptions
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case configurationOptions = "ConfigurationOptions"
            case description = "Description"
        }
    }

    public struct PatchSummary: AWSEncodableShape & AWSDecodableShape {
        /// The number of patches from the compliance standard that failed to install. The value can be an integer from 0 to 100000.
        public let failedCount: Int?
        /// The identifier of the compliance standard that was used to determine the patch compliance status. Length Constraints: Minimum length of 1. Maximum length of 256.
        public let id: String?
        /// The number of patches from the compliance standard that were installed successfully. The value can be an integer from 0 to 100000.
        public let installedCount: Int?
        /// The number of installed patches that are not part of the compliance standard. The value can be an integer from 0 to 100000.
        public let installedOtherCount: Int?
        /// The number of patches that were applied, but that require the instance to be rebooted in order to be marked as installed. The value can be an integer from 0 to 100000.
        public let installedPendingReboot: Int?
        /// The number of patches that are installed but are also on a list of patches that the customer rejected. The value can be an integer from 0 to 100000.
        public let installedRejectedCount: Int?
        /// The number of patches that are part of the compliance standard but are not installed. The count includes patches that failed to install. The value can be an integer from 0 to 100000.
        public let missingCount: Int?
        /// The type of patch operation performed. For Patch Manager, the values are SCAN and INSTALL. Length Constraints: Minimum length of 1. Maximum length of 256.
        public let operation: String?
        /// Indicates when the operation completed. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let operationEndTime: String?
        /// Indicates when the operation started. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let operationStartTime: String?
        /// The reboot option specified for the instance. Length Constraints: Minimum length of 1. Maximum length of 256.
        public let rebootOption: String?

        @inlinable
        public init(failedCount: Int? = nil, id: String? = nil, installedCount: Int? = nil, installedOtherCount: Int? = nil, installedPendingReboot: Int? = nil, installedRejectedCount: Int? = nil, missingCount: Int? = nil, operation: String? = nil, operationEndTime: String? = nil, operationStartTime: String? = nil, rebootOption: String? = nil) {
            self.failedCount = failedCount
            self.id = id
            self.installedCount = installedCount
            self.installedOtherCount = installedOtherCount
            self.installedPendingReboot = installedPendingReboot
            self.installedRejectedCount = installedRejectedCount
            self.missingCount = missingCount
            self.operation = operation
            self.operationEndTime = operationEndTime
            self.operationStartTime = operationStartTime
            self.rebootOption = rebootOption
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.operation, name: "operation", parent: name, pattern: "\\S")
            try self.validate(self.operationEndTime, name: "operationEndTime", parent: name, pattern: "\\S")
            try self.validate(self.operationStartTime, name: "operationStartTime", parent: name, pattern: "\\S")
            try self.validate(self.rebootOption, name: "rebootOption", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case failedCount = "FailedCount"
            case id = "Id"
            case installedCount = "InstalledCount"
            case installedOtherCount = "InstalledOtherCount"
            case installedPendingReboot = "InstalledPendingReboot"
            case installedRejectedCount = "InstalledRejectedCount"
            case missingCount = "MissingCount"
            case operation = "Operation"
            case operationEndTime = "OperationEndTime"
            case operationStartTime = "OperationStartTime"
            case rebootOption = "RebootOption"
        }
    }

    public struct PortProbeAction: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the port probe was blocked.
        public let blocked: Bool?
        /// Information about the ports affected by the port probe.
        public let portProbeDetails: [PortProbeDetail]?

        @inlinable
        public init(blocked: Bool? = nil, portProbeDetails: [PortProbeDetail]? = nil) {
            self.blocked = blocked
            self.portProbeDetails = portProbeDetails
        }

        public func validate(name: String) throws {
            try self.portProbeDetails?.forEach {
                try $0.validate(name: "\(name).portProbeDetails[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case blocked = "Blocked"
            case portProbeDetails = "PortProbeDetails"
        }
    }

    public struct PortProbeDetail: AWSEncodableShape & AWSDecodableShape {
        /// Provides information about the IP address where the scanned port is located.
        public let localIpDetails: ActionLocalIpDetails?
        /// Provides information about the port that was scanned.
        public let localPortDetails: ActionLocalPortDetails?
        /// Provides information about the remote IP address that performed the scan.
        public let remoteIpDetails: ActionRemoteIpDetails?

        @inlinable
        public init(localIpDetails: ActionLocalIpDetails? = nil, localPortDetails: ActionLocalPortDetails? = nil, remoteIpDetails: ActionRemoteIpDetails? = nil) {
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.remoteIpDetails = remoteIpDetails
        }

        public func validate(name: String) throws {
            try self.localIpDetails?.validate(name: "\(name).localIpDetails")
            try self.localPortDetails?.validate(name: "\(name).localPortDetails")
            try self.remoteIpDetails?.validate(name: "\(name).remoteIpDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case localIpDetails = "LocalIpDetails"
            case localPortDetails = "LocalPortDetails"
            case remoteIpDetails = "RemoteIpDetails"
        }
    }

    public struct PortRange: AWSEncodableShape & AWSDecodableShape {
        /// The first port in the port range.
        public let begin: Int?
        /// The last port in the port range.
        public let end: Int?

        @inlinable
        public init(begin: Int? = nil, end: Int? = nil) {
            self.begin = begin
            self.end = end
        }

        private enum CodingKeys: String, CodingKey {
            case begin = "Begin"
            case end = "End"
        }
    }

    public struct PortRangeFromTo: AWSEncodableShape & AWSDecodableShape {
        /// The first port in the port range.
        public let from: Int?
        /// The last port in the port range.
        public let to: Int?

        @inlinable
        public init(from: Int? = nil, to: Int? = nil) {
            self.from = from
            self.to = to
        }

        private enum CodingKeys: String, CodingKey {
            case from = "From"
            case to = "To"
        }
    }

    public struct ProcessDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates when the process was launched. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let launchedAt: String?
        /// The name of the process. Length Constraints: Minimum of 1. Maximum of 64.
        public let name: String?
        /// The parent process ID. This field accepts positive integers between O and 2147483647.
        public let parentPid: Int?
        /// The path to the process executable. Length Constraints: Minimum of 1. Maximum of 512.
        public let path: String?
        /// The process ID.
        public let pid: Int?
        /// Indicates when the process was terminated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let terminatedAt: String?

        @inlinable
        public init(launchedAt: String? = nil, name: String? = nil, parentPid: Int? = nil, path: String? = nil, pid: Int? = nil, terminatedAt: String? = nil) {
            self.launchedAt = launchedAt
            self.name = name
            self.parentPid = parentPid
            self.path = path
            self.pid = pid
            self.terminatedAt = terminatedAt
        }

        public func validate(name: String) throws {
            try self.validate(self.launchedAt, name: "launchedAt", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.path, name: "path", parent: name, pattern: "\\S")
            try self.validate(self.terminatedAt, name: "terminatedAt", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case launchedAt = "LaunchedAt"
            case name = "Name"
            case parentPid = "ParentPid"
            case path = "Path"
            case pid = "Pid"
            case terminatedAt = "TerminatedAt"
        }
    }

    public struct Product: AWSDecodableShape {
        /// The URL to the service or product documentation about the integration with Security Hub, including how to activate the integration.
        public let activationUrl: String?
        /// The categories assigned to the product.
        public let categories: [String]?
        /// The name of the company that provides the product.
        public let companyName: String?
        /// A description of the product.
        public let description: String?
        /// The types of integration that the product supports. Available values are the following.    SEND_FINDINGS_TO_SECURITY_HUB - The integration sends findings to Security Hub.    RECEIVE_FINDINGS_FROM_SECURITY_HUB - The integration receives findings from Security Hub.    UPDATE_FINDINGS_IN_SECURITY_HUB - The integration does not send new findings to Security Hub, but does make updates to the findings that it receives from Security Hub.
        public let integrationTypes: [IntegrationType]?
        /// For integrations with Amazon Web Services services, the Amazon Web Services Console URL from which to activate the service. For integrations with third-party products, the Amazon Web Services Marketplace URL from which to subscribe to or purchase the product.
        public let marketplaceUrl: String?
        /// The ARN assigned to the product.
        public let productArn: String?
        /// The name of the product.
        public let productName: String?
        /// The resource policy associated with the product.
        public let productSubscriptionResourcePolicy: String?

        @inlinable
        public init(activationUrl: String? = nil, categories: [String]? = nil, companyName: String? = nil, description: String? = nil, integrationTypes: [IntegrationType]? = nil, marketplaceUrl: String? = nil, productArn: String? = nil, productName: String? = nil, productSubscriptionResourcePolicy: String? = nil) {
            self.activationUrl = activationUrl
            self.categories = categories
            self.companyName = companyName
            self.description = description
            self.integrationTypes = integrationTypes
            self.marketplaceUrl = marketplaceUrl
            self.productArn = productArn
            self.productName = productName
            self.productSubscriptionResourcePolicy = productSubscriptionResourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case activationUrl = "ActivationUrl"
            case categories = "Categories"
            case companyName = "CompanyName"
            case description = "Description"
            case integrationTypes = "IntegrationTypes"
            case marketplaceUrl = "MarketplaceUrl"
            case productArn = "ProductArn"
            case productName = "ProductName"
            case productSubscriptionResourcePolicy = "ProductSubscriptionResourcePolicy"
        }
    }

    public struct PropagatingVgwSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The ID of the virtual private gateway.
        public let gatewayId: String?

        @inlinable
        public init(gatewayId: String? = nil) {
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayId = "GatewayId"
        }
    }

    public struct Range: AWSEncodableShape & AWSDecodableShape {
        /// The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.
        public let end: Int64?
        /// The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.
        public let start: Int64?
        /// In the line where the sensitive data starts, the column within the line where the sensitive data starts.
        public let startColumn: Int64?

        @inlinable
        public init(end: Int64? = nil, start: Int64? = nil, startColumn: Int64? = nil) {
            self.end = end
            self.start = start
            self.startColumn = startColumn
        }

        private enum CodingKeys: String, CodingKey {
            case end = "End"
            case start = "Start"
            case startColumn = "StartColumn"
        }
    }

    public struct Recommendation: AWSEncodableShape & AWSDecodableShape {
        /// Describes the recommended steps to take to remediate an issue identified in a finding. Length Constraints: Minimum of 1 length. Maximum of 512 length.
        public let text: String?
        /// A URL to a page or site that contains information about how to remediate a finding.
        public let url: String?

        @inlinable
        public init(text: String? = nil, url: String? = nil) {
            self.text = text
            self.url = url
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, pattern: "\\S")
            try self.validate(self.url, name: "url", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
            case url = "Url"
        }
    }

    public struct Record: AWSEncodableShape & AWSDecodableShape {
        /// The path, as a JSONPath expression, to the field in the record that contains the data. If the field name is longer than 20 characters, it is truncated. If the path is longer than 250 characters, it is truncated.
        public let jsonPath: String?
        /// The record index, starting from 0, for the record that contains the data.
        public let recordIndex: Int64?

        @inlinable
        public init(jsonPath: String? = nil, recordIndex: Int64? = nil) {
            self.jsonPath = jsonPath
            self.recordIndex = recordIndex
        }

        public func validate(name: String) throws {
            try self.validate(self.jsonPath, name: "jsonPath", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case jsonPath = "JsonPath"
            case recordIndex = "RecordIndex"
        }
    }

    public struct RelatedFinding: AWSEncodableShape & AWSDecodableShape {
        /// The product-generated identifier for a related finding.
        public let id: String?
        /// The ARN of the product that generated a related finding.
        public let productArn: String?

        @inlinable
        public init(id: String? = nil, productArn: String? = nil) {
            self.id = id
            self.productArn = productArn
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case productArn = "ProductArn"
        }
    }

    public struct Remediation: AWSEncodableShape & AWSDecodableShape {
        /// A recommendation on the steps to take to remediate the issue identified by a finding.
        public let recommendation: Recommendation?

        @inlinable
        public init(recommendation: Recommendation? = nil) {
            self.recommendation = recommendation
        }

        public func validate(name: String) throws {
            try self.recommendation?.validate(name: "\(name).recommendation")
        }

        private enum CodingKeys: String, CodingKey {
            case recommendation = "Recommendation"
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the application that is related to a finding.
        public let applicationArn: String?
        ///  The name of the application that is related to a finding.
        public let applicationName: String?
        /// Contains information about sensitive data that was detected on the resource.
        public let dataClassification: DataClassificationDetails?
        /// Additional details about the resource related to a finding.
        public let details: ResourceDetails?
        /// The canonical identifier for the given resource type.
        public let id: String?
        /// The canonical Amazon Web Services partition name that the Region is assigned to.
        public let partition: Partition?
        /// The canonical Amazon Web Services external Region name where this resource is located. Length Constraints: Minimum length of 1. Maximum length of 16.
        public let region: String?
        /// Identifies the role of the resource in the finding. A resource is either the actor or target of the finding activity,
        public let resourceRole: String?
        /// A list of Amazon Web Services tags associated with a resource at the time the finding was processed. Tags must follow Amazon Web Services tag naming limits and requirements.
        public let tags: [String: String]?
        /// The type of the resource that details are provided for. If possible, set Type to one of the supported resource types. For example, if the resource is an EC2 instance, then set Type to AwsEc2Instance. If the resource does not match any of the provided types, then set Type to Other.  Length Constraints: Minimum length of 1. Maximum length of 256.
        public let type: String?

        @inlinable
        public init(applicationArn: String? = nil, applicationName: String? = nil, dataClassification: DataClassificationDetails? = nil, details: ResourceDetails? = nil, id: String? = nil, partition: Partition? = nil, region: String? = nil, resourceRole: String? = nil, tags: [String: String]? = nil, type: String? = nil) {
            self.applicationArn = applicationArn
            self.applicationName = applicationName
            self.dataClassification = dataClassification
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.resourceRole = resourceRole
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationArn, name: "applicationArn", parent: name, pattern: "\\S")
            try self.validate(self.applicationName, name: "applicationName", parent: name, pattern: "\\S")
            try self.dataClassification?.validate(name: "\(name).dataClassification")
            try self.details?.validate(name: "\(name).details")
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.region, name: "region", parent: name, pattern: "\\S")
            try self.validate(self.resourceRole, name: "resourceRole", parent: name, pattern: "\\S")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "ApplicationArn"
            case applicationName = "ApplicationName"
            case dataClassification = "DataClassification"
            case details = "Details"
            case id = "Id"
            case partition = "Partition"
            case region = "Region"
            case resourceRole = "ResourceRole"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct ResourceConflictException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct ResourceDetails: AWSEncodableShape & AWSDecodableShape {
        ///  Provides details about AppSync message broker. A message broker allows software applications and  components to communicate using various programming languages, operating systems, and formal messaging protocols.
        public let awsAmazonMqBroker: AwsAmazonMqBrokerDetails?
        /// Provides information about a REST API in version 1 of Amazon API Gateway.
        public let awsApiGatewayRestApi: AwsApiGatewayRestApiDetails?
        /// Provides information about a version 1 Amazon API Gateway stage.
        public let awsApiGatewayStage: AwsApiGatewayStageDetails?
        /// Provides information about a version 2 API in Amazon API Gateway.
        public let awsApiGatewayV2Api: AwsApiGatewayV2ApiDetails?
        /// Provides information about a version 2 stage for Amazon API Gateway.
        public let awsApiGatewayV2Stage: AwsApiGatewayV2StageDetails?
        ///  Provides details about an AppSync Graph QL API, which lets you query multiple databases, microservices,  and APIs from a single GraphQL endpoint.
        public let awsAppSyncGraphQlApi: AwsAppSyncGraphQlApiDetails?
        ///  Provides information about an Amazon Athena workgroup. A workgroup helps you separate users, teams,  applications, or workloads. It also helps you set limits on data processing and track costs.
        public let awsAthenaWorkGroup: AwsAthenaWorkGroupDetails?
        /// Details for an autoscaling group.
        public let awsAutoScalingAutoScalingGroup: AwsAutoScalingAutoScalingGroupDetails?
        /// Provides details about a launch configuration.
        public let awsAutoScalingLaunchConfiguration: AwsAutoScalingLaunchConfigurationDetails?
        /// Provides details about an Backup backup plan.
        public let awsBackupBackupPlan: AwsBackupBackupPlanDetails?
        /// Provides details about an Backup backup vault.
        public let awsBackupBackupVault: AwsBackupBackupVaultDetails?
        /// Provides details about an Backup backup, or recovery point.
        public let awsBackupRecoveryPoint: AwsBackupRecoveryPointDetails?
        /// Provides details about an Certificate Manager certificate.
        public let awsCertificateManagerCertificate: AwsCertificateManagerCertificateDetails?
        /// Details about an CloudFormation stack. A stack is a collection of Amazon Web Services resources that you can manage as a single unit.
        public let awsCloudFormationStack: AwsCloudFormationStackDetails?
        /// Details about a CloudFront distribution.
        public let awsCloudFrontDistribution: AwsCloudFrontDistributionDetails?
        /// Provides details about a CloudTrail trail.
        public let awsCloudTrailTrail: AwsCloudTrailTrailDetails?
        /// Details about an Amazon CloudWatch alarm. An alarm allows you to monitor and receive alerts about your Amazon Web Services resources and applications across multiple Regions.
        public let awsCloudWatchAlarm: AwsCloudWatchAlarmDetails?
        /// Details for an CodeBuild project.
        public let awsCodeBuildProject: AwsCodeBuildProjectDetails?
        ///  Provides details about an Database Migration Service (DMS) endpoint. An endpoint provides connection, data
        /// store type, and location information about your data store.
        public let awsDmsEndpoint: AwsDmsEndpointDetails?
        ///  Provides details about an DMS replication instance. DMS uses a replication instance to connect to your
        /// source data store, read the source data, and format the data for consumption by the target data store.
        public let awsDmsReplicationInstance: AwsDmsReplicationInstanceDetails?
        ///  Provides details about an DMS replication task. A replication task moves a set of data from the source
        /// endpoint to the target endpoint.
        public let awsDmsReplicationTask: AwsDmsReplicationTaskDetails?
        /// Details about a DynamoDB table.
        public let awsDynamoDbTable: AwsDynamoDbTableDetails?
        ///  Provides details about an Client VPN endpoint. A Client VPN endpoint is the resource that you  create and configure to enable and manage client VPN sessions. It's the termination point for all client VPN sessions.
        public let awsEc2ClientVpnEndpoint: AwsEc2ClientVpnEndpointDetails?
        /// Details about an Elastic IP address.
        public let awsEc2Eip: AwsEc2EipDetails?
        /// Details about an EC2 instance related to a finding.
        public let awsEc2Instance: AwsEc2InstanceDetails?
        public let awsEc2LaunchTemplate: AwsEc2LaunchTemplateDetails?
        /// Details about an EC2 network access control list (ACL).
        public let awsEc2NetworkAcl: AwsEc2NetworkAclDetails?
        /// Details for an EC2 network interface.
        public let awsEc2NetworkInterface: AwsEc2NetworkInterfaceDetails?
        ///  Provides details about a route table. A route table contains a set of rules, called routes, that  determine where to direct network traffic from your subnet or gateway.
        public let awsEc2RouteTable: AwsEc2RouteTableDetails?
        /// Details for an EC2 security group.
        public let awsEc2SecurityGroup: AwsEc2SecurityGroupDetails?
        /// Details about a subnet in Amazon EC2.
        public let awsEc2Subnet: AwsEc2SubnetDetails?
        /// Details about an Amazon EC2 transit gateway that interconnects your virtual private clouds (VPC) and on-premises networks.
        public let awsEc2TransitGateway: AwsEc2TransitGatewayDetails?
        /// Details for an Amazon EC2 volume.
        public let awsEc2Volume: AwsEc2VolumeDetails?
        /// Details for an Amazon EC2 VPC.
        public let awsEc2Vpc: AwsEc2VpcDetails?
        /// Details about the service configuration for a VPC endpoint service.
        public let awsEc2VpcEndpointService: AwsEc2VpcEndpointServiceDetails?
        /// Details about an Amazon EC2 VPC peering connection. A VPC peering connection is a networking connection between two VPCs that enables you to route traffic between them privately.
        public let awsEc2VpcPeeringConnection: AwsEc2VpcPeeringConnectionDetails?
        /// Details about an Amazon EC2 VPN connection.
        public let awsEc2VpnConnection: AwsEc2VpnConnectionDetails?
        /// Information about an Amazon ECR image.
        public let awsEcrContainerImage: AwsEcrContainerImageDetails?
        /// Information about an Amazon Elastic Container Registry repository.
        public let awsEcrRepository: AwsEcrRepositoryDetails?
        /// Details about an Amazon ECS cluster.
        public let awsEcsCluster: AwsEcsClusterDetails?
        /// Provides information about a Docker container that's part of a task.
        public let awsEcsContainer: AwsEcsContainerDetails?
        /// Details about a service within an ECS cluster.
        public let awsEcsService: AwsEcsServiceDetails?
        /// Details about a task in a cluster.
        public let awsEcsTask: AwsEcsTaskDetails?
        /// Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.
        public let awsEcsTaskDefinition: AwsEcsTaskDefinitionDetails?
        /// Details about an Amazon EFS access point. An access point is an application-specific view into an EFS file system that
        /// applies an operating system user and group, and a file system path, to any file system request made through the access point.
        public let awsEfsAccessPoint: AwsEfsAccessPointDetails?
        /// Details about an Amazon EKS cluster.
        public let awsEksCluster: AwsEksClusterDetails?
        /// Details about an Elastic Beanstalk environment.
        public let awsElasticBeanstalkEnvironment: AwsElasticBeanstalkEnvironmentDetails?
        /// Details for an Elasticsearch domain.
        public let awsElasticsearchDomain: AwsElasticsearchDomainDetails?
        /// Contains details about a Classic Load Balancer.
        public let awsElbLoadBalancer: AwsElbLoadBalancerDetails?
        /// Details about a load balancer.
        public let awsElbv2LoadBalancer: AwsElbv2LoadBalancerDetails?
        ///  A schema defines the structure of events that are sent to Amazon EventBridge. Schema registries are containers for  schemas. They collect and organize schemas so that your schemas are in logical groups.
        public let awsEventSchemasRegistry: AwsEventSchemasRegistryDetails?
        ///  Provides details about an Amazon EventBridge global endpoint. The endpoint can improve your applicationâ€™s
        /// availability by making it Regional-fault tolerant.
        public let awsEventsEndpoint: AwsEventsEndpointDetails?
        ///  Provides details about Amazon EventBridge event bus for an endpoint. An event bus is a router that receives events
        /// and delivers them to zero or more destinations, or targets.
        public let awsEventsEventbus: AwsEventsEventbusDetails?
        ///  Provides details about an Amazon GuardDuty detector. A detector is an object that represents the GuardDuty  service. A detector is required for GuardDuty to become operational.
        public let awsGuardDutyDetector: AwsGuardDutyDetectorDetails?
        /// Details about an IAM access key related to a finding.
        public let awsIamAccessKey: AwsIamAccessKeyDetails?
        /// Contains details about an IAM group.
        public let awsIamGroup: AwsIamGroupDetails?
        /// Details about an IAM permissions policy.
        public let awsIamPolicy: AwsIamPolicyDetails?
        /// Details about an IAM role.
        public let awsIamRole: AwsIamRoleDetails?
        /// Details about an IAM user.
        public let awsIamUser: AwsIamUserDetails?
        /// Details about an Amazon Kinesis data stream.
        public let awsKinesisStream: AwsKinesisStreamDetails?
        /// Details about an KMS key.
        public let awsKmsKey: AwsKmsKeyDetails?
        /// Details about a Lambda function.
        public let awsLambdaFunction: AwsLambdaFunctionDetails?
        /// Details for a Lambda layer version.
        public let awsLambdaLayerVersion: AwsLambdaLayerVersionDetails?
        ///  Provides details about an Amazon Managed Streaming for Apache Kafka (Amazon MSK) cluster.
        public let awsMskCluster: AwsMskClusterDetails?
        /// Details about an Network Firewall firewall.
        public let awsNetworkFirewallFirewall: AwsNetworkFirewallFirewallDetails?
        /// Details about an Network Firewall firewall policy.
        public let awsNetworkFirewallFirewallPolicy: AwsNetworkFirewallFirewallPolicyDetails?
        /// Details about an Network Firewall rule group.
        public let awsNetworkFirewallRuleGroup: AwsNetworkFirewallRuleGroupDetails?
        /// Details about an Amazon OpenSearch Service domain.
        public let awsOpenSearchServiceDomain: AwsOpenSearchServiceDomainDetails?
        /// Details about an Amazon RDS database cluster.
        public let awsRdsDbCluster: AwsRdsDbClusterDetails?
        /// Details about an Amazon RDS database cluster snapshot.
        public let awsRdsDbClusterSnapshot: AwsRdsDbClusterSnapshotDetails?
        /// Details about an Amazon RDS database instance.
        public let awsRdsDbInstance: AwsRdsDbInstanceDetails?
        /// Details about an Amazon RDS DB security group.
        public let awsRdsDbSecurityGroup: AwsRdsDbSecurityGroupDetails?
        /// Details about an Amazon RDS database snapshot.
        public let awsRdsDbSnapshot: AwsRdsDbSnapshotDetails?
        /// Details about an RDS event notification subscription.
        public let awsRdsEventSubscription: AwsRdsEventSubscriptionDetails?
        /// Contains details about an Amazon Redshift cluster.
        public let awsRedshiftCluster: AwsRedshiftClusterDetails?
        ///  Provides details about an Amazon RouteÂ 53 hosted zone, including the four name servers assigned to the hosted
        /// zone. A hosted zone represents a collection of records that can be managed together, belonging to a single parent domain name.
        public let awsRoute53HostedZone: AwsRoute53HostedZoneDetails?
        ///  Provides details about an Amazon Simple Storage Service (Amazon S3) access point. S3 access points are named network  endpoints that are attached to S3 buckets that you can use to perform S3 object operations.
        public let awsS3AccessPoint: AwsS3AccessPointDetails?
        /// Details about the Amazon S3 Public Access Block configuration for an account.
        public let awsS3AccountPublicAccessBlock: AwsS3AccountPublicAccessBlockDetails?
        /// Details about an S3 bucket related to a finding.
        public let awsS3Bucket: AwsS3BucketDetails?
        /// Details about an S3 object related to a finding.
        public let awsS3Object: AwsS3ObjectDetails?
        public let awsSageMakerNotebookInstance: AwsSageMakerNotebookInstanceDetails?
        /// Details about a Secrets Manager secret.
        public let awsSecretsManagerSecret: AwsSecretsManagerSecretDetails?
        /// Details about an SNS topic.
        public let awsSnsTopic: AwsSnsTopicDetails?
        /// Details about an SQS queue.
        public let awsSqsQueue: AwsSqsQueueDetails?
        /// Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.
        public let awsSsmPatchCompliance: AwsSsmPatchComplianceDetails?
        ///  Provides details about an Step Functions state machine, which is a workflow consisting of a series of event-driven steps.
        public let awsStepFunctionStateMachine: AwsStepFunctionStateMachineDetails?
        /// Details about a rate-based rule for global resources.
        public let awsWafRateBasedRule: AwsWafRateBasedRuleDetails?
        /// Details about a rate-based rule for Regional resources.
        public let awsWafRegionalRateBasedRule: AwsWafRegionalRateBasedRuleDetails?
        /// Details about an WAF rule for Regional resources.
        public let awsWafRegionalRule: AwsWafRegionalRuleDetails?
        /// Details about an WAF rule group for Regional resources.
        public let awsWafRegionalRuleGroup: AwsWafRegionalRuleGroupDetails?
        /// Details about an WAF web access control list (web ACL) for Regional resources.
        public let awsWafRegionalWebAcl: AwsWafRegionalWebAclDetails?
        /// Details about an WAF rule for global resources.
        public let awsWafRule: AwsWafRuleDetails?
        /// Details about an WAF rule group for global resources.
        public let awsWafRuleGroup: AwsWafRuleGroupDetails?
        public let awsWafv2RuleGroup: AwsWafv2RuleGroupDetails?
        public let awsWafv2WebAcl: AwsWafv2WebAclDetails?
        /// Details for an WAF web ACL.
        public let awsWafWebAcl: AwsWafWebAclDetails?
        /// Information about the encryption configuration for X-Ray.
        public let awsXrayEncryptionConfig: AwsXrayEncryptionConfigDetails?
        /// Details about a container resource related to a finding.
        public let container: ContainerDetails?
        /// Details about a resource that are not available in a type-specific details object. Use the Other object in the following cases.   The type-specific object does not contain all of the fields that you want to populate. In this case, first use the type-specific object to populate those fields. Use the Other object to populate the fields that are missing from the type-specific object.   The resource type does not have a corresponding object. This includes resources for which the type is Other.
        public let other: [String: String]?

        @inlinable
        public init(awsAmazonMqBroker: AwsAmazonMqBrokerDetails? = nil, awsApiGatewayRestApi: AwsApiGatewayRestApiDetails? = nil, awsApiGatewayStage: AwsApiGatewayStageDetails? = nil, awsApiGatewayV2Api: AwsApiGatewayV2ApiDetails? = nil, awsApiGatewayV2Stage: AwsApiGatewayV2StageDetails? = nil, awsAppSyncGraphQlApi: AwsAppSyncGraphQlApiDetails? = nil, awsAthenaWorkGroup: AwsAthenaWorkGroupDetails? = nil, awsAutoScalingAutoScalingGroup: AwsAutoScalingAutoScalingGroupDetails? = nil, awsAutoScalingLaunchConfiguration: AwsAutoScalingLaunchConfigurationDetails? = nil, awsBackupBackupPlan: AwsBackupBackupPlanDetails? = nil, awsBackupBackupVault: AwsBackupBackupVaultDetails? = nil, awsBackupRecoveryPoint: AwsBackupRecoveryPointDetails? = nil, awsCertificateManagerCertificate: AwsCertificateManagerCertificateDetails? = nil, awsCloudFormationStack: AwsCloudFormationStackDetails? = nil, awsCloudFrontDistribution: AwsCloudFrontDistributionDetails? = nil, awsCloudTrailTrail: AwsCloudTrailTrailDetails? = nil, awsCloudWatchAlarm: AwsCloudWatchAlarmDetails? = nil, awsCodeBuildProject: AwsCodeBuildProjectDetails? = nil, awsDmsEndpoint: AwsDmsEndpointDetails? = nil, awsDmsReplicationInstance: AwsDmsReplicationInstanceDetails? = nil, awsDmsReplicationTask: AwsDmsReplicationTaskDetails? = nil, awsDynamoDbTable: AwsDynamoDbTableDetails? = nil, awsEc2ClientVpnEndpoint: AwsEc2ClientVpnEndpointDetails? = nil, awsEc2Eip: AwsEc2EipDetails? = nil, awsEc2Instance: AwsEc2InstanceDetails? = nil, awsEc2LaunchTemplate: AwsEc2LaunchTemplateDetails? = nil, awsEc2NetworkAcl: AwsEc2NetworkAclDetails? = nil, awsEc2NetworkInterface: AwsEc2NetworkInterfaceDetails? = nil, awsEc2RouteTable: AwsEc2RouteTableDetails? = nil, awsEc2SecurityGroup: AwsEc2SecurityGroupDetails? = nil, awsEc2Subnet: AwsEc2SubnetDetails? = nil, awsEc2TransitGateway: AwsEc2TransitGatewayDetails? = nil, awsEc2Volume: AwsEc2VolumeDetails? = nil, awsEc2Vpc: AwsEc2VpcDetails? = nil, awsEc2VpcEndpointService: AwsEc2VpcEndpointServiceDetails? = nil, awsEc2VpcPeeringConnection: AwsEc2VpcPeeringConnectionDetails? = nil, awsEc2VpnConnection: AwsEc2VpnConnectionDetails? = nil, awsEcrContainerImage: AwsEcrContainerImageDetails? = nil, awsEcrRepository: AwsEcrRepositoryDetails? = nil, awsEcsCluster: AwsEcsClusterDetails? = nil, awsEcsContainer: AwsEcsContainerDetails? = nil, awsEcsService: AwsEcsServiceDetails? = nil, awsEcsTask: AwsEcsTaskDetails? = nil, awsEcsTaskDefinition: AwsEcsTaskDefinitionDetails? = nil, awsEfsAccessPoint: AwsEfsAccessPointDetails? = nil, awsEksCluster: AwsEksClusterDetails? = nil, awsElasticBeanstalkEnvironment: AwsElasticBeanstalkEnvironmentDetails? = nil, awsElasticsearchDomain: AwsElasticsearchDomainDetails? = nil, awsElbLoadBalancer: AwsElbLoadBalancerDetails? = nil, awsElbv2LoadBalancer: AwsElbv2LoadBalancerDetails? = nil, awsEventSchemasRegistry: AwsEventSchemasRegistryDetails? = nil, awsEventsEndpoint: AwsEventsEndpointDetails? = nil, awsEventsEventbus: AwsEventsEventbusDetails? = nil, awsGuardDutyDetector: AwsGuardDutyDetectorDetails? = nil, awsIamAccessKey: AwsIamAccessKeyDetails? = nil, awsIamGroup: AwsIamGroupDetails? = nil, awsIamPolicy: AwsIamPolicyDetails? = nil, awsIamRole: AwsIamRoleDetails? = nil, awsIamUser: AwsIamUserDetails? = nil, awsKinesisStream: AwsKinesisStreamDetails? = nil, awsKmsKey: AwsKmsKeyDetails? = nil, awsLambdaFunction: AwsLambdaFunctionDetails? = nil, awsLambdaLayerVersion: AwsLambdaLayerVersionDetails? = nil, awsMskCluster: AwsMskClusterDetails? = nil, awsNetworkFirewallFirewall: AwsNetworkFirewallFirewallDetails? = nil, awsNetworkFirewallFirewallPolicy: AwsNetworkFirewallFirewallPolicyDetails? = nil, awsNetworkFirewallRuleGroup: AwsNetworkFirewallRuleGroupDetails? = nil, awsOpenSearchServiceDomain: AwsOpenSearchServiceDomainDetails? = nil, awsRdsDbCluster: AwsRdsDbClusterDetails? = nil, awsRdsDbClusterSnapshot: AwsRdsDbClusterSnapshotDetails? = nil, awsRdsDbInstance: AwsRdsDbInstanceDetails? = nil, awsRdsDbSecurityGroup: AwsRdsDbSecurityGroupDetails? = nil, awsRdsDbSnapshot: AwsRdsDbSnapshotDetails? = nil, awsRdsEventSubscription: AwsRdsEventSubscriptionDetails? = nil, awsRedshiftCluster: AwsRedshiftClusterDetails? = nil, awsRoute53HostedZone: AwsRoute53HostedZoneDetails? = nil, awsS3AccessPoint: AwsS3AccessPointDetails? = nil, awsS3AccountPublicAccessBlock: AwsS3AccountPublicAccessBlockDetails? = nil, awsS3Bucket: AwsS3BucketDetails? = nil, awsS3Object: AwsS3ObjectDetails? = nil, awsSageMakerNotebookInstance: AwsSageMakerNotebookInstanceDetails? = nil, awsSecretsManagerSecret: AwsSecretsManagerSecretDetails? = nil, awsSnsTopic: AwsSnsTopicDetails? = nil, awsSqsQueue: AwsSqsQueueDetails? = nil, awsSsmPatchCompliance: AwsSsmPatchComplianceDetails? = nil, awsStepFunctionStateMachine: AwsStepFunctionStateMachineDetails? = nil, awsWafRateBasedRule: AwsWafRateBasedRuleDetails? = nil, awsWafRegionalRateBasedRule: AwsWafRegionalRateBasedRuleDetails? = nil, awsWafRegionalRule: AwsWafRegionalRuleDetails? = nil, awsWafRegionalRuleGroup: AwsWafRegionalRuleGroupDetails? = nil, awsWafRegionalWebAcl: AwsWafRegionalWebAclDetails? = nil, awsWafRule: AwsWafRuleDetails? = nil, awsWafRuleGroup: AwsWafRuleGroupDetails? = nil, awsWafv2RuleGroup: AwsWafv2RuleGroupDetails? = nil, awsWafv2WebAcl: AwsWafv2WebAclDetails? = nil, awsWafWebAcl: AwsWafWebAclDetails? = nil, awsXrayEncryptionConfig: AwsXrayEncryptionConfigDetails? = nil, container: ContainerDetails? = nil, other: [String: String]? = nil) {
            self.awsAmazonMqBroker = awsAmazonMqBroker
            self.awsApiGatewayRestApi = awsApiGatewayRestApi
            self.awsApiGatewayStage = awsApiGatewayStage
            self.awsApiGatewayV2Api = awsApiGatewayV2Api
            self.awsApiGatewayV2Stage = awsApiGatewayV2Stage
            self.awsAppSyncGraphQlApi = awsAppSyncGraphQlApi
            self.awsAthenaWorkGroup = awsAthenaWorkGroup
            self.awsAutoScalingAutoScalingGroup = awsAutoScalingAutoScalingGroup
            self.awsAutoScalingLaunchConfiguration = awsAutoScalingLaunchConfiguration
            self.awsBackupBackupPlan = awsBackupBackupPlan
            self.awsBackupBackupVault = awsBackupBackupVault
            self.awsBackupRecoveryPoint = awsBackupRecoveryPoint
            self.awsCertificateManagerCertificate = awsCertificateManagerCertificate
            self.awsCloudFormationStack = awsCloudFormationStack
            self.awsCloudFrontDistribution = awsCloudFrontDistribution
            self.awsCloudTrailTrail = awsCloudTrailTrail
            self.awsCloudWatchAlarm = awsCloudWatchAlarm
            self.awsCodeBuildProject = awsCodeBuildProject
            self.awsDmsEndpoint = awsDmsEndpoint
            self.awsDmsReplicationInstance = awsDmsReplicationInstance
            self.awsDmsReplicationTask = awsDmsReplicationTask
            self.awsDynamoDbTable = awsDynamoDbTable
            self.awsEc2ClientVpnEndpoint = awsEc2ClientVpnEndpoint
            self.awsEc2Eip = awsEc2Eip
            self.awsEc2Instance = awsEc2Instance
            self.awsEc2LaunchTemplate = awsEc2LaunchTemplate
            self.awsEc2NetworkAcl = awsEc2NetworkAcl
            self.awsEc2NetworkInterface = awsEc2NetworkInterface
            self.awsEc2RouteTable = awsEc2RouteTable
            self.awsEc2SecurityGroup = awsEc2SecurityGroup
            self.awsEc2Subnet = awsEc2Subnet
            self.awsEc2TransitGateway = awsEc2TransitGateway
            self.awsEc2Volume = awsEc2Volume
            self.awsEc2Vpc = awsEc2Vpc
            self.awsEc2VpcEndpointService = awsEc2VpcEndpointService
            self.awsEc2VpcPeeringConnection = awsEc2VpcPeeringConnection
            self.awsEc2VpnConnection = awsEc2VpnConnection
            self.awsEcrContainerImage = awsEcrContainerImage
            self.awsEcrRepository = awsEcrRepository
            self.awsEcsCluster = awsEcsCluster
            self.awsEcsContainer = awsEcsContainer
            self.awsEcsService = awsEcsService
            self.awsEcsTask = awsEcsTask
            self.awsEcsTaskDefinition = awsEcsTaskDefinition
            self.awsEfsAccessPoint = awsEfsAccessPoint
            self.awsEksCluster = awsEksCluster
            self.awsElasticBeanstalkEnvironment = awsElasticBeanstalkEnvironment
            self.awsElasticsearchDomain = awsElasticsearchDomain
            self.awsElbLoadBalancer = awsElbLoadBalancer
            self.awsElbv2LoadBalancer = awsElbv2LoadBalancer
            self.awsEventSchemasRegistry = awsEventSchemasRegistry
            self.awsEventsEndpoint = awsEventsEndpoint
            self.awsEventsEventbus = awsEventsEventbus
            self.awsGuardDutyDetector = awsGuardDutyDetector
            self.awsIamAccessKey = awsIamAccessKey
            self.awsIamGroup = awsIamGroup
            self.awsIamPolicy = awsIamPolicy
            self.awsIamRole = awsIamRole
            self.awsIamUser = awsIamUser
            self.awsKinesisStream = awsKinesisStream
            self.awsKmsKey = awsKmsKey
            self.awsLambdaFunction = awsLambdaFunction
            self.awsLambdaLayerVersion = awsLambdaLayerVersion
            self.awsMskCluster = awsMskCluster
            self.awsNetworkFirewallFirewall = awsNetworkFirewallFirewall
            self.awsNetworkFirewallFirewallPolicy = awsNetworkFirewallFirewallPolicy
            self.awsNetworkFirewallRuleGroup = awsNetworkFirewallRuleGroup
            self.awsOpenSearchServiceDomain = awsOpenSearchServiceDomain
            self.awsRdsDbCluster = awsRdsDbCluster
            self.awsRdsDbClusterSnapshot = awsRdsDbClusterSnapshot
            self.awsRdsDbInstance = awsRdsDbInstance
            self.awsRdsDbSecurityGroup = awsRdsDbSecurityGroup
            self.awsRdsDbSnapshot = awsRdsDbSnapshot
            self.awsRdsEventSubscription = awsRdsEventSubscription
            self.awsRedshiftCluster = awsRedshiftCluster
            self.awsRoute53HostedZone = awsRoute53HostedZone
            self.awsS3AccessPoint = awsS3AccessPoint
            self.awsS3AccountPublicAccessBlock = awsS3AccountPublicAccessBlock
            self.awsS3Bucket = awsS3Bucket
            self.awsS3Object = awsS3Object
            self.awsSageMakerNotebookInstance = awsSageMakerNotebookInstance
            self.awsSecretsManagerSecret = awsSecretsManagerSecret
            self.awsSnsTopic = awsSnsTopic
            self.awsSqsQueue = awsSqsQueue
            self.awsSsmPatchCompliance = awsSsmPatchCompliance
            self.awsStepFunctionStateMachine = awsStepFunctionStateMachine
            self.awsWafRateBasedRule = awsWafRateBasedRule
            self.awsWafRegionalRateBasedRule = awsWafRegionalRateBasedRule
            self.awsWafRegionalRule = awsWafRegionalRule
            self.awsWafRegionalRuleGroup = awsWafRegionalRuleGroup
            self.awsWafRegionalWebAcl = awsWafRegionalWebAcl
            self.awsWafRule = awsWafRule
            self.awsWafRuleGroup = awsWafRuleGroup
            self.awsWafv2RuleGroup = awsWafv2RuleGroup
            self.awsWafv2WebAcl = awsWafv2WebAcl
            self.awsWafWebAcl = awsWafWebAcl
            self.awsXrayEncryptionConfig = awsXrayEncryptionConfig
            self.container = container
            self.other = other
        }

        public func validate(name: String) throws {
            try self.awsAmazonMqBroker?.validate(name: "\(name).awsAmazonMqBroker")
            try self.awsApiGatewayRestApi?.validate(name: "\(name).awsApiGatewayRestApi")
            try self.awsApiGatewayStage?.validate(name: "\(name).awsApiGatewayStage")
            try self.awsApiGatewayV2Api?.validate(name: "\(name).awsApiGatewayV2Api")
            try self.awsApiGatewayV2Stage?.validate(name: "\(name).awsApiGatewayV2Stage")
            try self.awsAppSyncGraphQlApi?.validate(name: "\(name).awsAppSyncGraphQlApi")
            try self.awsAthenaWorkGroup?.validate(name: "\(name).awsAthenaWorkGroup")
            try self.awsAutoScalingAutoScalingGroup?.validate(name: "\(name).awsAutoScalingAutoScalingGroup")
            try self.awsAutoScalingLaunchConfiguration?.validate(name: "\(name).awsAutoScalingLaunchConfiguration")
            try self.awsBackupBackupPlan?.validate(name: "\(name).awsBackupBackupPlan")
            try self.awsBackupBackupVault?.validate(name: "\(name).awsBackupBackupVault")
            try self.awsBackupRecoveryPoint?.validate(name: "\(name).awsBackupRecoveryPoint")
            try self.awsCertificateManagerCertificate?.validate(name: "\(name).awsCertificateManagerCertificate")
            try self.awsCloudFormationStack?.validate(name: "\(name).awsCloudFormationStack")
            try self.awsCloudFrontDistribution?.validate(name: "\(name).awsCloudFrontDistribution")
            try self.awsCloudTrailTrail?.validate(name: "\(name).awsCloudTrailTrail")
            try self.awsCloudWatchAlarm?.validate(name: "\(name).awsCloudWatchAlarm")
            try self.awsCodeBuildProject?.validate(name: "\(name).awsCodeBuildProject")
            try self.awsDmsEndpoint?.validate(name: "\(name).awsDmsEndpoint")
            try self.awsDmsReplicationInstance?.validate(name: "\(name).awsDmsReplicationInstance")
            try self.awsDmsReplicationTask?.validate(name: "\(name).awsDmsReplicationTask")
            try self.awsDynamoDbTable?.validate(name: "\(name).awsDynamoDbTable")
            try self.awsEc2ClientVpnEndpoint?.validate(name: "\(name).awsEc2ClientVpnEndpoint")
            try self.awsEc2Eip?.validate(name: "\(name).awsEc2Eip")
            try self.awsEc2Instance?.validate(name: "\(name).awsEc2Instance")
            try self.awsEc2LaunchTemplate?.validate(name: "\(name).awsEc2LaunchTemplate")
            try self.awsEc2NetworkAcl?.validate(name: "\(name).awsEc2NetworkAcl")
            try self.awsEc2NetworkInterface?.validate(name: "\(name).awsEc2NetworkInterface")
            try self.awsEc2RouteTable?.validate(name: "\(name).awsEc2RouteTable")
            try self.awsEc2SecurityGroup?.validate(name: "\(name).awsEc2SecurityGroup")
            try self.awsEc2Subnet?.validate(name: "\(name).awsEc2Subnet")
            try self.awsEc2TransitGateway?.validate(name: "\(name).awsEc2TransitGateway")
            try self.awsEc2Volume?.validate(name: "\(name).awsEc2Volume")
            try self.awsEc2Vpc?.validate(name: "\(name).awsEc2Vpc")
            try self.awsEc2VpcEndpointService?.validate(name: "\(name).awsEc2VpcEndpointService")
            try self.awsEc2VpcPeeringConnection?.validate(name: "\(name).awsEc2VpcPeeringConnection")
            try self.awsEc2VpnConnection?.validate(name: "\(name).awsEc2VpnConnection")
            try self.awsEcrContainerImage?.validate(name: "\(name).awsEcrContainerImage")
            try self.awsEcrRepository?.validate(name: "\(name).awsEcrRepository")
            try self.awsEcsCluster?.validate(name: "\(name).awsEcsCluster")
            try self.awsEcsContainer?.validate(name: "\(name).awsEcsContainer")
            try self.awsEcsService?.validate(name: "\(name).awsEcsService")
            try self.awsEcsTask?.validate(name: "\(name).awsEcsTask")
            try self.awsEcsTaskDefinition?.validate(name: "\(name).awsEcsTaskDefinition")
            try self.awsEfsAccessPoint?.validate(name: "\(name).awsEfsAccessPoint")
            try self.awsEksCluster?.validate(name: "\(name).awsEksCluster")
            try self.awsElasticBeanstalkEnvironment?.validate(name: "\(name).awsElasticBeanstalkEnvironment")
            try self.awsElasticsearchDomain?.validate(name: "\(name).awsElasticsearchDomain")
            try self.awsElbLoadBalancer?.validate(name: "\(name).awsElbLoadBalancer")
            try self.awsElbv2LoadBalancer?.validate(name: "\(name).awsElbv2LoadBalancer")
            try self.awsEventSchemasRegistry?.validate(name: "\(name).awsEventSchemasRegistry")
            try self.awsEventsEndpoint?.validate(name: "\(name).awsEventsEndpoint")
            try self.awsEventsEventbus?.validate(name: "\(name).awsEventsEventbus")
            try self.awsGuardDutyDetector?.validate(name: "\(name).awsGuardDutyDetector")
            try self.awsIamAccessKey?.validate(name: "\(name).awsIamAccessKey")
            try self.awsIamGroup?.validate(name: "\(name).awsIamGroup")
            try self.awsIamPolicy?.validate(name: "\(name).awsIamPolicy")
            try self.awsIamRole?.validate(name: "\(name).awsIamRole")
            try self.awsIamUser?.validate(name: "\(name).awsIamUser")
            try self.awsKinesisStream?.validate(name: "\(name).awsKinesisStream")
            try self.awsKmsKey?.validate(name: "\(name).awsKmsKey")
            try self.awsLambdaFunction?.validate(name: "\(name).awsLambdaFunction")
            try self.awsLambdaLayerVersion?.validate(name: "\(name).awsLambdaLayerVersion")
            try self.awsMskCluster?.validate(name: "\(name).awsMskCluster")
            try self.awsNetworkFirewallFirewall?.validate(name: "\(name).awsNetworkFirewallFirewall")
            try self.awsNetworkFirewallFirewallPolicy?.validate(name: "\(name).awsNetworkFirewallFirewallPolicy")
            try self.awsNetworkFirewallRuleGroup?.validate(name: "\(name).awsNetworkFirewallRuleGroup")
            try self.awsOpenSearchServiceDomain?.validate(name: "\(name).awsOpenSearchServiceDomain")
            try self.awsRdsDbCluster?.validate(name: "\(name).awsRdsDbCluster")
            try self.awsRdsDbClusterSnapshot?.validate(name: "\(name).awsRdsDbClusterSnapshot")
            try self.awsRdsDbInstance?.validate(name: "\(name).awsRdsDbInstance")
            try self.awsRdsDbSecurityGroup?.validate(name: "\(name).awsRdsDbSecurityGroup")
            try self.awsRdsDbSnapshot?.validate(name: "\(name).awsRdsDbSnapshot")
            try self.awsRdsEventSubscription?.validate(name: "\(name).awsRdsEventSubscription")
            try self.awsRedshiftCluster?.validate(name: "\(name).awsRedshiftCluster")
            try self.awsRoute53HostedZone?.validate(name: "\(name).awsRoute53HostedZone")
            try self.awsS3AccessPoint?.validate(name: "\(name).awsS3AccessPoint")
            try self.awsS3Bucket?.validate(name: "\(name).awsS3Bucket")
            try self.awsS3Object?.validate(name: "\(name).awsS3Object")
            try self.awsSageMakerNotebookInstance?.validate(name: "\(name).awsSageMakerNotebookInstance")
            try self.awsSecretsManagerSecret?.validate(name: "\(name).awsSecretsManagerSecret")
            try self.awsSnsTopic?.validate(name: "\(name).awsSnsTopic")
            try self.awsSqsQueue?.validate(name: "\(name).awsSqsQueue")
            try self.awsSsmPatchCompliance?.validate(name: "\(name).awsSsmPatchCompliance")
            try self.awsStepFunctionStateMachine?.validate(name: "\(name).awsStepFunctionStateMachine")
            try self.awsWafRateBasedRule?.validate(name: "\(name).awsWafRateBasedRule")
            try self.awsWafRegionalRateBasedRule?.validate(name: "\(name).awsWafRegionalRateBasedRule")
            try self.awsWafRegionalRule?.validate(name: "\(name).awsWafRegionalRule")
            try self.awsWafRegionalRuleGroup?.validate(name: "\(name).awsWafRegionalRuleGroup")
            try self.awsWafRegionalWebAcl?.validate(name: "\(name).awsWafRegionalWebAcl")
            try self.awsWafRule?.validate(name: "\(name).awsWafRule")
            try self.awsWafRuleGroup?.validate(name: "\(name).awsWafRuleGroup")
            try self.awsWafv2RuleGroup?.validate(name: "\(name).awsWafv2RuleGroup")
            try self.awsWafv2WebAcl?.validate(name: "\(name).awsWafv2WebAcl")
            try self.awsWafWebAcl?.validate(name: "\(name).awsWafWebAcl")
            try self.awsXrayEncryptionConfig?.validate(name: "\(name).awsXrayEncryptionConfig")
            try self.container?.validate(name: "\(name).container")
            try self.other?.forEach {
                try validate($0.key, name: "other.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "other[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAmazonMqBroker = "AwsAmazonMqBroker"
            case awsApiGatewayRestApi = "AwsApiGatewayRestApi"
            case awsApiGatewayStage = "AwsApiGatewayStage"
            case awsApiGatewayV2Api = "AwsApiGatewayV2Api"
            case awsApiGatewayV2Stage = "AwsApiGatewayV2Stage"
            case awsAppSyncGraphQlApi = "AwsAppSyncGraphQlApi"
            case awsAthenaWorkGroup = "AwsAthenaWorkGroup"
            case awsAutoScalingAutoScalingGroup = "AwsAutoScalingAutoScalingGroup"
            case awsAutoScalingLaunchConfiguration = "AwsAutoScalingLaunchConfiguration"
            case awsBackupBackupPlan = "AwsBackupBackupPlan"
            case awsBackupBackupVault = "AwsBackupBackupVault"
            case awsBackupRecoveryPoint = "AwsBackupRecoveryPoint"
            case awsCertificateManagerCertificate = "AwsCertificateManagerCertificate"
            case awsCloudFormationStack = "AwsCloudFormationStack"
            case awsCloudFrontDistribution = "AwsCloudFrontDistribution"
            case awsCloudTrailTrail = "AwsCloudTrailTrail"
            case awsCloudWatchAlarm = "AwsCloudWatchAlarm"
            case awsCodeBuildProject = "AwsCodeBuildProject"
            case awsDmsEndpoint = "AwsDmsEndpoint"
            case awsDmsReplicationInstance = "AwsDmsReplicationInstance"
            case awsDmsReplicationTask = "AwsDmsReplicationTask"
            case awsDynamoDbTable = "AwsDynamoDbTable"
            case awsEc2ClientVpnEndpoint = "AwsEc2ClientVpnEndpoint"
            case awsEc2Eip = "AwsEc2Eip"
            case awsEc2Instance = "AwsEc2Instance"
            case awsEc2LaunchTemplate = "AwsEc2LaunchTemplate"
            case awsEc2NetworkAcl = "AwsEc2NetworkAcl"
            case awsEc2NetworkInterface = "AwsEc2NetworkInterface"
            case awsEc2RouteTable = "AwsEc2RouteTable"
            case awsEc2SecurityGroup = "AwsEc2SecurityGroup"
            case awsEc2Subnet = "AwsEc2Subnet"
            case awsEc2TransitGateway = "AwsEc2TransitGateway"
            case awsEc2Volume = "AwsEc2Volume"
            case awsEc2Vpc = "AwsEc2Vpc"
            case awsEc2VpcEndpointService = "AwsEc2VpcEndpointService"
            case awsEc2VpcPeeringConnection = "AwsEc2VpcPeeringConnection"
            case awsEc2VpnConnection = "AwsEc2VpnConnection"
            case awsEcrContainerImage = "AwsEcrContainerImage"
            case awsEcrRepository = "AwsEcrRepository"
            case awsEcsCluster = "AwsEcsCluster"
            case awsEcsContainer = "AwsEcsContainer"
            case awsEcsService = "AwsEcsService"
            case awsEcsTask = "AwsEcsTask"
            case awsEcsTaskDefinition = "AwsEcsTaskDefinition"
            case awsEfsAccessPoint = "AwsEfsAccessPoint"
            case awsEksCluster = "AwsEksCluster"
            case awsElasticBeanstalkEnvironment = "AwsElasticBeanstalkEnvironment"
            case awsElasticsearchDomain = "AwsElasticsearchDomain"
            case awsElbLoadBalancer = "AwsElbLoadBalancer"
            case awsElbv2LoadBalancer = "AwsElbv2LoadBalancer"
            case awsEventSchemasRegistry = "AwsEventSchemasRegistry"
            case awsEventsEndpoint = "AwsEventsEndpoint"
            case awsEventsEventbus = "AwsEventsEventbus"
            case awsGuardDutyDetector = "AwsGuardDutyDetector"
            case awsIamAccessKey = "AwsIamAccessKey"
            case awsIamGroup = "AwsIamGroup"
            case awsIamPolicy = "AwsIamPolicy"
            case awsIamRole = "AwsIamRole"
            case awsIamUser = "AwsIamUser"
            case awsKinesisStream = "AwsKinesisStream"
            case awsKmsKey = "AwsKmsKey"
            case awsLambdaFunction = "AwsLambdaFunction"
            case awsLambdaLayerVersion = "AwsLambdaLayerVersion"
            case awsMskCluster = "AwsMskCluster"
            case awsNetworkFirewallFirewall = "AwsNetworkFirewallFirewall"
            case awsNetworkFirewallFirewallPolicy = "AwsNetworkFirewallFirewallPolicy"
            case awsNetworkFirewallRuleGroup = "AwsNetworkFirewallRuleGroup"
            case awsOpenSearchServiceDomain = "AwsOpenSearchServiceDomain"
            case awsRdsDbCluster = "AwsRdsDbCluster"
            case awsRdsDbClusterSnapshot = "AwsRdsDbClusterSnapshot"
            case awsRdsDbInstance = "AwsRdsDbInstance"
            case awsRdsDbSecurityGroup = "AwsRdsDbSecurityGroup"
            case awsRdsDbSnapshot = "AwsRdsDbSnapshot"
            case awsRdsEventSubscription = "AwsRdsEventSubscription"
            case awsRedshiftCluster = "AwsRedshiftCluster"
            case awsRoute53HostedZone = "AwsRoute53HostedZone"
            case awsS3AccessPoint = "AwsS3AccessPoint"
            case awsS3AccountPublicAccessBlock = "AwsS3AccountPublicAccessBlock"
            case awsS3Bucket = "AwsS3Bucket"
            case awsS3Object = "AwsS3Object"
            case awsSageMakerNotebookInstance = "AwsSageMakerNotebookInstance"
            case awsSecretsManagerSecret = "AwsSecretsManagerSecret"
            case awsSnsTopic = "AwsSnsTopic"
            case awsSqsQueue = "AwsSqsQueue"
            case awsSsmPatchCompliance = "AwsSsmPatchCompliance"
            case awsStepFunctionStateMachine = "AwsStepFunctionStateMachine"
            case awsWafRateBasedRule = "AwsWafRateBasedRule"
            case awsWafRegionalRateBasedRule = "AwsWafRegionalRateBasedRule"
            case awsWafRegionalRule = "AwsWafRegionalRule"
            case awsWafRegionalRuleGroup = "AwsWafRegionalRuleGroup"
            case awsWafRegionalWebAcl = "AwsWafRegionalWebAcl"
            case awsWafRule = "AwsWafRule"
            case awsWafRuleGroup = "AwsWafRuleGroup"
            case awsWafv2RuleGroup = "AwsWafv2RuleGroup"
            case awsWafv2WebAcl = "AwsWafv2WebAcl"
            case awsWafWebAcl = "AwsWafWebAcl"
            case awsXrayEncryptionConfig = "AwsXrayEncryptionConfig"
            case container = "Container"
            case other = "Other"
        }
    }

    public struct ResourceInUseException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct Result: AWSDecodableShape {
        /// An Amazon Web Services account ID of the account that was not processed.
        public let accountId: String?
        /// The reason that the account was not processed.
        public let processingResult: String?

        @inlinable
        public init(accountId: String? = nil, processingResult: String? = nil) {
            self.accountId = accountId
            self.processingResult = processingResult
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case processingResult = "ProcessingResult"
        }
    }

    public struct RouteSetDetails: AWSEncodableShape & AWSDecodableShape {
        ///  The ID of the carrier gateway.
        public let carrierGatewayId: String?
        ///  The Amazon Resource Name (ARN) of the core network.
        public let coreNetworkArn: String?
        ///  The IPv4 CIDR block used for the destination match.
        public let destinationCidrBlock: String?
        ///  The IPv6 CIDR block used for the destination match.
        public let destinationIpv6CidrBlock: String?
        ///  The prefix of the destination Amazon Web Services service.
        public let destinationPrefixListId: String?
        ///  The ID of the egress-only internet gateway.
        public let egressOnlyInternetGatewayId: String?
        ///  The ID of a gateway attached to your VPC.
        public let gatewayId: String?
        ///  The ID of a NAT instance in your VPC.
        public let instanceId: String?
        ///  The ID of the Amazon Web Services account that owns the instance.
        public let instanceOwnerId: String?
        ///  The ID of the local gateway.
        public let localGatewayId: String?
        ///  The ID of a NAT gateway.
        public let natGatewayId: String?
        ///  The ID of the network interface.
        public let networkInterfaceId: String?
        ///  Describes how the route was created.
        public let origin: String?
        ///  The state of the route.
        public let state: String?
        ///  The ID of a transit gateway.
        public let transitGatewayId: String?
        ///  The ID of a VPC peering connection.
        public let vpcPeeringConnectionId: String?

        @inlinable
        public init(carrierGatewayId: String? = nil, coreNetworkArn: String? = nil, destinationCidrBlock: String? = nil, destinationIpv6CidrBlock: String? = nil, destinationPrefixListId: String? = nil, egressOnlyInternetGatewayId: String? = nil, gatewayId: String? = nil, instanceId: String? = nil, instanceOwnerId: String? = nil, localGatewayId: String? = nil, natGatewayId: String? = nil, networkInterfaceId: String? = nil, origin: String? = nil, state: String? = nil, transitGatewayId: String? = nil, vpcPeeringConnectionId: String? = nil) {
            self.carrierGatewayId = carrierGatewayId
            self.coreNetworkArn = coreNetworkArn
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.gatewayId = gatewayId
            self.instanceId = instanceId
            self.instanceOwnerId = instanceOwnerId
            self.localGatewayId = localGatewayId
            self.natGatewayId = natGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.origin = origin
            self.state = state
            self.transitGatewayId = transitGatewayId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }

        public func validate(name: String) throws {
            try self.validate(self.carrierGatewayId, name: "carrierGatewayId", parent: name, pattern: "\\S")
            try self.validate(self.coreNetworkArn, name: "coreNetworkArn", parent: name, pattern: "\\S")
            try self.validate(self.destinationCidrBlock, name: "destinationCidrBlock", parent: name, pattern: "\\S")
            try self.validate(self.destinationIpv6CidrBlock, name: "destinationIpv6CidrBlock", parent: name, pattern: "\\S")
            try self.validate(self.destinationPrefixListId, name: "destinationPrefixListId", parent: name, pattern: "\\S")
            try self.validate(self.egressOnlyInternetGatewayId, name: "egressOnlyInternetGatewayId", parent: name, pattern: "\\S")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "\\S")
            try self.validate(self.instanceOwnerId, name: "instanceOwnerId", parent: name, pattern: "\\S")
            try self.validate(self.localGatewayId, name: "localGatewayId", parent: name, pattern: "\\S")
            try self.validate(self.natGatewayId, name: "natGatewayId", parent: name, pattern: "\\S")
            try self.validate(self.networkInterfaceId, name: "networkInterfaceId", parent: name, pattern: "\\S")
            try self.validate(self.origin, name: "origin", parent: name, pattern: "\\S")
            try self.validate(self.state, name: "state", parent: name, pattern: "\\S")
            try self.validate(self.transitGatewayId, name: "transitGatewayId", parent: name, pattern: "\\S")
            try self.validate(self.vpcPeeringConnectionId, name: "vpcPeeringConnectionId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case carrierGatewayId = "CarrierGatewayId"
            case coreNetworkArn = "CoreNetworkArn"
            case destinationCidrBlock = "DestinationCidrBlock"
            case destinationIpv6CidrBlock = "DestinationIpv6CidrBlock"
            case destinationPrefixListId = "DestinationPrefixListId"
            case egressOnlyInternetGatewayId = "EgressOnlyInternetGatewayId"
            case gatewayId = "GatewayId"
            case instanceId = "InstanceId"
            case instanceOwnerId = "InstanceOwnerId"
            case localGatewayId = "LocalGatewayId"
            case natGatewayId = "NatGatewayId"
            case networkInterfaceId = "NetworkInterfaceId"
            case origin = "Origin"
            case state = "State"
            case transitGatewayId = "TransitGatewayId"
            case vpcPeeringConnectionId = "VpcPeeringConnectionId"
        }
    }

    public struct RuleGroupDetails: AWSEncodableShape & AWSDecodableShape {
        /// The rules and actions for the rule group. For stateful rule groups, can contain RulesString, RulesSourceList, or StatefulRules. For stateless rule groups, contains StatelessRulesAndCustomActions.
        public let rulesSource: RuleGroupSource?
        /// Additional settings to use in the specified rules.
        public let ruleVariables: RuleGroupVariables?

        @inlinable
        public init(rulesSource: RuleGroupSource? = nil, ruleVariables: RuleGroupVariables? = nil) {
            self.rulesSource = rulesSource
            self.ruleVariables = ruleVariables
        }

        public func validate(name: String) throws {
            try self.rulesSource?.validate(name: "\(name).rulesSource")
            try self.ruleVariables?.validate(name: "\(name).ruleVariables")
        }

        private enum CodingKeys: String, CodingKey {
            case rulesSource = "RulesSource"
            case ruleVariables = "RuleVariables"
        }
    }

    public struct RuleGroupSource: AWSEncodableShape & AWSDecodableShape {
        /// Stateful inspection criteria for a domain list rule group. A domain list rule group determines access by specific protocols to specific domains.
        public let rulesSourceList: RuleGroupSourceListDetails?
        /// Stateful inspection criteria, provided in Suricata compatible intrusion prevention system (IPS) rules.
        public let rulesString: String?
        /// Suricata rule specifications.
        public let statefulRules: [RuleGroupSourceStatefulRulesDetails]?
        /// The stateless rules and custom actions used by a stateless rule group.
        public let statelessRulesAndCustomActions: RuleGroupSourceStatelessRulesAndCustomActionsDetails?

        @inlinable
        public init(rulesSourceList: RuleGroupSourceListDetails? = nil, rulesString: String? = nil, statefulRules: [RuleGroupSourceStatefulRulesDetails]? = nil, statelessRulesAndCustomActions: RuleGroupSourceStatelessRulesAndCustomActionsDetails? = nil) {
            self.rulesSourceList = rulesSourceList
            self.rulesString = rulesString
            self.statefulRules = statefulRules
            self.statelessRulesAndCustomActions = statelessRulesAndCustomActions
        }

        public func validate(name: String) throws {
            try self.rulesSourceList?.validate(name: "\(name).rulesSourceList")
            try self.validate(self.rulesString, name: "rulesString", parent: name, pattern: "\\S")
            try self.statefulRules?.forEach {
                try $0.validate(name: "\(name).statefulRules[]")
            }
            try self.statelessRulesAndCustomActions?.validate(name: "\(name).statelessRulesAndCustomActions")
        }

        private enum CodingKeys: String, CodingKey {
            case rulesSourceList = "RulesSourceList"
            case rulesString = "RulesString"
            case statefulRules = "StatefulRules"
            case statelessRulesAndCustomActions = "StatelessRulesAndCustomActions"
        }
    }

    public struct RuleGroupSourceCustomActionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The definition of a custom action.
        public let actionDefinition: StatelessCustomActionDefinition?
        /// A descriptive name of the custom action.
        public let actionName: String?

        @inlinable
        public init(actionDefinition: StatelessCustomActionDefinition? = nil, actionName: String? = nil) {
            self.actionDefinition = actionDefinition
            self.actionName = actionName
        }

        public func validate(name: String) throws {
            try self.actionDefinition?.validate(name: "\(name).actionDefinition")
            try self.validate(self.actionName, name: "actionName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case actionDefinition = "ActionDefinition"
            case actionName = "ActionName"
        }
    }

    public struct RuleGroupSourceListDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether to allow or deny access to the domains listed in Targets.
        public let generatedRulesType: String?
        /// The domains that you want to inspect for in your traffic flows. You can provide full domain names, or use the '.' prefix as a wildcard. For example, .example.com matches all domains that end with example.com.
        public let targets: [String]?
        /// The protocols that you want to inspect. Specify LS_SNI for HTTPS. Specify HTTP_HOST for HTTP. You can specify either or both.
        public let targetTypes: [String]?

        @inlinable
        public init(generatedRulesType: String? = nil, targets: [String]? = nil, targetTypes: [String]? = nil) {
            self.generatedRulesType = generatedRulesType
            self.targets = targets
            self.targetTypes = targetTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.generatedRulesType, name: "generatedRulesType", parent: name, pattern: "\\S")
            try self.targets?.forEach {
                try validate($0, name: "targets[]", parent: name, pattern: "\\S")
            }
            try self.targetTypes?.forEach {
                try validate($0, name: "targetTypes[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case generatedRulesType = "GeneratedRulesType"
            case targets = "Targets"
            case targetTypes = "TargetTypes"
        }
    }

    public struct RuleGroupSourceStatefulRulesDetails: AWSEncodableShape & AWSDecodableShape {
        /// Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria.
        public let action: String?
        /// The stateful inspection criteria for the rule.
        public let header: RuleGroupSourceStatefulRulesHeaderDetails?
        /// Additional options for the rule.
        public let ruleOptions: [RuleGroupSourceStatefulRulesOptionsDetails]?

        @inlinable
        public init(action: String? = nil, header: RuleGroupSourceStatefulRulesHeaderDetails? = nil, ruleOptions: [RuleGroupSourceStatefulRulesOptionsDetails]? = nil) {
            self.action = action
            self.header = header
            self.ruleOptions = ruleOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.action, name: "action", parent: name, pattern: "\\S")
            try self.header?.validate(name: "\(name).header")
            try self.ruleOptions?.forEach {
                try $0.validate(name: "\(name).ruleOptions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case header = "Header"
            case ruleOptions = "RuleOptions"
        }
    }

    public struct RuleGroupSourceStatefulRulesHeaderDetails: AWSEncodableShape & AWSDecodableShape {
        /// The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify ANY.
        public let destination: String?
        /// The destination port to inspect for. You can specify an individual port, such as 1994. You also can specify a port range, such as 1990:1994. To match with any port, specify ANY.
        public let destinationPort: String?
        /// The direction of traffic flow to inspect. If set to ANY, the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to FORWARD, the inspection only matches traffic going from the source to the destination.
        public let direction: String?
        /// The protocol to inspect for. To inspector for all protocols, use IP.
        public let `protocol`: String?
        /// The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify ANY.
        public let source: String?
        /// The source port to inspect for. You can specify an individual port, such as 1994. You also can specify a port range, such as 1990:1994. To match with any port, specify ANY.
        public let sourcePort: String?

        @inlinable
        public init(destination: String? = nil, destinationPort: String? = nil, direction: String? = nil, protocol: String? = nil, source: String? = nil, sourcePort: String? = nil) {
            self.destination = destination
            self.destinationPort = destinationPort
            self.direction = direction
            self.`protocol` = `protocol`
            self.source = source
            self.sourcePort = sourcePort
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, pattern: "\\S")
            try self.validate(self.destinationPort, name: "destinationPort", parent: name, pattern: "\\S")
            try self.validate(self.direction, name: "direction", parent: name, pattern: "\\S")
            try self.validate(self.`protocol`, name: "`protocol`", parent: name, pattern: "\\S")
            try self.validate(self.source, name: "source", parent: name, pattern: "\\S")
            try self.validate(self.sourcePort, name: "sourcePort", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case destinationPort = "DestinationPort"
            case direction = "Direction"
            case `protocol` = "Protocol"
            case source = "Source"
            case sourcePort = "SourcePort"
        }
    }

    public struct RuleGroupSourceStatefulRulesOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// A keyword to look for.
        public let keyword: String?
        /// A list of settings.
        public let settings: [String]?

        @inlinable
        public init(keyword: String? = nil, settings: [String]? = nil) {
            self.keyword = keyword
            self.settings = settings
        }

        public func validate(name: String) throws {
            try self.validate(self.keyword, name: "keyword", parent: name, pattern: "\\S")
            try self.settings?.forEach {
                try validate($0, name: "settings[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case keyword = "Keyword"
            case settings = "Settings"
        }
    }

    public struct RuleGroupSourceStatelessRuleDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action (aws:pass, aws:drop, or aws:forward_to_sfe). You can then add custom actions.
        public let actions: [String]?
        /// The criteria for Network Firewall to use to inspect an individual packet in a stateless rule inspection.
        public let matchAttributes: RuleGroupSourceStatelessRuleMatchAttributes?

        @inlinable
        public init(actions: [String]? = nil, matchAttributes: RuleGroupSourceStatelessRuleMatchAttributes? = nil) {
            self.actions = actions
            self.matchAttributes = matchAttributes
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try validate($0, name: "actions[]", parent: name, pattern: "\\S")
            }
            try self.matchAttributes?.validate(name: "\(name).matchAttributes")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case matchAttributes = "MatchAttributes"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributes: AWSEncodableShape & AWSDecodableShape {
        /// A list of port ranges to specify the destination ports to inspect for.
        public let destinationPorts: [RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts]?
        /// The destination IP addresses and address ranges to inspect for, in CIDR notation.
        public let destinations: [RuleGroupSourceStatelessRuleMatchAttributesDestinations]?
        /// The protocols to inspect for.
        public let protocols: [Int]?
        /// A list of port ranges to specify the source ports to inspect for.
        public let sourcePorts: [RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]?
        /// The source IP addresses and address ranges to inspect for, in CIDR notation.
        public let sources: [RuleGroupSourceStatelessRuleMatchAttributesSources]?
        /// The TCP flags and masks to inspect for.
        public let tcpFlags: [RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]?

        @inlinable
        public init(destinationPorts: [RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts]? = nil, destinations: [RuleGroupSourceStatelessRuleMatchAttributesDestinations]? = nil, protocols: [Int]? = nil, sourcePorts: [RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]? = nil, sources: [RuleGroupSourceStatelessRuleMatchAttributesSources]? = nil, tcpFlags: [RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]? = nil) {
            self.destinationPorts = destinationPorts
            self.destinations = destinations
            self.protocols = protocols
            self.sourcePorts = sourcePorts
            self.sources = sources
            self.tcpFlags = tcpFlags
        }

        public func validate(name: String) throws {
            try self.destinations?.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
            try self.sources?.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.tcpFlags?.forEach {
                try $0.validate(name: "\(name).tcpFlags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case destinationPorts = "DestinationPorts"
            case destinations = "Destinations"
            case protocols = "Protocols"
            case sourcePorts = "SourcePorts"
            case sources = "Sources"
            case tcpFlags = "TcpFlags"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts: AWSEncodableShape & AWSDecodableShape {
        /// The starting port value for the port range.
        public let fromPort: Int?
        /// The ending port value for the port range.
        public let toPort: Int?

        @inlinable
        public init(fromPort: Int? = nil, toPort: Int? = nil) {
            self.fromPort = fromPort
            self.toPort = toPort
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case toPort = "ToPort"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributesDestinations: AWSEncodableShape & AWSDecodableShape {
        /// An IP address or a block of IP addresses.
        public let addressDefinition: String?

        @inlinable
        public init(addressDefinition: String? = nil) {
            self.addressDefinition = addressDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.addressDefinition, name: "addressDefinition", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case addressDefinition = "AddressDefinition"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributesSourcePorts: AWSEncodableShape & AWSDecodableShape {
        /// The starting port value for the port range.
        public let fromPort: Int?
        /// The ending port value for the port range.
        public let toPort: Int?

        @inlinable
        public init(fromPort: Int? = nil, toPort: Int? = nil) {
            self.fromPort = fromPort
            self.toPort = toPort
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case toPort = "ToPort"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributesSources: AWSEncodableShape & AWSDecodableShape {
        /// An IP address or a block of IP addresses.
        public let addressDefinition: String?

        @inlinable
        public init(addressDefinition: String? = nil) {
            self.addressDefinition = addressDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.addressDefinition, name: "addressDefinition", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case addressDefinition = "AddressDefinition"
        }
    }

    public struct RuleGroupSourceStatelessRuleMatchAttributesTcpFlags: AWSEncodableShape & AWSDecodableShape {
        /// Defines the flags from the Masks setting that must be set in order for the packet to match. Flags that are listed must be set. Flags that are not listed must not be set.
        public let flags: [String]?
        /// The set of flags to consider in the inspection. If not specified, then all flags are inspected.
        public let masks: [String]?

        @inlinable
        public init(flags: [String]? = nil, masks: [String]? = nil) {
            self.flags = flags
            self.masks = masks
        }

        public func validate(name: String) throws {
            try self.flags?.forEach {
                try validate($0, name: "flags[]", parent: name, pattern: "\\S")
            }
            try self.masks?.forEach {
                try validate($0, name: "masks[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case flags = "Flags"
            case masks = "Masks"
        }
    }

    public struct RuleGroupSourceStatelessRulesAndCustomActionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Custom actions for the rule group.
        public let customActions: [RuleGroupSourceCustomActionsDetails]?
        /// Stateless rules for the rule group.
        public let statelessRules: [RuleGroupSourceStatelessRulesDetails]?

        @inlinable
        public init(customActions: [RuleGroupSourceCustomActionsDetails]? = nil, statelessRules: [RuleGroupSourceStatelessRulesDetails]? = nil) {
            self.customActions = customActions
            self.statelessRules = statelessRules
        }

        public func validate(name: String) throws {
            try self.customActions?.forEach {
                try $0.validate(name: "\(name).customActions[]")
            }
            try self.statelessRules?.forEach {
                try $0.validate(name: "\(name).statelessRules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customActions = "CustomActions"
            case statelessRules = "StatelessRules"
        }
    }

    public struct RuleGroupSourceStatelessRulesDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the order in which to run this rule relative to all of the rules in the stateless rule group.
        public let priority: Int?
        /// Provides the definition of the stateless rule.
        public let ruleDefinition: RuleGroupSourceStatelessRuleDefinition?

        @inlinable
        public init(priority: Int? = nil, ruleDefinition: RuleGroupSourceStatelessRuleDefinition? = nil) {
            self.priority = priority
            self.ruleDefinition = ruleDefinition
        }

        public func validate(name: String) throws {
            try self.ruleDefinition?.validate(name: "\(name).ruleDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case priority = "Priority"
            case ruleDefinition = "RuleDefinition"
        }
    }

    public struct RuleGroupVariables: AWSEncodableShape & AWSDecodableShape {
        /// A list of IP addresses and address ranges, in CIDR notation.
        public let ipSets: RuleGroupVariablesIpSetsDetails?
        /// A list of port ranges.
        public let portSets: RuleGroupVariablesPortSetsDetails?

        @inlinable
        public init(ipSets: RuleGroupVariablesIpSetsDetails? = nil, portSets: RuleGroupVariablesPortSetsDetails? = nil) {
            self.ipSets = ipSets
            self.portSets = portSets
        }

        public func validate(name: String) throws {
            try self.ipSets?.validate(name: "\(name).ipSets")
            try self.portSets?.validate(name: "\(name).portSets")
        }

        private enum CodingKeys: String, CodingKey {
            case ipSets = "IpSets"
            case portSets = "PortSets"
        }
    }

    public struct RuleGroupVariablesIpSetsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The list of IP addresses and ranges.
        public let definition: [String]?

        @inlinable
        public init(definition: [String]? = nil) {
            self.definition = definition
        }

        public func validate(name: String) throws {
            try self.definition?.forEach {
                try validate($0, name: "definition[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
        }
    }

    public struct RuleGroupVariablesPortSetsDetails: AWSEncodableShape & AWSDecodableShape {
        /// The list of port ranges.
        public let definition: [String]?

        @inlinable
        public init(definition: [String]? = nil) {
            self.definition = definition
        }

        public func validate(name: String) throws {
            try self.definition?.forEach {
                try validate($0, name: "definition[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
        }
    }

    public struct SecurityControl: AWSDecodableShape {
        ///  The description of a security control across standards. This typically summarizes how Security Hub evaluates the control and the conditions under which it produces a failed finding. This parameter doesn't reference a specific standard.
        public let description: String?
        ///  The most recent reason for updating the customizable properties of a security control. This differs from the  UpdateReason field of the  BatchUpdateStandardsControlAssociations API, which tracks the  reason for updating the enablement status of a control. This field accepts alphanumeric  characters in addition to white spaces, dashes, and underscores.
        public let lastUpdateReason: String?
        ///  An object that identifies the name of a control parameter, its current value, and whether it has been customized.
        public let parameters: [String: ParameterConfiguration]?
        ///  A link to Security Hub documentation that explains how to remediate a failed finding for a security control.
        public let remediationUrl: String?
        ///  The Amazon Resource Name (ARN) for a security control across standards, such as arn:aws:securityhub:eu-central-1:123456789012:security-control/S3.1. This parameter doesn't mention a specific standard.
        public let securityControlArn: String?
        ///  The unique identifier of a security control across standards. Values for this field typically consist of an Amazon Web Services service name and a  number, such as APIGateway.3.
        public let securityControlId: String?
        ///  The enablement status of a security control in a specific standard.
        public let securityControlStatus: ControlStatus?
        ///  The severity of a security control. For more information about how Security Hub determines control severity, see  Assigning severity to control findings in the  Security Hub User Guide.
        public let severityRating: SeverityRating?
        /// The title of a security control.
        public let title: String?
        ///  Identifies whether customizable properties of a security control are reflected in Security Hub findings. A status of
        /// READY indicates that Security Hub uses the current control parameter values when running security checks of the control.
        /// A status of UPDATING indicates that all security checks might not use the current parameter values.
        public let updateStatus: UpdateStatus?

        @inlinable
        public init(description: String? = nil, lastUpdateReason: String? = nil, parameters: [String: ParameterConfiguration]? = nil, remediationUrl: String? = nil, securityControlArn: String? = nil, securityControlId: String? = nil, securityControlStatus: ControlStatus? = nil, severityRating: SeverityRating? = nil, title: String? = nil, updateStatus: UpdateStatus? = nil) {
            self.description = description
            self.lastUpdateReason = lastUpdateReason
            self.parameters = parameters
            self.remediationUrl = remediationUrl
            self.securityControlArn = securityControlArn
            self.securityControlId = securityControlId
            self.securityControlStatus = securityControlStatus
            self.severityRating = severityRating
            self.title = title
            self.updateStatus = updateStatus
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastUpdateReason = "LastUpdateReason"
            case parameters = "Parameters"
            case remediationUrl = "RemediationUrl"
            case securityControlArn = "SecurityControlArn"
            case securityControlId = "SecurityControlId"
            case securityControlStatus = "SecurityControlStatus"
            case severityRating = "SeverityRating"
            case title = "Title"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct SecurityControlCustomParameter: AWSEncodableShape & AWSDecodableShape {
        ///  An object that specifies parameter values for a control in a configuration policy.
        public let parameters: [String: ParameterConfiguration]?
        ///  The ID of the security control.
        public let securityControlId: String?

        @inlinable
        public init(parameters: [String: ParameterConfiguration]? = nil, securityControlId: String? = nil) {
            self.parameters = parameters
            self.securityControlId = securityControlId
        }

        public func validate(name: String) throws {
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, pattern: "\\S")
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.securityControlId, name: "securityControlId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "Parameters"
            case securityControlId = "SecurityControlId"
        }
    }

    public struct SecurityControlDefinition: AWSDecodableShape {
        ///  Specifies whether a security control is available in the current Amazon Web Services Region.
        public let currentRegionAvailability: RegionAvailabilityStatus?
        ///  Security control properties that you can customize. Currently, only parameter customization is supported for select  controls. An empty array is returned for controls that donâ€™t support custom properties.
        public let customizableProperties: [SecurityControlProperty]?
        ///  The description of a security control across standards. This typically summarizes how Security Hub evaluates the control and the conditions under which it produces a failed finding. This parameter doesn't reference a specific standard.
        public let description: String?
        ///  An object that provides a security control parameter name, description, and the options for customizing it. This
        /// object is excluded for a control that doesn't support custom parameters.
        public let parameterDefinitions: [String: ParameterDefinition]?
        ///  A link to Security Hub documentation that explains how to remediate a failed finding for a security control.
        public let remediationUrl: String?
        ///  The unique identifier of a security control across standards. Values for this field typically consist of an  Amazon Web Services service name and a number (for example, APIGateway.3). This parameter differs from  SecurityControlArn, which is a unique Amazon Resource Name (ARN) assigned to a control. The  ARN references the security control ID (for example, arn:aws:securityhub:eu-central-1:123456789012:security-control/APIGateway.3).
        public let securityControlId: String?
        ///  The severity of a security control. For more information about how Security Hub determines control severity,  see Assigning severity to control findings in the  Security Hub User Guide.
        public let severityRating: SeverityRating?
        ///  The title of a security control.
        public let title: String?

        @inlinable
        public init(currentRegionAvailability: RegionAvailabilityStatus? = nil, customizableProperties: [SecurityControlProperty]? = nil, description: String? = nil, parameterDefinitions: [String: ParameterDefinition]? = nil, remediationUrl: String? = nil, securityControlId: String? = nil, severityRating: SeverityRating? = nil, title: String? = nil) {
            self.currentRegionAvailability = currentRegionAvailability
            self.customizableProperties = customizableProperties
            self.description = description
            self.parameterDefinitions = parameterDefinitions
            self.remediationUrl = remediationUrl
            self.securityControlId = securityControlId
            self.severityRating = severityRating
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case currentRegionAvailability = "CurrentRegionAvailability"
            case customizableProperties = "CustomizableProperties"
            case description = "Description"
            case parameterDefinitions = "ParameterDefinitions"
            case remediationUrl = "RemediationUrl"
            case securityControlId = "SecurityControlId"
            case severityRating = "SeverityRating"
            case title = "Title"
        }
    }

    public struct SecurityControlParameter: AWSEncodableShape & AWSDecodableShape {
        ///  The name of a
        public let name: String?
        ///  The current value of a control parameter.
        public let value: [String]?

        @inlinable
        public init(name: String? = nil, value: [String]? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.value?.forEach {
                try validate($0, name: "value[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct SecurityControlsConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  A list of security controls that are disabled in the configuration policy. Security Hub enables all other  controls (including newly released controls) other than the listed controls.
        public let disabledSecurityControlIdentifiers: [String]?
        ///  A list of security controls that are enabled in the configuration policy. Security Hub disables all other  controls (including newly released controls) other than the listed controls.
        public let enabledSecurityControlIdentifiers: [String]?
        ///  A list of security controls and control parameter values that are included in a configuration policy.
        public let securityControlCustomParameters: [SecurityControlCustomParameter]?

        @inlinable
        public init(disabledSecurityControlIdentifiers: [String]? = nil, enabledSecurityControlIdentifiers: [String]? = nil, securityControlCustomParameters: [SecurityControlCustomParameter]? = nil) {
            self.disabledSecurityControlIdentifiers = disabledSecurityControlIdentifiers
            self.enabledSecurityControlIdentifiers = enabledSecurityControlIdentifiers
            self.securityControlCustomParameters = securityControlCustomParameters
        }

        public func validate(name: String) throws {
            try self.disabledSecurityControlIdentifiers?.forEach {
                try validate($0, name: "disabledSecurityControlIdentifiers[]", parent: name, pattern: "\\S")
            }
            try self.enabledSecurityControlIdentifiers?.forEach {
                try validate($0, name: "enabledSecurityControlIdentifiers[]", parent: name, pattern: "\\S")
            }
            try self.securityControlCustomParameters?.forEach {
                try $0.validate(name: "\(name).securityControlCustomParameters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case disabledSecurityControlIdentifiers = "DisabledSecurityControlIdentifiers"
            case enabledSecurityControlIdentifiers = "EnabledSecurityControlIdentifiers"
            case securityControlCustomParameters = "SecurityControlCustomParameters"
        }
    }

    public struct SecurityHubPolicy: AWSEncodableShape & AWSDecodableShape {
        ///  A list that defines which security standards are enabled in the configuration policy.
        public let enabledStandardIdentifiers: [String]?
        ///  An object that defines which security controls are enabled in the configuration policy. The enablement status  of a control is aligned across all of the enabled standards in an account.
        public let securityControlsConfiguration: SecurityControlsConfiguration?
        ///  Indicates whether Security Hub is enabled in the policy.
        public let serviceEnabled: Bool?

        @inlinable
        public init(enabledStandardIdentifiers: [String]? = nil, securityControlsConfiguration: SecurityControlsConfiguration? = nil, serviceEnabled: Bool? = nil) {
            self.enabledStandardIdentifiers = enabledStandardIdentifiers
            self.securityControlsConfiguration = securityControlsConfiguration
            self.serviceEnabled = serviceEnabled
        }

        public func validate(name: String) throws {
            try self.enabledStandardIdentifiers?.forEach {
                try validate($0, name: "enabledStandardIdentifiers[]", parent: name, pattern: "\\S")
            }
            try self.securityControlsConfiguration?.validate(name: "\(name).securityControlsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case enabledStandardIdentifiers = "EnabledStandardIdentifiers"
            case securityControlsConfiguration = "SecurityControlsConfiguration"
            case serviceEnabled = "ServiceEnabled"
        }
    }

    public struct SensitiveDataDetections: AWSEncodableShape & AWSDecodableShape {
        /// The total number of occurrences of sensitive data that were detected.
        public let count: Int64?
        /// Details about the sensitive data that was detected.
        public let occurrences: Occurrences?
        /// The type of sensitive data that was detected. For example, the type might indicate that the data is an email address.
        public let type: String?

        @inlinable
        public init(count: Int64? = nil, occurrences: Occurrences? = nil, type: String? = nil) {
            self.count = count
            self.occurrences = occurrences
            self.type = type
        }

        public func validate(name: String) throws {
            try self.occurrences?.validate(name: "\(name).occurrences")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case occurrences = "Occurrences"
            case type = "Type"
        }
    }

    public struct SensitiveDataResult: AWSEncodableShape & AWSDecodableShape {
        /// The category of sensitive data that was detected. For example, the category can indicate that the sensitive data involved credentials, financial information, or personal information.
        public let category: String?
        /// The list of detected instances of sensitive data.
        public let detections: [SensitiveDataDetections]?
        /// The total number of occurrences of sensitive data.
        public let totalCount: Int64?

        @inlinable
        public init(category: String? = nil, detections: [SensitiveDataDetections]? = nil, totalCount: Int64? = nil) {
            self.category = category
            self.detections = detections
            self.totalCount = totalCount
        }

        public func validate(name: String) throws {
            try self.validate(self.category, name: "category", parent: name, pattern: "\\S")
            try self.detections?.forEach {
                try $0.validate(name: "\(name).detections[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case detections = "Detections"
            case totalCount = "TotalCount"
        }
    }

    public struct Sequence: AWSEncodableShape & AWSDecodableShape {
        ///  Provides information about the actors involved in the attack sequence.
        public let actors: [Actor]?
        ///  Contains information about the network endpoints that were used in the attack sequence.
        public let endpoints: [NetworkEndpoint]?
        ///  Contains information about the indicators observed in the attack sequence. The values for   SignalIndicators are a subset of the values for SequenceIndicators, but the values for  these fields don't always match 1:1.
        public let sequenceIndicators: [Indicator]?
        ///  Contains information about the signals involved in the attack sequence.
        public let signals: [Signal]?
        ///  Unique identifier of the attack sequence.
        public let uid: String?

        @inlinable
        public init(actors: [Actor]? = nil, endpoints: [NetworkEndpoint]? = nil, sequenceIndicators: [Indicator]? = nil, signals: [Signal]? = nil, uid: String? = nil) {
            self.actors = actors
            self.endpoints = endpoints
            self.sequenceIndicators = sequenceIndicators
            self.signals = signals
            self.uid = uid
        }

        public func validate(name: String) throws {
            try self.actors?.forEach {
                try $0.validate(name: "\(name).actors[]")
            }
            try self.validate(self.actors, name: "actors", parent: name, max: 10)
            try self.endpoints?.forEach {
                try $0.validate(name: "\(name).endpoints[]")
            }
            try self.validate(self.endpoints, name: "endpoints", parent: name, max: 10)
            try self.sequenceIndicators?.forEach {
                try $0.validate(name: "\(name).sequenceIndicators[]")
            }
            try self.validate(self.sequenceIndicators, name: "sequenceIndicators", parent: name, max: 100)
            try self.signals?.forEach {
                try $0.validate(name: "\(name).signals[]")
            }
            try self.validate(self.signals, name: "signals", parent: name, max: 100)
            try self.validate(self.signals, name: "signals", parent: name, min: 1)
            try self.validate(self.uid, name: "uid", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case actors = "Actors"
            case endpoints = "Endpoints"
            case sequenceIndicators = "SequenceIndicators"
            case signals = "Signals"
            case uid = "Uid"
        }
    }

    public struct Severity: AWSEncodableShape & AWSDecodableShape {
        /// The severity value of the finding. The allowed values are the following.    INFORMATIONAL - No issue was found.    LOW - The issue does not require action on its own.    MEDIUM - The issue must be addressed but not urgently.    HIGH - The issue must be addressed as a priority.    CRITICAL - The issue must be remediated immediately to avoid it escalating.   If you provide Normalized and don't provide Label, then Label is set automatically as follows.    0 - INFORMATIONAL    1â€“39 - LOW    40â€“69 - MEDIUM    70â€“89 - HIGH    90â€“100 - CRITICAL
        public let label: SeverityLabel?
        /// Deprecated. The normalized severity of a finding. Instead of providing Normalized, provide Label. The value of Normalized can be an integer between 0 and 100. If you provide Label and don't provide Normalized, then Normalized is set automatically as follows.    INFORMATIONAL - 0    LOW - 1    MEDIUM - 40    HIGH - 70    CRITICAL - 90
        public let normalized: Int?
        /// The native severity from the finding product that generated the finding. Length Constraints: Minimum length of 1. Maximum length of 64.
        public let original: String?
        /// Deprecated. This attribute isn't included in findings. Instead of providing Product, provide Original. The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.
        public let product: Double?

        @inlinable
        public init(label: SeverityLabel? = nil, normalized: Int? = nil, original: String? = nil, product: Double? = nil) {
            self.label = label
            self.normalized = normalized
            self.original = original
            self.product = product
        }

        public func validate(name: String) throws {
            try self.validate(self.original, name: "original", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case normalized = "Normalized"
            case original = "Original"
            case product = "Product"
        }
    }

    public struct SeverityUpdate: AWSEncodableShape & AWSDecodableShape {
        /// The severity value of the finding. The allowed values are the following.    INFORMATIONAL - No issue was found.    LOW - The issue does not require action on its own.    MEDIUM - The issue must be addressed but not urgently.    HIGH - The issue must be addressed as a priority.    CRITICAL - The issue must be remediated immediately to avoid it escalating.
        public let label: SeverityLabel?
        /// The normalized severity for the finding. This attribute is to be deprecated in favor of Label. If you provide Normalized and don't provide Label, Label is set automatically as follows.   0 - INFORMATIONAL    1â€“39 - LOW    40â€“69 - MEDIUM    70â€“89 - HIGH    90â€“100 - CRITICAL
        public let normalized: Int?
        /// The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.
        public let product: Double?

        @inlinable
        public init(label: SeverityLabel? = nil, normalized: Int? = nil, product: Double? = nil) {
            self.label = label
            self.normalized = normalized
            self.product = product
        }

        public func validate(name: String) throws {
            try self.validate(self.normalized, name: "normalized", parent: name, max: 100)
            try self.validate(self.normalized, name: "normalized", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
            case normalized = "Normalized"
            case product = "Product"
        }
    }

    public struct Signal: AWSEncodableShape & AWSDecodableShape {
        ///  The IDs of the threat actors involved in the signal.
        public let actorIds: [String]?
        ///  The number of times this signal was observed.
        public let count: Int?
        ///  The timestamp when the first finding or activity related to this signal was observed.
        public let createdAt: Int64?
        /// Information about the endpoint IDs associated with this signal.
        public let endpointIds: [String]?
        ///  The timestamp when the first finding or activity related to this signal was observed.
        public let firstSeenAt: Int64?
        ///  The identifier of the signal.
        public let id: String?
        ///  The timestamp when the last finding or activity related to this signal was observed.
        public let lastSeenAt: Int64?
        ///  The name of the GuardDuty signal. For example, when signal type is FINDING,  the signal name is the name of the finding.
        public let name: String?
        ///  The Amazon Resource Name (ARN) of the product that generated the signal.
        public let productArn: String?
        ///  The ARN or ID of the Amazon Web Services resource associated with the signal.
        public let resourceIds: [String]?
        /// The severity associated with the signal. For more information about severity, see  Severity levels for GuardDuty findings in the Amazon GuardDuty User Guide.
        public let severity: Double?
        ///  Contains information about the indicators associated with the signals in this attack sequence finding. The values for  SignalIndicators are a subset of the values for SequenceIndicators, but the values for  these fields don't always match 1:1.
        public let signalIndicators: [Indicator]?
        ///  The description of the GuardDuty finding.
        public let title: String?
        ///  The type of the signal used to identify an attack sequence.  Signals can be GuardDuty findings or activities observed in data sources that GuardDuty monitors.  For more information, see  GuardDuty foundational data sources in the Amazon GuardDuty User Guide. A signal type can be one of the following values. Here are the related descriptions:    FINDING - Individually generated GuardDuty finding.    CLOUD_TRAIL - Activity observed from CloudTrail logs    S3_DATA_EVENTS - Activity observed from CloudTrail data events for Amazon Simple Storage Service (S3).  Activities associated with this type will show up only when you have enabled GuardDuty S3 Protection feature in your account. For more information about  S3 Protection and the steps to enable it, see S3 Protection in the Amazon GuardDuty User Guide.
        public let type: String?
        ///  The timestamp when this signal was last observed.
        public let updatedAt: Int64?

        @inlinable
        public init(actorIds: [String]? = nil, count: Int? = nil, createdAt: Int64? = nil, endpointIds: [String]? = nil, firstSeenAt: Int64? = nil, id: String? = nil, lastSeenAt: Int64? = nil, name: String? = nil, productArn: String? = nil, resourceIds: [String]? = nil, severity: Double? = nil, signalIndicators: [Indicator]? = nil, title: String? = nil, type: String? = nil, updatedAt: Int64? = nil) {
            self.actorIds = actorIds
            self.count = count
            self.createdAt = createdAt
            self.endpointIds = endpointIds
            self.firstSeenAt = firstSeenAt
            self.id = id
            self.lastSeenAt = lastSeenAt
            self.name = name
            self.productArn = productArn
            self.resourceIds = resourceIds
            self.severity = severity
            self.signalIndicators = signalIndicators
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }

        public func validate(name: String) throws {
            try self.actorIds?.forEach {
                try validate($0, name: "actorIds[]", parent: name, pattern: "\\S")
            }
            try self.endpointIds?.forEach {
                try validate($0, name: "endpointIds[]", parent: name, pattern: "\\S")
            }
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.productArn, name: "productArn", parent: name, pattern: "\\S")
            try self.resourceIds?.forEach {
                try validate($0, name: "resourceIds[]", parent: name, pattern: "\\S")
            }
            try self.signalIndicators?.forEach {
                try $0.validate(name: "\(name).signalIndicators[]")
            }
            try self.validate(self.signalIndicators, name: "signalIndicators", parent: name, max: 100)
            try self.validate(self.title, name: "title", parent: name, pattern: "\\S")
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case actorIds = "ActorIds"
            case count = "Count"
            case createdAt = "CreatedAt"
            case endpointIds = "EndpointIds"
            case firstSeenAt = "FirstSeenAt"
            case id = "Id"
            case lastSeenAt = "LastSeenAt"
            case name = "Name"
            case productArn = "ProductArn"
            case resourceIds = "ResourceIds"
            case severity = "Severity"
            case signalIndicators = "SignalIndicators"
            case title = "Title"
            case type = "Type"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct SoftwarePackage: AWSEncodableShape & AWSDecodableShape {
        /// The architecture used for the software package.
        public let architecture: String?
        /// The epoch of the software package.
        public let epoch: String?
        /// The file system path to the package manager inventory file.
        public let filePath: String?
        /// The version of the software package in which the vulnerability has been resolved.
        public let fixedInVersion: String?
        /// The name of the software package.
        public let name: String?
        /// The source of the package.
        public let packageManager: String?
        /// The release of the software package.
        public let release: String?
        /// Describes the actions a customer can take to resolve the vulnerability in the software package.
        public let remediation: String?
        /// The Amazon Resource Name (ARN) of the source layer.
        public let sourceLayerArn: String?
        /// The source layer hash of the vulnerable package.
        public let sourceLayerHash: String?
        /// The version of the software package.
        public let version: String?

        @inlinable
        public init(architecture: String? = nil, epoch: String? = nil, filePath: String? = nil, fixedInVersion: String? = nil, name: String? = nil, packageManager: String? = nil, release: String? = nil, remediation: String? = nil, sourceLayerArn: String? = nil, sourceLayerHash: String? = nil, version: String? = nil) {
            self.architecture = architecture
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLayerArn = sourceLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.architecture, name: "architecture", parent: name, pattern: "\\S")
            try self.validate(self.epoch, name: "epoch", parent: name, pattern: "\\S")
            try self.validate(self.filePath, name: "filePath", parent: name, pattern: "\\S")
            try self.validate(self.fixedInVersion, name: "fixedInVersion", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.packageManager, name: "packageManager", parent: name, pattern: "\\S")
            try self.validate(self.release, name: "release", parent: name, pattern: "\\S")
            try self.validate(self.remediation, name: "remediation", parent: name, pattern: "\\S")
            try self.validate(self.sourceLayerArn, name: "sourceLayerArn", parent: name, pattern: "\\S")
            try self.validate(self.sourceLayerHash, name: "sourceLayerHash", parent: name, pattern: "\\S")
            try self.validate(self.version, name: "version", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case architecture = "Architecture"
            case epoch = "Epoch"
            case filePath = "FilePath"
            case fixedInVersion = "FixedInVersion"
            case name = "Name"
            case packageManager = "PackageManager"
            case release = "Release"
            case remediation = "Remediation"
            case sourceLayerArn = "SourceLayerArn"
            case sourceLayerHash = "SourceLayerHash"
            case version = "Version"
        }
    }

    public struct SortCriterion: AWSEncodableShape {
        /// The finding attribute used to sort findings.
        public let field: String?
        /// The order used to sort findings.
        public let sortOrder: SortOrder?

        @inlinable
        public init(field: String? = nil, sortOrder: SortOrder? = nil) {
            self.field = field
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.field, name: "field", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case field = "Field"
            case sortOrder = "SortOrder"
        }
    }

    public struct Standard: AWSDecodableShape {
        /// A description of the standard.
        public let description: String?
        /// Whether the standard is enabled by default. When Security Hub is enabled from the console, if a standard is enabled by default, the check box for that standard is selected by default. When Security Hub is enabled using the EnableSecurityHub API operation, the standard is enabled by default unless EnableDefaultStandards is set to false.
        public let enabledByDefault: Bool?
        /// The name of the standard.
        public let name: String?
        /// The ARN of the standard.
        public let standardsArn: String?
        /// Provides details about the management of a standard.
        public let standardsManagedBy: StandardsManagedBy?

        @inlinable
        public init(description: String? = nil, enabledByDefault: Bool? = nil, name: String? = nil, standardsArn: String? = nil, standardsManagedBy: StandardsManagedBy? = nil) {
            self.description = description
            self.enabledByDefault = enabledByDefault
            self.name = name
            self.standardsArn = standardsArn
            self.standardsManagedBy = standardsManagedBy
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case enabledByDefault = "EnabledByDefault"
            case name = "Name"
            case standardsArn = "StandardsArn"
            case standardsManagedBy = "StandardsManagedBy"
        }
    }

    public struct StandardsControl: AWSDecodableShape {
        /// The identifier of the security standard control.
        public let controlId: String?
        /// The current status of the security standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.
        public let controlStatus: ControlStatus?
        /// The date and time that the status of the security standard control was most recently updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var controlStatusUpdatedAt: Date?
        /// The longer description of the security standard control. Provides information about what the control is checking for.
        public let description: String?
        /// The reason provided for the most recent change in status for the control.
        public let disabledReason: String?
        /// The list of requirements that are related to this control.
        public let relatedRequirements: [String]?
        /// A link to remediation information for the control in the Security Hub user documentation.
        public let remediationUrl: String?
        /// The severity of findings generated from this security standard control. The finding severity is based on an assessment of how easy it would be to compromise Amazon Web Services resources if the issue is detected.
        public let severityRating: SeverityRating?
        /// The ARN of the security standard control.
        public let standardsControlArn: String?
        /// The title of the security standard control.
        public let title: String?

        @inlinable
        public init(controlId: String? = nil, controlStatus: ControlStatus? = nil, controlStatusUpdatedAt: Date? = nil, description: String? = nil, disabledReason: String? = nil, relatedRequirements: [String]? = nil, remediationUrl: String? = nil, severityRating: SeverityRating? = nil, standardsControlArn: String? = nil, title: String? = nil) {
            self.controlId = controlId
            self.controlStatus = controlStatus
            self.controlStatusUpdatedAt = controlStatusUpdatedAt
            self.description = description
            self.disabledReason = disabledReason
            self.relatedRequirements = relatedRequirements
            self.remediationUrl = remediationUrl
            self.severityRating = severityRating
            self.standardsControlArn = standardsControlArn
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case controlId = "ControlId"
            case controlStatus = "ControlStatus"
            case controlStatusUpdatedAt = "ControlStatusUpdatedAt"
            case description = "Description"
            case disabledReason = "DisabledReason"
            case relatedRequirements = "RelatedRequirements"
            case remediationUrl = "RemediationUrl"
            case severityRating = "SeverityRating"
            case standardsControlArn = "StandardsControlArn"
            case title = "Title"
        }
    }

    public struct StandardsControlAssociationDetail: AWSDecodableShape {
        ///  Specifies whether a control is enabled or disabled in a specified standard.
        public let associationStatus: AssociationStatus?
        ///  The requirement that underlies a control in the compliance framework related to the standard.
        public let relatedRequirements: [String]?
        ///  The ARN of a security control across standards, such as arn:aws:securityhub:eu-central-1:123456789012:security-control/S3.1. This parameter doesn't mention a specific standard.
        public let securityControlArn: String?
        ///  The unique identifier of a security control across standards. Values for this field typically consist of an Amazon Web Services service  name and a number, such as APIGateway.3.
        public let securityControlId: String?
        ///  The Amazon Resource Name (ARN) of a security standard.
        public let standardsArn: String?
        ///  Provides the input parameter that Security Hub uses to call the UpdateStandardsControl API. This API can be used to enable or disable a control in a specified standard.
        public let standardsControlArns: [String]?
        ///  The description of a control. This typically summarizes how Security Hub evaluates the control and the  conditions under which it produces a failed finding. This parameter may reference a specific standard.
        public let standardsControlDescription: String?
        ///  The title of a control. This field may reference a specific standard.
        public let standardsControlTitle: String?
        ///  The time at which the enablement status of the control in the specified standard was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        ///  The reason for updating the enablement status of a control in a specified standard.
        public let updatedReason: String?

        @inlinable
        public init(associationStatus: AssociationStatus? = nil, relatedRequirements: [String]? = nil, securityControlArn: String? = nil, securityControlId: String? = nil, standardsArn: String? = nil, standardsControlArns: [String]? = nil, standardsControlDescription: String? = nil, standardsControlTitle: String? = nil, updatedAt: Date? = nil, updatedReason: String? = nil) {
            self.associationStatus = associationStatus
            self.relatedRequirements = relatedRequirements
            self.securityControlArn = securityControlArn
            self.securityControlId = securityControlId
            self.standardsArn = standardsArn
            self.standardsControlArns = standardsControlArns
            self.standardsControlDescription = standardsControlDescription
            self.standardsControlTitle = standardsControlTitle
            self.updatedAt = updatedAt
            self.updatedReason = updatedReason
        }

        private enum CodingKeys: String, CodingKey {
            case associationStatus = "AssociationStatus"
            case relatedRequirements = "RelatedRequirements"
            case securityControlArn = "SecurityControlArn"
            case securityControlId = "SecurityControlId"
            case standardsArn = "StandardsArn"
            case standardsControlArns = "StandardsControlArns"
            case standardsControlDescription = "StandardsControlDescription"
            case standardsControlTitle = "StandardsControlTitle"
            case updatedAt = "UpdatedAt"
            case updatedReason = "UpdatedReason"
        }
    }

    public struct StandardsControlAssociationId: AWSEncodableShape & AWSDecodableShape {
        ///  The unique identifier (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) of a security  control across standards.
        public let securityControlId: String?
        ///  The ARN of a standard.
        public let standardsArn: String?

        @inlinable
        public init(securityControlId: String? = nil, standardsArn: String? = nil) {
            self.securityControlId = securityControlId
            self.standardsArn = standardsArn
        }

        public func validate(name: String) throws {
            try self.validate(self.securityControlId, name: "securityControlId", parent: name, pattern: "\\S")
            try self.validate(self.standardsArn, name: "standardsArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case securityControlId = "SecurityControlId"
            case standardsArn = "StandardsArn"
        }
    }

    public struct StandardsControlAssociationSummary: AWSDecodableShape {
        ///  The enablement status of a control in a specific standard.
        public let associationStatus: AssociationStatus?
        ///  The requirement that underlies this control in the compliance framework related to the standard.
        public let relatedRequirements: [String]?
        ///  The ARN of a control, such as arn:aws:securityhub:eu-central-1:123456789012:security-control/S3.1. This parameter doesn't mention a specific standard.
        public let securityControlArn: String?
        ///  A unique standard-agnostic identifier for a control. Values for this field typically consist of an  Amazon Web Services service and a number, such as APIGateway.5. This field doesn't reference a specific standard.
        public let securityControlId: String?
        ///  The Amazon Resource Name (ARN) of a standard.
        public let standardsArn: String?
        ///  The description of a control. This typically summarizes how Security Hub evaluates the control and the  conditions under which it produces a failed finding. The parameter may reference a specific standard.
        public let standardsControlDescription: String?
        ///  The title of a control.
        public let standardsControlTitle: String?
        /// The last time that a control's enablement status in a specified standard was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The reason for updating a control's enablement status in a specified standard.
        public let updatedReason: String?

        @inlinable
        public init(associationStatus: AssociationStatus? = nil, relatedRequirements: [String]? = nil, securityControlArn: String? = nil, securityControlId: String? = nil, standardsArn: String? = nil, standardsControlDescription: String? = nil, standardsControlTitle: String? = nil, updatedAt: Date? = nil, updatedReason: String? = nil) {
            self.associationStatus = associationStatus
            self.relatedRequirements = relatedRequirements
            self.securityControlArn = securityControlArn
            self.securityControlId = securityControlId
            self.standardsArn = standardsArn
            self.standardsControlDescription = standardsControlDescription
            self.standardsControlTitle = standardsControlTitle
            self.updatedAt = updatedAt
            self.updatedReason = updatedReason
        }

        private enum CodingKeys: String, CodingKey {
            case associationStatus = "AssociationStatus"
            case relatedRequirements = "RelatedRequirements"
            case securityControlArn = "SecurityControlArn"
            case securityControlId = "SecurityControlId"
            case standardsArn = "StandardsArn"
            case standardsControlDescription = "StandardsControlDescription"
            case standardsControlTitle = "StandardsControlTitle"
            case updatedAt = "UpdatedAt"
            case updatedReason = "UpdatedReason"
        }
    }

    public struct StandardsControlAssociationUpdate: AWSEncodableShape & AWSDecodableShape {
        /// The desired enablement status of the control in the standard.
        public let associationStatus: AssociationStatus?
        /// The unique identifier for the security control whose enablement status you want to update.
        public let securityControlId: String?
        /// The Amazon Resource Name (ARN) of the standard in which you want to update the control's enablement status.
        public let standardsArn: String?
        /// The reason for updating the control's enablement status in the standard.
        public let updatedReason: String?

        @inlinable
        public init(associationStatus: AssociationStatus? = nil, securityControlId: String? = nil, standardsArn: String? = nil, updatedReason: String? = nil) {
            self.associationStatus = associationStatus
            self.securityControlId = securityControlId
            self.standardsArn = standardsArn
            self.updatedReason = updatedReason
        }

        public func validate(name: String) throws {
            try self.validate(self.securityControlId, name: "securityControlId", parent: name, pattern: "\\S")
            try self.validate(self.standardsArn, name: "standardsArn", parent: name, pattern: "\\S")
            try self.validate(self.updatedReason, name: "updatedReason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case associationStatus = "AssociationStatus"
            case securityControlId = "SecurityControlId"
            case standardsArn = "StandardsArn"
            case updatedReason = "UpdatedReason"
        }
    }

    public struct StandardsManagedBy: AWSDecodableShape {
        /// An identifier for the company that manages a specific security standard. For existing standards, the value is equal to Amazon Web Services.
        public let company: String?
        /// An identifier for the product that manages a specific security standard. For existing standards, the value is equal to the Amazon Web Services service that manages the standard.
        public let product: String?

        @inlinable
        public init(company: String? = nil, product: String? = nil) {
            self.company = company
            self.product = product
        }

        private enum CodingKeys: String, CodingKey {
            case company = "Company"
            case product = "Product"
        }
    }

    public struct StandardsStatusReason: AWSDecodableShape {
        /// The reason code that represents the reason for the current status of a standard subscription.
        public let statusReasonCode: StatusReasonCode?

        @inlinable
        public init(statusReasonCode: StatusReasonCode? = nil) {
            self.statusReasonCode = statusReasonCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusReasonCode = "StatusReasonCode"
        }
    }

    public struct StandardsSubscription: AWSDecodableShape {
        /// The ARN of the standard.
        public let standardsArn: String?
        /// Specifies whether you can retrieve information about and configure individual controls that apply to the standard. Possible values are:    READY_FOR_UPDATES - Controls in the standard can be retrieved and configured.    NOT_READY_FOR_UPDATES - Controls in the standard cannot be retrieved or configured.
        public let standardsControlsUpdatable: StandardsControlsUpdatable?
        /// A key-value pair of input for the standard.
        public let standardsInput: [String: String]?
        /// The status of your subscription to the standard. Possible values are:    PENDING - The standard is in the process of being enabled. Or the standard is already  enabled and Security Hub is adding new controls to the standard.    READY - The standard is enabled.    INCOMPLETE - The standard could not be enabled completely. One or more errors (StandardsStatusReason)  occurred when Security Hub attempted to enable the standard.    DELETING - The standard is in the process of being disabled.    FAILED - The standard could not be disabled. One or more errors (StandardsStatusReason)  occurred when Security Hub attempted to disable the standard.
        public let standardsStatus: StandardsStatus?
        /// The reason for the current status.
        public let standardsStatusReason: StandardsStatusReason?
        /// The ARN of the resource that represents your subscription to the standard.
        public let standardsSubscriptionArn: String?

        @inlinable
        public init(standardsArn: String? = nil, standardsControlsUpdatable: StandardsControlsUpdatable? = nil, standardsInput: [String: String]? = nil, standardsStatus: StandardsStatus? = nil, standardsStatusReason: StandardsStatusReason? = nil, standardsSubscriptionArn: String? = nil) {
            self.standardsArn = standardsArn
            self.standardsControlsUpdatable = standardsControlsUpdatable
            self.standardsInput = standardsInput
            self.standardsStatus = standardsStatus
            self.standardsStatusReason = standardsStatusReason
            self.standardsSubscriptionArn = standardsSubscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case standardsArn = "StandardsArn"
            case standardsControlsUpdatable = "StandardsControlsUpdatable"
            case standardsInput = "StandardsInput"
            case standardsStatus = "StandardsStatus"
            case standardsStatusReason = "StandardsStatusReason"
            case standardsSubscriptionArn = "StandardsSubscriptionArn"
        }
    }

    public struct StandardsSubscriptionRequest: AWSEncodableShape {
        /// The ARN of the standard that you want to enable. To view the list of available standards and their ARNs, use the DescribeStandards operation.
        public let standardsArn: String?
        /// A key-value pair of input for the standard.
        public let standardsInput: [String: String]?

        @inlinable
        public init(standardsArn: String? = nil, standardsInput: [String: String]? = nil) {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
        }

        public func validate(name: String) throws {
            try self.validate(self.standardsArn, name: "standardsArn", parent: name, pattern: "\\S")
            try self.standardsInput?.forEach {
                try validate($0.key, name: "standardsInput.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "standardsInput[\"\($0.key)\"]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case standardsArn = "StandardsArn"
            case standardsInput = "StandardsInput"
        }
    }

    public struct StartConfigurationPolicyAssociationRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of a configuration policy, the universally unique identifier (UUID) of a  configuration policy, or a value of SELF_MANAGED_SECURITY_HUB for a self-managed configuration.
        public let configurationPolicyIdentifier: String?
        ///  The identifier of the target account, organizational unit, or the root to associate with the specified configuration.
        public let target: Target?

        @inlinable
        public init(configurationPolicyIdentifier: String? = nil, target: Target? = nil) {
            self.configurationPolicyIdentifier = configurationPolicyIdentifier
            self.target = target
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationPolicyIdentifier, name: "configurationPolicyIdentifier", parent: name, pattern: "\\S")
            try self.target?.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationPolicyIdentifier = "ConfigurationPolicyIdentifier"
            case target = "Target"
        }
    }

    public struct StartConfigurationPolicyAssociationResponse: AWSDecodableShape {
        ///  The current status of the association between the specified target and the configuration.
        public let associationStatus: ConfigurationPolicyAssociationStatus?
        ///  An explanation for a FAILED value for AssociationStatus.
        public let associationStatusMessage: String?
        ///  Indicates whether the association between the specified target and the configuration was directly applied by the  Security Hub delegated administrator or inherited from a parent.
        public let associationType: AssociationType?
        ///  The UUID of the configuration policy.
        public let configurationPolicyId: String?
        ///  The identifier of the target account, organizational unit, or the organization root with which the configuration is associated.
        public let targetId: String?
        ///  Indicates whether the target is an Amazon Web Services account, organizational unit, or the organization root.
        public let targetType: TargetType?
        ///  The date and time, in UTC and ISO 8601 format, that the configuration policy association was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(associationStatus: ConfigurationPolicyAssociationStatus? = nil, associationStatusMessage: String? = nil, associationType: AssociationType? = nil, configurationPolicyId: String? = nil, targetId: String? = nil, targetType: TargetType? = nil, updatedAt: Date? = nil) {
            self.associationStatus = associationStatus
            self.associationStatusMessage = associationStatusMessage
            self.associationType = associationType
            self.configurationPolicyId = configurationPolicyId
            self.targetId = targetId
            self.targetType = targetType
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case associationStatus = "AssociationStatus"
            case associationStatusMessage = "AssociationStatusMessage"
            case associationType = "AssociationType"
            case configurationPolicyId = "ConfigurationPolicyId"
            case targetId = "TargetId"
            case targetType = "TargetType"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct StartConfigurationPolicyDisassociationRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of a configuration policy, the universally unique identifier (UUID) of a  configuration policy, or a value of SELF_MANAGED_SECURITY_HUB for a self-managed configuration.
        public let configurationPolicyIdentifier: String?
        ///  The identifier of the target account, organizational unit, or the root to disassociate from the specified configuration.
        public let target: Target?

        @inlinable
        public init(configurationPolicyIdentifier: String? = nil, target: Target? = nil) {
            self.configurationPolicyIdentifier = configurationPolicyIdentifier
            self.target = target
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationPolicyIdentifier, name: "configurationPolicyIdentifier", parent: name, pattern: "\\S")
            try self.target?.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationPolicyIdentifier = "ConfigurationPolicyIdentifier"
            case target = "Target"
        }
    }

    public struct StartConfigurationPolicyDisassociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StatelessCustomActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// Information about metrics to publish to CloudWatch.
        public let publishMetricAction: StatelessCustomPublishMetricAction?

        @inlinable
        public init(publishMetricAction: StatelessCustomPublishMetricAction? = nil) {
            self.publishMetricAction = publishMetricAction
        }

        public func validate(name: String) throws {
            try self.publishMetricAction?.validate(name: "\(name).publishMetricAction")
        }

        private enum CodingKeys: String, CodingKey {
            case publishMetricAction = "PublishMetricAction"
        }
    }

    public struct StatelessCustomPublishMetricAction: AWSEncodableShape & AWSDecodableShape {
        /// Defines CloudWatch dimension values to publish.
        public let dimensions: [StatelessCustomPublishMetricActionDimension]?

        @inlinable
        public init(dimensions: [StatelessCustomPublishMetricActionDimension]? = nil) {
            self.dimensions = dimensions
        }

        public func validate(name: String) throws {
            try self.dimensions?.forEach {
                try $0.validate(name: "\(name).dimensions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dimensions = "Dimensions"
        }
    }

    public struct StatelessCustomPublishMetricActionDimension: AWSEncodableShape & AWSDecodableShape {
        /// The value to use for the custom metric dimension.
        public let value: String?

        @inlinable
        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct StatusReason: AWSEncodableShape & AWSDecodableShape {
        /// The corresponding description for the status reason code.
        public let description: String?
        /// A code that represents a reason for the control status. For the list of status reason codes and their meanings, see Compliance details for control findings in the Security Hub User Guide.
        public let reasonCode: String?

        @inlinable
        public init(description: String? = nil, reasonCode: String? = nil) {
            self.description = description
            self.reasonCode = reasonCode
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.reasonCode, name: "reasonCode", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case reasonCode = "ReasonCode"
        }
    }

    public struct StringConfigurationOptions: AWSDecodableShape {
        ///  The Security Hub default value for a control parameter that is a string.
        public let defaultValue: String?
        ///  The description of the RE2 regular expression.
        public let expressionDescription: String?
        ///  An RE2 regular expression that Security Hub uses to validate a user-provided control parameter string.
        public let re2Expression: String?

        @inlinable
        public init(defaultValue: String? = nil, expressionDescription: String? = nil, re2Expression: String? = nil) {
            self.defaultValue = defaultValue
            self.expressionDescription = expressionDescription
            self.re2Expression = re2Expression
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case expressionDescription = "ExpressionDescription"
            case re2Expression = "Re2Expression"
        }
    }

    public struct StringFilter: AWSEncodableShape & AWSDecodableShape {
        /// The condition to apply to a string value when filtering Security Hub findings. To search for values that have the filter value, use one of the following comparison operators:   To search for values that include the filter value, use CONTAINS. For example, the  filter Title CONTAINS CloudFront matches findings that have a Title that  includes the string CloudFront.   To search for values that exactly match the filter value, use EQUALS. For example,  the filter AwsAccountId EQUALS 123456789012 only matches findings that have an account ID of  123456789012.   To search for values that start with the filter value, use PREFIX. For example, the  filter ResourceRegion PREFIX us matches findings that have a ResourceRegion that starts  with us. A ResourceRegion that starts with a different value, such as af,  ap, or ca, doesn't match.    CONTAINS, EQUALS, and PREFIX filters on the same field are joined by  OR. A finding matches if it matches any one of those filters. For example, the filters Title CONTAINS CloudFront OR  Title CONTAINS CloudWatch match a finding that includes either CloudFront,  CloudWatch, or both strings in the title. To search for values that donâ€™t have the filter value, use one of the following comparison operators:   To search for values that exclude the filter value, use NOT_CONTAINS. For example, the  filter Title NOT_CONTAINS CloudFront matches findings that have a Title that  excludes the string CloudFront.   To search for values other than the filter value, use NOT_EQUALS. For  example, the filter AwsAccountId NOT_EQUALS 123456789012 only matches findings that have an account  ID other than 123456789012.   To search for values that don't start with the filter value, use PREFIX_NOT_EQUALS. For  example, the filter ResourceRegion PREFIX_NOT_EQUALS us matches findings with a  ResourceRegion that starts with a value other than us.    NOT_CONTAINS, NOT_EQUALS, and PREFIX_NOT_EQUALS filters on the same field  are joined by AND. A finding matches only if it matches all of those filters. For example, the filters Title NOT_CONTAINS CloudFront AND  Title NOT_CONTAINS CloudWatch match a finding that excludes both CloudFront and  CloudWatch in the title. You canâ€™t have both a CONTAINS filter and a NOT_CONTAINS filter on the same field. Similarly,  you can't provide both an EQUALS filter and a NOT_EQUALS or  PREFIX_NOT_EQUALS filter on the same field. Combining filters in this way returns an error. CONTAINS filters  can only be used with other CONTAINS filters. NOT_CONTAINS filters can only be used with  other NOT_CONTAINS filters.  You can combine PREFIX filters with NOT_EQUALS or PREFIX_NOT_EQUALS filters for the same field.  Security Hub first processes the PREFIX filters, and then the NOT_EQUALS or PREFIX_NOT_EQUALS filters. For example, for the following filters, Security Hub first identifies findings that have resource types  that start with either AwsIam or AwsEc2. It then excludes findings that have a resource  type of AwsIamPolicy and findings that have a resource type of AwsEc2NetworkInterface.    ResourceType PREFIX AwsIam     ResourceType PREFIX AwsEc2     ResourceType NOT_EQUALS AwsIamPolicy     ResourceType NOT_EQUALS AwsEc2NetworkInterface     CONTAINS and NOT_CONTAINS operators can be used only with automation rules. For more information,  see Automation rules in the Security Hub User Guide.
        public let comparison: StringFilterComparison?
        /// The string filter value. Filter values are case sensitive. For example, the product name for control-based findings is Security Hub. If you provide security hub as the filter value, there's no match.
        public let value: String?

        @inlinable
        public init(comparison: StringFilterComparison? = nil, value: String? = nil) {
            self.comparison = comparison
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case value = "Value"
        }
    }

    public struct StringListConfigurationOptions: AWSDecodableShape {
        ///  The Security Hub default value for a control parameter that is a list of strings.
        public let defaultValue: [String]?
        ///  The description of the RE2 regular expression.
        public let expressionDescription: String?
        ///  The maximum number of list items that a string list control parameter can accept.
        public let maxItems: Int?
        ///  An RE2 regular expression that Security Hub uses to validate a user-provided list of strings for a control  parameter.
        public let re2Expression: String?

        @inlinable
        public init(defaultValue: [String]? = nil, expressionDescription: String? = nil, maxItems: Int? = nil, re2Expression: String? = nil) {
            self.defaultValue = defaultValue
            self.expressionDescription = expressionDescription
            self.maxItems = maxItems
            self.re2Expression = re2Expression
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case expressionDescription = "ExpressionDescription"
            case maxItems = "MaxItems"
            case re2Expression = "Re2Expression"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to apply the tags to.
        public let resourceArn: String
        /// The tags to add to the resource. You can add up to 50 tags at a time. The tag keys can be no longer than 128 characters. The tag values can be no longer than 256 characters.
        public let tags: [String: String]?

        @inlinable
        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:securityhub:")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Threat: AWSEncodableShape & AWSDecodableShape {
        /// Provides information about the file paths that were affected by the threat.
        /// 		 Array Members: Minimum number of 1 item. Maximum number of 5 items.
        public let filePaths: [FilePaths]?
        /// This total number of items in which the threat has been detected.
        ///
        public let itemCount: Int?
        /// The name of the threat.
        /// 		 Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public let name: String?
        /// The severity of the threat.
        /// 		 Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public let severity: String?

        @inlinable
        public init(filePaths: [FilePaths]? = nil, itemCount: Int? = nil, name: String? = nil, severity: String? = nil) {
            self.filePaths = filePaths
            self.itemCount = itemCount
            self.name = name
            self.severity = severity
        }

        public func validate(name: String) throws {
            try self.filePaths?.forEach {
                try $0.validate(name: "\(name).filePaths[]")
            }
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.severity, name: "severity", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case filePaths = "FilePaths"
            case itemCount = "ItemCount"
            case name = "Name"
            case severity = "Severity"
        }
    }

    public struct ThreatIntelIndicator: AWSEncodableShape & AWSDecodableShape {
        /// The category of a threat intelligence indicator.
        public let category: ThreatIntelIndicatorCategory?
        /// Indicates when the most recent instance of a threat intelligence indicator was observed. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let lastObservedAt: String?
        /// The source of the threat intelligence indicator. Length Constraints: Minimum of 1 length. Maximum of 64 length.
        public let source: String?
        /// The URL to the page or site where you can get more information about the threat intelligence indicator.
        public let sourceUrl: String?
        /// The type of threat intelligence indicator.
        public let type: ThreatIntelIndicatorType?
        /// The value of a threat intelligence indicator. Length Constraints: Minimum of 1 length. Maximum of 512 length.
        public let value: String?

        @inlinable
        public init(category: ThreatIntelIndicatorCategory? = nil, lastObservedAt: String? = nil, source: String? = nil, sourceUrl: String? = nil, type: ThreatIntelIndicatorType? = nil, value: String? = nil) {
            self.category = category
            self.lastObservedAt = lastObservedAt
            self.source = source
            self.sourceUrl = sourceUrl
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.lastObservedAt, name: "lastObservedAt", parent: name, pattern: "\\S")
            try self.validate(self.source, name: "source", parent: name, pattern: "\\S")
            try self.validate(self.sourceUrl, name: "sourceUrl", parent: name, pattern: "\\S")
            try self.validate(self.value, name: "value", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case lastObservedAt = "LastObservedAt"
            case source = "Source"
            case sourceUrl = "SourceUrl"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct UnprocessedAutomationRule: AWSDecodableShape {
        ///  The error code associated with the unprocessed automation rule.
        public let errorCode: Int?
        ///  An error message describing why a request didn't process a specific rule.
        public let errorMessage: String?
        ///  The Amazon Resource Name (ARN) for the unprocessed automation rule.
        public let ruleArn: String?

        @inlinable
        public init(errorCode: Int? = nil, errorMessage: String? = nil, ruleArn: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.ruleArn = ruleArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case ruleArn = "RuleArn"
        }
    }

    public struct UnprocessedConfigurationPolicyAssociation: AWSDecodableShape {
        ///  Configuration policy association identifiers that were specified in a BatchGetConfigurationPolicyAssociations  request but couldnâ€™t be processed due to an error.
        public let configurationPolicyAssociationIdentifiers: ConfigurationPolicyAssociation?
        ///  An HTTP status code that identifies why the configuration policy association failed.
        public let errorCode: String?
        ///  A string that identifies why the configuration policy association failed.
        public let errorReason: String?

        @inlinable
        public init(configurationPolicyAssociationIdentifiers: ConfigurationPolicyAssociation? = nil, errorCode: String? = nil, errorReason: String? = nil) {
            self.configurationPolicyAssociationIdentifiers = configurationPolicyAssociationIdentifiers
            self.errorCode = errorCode
            self.errorReason = errorReason
        }

        private enum CodingKeys: String, CodingKey {
            case configurationPolicyAssociationIdentifiers = "ConfigurationPolicyAssociationIdentifiers"
            case errorCode = "ErrorCode"
            case errorReason = "ErrorReason"
        }
    }

    public struct UnprocessedSecurityControl: AWSDecodableShape {
        ///  The error code for the unprocessed security control.
        public let errorCode: UnprocessedErrorCode?
        ///  The reason why the security control was unprocessed.
        public let errorReason: String?
        ///  The control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) for which a response couldn't be returned.
        public let securityControlId: String?

        @inlinable
        public init(errorCode: UnprocessedErrorCode? = nil, errorReason: String? = nil, securityControlId: String? = nil) {
            self.errorCode = errorCode
            self.errorReason = errorReason
            self.securityControlId = securityControlId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorReason = "ErrorReason"
            case securityControlId = "SecurityControlId"
        }
    }

    public struct UnprocessedStandardsControlAssociation: AWSDecodableShape {
        /// The error code for the unprocessed standard and control association.
        public let errorCode: UnprocessedErrorCode?
        /// The reason why the standard and control association was unprocessed.
        public let errorReason: String?
        ///  An array with one or more objects that includes a security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) and the Amazon Resource Name (ARN) of a standard. This parameter shows the specific controls for which the enablement status couldn't be retrieved in specified standards when calling BatchUpdateStandardsControlAssociations.
        public let standardsControlAssociationId: StandardsControlAssociationId?

        @inlinable
        public init(errorCode: UnprocessedErrorCode? = nil, errorReason: String? = nil, standardsControlAssociationId: StandardsControlAssociationId? = nil) {
            self.errorCode = errorCode
            self.errorReason = errorReason
            self.standardsControlAssociationId = standardsControlAssociationId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorReason = "ErrorReason"
            case standardsControlAssociationId = "StandardsControlAssociationId"
        }
    }

    public struct UnprocessedStandardsControlAssociationUpdate: AWSDecodableShape {
        /// The error code for the unprocessed update of the control's enablement status in the specified standard.
        public let errorCode: UnprocessedErrorCode?
        /// The reason why a control's enablement status in the specified standard couldn't be updated.
        public let errorReason: String?
        /// An array of control and standard associations for which an update failed when calling  BatchUpdateStandardsControlAssociations.
        public let standardsControlAssociationUpdate: StandardsControlAssociationUpdate?

        @inlinable
        public init(errorCode: UnprocessedErrorCode? = nil, errorReason: String? = nil, standardsControlAssociationUpdate: StandardsControlAssociationUpdate? = nil) {
            self.errorCode = errorCode
            self.errorReason = errorReason
            self.standardsControlAssociationUpdate = standardsControlAssociationUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorReason = "ErrorReason"
            case standardsControlAssociationUpdate = "StandardsControlAssociationUpdate"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to remove the tags from.
        public let resourceArn: String
        /// The tag keys associated with the tags to remove from the resource. You can remove up to 50 tags at a time.
        public let tagKeys: [String]?

        @inlinable
        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:securityhub:")
            try self.tagKeys?.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateActionTargetRequest: AWSEncodableShape {
        /// The ARN of the custom action target to update.
        public let actionTargetArn: String
        /// The updated description for the custom action target.
        public let description: String?
        /// The updated name of the custom action target.
        public let name: String?

        @inlinable
        public init(actionTargetArn: String, description: String? = nil, name: String? = nil) {
            self.actionTargetArn = actionTargetArn
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionTargetArn, key: "ActionTargetArn")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.actionTargetArn, name: "actionTargetArn", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateActionTargetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAutomationRulesRequestItem: AWSEncodableShape {
        ///  One or more actions to update finding fields if a finding matches the conditions  specified in Criteria.
        public let actions: [AutomationRulesAction]?
        ///  A set of ASFF finding field attributes and corresponding expected values that  Security Hub uses to filter findings. If a rule is enabled and a finding matches the conditions specified in this parameter, Security Hub applies the rule action to the finding.
        public let criteria: AutomationRulesFindingFilters?
        ///  A description of the rule.
        public let description: String?
        /// Specifies whether a rule is the last to be applied with respect to a finding that matches the rule criteria. This is useful when a finding  matches the criteria for multiple rules, and each rule has different actions. If a rule is terminal, Security Hub applies the rule action to a finding that matches  the rule criteria and doesn't evaluate other rules for the finding. By default, a rule isn't terminal.
        public let isTerminal: Bool?
        ///  The Amazon Resource Name (ARN) for the rule.
        public let ruleArn: String?
        ///  The name of the rule.
        public let ruleName: String?
        ///  An integer ranging from 1 to 1000 that represents the order in which the rule action is applied to findings. Security Hub applies rules with lower values for this parameter first.
        public let ruleOrder: Int?
        ///  Whether the rule is active after it is created. If  this parameter is equal to ENABLED, Security Hub starts applying the rule to findings  and finding updates after the rule is created. To change the value of this parameter after creating a rule, use  BatchUpdateAutomationRules .
        public let ruleStatus: RuleStatus?

        @inlinable
        public init(actions: [AutomationRulesAction]? = nil, criteria: AutomationRulesFindingFilters? = nil, description: String? = nil, isTerminal: Bool? = nil, ruleArn: String? = nil, ruleName: String? = nil, ruleOrder: Int? = nil, ruleStatus: RuleStatus? = nil) {
            self.actions = actions
            self.criteria = criteria
            self.description = description
            self.isTerminal = isTerminal
            self.ruleArn = ruleArn
            self.ruleName = ruleName
            self.ruleOrder = ruleOrder
            self.ruleStatus = ruleStatus
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 1)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.criteria?.validate(name: "\(name).criteria")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.ruleArn, name: "ruleArn", parent: name, pattern: "\\S")
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "\\S")
            try self.validate(self.ruleOrder, name: "ruleOrder", parent: name, max: 1000)
            try self.validate(self.ruleOrder, name: "ruleOrder", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case criteria = "Criteria"
            case description = "Description"
            case isTerminal = "IsTerminal"
            case ruleArn = "RuleArn"
            case ruleName = "RuleName"
            case ruleOrder = "RuleOrder"
            case ruleStatus = "RuleStatus"
        }
    }

    public struct UpdateConfigurationPolicyRequest: AWSEncodableShape {
        ///  An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or  disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls.  If you provide a list of security controls that are enabled in the configuration policy, Security Hub disables all other controls (including newly  released controls). If you provide a list of security controls that are disabled in the configuration policy, Security Hub  enables all other controls (including newly released controls).  When updating a configuration policy, provide a complete list of standards that you want to enable and a complete list  of controls that you want to enable or disable. The updated configuration replaces the current configuration.
        public let configurationPolicy: Policy?
        ///  The description of the configuration policy.
        public let description: String?
        ///  The Amazon Resource Name (ARN) or universally unique identifier (UUID) of the configuration policy.
        public let identifier: String
        ///  The name of the configuration policy. Alphanumeric characters and the following ASCII characters are permitted:  -, ., !, *, /.
        public let name: String?
        ///  The reason for updating the configuration policy.
        public let updatedReason: String?

        @inlinable
        public init(configurationPolicy: Policy? = nil, description: String? = nil, identifier: String, name: String? = nil, updatedReason: String? = nil) {
            self.configurationPolicy = configurationPolicy
            self.description = description
            self.identifier = identifier
            self.name = name
            self.updatedReason = updatedReason
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.configurationPolicy, forKey: .configurationPolicy)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.updatedReason, forKey: .updatedReason)
        }

        public func validate(name: String) throws {
            try self.configurationPolicy?.validate(name: "\(name).configurationPolicy")
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.updatedReason, name: "updatedReason", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationPolicy = "ConfigurationPolicy"
            case description = "Description"
            case name = "Name"
            case updatedReason = "UpdatedReason"
        }
    }

    public struct UpdateConfigurationPolicyResponse: AWSDecodableShape {
        ///  The ARN of the configuration policy.
        public let arn: String?
        ///  An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or  disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls. If the request included a  list of security controls that are enabled in the configuration policy, Security Hub disables all other controls (including  newly released controls). If the request included a list of security controls that are disabled in the configuration policy,  Security Hub enables all other controls (including newly released controls).
        public let configurationPolicy: Policy?
        ///  The date and time, in UTC and ISO 8601 format, that the configuration policy was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        ///  The description of the configuration policy.
        public let description: String?
        ///  The UUID of the configuration policy.
        public let id: String?
        ///  The name of the configuration policy.
        public let name: String?
        ///  The date and time, in UTC and ISO 8601 format, that the configuration policy was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(arn: String? = nil, configurationPolicy: Policy? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, updatedAt: Date? = nil) {
            self.arn = arn
            self.configurationPolicy = configurationPolicy
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case configurationPolicy = "ConfigurationPolicy"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct UpdateFindingAggregatorRequest: AWSEncodableShape {
        /// The ARN of the finding aggregator. To obtain the ARN, use ListFindingAggregators.
        public let findingAggregatorArn: String?
        /// Indicates whether to aggregate findings from all of the available Regions in the current partition. Also determines whether to automatically aggregate findings from new Regions as Security Hub supports them and you opt into them. The selected option also determines how to use the Regions provided in the Regions list. The options are as follows:    ALL_REGIONS - Aggregates findings from all of the Regions where Security Hub is enabled. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.     ALL_REGIONS_EXCEPT_SPECIFIED - Aggregates findings from all of the Regions where Security Hub is enabled, except for the Regions listed in the Regions parameter. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.     SPECIFIED_REGIONS - Aggregates findings only from the Regions listed in the Regions parameter. Security Hub does not automatically aggregate findings from new Regions.     NO_REGIONS - Aggregates no data because no Regions are selected as linked Regions.
        public let regionLinkingMode: String?
        /// If RegionLinkingMode is ALL_REGIONS_EXCEPT_SPECIFIED, then this is a space-separated list of Regions that don't replicate and send findings to the home Region. If RegionLinkingMode is SPECIFIED_REGIONS, then this is a space-separated list of Regions that do replicate and send findings to the home Region. An InvalidInputException error results if you populate this field while RegionLinkingMode is  NO_REGIONS.
        public let regions: [String]?

        @inlinable
        public init(findingAggregatorArn: String? = nil, regionLinkingMode: String? = nil, regions: [String]? = nil) {
            self.findingAggregatorArn = findingAggregatorArn
            self.regionLinkingMode = regionLinkingMode
            self.regions = regions
        }

        public func validate(name: String) throws {
            try self.validate(self.findingAggregatorArn, name: "findingAggregatorArn", parent: name, pattern: "\\S")
            try self.validate(self.regionLinkingMode, name: "regionLinkingMode", parent: name, pattern: "\\S")
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregatorArn = "FindingAggregatorArn"
            case regionLinkingMode = "RegionLinkingMode"
            case regions = "Regions"
        }
    }

    public struct UpdateFindingAggregatorResponse: AWSDecodableShape {
        /// The home Region. Findings generated in linked Regions are replicated and sent to the home Region.
        public let findingAggregationRegion: String?
        /// The ARN of the finding aggregator.
        public let findingAggregatorArn: String?
        /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
        public let regionLinkingMode: String?
        /// The list of excluded Regions or included Regions.
        public let regions: [String]?

        @inlinable
        public init(findingAggregationRegion: String? = nil, findingAggregatorArn: String? = nil, regionLinkingMode: String? = nil, regions: [String]? = nil) {
            self.findingAggregationRegion = findingAggregationRegion
            self.findingAggregatorArn = findingAggregatorArn
            self.regionLinkingMode = regionLinkingMode
            self.regions = regions
        }

        private enum CodingKeys: String, CodingKey {
            case findingAggregationRegion = "FindingAggregationRegion"
            case findingAggregatorArn = "FindingAggregatorArn"
            case regionLinkingMode = "RegionLinkingMode"
            case regions = "Regions"
        }
    }

    public struct UpdateFindingsRequest: AWSEncodableShape {
        /// A collection of attributes that specify which findings you want to update.
        public let filters: AwsSecurityFindingFilters?
        /// The updated note for the finding.
        public let note: NoteUpdate?
        /// The updated record state for the finding.
        public let recordState: RecordState?

        @inlinable
        public init(filters: AwsSecurityFindingFilters? = nil, note: NoteUpdate? = nil, recordState: RecordState? = nil) {
            self.filters = filters
            self.note = note
            self.recordState = recordState
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.note?.validate(name: "\(name).note")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case note = "Note"
            case recordState = "RecordState"
        }
    }

    public struct UpdateFindingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateInsightRequest: AWSEncodableShape {
        /// The updated filters that define this insight.
        public let filters: AwsSecurityFindingFilters?
        /// The updated GroupBy attribute that defines this insight.
        public let groupByAttribute: String?
        /// The ARN of the insight that you want to update.
        public let insightArn: String
        /// The updated name for the insight.
        public let name: String?

        @inlinable
        public init(filters: AwsSecurityFindingFilters? = nil, groupByAttribute: String? = nil, insightArn: String, name: String? = nil) {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.groupByAttribute, forKey: .groupByAttribute)
            request.encodePath(self.insightArn, key: "InsightArn")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.groupByAttribute, name: "groupByAttribute", parent: name, pattern: "\\S")
            try self.validate(self.insightArn, name: "insightArn", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case groupByAttribute = "GroupByAttribute"
            case name = "Name"
        }
    }

    public struct UpdateInsightResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateOrganizationConfigurationRequest: AWSEncodableShape {
        /// Whether to automatically enable Security Hub in new member accounts when they join the organization. If set to true, then Security Hub is automatically enabled in new accounts. If set to false, then Security Hub isn't enabled in new accounts automatically. The default value is false. If the ConfigurationType of your organization is set to CENTRAL, then this field is set  to false and can't be changed in the home Region and linked Regions. However, in that case, the delegated administrator can create a configuration  policy in which Security Hub is enabled and associate the policy with new organization accounts.
        public let autoEnable: Bool?
        /// Whether to automatically enable Security Hub default standards  in new member accounts when they join the organization. The default value of this parameter is equal to DEFAULT. If equal to DEFAULT, then Security Hub default standards are automatically enabled for new member  accounts. If equal to NONE, then default standards are not automatically enabled for new member  accounts. If the ConfigurationType of your organization is set to CENTRAL, then this field is set  to NONE and can't be changed in the home Region and linked Regions. However, in that case, the delegated administrator can create a configuration  policy in which specific security standards are enabled and associate the policy with new organization accounts.
        public let autoEnableStandards: AutoEnableStandards?
        public let organizationConfiguration: OrganizationConfiguration?

        @inlinable
        public init(autoEnable: Bool? = nil, autoEnableStandards: AutoEnableStandards? = nil, organizationConfiguration: OrganizationConfiguration? = nil) {
            self.autoEnable = autoEnable
            self.autoEnableStandards = autoEnableStandards
            self.organizationConfiguration = organizationConfiguration
        }

        public func validate(name: String) throws {
            try self.organizationConfiguration?.validate(name: "\(name).organizationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable = "AutoEnable"
            case autoEnableStandards = "AutoEnableStandards"
            case organizationConfiguration = "OrganizationConfiguration"
        }
    }

    public struct UpdateOrganizationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateSecurityControlRequest: AWSEncodableShape {
        ///  The most recent reason for updating the properties of the security control. This field accepts alphanumeric
        /// characters in addition to white spaces, dashes, and underscores.
        public let lastUpdateReason: String?
        ///  An object that specifies which security control parameters to update.
        public let parameters: [String: ParameterConfiguration]?
        ///  The Amazon Resource Name (ARN) or ID of the control to update.
        public let securityControlId: String?

        @inlinable
        public init(lastUpdateReason: String? = nil, parameters: [String: ParameterConfiguration]? = nil, securityControlId: String? = nil) {
            self.lastUpdateReason = lastUpdateReason
            self.parameters = parameters
            self.securityControlId = securityControlId
        }

        public func validate(name: String) throws {
            try self.validate(self.lastUpdateReason, name: "lastUpdateReason", parent: name, pattern: "^([^\\u0000-\\u007F]|[-_ a-zA-Z0-9])+$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, pattern: "\\S")
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.securityControlId, name: "securityControlId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case lastUpdateReason = "LastUpdateReason"
            case parameters = "Parameters"
            case securityControlId = "SecurityControlId"
        }
    }

    public struct UpdateSecurityControlResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateSecurityHubConfigurationRequest: AWSEncodableShape {
        /// Whether to automatically enable new controls when they are added to standards that are enabled. By default, this is set to true, and new controls are enabled automatically. To not automatically enable new controls, set this to false.  When you automatically enable new controls, you can interact with the controls in  the console and programmatically immediately after release. However, automatically enabled controls have a temporary default status of  DISABLED. It can take up to several days for Security Hub to process the control release and designate the  control as ENABLED in your account. During the processing period, you can manually enable or disable a  control, and Security Hub will maintain that designation regardless of whether you have AutoEnableControls set to  true.
        public let autoEnableControls: Bool?
        /// Updates whether the calling account has consolidated control findings turned on.  If the value for this field is set to  SECURITY_CONTROL, Security Hub generates a single finding for a control check even when the check  applies to multiple enabled standards. If the value for this field is set to STANDARD_CONTROL, Security Hub generates separate findings  for a control check when the check applies to multiple enabled standards. For accounts that are part of an organization, this value can only be updated in the administrator account.
        public let controlFindingGenerator: ControlFindingGenerator?

        @inlinable
        public init(autoEnableControls: Bool? = nil, controlFindingGenerator: ControlFindingGenerator? = nil) {
            self.autoEnableControls = autoEnableControls
            self.controlFindingGenerator = controlFindingGenerator
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnableControls = "AutoEnableControls"
            case controlFindingGenerator = "ControlFindingGenerator"
        }
    }

    public struct UpdateSecurityHubConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateStandardsControlRequest: AWSEncodableShape {
        /// The updated status of the security standard control.
        public let controlStatus: ControlStatus?
        /// A description of the reason why you are disabling a security standard control. If you are disabling a control, then this is required.
        public let disabledReason: String?
        /// The ARN of the security standard control to enable or disable.
        public let standardsControlArn: String

        @inlinable
        public init(controlStatus: ControlStatus? = nil, disabledReason: String? = nil, standardsControlArn: String) {
            self.controlStatus = controlStatus
            self.disabledReason = disabledReason
            self.standardsControlArn = standardsControlArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.controlStatus, forKey: .controlStatus)
            try container.encodeIfPresent(self.disabledReason, forKey: .disabledReason)
            request.encodePath(self.standardsControlArn, key: "StandardsControlArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.disabledReason, name: "disabledReason", parent: name, pattern: "\\S")
            try self.validate(self.standardsControlArn, name: "standardsControlArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case controlStatus = "ControlStatus"
            case disabledReason = "DisabledReason"
        }
    }

    public struct UpdateStandardsControlResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserAccount: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the user account involved in the attack sequence.
        public let name: String?
        ///  The unique identifier of the user account involved in the attack sequence.
        public let uid: String?

        @inlinable
        public init(name: String? = nil, uid: String? = nil) {
            self.name = name
            self.uid = uid
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.uid, name: "uid", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case uid = "Uid"
        }
    }

    public struct VolumeMount: AWSEncodableShape & AWSDecodableShape {
        /// The path in the container at which the volume should be mounted.
        public let mountPath: String?
        /// The name of the volume.
        public let name: String?

        @inlinable
        public init(mountPath: String? = nil, name: String? = nil) {
            self.mountPath = mountPath
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.mountPath, name: "mountPath", parent: name, pattern: "\\S")
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case mountPath = "MountPath"
            case name = "Name"
        }
    }

    public struct VpcInfoCidrBlockSetDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IPv4 CIDR block for the VPC.
        public let cidrBlock: String?

        @inlinable
        public init(cidrBlock: String? = nil) {
            self.cidrBlock = cidrBlock
        }

        public func validate(name: String) throws {
            try self.validate(self.cidrBlock, name: "cidrBlock", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cidrBlock = "CidrBlock"
        }
    }

    public struct VpcInfoIpv6CidrBlockSetDetails: AWSEncodableShape & AWSDecodableShape {
        /// The IPv6 CIDR block for the VPC.
        public let ipv6CidrBlock: String?

        @inlinable
        public init(ipv6CidrBlock: String? = nil) {
            self.ipv6CidrBlock = ipv6CidrBlock
        }

        public func validate(name: String) throws {
            try self.validate(self.ipv6CidrBlock, name: "ipv6CidrBlock", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ipv6CidrBlock = "Ipv6CidrBlock"
        }
    }

    public struct VpcInfoPeeringOptionsDetails: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.
        public let allowDnsResolutionFromRemoteVpc: Bool?
        /// Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.
        public let allowEgressFromLocalClassicLinkToRemoteVpc: Bool?
        /// Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.
        public let allowEgressFromLocalVpcToRemoteClassicLink: Bool?

        @inlinable
        public init(allowDnsResolutionFromRemoteVpc: Bool? = nil, allowEgressFromLocalClassicLinkToRemoteVpc: Bool? = nil, allowEgressFromLocalVpcToRemoteClassicLink: Bool? = nil) {
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
        }

        private enum CodingKeys: String, CodingKey {
            case allowDnsResolutionFromRemoteVpc = "AllowDnsResolutionFromRemoteVpc"
            case allowEgressFromLocalClassicLinkToRemoteVpc = "AllowEgressFromLocalClassicLinkToRemoteVpc"
            case allowEgressFromLocalVpcToRemoteClassicLink = "AllowEgressFromLocalVpcToRemoteClassicLink"
        }
    }

    public struct Vulnerability: AWSEncodableShape & AWSDecodableShape {
        /// The vulnerabilities found in your Lambda function code. This field pertains to findings that
        /// Security Hub receives from Amazon Inspector.
        public let codeVulnerabilities: [VulnerabilityCodeVulnerabilities]?
        /// CVSS scores from the advisory related to the vulnerability.
        public let cvss: [Cvss]?
        /// The Exploit Prediction Scoring System (EPSS) score for a finding.
        ///
        public let epssScore: Double?
        /// Whether an exploit is available for a finding.
        ///
        public let exploitAvailable: VulnerabilityExploitAvailable?
        /// Specifies if all vulnerable packages in a finding have a value for FixedInVersion
        /// and Remediation.
        /// This field is evaluated for each vulnerability Id based on the number of vulnerable packages that have a value for both
        /// FixedInVersion and Remediation. Valid values are as follows:    YES if all vulnerable packages have a value for both FixedInVersion and Remediation     NO if no vulnerable packages have a value for FixedInVersion and Remediation     PARTIAL otherwise
        public let fixAvailable: VulnerabilityFixAvailable?
        /// The identifier of the vulnerability.
        public let id: String?
        ///  The date and time of the last exploit associated with a finding discovered in your environment.
        public let lastKnownExploitAt: String?
        /// A list of URLs that provide additional information about the vulnerability.
        public let referenceUrls: [String]?
        /// List of vulnerabilities that are related to this vulnerability.
        public let relatedVulnerabilities: [String]?
        /// Information about the vendor that generates the vulnerability report.
        public let vendor: VulnerabilityVendor?
        /// List of software packages that have the vulnerability.
        public let vulnerablePackages: [SoftwarePackage]?

        @inlinable
        public init(codeVulnerabilities: [VulnerabilityCodeVulnerabilities]? = nil, cvss: [Cvss]? = nil, epssScore: Double? = nil, exploitAvailable: VulnerabilityExploitAvailable? = nil, fixAvailable: VulnerabilityFixAvailable? = nil, id: String? = nil, lastKnownExploitAt: String? = nil, referenceUrls: [String]? = nil, relatedVulnerabilities: [String]? = nil, vendor: VulnerabilityVendor? = nil, vulnerablePackages: [SoftwarePackage]? = nil) {
            self.codeVulnerabilities = codeVulnerabilities
            self.cvss = cvss
            self.epssScore = epssScore
            self.exploitAvailable = exploitAvailable
            self.fixAvailable = fixAvailable
            self.id = id
            self.lastKnownExploitAt = lastKnownExploitAt
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.vendor = vendor
            self.vulnerablePackages = vulnerablePackages
        }

        public func validate(name: String) throws {
            try self.codeVulnerabilities?.forEach {
                try $0.validate(name: "\(name).codeVulnerabilities[]")
            }
            try self.cvss?.forEach {
                try $0.validate(name: "\(name).cvss[]")
            }
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S")
            try self.validate(self.lastKnownExploitAt, name: "lastKnownExploitAt", parent: name, pattern: "\\S")
            try self.referenceUrls?.forEach {
                try validate($0, name: "referenceUrls[]", parent: name, pattern: "\\S")
            }
            try self.relatedVulnerabilities?.forEach {
                try validate($0, name: "relatedVulnerabilities[]", parent: name, pattern: "\\S")
            }
            try self.vendor?.validate(name: "\(name).vendor")
            try self.vulnerablePackages?.forEach {
                try $0.validate(name: "\(name).vulnerablePackages[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case codeVulnerabilities = "CodeVulnerabilities"
            case cvss = "Cvss"
            case epssScore = "EpssScore"
            case exploitAvailable = "ExploitAvailable"
            case fixAvailable = "FixAvailable"
            case id = "Id"
            case lastKnownExploitAt = "LastKnownExploitAt"
            case referenceUrls = "ReferenceUrls"
            case relatedVulnerabilities = "RelatedVulnerabilities"
            case vendor = "Vendor"
            case vulnerablePackages = "VulnerablePackages"
        }
    }

    public struct VulnerabilityCodeVulnerabilities: AWSEncodableShape & AWSDecodableShape {
        ///  The Common Weakness Enumeration (CWE) item associated with the detected code vulnerability.
        public let cwes: [String]?
        ///  Provides details about where a code vulnerability is located in your Lambda function.
        public let filePath: CodeVulnerabilitiesFilePath?
        ///  The Amazon Resource Name (ARN) of the Lambda layer in which the code vulnerability is located.
        public let sourceArn: String?

        @inlinable
        public init(cwes: [String]? = nil, filePath: CodeVulnerabilitiesFilePath? = nil, sourceArn: String? = nil) {
            self.cwes = cwes
            self.filePath = filePath
            self.sourceArn = sourceArn
        }

        public func validate(name: String) throws {
            try self.cwes?.forEach {
                try validate($0, name: "cwes[]", parent: name, pattern: "\\S")
            }
            try self.filePath?.validate(name: "\(name).filePath")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case cwes = "Cwes"
            case filePath = "FilePath"
            case sourceArn = "SourceArn"
        }
    }

    public struct VulnerabilityVendor: AWSEncodableShape & AWSDecodableShape {
        /// The name of the vendor.
        public let name: String?
        /// The URL of the vulnerability advisory.
        public let url: String?
        /// Indicates when the vulnerability advisory was created. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let vendorCreatedAt: String?
        /// The severity that the vendor assigned to the vulnerability.
        public let vendorSeverity: String?
        /// Indicates when the vulnerability advisory was last updated. For more information about the validation and formatting of timestamp fields in Security Hub, see Timestamps.
        public let vendorUpdatedAt: String?

        @inlinable
        public init(name: String? = nil, url: String? = nil, vendorCreatedAt: String? = nil, vendorSeverity: String? = nil, vendorUpdatedAt: String? = nil) {
            self.name = name
            self.url = url
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.url, name: "url", parent: name, pattern: "\\S")
            try self.validate(self.vendorCreatedAt, name: "vendorCreatedAt", parent: name, pattern: "\\S")
            try self.validate(self.vendorSeverity, name: "vendorSeverity", parent: name, pattern: "\\S")
            try self.validate(self.vendorUpdatedAt, name: "vendorUpdatedAt", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case url = "Url"
            case vendorCreatedAt = "VendorCreatedAt"
            case vendorSeverity = "VendorSeverity"
            case vendorUpdatedAt = "VendorUpdatedAt"
        }
    }

    public struct WafAction: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how you want WAF to respond to requests that match the settings in a rule. Valid settings include the following:    ALLOW - WAF allows requests    BLOCK - WAF blocks requests    COUNT - WAF increments a counter of the requests that match all of the conditions in the rule. WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify COUNT for the default action for a web ACL.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct WafExcludedRule: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the rule to exclude from the rule group.
        public let ruleId: String?

        @inlinable
        public init(ruleId: String? = nil) {
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleId, name: "ruleId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case ruleId = "RuleId"
        }
    }

    public struct WafOverrideAction: AWSEncodableShape & AWSDecodableShape {
        ///  COUNT overrides the action specified by the individual rule within a RuleGroup . If set to NONE, the rule's action takes place.
        public let type: String?

        @inlinable
        public init(type: String? = nil) {
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.type, name: "type", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct Workflow: AWSEncodableShape & AWSDecodableShape {
        /// The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to SUPPRESSED or RESOLVED does not prevent a new finding for the same issue. The allowed values are the following.    NEW - The initial state of a finding, before it is reviewed. Security Hub also resets the workflow status from NOTIFIED or RESOLVED to NEW in the following cases:    RecordState changes from ARCHIVED to ACTIVE.    ComplianceStatus changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.      NOTIFIED - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.    SUPPRESSED - Indicates that you reviewed the finding and don't believe that any action is needed. The finding is no longer updated.    RESOLVED - The finding was reviewed and remediated and is now considered resolved.
        public let status: WorkflowStatus?

        @inlinable
        public init(status: WorkflowStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct WorkflowUpdate: AWSEncodableShape & AWSDecodableShape {
        /// The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to SUPPRESSED or RESOLVED does not prevent a new finding for the same issue. The allowed values are the following.    NEW - The initial state of a finding, before it is reviewed. Security Hub also resets WorkFlowStatus from NOTIFIED or RESOLVED to NEW in the following cases:   The record state changes from ARCHIVED to ACTIVE.   The compliance status changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.      NOTIFIED - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.    RESOLVED - The finding was reviewed and remediated and is now considered resolved.    SUPPRESSED - Indicates that you reviewed the finding and don't believe that any action is needed. The finding is no longer updated.
        public let status: WorkflowStatus?

        @inlinable
        public init(status: WorkflowStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct Policy: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Web Services service that the configuration policy applies to.
        public let securityHub: SecurityHubPolicy?

        @inlinable
        public init(securityHub: SecurityHubPolicy? = nil) {
            self.securityHub = securityHub
        }

        public func validate(name: String) throws {
            try self.securityHub?.validate(name: "\(name).securityHub")
        }

        private enum CodingKeys: String, CodingKey {
            case securityHub = "SecurityHub"
        }
    }
}

// MARK: - Errors

/// Error enum for SecurityHub
public struct SecurityHubErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalException = "InternalException"
        case invalidAccessException = "InvalidAccessException"
        case invalidInputException = "InvalidInputException"
        case limitExceededException = "LimitExceededException"
        case resourceConflictException = "ResourceConflictException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SecurityHub
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have permission to perform the action specified in the request.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Internal server error.
    public static var internalException: Self { .init(.internalException) }
    /// The account doesn't have permission to perform this action.
    public static var invalidAccessException: Self { .init(.invalidAccessException) }
    /// The request was rejected because you supplied an invalid or out-of-range value for an input parameter.
    public static var invalidInputException: Self { .init(.invalidInputException) }
    /// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account or throttling limits. The error code describes the limit exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The resource specified in the request conflicts with an existing resource.
    public static var resourceConflictException: Self { .init(.resourceConflictException) }
    ///  The request was rejected because it conflicts with the resource's availability. For example, you tried  to update a security control that's currently in the UPDATING state.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// The request was rejected because we can't find the specified resource.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
}

extension SecurityHubErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": SecurityHub.AccessDeniedException.self,
        "InternalException": SecurityHub.InternalException.self,
        "InvalidAccessException": SecurityHub.InvalidAccessException.self,
        "InvalidInputException": SecurityHub.InvalidInputException.self,
        "LimitExceededException": SecurityHub.LimitExceededException.self,
        "ResourceConflictException": SecurityHub.ResourceConflictException.self,
        "ResourceInUseException": SecurityHub.ResourceInUseException.self,
        "ResourceNotFoundException": SecurityHub.ResourceNotFoundException.self
    ]
}

extension SecurityHubErrorType: Equatable {
    public static func == (lhs: SecurityHubErrorType, rhs: SecurityHubErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SecurityHubErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
